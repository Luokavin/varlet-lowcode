;(function () {
  var style = document.createElement('style')
  style.type = 'text/css'
  style.rel = 'stylesheet'
  style.appendChild(
    document.createTextNode(`.var--box,.var--box *{box-sizing:border-box}.var--relative{position:relative}.var--absolute{position:absolute}.var--hidden,.var--lock{overflow:hidden}.var--box,.var--box *{box-sizing:border-box}.var--relative{position:relative}.var--absolute{position:absolute}.var--hidden,.var--lock{overflow:hidden}.var--block{display:block}.var--ellipsis{overflow-x:hidden;text-overflow:ellipsis;white-space:nowrap}.var--inline-block{display:inline-block}.var--flex{display:flex}.var--inline-flex{display:inline-flex}:root{--font-size-xs: 10px;--font-size-sm: 12px;--font-size-md: 14px;--font-size-lg: 16px;--icon-size-xs: 16px;--icon-size-sm: 18px;--icon-size-md: 20px;--icon-size-lg: 22px;--color-body: #fff;--color-text: #333;--color-primary: #3a7afe;--color-info: #00afef;--color-success: #00c48f;--color-warning: #ff9f00;--color-danger: #f44336;--color-disabled: #e0e0e0;--color-text-disabled: #aaa;--cubic-bezier: cubic-bezier(.25, .8, .5, 1);--shadow-key-umbra-opacity: rgba(0, 0, 0, .2);--shadow-key-penumbra-opacity: rgba(0, 0, 0, .14);--shadow-key-ambient-opacity: rgba(0, 0, 0, .12)}.var-elevation--0{box-shadow:0 0 0 0 var(--shadow-key-umbra-opacity),0 0 0 0 var(--shadow-key-penumbra-opacity),0 0 0 0 var(--shadow-key-ambient-opacity)}.var-elevation--1{box-shadow:0 2px 1px -1px var(--shadow-key-umbra-opacity),0 1px 1px 0 var(--shadow-key-penumbra-opacity),0 1px 3px 0 var(--shadow-key-ambient-opacity)}.var-elevation--2{box-shadow:0 3px 1px -2px var(--shadow-key-umbra-opacity),0 2px 2px 0 var(--shadow-key-penumbra-opacity),0 1px 5px 0 var(--shadow-key-ambient-opacity)}.var-elevation--3{box-shadow:0 3px 3px -2px var(--shadow-key-umbra-opacity),0 3px 4px 0 var(--shadow-key-penumbra-opacity),0 1px 8px 0 var(--shadow-key-ambient-opacity)}.var-elevation--4{box-shadow:0 2px 4px -1px var(--shadow-key-umbra-opacity),0 4px 5px 0 var(--shadow-key-penumbra-opacity),0 1px 10px 0 var(--shadow-key-ambient-opacity)}.var-elevation--5{box-shadow:0 3px 5px -1px var(--shadow-key-umbra-opacity),0 5px 8px 0 var(--shadow-key-penumbra-opacity),0 1px 14px 0 var(--shadow-key-ambient-opacity)}.var-elevation--6{box-shadow:0 3px 5px -1px var(--shadow-key-umbra-opacity),0 6px 10px 0 var(--shadow-key-penumbra-opacity),0 1px 18px 0 var(--shadow-key-ambient-opacity)}.var-elevation--7{box-shadow:0 4px 5px -2px var(--shadow-key-umbra-opacity),0 7px 10px 1px var(--shadow-key-penumbra-opacity),0 2px 16px 1px var(--shadow-key-ambient-opacity)}.var-elevation--8{box-shadow:0 5px 5px -3px var(--shadow-key-umbra-opacity),0 8px 10px 1px var(--shadow-key-penumbra-opacity),0 3px 14px 2px var(--shadow-key-ambient-opacity)}.var-elevation--9{box-shadow:0 5px 6px -3px var(--shadow-key-umbra-opacity),0 9px 12px 1px var(--shadow-key-penumbra-opacity),0 3px 16px 2px var(--shadow-key-ambient-opacity)}.var-elevation--10{box-shadow:0 6px 6px -3px var(--shadow-key-umbra-opacity),0 10px 14px 1px var(--shadow-key-penumbra-opacity),0 4px 18px 3px var(--shadow-key-ambient-opacity)}.var-elevation--11{box-shadow:0 6px 7px -4px var(--shadow-key-umbra-opacity),0 11px 15px 1px var(--shadow-key-penumbra-opacity),0 4px 20px 3px var(--shadow-key-ambient-opacity)}.var-elevation--12{box-shadow:0 7px 8px -4px var(--shadow-key-umbra-opacity),0 12px 17px 2px var(--shadow-key-penumbra-opacity),0 5px 22px 4px var(--shadow-key-ambient-opacity)}.var-elevation--13{box-shadow:0 7px 8px -4px var(--shadow-key-umbra-opacity),0 13px 19px 2px var(--shadow-key-penumbra-opacity),0 5px 24px 4px var(--shadow-key-ambient-opacity)}.var-elevation--14{box-shadow:0 7px 9px -4px var(--shadow-key-umbra-opacity),0 14px 21px 2px var(--shadow-key-penumbra-opacity),0 5px 26px 4px var(--shadow-key-ambient-opacity)}.var-elevation--15{box-shadow:0 8px 9px -5px var(--shadow-key-umbra-opacity),0 15px 22px 2px var(--shadow-key-penumbra-opacity),0 6px 28px 5px var(--shadow-key-ambient-opacity)}.var-elevation--16{box-shadow:0 8px 10px -5px var(--shadow-key-umbra-opacity),0 16px 24px 2px var(--shadow-key-penumbra-opacity),0 6px 30px 5px var(--shadow-key-ambient-opacity)}.var-elevation--17{box-shadow:0 8px 11px -5px var(--shadow-key-umbra-opacity),0 17px 26px 2px var(--shadow-key-penumbra-opacity),0 6px 32px 5px var(--shadow-key-ambient-opacity)}.var-elevation--18{box-shadow:0 9px 11px -5px var(--shadow-key-umbra-opacity),0 18px 28px 2px var(--shadow-key-penumbra-opacity),0 7px 34px 6px var(--shadow-key-ambient-opacity)}.var-elevation--19{box-shadow:0 9px 12px -6px var(--shadow-key-umbra-opacity),0 19px 29px 2px var(--shadow-key-penumbra-opacity),0 7px 36px 6px var(--shadow-key-ambient-opacity)}.var-elevation--20{box-shadow:0 10px 13px -6px var(--shadow-key-umbra-opacity),0 20px 31px 3px var(--shadow-key-penumbra-opacity),0 8px 38px 7px var(--shadow-key-ambient-opacity)}.var-elevation--21{box-shadow:0 10px 13px -6px var(--shadow-key-umbra-opacity),0 21px 33px 3px var(--shadow-key-penumbra-opacity),0 8px 40px 7px var(--shadow-key-ambient-opacity)}.var-elevation--22{box-shadow:0 10px 14px -6px var(--shadow-key-umbra-opacity),0 22px 35px 3px var(--shadow-key-penumbra-opacity),0 8px 42px 7px var(--shadow-key-ambient-opacity)}.var-elevation--23{box-shadow:0 11px 14px -7px var(--shadow-key-umbra-opacity),0 23px 36px 3px var(--shadow-key-penumbra-opacity),0 9px 44px 8px var(--shadow-key-ambient-opacity)}.var-elevation--24{box-shadow:0 11px 15px -7px var(--shadow-key-umbra-opacity),0 24px 38px 3px var(--shadow-key-penumbra-opacity),0 9px 46px 8px var(--shadow-key-ambient-opacity)}:root{--ripple-cubic-bezier: cubic-bezier(.68, .01, .62, .6);--ripple-color: currentColor}.var-ripple{position:absolute;transition:transform .2s var(--ripple-cubic-bezier),opacity .14s linear;top:0;left:0;border-radius:50%;opacity:0;will-change:transform,opacity;pointer-events:none;z-index:100;background-color:var(--ripple-color)}:root{--loading-opacity: .38;--loading-desc-margin: 8px 0 0}.var-loading{position:relative}.var-loading__content{position:relative;transition:opacity .3s;opacity:1}.var-loading__content--active{opacity:var(--loading-opacity)}.var-loading__content-mask{position:absolute;left:0;right:0;top:0;bottom:0}.var-loading__body{display:flex;justify-content:center;align-items:center;height:100%;flex-direction:column}.var-loading__inside{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);z-index:1}.var-loading__description{color:currentColor;margin:var(--loading-desc-margin)}.var-loading__description--large{font-size:16px}.var-loading__description--normal{font-size:14px}.var-loading__description--small{font-size:12px}.var-loading__description--mini{font-size:10px}.var-loading__circle{display:flex}.var-loading__circle-block{display:inline-block;animation:circle 1.8s linear infinite}.var-loading__circle-block--large{width:36px;height:36px}.var-loading__circle-block--normal{width:30px;height:30px}.var-loading__circle-block--small{width:24px;height:24px}.var-loading__circle-block--mini{width:18px;height:18px}.var-loading__circle-block svg{display:block;width:100%;height:100%}.var-loading__circle-block svg circle{animation:circular 1.5s ease-in-out infinite;stroke:currentColor;stroke-width:3;stroke-linecap:round}@keyframes circle{0%{transform:rotate(0)}to{transform:rotate(360deg)}}@keyframes circular{0%{stroke-dasharray:1,200;stroke-dashoffset:0}50%{stroke-dasharray:90,150;stroke-dashoffset:-40}to{stroke-dasharray:90,150;stroke-dashoffset:-120}}.var-loading__wave{display:flex;align-items:center;justify-content:center}.var-loading__wave--large{width:64px;height:18px}.var-loading__wave--normal{width:50px;height:16px}.var-loading__wave--small{width:36px;height:14px}.var-loading__wave--mini{width:22px;height:12px}.var-loading__wave-item{height:100%;display:inline-block;animation:1.2s ease-in-out infinite wave}.var-loading__wave-item:nth-child(1){animation-delay:-1.2s;margin-left:0}.var-loading__wave-item:nth-child(2){animation-delay:-1.1s}.var-loading__wave-item:nth-child(3){animation-delay:-1s}.var-loading__wave-item:nth-child(4){animation-delay:-.9s}.var-loading__wave-item:nth-child(5){animation-delay:-.8s}.var-loading__wave-item--large{width:5px;margin-left:5px}.var-loading__wave-item--normal{width:4px;margin-left:4px}.var-loading__wave-item--small{width:3px;margin-left:3px}.var-loading__wave-item--mini{width:2px;margin-left:2px}@keyframes wave{0%,40%,to{transform:scaleY(.4)}20%{transform:scaleY(1)}}.var-loading__cube{display:flex;align-items:center}.var-loading__cube--large{width:64px;height:18px}.var-loading__cube--normal{width:50px;height:16px}.var-loading__cube--small{width:36px;height:14px}.var-loading__cube--mini{width:22px;height:12px}.var-loading__cube-item{display:inline-block;transform-origin:right bottom;animation:1.5s ease infinite cube}.var-loading__cube-item:nth-child(1){animation-delay:.2s;margin-left:0}.var-loading__cube-item:nth-child(2){animation-delay:.4s}.var-loading__cube-item:nth-child(3){animation-delay:.6s}.var-loading__cube-item:nth-child(4){animation-delay:.8s}.var-loading__cube-item--large{height:10px;width:10px;margin-left:5px}.var-loading__cube-item--normal{height:8px;width:8px;margin-left:4px}.var-loading__cube-item--small{height:6px;width:6px;margin-left:3px}.var-loading__cube-item--mini{height:4px;width:4px;margin-left:2px}@keyframes cube{0%{opacity:1;transform:scale(1)}to{opacity:0;transform:rotate(90deg) scale(.3)}}.var-loading__rect{display:flex;flex-wrap:nowrap;justify-content:center;align-items:center}.var-loading__rect--large{width:64px;height:18px}.var-loading__rect--normal{width:50px;height:16px}.var-loading__rect--small{width:36px;height:14px}.var-loading__rect--mini{width:22px;height:12px}.var-loading__rect-item{animation:2s ease-in-out infinite rect}.var-loading__rect-item:nth-child(1){animation-delay:1.75s}.var-loading__rect-item:nth-child(2){animation-delay:1.5s}.var-loading__rect-item:nth-child(3){animation-delay:1.25s}.var-loading__rect-item:nth-child(4){animation-delay:1s}.var-loading__rect-item:nth-child(5){animation-delay:.75s}.var-loading__rect-item:nth-child(6){animation-delay:.5s}.var-loading__rect-item:nth-child(7){animation-delay:.25s}.var-loading__rect-item:nth-child(8){animation-delay:0s}.var-loading__rect-item--large{height:100%;width:8px}.var-loading__rect-item--normal{height:90%;width:6.4px}.var-loading__rect-item--small{height:80%;width:4.8px}.var-loading__rect-item--mini{height:70%;width:3.2px}@keyframes rect{0%{opacity:.3}25%{opacity:1}50%{opacity:.3}65%{opacity:1}to{opacity:.3}}.var-loading__disappear{display:flex;justify-content:space-around;align-items:center;flex-flow:nowrap}.var-loading__disappear--large{width:64px;height:18px}.var-loading__disappear--normal{width:50px;height:16px}.var-loading__disappear--small{width:36px;height:14px}.var-loading__disappear--mini{width:22px;height:12px}.var-loading__disappear-item{border-radius:50%;animation:.5s ease-in-out infinite alternate disappear}.var-loading__disappear-item:nth-child(1){animation-delay:-.4s}.var-loading__disappear-item:nth-child(2){animation-delay:-.2s}.var-loading__disappear-item:nth-child(3){animation-delay:0s}.var-loading__disappear-item--large{height:15px;width:15px}.var-loading__disappear-item--normal{height:12px;width:12px}.var-loading__disappear-item--small{height:9px;width:9px}.var-loading__disappear-item--mini{height:6px;width:6px}@keyframes disappear{0%{opacity:1}to{opacity:0}}:root{--button-default-color: #f5f5f5;--button-primary-color: var(--color-primary);--button-danger-color: var(--color-danger);--button-success-color: var(--color-success);--button-warning-color: var(--color-warning);--button-info-color: var(--color-info);--button-disabled-color: var(--color-disabled);--button-disabled-text-color: var(--color-text-disabled);--button-border-radius: 4px;--button-mini-padding: 0 9px;--button-small-padding: 0 11px;--button-normal-padding: 0 15px;--button-large-padding: 0 22px;--button-round-padding: 6px;--button-mini-height: 20px;--button-small-height: 28px;--button-normal-height: 36px;--button-large-height: 44px}.var-button{position:relative;justify-content:center;align-items:center;outline:none;border:none;border-radius:var(--button-border-radius);user-select:none;cursor:pointer;font-family:inherit;transition:box-shadow .2s,background-color .25s;will-change:box-shadow;-webkit-tap-highlight-color:rgba(0,0,0,0);white-space:nowrap;line-height:1}.var-button:active{box-shadow:0 3px 5px -1px var(--shadow-key-umbra-opacity),0 5px 8px 0 var(--shadow-key-penumbra-opacity),0 1px 14px 0 var(--shadow-key-ambient-opacity)}.var-button__loading[var-button-cover]{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%)}.var-button--default{color:inherit;background-color:var(--button-default-color)}.var-button--primary{color:#fff;background-color:var(--button-primary-color)}.var-button--info{color:#fff;background-color:var(--button-info-color)}.var-button--success{color:#fff;background-color:var(--button-success-color)}.var-button--warning{color:#fff;background-color:var(--button-warning-color)}.var-button--danger{color:#fff;background-color:var(--button-danger-color)}.var-button--disabled{background-color:var(--button-disabled-color);color:var(--button-disabled-text-color);cursor:not-allowed;box-shadow:none!important}.var-button--block{width:100%}.var-button--text{background-color:transparent}.var-button--text:active{box-shadow:none}.var-button--text-default{color:inherit}.var-button--text-primary{color:var(--button-primary-color)}.var-button--text-info{color:var(--button-info-color)}.var-button--text-success{color:var(--button-success-color)}.var-button--text-warning{color:var(--button-warning-color)}.var-button--text-danger{color:var(--button-danger-color)}.var-button--text-disabled{color:var(--button-disabled-text-color)}.var-button--normal{height:var(--button-normal-height);padding:var(--button-normal-padding);font-size:var(--font-size-md)}.var-button--large{height:var(--button-large-height);padding:var(--button-large-padding);font-size:var(--font-size-lg)}.var-button--small{height:var(--button-small-height);padding:var(--button-small-padding);font-size:var(--font-size-sm)}.var-button--mini{height:var(--button-mini-height);padding:var(--button-mini-padding);font-size:var(--font-size-xs)}.var-button--round{padding:var(--button-round-padding);border-radius:50%;height:auto}.var-button--outline{border:thin solid currentColor}.var-button--hidden{opacity:0}
`)
  )
  var head = document.querySelector('head')
  head.appendChild(style)
})()
;(function (pi, l) {
  typeof exports == 'object' && typeof module != 'undefined'
    ? l(exports, require('vue'), require('@varlet/lowcode-core'))
    : typeof define == 'function' && define.amd
    ? define(['exports', 'vue', '@varlet/lowcode-core'], l)
    : ((pi = typeof globalThis != 'undefined' ? globalThis : pi || self),
      l((pi.VarletLowcodeCodegen = {}), pi.Vue, pi.VarletLowcodeCore))
})(this, function (pi, l, pr) {
  'use strict'
  var TS = `<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" href="/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite Varlet Low Code Starter</title>
  </head>
  <body>
    <div id="app"></div>

    <script src="https://cdn.jsdelivr.net/npm/vue"><\/script>
    <script type="module" src="/src/main.js"><\/script>
  </body>
</html>
`,
    bS = `{
  "name": "vite-varlet-low-code-starter",
  "version": "0.0.0",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "serve": "vite preview"
  },
  "dependencies": {
    "vue": "latest"
  },
  "devDependencies": {
    "@vitejs/plugin-vue": "latest",
    "vite-plugin-externals": "latest",
    "@vue/compiler-sfc": "latest",
    "vite": "latest"
  }
}
`,
    SS = `import vue from '@vitejs/plugin-vue'
import { viteExternalsPlugin } from 'vite-plugin-externals'
import { defineConfig } from 'vite'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [vue(), viteExternalsPlugin()],
})
`,
    vS = `# Vite Varlet Low Code Starter

This is a project template using [Vite](https://vitejs.dev/). It requires [Node.js](https://nodejs.org) v12+.

To start:

\`\`\`sh
npm install
npm run dev

# if using yarn:
yarn
yarn dev
\`\`\`
`,
    jt =
      typeof globalThis != 'undefined'
        ? globalThis
        : typeof window != 'undefined'
        ? window
        : typeof global != 'undefined'
        ? global
        : typeof self != 'undefined'
        ? self
        : {}
  function ES(t) {
    return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, 'default') ? t.default : t
  }
  function PS(t) {
    if (t.__esModule) return t
    var e = Object.defineProperty({}, '__esModule', { value: !0 })
    return (
      Object.keys(t).forEach(function (r) {
        var i = Object.getOwnPropertyDescriptor(t, r)
        Object.defineProperty(
          e,
          r,
          i.get
            ? i
            : {
                enumerable: !0,
                get: function () {
                  return t[r]
                },
              }
        )
      }),
      e
    )
  }
  function da(t) {
    throw new Error(
      'Could not dynamically require "' +
        t +
        '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.'
    )
  }
  var ss = {},
    Tn = {},
    rt = {},
    st = {},
    ma = {},
    ya = {},
    ga = {},
    $ = {},
    as = {}
  Object.defineProperty(as, '__esModule', { value: !0 }), (as.default = wS)
  function wS(t, e) {
    const r = Object.keys(e)
    for (const i of r) if (t[i] !== e[i]) return !1
    return !0
  }
  Object.defineProperty($, '__esModule', { value: !0 }),
    ($.isAccessor = $w),
    ($.isAnyTypeAnnotation = n1),
    ($.isArgumentPlaceholder = BE),
    ($.isArrayExpression = AS),
    ($.isArrayPattern = Pv),
    ($.isArrayTypeAnnotation = s1),
    ($.isArrowFunctionExpression = wv),
    ($.isAssignmentExpression = CS),
    ($.isAssignmentPattern = Ev),
    ($.isAwaitExpression = Yv),
    ($.isBigIntLiteral = qv),
    ($.isBinary = sw),
    ($.isBinaryExpression = xS),
    ($.isBindExpression = LE),
    ($.isBlock = lw),
    ($.isBlockParent = ow),
    ($.isBlockStatement = OS),
    ($.isBooleanLiteral = ZS),
    ($.isBooleanLiteralTypeAnnotation = o1),
    ($.isBooleanTypeAnnotation = a1),
    ($.isBreakStatement = DS),
    ($.isCallExpression = BS),
    ($.isCatchClause = LS),
    ($.isClass = Bw),
    ($.isClassAccessorProperty = Qv),
    ($.isClassBody = Av),
    ($.isClassDeclaration = xv),
    ($.isClassExpression = Cv),
    ($.isClassImplements = u1),
    ($.isClassMethod = Rv),
    ($.isClassPrivateMethod = t1),
    ($.isClassPrivateProperty = e1),
    ($.isClassProperty = Zv),
    ($.isCompletionStatement = pw),
    ($.isConditional = fw),
    ($.isConditionalExpression = MS),
    ($.isContinueStatement = FS),
    ($.isDebuggerStatement = $S),
    ($.isDecimalLiteral = VE),
    ($.isDeclaration = vw),
    ($.isDeclareClass = c1),
    ($.isDeclareExportAllDeclaration = b1),
    ($.isDeclareExportDeclaration = T1),
    ($.isDeclareFunction = p1),
    ($.isDeclareInterface = f1),
    ($.isDeclareModule = h1),
    ($.isDeclareModuleExports = d1),
    ($.isDeclareOpaqueType = y1),
    ($.isDeclareTypeAlias = m1),
    ($.isDeclareVariable = g1),
    ($.isDeclaredPredicate = S1),
    ($.isDecorator = FE),
    ($.isDirective = kS),
    ($.isDirectiveLiteral = NS),
    ($.isDoExpression = $E),
    ($.isDoWhileStatement = RS),
    ($.isEmptyStatement = jS),
    ($.isEmptyTypeAnnotation = O1),
    ($.isEnumBody = Kw),
    ($.isEnumBooleanBody = sE),
    ($.isEnumBooleanMember = uE),
    ($.isEnumDeclaration = nE),
    ($.isEnumDefaultedMember = fE),
    ($.isEnumMember = Ww),
    ($.isEnumNumberBody = aE),
    ($.isEnumNumberMember = cE),
    ($.isEnumStringBody = oE),
    ($.isEnumStringMember = pE),
    ($.isEnumSymbolBody = lE),
    ($.isExistsTypeAnnotation = v1),
    ($.isExportAllDeclaration = Iv),
    ($.isExportDeclaration = Mw),
    ($.isExportDefaultDeclaration = kv),
    ($.isExportDefaultSpecifier = RE),
    ($.isExportNamedDeclaration = Nv),
    ($.isExportNamespaceSpecifier = Xv),
    ($.isExportSpecifier = Ov),
    ($.isExpression = nw),
    ($.isExpressionStatement = _S),
    ($.isExpressionWrapper = mw),
    ($.isFile = VS),
    ($.isFlow = jw),
    ($.isFlowBaseAnnotation = Vw),
    ($.isFlowDeclaration = Uw),
    ($.isFlowPredicate = zw),
    ($.isFlowType = _w),
    ($.isFor = yw),
    ($.isForInStatement = US),
    ($.isForOfStatement = Dv),
    ($.isForStatement = zS),
    ($.isForXStatement = gw),
    ($.isFunction = Tw),
    ($.isFunctionDeclaration = KS),
    ($.isFunctionExpression = WS),
    ($.isFunctionParent = bw),
    ($.isFunctionTypeAnnotation = E1),
    ($.isFunctionTypeParam = P1),
    ($.isGenericTypeAnnotation = w1),
    ($.isIdentifier = YS),
    ($.isIfStatement = HS),
    ($.isImmutable = Cw),
    ($.isImport = Hv),
    ($.isImportAttribute = ME),
    ($.isImportDeclaration = Bv),
    ($.isImportDefaultSpecifier = Lv),
    ($.isImportNamespaceSpecifier = Mv),
    ($.isImportSpecifier = Fv),
    ($.isIndexedAccessType = hE),
    ($.isInferredPredicate = A1),
    ($.isInterfaceDeclaration = x1),
    ($.isInterfaceExtends = C1),
    ($.isInterfaceTypeAnnotation = I1),
    ($.isInterpreterDirective = IS),
    ($.isIntersectionTypeAnnotation = k1),
    ($.isJSX = Yw),
    ($.isJSXAttribute = mE),
    ($.isJSXClosingElement = yE),
    ($.isJSXClosingFragment = kE),
    ($.isJSXElement = gE),
    ($.isJSXEmptyExpression = TE),
    ($.isJSXExpressionContainer = bE),
    ($.isJSXFragment = xE),
    ($.isJSXIdentifier = vE),
    ($.isJSXMemberExpression = EE),
    ($.isJSXNamespacedName = PE),
    ($.isJSXOpeningElement = wE),
    ($.isJSXOpeningFragment = IE),
    ($.isJSXSpreadAttribute = AE),
    ($.isJSXSpreadChild = SE),
    ($.isJSXText = CE),
    ($.isLVal = Pw),
    ($.isLabeledStatement = qS),
    ($.isLiteral = Aw),
    ($.isLogicalExpression = ev),
    ($.isLoop = hw),
    ($.isMemberExpression = tv),
    ($.isMetaProperty = $v),
    ($.isMethod = Iw),
    ($.isMiscellaneous = Hw),
    ($.isMixedTypeAnnotation = N1),
    ($.isModuleDeclaration = Lw),
    ($.isModuleExpression = UE),
    ($.isModuleSpecifier = Fw),
    ($.isNewExpression = rv),
    ($.isNoop = NE),
    ($.isNullLiteral = JS),
    ($.isNullLiteralTypeAnnotation = l1),
    ($.isNullableTypeAnnotation = D1),
    ($.isNumberLiteral = Zw),
    ($.isNumberLiteralTypeAnnotation = B1),
    ($.isNumberTypeAnnotation = L1),
    ($.isNumericLiteral = GS),
    ($.isObjectExpression = nv),
    ($.isObjectMember = kw),
    ($.isObjectMethod = sv),
    ($.isObjectPattern = jv),
    ($.isObjectProperty = av),
    ($.isObjectTypeAnnotation = M1),
    ($.isObjectTypeCallProperty = $1),
    ($.isObjectTypeIndexer = R1),
    ($.isObjectTypeInternalSlot = F1),
    ($.isObjectTypeProperty = j1),
    ($.isObjectTypeSpreadProperty = _1),
    ($.isOpaqueType = V1),
    ($.isOptionalCallExpression = Jv),
    ($.isOptionalIndexedAccessType = dE),
    ($.isOptionalMemberExpression = Gv),
    ($.isParenthesizedExpression = cv),
    ($.isPattern = Dw),
    ($.isPatternLike = Ew),
    ($.isPipelineBareFunction = WE),
    ($.isPipelinePrimaryTopicReference = YE),
    ($.isPipelineTopicExpression = KE),
    ($.isPlaceholder = OE),
    ($.isPrivate = Rw),
    ($.isPrivateName = r1),
    ($.isProgram = iv),
    ($.isProperty = Nw),
    ($.isPureish = Sw),
    ($.isQualifiedTypeIdentifier = U1),
    ($.isRecordExpression = jE),
    ($.isRegExpLiteral = QS),
    ($.isRegexLiteral = Qw),
    ($.isRestElement = ov),
    ($.isRestProperty = eA),
    ($.isReturnStatement = lv),
    ($.isScopable = aw),
    ($.isSequenceExpression = uv),
    ($.isSpreadElement = _v),
    ($.isSpreadProperty = tA),
    ($.isStandardized = iw),
    ($.isStatement = uw),
    ($.isStaticBlock = i1),
    ($.isStringLiteral = XS),
    ($.isStringLiteralTypeAnnotation = z1),
    ($.isStringTypeAnnotation = K1),
    ($.isSuper = Vv),
    ($.isSwitchCase = pv),
    ($.isSwitchStatement = fv),
    ($.isSymbolTypeAnnotation = W1),
    ($.isTSAnyKeyword = rP),
    ($.isTSArrayType = EP),
    ($.isTSAsExpression = VP),
    ($.isTSBaseType = Jw),
    ($.isTSBigIntKeyword = nP),
    ($.isTSBooleanKeyword = iP),
    ($.isTSCallSignatureDeclaration = JE),
    ($.isTSConditionalType = kP),
    ($.isTSConstructSignatureDeclaration = ZE),
    ($.isTSConstructorType = gP),
    ($.isTSDeclareFunction = qE),
    ($.isTSDeclareMethod = XE),
    ($.isTSEntityName = ww),
    ($.isTSEnumDeclaration = zP),
    ($.isTSEnumMember = KP),
    ($.isTSExportAssignment = JP),
    ($.isTSExpressionWithTypeArguments = FP),
    ($.isTSExternalModuleReference = XP),
    ($.isTSFunctionType = yP),
    ($.isTSImportEqualsDeclaration = qP),
    ($.isTSImportType = HP),
    ($.isTSIndexSignature = tP),
    ($.isTSIndexedAccessType = BP),
    ($.isTSInferType = NP),
    ($.isTSInstantiationExpression = _P),
    ($.isTSInterfaceBody = RP),
    ($.isTSInterfaceDeclaration = $P),
    ($.isTSIntersectionType = IP),
    ($.isTSIntrinsicKeyword = sP),
    ($.isTSLiteralType = MP),
    ($.isTSMappedType = LP),
    ($.isTSMethodSignature = eP),
    ($.isTSModuleBlock = YP),
    ($.isTSModuleDeclaration = WP),
    ($.isTSNamedTupleMember = CP),
    ($.isTSNamespaceExportDeclaration = ZP),
    ($.isTSNeverKeyword = aP),
    ($.isTSNonNullExpression = GP),
    ($.isTSNullKeyword = oP),
    ($.isTSNumberKeyword = lP),
    ($.isTSObjectKeyword = uP),
    ($.isTSOptionalType = wP),
    ($.isTSParameterProperty = HE),
    ($.isTSParenthesizedType = OP),
    ($.isTSPropertySignature = QE),
    ($.isTSQualifiedName = GE),
    ($.isTSRestType = AP),
    ($.isTSStringKeyword = cP),
    ($.isTSSymbolKeyword = pP),
    ($.isTSThisType = mP),
    ($.isTSTupleType = PP),
    ($.isTSType = Gw),
    ($.isTSTypeAliasDeclaration = jP),
    ($.isTSTypeAnnotation = QP),
    ($.isTSTypeAssertion = UP),
    ($.isTSTypeElement = Xw),
    ($.isTSTypeLiteral = vP),
    ($.isTSTypeOperator = DP),
    ($.isTSTypeParameter = rw),
    ($.isTSTypeParameterDeclaration = tw),
    ($.isTSTypeParameterInstantiation = ew),
    ($.isTSTypePredicate = bP),
    ($.isTSTypeQuery = SP),
    ($.isTSTypeReference = TP),
    ($.isTSUndefinedKeyword = fP),
    ($.isTSUnionType = xP),
    ($.isTSUnknownKeyword = hP),
    ($.isTSVoidKeyword = dP),
    ($.isTaggedTemplateExpression = Uv),
    ($.isTemplateElement = zv),
    ($.isTemplateLiteral = Kv),
    ($.isTerminatorless = cw),
    ($.isThisExpression = hv),
    ($.isThisTypeAnnotation = Y1),
    ($.isThrowStatement = dv),
    ($.isTopicReference = zE),
    ($.isTryStatement = mv),
    ($.isTupleExpression = _E),
    ($.isTupleTypeAnnotation = H1),
    ($.isTypeAlias = X1),
    ($.isTypeAnnotation = G1),
    ($.isTypeCastExpression = J1),
    ($.isTypeParameter = Z1),
    ($.isTypeParameterDeclaration = Q1),
    ($.isTypeParameterInstantiation = eE),
    ($.isTypeScript = qw),
    ($.isTypeofTypeAnnotation = q1),
    ($.isUnaryExpression = yv),
    ($.isUnaryLike = Ow),
    ($.isUnionTypeAnnotation = tE),
    ($.isUpdateExpression = gv),
    ($.isUserWhitespacable = xw),
    ($.isV8IntrinsicIdentifier = DE),
    ($.isVariableDeclaration = Tv),
    ($.isVariableDeclarator = bv),
    ($.isVariance = rE),
    ($.isVoidTypeAnnotation = iE),
    ($.isWhile = dw),
    ($.isWhileStatement = Sv),
    ($.isWithStatement = vv),
    ($.isYieldExpression = Wv)
  var _ = as
  function AS(t, e) {
    return t && t.type === 'ArrayExpression' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function CS(t, e) {
    return t && t.type === 'AssignmentExpression' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function xS(t, e) {
    return t && t.type === 'BinaryExpression' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function IS(t, e) {
    return t && t.type === 'InterpreterDirective' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function kS(t, e) {
    return t && t.type === 'Directive' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function NS(t, e) {
    return t && t.type === 'DirectiveLiteral' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function OS(t, e) {
    return t && t.type === 'BlockStatement' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function DS(t, e) {
    return t && t.type === 'BreakStatement' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function BS(t, e) {
    return t && t.type === 'CallExpression' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function LS(t, e) {
    return t && t.type === 'CatchClause' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function MS(t, e) {
    return t && t.type === 'ConditionalExpression' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function FS(t, e) {
    return t && t.type === 'ContinueStatement' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function $S(t, e) {
    return t && t.type === 'DebuggerStatement' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function RS(t, e) {
    return t && t.type === 'DoWhileStatement' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function jS(t, e) {
    return t && t.type === 'EmptyStatement' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function _S(t, e) {
    return t && t.type === 'ExpressionStatement' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function VS(t, e) {
    return t && t.type === 'File' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function US(t, e) {
    return t && t.type === 'ForInStatement' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function zS(t, e) {
    return t && t.type === 'ForStatement' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function KS(t, e) {
    return t && t.type === 'FunctionDeclaration' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function WS(t, e) {
    return t && t.type === 'FunctionExpression' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function YS(t, e) {
    return t && t.type === 'Identifier' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function HS(t, e) {
    return t && t.type === 'IfStatement' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function qS(t, e) {
    return t && t.type === 'LabeledStatement' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function XS(t, e) {
    return t && t.type === 'StringLiteral' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function GS(t, e) {
    return t && t.type === 'NumericLiteral' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function JS(t, e) {
    return t && t.type === 'NullLiteral' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function ZS(t, e) {
    return t && t.type === 'BooleanLiteral' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function QS(t, e) {
    return t && t.type === 'RegExpLiteral' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function ev(t, e) {
    return t && t.type === 'LogicalExpression' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function tv(t, e) {
    return t && t.type === 'MemberExpression' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function rv(t, e) {
    return t && t.type === 'NewExpression' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function iv(t, e) {
    return t && t.type === 'Program' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function nv(t, e) {
    return t && t.type === 'ObjectExpression' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function sv(t, e) {
    return t && t.type === 'ObjectMethod' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function av(t, e) {
    return t && t.type === 'ObjectProperty' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function ov(t, e) {
    return t && t.type === 'RestElement' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function lv(t, e) {
    return t && t.type === 'ReturnStatement' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function uv(t, e) {
    return t && t.type === 'SequenceExpression' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function cv(t, e) {
    return t && t.type === 'ParenthesizedExpression' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function pv(t, e) {
    return t && t.type === 'SwitchCase' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function fv(t, e) {
    return t && t.type === 'SwitchStatement' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function hv(t, e) {
    return t && t.type === 'ThisExpression' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function dv(t, e) {
    return t && t.type === 'ThrowStatement' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function mv(t, e) {
    return t && t.type === 'TryStatement' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function yv(t, e) {
    return t && t.type === 'UnaryExpression' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function gv(t, e) {
    return t && t.type === 'UpdateExpression' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function Tv(t, e) {
    return t && t.type === 'VariableDeclaration' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function bv(t, e) {
    return t && t.type === 'VariableDeclarator' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function Sv(t, e) {
    return t && t.type === 'WhileStatement' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function vv(t, e) {
    return t && t.type === 'WithStatement' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function Ev(t, e) {
    return t && t.type === 'AssignmentPattern' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function Pv(t, e) {
    return t && t.type === 'ArrayPattern' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function wv(t, e) {
    return t && t.type === 'ArrowFunctionExpression' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function Av(t, e) {
    return t && t.type === 'ClassBody' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function Cv(t, e) {
    return t && t.type === 'ClassExpression' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function xv(t, e) {
    return t && t.type === 'ClassDeclaration' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function Iv(t, e) {
    return t && t.type === 'ExportAllDeclaration' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function kv(t, e) {
    return t && t.type === 'ExportDefaultDeclaration' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function Nv(t, e) {
    return t && t.type === 'ExportNamedDeclaration' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function Ov(t, e) {
    return t && t.type === 'ExportSpecifier' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function Dv(t, e) {
    return t && t.type === 'ForOfStatement' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function Bv(t, e) {
    return t && t.type === 'ImportDeclaration' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function Lv(t, e) {
    return t && t.type === 'ImportDefaultSpecifier' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function Mv(t, e) {
    return t && t.type === 'ImportNamespaceSpecifier' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function Fv(t, e) {
    return t && t.type === 'ImportSpecifier' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function $v(t, e) {
    return t && t.type === 'MetaProperty' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function Rv(t, e) {
    return t && t.type === 'ClassMethod' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function jv(t, e) {
    return t && t.type === 'ObjectPattern' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function _v(t, e) {
    return t && t.type === 'SpreadElement' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function Vv(t, e) {
    return t && t.type === 'Super' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function Uv(t, e) {
    return t && t.type === 'TaggedTemplateExpression' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function zv(t, e) {
    return t && t.type === 'TemplateElement' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function Kv(t, e) {
    return t && t.type === 'TemplateLiteral' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function Wv(t, e) {
    return t && t.type === 'YieldExpression' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function Yv(t, e) {
    return t && t.type === 'AwaitExpression' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function Hv(t, e) {
    return t && t.type === 'Import' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function qv(t, e) {
    return t && t.type === 'BigIntLiteral' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function Xv(t, e) {
    return t && t.type === 'ExportNamespaceSpecifier' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function Gv(t, e) {
    return t && t.type === 'OptionalMemberExpression' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function Jv(t, e) {
    return t && t.type === 'OptionalCallExpression' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function Zv(t, e) {
    return t && t.type === 'ClassProperty' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function Qv(t, e) {
    return t && t.type === 'ClassAccessorProperty' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function e1(t, e) {
    return t && t.type === 'ClassPrivateProperty' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function t1(t, e) {
    return t && t.type === 'ClassPrivateMethod' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function r1(t, e) {
    return t && t.type === 'PrivateName' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function i1(t, e) {
    return t && t.type === 'StaticBlock' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function n1(t, e) {
    return t && t.type === 'AnyTypeAnnotation' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function s1(t, e) {
    return t && t.type === 'ArrayTypeAnnotation' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function a1(t, e) {
    return t && t.type === 'BooleanTypeAnnotation' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function o1(t, e) {
    return t && t.type === 'BooleanLiteralTypeAnnotation' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function l1(t, e) {
    return t && t.type === 'NullLiteralTypeAnnotation' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function u1(t, e) {
    return t && t.type === 'ClassImplements' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function c1(t, e) {
    return t && t.type === 'DeclareClass' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function p1(t, e) {
    return t && t.type === 'DeclareFunction' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function f1(t, e) {
    return t && t.type === 'DeclareInterface' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function h1(t, e) {
    return t && t.type === 'DeclareModule' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function d1(t, e) {
    return t && t.type === 'DeclareModuleExports' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function m1(t, e) {
    return t && t.type === 'DeclareTypeAlias' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function y1(t, e) {
    return t && t.type === 'DeclareOpaqueType' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function g1(t, e) {
    return t && t.type === 'DeclareVariable' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function T1(t, e) {
    return t && t.type === 'DeclareExportDeclaration' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function b1(t, e) {
    return t && t.type === 'DeclareExportAllDeclaration' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function S1(t, e) {
    return t && t.type === 'DeclaredPredicate' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function v1(t, e) {
    return t && t.type === 'ExistsTypeAnnotation' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function E1(t, e) {
    return t && t.type === 'FunctionTypeAnnotation' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function P1(t, e) {
    return t && t.type === 'FunctionTypeParam' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function w1(t, e) {
    return t && t.type === 'GenericTypeAnnotation' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function A1(t, e) {
    return t && t.type === 'InferredPredicate' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function C1(t, e) {
    return t && t.type === 'InterfaceExtends' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function x1(t, e) {
    return t && t.type === 'InterfaceDeclaration' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function I1(t, e) {
    return t && t.type === 'InterfaceTypeAnnotation' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function k1(t, e) {
    return t && t.type === 'IntersectionTypeAnnotation' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function N1(t, e) {
    return t && t.type === 'MixedTypeAnnotation' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function O1(t, e) {
    return t && t.type === 'EmptyTypeAnnotation' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function D1(t, e) {
    return t && t.type === 'NullableTypeAnnotation' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function B1(t, e) {
    return t && t.type === 'NumberLiteralTypeAnnotation' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function L1(t, e) {
    return t && t.type === 'NumberTypeAnnotation' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function M1(t, e) {
    return t && t.type === 'ObjectTypeAnnotation' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function F1(t, e) {
    return t && t.type === 'ObjectTypeInternalSlot' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function $1(t, e) {
    return t && t.type === 'ObjectTypeCallProperty' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function R1(t, e) {
    return t && t.type === 'ObjectTypeIndexer' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function j1(t, e) {
    return t && t.type === 'ObjectTypeProperty' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function _1(t, e) {
    return t && t.type === 'ObjectTypeSpreadProperty' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function V1(t, e) {
    return t && t.type === 'OpaqueType' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function U1(t, e) {
    return t && t.type === 'QualifiedTypeIdentifier' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function z1(t, e) {
    return t && t.type === 'StringLiteralTypeAnnotation' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function K1(t, e) {
    return t && t.type === 'StringTypeAnnotation' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function W1(t, e) {
    return t && t.type === 'SymbolTypeAnnotation' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function Y1(t, e) {
    return t && t.type === 'ThisTypeAnnotation' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function H1(t, e) {
    return t && t.type === 'TupleTypeAnnotation' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function q1(t, e) {
    return t && t.type === 'TypeofTypeAnnotation' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function X1(t, e) {
    return t && t.type === 'TypeAlias' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function G1(t, e) {
    return t && t.type === 'TypeAnnotation' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function J1(t, e) {
    return t && t.type === 'TypeCastExpression' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function Z1(t, e) {
    return t && t.type === 'TypeParameter' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function Q1(t, e) {
    return t && t.type === 'TypeParameterDeclaration' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function eE(t, e) {
    return t && t.type === 'TypeParameterInstantiation' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function tE(t, e) {
    return t && t.type === 'UnionTypeAnnotation' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function rE(t, e) {
    return t && t.type === 'Variance' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function iE(t, e) {
    return t && t.type === 'VoidTypeAnnotation' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function nE(t, e) {
    return t && t.type === 'EnumDeclaration' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function sE(t, e) {
    return t && t.type === 'EnumBooleanBody' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function aE(t, e) {
    return t && t.type === 'EnumNumberBody' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function oE(t, e) {
    return t && t.type === 'EnumStringBody' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function lE(t, e) {
    return t && t.type === 'EnumSymbolBody' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function uE(t, e) {
    return t && t.type === 'EnumBooleanMember' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function cE(t, e) {
    return t && t.type === 'EnumNumberMember' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function pE(t, e) {
    return t && t.type === 'EnumStringMember' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function fE(t, e) {
    return t && t.type === 'EnumDefaultedMember' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function hE(t, e) {
    return t && t.type === 'IndexedAccessType' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function dE(t, e) {
    return t && t.type === 'OptionalIndexedAccessType' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function mE(t, e) {
    return t && t.type === 'JSXAttribute' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function yE(t, e) {
    return t && t.type === 'JSXClosingElement' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function gE(t, e) {
    return t && t.type === 'JSXElement' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function TE(t, e) {
    return t && t.type === 'JSXEmptyExpression' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function bE(t, e) {
    return t && t.type === 'JSXExpressionContainer' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function SE(t, e) {
    return t && t.type === 'JSXSpreadChild' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function vE(t, e) {
    return t && t.type === 'JSXIdentifier' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function EE(t, e) {
    return t && t.type === 'JSXMemberExpression' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function PE(t, e) {
    return t && t.type === 'JSXNamespacedName' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function wE(t, e) {
    return t && t.type === 'JSXOpeningElement' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function AE(t, e) {
    return t && t.type === 'JSXSpreadAttribute' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function CE(t, e) {
    return t && t.type === 'JSXText' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function xE(t, e) {
    return t && t.type === 'JSXFragment' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function IE(t, e) {
    return t && t.type === 'JSXOpeningFragment' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function kE(t, e) {
    return t && t.type === 'JSXClosingFragment' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function NE(t, e) {
    return t && t.type === 'Noop' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function OE(t, e) {
    return t && t.type === 'Placeholder' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function DE(t, e) {
    return t && t.type === 'V8IntrinsicIdentifier' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function BE(t, e) {
    return t && t.type === 'ArgumentPlaceholder' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function LE(t, e) {
    return t && t.type === 'BindExpression' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function ME(t, e) {
    return t && t.type === 'ImportAttribute' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function FE(t, e) {
    return t && t.type === 'Decorator' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function $E(t, e) {
    return t && t.type === 'DoExpression' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function RE(t, e) {
    return t && t.type === 'ExportDefaultSpecifier' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function jE(t, e) {
    return t && t.type === 'RecordExpression' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function _E(t, e) {
    return t && t.type === 'TupleExpression' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function VE(t, e) {
    return t && t.type === 'DecimalLiteral' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function UE(t, e) {
    return t && t.type === 'ModuleExpression' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function zE(t, e) {
    return t && t.type === 'TopicReference' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function KE(t, e) {
    return t && t.type === 'PipelineTopicExpression' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function WE(t, e) {
    return t && t.type === 'PipelineBareFunction' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function YE(t, e) {
    return t && t.type === 'PipelinePrimaryTopicReference' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function HE(t, e) {
    return t && t.type === 'TSParameterProperty' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function qE(t, e) {
    return t && t.type === 'TSDeclareFunction' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function XE(t, e) {
    return t && t.type === 'TSDeclareMethod' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function GE(t, e) {
    return t && t.type === 'TSQualifiedName' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function JE(t, e) {
    return t && t.type === 'TSCallSignatureDeclaration' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function ZE(t, e) {
    return t && t.type === 'TSConstructSignatureDeclaration'
      ? typeof e == 'undefined'
        ? !0
        : (0, _.default)(t, e)
      : !1
  }
  function QE(t, e) {
    return t && t.type === 'TSPropertySignature' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function eP(t, e) {
    return t && t.type === 'TSMethodSignature' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function tP(t, e) {
    return t && t.type === 'TSIndexSignature' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function rP(t, e) {
    return t && t.type === 'TSAnyKeyword' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function iP(t, e) {
    return t && t.type === 'TSBooleanKeyword' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function nP(t, e) {
    return t && t.type === 'TSBigIntKeyword' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function sP(t, e) {
    return t && t.type === 'TSIntrinsicKeyword' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function aP(t, e) {
    return t && t.type === 'TSNeverKeyword' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function oP(t, e) {
    return t && t.type === 'TSNullKeyword' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function lP(t, e) {
    return t && t.type === 'TSNumberKeyword' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function uP(t, e) {
    return t && t.type === 'TSObjectKeyword' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function cP(t, e) {
    return t && t.type === 'TSStringKeyword' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function pP(t, e) {
    return t && t.type === 'TSSymbolKeyword' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function fP(t, e) {
    return t && t.type === 'TSUndefinedKeyword' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function hP(t, e) {
    return t && t.type === 'TSUnknownKeyword' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function dP(t, e) {
    return t && t.type === 'TSVoidKeyword' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function mP(t, e) {
    return t && t.type === 'TSThisType' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function yP(t, e) {
    return t && t.type === 'TSFunctionType' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function gP(t, e) {
    return t && t.type === 'TSConstructorType' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function TP(t, e) {
    return t && t.type === 'TSTypeReference' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function bP(t, e) {
    return t && t.type === 'TSTypePredicate' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function SP(t, e) {
    return t && t.type === 'TSTypeQuery' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function vP(t, e) {
    return t && t.type === 'TSTypeLiteral' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function EP(t, e) {
    return t && t.type === 'TSArrayType' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function PP(t, e) {
    return t && t.type === 'TSTupleType' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function wP(t, e) {
    return t && t.type === 'TSOptionalType' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function AP(t, e) {
    return t && t.type === 'TSRestType' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function CP(t, e) {
    return t && t.type === 'TSNamedTupleMember' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function xP(t, e) {
    return t && t.type === 'TSUnionType' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function IP(t, e) {
    return t && t.type === 'TSIntersectionType' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function kP(t, e) {
    return t && t.type === 'TSConditionalType' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function NP(t, e) {
    return t && t.type === 'TSInferType' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function OP(t, e) {
    return t && t.type === 'TSParenthesizedType' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function DP(t, e) {
    return t && t.type === 'TSTypeOperator' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function BP(t, e) {
    return t && t.type === 'TSIndexedAccessType' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function LP(t, e) {
    return t && t.type === 'TSMappedType' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function MP(t, e) {
    return t && t.type === 'TSLiteralType' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function FP(t, e) {
    return t && t.type === 'TSExpressionWithTypeArguments' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function $P(t, e) {
    return t && t.type === 'TSInterfaceDeclaration' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function RP(t, e) {
    return t && t.type === 'TSInterfaceBody' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function jP(t, e) {
    return t && t.type === 'TSTypeAliasDeclaration' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function _P(t, e) {
    return t && t.type === 'TSInstantiationExpression' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function VP(t, e) {
    return t && t.type === 'TSAsExpression' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function UP(t, e) {
    return t && t.type === 'TSTypeAssertion' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function zP(t, e) {
    return t && t.type === 'TSEnumDeclaration' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function KP(t, e) {
    return t && t.type === 'TSEnumMember' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function WP(t, e) {
    return t && t.type === 'TSModuleDeclaration' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function YP(t, e) {
    return t && t.type === 'TSModuleBlock' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function HP(t, e) {
    return t && t.type === 'TSImportType' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function qP(t, e) {
    return t && t.type === 'TSImportEqualsDeclaration' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function XP(t, e) {
    return t && t.type === 'TSExternalModuleReference' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function GP(t, e) {
    return t && t.type === 'TSNonNullExpression' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function JP(t, e) {
    return t && t.type === 'TSExportAssignment' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function ZP(t, e) {
    return t && t.type === 'TSNamespaceExportDeclaration' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function QP(t, e) {
    return t && t.type === 'TSTypeAnnotation' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function ew(t, e) {
    return t && t.type === 'TSTypeParameterInstantiation' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function tw(t, e) {
    return t && t.type === 'TSTypeParameterDeclaration' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function rw(t, e) {
    return t && t.type === 'TSTypeParameter' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function iw(t, e) {
    if (!t) return !1
    const r = t.type
    return r === 'ArrayExpression' ||
      r === 'AssignmentExpression' ||
      r === 'BinaryExpression' ||
      r === 'InterpreterDirective' ||
      r === 'Directive' ||
      r === 'DirectiveLiteral' ||
      r === 'BlockStatement' ||
      r === 'BreakStatement' ||
      r === 'CallExpression' ||
      r === 'CatchClause' ||
      r === 'ConditionalExpression' ||
      r === 'ContinueStatement' ||
      r === 'DebuggerStatement' ||
      r === 'DoWhileStatement' ||
      r === 'EmptyStatement' ||
      r === 'ExpressionStatement' ||
      r === 'File' ||
      r === 'ForInStatement' ||
      r === 'ForStatement' ||
      r === 'FunctionDeclaration' ||
      r === 'FunctionExpression' ||
      r === 'Identifier' ||
      r === 'IfStatement' ||
      r === 'LabeledStatement' ||
      r === 'StringLiteral' ||
      r === 'NumericLiteral' ||
      r === 'NullLiteral' ||
      r === 'BooleanLiteral' ||
      r === 'RegExpLiteral' ||
      r === 'LogicalExpression' ||
      r === 'MemberExpression' ||
      r === 'NewExpression' ||
      r === 'Program' ||
      r === 'ObjectExpression' ||
      r === 'ObjectMethod' ||
      r === 'ObjectProperty' ||
      r === 'RestElement' ||
      r === 'ReturnStatement' ||
      r === 'SequenceExpression' ||
      r === 'ParenthesizedExpression' ||
      r === 'SwitchCase' ||
      r === 'SwitchStatement' ||
      r === 'ThisExpression' ||
      r === 'ThrowStatement' ||
      r === 'TryStatement' ||
      r === 'UnaryExpression' ||
      r === 'UpdateExpression' ||
      r === 'VariableDeclaration' ||
      r === 'VariableDeclarator' ||
      r === 'WhileStatement' ||
      r === 'WithStatement' ||
      r === 'AssignmentPattern' ||
      r === 'ArrayPattern' ||
      r === 'ArrowFunctionExpression' ||
      r === 'ClassBody' ||
      r === 'ClassExpression' ||
      r === 'ClassDeclaration' ||
      r === 'ExportAllDeclaration' ||
      r === 'ExportDefaultDeclaration' ||
      r === 'ExportNamedDeclaration' ||
      r === 'ExportSpecifier' ||
      r === 'ForOfStatement' ||
      r === 'ImportDeclaration' ||
      r === 'ImportDefaultSpecifier' ||
      r === 'ImportNamespaceSpecifier' ||
      r === 'ImportSpecifier' ||
      r === 'MetaProperty' ||
      r === 'ClassMethod' ||
      r === 'ObjectPattern' ||
      r === 'SpreadElement' ||
      r === 'Super' ||
      r === 'TaggedTemplateExpression' ||
      r === 'TemplateElement' ||
      r === 'TemplateLiteral' ||
      r === 'YieldExpression' ||
      r === 'AwaitExpression' ||
      r === 'Import' ||
      r === 'BigIntLiteral' ||
      r === 'ExportNamespaceSpecifier' ||
      r === 'OptionalMemberExpression' ||
      r === 'OptionalCallExpression' ||
      r === 'ClassProperty' ||
      r === 'ClassAccessorProperty' ||
      r === 'ClassPrivateProperty' ||
      r === 'ClassPrivateMethod' ||
      r === 'PrivateName' ||
      r === 'StaticBlock' ||
      (r === 'Placeholder' &&
        (t.expectedNode === 'Identifier' ||
          t.expectedNode === 'StringLiteral' ||
          t.expectedNode === 'BlockStatement' ||
          t.expectedNode === 'ClassBody'))
      ? typeof e == 'undefined'
        ? !0
        : (0, _.default)(t, e)
      : !1
  }
  function nw(t, e) {
    if (!t) return !1
    const r = t.type
    return r === 'ArrayExpression' ||
      r === 'AssignmentExpression' ||
      r === 'BinaryExpression' ||
      r === 'CallExpression' ||
      r === 'ConditionalExpression' ||
      r === 'FunctionExpression' ||
      r === 'Identifier' ||
      r === 'StringLiteral' ||
      r === 'NumericLiteral' ||
      r === 'NullLiteral' ||
      r === 'BooleanLiteral' ||
      r === 'RegExpLiteral' ||
      r === 'LogicalExpression' ||
      r === 'MemberExpression' ||
      r === 'NewExpression' ||
      r === 'ObjectExpression' ||
      r === 'SequenceExpression' ||
      r === 'ParenthesizedExpression' ||
      r === 'ThisExpression' ||
      r === 'UnaryExpression' ||
      r === 'UpdateExpression' ||
      r === 'ArrowFunctionExpression' ||
      r === 'ClassExpression' ||
      r === 'MetaProperty' ||
      r === 'Super' ||
      r === 'TaggedTemplateExpression' ||
      r === 'TemplateLiteral' ||
      r === 'YieldExpression' ||
      r === 'AwaitExpression' ||
      r === 'Import' ||
      r === 'BigIntLiteral' ||
      r === 'OptionalMemberExpression' ||
      r === 'OptionalCallExpression' ||
      r === 'TypeCastExpression' ||
      r === 'JSXElement' ||
      r === 'JSXFragment' ||
      r === 'BindExpression' ||
      r === 'DoExpression' ||
      r === 'RecordExpression' ||
      r === 'TupleExpression' ||
      r === 'DecimalLiteral' ||
      r === 'ModuleExpression' ||
      r === 'TopicReference' ||
      r === 'PipelineTopicExpression' ||
      r === 'PipelineBareFunction' ||
      r === 'PipelinePrimaryTopicReference' ||
      r === 'TSInstantiationExpression' ||
      r === 'TSAsExpression' ||
      r === 'TSTypeAssertion' ||
      r === 'TSNonNullExpression' ||
      (r === 'Placeholder' &&
        (t.expectedNode === 'Expression' || t.expectedNode === 'Identifier' || t.expectedNode === 'StringLiteral'))
      ? typeof e == 'undefined'
        ? !0
        : (0, _.default)(t, e)
      : !1
  }
  function sw(t, e) {
    if (!t) return !1
    const r = t.type
    return r === 'BinaryExpression' || r === 'LogicalExpression'
      ? typeof e == 'undefined'
        ? !0
        : (0, _.default)(t, e)
      : !1
  }
  function aw(t, e) {
    if (!t) return !1
    const r = t.type
    return r === 'BlockStatement' ||
      r === 'CatchClause' ||
      r === 'DoWhileStatement' ||
      r === 'ForInStatement' ||
      r === 'ForStatement' ||
      r === 'FunctionDeclaration' ||
      r === 'FunctionExpression' ||
      r === 'Program' ||
      r === 'ObjectMethod' ||
      r === 'SwitchStatement' ||
      r === 'WhileStatement' ||
      r === 'ArrowFunctionExpression' ||
      r === 'ClassExpression' ||
      r === 'ClassDeclaration' ||
      r === 'ForOfStatement' ||
      r === 'ClassMethod' ||
      r === 'ClassPrivateMethod' ||
      r === 'StaticBlock' ||
      r === 'TSModuleBlock' ||
      (r === 'Placeholder' && t.expectedNode === 'BlockStatement')
      ? typeof e == 'undefined'
        ? !0
        : (0, _.default)(t, e)
      : !1
  }
  function ow(t, e) {
    if (!t) return !1
    const r = t.type
    return r === 'BlockStatement' ||
      r === 'CatchClause' ||
      r === 'DoWhileStatement' ||
      r === 'ForInStatement' ||
      r === 'ForStatement' ||
      r === 'FunctionDeclaration' ||
      r === 'FunctionExpression' ||
      r === 'Program' ||
      r === 'ObjectMethod' ||
      r === 'SwitchStatement' ||
      r === 'WhileStatement' ||
      r === 'ArrowFunctionExpression' ||
      r === 'ForOfStatement' ||
      r === 'ClassMethod' ||
      r === 'ClassPrivateMethod' ||
      r === 'StaticBlock' ||
      r === 'TSModuleBlock' ||
      (r === 'Placeholder' && t.expectedNode === 'BlockStatement')
      ? typeof e == 'undefined'
        ? !0
        : (0, _.default)(t, e)
      : !1
  }
  function lw(t, e) {
    if (!t) return !1
    const r = t.type
    return r === 'BlockStatement' ||
      r === 'Program' ||
      r === 'TSModuleBlock' ||
      (r === 'Placeholder' && t.expectedNode === 'BlockStatement')
      ? typeof e == 'undefined'
        ? !0
        : (0, _.default)(t, e)
      : !1
  }
  function uw(t, e) {
    if (!t) return !1
    const r = t.type
    return r === 'BlockStatement' ||
      r === 'BreakStatement' ||
      r === 'ContinueStatement' ||
      r === 'DebuggerStatement' ||
      r === 'DoWhileStatement' ||
      r === 'EmptyStatement' ||
      r === 'ExpressionStatement' ||
      r === 'ForInStatement' ||
      r === 'ForStatement' ||
      r === 'FunctionDeclaration' ||
      r === 'IfStatement' ||
      r === 'LabeledStatement' ||
      r === 'ReturnStatement' ||
      r === 'SwitchStatement' ||
      r === 'ThrowStatement' ||
      r === 'TryStatement' ||
      r === 'VariableDeclaration' ||
      r === 'WhileStatement' ||
      r === 'WithStatement' ||
      r === 'ClassDeclaration' ||
      r === 'ExportAllDeclaration' ||
      r === 'ExportDefaultDeclaration' ||
      r === 'ExportNamedDeclaration' ||
      r === 'ForOfStatement' ||
      r === 'ImportDeclaration' ||
      r === 'DeclareClass' ||
      r === 'DeclareFunction' ||
      r === 'DeclareInterface' ||
      r === 'DeclareModule' ||
      r === 'DeclareModuleExports' ||
      r === 'DeclareTypeAlias' ||
      r === 'DeclareOpaqueType' ||
      r === 'DeclareVariable' ||
      r === 'DeclareExportDeclaration' ||
      r === 'DeclareExportAllDeclaration' ||
      r === 'InterfaceDeclaration' ||
      r === 'OpaqueType' ||
      r === 'TypeAlias' ||
      r === 'EnumDeclaration' ||
      r === 'TSDeclareFunction' ||
      r === 'TSInterfaceDeclaration' ||
      r === 'TSTypeAliasDeclaration' ||
      r === 'TSEnumDeclaration' ||
      r === 'TSModuleDeclaration' ||
      r === 'TSImportEqualsDeclaration' ||
      r === 'TSExportAssignment' ||
      r === 'TSNamespaceExportDeclaration' ||
      (r === 'Placeholder' &&
        (t.expectedNode === 'Statement' || t.expectedNode === 'Declaration' || t.expectedNode === 'BlockStatement'))
      ? typeof e == 'undefined'
        ? !0
        : (0, _.default)(t, e)
      : !1
  }
  function cw(t, e) {
    if (!t) return !1
    const r = t.type
    return r === 'BreakStatement' ||
      r === 'ContinueStatement' ||
      r === 'ReturnStatement' ||
      r === 'ThrowStatement' ||
      r === 'YieldExpression' ||
      r === 'AwaitExpression'
      ? typeof e == 'undefined'
        ? !0
        : (0, _.default)(t, e)
      : !1
  }
  function pw(t, e) {
    if (!t) return !1
    const r = t.type
    return r === 'BreakStatement' || r === 'ContinueStatement' || r === 'ReturnStatement' || r === 'ThrowStatement'
      ? typeof e == 'undefined'
        ? !0
        : (0, _.default)(t, e)
      : !1
  }
  function fw(t, e) {
    if (!t) return !1
    const r = t.type
    return r === 'ConditionalExpression' || r === 'IfStatement'
      ? typeof e == 'undefined'
        ? !0
        : (0, _.default)(t, e)
      : !1
  }
  function hw(t, e) {
    if (!t) return !1
    const r = t.type
    return r === 'DoWhileStatement' ||
      r === 'ForInStatement' ||
      r === 'ForStatement' ||
      r === 'WhileStatement' ||
      r === 'ForOfStatement'
      ? typeof e == 'undefined'
        ? !0
        : (0, _.default)(t, e)
      : !1
  }
  function dw(t, e) {
    if (!t) return !1
    const r = t.type
    return r === 'DoWhileStatement' || r === 'WhileStatement'
      ? typeof e == 'undefined'
        ? !0
        : (0, _.default)(t, e)
      : !1
  }
  function mw(t, e) {
    if (!t) return !1
    const r = t.type
    return r === 'ExpressionStatement' || r === 'ParenthesizedExpression' || r === 'TypeCastExpression'
      ? typeof e == 'undefined'
        ? !0
        : (0, _.default)(t, e)
      : !1
  }
  function yw(t, e) {
    if (!t) return !1
    const r = t.type
    return r === 'ForInStatement' || r === 'ForStatement' || r === 'ForOfStatement'
      ? typeof e == 'undefined'
        ? !0
        : (0, _.default)(t, e)
      : !1
  }
  function gw(t, e) {
    if (!t) return !1
    const r = t.type
    return r === 'ForInStatement' || r === 'ForOfStatement' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function Tw(t, e) {
    if (!t) return !1
    const r = t.type
    return r === 'FunctionDeclaration' ||
      r === 'FunctionExpression' ||
      r === 'ObjectMethod' ||
      r === 'ArrowFunctionExpression' ||
      r === 'ClassMethod' ||
      r === 'ClassPrivateMethod'
      ? typeof e == 'undefined'
        ? !0
        : (0, _.default)(t, e)
      : !1
  }
  function bw(t, e) {
    if (!t) return !1
    const r = t.type
    return r === 'FunctionDeclaration' ||
      r === 'FunctionExpression' ||
      r === 'ObjectMethod' ||
      r === 'ArrowFunctionExpression' ||
      r === 'ClassMethod' ||
      r === 'ClassPrivateMethod' ||
      r === 'StaticBlock'
      ? typeof e == 'undefined'
        ? !0
        : (0, _.default)(t, e)
      : !1
  }
  function Sw(t, e) {
    if (!t) return !1
    const r = t.type
    return r === 'FunctionDeclaration' ||
      r === 'FunctionExpression' ||
      r === 'StringLiteral' ||
      r === 'NumericLiteral' ||
      r === 'NullLiteral' ||
      r === 'BooleanLiteral' ||
      r === 'RegExpLiteral' ||
      r === 'ArrowFunctionExpression' ||
      r === 'BigIntLiteral' ||
      r === 'DecimalLiteral' ||
      (r === 'Placeholder' && t.expectedNode === 'StringLiteral')
      ? typeof e == 'undefined'
        ? !0
        : (0, _.default)(t, e)
      : !1
  }
  function vw(t, e) {
    if (!t) return !1
    const r = t.type
    return r === 'FunctionDeclaration' ||
      r === 'VariableDeclaration' ||
      r === 'ClassDeclaration' ||
      r === 'ExportAllDeclaration' ||
      r === 'ExportDefaultDeclaration' ||
      r === 'ExportNamedDeclaration' ||
      r === 'ImportDeclaration' ||
      r === 'DeclareClass' ||
      r === 'DeclareFunction' ||
      r === 'DeclareInterface' ||
      r === 'DeclareModule' ||
      r === 'DeclareModuleExports' ||
      r === 'DeclareTypeAlias' ||
      r === 'DeclareOpaqueType' ||
      r === 'DeclareVariable' ||
      r === 'DeclareExportDeclaration' ||
      r === 'DeclareExportAllDeclaration' ||
      r === 'InterfaceDeclaration' ||
      r === 'OpaqueType' ||
      r === 'TypeAlias' ||
      r === 'EnumDeclaration' ||
      r === 'TSDeclareFunction' ||
      r === 'TSInterfaceDeclaration' ||
      r === 'TSTypeAliasDeclaration' ||
      r === 'TSEnumDeclaration' ||
      r === 'TSModuleDeclaration' ||
      (r === 'Placeholder' && t.expectedNode === 'Declaration')
      ? typeof e == 'undefined'
        ? !0
        : (0, _.default)(t, e)
      : !1
  }
  function Ew(t, e) {
    if (!t) return !1
    const r = t.type
    return r === 'Identifier' ||
      r === 'RestElement' ||
      r === 'AssignmentPattern' ||
      r === 'ArrayPattern' ||
      r === 'ObjectPattern' ||
      r === 'TSAsExpression' ||
      r === 'TSTypeAssertion' ||
      r === 'TSNonNullExpression' ||
      (r === 'Placeholder' && (t.expectedNode === 'Pattern' || t.expectedNode === 'Identifier'))
      ? typeof e == 'undefined'
        ? !0
        : (0, _.default)(t, e)
      : !1
  }
  function Pw(t, e) {
    if (!t) return !1
    const r = t.type
    return r === 'Identifier' ||
      r === 'MemberExpression' ||
      r === 'RestElement' ||
      r === 'AssignmentPattern' ||
      r === 'ArrayPattern' ||
      r === 'ObjectPattern' ||
      r === 'TSParameterProperty' ||
      r === 'TSAsExpression' ||
      r === 'TSTypeAssertion' ||
      r === 'TSNonNullExpression' ||
      (r === 'Placeholder' && (t.expectedNode === 'Pattern' || t.expectedNode === 'Identifier'))
      ? typeof e == 'undefined'
        ? !0
        : (0, _.default)(t, e)
      : !1
  }
  function ww(t, e) {
    if (!t) return !1
    const r = t.type
    return r === 'Identifier' || r === 'TSQualifiedName' || (r === 'Placeholder' && t.expectedNode === 'Identifier')
      ? typeof e == 'undefined'
        ? !0
        : (0, _.default)(t, e)
      : !1
  }
  function Aw(t, e) {
    if (!t) return !1
    const r = t.type
    return r === 'StringLiteral' ||
      r === 'NumericLiteral' ||
      r === 'NullLiteral' ||
      r === 'BooleanLiteral' ||
      r === 'RegExpLiteral' ||
      r === 'TemplateLiteral' ||
      r === 'BigIntLiteral' ||
      r === 'DecimalLiteral' ||
      (r === 'Placeholder' && t.expectedNode === 'StringLiteral')
      ? typeof e == 'undefined'
        ? !0
        : (0, _.default)(t, e)
      : !1
  }
  function Cw(t, e) {
    if (!t) return !1
    const r = t.type
    return r === 'StringLiteral' ||
      r === 'NumericLiteral' ||
      r === 'NullLiteral' ||
      r === 'BooleanLiteral' ||
      r === 'BigIntLiteral' ||
      r === 'JSXAttribute' ||
      r === 'JSXClosingElement' ||
      r === 'JSXElement' ||
      r === 'JSXExpressionContainer' ||
      r === 'JSXSpreadChild' ||
      r === 'JSXOpeningElement' ||
      r === 'JSXText' ||
      r === 'JSXFragment' ||
      r === 'JSXOpeningFragment' ||
      r === 'JSXClosingFragment' ||
      r === 'DecimalLiteral' ||
      (r === 'Placeholder' && t.expectedNode === 'StringLiteral')
      ? typeof e == 'undefined'
        ? !0
        : (0, _.default)(t, e)
      : !1
  }
  function xw(t, e) {
    if (!t) return !1
    const r = t.type
    return r === 'ObjectMethod' ||
      r === 'ObjectProperty' ||
      r === 'ObjectTypeInternalSlot' ||
      r === 'ObjectTypeCallProperty' ||
      r === 'ObjectTypeIndexer' ||
      r === 'ObjectTypeProperty' ||
      r === 'ObjectTypeSpreadProperty'
      ? typeof e == 'undefined'
        ? !0
        : (0, _.default)(t, e)
      : !1
  }
  function Iw(t, e) {
    if (!t) return !1
    const r = t.type
    return r === 'ObjectMethod' || r === 'ClassMethod' || r === 'ClassPrivateMethod'
      ? typeof e == 'undefined'
        ? !0
        : (0, _.default)(t, e)
      : !1
  }
  function kw(t, e) {
    if (!t) return !1
    const r = t.type
    return r === 'ObjectMethod' || r === 'ObjectProperty' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function Nw(t, e) {
    if (!t) return !1
    const r = t.type
    return r === 'ObjectProperty' ||
      r === 'ClassProperty' ||
      r === 'ClassAccessorProperty' ||
      r === 'ClassPrivateProperty'
      ? typeof e == 'undefined'
        ? !0
        : (0, _.default)(t, e)
      : !1
  }
  function Ow(t, e) {
    if (!t) return !1
    const r = t.type
    return r === 'UnaryExpression' || r === 'SpreadElement' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function Dw(t, e) {
    if (!t) return !1
    const r = t.type
    return r === 'AssignmentPattern' ||
      r === 'ArrayPattern' ||
      r === 'ObjectPattern' ||
      (r === 'Placeholder' && t.expectedNode === 'Pattern')
      ? typeof e == 'undefined'
        ? !0
        : (0, _.default)(t, e)
      : !1
  }
  function Bw(t, e) {
    if (!t) return !1
    const r = t.type
    return r === 'ClassExpression' || r === 'ClassDeclaration'
      ? typeof e == 'undefined'
        ? !0
        : (0, _.default)(t, e)
      : !1
  }
  function Lw(t, e) {
    if (!t) return !1
    const r = t.type
    return r === 'ExportAllDeclaration' ||
      r === 'ExportDefaultDeclaration' ||
      r === 'ExportNamedDeclaration' ||
      r === 'ImportDeclaration'
      ? typeof e == 'undefined'
        ? !0
        : (0, _.default)(t, e)
      : !1
  }
  function Mw(t, e) {
    if (!t) return !1
    const r = t.type
    return r === 'ExportAllDeclaration' || r === 'ExportDefaultDeclaration' || r === 'ExportNamedDeclaration'
      ? typeof e == 'undefined'
        ? !0
        : (0, _.default)(t, e)
      : !1
  }
  function Fw(t, e) {
    if (!t) return !1
    const r = t.type
    return r === 'ExportSpecifier' ||
      r === 'ImportDefaultSpecifier' ||
      r === 'ImportNamespaceSpecifier' ||
      r === 'ImportSpecifier' ||
      r === 'ExportNamespaceSpecifier' ||
      r === 'ExportDefaultSpecifier'
      ? typeof e == 'undefined'
        ? !0
        : (0, _.default)(t, e)
      : !1
  }
  function $w(t, e) {
    return t && t.type === 'ClassAccessorProperty' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
  }
  function Rw(t, e) {
    if (!t) return !1
    const r = t.type
    return r === 'ClassPrivateProperty' || r === 'ClassPrivateMethod' || r === 'PrivateName'
      ? typeof e == 'undefined'
        ? !0
        : (0, _.default)(t, e)
      : !1
  }
  function jw(t, e) {
    if (!t) return !1
    const r = t.type
    return r === 'AnyTypeAnnotation' ||
      r === 'ArrayTypeAnnotation' ||
      r === 'BooleanTypeAnnotation' ||
      r === 'BooleanLiteralTypeAnnotation' ||
      r === 'NullLiteralTypeAnnotation' ||
      r === 'ClassImplements' ||
      r === 'DeclareClass' ||
      r === 'DeclareFunction' ||
      r === 'DeclareInterface' ||
      r === 'DeclareModule' ||
      r === 'DeclareModuleExports' ||
      r === 'DeclareTypeAlias' ||
      r === 'DeclareOpaqueType' ||
      r === 'DeclareVariable' ||
      r === 'DeclareExportDeclaration' ||
      r === 'DeclareExportAllDeclaration' ||
      r === 'DeclaredPredicate' ||
      r === 'ExistsTypeAnnotation' ||
      r === 'FunctionTypeAnnotation' ||
      r === 'FunctionTypeParam' ||
      r === 'GenericTypeAnnotation' ||
      r === 'InferredPredicate' ||
      r === 'InterfaceExtends' ||
      r === 'InterfaceDeclaration' ||
      r === 'InterfaceTypeAnnotation' ||
      r === 'IntersectionTypeAnnotation' ||
      r === 'MixedTypeAnnotation' ||
      r === 'EmptyTypeAnnotation' ||
      r === 'NullableTypeAnnotation' ||
      r === 'NumberLiteralTypeAnnotation' ||
      r === 'NumberTypeAnnotation' ||
      r === 'ObjectTypeAnnotation' ||
      r === 'ObjectTypeInternalSlot' ||
      r === 'ObjectTypeCallProperty' ||
      r === 'ObjectTypeIndexer' ||
      r === 'ObjectTypeProperty' ||
      r === 'ObjectTypeSpreadProperty' ||
      r === 'OpaqueType' ||
      r === 'QualifiedTypeIdentifier' ||
      r === 'StringLiteralTypeAnnotation' ||
      r === 'StringTypeAnnotation' ||
      r === 'SymbolTypeAnnotation' ||
      r === 'ThisTypeAnnotation' ||
      r === 'TupleTypeAnnotation' ||
      r === 'TypeofTypeAnnotation' ||
      r === 'TypeAlias' ||
      r === 'TypeAnnotation' ||
      r === 'TypeCastExpression' ||
      r === 'TypeParameter' ||
      r === 'TypeParameterDeclaration' ||
      r === 'TypeParameterInstantiation' ||
      r === 'UnionTypeAnnotation' ||
      r === 'Variance' ||
      r === 'VoidTypeAnnotation' ||
      r === 'EnumDeclaration' ||
      r === 'EnumBooleanBody' ||
      r === 'EnumNumberBody' ||
      r === 'EnumStringBody' ||
      r === 'EnumSymbolBody' ||
      r === 'EnumBooleanMember' ||
      r === 'EnumNumberMember' ||
      r === 'EnumStringMember' ||
      r === 'EnumDefaultedMember' ||
      r === 'IndexedAccessType' ||
      r === 'OptionalIndexedAccessType'
      ? typeof e == 'undefined'
        ? !0
        : (0, _.default)(t, e)
      : !1
  }
  function _w(t, e) {
    if (!t) return !1
    const r = t.type
    return r === 'AnyTypeAnnotation' ||
      r === 'ArrayTypeAnnotation' ||
      r === 'BooleanTypeAnnotation' ||
      r === 'BooleanLiteralTypeAnnotation' ||
      r === 'NullLiteralTypeAnnotation' ||
      r === 'ExistsTypeAnnotation' ||
      r === 'FunctionTypeAnnotation' ||
      r === 'GenericTypeAnnotation' ||
      r === 'InterfaceTypeAnnotation' ||
      r === 'IntersectionTypeAnnotation' ||
      r === 'MixedTypeAnnotation' ||
      r === 'EmptyTypeAnnotation' ||
      r === 'NullableTypeAnnotation' ||
      r === 'NumberLiteralTypeAnnotation' ||
      r === 'NumberTypeAnnotation' ||
      r === 'ObjectTypeAnnotation' ||
      r === 'StringLiteralTypeAnnotation' ||
      r === 'StringTypeAnnotation' ||
      r === 'SymbolTypeAnnotation' ||
      r === 'ThisTypeAnnotation' ||
      r === 'TupleTypeAnnotation' ||
      r === 'TypeofTypeAnnotation' ||
      r === 'UnionTypeAnnotation' ||
      r === 'VoidTypeAnnotation' ||
      r === 'IndexedAccessType' ||
      r === 'OptionalIndexedAccessType'
      ? typeof e == 'undefined'
        ? !0
        : (0, _.default)(t, e)
      : !1
  }
  function Vw(t, e) {
    if (!t) return !1
    const r = t.type
    return r === 'AnyTypeAnnotation' ||
      r === 'BooleanTypeAnnotation' ||
      r === 'NullLiteralTypeAnnotation' ||
      r === 'MixedTypeAnnotation' ||
      r === 'EmptyTypeAnnotation' ||
      r === 'NumberTypeAnnotation' ||
      r === 'StringTypeAnnotation' ||
      r === 'SymbolTypeAnnotation' ||
      r === 'ThisTypeAnnotation' ||
      r === 'VoidTypeAnnotation'
      ? typeof e == 'undefined'
        ? !0
        : (0, _.default)(t, e)
      : !1
  }
  function Uw(t, e) {
    if (!t) return !1
    const r = t.type
    return r === 'DeclareClass' ||
      r === 'DeclareFunction' ||
      r === 'DeclareInterface' ||
      r === 'DeclareModule' ||
      r === 'DeclareModuleExports' ||
      r === 'DeclareTypeAlias' ||
      r === 'DeclareOpaqueType' ||
      r === 'DeclareVariable' ||
      r === 'DeclareExportDeclaration' ||
      r === 'DeclareExportAllDeclaration' ||
      r === 'InterfaceDeclaration' ||
      r === 'OpaqueType' ||
      r === 'TypeAlias'
      ? typeof e == 'undefined'
        ? !0
        : (0, _.default)(t, e)
      : !1
  }
  function zw(t, e) {
    if (!t) return !1
    const r = t.type
    return r === 'DeclaredPredicate' || r === 'InferredPredicate'
      ? typeof e == 'undefined'
        ? !0
        : (0, _.default)(t, e)
      : !1
  }
  function Kw(t, e) {
    if (!t) return !1
    const r = t.type
    return r === 'EnumBooleanBody' || r === 'EnumNumberBody' || r === 'EnumStringBody' || r === 'EnumSymbolBody'
      ? typeof e == 'undefined'
        ? !0
        : (0, _.default)(t, e)
      : !1
  }
  function Ww(t, e) {
    if (!t) return !1
    const r = t.type
    return r === 'EnumBooleanMember' ||
      r === 'EnumNumberMember' ||
      r === 'EnumStringMember' ||
      r === 'EnumDefaultedMember'
      ? typeof e == 'undefined'
        ? !0
        : (0, _.default)(t, e)
      : !1
  }
  function Yw(t, e) {
    if (!t) return !1
    const r = t.type
    return r === 'JSXAttribute' ||
      r === 'JSXClosingElement' ||
      r === 'JSXElement' ||
      r === 'JSXEmptyExpression' ||
      r === 'JSXExpressionContainer' ||
      r === 'JSXSpreadChild' ||
      r === 'JSXIdentifier' ||
      r === 'JSXMemberExpression' ||
      r === 'JSXNamespacedName' ||
      r === 'JSXOpeningElement' ||
      r === 'JSXSpreadAttribute' ||
      r === 'JSXText' ||
      r === 'JSXFragment' ||
      r === 'JSXOpeningFragment' ||
      r === 'JSXClosingFragment'
      ? typeof e == 'undefined'
        ? !0
        : (0, _.default)(t, e)
      : !1
  }
  function Hw(t, e) {
    if (!t) return !1
    const r = t.type
    return r === 'Noop' || r === 'Placeholder' || r === 'V8IntrinsicIdentifier'
      ? typeof e == 'undefined'
        ? !0
        : (0, _.default)(t, e)
      : !1
  }
  function qw(t, e) {
    if (!t) return !1
    const r = t.type
    return r === 'TSParameterProperty' ||
      r === 'TSDeclareFunction' ||
      r === 'TSDeclareMethod' ||
      r === 'TSQualifiedName' ||
      r === 'TSCallSignatureDeclaration' ||
      r === 'TSConstructSignatureDeclaration' ||
      r === 'TSPropertySignature' ||
      r === 'TSMethodSignature' ||
      r === 'TSIndexSignature' ||
      r === 'TSAnyKeyword' ||
      r === 'TSBooleanKeyword' ||
      r === 'TSBigIntKeyword' ||
      r === 'TSIntrinsicKeyword' ||
      r === 'TSNeverKeyword' ||
      r === 'TSNullKeyword' ||
      r === 'TSNumberKeyword' ||
      r === 'TSObjectKeyword' ||
      r === 'TSStringKeyword' ||
      r === 'TSSymbolKeyword' ||
      r === 'TSUndefinedKeyword' ||
      r === 'TSUnknownKeyword' ||
      r === 'TSVoidKeyword' ||
      r === 'TSThisType' ||
      r === 'TSFunctionType' ||
      r === 'TSConstructorType' ||
      r === 'TSTypeReference' ||
      r === 'TSTypePredicate' ||
      r === 'TSTypeQuery' ||
      r === 'TSTypeLiteral' ||
      r === 'TSArrayType' ||
      r === 'TSTupleType' ||
      r === 'TSOptionalType' ||
      r === 'TSRestType' ||
      r === 'TSNamedTupleMember' ||
      r === 'TSUnionType' ||
      r === 'TSIntersectionType' ||
      r === 'TSConditionalType' ||
      r === 'TSInferType' ||
      r === 'TSParenthesizedType' ||
      r === 'TSTypeOperator' ||
      r === 'TSIndexedAccessType' ||
      r === 'TSMappedType' ||
      r === 'TSLiteralType' ||
      r === 'TSExpressionWithTypeArguments' ||
      r === 'TSInterfaceDeclaration' ||
      r === 'TSInterfaceBody' ||
      r === 'TSTypeAliasDeclaration' ||
      r === 'TSInstantiationExpression' ||
      r === 'TSAsExpression' ||
      r === 'TSTypeAssertion' ||
      r === 'TSEnumDeclaration' ||
      r === 'TSEnumMember' ||
      r === 'TSModuleDeclaration' ||
      r === 'TSModuleBlock' ||
      r === 'TSImportType' ||
      r === 'TSImportEqualsDeclaration' ||
      r === 'TSExternalModuleReference' ||
      r === 'TSNonNullExpression' ||
      r === 'TSExportAssignment' ||
      r === 'TSNamespaceExportDeclaration' ||
      r === 'TSTypeAnnotation' ||
      r === 'TSTypeParameterInstantiation' ||
      r === 'TSTypeParameterDeclaration' ||
      r === 'TSTypeParameter'
      ? typeof e == 'undefined'
        ? !0
        : (0, _.default)(t, e)
      : !1
  }
  function Xw(t, e) {
    if (!t) return !1
    const r = t.type
    return r === 'TSCallSignatureDeclaration' ||
      r === 'TSConstructSignatureDeclaration' ||
      r === 'TSPropertySignature' ||
      r === 'TSMethodSignature' ||
      r === 'TSIndexSignature'
      ? typeof e == 'undefined'
        ? !0
        : (0, _.default)(t, e)
      : !1
  }
  function Gw(t, e) {
    if (!t) return !1
    const r = t.type
    return r === 'TSAnyKeyword' ||
      r === 'TSBooleanKeyword' ||
      r === 'TSBigIntKeyword' ||
      r === 'TSIntrinsicKeyword' ||
      r === 'TSNeverKeyword' ||
      r === 'TSNullKeyword' ||
      r === 'TSNumberKeyword' ||
      r === 'TSObjectKeyword' ||
      r === 'TSStringKeyword' ||
      r === 'TSSymbolKeyword' ||
      r === 'TSUndefinedKeyword' ||
      r === 'TSUnknownKeyword' ||
      r === 'TSVoidKeyword' ||
      r === 'TSThisType' ||
      r === 'TSFunctionType' ||
      r === 'TSConstructorType' ||
      r === 'TSTypeReference' ||
      r === 'TSTypePredicate' ||
      r === 'TSTypeQuery' ||
      r === 'TSTypeLiteral' ||
      r === 'TSArrayType' ||
      r === 'TSTupleType' ||
      r === 'TSOptionalType' ||
      r === 'TSRestType' ||
      r === 'TSUnionType' ||
      r === 'TSIntersectionType' ||
      r === 'TSConditionalType' ||
      r === 'TSInferType' ||
      r === 'TSParenthesizedType' ||
      r === 'TSTypeOperator' ||
      r === 'TSIndexedAccessType' ||
      r === 'TSMappedType' ||
      r === 'TSLiteralType' ||
      r === 'TSExpressionWithTypeArguments' ||
      r === 'TSImportType'
      ? typeof e == 'undefined'
        ? !0
        : (0, _.default)(t, e)
      : !1
  }
  function Jw(t, e) {
    if (!t) return !1
    const r = t.type
    return r === 'TSAnyKeyword' ||
      r === 'TSBooleanKeyword' ||
      r === 'TSBigIntKeyword' ||
      r === 'TSIntrinsicKeyword' ||
      r === 'TSNeverKeyword' ||
      r === 'TSNullKeyword' ||
      r === 'TSNumberKeyword' ||
      r === 'TSObjectKeyword' ||
      r === 'TSStringKeyword' ||
      r === 'TSSymbolKeyword' ||
      r === 'TSUndefinedKeyword' ||
      r === 'TSUnknownKeyword' ||
      r === 'TSVoidKeyword' ||
      r === 'TSThisType' ||
      r === 'TSLiteralType'
      ? typeof e == 'undefined'
        ? !0
        : (0, _.default)(t, e)
      : !1
  }
  function Zw(t, e) {
    return (
      console.trace('The node type NumberLiteral has been renamed to NumericLiteral'),
      t && t.type === 'NumberLiteral' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
    )
  }
  function Qw(t, e) {
    return (
      console.trace('The node type RegexLiteral has been renamed to RegExpLiteral'),
      t && t.type === 'RegexLiteral' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
    )
  }
  function eA(t, e) {
    return (
      console.trace('The node type RestProperty has been renamed to RestElement'),
      t && t.type === 'RestProperty' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
    )
  }
  function tA(t, e) {
    return (
      console.trace('The node type SpreadProperty has been renamed to SpreadElement'),
      t && t.type === 'SpreadProperty' ? (typeof e == 'undefined' ? !0 : (0, _.default)(t, e)) : !1
    )
  }
  Object.defineProperty(ga, '__esModule', { value: !0 }), (ga.default = rA)
  var os = $
  function rA(t, e, r) {
    if (!(0, os.isMemberExpression)(t)) return !1
    const i = Array.isArray(e) ? e : e.split('.'),
      n = []
    let s
    for (s = t; (0, os.isMemberExpression)(s); s = s.object) n.push(s.property)
    if ((n.push(s), n.length < i.length || (!r && n.length > i.length))) return !1
    for (let a = 0, o = n.length - 1; a < i.length; a++, o--) {
      const u = n[o]
      let c
      if ((0, os.isIdentifier)(u)) c = u.name
      else if ((0, os.isStringLiteral)(u)) c = u.value
      else if ((0, os.isThisExpression)(u)) c = 'this'
      else return !1
      if (i[a] !== c) return !1
    }
    return !0
  }
  Object.defineProperty(ya, '__esModule', { value: !0 }), (ya.default = nA)
  var iA = ga
  function nA(t, e) {
    const r = t.split('.')
    return (i) => (0, iA.default)(i, r, e)
  }
  Object.defineProperty(ma, '__esModule', { value: !0 }), (ma.default = void 0)
  var sA = ya,
    aA = (0, sA.default)('React.Component')
  ma.default = aA
  var Zl = {}
  Object.defineProperty(Zl, '__esModule', { value: !0 }), (Zl.default = oA)
  function oA(t) {
    return !!t && /^[a-z]/.test(t)
  }
  var Ql = {},
    eu = {},
    M = {},
    tu = {},
    _i = {},
    fr = {}
  let ls = null
  function us(t) {
    if (ls !== null && typeof ls.property) {
      const e = ls
      return (ls = us.prototype = null), e
    }
    return (ls = us.prototype = t == null ? Object.create(null) : t), new us()
  }
  us()
  var lA = function (e) {
      return us(e)
    },
    ir = {},
    Vi = {},
    cs = {}
  Object.defineProperty(cs, '__esModule', { value: !0 }), (cs.default = uA)
  var rd = fr
  function uA(t, e) {
    if (t === e) return !0
    if (rd.ALIAS_KEYS[e]) return !1
    const r = rd.FLIPPED_ALIAS_KEYS[e]
    if (r) {
      if (r[0] === t) return !0
      for (const i of r) if (t === i) return !0
    }
    return !1
  }
  var Ta = {}
  Object.defineProperty(Ta, '__esModule', { value: !0 }), (Ta.default = pA)
  var cA = fr
  function pA(t, e) {
    if (t === e) return !0
    const r = cA.PLACEHOLDERS_ALIAS[t]
    if (r) {
      for (const i of r) if (e === i) return !0
    }
    return !1
  }
  Object.defineProperty(Vi, '__esModule', { value: !0 }), (Vi.default = yA)
  var fA = as,
    hA = cs,
    dA = Ta,
    mA = fr
  function yA(t, e, r) {
    return e
      ? (0, hA.default)(e.type, t)
        ? typeof r == 'undefined'
          ? !0
          : (0, fA.default)(e, r)
        : !r && e.type === 'Placeholder' && t in mA.FLIPPED_ALIAS_KEYS
        ? (0, dA.default)(e.expectedNode, t)
        : !1
      : !1
  }
  var Ui = {},
    ps = {},
    fs = {}
  Object.defineProperty(fs, '__esModule', { value: !0 }),
    (fs.isIdentifierChar = ad),
    (fs.isIdentifierName = SA),
    (fs.isIdentifierStart = sd)
  let ru =
      '\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC',
    id =
      '\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F'
  const gA = new RegExp('[' + ru + ']'),
    TA = new RegExp('[' + ru + id + ']')
  ru = id = null
  const nd = [
      0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5,
      7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10,
      21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11,
      25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72,
      56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44,
      33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2,
      9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0,
      185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16,
      0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50,
      29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2637, 96,
      16, 1070, 4050, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67,
      12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 46, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4,
      8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4,
      2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 482, 44,
      11, 6, 17, 0, 322, 29, 19, 43, 1269, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0,
      2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3,
      2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4152, 8, 221, 3, 5761, 15, 7472, 3104,
      541, 1507, 4938,
    ],
    bA = [
      509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 50, 3,
      123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2,
      11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0,
      82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3,
      2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2,
      13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 87, 9, 39, 4, 60, 6, 26, 9,
      1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49,
      513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 357, 0, 62, 13, 1495,
      6, 110, 6, 6, 9, 4759, 9, 787719, 239,
    ]
  function iu(t, e) {
    let r = 65536
    for (let i = 0, n = e.length; i < n; i += 2) {
      if (((r += e[i]), r > t)) return !1
      if (((r += e[i + 1]), r >= t)) return !0
    }
    return !1
  }
  function sd(t) {
    return t < 65
      ? t === 36
      : t <= 90
      ? !0
      : t < 97
      ? t === 95
      : t <= 122
      ? !0
      : t <= 65535
      ? t >= 170 && gA.test(String.fromCharCode(t))
      : iu(t, nd)
  }
  function ad(t) {
    return t < 48
      ? t === 36
      : t < 58
      ? !0
      : t < 65
      ? !1
      : t <= 90
      ? !0
      : t < 97
      ? t === 95
      : t <= 122
      ? !0
      : t <= 65535
      ? t >= 170 && TA.test(String.fromCharCode(t))
      : iu(t, nd) || iu(t, bA)
  }
  function SA(t) {
    let e = !0
    for (let r = 0; r < t.length; r++) {
      let i = t.charCodeAt(r)
      if ((i & 64512) === 55296 && r + 1 < t.length) {
        const n = t.charCodeAt(++r)
        ;(n & 64512) === 56320 && (i = 65536 + ((i & 1023) << 10) + (n & 1023))
      }
      if (e) {
        if (((e = !1), !sd(i))) return !1
      } else if (!ad(i)) return !1
    }
    return !e
  }
  var zi = {}
  Object.defineProperty(zi, '__esModule', { value: !0 }),
    (zi.isKeyword = AA),
    (zi.isReservedWord = od),
    (zi.isStrictBindOnlyReservedWord = ud),
    (zi.isStrictBindReservedWord = wA),
    (zi.isStrictReservedWord = ld)
  const nu = {
      keyword: [
        'break',
        'case',
        'catch',
        'continue',
        'debugger',
        'default',
        'do',
        'else',
        'finally',
        'for',
        'function',
        'if',
        'return',
        'switch',
        'throw',
        'try',
        'var',
        'const',
        'while',
        'with',
        'new',
        'this',
        'super',
        'class',
        'extends',
        'export',
        'import',
        'null',
        'true',
        'false',
        'in',
        'instanceof',
        'typeof',
        'void',
        'delete',
      ],
      strict: ['implements', 'interface', 'let', 'package', 'private', 'protected', 'public', 'static', 'yield'],
      strictBind: ['eval', 'arguments'],
    },
    vA = new Set(nu.keyword),
    EA = new Set(nu.strict),
    PA = new Set(nu.strictBind)
  function od(t, e) {
    return (e && t === 'await') || t === 'enum'
  }
  function ld(t, e) {
    return od(t, e) || EA.has(t)
  }
  function ud(t) {
    return PA.has(t)
  }
  function wA(t, e) {
    return ld(t, e) || ud(t)
  }
  function AA(t) {
    return vA.has(t)
  }
  ;(function (t) {
    Object.defineProperty(t, '__esModule', { value: !0 }),
      Object.defineProperty(t, 'isIdentifierChar', {
        enumerable: !0,
        get: function () {
          return e.isIdentifierChar
        },
      }),
      Object.defineProperty(t, 'isIdentifierName', {
        enumerable: !0,
        get: function () {
          return e.isIdentifierName
        },
      }),
      Object.defineProperty(t, 'isIdentifierStart', {
        enumerable: !0,
        get: function () {
          return e.isIdentifierStart
        },
      }),
      Object.defineProperty(t, 'isKeyword', {
        enumerable: !0,
        get: function () {
          return r.isKeyword
        },
      }),
      Object.defineProperty(t, 'isReservedWord', {
        enumerable: !0,
        get: function () {
          return r.isReservedWord
        },
      }),
      Object.defineProperty(t, 'isStrictBindOnlyReservedWord', {
        enumerable: !0,
        get: function () {
          return r.isStrictBindOnlyReservedWord
        },
      }),
      Object.defineProperty(t, 'isStrictBindReservedWord', {
        enumerable: !0,
        get: function () {
          return r.isStrictBindReservedWord
        },
      }),
      Object.defineProperty(t, 'isStrictReservedWord', {
        enumerable: !0,
        get: function () {
          return r.isStrictReservedWord
        },
      })
    var e = fs,
      r = zi
  })(ps),
    Object.defineProperty(Ui, '__esModule', { value: !0 }),
    (Ui.default = CA)
  var su = ps
  function CA(t, e = !0) {
    return typeof t != 'string' || (e && ((0, su.isKeyword)(t) || (0, su.isStrictReservedWord)(t, !0)))
      ? !1
      : (0, su.isIdentifierName)(t)
  }
  var Je = {}
  Object.defineProperty(Je, '__esModule', { value: !0 }),
    (Je.UPDATE_OPERATORS =
      Je.UNARY_OPERATORS =
      Je.STRING_UNARY_OPERATORS =
      Je.STATEMENT_OR_BLOCK_KEYS =
      Je.NUMBER_UNARY_OPERATORS =
      Je.NUMBER_BINARY_OPERATORS =
      Je.NOT_LOCAL_BINDING =
      Je.LOGICAL_OPERATORS =
      Je.INHERIT_KEYS =
      Je.FOR_INIT_KEYS =
      Je.FLATTENABLE_KEYS =
      Je.EQUALITY_BINARY_OPERATORS =
      Je.COMPARISON_BINARY_OPERATORS =
      Je.COMMENT_KEYS =
      Je.BOOLEAN_UNARY_OPERATORS =
      Je.BOOLEAN_NUMBER_BINARY_OPERATORS =
      Je.BOOLEAN_BINARY_OPERATORS =
      Je.BLOCK_SCOPED_SYMBOL =
      Je.BINARY_OPERATORS =
      Je.ASSIGNMENT_OPERATORS =
        void 0)
  const xA = ['consequent', 'body', 'alternate']
  Je.STATEMENT_OR_BLOCK_KEYS = xA
  const IA = ['body', 'expressions']
  Je.FLATTENABLE_KEYS = IA
  const kA = ['left', 'init']
  Je.FOR_INIT_KEYS = kA
  const NA = ['leadingComments', 'trailingComments', 'innerComments']
  Je.COMMENT_KEYS = NA
  const cd = ['||', '&&', '??']
  Je.LOGICAL_OPERATORS = cd
  const OA = ['++', '--']
  Je.UPDATE_OPERATORS = OA
  const pd = ['>', '<', '>=', '<=']
  Je.BOOLEAN_NUMBER_BINARY_OPERATORS = pd
  const fd = ['==', '===', '!=', '!==']
  Je.EQUALITY_BINARY_OPERATORS = fd
  const hd = [...fd, 'in', 'instanceof']
  Je.COMPARISON_BINARY_OPERATORS = hd
  const dd = [...hd, ...pd]
  Je.BOOLEAN_BINARY_OPERATORS = dd
  const au = ['-', '/', '%', '*', '**', '&', '|', '>>', '>>>', '<<', '^']
  Je.NUMBER_BINARY_OPERATORS = au
  const DA = ['+', ...au, ...dd, '|>']
  Je.BINARY_OPERATORS = DA
  const BA = ['=', '+=', ...au.map((t) => t + '='), ...cd.map((t) => t + '=')]
  Je.ASSIGNMENT_OPERATORS = BA
  const md = ['delete', '!']
  Je.BOOLEAN_UNARY_OPERATORS = md
  const yd = ['+', '-', '~']
  Je.NUMBER_UNARY_OPERATORS = yd
  const gd = ['typeof']
  Je.STRING_UNARY_OPERATORS = gd
  const LA = ['void', 'throw', ...md, ...yd, ...gd]
  Je.UNARY_OPERATORS = LA
  const MA = { optional: ['typeAnnotation', 'typeParameters', 'returnType'], force: ['start', 'loc', 'end'] }
  Je.INHERIT_KEYS = MA
  const FA = Symbol.for('var used to be block scoped')
  Je.BLOCK_SCOPED_SYMBOL = FA
  const $A = Symbol.for('should not be considered a local binding')
  Je.NOT_LOCAL_BINDING = $A
  var tt = {}
  Object.defineProperty(tt, '__esModule', { value: !0 }),
    (tt.VISITOR_KEYS =
      tt.NODE_PARENT_VALIDATIONS =
      tt.NODE_FIELDS =
      tt.FLIPPED_ALIAS_KEYS =
      tt.DEPRECATED_KEYS =
      tt.BUILDER_KEYS =
      tt.ALIAS_KEYS =
        void 0),
    (tt.arrayOf = Ad),
    (tt.arrayOfType = Cd),
    (tt.assertEach = xd),
    (tt.assertNodeOrValueType = zA),
    (tt.assertNodeType = lu),
    (tt.assertOneOf = UA),
    (tt.assertOptionalChainStart = WA),
    (tt.assertShape = KA),
    (tt.assertValueType = uu),
    (tt.chain = Id),
    (tt.default = kd),
    (tt.defineAliasedType = qA),
    (tt.typeIs = Ea),
    (tt.validate = ou),
    (tt.validateArrayOfType = VA),
    (tt.validateOptional = jA),
    (tt.validateOptionalType = _A),
    (tt.validateType = RA)
  var Td = Vi,
    ba = _i
  const bd = {}
  tt.VISITOR_KEYS = bd
  const Sd = {}
  tt.ALIAS_KEYS = Sd
  const Sa = {}
  tt.FLIPPED_ALIAS_KEYS = Sa
  const vd = {}
  tt.NODE_FIELDS = vd
  const Ed = {}
  tt.BUILDER_KEYS = Ed
  const Pd = {}
  tt.DEPRECATED_KEYS = Pd
  const wd = {}
  tt.NODE_PARENT_VALIDATIONS = wd
  function va(t) {
    return Array.isArray(t) ? 'array' : t === null ? 'null' : typeof t
  }
  function ou(t) {
    return { validate: t }
  }
  function Ea(t) {
    return typeof t == 'string' ? lu(t) : lu(...t)
  }
  function RA(t) {
    return ou(Ea(t))
  }
  function jA(t) {
    return { validate: t, optional: !0 }
  }
  function _A(t) {
    return { validate: Ea(t), optional: !0 }
  }
  function Ad(t) {
    return Id(uu('array'), xd(t))
  }
  function Cd(t) {
    return Ad(Ea(t))
  }
  function VA(t) {
    return ou(Cd(t))
  }
  function xd(t) {
    function e(r, i, n) {
      if (!!Array.isArray(n))
        for (let s = 0; s < n.length; s++) {
          const a = `${i}[${s}]`,
            o = n[s]
          t(r, a, o), {}.BABEL_TYPES_8_BREAKING && (0, ba.validateChild)(r, a, o)
        }
    }
    return (e.each = t), e
  }
  function UA(...t) {
    function e(r, i, n) {
      if (t.indexOf(n) < 0)
        throw new TypeError(
          `Property ${i} expected value to be one of ${JSON.stringify(t)} but got ${JSON.stringify(n)}`
        )
    }
    return (e.oneOf = t), e
  }
  function lu(...t) {
    function e(r, i, n) {
      for (const s of t)
        if ((0, Td.default)(s, n)) {
          ;(0, ba.validateChild)(r, i, n)
          return
        }
      throw new TypeError(
        `Property ${i} of ${r.type} expected node to be of a type ${JSON.stringify(t)} but instead got ${JSON.stringify(
          n == null ? void 0 : n.type
        )}`
      )
    }
    return (e.oneOfNodeTypes = t), e
  }
  function zA(...t) {
    function e(r, i, n) {
      for (const s of t)
        if (va(n) === s || (0, Td.default)(s, n)) {
          ;(0, ba.validateChild)(r, i, n)
          return
        }
      throw new TypeError(
        `Property ${i} of ${r.type} expected node to be of a type ${JSON.stringify(t)} but instead got ${JSON.stringify(
          n == null ? void 0 : n.type
        )}`
      )
    }
    return (e.oneOfNodeOrValueTypes = t), e
  }
  function uu(t) {
    function e(r, i, n) {
      if (!(va(n) === t)) throw new TypeError(`Property ${i} expected type of ${t} but got ${va(n)}`)
    }
    return (e.type = t), e
  }
  function KA(t) {
    function e(r, i, n) {
      const s = []
      for (const a of Object.keys(t))
        try {
          ;(0, ba.validateField)(r, a, n[a], t[a])
        } catch (o) {
          if (o instanceof TypeError) {
            s.push(o.message)
            continue
          }
          throw o
        }
      if (s.length)
        throw new TypeError(`Property ${i} of ${r.type} expected to have the following:
${s.join(`
`)}`)
    }
    return (e.shapeOf = t), e
  }
  function WA() {
    function t(e) {
      var r
      let i = e
      for (; e; ) {
        const { type: n } = i
        if (n === 'OptionalCallExpression') {
          if (i.optional) return
          i = i.callee
          continue
        }
        if (n === 'OptionalMemberExpression') {
          if (i.optional) return
          i = i.object
          continue
        }
        break
      }
      throw new TypeError(
        `Non-optional ${
          e.type
        } must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${
          (r = i) == null ? void 0 : r.type
        }`
      )
    }
    return t
  }
  function Id(...t) {
    function e(...r) {
      for (const i of t) i(...r)
    }
    if (((e.chainOf = t), t.length >= 2 && 'type' in t[0] && t[0].type === 'array' && !('each' in t[1])))
      throw new Error('An assertValueType("array") validator can only be followed by an assertEach(...) validator.')
    return e
  }
  const YA = ['aliases', 'builder', 'deprecatedAlias', 'fields', 'inherits', 'visitor', 'validate'],
    HA = ['default', 'optional', 'validate']
  function qA(...t) {
    return (e, r = {}) => {
      let i = r.aliases
      if (!i) {
        var n, s
        r.inherits && (i = (n = cu[r.inherits].aliases) == null ? void 0 : n.slice()),
          (s = i) != null || (i = []),
          (r.aliases = i)
      }
      const a = t.filter((o) => !i.includes(o))
      return i.unshift(...a), kd(e, r)
    }
  }
  function kd(t, e = {}) {
    const r = (e.inherits && cu[e.inherits]) || {}
    let i = e.fields
    if (!i && ((i = {}), r.fields)) {
      const o = Object.getOwnPropertyNames(r.fields)
      for (const u of o) {
        const c = r.fields[u],
          p = c.default
        if (Array.isArray(p) ? p.length > 0 : p && typeof p == 'object')
          throw new Error('field defaults can only be primitives or empty arrays currently')
        i[u] = { default: Array.isArray(p) ? [] : p, optional: c.optional, validate: c.validate }
      }
    }
    const n = e.visitor || r.visitor || [],
      s = e.aliases || r.aliases || [],
      a = e.builder || r.builder || e.visitor || []
    for (const o of Object.keys(e)) if (YA.indexOf(o) === -1) throw new Error(`Unknown type option "${o}" on ${t}`)
    e.deprecatedAlias && (Pd[e.deprecatedAlias] = t)
    for (const o of n.concat(a)) i[o] = i[o] || {}
    for (const o of Object.keys(i)) {
      const u = i[o]
      u.default !== void 0 && a.indexOf(o) === -1 && (u.optional = !0),
        u.default === void 0 ? (u.default = null) : !u.validate && u.default != null && (u.validate = uu(va(u.default)))
      for (const c of Object.keys(u)) if (HA.indexOf(c) === -1) throw new Error(`Unknown field key "${c}" on ${t}.${o}`)
    }
    ;(bd[t] = e.visitor = n),
      (Ed[t] = e.builder = a),
      (vd[t] = e.fields = i),
      (Sd[t] = e.aliases = s),
      s.forEach((o) => {
        ;(Sa[o] = Sa[o] || []), Sa[o].push(t)
      }),
      e.validate && (wd[t] = e.validate),
      (cu[t] = e)
  }
  const cu = {}
  Object.defineProperty(ir, '__esModule', { value: !0 }),
    (ir.patternLikeCommon =
      ir.functionTypeAnnotationCommon =
      ir.functionDeclarationCommon =
      ir.functionCommon =
      ir.classMethodOrPropertyCommon =
      ir.classMethodOrDeclareMethodCommon =
        void 0)
  var Jt = Vi,
    XA = Ui,
    Nd = ps,
    hs = Je,
    k = tt
  const Ie = (0, k.defineAliasedType)('Standardized')
  Ie('ArrayExpression', {
    fields: {
      elements: {
        validate: (0, k.chain)(
          (0, k.assertValueType)('array'),
          (0, k.assertEach)((0, k.assertNodeOrValueType)('null', 'Expression', 'SpreadElement'))
        ),
        default: {}.BABEL_TYPES_8_BREAKING ? void 0 : [],
      },
    },
    visitor: ['elements'],
    aliases: ['Expression'],
  }),
    Ie('AssignmentExpression', {
      fields: {
        operator: {
          validate: (function () {
            if (!{}.BABEL_TYPES_8_BREAKING) return (0, k.assertValueType)('string')
            const t = (0, k.assertOneOf)(...hs.ASSIGNMENT_OPERATORS),
              e = (0, k.assertOneOf)('=')
            return function (r, i, n) {
              ;((0, Jt.default)('Pattern', r.left) ? e : t)(r, i, n)
            }
          })(),
        },
        left: {
          validate: {}.BABEL_TYPES_8_BREAKING
            ? (0, k.assertNodeType)(
                'Identifier',
                'MemberExpression',
                'ArrayPattern',
                'ObjectPattern',
                'TSAsExpression',
                'TSTypeAssertion',
                'TSNonNullExpression'
              )
            : (0, k.assertNodeType)('LVal'),
        },
        right: { validate: (0, k.assertNodeType)('Expression') },
      },
      builder: ['operator', 'left', 'right'],
      visitor: ['left', 'right'],
      aliases: ['Expression'],
    }),
    Ie('BinaryExpression', {
      builder: ['operator', 'left', 'right'],
      fields: {
        operator: { validate: (0, k.assertOneOf)(...hs.BINARY_OPERATORS) },
        left: {
          validate: (function () {
            const t = (0, k.assertNodeType)('Expression'),
              e = (0, k.assertNodeType)('Expression', 'PrivateName'),
              r = function (i, n, s) {
                ;(i.operator === 'in' ? e : t)(i, n, s)
              }
            return (r.oneOfNodeTypes = ['Expression', 'PrivateName']), r
          })(),
        },
        right: { validate: (0, k.assertNodeType)('Expression') },
      },
      visitor: ['left', 'right'],
      aliases: ['Binary', 'Expression'],
    }),
    Ie('InterpreterDirective', {
      builder: ['value'],
      fields: { value: { validate: (0, k.assertValueType)('string') } },
    }),
    Ie('Directive', { visitor: ['value'], fields: { value: { validate: (0, k.assertNodeType)('DirectiveLiteral') } } }),
    Ie('DirectiveLiteral', { builder: ['value'], fields: { value: { validate: (0, k.assertValueType)('string') } } }),
    Ie('BlockStatement', {
      builder: ['body', 'directives'],
      visitor: ['directives', 'body'],
      fields: {
        directives: {
          validate: (0, k.chain)(
            (0, k.assertValueType)('array'),
            (0, k.assertEach)((0, k.assertNodeType)('Directive'))
          ),
          default: [],
        },
        body: {
          validate: (0, k.chain)(
            (0, k.assertValueType)('array'),
            (0, k.assertEach)((0, k.assertNodeType)('Statement'))
          ),
        },
      },
      aliases: ['Scopable', 'BlockParent', 'Block', 'Statement'],
    }),
    Ie('BreakStatement', {
      visitor: ['label'],
      fields: { label: { validate: (0, k.assertNodeType)('Identifier'), optional: !0 } },
      aliases: ['Statement', 'Terminatorless', 'CompletionStatement'],
    }),
    Ie('CallExpression', {
      visitor: ['callee', 'arguments', 'typeParameters', 'typeArguments'],
      builder: ['callee', 'arguments'],
      aliases: ['Expression'],
      fields: Object.assign(
        {
          callee: { validate: (0, k.assertNodeType)('Expression', 'V8IntrinsicIdentifier') },
          arguments: {
            validate: (0, k.chain)(
              (0, k.assertValueType)('array'),
              (0, k.assertEach)(
                (0, k.assertNodeType)('Expression', 'SpreadElement', 'JSXNamespacedName', 'ArgumentPlaceholder')
              )
            ),
          },
        },
        {}.BABEL_TYPES_8_BREAKING ? {} : { optional: { validate: (0, k.assertOneOf)(!0, !1), optional: !0 } },
        {
          typeArguments: { validate: (0, k.assertNodeType)('TypeParameterInstantiation'), optional: !0 },
          typeParameters: { validate: (0, k.assertNodeType)('TSTypeParameterInstantiation'), optional: !0 },
        }
      ),
    }),
    Ie('CatchClause', {
      visitor: ['param', 'body'],
      fields: {
        param: { validate: (0, k.assertNodeType)('Identifier', 'ArrayPattern', 'ObjectPattern'), optional: !0 },
        body: { validate: (0, k.assertNodeType)('BlockStatement') },
      },
      aliases: ['Scopable', 'BlockParent'],
    }),
    Ie('ConditionalExpression', {
      visitor: ['test', 'consequent', 'alternate'],
      fields: {
        test: { validate: (0, k.assertNodeType)('Expression') },
        consequent: { validate: (0, k.assertNodeType)('Expression') },
        alternate: { validate: (0, k.assertNodeType)('Expression') },
      },
      aliases: ['Expression', 'Conditional'],
    }),
    Ie('ContinueStatement', {
      visitor: ['label'],
      fields: { label: { validate: (0, k.assertNodeType)('Identifier'), optional: !0 } },
      aliases: ['Statement', 'Terminatorless', 'CompletionStatement'],
    }),
    Ie('DebuggerStatement', { aliases: ['Statement'] }),
    Ie('DoWhileStatement', {
      visitor: ['test', 'body'],
      fields: {
        test: { validate: (0, k.assertNodeType)('Expression') },
        body: { validate: (0, k.assertNodeType)('Statement') },
      },
      aliases: ['Statement', 'BlockParent', 'Loop', 'While', 'Scopable'],
    }),
    Ie('EmptyStatement', { aliases: ['Statement'] }),
    Ie('ExpressionStatement', {
      visitor: ['expression'],
      fields: { expression: { validate: (0, k.assertNodeType)('Expression') } },
      aliases: ['Statement', 'ExpressionWrapper'],
    }),
    Ie('File', {
      builder: ['program', 'comments', 'tokens'],
      visitor: ['program'],
      fields: {
        program: { validate: (0, k.assertNodeType)('Program') },
        comments: {
          validate: {}.BABEL_TYPES_8_BREAKING
            ? (0, k.assertEach)((0, k.assertNodeType)('CommentBlock', 'CommentLine'))
            : Object.assign(() => {}, { each: { oneOfNodeTypes: ['CommentBlock', 'CommentLine'] } }),
          optional: !0,
        },
        tokens: { validate: (0, k.assertEach)(Object.assign(() => {}, { type: 'any' })), optional: !0 },
      },
    }),
    Ie('ForInStatement', {
      visitor: ['left', 'right', 'body'],
      aliases: ['Scopable', 'Statement', 'For', 'BlockParent', 'Loop', 'ForXStatement'],
      fields: {
        left: {
          validate: {}.BABEL_TYPES_8_BREAKING
            ? (0, k.assertNodeType)(
                'VariableDeclaration',
                'Identifier',
                'MemberExpression',
                'ArrayPattern',
                'ObjectPattern',
                'TSAsExpression',
                'TSTypeAssertion',
                'TSNonNullExpression'
              )
            : (0, k.assertNodeType)('VariableDeclaration', 'LVal'),
        },
        right: { validate: (0, k.assertNodeType)('Expression') },
        body: { validate: (0, k.assertNodeType)('Statement') },
      },
    }),
    Ie('ForStatement', {
      visitor: ['init', 'test', 'update', 'body'],
      aliases: ['Scopable', 'Statement', 'For', 'BlockParent', 'Loop'],
      fields: {
        init: { validate: (0, k.assertNodeType)('VariableDeclaration', 'Expression'), optional: !0 },
        test: { validate: (0, k.assertNodeType)('Expression'), optional: !0 },
        update: { validate: (0, k.assertNodeType)('Expression'), optional: !0 },
        body: { validate: (0, k.assertNodeType)('Statement') },
      },
    })
  const bn = {
    params: {
      validate: (0, k.chain)(
        (0, k.assertValueType)('array'),
        (0, k.assertEach)((0, k.assertNodeType)('Identifier', 'Pattern', 'RestElement'))
      ),
    },
    generator: { default: !1 },
    async: { default: !1 },
  }
  ir.functionCommon = bn
  const Ki = {
    returnType: { validate: (0, k.assertNodeType)('TypeAnnotation', 'TSTypeAnnotation', 'Noop'), optional: !0 },
    typeParameters: {
      validate: (0, k.assertNodeType)('TypeParameterDeclaration', 'TSTypeParameterDeclaration', 'Noop'),
      optional: !0,
    },
  }
  ir.functionTypeAnnotationCommon = Ki
  const Od = Object.assign({}, bn, {
    declare: { validate: (0, k.assertValueType)('boolean'), optional: !0 },
    id: { validate: (0, k.assertNodeType)('Identifier'), optional: !0 },
  })
  ;(ir.functionDeclarationCommon = Od),
    Ie('FunctionDeclaration', {
      builder: ['id', 'params', 'body', 'generator', 'async'],
      visitor: ['id', 'params', 'body', 'returnType', 'typeParameters'],
      fields: Object.assign({}, Od, Ki, {
        body: { validate: (0, k.assertNodeType)('BlockStatement') },
        predicate: { validate: (0, k.assertNodeType)('DeclaredPredicate', 'InferredPredicate'), optional: !0 },
      }),
      aliases: ['Scopable', 'Function', 'BlockParent', 'FunctionParent', 'Statement', 'Pureish', 'Declaration'],
      validate: (function () {
        if (!{}.BABEL_TYPES_8_BREAKING) return () => {}
        const t = (0, k.assertNodeType)('Identifier')
        return function (e, r, i) {
          ;(0, Jt.default)('ExportDefaultDeclaration', e) || t(i, 'id', i.id)
        }
      })(),
    }),
    Ie('FunctionExpression', {
      inherits: 'FunctionDeclaration',
      aliases: ['Scopable', 'Function', 'BlockParent', 'FunctionParent', 'Expression', 'Pureish'],
      fields: Object.assign({}, bn, Ki, {
        id: { validate: (0, k.assertNodeType)('Identifier'), optional: !0 },
        body: { validate: (0, k.assertNodeType)('BlockStatement') },
        predicate: { validate: (0, k.assertNodeType)('DeclaredPredicate', 'InferredPredicate'), optional: !0 },
      }),
    })
  const Sn = {
    typeAnnotation: { validate: (0, k.assertNodeType)('TypeAnnotation', 'TSTypeAnnotation', 'Noop'), optional: !0 },
    decorators: {
      validate: (0, k.chain)((0, k.assertValueType)('array'), (0, k.assertEach)((0, k.assertNodeType)('Decorator'))),
    },
  }
  ;(ir.patternLikeCommon = Sn),
    Ie('Identifier', {
      builder: ['name'],
      visitor: ['typeAnnotation', 'decorators'],
      aliases: ['Expression', 'PatternLike', 'LVal', 'TSEntityName'],
      fields: Object.assign({}, Sn, {
        name: {
          validate: (0, k.chain)(
            (0, k.assertValueType)('string'),
            Object.assign(
              function (t, e, r) {
                if (!!{}.BABEL_TYPES_8_BREAKING && !(0, XA.default)(r, !1))
                  throw new TypeError(`"${r}" is not a valid identifier name`)
              },
              { type: 'string' }
            )
          ),
        },
        optional: { validate: (0, k.assertValueType)('boolean'), optional: !0 },
      }),
      validate(t, e, r) {
        if (!{}.BABEL_TYPES_8_BREAKING) return
        const i = /\.(\w+)$/.exec(e)
        if (!i) return
        const [, n] = i,
          s = { computed: !1 }
        if (n === 'property') {
          if ((0, Jt.default)('MemberExpression', t, s) || (0, Jt.default)('OptionalMemberExpression', t, s)) return
        } else if (n === 'key') {
          if ((0, Jt.default)('Property', t, s) || (0, Jt.default)('Method', t, s)) return
        } else if (n === 'exported') {
          if ((0, Jt.default)('ExportSpecifier', t)) return
        } else if (n === 'imported') {
          if ((0, Jt.default)('ImportSpecifier', t, { imported: r })) return
        } else if (n === 'meta' && (0, Jt.default)('MetaProperty', t, { meta: r })) return
        if (((0, Nd.isKeyword)(r.name) || (0, Nd.isReservedWord)(r.name, !1)) && r.name !== 'this')
          throw new TypeError(`"${r.name}" is not a valid identifier`)
      },
    }),
    Ie('IfStatement', {
      visitor: ['test', 'consequent', 'alternate'],
      aliases: ['Statement', 'Conditional'],
      fields: {
        test: { validate: (0, k.assertNodeType)('Expression') },
        consequent: { validate: (0, k.assertNodeType)('Statement') },
        alternate: { optional: !0, validate: (0, k.assertNodeType)('Statement') },
      },
    }),
    Ie('LabeledStatement', {
      visitor: ['label', 'body'],
      aliases: ['Statement'],
      fields: {
        label: { validate: (0, k.assertNodeType)('Identifier') },
        body: { validate: (0, k.assertNodeType)('Statement') },
      },
    }),
    Ie('StringLiteral', {
      builder: ['value'],
      fields: { value: { validate: (0, k.assertValueType)('string') } },
      aliases: ['Expression', 'Pureish', 'Literal', 'Immutable'],
    }),
    Ie('NumericLiteral', {
      builder: ['value'],
      deprecatedAlias: 'NumberLiteral',
      fields: { value: { validate: (0, k.assertValueType)('number') } },
      aliases: ['Expression', 'Pureish', 'Literal', 'Immutable'],
    }),
    Ie('NullLiteral', { aliases: ['Expression', 'Pureish', 'Literal', 'Immutable'] }),
    Ie('BooleanLiteral', {
      builder: ['value'],
      fields: { value: { validate: (0, k.assertValueType)('boolean') } },
      aliases: ['Expression', 'Pureish', 'Literal', 'Immutable'],
    }),
    Ie('RegExpLiteral', {
      builder: ['pattern', 'flags'],
      deprecatedAlias: 'RegexLiteral',
      aliases: ['Expression', 'Pureish', 'Literal'],
      fields: {
        pattern: { validate: (0, k.assertValueType)('string') },
        flags: {
          validate: (0, k.chain)(
            (0, k.assertValueType)('string'),
            Object.assign(
              function (t, e, r) {
                if (!{}.BABEL_TYPES_8_BREAKING) return
                const i = /[^gimsuy]/.exec(r)
                if (i) throw new TypeError(`"${i[0]}" is not a valid RegExp flag`)
              },
              { type: 'string' }
            )
          ),
          default: '',
        },
      },
    }),
    Ie('LogicalExpression', {
      builder: ['operator', 'left', 'right'],
      visitor: ['left', 'right'],
      aliases: ['Binary', 'Expression'],
      fields: {
        operator: { validate: (0, k.assertOneOf)(...hs.LOGICAL_OPERATORS) },
        left: { validate: (0, k.assertNodeType)('Expression') },
        right: { validate: (0, k.assertNodeType)('Expression') },
      },
    }),
    Ie('MemberExpression', {
      builder: ['object', 'property', 'computed', ...({}.BABEL_TYPES_8_BREAKING ? [] : ['optional'])],
      visitor: ['object', 'property'],
      aliases: ['Expression', 'LVal'],
      fields: Object.assign(
        {
          object: { validate: (0, k.assertNodeType)('Expression') },
          property: {
            validate: (function () {
              const t = (0, k.assertNodeType)('Identifier', 'PrivateName'),
                e = (0, k.assertNodeType)('Expression'),
                r = function (i, n, s) {
                  ;(i.computed ? e : t)(i, n, s)
                }
              return (r.oneOfNodeTypes = ['Expression', 'Identifier', 'PrivateName']), r
            })(),
          },
          computed: { default: !1 },
        },
        {}.BABEL_TYPES_8_BREAKING ? {} : { optional: { validate: (0, k.assertOneOf)(!0, !1), optional: !0 } }
      ),
    }),
    Ie('NewExpression', { inherits: 'CallExpression' }),
    Ie('Program', {
      visitor: ['directives', 'body'],
      builder: ['body', 'directives', 'sourceType', 'interpreter'],
      fields: {
        sourceFile: { validate: (0, k.assertValueType)('string') },
        sourceType: { validate: (0, k.assertOneOf)('script', 'module'), default: 'script' },
        interpreter: { validate: (0, k.assertNodeType)('InterpreterDirective'), default: null, optional: !0 },
        directives: {
          validate: (0, k.chain)(
            (0, k.assertValueType)('array'),
            (0, k.assertEach)((0, k.assertNodeType)('Directive'))
          ),
          default: [],
        },
        body: {
          validate: (0, k.chain)(
            (0, k.assertValueType)('array'),
            (0, k.assertEach)((0, k.assertNodeType)('Statement'))
          ),
        },
      },
      aliases: ['Scopable', 'BlockParent', 'Block'],
    }),
    Ie('ObjectExpression', {
      visitor: ['properties'],
      aliases: ['Expression'],
      fields: {
        properties: {
          validate: (0, k.chain)(
            (0, k.assertValueType)('array'),
            (0, k.assertEach)((0, k.assertNodeType)('ObjectMethod', 'ObjectProperty', 'SpreadElement'))
          ),
        },
      },
    }),
    Ie('ObjectMethod', {
      builder: ['kind', 'key', 'params', 'body', 'computed', 'generator', 'async'],
      fields: Object.assign({}, bn, Ki, {
        kind: Object.assign(
          { validate: (0, k.assertOneOf)('method', 'get', 'set') },
          {}.BABEL_TYPES_8_BREAKING ? {} : { default: 'method' }
        ),
        computed: { default: !1 },
        key: {
          validate: (function () {
            const t = (0, k.assertNodeType)('Identifier', 'StringLiteral', 'NumericLiteral'),
              e = (0, k.assertNodeType)('Expression'),
              r = function (i, n, s) {
                ;(i.computed ? e : t)(i, n, s)
              }
            return (r.oneOfNodeTypes = ['Expression', 'Identifier', 'StringLiteral', 'NumericLiteral']), r
          })(),
        },
        decorators: {
          validate: (0, k.chain)(
            (0, k.assertValueType)('array'),
            (0, k.assertEach)((0, k.assertNodeType)('Decorator'))
          ),
          optional: !0,
        },
        body: { validate: (0, k.assertNodeType)('BlockStatement') },
      }),
      visitor: ['key', 'params', 'body', 'decorators', 'returnType', 'typeParameters'],
      aliases: ['UserWhitespacable', 'Function', 'Scopable', 'BlockParent', 'FunctionParent', 'Method', 'ObjectMember'],
    }),
    Ie('ObjectProperty', {
      builder: ['key', 'value', 'computed', 'shorthand', ...({}.BABEL_TYPES_8_BREAKING ? [] : ['decorators'])],
      fields: {
        computed: { default: !1 },
        key: {
          validate: (function () {
            const t = (0, k.assertNodeType)(
                'Identifier',
                'StringLiteral',
                'NumericLiteral',
                'BigIntLiteral',
                'DecimalLiteral',
                'PrivateName'
              ),
              e = (0, k.assertNodeType)('Expression'),
              r = function (i, n, s) {
                ;(i.computed ? e : t)(i, n, s)
              }
            return (
              (r.oneOfNodeTypes = [
                'Expression',
                'Identifier',
                'StringLiteral',
                'NumericLiteral',
                'BigIntLiteral',
                'DecimalLiteral',
                'PrivateName',
              ]),
              r
            )
          })(),
        },
        value: { validate: (0, k.assertNodeType)('Expression', 'PatternLike') },
        shorthand: {
          validate: (0, k.chain)(
            (0, k.assertValueType)('boolean'),
            Object.assign(
              function (t, e, r) {
                if (!!{}.BABEL_TYPES_8_BREAKING && r && t.computed)
                  throw new TypeError('Property shorthand of ObjectProperty cannot be true if computed is true')
              },
              { type: 'boolean' }
            ),
            function (t, e, r) {
              if (!!{}.BABEL_TYPES_8_BREAKING && r && !(0, Jt.default)('Identifier', t.key))
                throw new TypeError('Property shorthand of ObjectProperty cannot be true if key is not an Identifier')
            }
          ),
          default: !1,
        },
        decorators: {
          validate: (0, k.chain)(
            (0, k.assertValueType)('array'),
            (0, k.assertEach)((0, k.assertNodeType)('Decorator'))
          ),
          optional: !0,
        },
      },
      visitor: ['key', 'value', 'decorators'],
      aliases: ['UserWhitespacable', 'Property', 'ObjectMember'],
      validate: (function () {
        const t = (0, k.assertNodeType)(
            'Identifier',
            'Pattern',
            'TSAsExpression',
            'TSNonNullExpression',
            'TSTypeAssertion'
          ),
          e = (0, k.assertNodeType)('Expression')
        return function (r, i, n) {
          if (!{}.BABEL_TYPES_8_BREAKING) return
          ;((0, Jt.default)('ObjectPattern', r) ? t : e)(n, 'value', n.value)
        }
      })(),
    }),
    Ie('RestElement', {
      visitor: ['argument', 'typeAnnotation'],
      builder: ['argument'],
      aliases: ['LVal', 'PatternLike'],
      deprecatedAlias: 'RestProperty',
      fields: Object.assign({}, Sn, {
        argument: {
          validate: {}.BABEL_TYPES_8_BREAKING
            ? (0, k.assertNodeType)(
                'Identifier',
                'ArrayPattern',
                'ObjectPattern',
                'MemberExpression',
                'TSAsExpression',
                'TSTypeAssertion',
                'TSNonNullExpression'
              )
            : (0, k.assertNodeType)('LVal'),
        },
        optional: { validate: (0, k.assertValueType)('boolean'), optional: !0 },
      }),
      validate(t, e) {
        if (!{}.BABEL_TYPES_8_BREAKING) return
        const r = /(\w+)\[(\d+)\]/.exec(e)
        if (!r) throw new Error('Internal Babel error: malformed key.')
        const [, i, n] = r
        if (t[i].length > n + 1) throw new TypeError(`RestElement must be last element of ${i}`)
      },
    }),
    Ie('ReturnStatement', {
      visitor: ['argument'],
      aliases: ['Statement', 'Terminatorless', 'CompletionStatement'],
      fields: { argument: { validate: (0, k.assertNodeType)('Expression'), optional: !0 } },
    }),
    Ie('SequenceExpression', {
      visitor: ['expressions'],
      fields: {
        expressions: {
          validate: (0, k.chain)(
            (0, k.assertValueType)('array'),
            (0, k.assertEach)((0, k.assertNodeType)('Expression'))
          ),
        },
      },
      aliases: ['Expression'],
    }),
    Ie('ParenthesizedExpression', {
      visitor: ['expression'],
      aliases: ['Expression', 'ExpressionWrapper'],
      fields: { expression: { validate: (0, k.assertNodeType)('Expression') } },
    }),
    Ie('SwitchCase', {
      visitor: ['test', 'consequent'],
      fields: {
        test: { validate: (0, k.assertNodeType)('Expression'), optional: !0 },
        consequent: {
          validate: (0, k.chain)(
            (0, k.assertValueType)('array'),
            (0, k.assertEach)((0, k.assertNodeType)('Statement'))
          ),
        },
      },
    }),
    Ie('SwitchStatement', {
      visitor: ['discriminant', 'cases'],
      aliases: ['Statement', 'BlockParent', 'Scopable'],
      fields: {
        discriminant: { validate: (0, k.assertNodeType)('Expression') },
        cases: {
          validate: (0, k.chain)(
            (0, k.assertValueType)('array'),
            (0, k.assertEach)((0, k.assertNodeType)('SwitchCase'))
          ),
        },
      },
    }),
    Ie('ThisExpression', { aliases: ['Expression'] }),
    Ie('ThrowStatement', {
      visitor: ['argument'],
      aliases: ['Statement', 'Terminatorless', 'CompletionStatement'],
      fields: { argument: { validate: (0, k.assertNodeType)('Expression') } },
    }),
    Ie('TryStatement', {
      visitor: ['block', 'handler', 'finalizer'],
      aliases: ['Statement'],
      fields: {
        block: {
          validate: (0, k.chain)(
            (0, k.assertNodeType)('BlockStatement'),
            Object.assign(
              function (t) {
                if (!!{}.BABEL_TYPES_8_BREAKING && !t.handler && !t.finalizer)
                  throw new TypeError('TryStatement expects either a handler or finalizer, or both')
              },
              { oneOfNodeTypes: ['BlockStatement'] }
            )
          ),
        },
        handler: { optional: !0, validate: (0, k.assertNodeType)('CatchClause') },
        finalizer: { optional: !0, validate: (0, k.assertNodeType)('BlockStatement') },
      },
    }),
    Ie('UnaryExpression', {
      builder: ['operator', 'argument', 'prefix'],
      fields: {
        prefix: { default: !0 },
        argument: { validate: (0, k.assertNodeType)('Expression') },
        operator: { validate: (0, k.assertOneOf)(...hs.UNARY_OPERATORS) },
      },
      visitor: ['argument'],
      aliases: ['UnaryLike', 'Expression'],
    }),
    Ie('UpdateExpression', {
      builder: ['operator', 'argument', 'prefix'],
      fields: {
        prefix: { default: !1 },
        argument: {
          validate: {}.BABEL_TYPES_8_BREAKING
            ? (0, k.assertNodeType)('Identifier', 'MemberExpression')
            : (0, k.assertNodeType)('Expression'),
        },
        operator: { validate: (0, k.assertOneOf)(...hs.UPDATE_OPERATORS) },
      },
      visitor: ['argument'],
      aliases: ['Expression'],
    }),
    Ie('VariableDeclaration', {
      builder: ['kind', 'declarations'],
      visitor: ['declarations'],
      aliases: ['Statement', 'Declaration'],
      fields: {
        declare: { validate: (0, k.assertValueType)('boolean'), optional: !0 },
        kind: { validate: (0, k.assertOneOf)('var', 'let', 'const') },
        declarations: {
          validate: (0, k.chain)(
            (0, k.assertValueType)('array'),
            (0, k.assertEach)((0, k.assertNodeType)('VariableDeclarator'))
          ),
        },
      },
      validate(t, e, r) {
        if (
          !!{}.BABEL_TYPES_8_BREAKING &&
          !!(0, Jt.default)('ForXStatement', t, { left: r }) &&
          r.declarations.length !== 1
        )
          throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${t.type}`)
      },
    }),
    Ie('VariableDeclarator', {
      visitor: ['id', 'init'],
      fields: {
        id: {
          validate: (function () {
            if (!{}.BABEL_TYPES_8_BREAKING) return (0, k.assertNodeType)('LVal')
            const t = (0, k.assertNodeType)('Identifier', 'ArrayPattern', 'ObjectPattern'),
              e = (0, k.assertNodeType)('Identifier')
            return function (r, i, n) {
              ;(r.init ? t : e)(r, i, n)
            }
          })(),
        },
        definite: { optional: !0, validate: (0, k.assertValueType)('boolean') },
        init: { optional: !0, validate: (0, k.assertNodeType)('Expression') },
      },
    }),
    Ie('WhileStatement', {
      visitor: ['test', 'body'],
      aliases: ['Statement', 'BlockParent', 'Loop', 'While', 'Scopable'],
      fields: {
        test: { validate: (0, k.assertNodeType)('Expression') },
        body: { validate: (0, k.assertNodeType)('Statement') },
      },
    }),
    Ie('WithStatement', {
      visitor: ['object', 'body'],
      aliases: ['Statement'],
      fields: {
        object: { validate: (0, k.assertNodeType)('Expression') },
        body: { validate: (0, k.assertNodeType)('Statement') },
      },
    }),
    Ie('AssignmentPattern', {
      visitor: ['left', 'right', 'decorators'],
      builder: ['left', 'right'],
      aliases: ['Pattern', 'PatternLike', 'LVal'],
      fields: Object.assign({}, Sn, {
        left: {
          validate: (0, k.assertNodeType)(
            'Identifier',
            'ObjectPattern',
            'ArrayPattern',
            'MemberExpression',
            'TSAsExpression',
            'TSTypeAssertion',
            'TSNonNullExpression'
          ),
        },
        right: { validate: (0, k.assertNodeType)('Expression') },
        decorators: {
          validate: (0, k.chain)(
            (0, k.assertValueType)('array'),
            (0, k.assertEach)((0, k.assertNodeType)('Decorator'))
          ),
          optional: !0,
        },
      }),
    }),
    Ie('ArrayPattern', {
      visitor: ['elements', 'typeAnnotation'],
      builder: ['elements'],
      aliases: ['Pattern', 'PatternLike', 'LVal'],
      fields: Object.assign({}, Sn, {
        elements: {
          validate: (0, k.chain)(
            (0, k.assertValueType)('array'),
            (0, k.assertEach)((0, k.assertNodeOrValueType)('null', 'PatternLike'))
          ),
        },
        decorators: {
          validate: (0, k.chain)(
            (0, k.assertValueType)('array'),
            (0, k.assertEach)((0, k.assertNodeType)('Decorator'))
          ),
          optional: !0,
        },
        optional: { validate: (0, k.assertValueType)('boolean'), optional: !0 },
      }),
    }),
    Ie('ArrowFunctionExpression', {
      builder: ['params', 'body', 'async'],
      visitor: ['params', 'body', 'returnType', 'typeParameters'],
      aliases: ['Scopable', 'Function', 'BlockParent', 'FunctionParent', 'Expression', 'Pureish'],
      fields: Object.assign({}, bn, Ki, {
        expression: { validate: (0, k.assertValueType)('boolean') },
        body: { validate: (0, k.assertNodeType)('BlockStatement', 'Expression') },
        predicate: { validate: (0, k.assertNodeType)('DeclaredPredicate', 'InferredPredicate'), optional: !0 },
      }),
    }),
    Ie('ClassBody', {
      visitor: ['body'],
      fields: {
        body: {
          validate: (0, k.chain)(
            (0, k.assertValueType)('array'),
            (0, k.assertEach)(
              (0, k.assertNodeType)(
                'ClassMethod',
                'ClassPrivateMethod',
                'ClassProperty',
                'ClassPrivateProperty',
                'ClassAccessorProperty',
                'TSDeclareMethod',
                'TSIndexSignature',
                'StaticBlock'
              )
            )
          ),
        },
      },
    }),
    Ie('ClassExpression', {
      builder: ['id', 'superClass', 'body', 'decorators'],
      visitor: [
        'id',
        'body',
        'superClass',
        'mixins',
        'typeParameters',
        'superTypeParameters',
        'implements',
        'decorators',
      ],
      aliases: ['Scopable', 'Class', 'Expression'],
      fields: {
        id: { validate: (0, k.assertNodeType)('Identifier'), optional: !0 },
        typeParameters: {
          validate: (0, k.assertNodeType)('TypeParameterDeclaration', 'TSTypeParameterDeclaration', 'Noop'),
          optional: !0,
        },
        body: { validate: (0, k.assertNodeType)('ClassBody') },
        superClass: { optional: !0, validate: (0, k.assertNodeType)('Expression') },
        superTypeParameters: {
          validate: (0, k.assertNodeType)('TypeParameterInstantiation', 'TSTypeParameterInstantiation'),
          optional: !0,
        },
        implements: {
          validate: (0, k.chain)(
            (0, k.assertValueType)('array'),
            (0, k.assertEach)((0, k.assertNodeType)('TSExpressionWithTypeArguments', 'ClassImplements'))
          ),
          optional: !0,
        },
        decorators: {
          validate: (0, k.chain)(
            (0, k.assertValueType)('array'),
            (0, k.assertEach)((0, k.assertNodeType)('Decorator'))
          ),
          optional: !0,
        },
        mixins: { validate: (0, k.assertNodeType)('InterfaceExtends'), optional: !0 },
      },
    }),
    Ie('ClassDeclaration', {
      inherits: 'ClassExpression',
      aliases: ['Scopable', 'Class', 'Statement', 'Declaration'],
      fields: {
        id: { validate: (0, k.assertNodeType)('Identifier') },
        typeParameters: {
          validate: (0, k.assertNodeType)('TypeParameterDeclaration', 'TSTypeParameterDeclaration', 'Noop'),
          optional: !0,
        },
        body: { validate: (0, k.assertNodeType)('ClassBody') },
        superClass: { optional: !0, validate: (0, k.assertNodeType)('Expression') },
        superTypeParameters: {
          validate: (0, k.assertNodeType)('TypeParameterInstantiation', 'TSTypeParameterInstantiation'),
          optional: !0,
        },
        implements: {
          validate: (0, k.chain)(
            (0, k.assertValueType)('array'),
            (0, k.assertEach)((0, k.assertNodeType)('TSExpressionWithTypeArguments', 'ClassImplements'))
          ),
          optional: !0,
        },
        decorators: {
          validate: (0, k.chain)(
            (0, k.assertValueType)('array'),
            (0, k.assertEach)((0, k.assertNodeType)('Decorator'))
          ),
          optional: !0,
        },
        mixins: { validate: (0, k.assertNodeType)('InterfaceExtends'), optional: !0 },
        declare: { validate: (0, k.assertValueType)('boolean'), optional: !0 },
        abstract: { validate: (0, k.assertValueType)('boolean'), optional: !0 },
      },
      validate: (function () {
        const t = (0, k.assertNodeType)('Identifier')
        return function (e, r, i) {
          !{}.BABEL_TYPES_8_BREAKING || (0, Jt.default)('ExportDefaultDeclaration', e) || t(i, 'id', i.id)
        }
      })(),
    }),
    Ie('ExportAllDeclaration', {
      visitor: ['source'],
      aliases: ['Statement', 'Declaration', 'ModuleDeclaration', 'ExportDeclaration'],
      fields: {
        source: { validate: (0, k.assertNodeType)('StringLiteral') },
        exportKind: (0, k.validateOptional)((0, k.assertOneOf)('type', 'value')),
        assertions: {
          optional: !0,
          validate: (0, k.chain)(
            (0, k.assertValueType)('array'),
            (0, k.assertEach)((0, k.assertNodeType)('ImportAttribute'))
          ),
        },
      },
    }),
    Ie('ExportDefaultDeclaration', {
      visitor: ['declaration'],
      aliases: ['Statement', 'Declaration', 'ModuleDeclaration', 'ExportDeclaration'],
      fields: {
        declaration: { validate: (0, k.assertNodeType)('FunctionDeclaration', 'ClassDeclaration', 'Expression') },
        exportKind: (0, k.validateOptional)((0, k.assertOneOf)('value')),
      },
    }),
    Ie('ExportNamedDeclaration', {
      visitor: ['declaration', 'specifiers', 'source'],
      aliases: ['Statement', 'Declaration', 'ModuleDeclaration', 'ExportDeclaration'],
      fields: {
        declaration: {
          optional: !0,
          validate: (0, k.chain)(
            (0, k.assertNodeType)('Declaration'),
            Object.assign(
              function (t, e, r) {
                if (!!{}.BABEL_TYPES_8_BREAKING && r && t.specifiers.length)
                  throw new TypeError('Only declaration or specifiers is allowed on ExportNamedDeclaration')
              },
              { oneOfNodeTypes: ['Declaration'] }
            ),
            function (t, e, r) {
              if (!!{}.BABEL_TYPES_8_BREAKING && r && t.source)
                throw new TypeError('Cannot export a declaration from a source')
            }
          ),
        },
        assertions: {
          optional: !0,
          validate: (0, k.chain)(
            (0, k.assertValueType)('array'),
            (0, k.assertEach)((0, k.assertNodeType)('ImportAttribute'))
          ),
        },
        specifiers: {
          default: [],
          validate: (0, k.chain)(
            (0, k.assertValueType)('array'),
            (0, k.assertEach)(
              (function () {
                const t = (0, k.assertNodeType)(
                    'ExportSpecifier',
                    'ExportDefaultSpecifier',
                    'ExportNamespaceSpecifier'
                  ),
                  e = (0, k.assertNodeType)('ExportSpecifier')
                return {}.BABEL_TYPES_8_BREAKING
                  ? function (r, i, n) {
                      ;(r.source ? t : e)(r, i, n)
                    }
                  : t
              })()
            )
          ),
        },
        source: { validate: (0, k.assertNodeType)('StringLiteral'), optional: !0 },
        exportKind: (0, k.validateOptional)((0, k.assertOneOf)('type', 'value')),
      },
    }),
    Ie('ExportSpecifier', {
      visitor: ['local', 'exported'],
      aliases: ['ModuleSpecifier'],
      fields: {
        local: { validate: (0, k.assertNodeType)('Identifier') },
        exported: { validate: (0, k.assertNodeType)('Identifier', 'StringLiteral') },
        exportKind: { validate: (0, k.assertOneOf)('type', 'value'), optional: !0 },
      },
    }),
    Ie('ForOfStatement', {
      visitor: ['left', 'right', 'body'],
      builder: ['left', 'right', 'body', 'await'],
      aliases: ['Scopable', 'Statement', 'For', 'BlockParent', 'Loop', 'ForXStatement'],
      fields: {
        left: {
          validate: (function () {
            if (!{}.BABEL_TYPES_8_BREAKING) return (0, k.assertNodeType)('VariableDeclaration', 'LVal')
            const t = (0, k.assertNodeType)('VariableDeclaration'),
              e = (0, k.assertNodeType)(
                'Identifier',
                'MemberExpression',
                'ArrayPattern',
                'ObjectPattern',
                'TSAsExpression',
                'TSTypeAssertion',
                'TSNonNullExpression'
              )
            return function (r, i, n) {
              ;(0, Jt.default)('VariableDeclaration', n) ? t(r, i, n) : e(r, i, n)
            }
          })(),
        },
        right: { validate: (0, k.assertNodeType)('Expression') },
        body: { validate: (0, k.assertNodeType)('Statement') },
        await: { default: !1 },
      },
    }),
    Ie('ImportDeclaration', {
      visitor: ['specifiers', 'source'],
      aliases: ['Statement', 'Declaration', 'ModuleDeclaration'],
      fields: {
        assertions: {
          optional: !0,
          validate: (0, k.chain)(
            (0, k.assertValueType)('array'),
            (0, k.assertEach)((0, k.assertNodeType)('ImportAttribute'))
          ),
        },
        specifiers: {
          validate: (0, k.chain)(
            (0, k.assertValueType)('array'),
            (0, k.assertEach)(
              (0, k.assertNodeType)('ImportSpecifier', 'ImportDefaultSpecifier', 'ImportNamespaceSpecifier')
            )
          ),
        },
        source: { validate: (0, k.assertNodeType)('StringLiteral') },
        importKind: { validate: (0, k.assertOneOf)('type', 'typeof', 'value'), optional: !0 },
      },
    }),
    Ie('ImportDefaultSpecifier', {
      visitor: ['local'],
      aliases: ['ModuleSpecifier'],
      fields: { local: { validate: (0, k.assertNodeType)('Identifier') } },
    }),
    Ie('ImportNamespaceSpecifier', {
      visitor: ['local'],
      aliases: ['ModuleSpecifier'],
      fields: { local: { validate: (0, k.assertNodeType)('Identifier') } },
    }),
    Ie('ImportSpecifier', {
      visitor: ['local', 'imported'],
      aliases: ['ModuleSpecifier'],
      fields: {
        local: { validate: (0, k.assertNodeType)('Identifier') },
        imported: { validate: (0, k.assertNodeType)('Identifier', 'StringLiteral') },
        importKind: { validate: (0, k.assertOneOf)('type', 'typeof', 'value'), optional: !0 },
      },
    }),
    Ie('MetaProperty', {
      visitor: ['meta', 'property'],
      aliases: ['Expression'],
      fields: {
        meta: {
          validate: (0, k.chain)(
            (0, k.assertNodeType)('Identifier'),
            Object.assign(
              function (t, e, r) {
                if (!{}.BABEL_TYPES_8_BREAKING) return
                let i
                switch (r.name) {
                  case 'function':
                    i = 'sent'
                    break
                  case 'new':
                    i = 'target'
                    break
                  case 'import':
                    i = 'meta'
                    break
                }
                if (!(0, Jt.default)('Identifier', t.property, { name: i }))
                  throw new TypeError('Unrecognised MetaProperty')
              },
              { oneOfNodeTypes: ['Identifier'] }
            )
          ),
        },
        property: { validate: (0, k.assertNodeType)('Identifier') },
      },
    })
  const Pa = {
    abstract: { validate: (0, k.assertValueType)('boolean'), optional: !0 },
    accessibility: { validate: (0, k.assertOneOf)('public', 'private', 'protected'), optional: !0 },
    static: { default: !1 },
    override: { default: !1 },
    computed: { default: !1 },
    optional: { validate: (0, k.assertValueType)('boolean'), optional: !0 },
    key: {
      validate: (0, k.chain)(
        (function () {
          const t = (0, k.assertNodeType)('Identifier', 'StringLiteral', 'NumericLiteral'),
            e = (0, k.assertNodeType)('Expression')
          return function (r, i, n) {
            ;(r.computed ? e : t)(r, i, n)
          }
        })(),
        (0, k.assertNodeType)('Identifier', 'StringLiteral', 'NumericLiteral', 'Expression')
      ),
    },
  }
  ir.classMethodOrPropertyCommon = Pa
  const pu = Object.assign({}, bn, Pa, {
    params: {
      validate: (0, k.chain)(
        (0, k.assertValueType)('array'),
        (0, k.assertEach)((0, k.assertNodeType)('Identifier', 'Pattern', 'RestElement', 'TSParameterProperty'))
      ),
    },
    kind: { validate: (0, k.assertOneOf)('get', 'set', 'method', 'constructor'), default: 'method' },
    access: {
      validate: (0, k.chain)((0, k.assertValueType)('string'), (0, k.assertOneOf)('public', 'private', 'protected')),
      optional: !0,
    },
    decorators: {
      validate: (0, k.chain)((0, k.assertValueType)('array'), (0, k.assertEach)((0, k.assertNodeType)('Decorator'))),
      optional: !0,
    },
  })
  ;(ir.classMethodOrDeclareMethodCommon = pu),
    Ie('ClassMethod', {
      aliases: ['Function', 'Scopable', 'BlockParent', 'FunctionParent', 'Method'],
      builder: ['kind', 'key', 'params', 'body', 'computed', 'static', 'generator', 'async'],
      visitor: ['key', 'params', 'body', 'decorators', 'returnType', 'typeParameters'],
      fields: Object.assign({}, pu, Ki, { body: { validate: (0, k.assertNodeType)('BlockStatement') } }),
    }),
    Ie('ObjectPattern', {
      visitor: ['properties', 'typeAnnotation', 'decorators'],
      builder: ['properties'],
      aliases: ['Pattern', 'PatternLike', 'LVal'],
      fields: Object.assign({}, Sn, {
        properties: {
          validate: (0, k.chain)(
            (0, k.assertValueType)('array'),
            (0, k.assertEach)((0, k.assertNodeType)('RestElement', 'ObjectProperty'))
          ),
        },
      }),
    }),
    Ie('SpreadElement', {
      visitor: ['argument'],
      aliases: ['UnaryLike'],
      deprecatedAlias: 'SpreadProperty',
      fields: { argument: { validate: (0, k.assertNodeType)('Expression') } },
    }),
    Ie('Super', { aliases: ['Expression'] }),
    Ie('TaggedTemplateExpression', {
      visitor: ['tag', 'quasi', 'typeParameters'],
      builder: ['tag', 'quasi'],
      aliases: ['Expression'],
      fields: {
        tag: { validate: (0, k.assertNodeType)('Expression') },
        quasi: { validate: (0, k.assertNodeType)('TemplateLiteral') },
        typeParameters: {
          validate: (0, k.assertNodeType)('TypeParameterInstantiation', 'TSTypeParameterInstantiation'),
          optional: !0,
        },
      },
    }),
    Ie('TemplateElement', {
      builder: ['value', 'tail'],
      fields: {
        value: {
          validate: (0, k.assertShape)({
            raw: { validate: (0, k.assertValueType)('string') },
            cooked: { validate: (0, k.assertValueType)('string'), optional: !0 },
          }),
        },
        tail: { default: !1 },
      },
    }),
    Ie('TemplateLiteral', {
      visitor: ['quasis', 'expressions'],
      aliases: ['Expression', 'Literal'],
      fields: {
        quasis: {
          validate: (0, k.chain)(
            (0, k.assertValueType)('array'),
            (0, k.assertEach)((0, k.assertNodeType)('TemplateElement'))
          ),
        },
        expressions: {
          validate: (0, k.chain)(
            (0, k.assertValueType)('array'),
            (0, k.assertEach)((0, k.assertNodeType)('Expression', 'TSType')),
            function (t, e, r) {
              if (t.quasis.length !== r.length + 1)
                throw new TypeError(`Number of ${
                  t.type
                } quasis should be exactly one more than the number of expressions.
Expected ${r.length + 1} quasis but got ${t.quasis.length}`)
            }
          ),
        },
      },
    }),
    Ie('YieldExpression', {
      builder: ['argument', 'delegate'],
      visitor: ['argument'],
      aliases: ['Expression', 'Terminatorless'],
      fields: {
        delegate: {
          validate: (0, k.chain)(
            (0, k.assertValueType)('boolean'),
            Object.assign(
              function (t, e, r) {
                if (!!{}.BABEL_TYPES_8_BREAKING && r && !t.argument)
                  throw new TypeError('Property delegate of YieldExpression cannot be true if there is no argument')
              },
              { type: 'boolean' }
            )
          ),
          default: !1,
        },
        argument: { optional: !0, validate: (0, k.assertNodeType)('Expression') },
      },
    }),
    Ie('AwaitExpression', {
      builder: ['argument'],
      visitor: ['argument'],
      aliases: ['Expression', 'Terminatorless'],
      fields: { argument: { validate: (0, k.assertNodeType)('Expression') } },
    }),
    Ie('Import', { aliases: ['Expression'] }),
    Ie('BigIntLiteral', {
      builder: ['value'],
      fields: { value: { validate: (0, k.assertValueType)('string') } },
      aliases: ['Expression', 'Pureish', 'Literal', 'Immutable'],
    }),
    Ie('ExportNamespaceSpecifier', {
      visitor: ['exported'],
      aliases: ['ModuleSpecifier'],
      fields: { exported: { validate: (0, k.assertNodeType)('Identifier') } },
    }),
    Ie('OptionalMemberExpression', {
      builder: ['object', 'property', 'computed', 'optional'],
      visitor: ['object', 'property'],
      aliases: ['Expression'],
      fields: {
        object: { validate: (0, k.assertNodeType)('Expression') },
        property: {
          validate: (function () {
            const t = (0, k.assertNodeType)('Identifier'),
              e = (0, k.assertNodeType)('Expression'),
              r = function (i, n, s) {
                ;(i.computed ? e : t)(i, n, s)
              }
            return (r.oneOfNodeTypes = ['Expression', 'Identifier']), r
          })(),
        },
        computed: { default: !1 },
        optional: {
          validate: {}.BABEL_TYPES_8_BREAKING
            ? (0, k.chain)((0, k.assertValueType)('boolean'), (0, k.assertOptionalChainStart)())
            : (0, k.assertValueType)('boolean'),
        },
      },
    }),
    Ie('OptionalCallExpression', {
      visitor: ['callee', 'arguments', 'typeParameters', 'typeArguments'],
      builder: ['callee', 'arguments', 'optional'],
      aliases: ['Expression'],
      fields: {
        callee: { validate: (0, k.assertNodeType)('Expression') },
        arguments: {
          validate: (0, k.chain)(
            (0, k.assertValueType)('array'),
            (0, k.assertEach)(
              (0, k.assertNodeType)('Expression', 'SpreadElement', 'JSXNamespacedName', 'ArgumentPlaceholder')
            )
          ),
        },
        optional: {
          validate: {}.BABEL_TYPES_8_BREAKING
            ? (0, k.chain)((0, k.assertValueType)('boolean'), (0, k.assertOptionalChainStart)())
            : (0, k.assertValueType)('boolean'),
        },
        typeArguments: { validate: (0, k.assertNodeType)('TypeParameterInstantiation'), optional: !0 },
        typeParameters: { validate: (0, k.assertNodeType)('TSTypeParameterInstantiation'), optional: !0 },
      },
    }),
    Ie('ClassProperty', {
      visitor: ['key', 'value', 'typeAnnotation', 'decorators'],
      builder: ['key', 'value', 'typeAnnotation', 'decorators', 'computed', 'static'],
      aliases: ['Property'],
      fields: Object.assign({}, Pa, {
        value: { validate: (0, k.assertNodeType)('Expression'), optional: !0 },
        definite: { validate: (0, k.assertValueType)('boolean'), optional: !0 },
        typeAnnotation: { validate: (0, k.assertNodeType)('TypeAnnotation', 'TSTypeAnnotation', 'Noop'), optional: !0 },
        decorators: {
          validate: (0, k.chain)(
            (0, k.assertValueType)('array'),
            (0, k.assertEach)((0, k.assertNodeType)('Decorator'))
          ),
          optional: !0,
        },
        readonly: { validate: (0, k.assertValueType)('boolean'), optional: !0 },
        declare: { validate: (0, k.assertValueType)('boolean'), optional: !0 },
        variance: { validate: (0, k.assertNodeType)('Variance'), optional: !0 },
      }),
    }),
    Ie('ClassAccessorProperty', {
      visitor: ['key', 'value', 'typeAnnotation', 'decorators'],
      builder: ['key', 'value', 'typeAnnotation', 'decorators', 'computed', 'static'],
      aliases: ['Property', 'Accessor'],
      fields: Object.assign({}, Pa, {
        key: {
          validate: (0, k.chain)(
            (function () {
              const t = (0, k.assertNodeType)('Identifier', 'StringLiteral', 'NumericLiteral', 'PrivateName'),
                e = (0, k.assertNodeType)('Expression')
              return function (r, i, n) {
                ;(r.computed ? e : t)(r, i, n)
              }
            })(),
            (0, k.assertNodeType)('Identifier', 'StringLiteral', 'NumericLiteral', 'Expression', 'PrivateName')
          ),
        },
        value: { validate: (0, k.assertNodeType)('Expression'), optional: !0 },
        definite: { validate: (0, k.assertValueType)('boolean'), optional: !0 },
        typeAnnotation: { validate: (0, k.assertNodeType)('TypeAnnotation', 'TSTypeAnnotation', 'Noop'), optional: !0 },
        decorators: {
          validate: (0, k.chain)(
            (0, k.assertValueType)('array'),
            (0, k.assertEach)((0, k.assertNodeType)('Decorator'))
          ),
          optional: !0,
        },
        readonly: { validate: (0, k.assertValueType)('boolean'), optional: !0 },
        declare: { validate: (0, k.assertValueType)('boolean'), optional: !0 },
        variance: { validate: (0, k.assertNodeType)('Variance'), optional: !0 },
      }),
    }),
    Ie('ClassPrivateProperty', {
      visitor: ['key', 'value', 'decorators', 'typeAnnotation'],
      builder: ['key', 'value', 'decorators', 'static'],
      aliases: ['Property', 'Private'],
      fields: {
        key: { validate: (0, k.assertNodeType)('PrivateName') },
        value: { validate: (0, k.assertNodeType)('Expression'), optional: !0 },
        typeAnnotation: { validate: (0, k.assertNodeType)('TypeAnnotation', 'TSTypeAnnotation', 'Noop'), optional: !0 },
        decorators: {
          validate: (0, k.chain)(
            (0, k.assertValueType)('array'),
            (0, k.assertEach)((0, k.assertNodeType)('Decorator'))
          ),
          optional: !0,
        },
        readonly: { validate: (0, k.assertValueType)('boolean'), optional: !0 },
        definite: { validate: (0, k.assertValueType)('boolean'), optional: !0 },
        variance: { validate: (0, k.assertNodeType)('Variance'), optional: !0 },
      },
    }),
    Ie('ClassPrivateMethod', {
      builder: ['kind', 'key', 'params', 'body', 'static'],
      visitor: ['key', 'params', 'body', 'decorators', 'returnType', 'typeParameters'],
      aliases: ['Function', 'Scopable', 'BlockParent', 'FunctionParent', 'Method', 'Private'],
      fields: Object.assign({}, pu, Ki, {
        key: { validate: (0, k.assertNodeType)('PrivateName') },
        body: { validate: (0, k.assertNodeType)('BlockStatement') },
      }),
    }),
    Ie('PrivateName', {
      visitor: ['id'],
      aliases: ['Private'],
      fields: { id: { validate: (0, k.assertNodeType)('Identifier') } },
    }),
    Ie('StaticBlock', {
      visitor: ['body'],
      fields: {
        body: {
          validate: (0, k.chain)(
            (0, k.assertValueType)('array'),
            (0, k.assertEach)((0, k.assertNodeType)('Statement'))
          ),
        },
      },
      aliases: ['Scopable', 'BlockParent', 'FunctionParent'],
    })
  var oe = tt
  const $e = (0, oe.defineAliasedType)('Flow'),
    fu = (t, e = 'TypeParameterDeclaration') => {
      $e(t, {
        builder: ['id', 'typeParameters', 'extends', 'body'],
        visitor: ['id', 'typeParameters', 'extends', 'mixins', 'implements', 'body'],
        aliases: ['FlowDeclaration', 'Statement', 'Declaration'],
        fields: {
          id: (0, oe.validateType)('Identifier'),
          typeParameters: (0, oe.validateOptionalType)(e),
          extends: (0, oe.validateOptional)((0, oe.arrayOfType)('InterfaceExtends')),
          mixins: (0, oe.validateOptional)((0, oe.arrayOfType)('InterfaceExtends')),
          implements: (0, oe.validateOptional)((0, oe.arrayOfType)('ClassImplements')),
          body: (0, oe.validateType)('ObjectTypeAnnotation'),
        },
      })
    }
  $e('AnyTypeAnnotation', { aliases: ['FlowType', 'FlowBaseAnnotation'] }),
    $e('ArrayTypeAnnotation', {
      visitor: ['elementType'],
      aliases: ['FlowType'],
      fields: { elementType: (0, oe.validateType)('FlowType') },
    }),
    $e('BooleanTypeAnnotation', { aliases: ['FlowType', 'FlowBaseAnnotation'] }),
    $e('BooleanLiteralTypeAnnotation', {
      builder: ['value'],
      aliases: ['FlowType'],
      fields: { value: (0, oe.validate)((0, oe.assertValueType)('boolean')) },
    }),
    $e('NullLiteralTypeAnnotation', { aliases: ['FlowType', 'FlowBaseAnnotation'] }),
    $e('ClassImplements', {
      visitor: ['id', 'typeParameters'],
      fields: {
        id: (0, oe.validateType)('Identifier'),
        typeParameters: (0, oe.validateOptionalType)('TypeParameterInstantiation'),
      },
    }),
    fu('DeclareClass'),
    $e('DeclareFunction', {
      visitor: ['id'],
      aliases: ['FlowDeclaration', 'Statement', 'Declaration'],
      fields: { id: (0, oe.validateType)('Identifier'), predicate: (0, oe.validateOptionalType)('DeclaredPredicate') },
    }),
    fu('DeclareInterface'),
    $e('DeclareModule', {
      builder: ['id', 'body', 'kind'],
      visitor: ['id', 'body'],
      aliases: ['FlowDeclaration', 'Statement', 'Declaration'],
      fields: {
        id: (0, oe.validateType)(['Identifier', 'StringLiteral']),
        body: (0, oe.validateType)('BlockStatement'),
        kind: (0, oe.validateOptional)((0, oe.assertOneOf)('CommonJS', 'ES')),
      },
    }),
    $e('DeclareModuleExports', {
      visitor: ['typeAnnotation'],
      aliases: ['FlowDeclaration', 'Statement', 'Declaration'],
      fields: { typeAnnotation: (0, oe.validateType)('TypeAnnotation') },
    }),
    $e('DeclareTypeAlias', {
      visitor: ['id', 'typeParameters', 'right'],
      aliases: ['FlowDeclaration', 'Statement', 'Declaration'],
      fields: {
        id: (0, oe.validateType)('Identifier'),
        typeParameters: (0, oe.validateOptionalType)('TypeParameterDeclaration'),
        right: (0, oe.validateType)('FlowType'),
      },
    }),
    $e('DeclareOpaqueType', {
      visitor: ['id', 'typeParameters', 'supertype'],
      aliases: ['FlowDeclaration', 'Statement', 'Declaration'],
      fields: {
        id: (0, oe.validateType)('Identifier'),
        typeParameters: (0, oe.validateOptionalType)('TypeParameterDeclaration'),
        supertype: (0, oe.validateOptionalType)('FlowType'),
        impltype: (0, oe.validateOptionalType)('FlowType'),
      },
    }),
    $e('DeclareVariable', {
      visitor: ['id'],
      aliases: ['FlowDeclaration', 'Statement', 'Declaration'],
      fields: { id: (0, oe.validateType)('Identifier') },
    }),
    $e('DeclareExportDeclaration', {
      visitor: ['declaration', 'specifiers', 'source'],
      aliases: ['FlowDeclaration', 'Statement', 'Declaration'],
      fields: {
        declaration: (0, oe.validateOptionalType)('Flow'),
        specifiers: (0, oe.validateOptional)((0, oe.arrayOfType)(['ExportSpecifier', 'ExportNamespaceSpecifier'])),
        source: (0, oe.validateOptionalType)('StringLiteral'),
        default: (0, oe.validateOptional)((0, oe.assertValueType)('boolean')),
      },
    }),
    $e('DeclareExportAllDeclaration', {
      visitor: ['source'],
      aliases: ['FlowDeclaration', 'Statement', 'Declaration'],
      fields: {
        source: (0, oe.validateType)('StringLiteral'),
        exportKind: (0, oe.validateOptional)((0, oe.assertOneOf)('type', 'value')),
      },
    }),
    $e('DeclaredPredicate', {
      visitor: ['value'],
      aliases: ['FlowPredicate'],
      fields: { value: (0, oe.validateType)('Flow') },
    }),
    $e('ExistsTypeAnnotation', { aliases: ['FlowType'] }),
    $e('FunctionTypeAnnotation', {
      visitor: ['typeParameters', 'params', 'rest', 'returnType'],
      aliases: ['FlowType'],
      fields: {
        typeParameters: (0, oe.validateOptionalType)('TypeParameterDeclaration'),
        params: (0, oe.validate)((0, oe.arrayOfType)('FunctionTypeParam')),
        rest: (0, oe.validateOptionalType)('FunctionTypeParam'),
        this: (0, oe.validateOptionalType)('FunctionTypeParam'),
        returnType: (0, oe.validateType)('FlowType'),
      },
    }),
    $e('FunctionTypeParam', {
      visitor: ['name', 'typeAnnotation'],
      fields: {
        name: (0, oe.validateOptionalType)('Identifier'),
        typeAnnotation: (0, oe.validateType)('FlowType'),
        optional: (0, oe.validateOptional)((0, oe.assertValueType)('boolean')),
      },
    }),
    $e('GenericTypeAnnotation', {
      visitor: ['id', 'typeParameters'],
      aliases: ['FlowType'],
      fields: {
        id: (0, oe.validateType)(['Identifier', 'QualifiedTypeIdentifier']),
        typeParameters: (0, oe.validateOptionalType)('TypeParameterInstantiation'),
      },
    }),
    $e('InferredPredicate', { aliases: ['FlowPredicate'] }),
    $e('InterfaceExtends', {
      visitor: ['id', 'typeParameters'],
      fields: {
        id: (0, oe.validateType)(['Identifier', 'QualifiedTypeIdentifier']),
        typeParameters: (0, oe.validateOptionalType)('TypeParameterInstantiation'),
      },
    }),
    fu('InterfaceDeclaration'),
    $e('InterfaceTypeAnnotation', {
      visitor: ['extends', 'body'],
      aliases: ['FlowType'],
      fields: {
        extends: (0, oe.validateOptional)((0, oe.arrayOfType)('InterfaceExtends')),
        body: (0, oe.validateType)('ObjectTypeAnnotation'),
      },
    }),
    $e('IntersectionTypeAnnotation', {
      visitor: ['types'],
      aliases: ['FlowType'],
      fields: { types: (0, oe.validate)((0, oe.arrayOfType)('FlowType')) },
    }),
    $e('MixedTypeAnnotation', { aliases: ['FlowType', 'FlowBaseAnnotation'] }),
    $e('EmptyTypeAnnotation', { aliases: ['FlowType', 'FlowBaseAnnotation'] }),
    $e('NullableTypeAnnotation', {
      visitor: ['typeAnnotation'],
      aliases: ['FlowType'],
      fields: { typeAnnotation: (0, oe.validateType)('FlowType') },
    }),
    $e('NumberLiteralTypeAnnotation', {
      builder: ['value'],
      aliases: ['FlowType'],
      fields: { value: (0, oe.validate)((0, oe.assertValueType)('number')) },
    }),
    $e('NumberTypeAnnotation', { aliases: ['FlowType', 'FlowBaseAnnotation'] }),
    $e('ObjectTypeAnnotation', {
      visitor: ['properties', 'indexers', 'callProperties', 'internalSlots'],
      aliases: ['FlowType'],
      builder: ['properties', 'indexers', 'callProperties', 'internalSlots', 'exact'],
      fields: {
        properties: (0, oe.validate)((0, oe.arrayOfType)(['ObjectTypeProperty', 'ObjectTypeSpreadProperty'])),
        indexers: { validate: (0, oe.arrayOfType)('ObjectTypeIndexer'), optional: !0, default: [] },
        callProperties: { validate: (0, oe.arrayOfType)('ObjectTypeCallProperty'), optional: !0, default: [] },
        internalSlots: { validate: (0, oe.arrayOfType)('ObjectTypeInternalSlot'), optional: !0, default: [] },
        exact: { validate: (0, oe.assertValueType)('boolean'), default: !1 },
        inexact: (0, oe.validateOptional)((0, oe.assertValueType)('boolean')),
      },
    }),
    $e('ObjectTypeInternalSlot', {
      visitor: ['id', 'value', 'optional', 'static', 'method'],
      aliases: ['UserWhitespacable'],
      fields: {
        id: (0, oe.validateType)('Identifier'),
        value: (0, oe.validateType)('FlowType'),
        optional: (0, oe.validate)((0, oe.assertValueType)('boolean')),
        static: (0, oe.validate)((0, oe.assertValueType)('boolean')),
        method: (0, oe.validate)((0, oe.assertValueType)('boolean')),
      },
    }),
    $e('ObjectTypeCallProperty', {
      visitor: ['value'],
      aliases: ['UserWhitespacable'],
      fields: { value: (0, oe.validateType)('FlowType'), static: (0, oe.validate)((0, oe.assertValueType)('boolean')) },
    }),
    $e('ObjectTypeIndexer', {
      visitor: ['id', 'key', 'value', 'variance'],
      aliases: ['UserWhitespacable'],
      fields: {
        id: (0, oe.validateOptionalType)('Identifier'),
        key: (0, oe.validateType)('FlowType'),
        value: (0, oe.validateType)('FlowType'),
        static: (0, oe.validate)((0, oe.assertValueType)('boolean')),
        variance: (0, oe.validateOptionalType)('Variance'),
      },
    }),
    $e('ObjectTypeProperty', {
      visitor: ['key', 'value', 'variance'],
      aliases: ['UserWhitespacable'],
      fields: {
        key: (0, oe.validateType)(['Identifier', 'StringLiteral']),
        value: (0, oe.validateType)('FlowType'),
        kind: (0, oe.validate)((0, oe.assertOneOf)('init', 'get', 'set')),
        static: (0, oe.validate)((0, oe.assertValueType)('boolean')),
        proto: (0, oe.validate)((0, oe.assertValueType)('boolean')),
        optional: (0, oe.validate)((0, oe.assertValueType)('boolean')),
        variance: (0, oe.validateOptionalType)('Variance'),
        method: (0, oe.validate)((0, oe.assertValueType)('boolean')),
      },
    }),
    $e('ObjectTypeSpreadProperty', {
      visitor: ['argument'],
      aliases: ['UserWhitespacable'],
      fields: { argument: (0, oe.validateType)('FlowType') },
    }),
    $e('OpaqueType', {
      visitor: ['id', 'typeParameters', 'supertype', 'impltype'],
      aliases: ['FlowDeclaration', 'Statement', 'Declaration'],
      fields: {
        id: (0, oe.validateType)('Identifier'),
        typeParameters: (0, oe.validateOptionalType)('TypeParameterDeclaration'),
        supertype: (0, oe.validateOptionalType)('FlowType'),
        impltype: (0, oe.validateType)('FlowType'),
      },
    }),
    $e('QualifiedTypeIdentifier', {
      visitor: ['id', 'qualification'],
      fields: {
        id: (0, oe.validateType)('Identifier'),
        qualification: (0, oe.validateType)(['Identifier', 'QualifiedTypeIdentifier']),
      },
    }),
    $e('StringLiteralTypeAnnotation', {
      builder: ['value'],
      aliases: ['FlowType'],
      fields: { value: (0, oe.validate)((0, oe.assertValueType)('string')) },
    }),
    $e('StringTypeAnnotation', { aliases: ['FlowType', 'FlowBaseAnnotation'] }),
    $e('SymbolTypeAnnotation', { aliases: ['FlowType', 'FlowBaseAnnotation'] }),
    $e('ThisTypeAnnotation', { aliases: ['FlowType', 'FlowBaseAnnotation'] }),
    $e('TupleTypeAnnotation', {
      visitor: ['types'],
      aliases: ['FlowType'],
      fields: { types: (0, oe.validate)((0, oe.arrayOfType)('FlowType')) },
    }),
    $e('TypeofTypeAnnotation', {
      visitor: ['argument'],
      aliases: ['FlowType'],
      fields: { argument: (0, oe.validateType)('FlowType') },
    }),
    $e('TypeAlias', {
      visitor: ['id', 'typeParameters', 'right'],
      aliases: ['FlowDeclaration', 'Statement', 'Declaration'],
      fields: {
        id: (0, oe.validateType)('Identifier'),
        typeParameters: (0, oe.validateOptionalType)('TypeParameterDeclaration'),
        right: (0, oe.validateType)('FlowType'),
      },
    }),
    $e('TypeAnnotation', { visitor: ['typeAnnotation'], fields: { typeAnnotation: (0, oe.validateType)('FlowType') } }),
    $e('TypeCastExpression', {
      visitor: ['expression', 'typeAnnotation'],
      aliases: ['ExpressionWrapper', 'Expression'],
      fields: {
        expression: (0, oe.validateType)('Expression'),
        typeAnnotation: (0, oe.validateType)('TypeAnnotation'),
      },
    }),
    $e('TypeParameter', {
      visitor: ['bound', 'default', 'variance'],
      fields: {
        name: (0, oe.validate)((0, oe.assertValueType)('string')),
        bound: (0, oe.validateOptionalType)('TypeAnnotation'),
        default: (0, oe.validateOptionalType)('FlowType'),
        variance: (0, oe.validateOptionalType)('Variance'),
      },
    }),
    $e('TypeParameterDeclaration', {
      visitor: ['params'],
      fields: { params: (0, oe.validate)((0, oe.arrayOfType)('TypeParameter')) },
    }),
    $e('TypeParameterInstantiation', {
      visitor: ['params'],
      fields: { params: (0, oe.validate)((0, oe.arrayOfType)('FlowType')) },
    }),
    $e('UnionTypeAnnotation', {
      visitor: ['types'],
      aliases: ['FlowType'],
      fields: { types: (0, oe.validate)((0, oe.arrayOfType)('FlowType')) },
    }),
    $e('Variance', { builder: ['kind'], fields: { kind: (0, oe.validate)((0, oe.assertOneOf)('minus', 'plus')) } }),
    $e('VoidTypeAnnotation', { aliases: ['FlowType', 'FlowBaseAnnotation'] }),
    $e('EnumDeclaration', {
      aliases: ['Statement', 'Declaration'],
      visitor: ['id', 'body'],
      fields: {
        id: (0, oe.validateType)('Identifier'),
        body: (0, oe.validateType)(['EnumBooleanBody', 'EnumNumberBody', 'EnumStringBody', 'EnumSymbolBody']),
      },
    }),
    $e('EnumBooleanBody', {
      aliases: ['EnumBody'],
      visitor: ['members'],
      fields: {
        explicitType: (0, oe.validate)((0, oe.assertValueType)('boolean')),
        members: (0, oe.validateArrayOfType)('EnumBooleanMember'),
        hasUnknownMembers: (0, oe.validate)((0, oe.assertValueType)('boolean')),
      },
    }),
    $e('EnumNumberBody', {
      aliases: ['EnumBody'],
      visitor: ['members'],
      fields: {
        explicitType: (0, oe.validate)((0, oe.assertValueType)('boolean')),
        members: (0, oe.validateArrayOfType)('EnumNumberMember'),
        hasUnknownMembers: (0, oe.validate)((0, oe.assertValueType)('boolean')),
      },
    }),
    $e('EnumStringBody', {
      aliases: ['EnumBody'],
      visitor: ['members'],
      fields: {
        explicitType: (0, oe.validate)((0, oe.assertValueType)('boolean')),
        members: (0, oe.validateArrayOfType)(['EnumStringMember', 'EnumDefaultedMember']),
        hasUnknownMembers: (0, oe.validate)((0, oe.assertValueType)('boolean')),
      },
    }),
    $e('EnumSymbolBody', {
      aliases: ['EnumBody'],
      visitor: ['members'],
      fields: {
        members: (0, oe.validateArrayOfType)('EnumDefaultedMember'),
        hasUnknownMembers: (0, oe.validate)((0, oe.assertValueType)('boolean')),
      },
    }),
    $e('EnumBooleanMember', {
      aliases: ['EnumMember'],
      visitor: ['id'],
      fields: { id: (0, oe.validateType)('Identifier'), init: (0, oe.validateType)('BooleanLiteral') },
    }),
    $e('EnumNumberMember', {
      aliases: ['EnumMember'],
      visitor: ['id', 'init'],
      fields: { id: (0, oe.validateType)('Identifier'), init: (0, oe.validateType)('NumericLiteral') },
    }),
    $e('EnumStringMember', {
      aliases: ['EnumMember'],
      visitor: ['id', 'init'],
      fields: { id: (0, oe.validateType)('Identifier'), init: (0, oe.validateType)('StringLiteral') },
    }),
    $e('EnumDefaultedMember', {
      aliases: ['EnumMember'],
      visitor: ['id'],
      fields: { id: (0, oe.validateType)('Identifier') },
    }),
    $e('IndexedAccessType', {
      visitor: ['objectType', 'indexType'],
      aliases: ['FlowType'],
      fields: { objectType: (0, oe.validateType)('FlowType'), indexType: (0, oe.validateType)('FlowType') },
    }),
    $e('OptionalIndexedAccessType', {
      visitor: ['objectType', 'indexType'],
      aliases: ['FlowType'],
      fields: {
        objectType: (0, oe.validateType)('FlowType'),
        indexType: (0, oe.validateType)('FlowType'),
        optional: (0, oe.validate)((0, oe.assertValueType)('boolean')),
      },
    })
  var ft = tt
  const Zt = (0, ft.defineAliasedType)('JSX')
  Zt('JSXAttribute', {
    visitor: ['name', 'value'],
    aliases: ['Immutable'],
    fields: {
      name: { validate: (0, ft.assertNodeType)('JSXIdentifier', 'JSXNamespacedName') },
      value: {
        optional: !0,
        validate: (0, ft.assertNodeType)('JSXElement', 'JSXFragment', 'StringLiteral', 'JSXExpressionContainer'),
      },
    },
  }),
    Zt('JSXClosingElement', {
      visitor: ['name'],
      aliases: ['Immutable'],
      fields: {
        name: { validate: (0, ft.assertNodeType)('JSXIdentifier', 'JSXMemberExpression', 'JSXNamespacedName') },
      },
    }),
    Zt('JSXElement', {
      builder: ['openingElement', 'closingElement', 'children', 'selfClosing'],
      visitor: ['openingElement', 'children', 'closingElement'],
      aliases: ['Immutable', 'Expression'],
      fields: Object.assign(
        {
          openingElement: { validate: (0, ft.assertNodeType)('JSXOpeningElement') },
          closingElement: { optional: !0, validate: (0, ft.assertNodeType)('JSXClosingElement') },
          children: {
            validate: (0, ft.chain)(
              (0, ft.assertValueType)('array'),
              (0, ft.assertEach)(
                (0, ft.assertNodeType)(
                  'JSXText',
                  'JSXExpressionContainer',
                  'JSXSpreadChild',
                  'JSXElement',
                  'JSXFragment'
                )
              )
            ),
          },
        },
        { selfClosing: { validate: (0, ft.assertValueType)('boolean'), optional: !0 } }
      ),
    }),
    Zt('JSXEmptyExpression', {}),
    Zt('JSXExpressionContainer', {
      visitor: ['expression'],
      aliases: ['Immutable'],
      fields: { expression: { validate: (0, ft.assertNodeType)('Expression', 'JSXEmptyExpression') } },
    }),
    Zt('JSXSpreadChild', {
      visitor: ['expression'],
      aliases: ['Immutable'],
      fields: { expression: { validate: (0, ft.assertNodeType)('Expression') } },
    }),
    Zt('JSXIdentifier', { builder: ['name'], fields: { name: { validate: (0, ft.assertValueType)('string') } } }),
    Zt('JSXMemberExpression', {
      visitor: ['object', 'property'],
      fields: {
        object: { validate: (0, ft.assertNodeType)('JSXMemberExpression', 'JSXIdentifier') },
        property: { validate: (0, ft.assertNodeType)('JSXIdentifier') },
      },
    }),
    Zt('JSXNamespacedName', {
      visitor: ['namespace', 'name'],
      fields: {
        namespace: { validate: (0, ft.assertNodeType)('JSXIdentifier') },
        name: { validate: (0, ft.assertNodeType)('JSXIdentifier') },
      },
    }),
    Zt('JSXOpeningElement', {
      builder: ['name', 'attributes', 'selfClosing'],
      visitor: ['name', 'attributes'],
      aliases: ['Immutable'],
      fields: {
        name: { validate: (0, ft.assertNodeType)('JSXIdentifier', 'JSXMemberExpression', 'JSXNamespacedName') },
        selfClosing: { default: !1 },
        attributes: {
          validate: (0, ft.chain)(
            (0, ft.assertValueType)('array'),
            (0, ft.assertEach)((0, ft.assertNodeType)('JSXAttribute', 'JSXSpreadAttribute'))
          ),
        },
        typeParameters: {
          validate: (0, ft.assertNodeType)('TypeParameterInstantiation', 'TSTypeParameterInstantiation'),
          optional: !0,
        },
      },
    }),
    Zt('JSXSpreadAttribute', {
      visitor: ['argument'],
      fields: { argument: { validate: (0, ft.assertNodeType)('Expression') } },
    }),
    Zt('JSXText', {
      aliases: ['Immutable'],
      builder: ['value'],
      fields: { value: { validate: (0, ft.assertValueType)('string') } },
    }),
    Zt('JSXFragment', {
      builder: ['openingFragment', 'closingFragment', 'children'],
      visitor: ['openingFragment', 'children', 'closingFragment'],
      aliases: ['Immutable', 'Expression'],
      fields: {
        openingFragment: { validate: (0, ft.assertNodeType)('JSXOpeningFragment') },
        closingFragment: { validate: (0, ft.assertNodeType)('JSXClosingFragment') },
        children: {
          validate: (0, ft.chain)(
            (0, ft.assertValueType)('array'),
            (0, ft.assertEach)(
              (0, ft.assertNodeType)('JSXText', 'JSXExpressionContainer', 'JSXSpreadChild', 'JSXElement', 'JSXFragment')
            )
          ),
        },
      },
    }),
    Zt('JSXOpeningFragment', { aliases: ['Immutable'] }),
    Zt('JSXClosingFragment', { aliases: ['Immutable'] })
  var _r = {}
  Object.defineProperty(_r, '__esModule', { value: !0 }),
    (_r.PLACEHOLDERS_FLIPPED_ALIAS = _r.PLACEHOLDERS_ALIAS = _r.PLACEHOLDERS = void 0)
  var GA = tt
  const Dd = [
    'Identifier',
    'StringLiteral',
    'Expression',
    'Statement',
    'Declaration',
    'BlockStatement',
    'ClassBody',
    'Pattern',
  ]
  _r.PLACEHOLDERS = Dd
  const wa = { Declaration: ['Statement'], Pattern: ['PatternLike', 'LVal'] }
  _r.PLACEHOLDERS_ALIAS = wa
  for (const t of Dd) {
    const e = GA.ALIAS_KEYS[t]
    e != null && e.length && (wa[t] = e)
  }
  const Aa = {}
  ;(_r.PLACEHOLDERS_FLIPPED_ALIAS = Aa),
    Object.keys(wa).forEach((t) => {
      wa[t].forEach((e) => {
        Object.hasOwnProperty.call(Aa, e) || (Aa[e] = []), Aa[e].push(t)
      })
    })
  var Ca = tt,
    JA = _r
  const hu = (0, Ca.defineAliasedType)('Miscellaneous')
  hu('Noop', { visitor: [] }),
    hu('Placeholder', {
      visitor: [],
      builder: ['expectedNode', 'name'],
      fields: {
        name: { validate: (0, Ca.assertNodeType)('Identifier') },
        expectedNode: { validate: (0, Ca.assertOneOf)(...JA.PLACEHOLDERS) },
      },
    }),
    hu('V8IntrinsicIdentifier', {
      builder: ['name'],
      fields: { name: { validate: (0, Ca.assertValueType)('string') } },
    })
  var pt = tt
  ;(0, pt.default)('ArgumentPlaceholder', {}),
    (0, pt.default)('BindExpression', {
      visitor: ['object', 'callee'],
      aliases: ['Expression'],
      fields: {}.BABEL_TYPES_8_BREAKING
        ? {
            object: { validate: (0, pt.assertNodeType)('Expression') },
            callee: { validate: (0, pt.assertNodeType)('Expression') },
          }
        : {
            object: { validate: Object.assign(() => {}, { oneOfNodeTypes: ['Expression'] }) },
            callee: { validate: Object.assign(() => {}, { oneOfNodeTypes: ['Expression'] }) },
          },
    }),
    (0, pt.default)('ImportAttribute', {
      visitor: ['key', 'value'],
      fields: {
        key: { validate: (0, pt.assertNodeType)('Identifier', 'StringLiteral') },
        value: { validate: (0, pt.assertNodeType)('StringLiteral') },
      },
    }),
    (0, pt.default)('Decorator', {
      visitor: ['expression'],
      fields: { expression: { validate: (0, pt.assertNodeType)('Expression') } },
    }),
    (0, pt.default)('DoExpression', {
      visitor: ['body'],
      builder: ['body', 'async'],
      aliases: ['Expression'],
      fields: {
        body: { validate: (0, pt.assertNodeType)('BlockStatement') },
        async: { validate: (0, pt.assertValueType)('boolean'), default: !1 },
      },
    }),
    (0, pt.default)('ExportDefaultSpecifier', {
      visitor: ['exported'],
      aliases: ['ModuleSpecifier'],
      fields: { exported: { validate: (0, pt.assertNodeType)('Identifier') } },
    }),
    (0, pt.default)('RecordExpression', {
      visitor: ['properties'],
      aliases: ['Expression'],
      fields: {
        properties: {
          validate: (0, pt.chain)(
            (0, pt.assertValueType)('array'),
            (0, pt.assertEach)((0, pt.assertNodeType)('ObjectProperty', 'SpreadElement'))
          ),
        },
      },
    }),
    (0, pt.default)('TupleExpression', {
      fields: {
        elements: {
          validate: (0, pt.chain)(
            (0, pt.assertValueType)('array'),
            (0, pt.assertEach)((0, pt.assertNodeType)('Expression', 'SpreadElement'))
          ),
          default: [],
        },
      },
      visitor: ['elements'],
      aliases: ['Expression'],
    }),
    (0, pt.default)('DecimalLiteral', {
      builder: ['value'],
      fields: { value: { validate: (0, pt.assertValueType)('string') } },
      aliases: ['Expression', 'Pureish', 'Literal', 'Immutable'],
    }),
    (0, pt.default)('ModuleExpression', {
      visitor: ['body'],
      fields: { body: { validate: (0, pt.assertNodeType)('Program') } },
      aliases: ['Expression'],
    }),
    (0, pt.default)('TopicReference', { aliases: ['Expression'] }),
    (0, pt.default)('PipelineTopicExpression', {
      builder: ['expression'],
      visitor: ['expression'],
      fields: { expression: { validate: (0, pt.assertNodeType)('Expression') } },
      aliases: ['Expression'],
    }),
    (0, pt.default)('PipelineBareFunction', {
      builder: ['callee'],
      visitor: ['callee'],
      fields: { callee: { validate: (0, pt.assertNodeType)('Expression') } },
      aliases: ['Expression'],
    }),
    (0, pt.default)('PipelinePrimaryTopicReference', { aliases: ['Expression'] })
  var ve = tt,
    Bd = ir,
    ZA = Vi
  const qe = (0, ve.defineAliasedType)('TypeScript'),
    Ft = (0, ve.assertValueType)('boolean'),
    Ld = {
      returnType: { validate: (0, ve.assertNodeType)('TSTypeAnnotation', 'Noop'), optional: !0 },
      typeParameters: { validate: (0, ve.assertNodeType)('TSTypeParameterDeclaration', 'Noop'), optional: !0 },
    }
  qe('TSParameterProperty', {
    aliases: ['LVal'],
    visitor: ['parameter'],
    fields: {
      accessibility: { validate: (0, ve.assertOneOf)('public', 'private', 'protected'), optional: !0 },
      readonly: { validate: (0, ve.assertValueType)('boolean'), optional: !0 },
      parameter: { validate: (0, ve.assertNodeType)('Identifier', 'AssignmentPattern') },
      override: { validate: (0, ve.assertValueType)('boolean'), optional: !0 },
      decorators: {
        validate: (0, ve.chain)(
          (0, ve.assertValueType)('array'),
          (0, ve.assertEach)((0, ve.assertNodeType)('Decorator'))
        ),
        optional: !0,
      },
    },
  }),
    qe('TSDeclareFunction', {
      aliases: ['Statement', 'Declaration'],
      visitor: ['id', 'typeParameters', 'params', 'returnType'],
      fields: Object.assign({}, Bd.functionDeclarationCommon, Ld),
    }),
    qe('TSDeclareMethod', {
      visitor: ['decorators', 'key', 'typeParameters', 'params', 'returnType'],
      fields: Object.assign({}, Bd.classMethodOrDeclareMethodCommon, Ld),
    }),
    qe('TSQualifiedName', {
      aliases: ['TSEntityName'],
      visitor: ['left', 'right'],
      fields: { left: (0, ve.validateType)('TSEntityName'), right: (0, ve.validateType)('Identifier') },
    })
  const xa = {
      typeParameters: (0, ve.validateOptionalType)('TSTypeParameterDeclaration'),
      parameters: (0, ve.validateArrayOfType)(['Identifier', 'RestElement']),
      typeAnnotation: (0, ve.validateOptionalType)('TSTypeAnnotation'),
    },
    Md = { aliases: ['TSTypeElement'], visitor: ['typeParameters', 'parameters', 'typeAnnotation'], fields: xa }
  qe('TSCallSignatureDeclaration', Md), qe('TSConstructSignatureDeclaration', Md)
  const Fd = {
    key: (0, ve.validateType)('Expression'),
    computed: (0, ve.validate)(Ft),
    optional: (0, ve.validateOptional)(Ft),
  }
  qe('TSPropertySignature', {
    aliases: ['TSTypeElement'],
    visitor: ['key', 'typeAnnotation', 'initializer'],
    fields: Object.assign({}, Fd, {
      readonly: (0, ve.validateOptional)(Ft),
      typeAnnotation: (0, ve.validateOptionalType)('TSTypeAnnotation'),
      initializer: (0, ve.validateOptionalType)('Expression'),
      kind: { validate: (0, ve.assertOneOf)('get', 'set') },
    }),
  }),
    qe('TSMethodSignature', {
      aliases: ['TSTypeElement'],
      visitor: ['key', 'typeParameters', 'parameters', 'typeAnnotation'],
      fields: Object.assign({}, xa, Fd, { kind: { validate: (0, ve.assertOneOf)('method', 'get', 'set') } }),
    }),
    qe('TSIndexSignature', {
      aliases: ['TSTypeElement'],
      visitor: ['parameters', 'typeAnnotation'],
      fields: {
        readonly: (0, ve.validateOptional)(Ft),
        static: (0, ve.validateOptional)(Ft),
        parameters: (0, ve.validateArrayOfType)('Identifier'),
        typeAnnotation: (0, ve.validateOptionalType)('TSTypeAnnotation'),
      },
    })
  const QA = [
    'TSAnyKeyword',
    'TSBooleanKeyword',
    'TSBigIntKeyword',
    'TSIntrinsicKeyword',
    'TSNeverKeyword',
    'TSNullKeyword',
    'TSNumberKeyword',
    'TSObjectKeyword',
    'TSStringKeyword',
    'TSSymbolKeyword',
    'TSUndefinedKeyword',
    'TSUnknownKeyword',
    'TSVoidKeyword',
  ]
  for (const t of QA) qe(t, { aliases: ['TSType', 'TSBaseType'], visitor: [], fields: {} })
  qe('TSThisType', { aliases: ['TSType', 'TSBaseType'], visitor: [], fields: {} })
  const $d = { aliases: ['TSType'], visitor: ['typeParameters', 'parameters', 'typeAnnotation'] }
  qe('TSFunctionType', Object.assign({}, $d, { fields: xa })),
    qe(
      'TSConstructorType',
      Object.assign({}, $d, { fields: Object.assign({}, xa, { abstract: (0, ve.validateOptional)(Ft) }) })
    ),
    qe('TSTypeReference', {
      aliases: ['TSType'],
      visitor: ['typeName', 'typeParameters'],
      fields: {
        typeName: (0, ve.validateType)('TSEntityName'),
        typeParameters: (0, ve.validateOptionalType)('TSTypeParameterInstantiation'),
      },
    }),
    qe('TSTypePredicate', {
      aliases: ['TSType'],
      visitor: ['parameterName', 'typeAnnotation'],
      builder: ['parameterName', 'typeAnnotation', 'asserts'],
      fields: {
        parameterName: (0, ve.validateType)(['Identifier', 'TSThisType']),
        typeAnnotation: (0, ve.validateOptionalType)('TSTypeAnnotation'),
        asserts: (0, ve.validateOptional)(Ft),
      },
    }),
    qe('TSTypeQuery', {
      aliases: ['TSType'],
      visitor: ['exprName', 'typeParameters'],
      fields: {
        exprName: (0, ve.validateType)(['TSEntityName', 'TSImportType']),
        typeParameters: (0, ve.validateOptionalType)('TSTypeParameterInstantiation'),
      },
    }),
    qe('TSTypeLiteral', {
      aliases: ['TSType'],
      visitor: ['members'],
      fields: { members: (0, ve.validateArrayOfType)('TSTypeElement') },
    }),
    qe('TSArrayType', {
      aliases: ['TSType'],
      visitor: ['elementType'],
      fields: { elementType: (0, ve.validateType)('TSType') },
    }),
    qe('TSTupleType', {
      aliases: ['TSType'],
      visitor: ['elementTypes'],
      fields: { elementTypes: (0, ve.validateArrayOfType)(['TSType', 'TSNamedTupleMember']) },
    }),
    qe('TSOptionalType', {
      aliases: ['TSType'],
      visitor: ['typeAnnotation'],
      fields: { typeAnnotation: (0, ve.validateType)('TSType') },
    }),
    qe('TSRestType', {
      aliases: ['TSType'],
      visitor: ['typeAnnotation'],
      fields: { typeAnnotation: (0, ve.validateType)('TSType') },
    }),
    qe('TSNamedTupleMember', {
      visitor: ['label', 'elementType'],
      builder: ['label', 'elementType', 'optional'],
      fields: {
        label: (0, ve.validateType)('Identifier'),
        optional: { validate: Ft, default: !1 },
        elementType: (0, ve.validateType)('TSType'),
      },
    })
  const Rd = { aliases: ['TSType'], visitor: ['types'], fields: { types: (0, ve.validateArrayOfType)('TSType') } }
  qe('TSUnionType', Rd),
    qe('TSIntersectionType', Rd),
    qe('TSConditionalType', {
      aliases: ['TSType'],
      visitor: ['checkType', 'extendsType', 'trueType', 'falseType'],
      fields: {
        checkType: (0, ve.validateType)('TSType'),
        extendsType: (0, ve.validateType)('TSType'),
        trueType: (0, ve.validateType)('TSType'),
        falseType: (0, ve.validateType)('TSType'),
      },
    }),
    qe('TSInferType', {
      aliases: ['TSType'],
      visitor: ['typeParameter'],
      fields: { typeParameter: (0, ve.validateType)('TSTypeParameter') },
    }),
    qe('TSParenthesizedType', {
      aliases: ['TSType'],
      visitor: ['typeAnnotation'],
      fields: { typeAnnotation: (0, ve.validateType)('TSType') },
    }),
    qe('TSTypeOperator', {
      aliases: ['TSType'],
      visitor: ['typeAnnotation'],
      fields: {
        operator: (0, ve.validate)((0, ve.assertValueType)('string')),
        typeAnnotation: (0, ve.validateType)('TSType'),
      },
    }),
    qe('TSIndexedAccessType', {
      aliases: ['TSType'],
      visitor: ['objectType', 'indexType'],
      fields: { objectType: (0, ve.validateType)('TSType'), indexType: (0, ve.validateType)('TSType') },
    }),
    qe('TSMappedType', {
      aliases: ['TSType'],
      visitor: ['typeParameter', 'typeAnnotation', 'nameType'],
      fields: {
        readonly: (0, ve.validateOptional)(Ft),
        typeParameter: (0, ve.validateType)('TSTypeParameter'),
        optional: (0, ve.validateOptional)(Ft),
        typeAnnotation: (0, ve.validateOptionalType)('TSType'),
        nameType: (0, ve.validateOptionalType)('TSType'),
      },
    }),
    qe('TSLiteralType', {
      aliases: ['TSType', 'TSBaseType'],
      visitor: ['literal'],
      fields: {
        literal: {
          validate: (function () {
            const t = (0, ve.assertNodeType)('NumericLiteral', 'BigIntLiteral'),
              e = (0, ve.assertOneOf)('-'),
              r = (0, ve.assertNodeType)('NumericLiteral', 'StringLiteral', 'BooleanLiteral', 'BigIntLiteral')
            function i(n, s, a) {
              ;(0, ZA.default)('UnaryExpression', a)
                ? (e(a, 'operator', a.operator), t(a, 'argument', a.argument))
                : r(n, s, a)
            }
            return (
              (i.oneOfNodeTypes = [
                'NumericLiteral',
                'StringLiteral',
                'BooleanLiteral',
                'BigIntLiteral',
                'UnaryExpression',
              ]),
              i
            )
          })(),
        },
      },
    }),
    qe('TSExpressionWithTypeArguments', {
      aliases: ['TSType'],
      visitor: ['expression', 'typeParameters'],
      fields: {
        expression: (0, ve.validateType)('TSEntityName'),
        typeParameters: (0, ve.validateOptionalType)('TSTypeParameterInstantiation'),
      },
    }),
    qe('TSInterfaceDeclaration', {
      aliases: ['Statement', 'Declaration'],
      visitor: ['id', 'typeParameters', 'extends', 'body'],
      fields: {
        declare: (0, ve.validateOptional)(Ft),
        id: (0, ve.validateType)('Identifier'),
        typeParameters: (0, ve.validateOptionalType)('TSTypeParameterDeclaration'),
        extends: (0, ve.validateOptional)((0, ve.arrayOfType)('TSExpressionWithTypeArguments')),
        body: (0, ve.validateType)('TSInterfaceBody'),
      },
    }),
    qe('TSInterfaceBody', { visitor: ['body'], fields: { body: (0, ve.validateArrayOfType)('TSTypeElement') } }),
    qe('TSTypeAliasDeclaration', {
      aliases: ['Statement', 'Declaration'],
      visitor: ['id', 'typeParameters', 'typeAnnotation'],
      fields: {
        declare: (0, ve.validateOptional)(Ft),
        id: (0, ve.validateType)('Identifier'),
        typeParameters: (0, ve.validateOptionalType)('TSTypeParameterDeclaration'),
        typeAnnotation: (0, ve.validateType)('TSType'),
      },
    }),
    qe('TSInstantiationExpression', {
      aliases: ['Expression'],
      visitor: ['expression', 'typeParameters'],
      fields: {
        expression: (0, ve.validateType)('Expression'),
        typeParameters: (0, ve.validateOptionalType)('TSTypeParameterInstantiation'),
      },
    }),
    qe('TSAsExpression', {
      aliases: ['Expression', 'LVal', 'PatternLike'],
      visitor: ['expression', 'typeAnnotation'],
      fields: { expression: (0, ve.validateType)('Expression'), typeAnnotation: (0, ve.validateType)('TSType') },
    }),
    qe('TSTypeAssertion', {
      aliases: ['Expression', 'LVal', 'PatternLike'],
      visitor: ['typeAnnotation', 'expression'],
      fields: { typeAnnotation: (0, ve.validateType)('TSType'), expression: (0, ve.validateType)('Expression') },
    }),
    qe('TSEnumDeclaration', {
      aliases: ['Statement', 'Declaration'],
      visitor: ['id', 'members'],
      fields: {
        declare: (0, ve.validateOptional)(Ft),
        const: (0, ve.validateOptional)(Ft),
        id: (0, ve.validateType)('Identifier'),
        members: (0, ve.validateArrayOfType)('TSEnumMember'),
        initializer: (0, ve.validateOptionalType)('Expression'),
      },
    }),
    qe('TSEnumMember', {
      visitor: ['id', 'initializer'],
      fields: {
        id: (0, ve.validateType)(['Identifier', 'StringLiteral']),
        initializer: (0, ve.validateOptionalType)('Expression'),
      },
    }),
    qe('TSModuleDeclaration', {
      aliases: ['Statement', 'Declaration'],
      visitor: ['id', 'body'],
      fields: {
        declare: (0, ve.validateOptional)(Ft),
        global: (0, ve.validateOptional)(Ft),
        id: (0, ve.validateType)(['Identifier', 'StringLiteral']),
        body: (0, ve.validateType)(['TSModuleBlock', 'TSModuleDeclaration']),
      },
    }),
    qe('TSModuleBlock', {
      aliases: ['Scopable', 'Block', 'BlockParent'],
      visitor: ['body'],
      fields: { body: (0, ve.validateArrayOfType)('Statement') },
    }),
    qe('TSImportType', {
      aliases: ['TSType'],
      visitor: ['argument', 'qualifier', 'typeParameters'],
      fields: {
        argument: (0, ve.validateType)('StringLiteral'),
        qualifier: (0, ve.validateOptionalType)('TSEntityName'),
        typeParameters: (0, ve.validateOptionalType)('TSTypeParameterInstantiation'),
      },
    }),
    qe('TSImportEqualsDeclaration', {
      aliases: ['Statement'],
      visitor: ['id', 'moduleReference'],
      fields: {
        isExport: (0, ve.validate)(Ft),
        id: (0, ve.validateType)('Identifier'),
        moduleReference: (0, ve.validateType)(['TSEntityName', 'TSExternalModuleReference']),
        importKind: { validate: (0, ve.assertOneOf)('type', 'value'), optional: !0 },
      },
    }),
    qe('TSExternalModuleReference', {
      visitor: ['expression'],
      fields: { expression: (0, ve.validateType)('StringLiteral') },
    }),
    qe('TSNonNullExpression', {
      aliases: ['Expression', 'LVal', 'PatternLike'],
      visitor: ['expression'],
      fields: { expression: (0, ve.validateType)('Expression') },
    }),
    qe('TSExportAssignment', {
      aliases: ['Statement'],
      visitor: ['expression'],
      fields: { expression: (0, ve.validateType)('Expression') },
    }),
    qe('TSNamespaceExportDeclaration', {
      aliases: ['Statement'],
      visitor: ['id'],
      fields: { id: (0, ve.validateType)('Identifier') },
    }),
    qe('TSTypeAnnotation', {
      visitor: ['typeAnnotation'],
      fields: { typeAnnotation: { validate: (0, ve.assertNodeType)('TSType') } },
    }),
    qe('TSTypeParameterInstantiation', {
      visitor: ['params'],
      fields: {
        params: {
          validate: (0, ve.chain)(
            (0, ve.assertValueType)('array'),
            (0, ve.assertEach)((0, ve.assertNodeType)('TSType'))
          ),
        },
      },
    }),
    qe('TSTypeParameterDeclaration', {
      visitor: ['params'],
      fields: {
        params: {
          validate: (0, ve.chain)(
            (0, ve.assertValueType)('array'),
            (0, ve.assertEach)((0, ve.assertNodeType)('TSTypeParameter'))
          ),
        },
      },
    }),
    qe('TSTypeParameter', {
      builder: ['constraint', 'default', 'name'],
      visitor: ['constraint', 'default'],
      fields: {
        name: { validate: (0, ve.assertValueType)('string') },
        in: { validate: (0, ve.assertValueType)('boolean'), optional: !0 },
        out: { validate: (0, ve.assertValueType)('boolean'), optional: !0 },
        constraint: { validate: (0, ve.assertNodeType)('TSType'), optional: !0 },
        default: { validate: (0, ve.assertNodeType)('TSType'), optional: !0 },
      },
    }),
    (function (t) {
      Object.defineProperty(t, '__esModule', { value: !0 }),
        Object.defineProperty(t, 'ALIAS_KEYS', {
          enumerable: !0,
          get: function () {
            return r.ALIAS_KEYS
          },
        }),
        Object.defineProperty(t, 'BUILDER_KEYS', {
          enumerable: !0,
          get: function () {
            return r.BUILDER_KEYS
          },
        }),
        Object.defineProperty(t, 'DEPRECATED_KEYS', {
          enumerable: !0,
          get: function () {
            return r.DEPRECATED_KEYS
          },
        }),
        Object.defineProperty(t, 'FLIPPED_ALIAS_KEYS', {
          enumerable: !0,
          get: function () {
            return r.FLIPPED_ALIAS_KEYS
          },
        }),
        Object.defineProperty(t, 'NODE_FIELDS', {
          enumerable: !0,
          get: function () {
            return r.NODE_FIELDS
          },
        }),
        Object.defineProperty(t, 'NODE_PARENT_VALIDATIONS', {
          enumerable: !0,
          get: function () {
            return r.NODE_PARENT_VALIDATIONS
          },
        }),
        Object.defineProperty(t, 'PLACEHOLDERS', {
          enumerable: !0,
          get: function () {
            return i.PLACEHOLDERS
          },
        }),
        Object.defineProperty(t, 'PLACEHOLDERS_ALIAS', {
          enumerable: !0,
          get: function () {
            return i.PLACEHOLDERS_ALIAS
          },
        }),
        Object.defineProperty(t, 'PLACEHOLDERS_FLIPPED_ALIAS', {
          enumerable: !0,
          get: function () {
            return i.PLACEHOLDERS_FLIPPED_ALIAS
          },
        }),
        (t.TYPES = void 0),
        Object.defineProperty(t, 'VISITOR_KEYS', {
          enumerable: !0,
          get: function () {
            return r.VISITOR_KEYS
          },
        })
      var e = lA,
        r = tt,
        i = _r
      e(r.VISITOR_KEYS),
        e(r.ALIAS_KEYS),
        e(r.FLIPPED_ALIAS_KEYS),
        e(r.NODE_FIELDS),
        e(r.BUILDER_KEYS),
        e(r.DEPRECATED_KEYS),
        e(i.PLACEHOLDERS_ALIAS),
        e(i.PLACEHOLDERS_FLIPPED_ALIAS)
      const n = [].concat(
        Object.keys(r.VISITOR_KEYS),
        Object.keys(r.FLIPPED_ALIAS_KEYS),
        Object.keys(r.DEPRECATED_KEYS)
      )
      t.TYPES = n
    })(fr),
    Object.defineProperty(_i, '__esModule', { value: !0 }),
    (_i.default = eC),
    (_i.validateChild = Vd),
    (_i.validateField = _d)
  var jd = fr
  function eC(t, e, r) {
    if (!t) return
    const i = jd.NODE_FIELDS[t.type]
    if (!i) return
    const n = i[e]
    _d(t, e, r, n), Vd(t, e, r)
  }
  function _d(t, e, r, i) {
    !(i != null && i.validate) || (i.optional && r == null) || i.validate(t, e, r)
  }
  function Vd(t, e, r) {
    if (r == null) return
    const i = jd.NODE_PARENT_VALIDATIONS[r.type]
    !i || i(t, e, r)
  }
  Object.defineProperty(tu, '__esModule', { value: !0 }), (tu.default = iC)
  var tC = _i,
    rC = st
  function iC(t) {
    const e = rC.BUILDER_KEYS[t.type]
    for (const r of e) (0, tC.default)(t, r, t[r])
    return t
  }
  Object.defineProperty(M, '__esModule', { value: !0 }),
    (M.anyTypeAnnotation = Bx),
    (M.argumentPlaceholder = lI),
    (M.arrayExpression = nC),
    (M.arrayPattern = QC),
    (M.arrayTypeAnnotation = Lx),
    (M.arrowFunctionExpression = ex),
    (M.assignmentExpression = sC),
    (M.assignmentPattern = ZC),
    (M.awaitExpression = vx),
    (M.bigIntLiteral = Px),
    (M.binaryExpression = aC),
    (M.bindExpression = uI),
    (M.blockStatement = cC),
    (M.booleanLiteral = NC),
    (M.booleanLiteralTypeAnnotation = Fx),
    (M.booleanTypeAnnotation = Mx),
    (M.breakStatement = pC),
    (M.callExpression = fC),
    (M.catchClause = hC),
    (M.classAccessorProperty = Ix),
    (M.classBody = tx),
    (M.classDeclaration = ix),
    (M.classExpression = rx),
    (M.classImplements = Rx),
    (M.classMethod = dx),
    (M.classPrivateMethod = Nx),
    (M.classPrivateProperty = kx),
    (M.classProperty = xx),
    (M.conditionalExpression = dC),
    (M.continueStatement = mC),
    (M.debuggerStatement = yC),
    (M.decimalLiteral = yI),
    (M.declareClass = jx),
    (M.declareExportAllDeclaration = qx),
    (M.declareExportDeclaration = Hx),
    (M.declareFunction = _x),
    (M.declareInterface = Vx),
    (M.declareModule = Ux),
    (M.declareModuleExports = zx),
    (M.declareOpaqueType = Wx),
    (M.declareTypeAlias = Kx),
    (M.declareVariable = Yx),
    (M.declaredPredicate = Xx),
    (M.decorator = pI),
    (M.directive = lC),
    (M.directiveLiteral = uC),
    (M.doExpression = fI),
    (M.doWhileStatement = gC),
    (M.emptyStatement = TC),
    (M.emptyTypeAnnotation = a2),
    (M.enumBooleanBody = L2),
    (M.enumBooleanMember = R2),
    (M.enumDeclaration = B2),
    (M.enumDefaultedMember = V2),
    (M.enumNumberBody = M2),
    (M.enumNumberMember = j2),
    (M.enumStringBody = F2),
    (M.enumStringMember = _2),
    (M.enumSymbolBody = $2),
    (M.existsTypeAnnotation = Gx),
    (M.exportAllDeclaration = nx),
    (M.exportDefaultDeclaration = sx),
    (M.exportDefaultSpecifier = hI),
    (M.exportNamedDeclaration = ax),
    (M.exportNamespaceSpecifier = wx),
    (M.exportSpecifier = ox),
    (M.expressionStatement = bC),
    (M.file = SC),
    (M.forInStatement = vC),
    (M.forOfStatement = lx),
    (M.forStatement = EC),
    (M.functionDeclaration = PC),
    (M.functionExpression = wC),
    (M.functionTypeAnnotation = Jx),
    (M.functionTypeParam = Zx),
    (M.genericTypeAnnotation = Qx),
    (M.identifier = AC),
    (M.ifStatement = CC),
    (M.import = Ex),
    (M.importAttribute = cI),
    (M.importDeclaration = ux),
    (M.importDefaultSpecifier = cx),
    (M.importNamespaceSpecifier = px),
    (M.importSpecifier = fx),
    (M.indexedAccessType = U2),
    (M.inferredPredicate = e2),
    (M.interfaceDeclaration = r2),
    (M.interfaceExtends = t2),
    (M.interfaceTypeAnnotation = i2),
    (M.interpreterDirective = oC),
    (M.intersectionTypeAnnotation = n2),
    (M.jSXAttribute = M.jsxAttribute = K2),
    (M.jSXClosingElement = M.jsxClosingElement = W2),
    (M.jSXClosingFragment = M.jsxClosingFragment = nI),
    (M.jSXElement = M.jsxElement = Y2),
    (M.jSXEmptyExpression = M.jsxEmptyExpression = H2),
    (M.jSXExpressionContainer = M.jsxExpressionContainer = q2),
    (M.jSXFragment = M.jsxFragment = rI),
    (M.jSXIdentifier = M.jsxIdentifier = G2),
    (M.jSXMemberExpression = M.jsxMemberExpression = J2),
    (M.jSXNamespacedName = M.jsxNamespacedName = Z2),
    (M.jSXOpeningElement = M.jsxOpeningElement = Q2),
    (M.jSXOpeningFragment = M.jsxOpeningFragment = iI),
    (M.jSXSpreadAttribute = M.jsxSpreadAttribute = eI),
    (M.jSXSpreadChild = M.jsxSpreadChild = X2),
    (M.jSXText = M.jsxText = tI),
    (M.labeledStatement = xC),
    (M.logicalExpression = OC),
    (M.memberExpression = DC),
    (M.metaProperty = hx),
    (M.mixedTypeAnnotation = s2),
    (M.moduleExpression = gI),
    (M.newExpression = BC),
    (M.noop = sI),
    (M.nullLiteral = kC),
    (M.nullLiteralTypeAnnotation = $x),
    (M.nullableTypeAnnotation = o2),
    (M.numberLiteral = Dk),
    (M.numberLiteralTypeAnnotation = l2),
    (M.numberTypeAnnotation = u2),
    (M.numericLiteral = Ud),
    (M.objectExpression = MC),
    (M.objectMethod = FC),
    (M.objectPattern = mx),
    (M.objectProperty = $C),
    (M.objectTypeAnnotation = c2),
    (M.objectTypeCallProperty = f2),
    (M.objectTypeIndexer = h2),
    (M.objectTypeInternalSlot = p2),
    (M.objectTypeProperty = d2),
    (M.objectTypeSpreadProperty = m2),
    (M.opaqueType = y2),
    (M.optionalCallExpression = Cx),
    (M.optionalIndexedAccessType = z2),
    (M.optionalMemberExpression = Ax),
    (M.parenthesizedExpression = _C),
    (M.pipelineBareFunction = SI),
    (M.pipelinePrimaryTopicReference = vI),
    (M.pipelineTopicExpression = bI),
    (M.placeholder = aI),
    (M.privateName = Ox),
    (M.program = LC),
    (M.qualifiedTypeIdentifier = g2),
    (M.recordExpression = dI),
    (M.regExpLiteral = zd),
    (M.regexLiteral = Bk),
    (M.restElement = Kd),
    (M.restProperty = Lk),
    (M.returnStatement = RC),
    (M.sequenceExpression = jC),
    (M.spreadElement = Wd),
    (M.spreadProperty = Mk),
    (M.staticBlock = Dx),
    (M.stringLiteral = IC),
    (M.stringLiteralTypeAnnotation = T2),
    (M.stringTypeAnnotation = b2),
    (M.super = yx),
    (M.switchCase = VC),
    (M.switchStatement = UC),
    (M.symbolTypeAnnotation = S2),
    (M.taggedTemplateExpression = gx),
    (M.templateElement = Tx),
    (M.templateLiteral = bx),
    (M.thisExpression = zC),
    (M.thisTypeAnnotation = v2),
    (M.throwStatement = KC),
    (M.topicReference = TI),
    (M.tryStatement = WC),
    (M.tSAnyKeyword = M.tsAnyKeyword = OI),
    (M.tSArrayType = M.tsArrayType = JI),
    (M.tSAsExpression = M.tsAsExpression = yk),
    (M.tSBigIntKeyword = M.tsBigIntKeyword = BI),
    (M.tSBooleanKeyword = M.tsBooleanKeyword = DI),
    (M.tSCallSignatureDeclaration = M.tsCallSignatureDeclaration = CI),
    (M.tSConditionalType = M.tsConditionalType = nk),
    (M.tSConstructSignatureDeclaration = M.tsConstructSignatureDeclaration = xI),
    (M.tSConstructorType = M.tsConstructorType = YI),
    (M.tSDeclareFunction = M.tsDeclareFunction = PI),
    (M.tSDeclareMethod = M.tsDeclareMethod = wI),
    (M.tSEnumDeclaration = M.tsEnumDeclaration = Tk),
    (M.tSEnumMember = M.tsEnumMember = bk),
    (M.tSExportAssignment = M.tsExportAssignment = Ck),
    (M.tSExpressionWithTypeArguments = M.tsExpressionWithTypeArguments = pk),
    (M.tSExternalModuleReference = M.tsExternalModuleReference = wk),
    (M.tSFunctionType = M.tsFunctionType = WI),
    (M.tSImportEqualsDeclaration = M.tsImportEqualsDeclaration = Pk),
    (M.tSImportType = M.tsImportType = Ek),
    (M.tSIndexSignature = M.tsIndexSignature = NI),
    (M.tSIndexedAccessType = M.tsIndexedAccessType = lk),
    (M.tSInferType = M.tsInferType = sk),
    (M.tSInstantiationExpression = M.tsInstantiationExpression = mk),
    (M.tSInterfaceBody = M.tsInterfaceBody = hk),
    (M.tSInterfaceDeclaration = M.tsInterfaceDeclaration = fk),
    (M.tSIntersectionType = M.tsIntersectionType = ik),
    (M.tSIntrinsicKeyword = M.tsIntrinsicKeyword = LI),
    (M.tSLiteralType = M.tsLiteralType = ck),
    (M.tSMappedType = M.tsMappedType = uk),
    (M.tSMethodSignature = M.tsMethodSignature = kI),
    (M.tSModuleBlock = M.tsModuleBlock = vk),
    (M.tSModuleDeclaration = M.tsModuleDeclaration = Sk),
    (M.tSNamedTupleMember = M.tsNamedTupleMember = tk),
    (M.tSNamespaceExportDeclaration = M.tsNamespaceExportDeclaration = xk),
    (M.tSNeverKeyword = M.tsNeverKeyword = MI),
    (M.tSNonNullExpression = M.tsNonNullExpression = Ak),
    (M.tSNullKeyword = M.tsNullKeyword = FI),
    (M.tSNumberKeyword = M.tsNumberKeyword = $I),
    (M.tSObjectKeyword = M.tsObjectKeyword = RI),
    (M.tSOptionalType = M.tsOptionalType = QI),
    (M.tSParameterProperty = M.tsParameterProperty = EI),
    (M.tSParenthesizedType = M.tsParenthesizedType = ak),
    (M.tSPropertySignature = M.tsPropertySignature = II),
    (M.tSQualifiedName = M.tsQualifiedName = AI),
    (M.tSRestType = M.tsRestType = ek),
    (M.tSStringKeyword = M.tsStringKeyword = jI),
    (M.tSSymbolKeyword = M.tsSymbolKeyword = _I),
    (M.tSThisType = M.tsThisType = KI),
    (M.tSTupleType = M.tsTupleType = ZI),
    (M.tSTypeAliasDeclaration = M.tsTypeAliasDeclaration = dk),
    (M.tSTypeAnnotation = M.tsTypeAnnotation = Ik),
    (M.tSTypeAssertion = M.tsTypeAssertion = gk),
    (M.tSTypeLiteral = M.tsTypeLiteral = GI),
    (M.tSTypeOperator = M.tsTypeOperator = ok),
    (M.tSTypeParameter = M.tsTypeParameter = Ok),
    (M.tSTypeParameterDeclaration = M.tsTypeParameterDeclaration = Nk),
    (M.tSTypeParameterInstantiation = M.tsTypeParameterInstantiation = kk),
    (M.tSTypePredicate = M.tsTypePredicate = qI),
    (M.tSTypeQuery = M.tsTypeQuery = XI),
    (M.tSTypeReference = M.tsTypeReference = HI),
    (M.tSUndefinedKeyword = M.tsUndefinedKeyword = VI),
    (M.tSUnionType = M.tsUnionType = rk),
    (M.tSUnknownKeyword = M.tsUnknownKeyword = UI),
    (M.tSVoidKeyword = M.tsVoidKeyword = zI),
    (M.tupleExpression = mI),
    (M.tupleTypeAnnotation = E2),
    (M.typeAlias = w2),
    (M.typeAnnotation = A2),
    (M.typeCastExpression = C2),
    (M.typeParameter = x2),
    (M.typeParameterDeclaration = I2),
    (M.typeParameterInstantiation = k2),
    (M.typeofTypeAnnotation = P2),
    (M.unaryExpression = YC),
    (M.unionTypeAnnotation = N2),
    (M.updateExpression = HC),
    (M.v8IntrinsicIdentifier = oI),
    (M.variableDeclaration = qC),
    (M.variableDeclarator = XC),
    (M.variance = O2),
    (M.voidTypeAnnotation = D2),
    (M.whileStatement = GC),
    (M.withStatement = JC),
    (M.yieldExpression = Sx)
  var Q = tu
  function nC(t = []) {
    return (0, Q.default)({ type: 'ArrayExpression', elements: t })
  }
  function sC(t, e, r) {
    return (0, Q.default)({ type: 'AssignmentExpression', operator: t, left: e, right: r })
  }
  function aC(t, e, r) {
    return (0, Q.default)({ type: 'BinaryExpression', operator: t, left: e, right: r })
  }
  function oC(t) {
    return (0, Q.default)({ type: 'InterpreterDirective', value: t })
  }
  function lC(t) {
    return (0, Q.default)({ type: 'Directive', value: t })
  }
  function uC(t) {
    return (0, Q.default)({ type: 'DirectiveLiteral', value: t })
  }
  function cC(t, e = []) {
    return (0, Q.default)({ type: 'BlockStatement', body: t, directives: e })
  }
  function pC(t = null) {
    return (0, Q.default)({ type: 'BreakStatement', label: t })
  }
  function fC(t, e) {
    return (0, Q.default)({ type: 'CallExpression', callee: t, arguments: e })
  }
  function hC(t = null, e) {
    return (0, Q.default)({ type: 'CatchClause', param: t, body: e })
  }
  function dC(t, e, r) {
    return (0, Q.default)({ type: 'ConditionalExpression', test: t, consequent: e, alternate: r })
  }
  function mC(t = null) {
    return (0, Q.default)({ type: 'ContinueStatement', label: t })
  }
  function yC() {
    return { type: 'DebuggerStatement' }
  }
  function gC(t, e) {
    return (0, Q.default)({ type: 'DoWhileStatement', test: t, body: e })
  }
  function TC() {
    return { type: 'EmptyStatement' }
  }
  function bC(t) {
    return (0, Q.default)({ type: 'ExpressionStatement', expression: t })
  }
  function SC(t, e = null, r = null) {
    return (0, Q.default)({ type: 'File', program: t, comments: e, tokens: r })
  }
  function vC(t, e, r) {
    return (0, Q.default)({ type: 'ForInStatement', left: t, right: e, body: r })
  }
  function EC(t = null, e = null, r = null, i) {
    return (0, Q.default)({ type: 'ForStatement', init: t, test: e, update: r, body: i })
  }
  function PC(t = null, e, r, i = !1, n = !1) {
    return (0, Q.default)({ type: 'FunctionDeclaration', id: t, params: e, body: r, generator: i, async: n })
  }
  function wC(t = null, e, r, i = !1, n = !1) {
    return (0, Q.default)({ type: 'FunctionExpression', id: t, params: e, body: r, generator: i, async: n })
  }
  function AC(t) {
    return (0, Q.default)({ type: 'Identifier', name: t })
  }
  function CC(t, e, r = null) {
    return (0, Q.default)({ type: 'IfStatement', test: t, consequent: e, alternate: r })
  }
  function xC(t, e) {
    return (0, Q.default)({ type: 'LabeledStatement', label: t, body: e })
  }
  function IC(t) {
    return (0, Q.default)({ type: 'StringLiteral', value: t })
  }
  function Ud(t) {
    return (0, Q.default)({ type: 'NumericLiteral', value: t })
  }
  function kC() {
    return { type: 'NullLiteral' }
  }
  function NC(t) {
    return (0, Q.default)({ type: 'BooleanLiteral', value: t })
  }
  function zd(t, e = '') {
    return (0, Q.default)({ type: 'RegExpLiteral', pattern: t, flags: e })
  }
  function OC(t, e, r) {
    return (0, Q.default)({ type: 'LogicalExpression', operator: t, left: e, right: r })
  }
  function DC(t, e, r = !1, i = null) {
    return (0, Q.default)({ type: 'MemberExpression', object: t, property: e, computed: r, optional: i })
  }
  function BC(t, e) {
    return (0, Q.default)({ type: 'NewExpression', callee: t, arguments: e })
  }
  function LC(t, e = [], r = 'script', i = null) {
    return (0, Q.default)({ type: 'Program', body: t, directives: e, sourceType: r, interpreter: i, sourceFile: null })
  }
  function MC(t) {
    return (0, Q.default)({ type: 'ObjectExpression', properties: t })
  }
  function FC(t = 'method', e, r, i, n = !1, s = !1, a = !1) {
    return (0,
    Q.default)({ type: 'ObjectMethod', kind: t, key: e, params: r, body: i, computed: n, generator: s, async: a })
  }
  function $C(t, e, r = !1, i = !1, n = null) {
    return (0, Q.default)({ type: 'ObjectProperty', key: t, value: e, computed: r, shorthand: i, decorators: n })
  }
  function Kd(t) {
    return (0, Q.default)({ type: 'RestElement', argument: t })
  }
  function RC(t = null) {
    return (0, Q.default)({ type: 'ReturnStatement', argument: t })
  }
  function jC(t) {
    return (0, Q.default)({ type: 'SequenceExpression', expressions: t })
  }
  function _C(t) {
    return (0, Q.default)({ type: 'ParenthesizedExpression', expression: t })
  }
  function VC(t = null, e) {
    return (0, Q.default)({ type: 'SwitchCase', test: t, consequent: e })
  }
  function UC(t, e) {
    return (0, Q.default)({ type: 'SwitchStatement', discriminant: t, cases: e })
  }
  function zC() {
    return { type: 'ThisExpression' }
  }
  function KC(t) {
    return (0, Q.default)({ type: 'ThrowStatement', argument: t })
  }
  function WC(t, e = null, r = null) {
    return (0, Q.default)({ type: 'TryStatement', block: t, handler: e, finalizer: r })
  }
  function YC(t, e, r = !0) {
    return (0, Q.default)({ type: 'UnaryExpression', operator: t, argument: e, prefix: r })
  }
  function HC(t, e, r = !1) {
    return (0, Q.default)({ type: 'UpdateExpression', operator: t, argument: e, prefix: r })
  }
  function qC(t, e) {
    return (0, Q.default)({ type: 'VariableDeclaration', kind: t, declarations: e })
  }
  function XC(t, e = null) {
    return (0, Q.default)({ type: 'VariableDeclarator', id: t, init: e })
  }
  function GC(t, e) {
    return (0, Q.default)({ type: 'WhileStatement', test: t, body: e })
  }
  function JC(t, e) {
    return (0, Q.default)({ type: 'WithStatement', object: t, body: e })
  }
  function ZC(t, e) {
    return (0, Q.default)({ type: 'AssignmentPattern', left: t, right: e })
  }
  function QC(t) {
    return (0, Q.default)({ type: 'ArrayPattern', elements: t })
  }
  function ex(t, e, r = !1) {
    return (0, Q.default)({ type: 'ArrowFunctionExpression', params: t, body: e, async: r, expression: null })
  }
  function tx(t) {
    return (0, Q.default)({ type: 'ClassBody', body: t })
  }
  function rx(t = null, e = null, r, i = null) {
    return (0, Q.default)({ type: 'ClassExpression', id: t, superClass: e, body: r, decorators: i })
  }
  function ix(t, e = null, r, i = null) {
    return (0, Q.default)({ type: 'ClassDeclaration', id: t, superClass: e, body: r, decorators: i })
  }
  function nx(t) {
    return (0, Q.default)({ type: 'ExportAllDeclaration', source: t })
  }
  function sx(t) {
    return (0, Q.default)({ type: 'ExportDefaultDeclaration', declaration: t })
  }
  function ax(t = null, e = [], r = null) {
    return (0, Q.default)({ type: 'ExportNamedDeclaration', declaration: t, specifiers: e, source: r })
  }
  function ox(t, e) {
    return (0, Q.default)({ type: 'ExportSpecifier', local: t, exported: e })
  }
  function lx(t, e, r, i = !1) {
    return (0, Q.default)({ type: 'ForOfStatement', left: t, right: e, body: r, await: i })
  }
  function ux(t, e) {
    return (0, Q.default)({ type: 'ImportDeclaration', specifiers: t, source: e })
  }
  function cx(t) {
    return (0, Q.default)({ type: 'ImportDefaultSpecifier', local: t })
  }
  function px(t) {
    return (0, Q.default)({ type: 'ImportNamespaceSpecifier', local: t })
  }
  function fx(t, e) {
    return (0, Q.default)({ type: 'ImportSpecifier', local: t, imported: e })
  }
  function hx(t, e) {
    return (0, Q.default)({ type: 'MetaProperty', meta: t, property: e })
  }
  function dx(t = 'method', e, r, i, n = !1, s = !1, a = !1, o = !1) {
    return (0,
    Q.default)({ type: 'ClassMethod', kind: t, key: e, params: r, body: i, computed: n, static: s, generator: a, async: o })
  }
  function mx(t) {
    return (0, Q.default)({ type: 'ObjectPattern', properties: t })
  }
  function Wd(t) {
    return (0, Q.default)({ type: 'SpreadElement', argument: t })
  }
  function yx() {
    return { type: 'Super' }
  }
  function gx(t, e) {
    return (0, Q.default)({ type: 'TaggedTemplateExpression', tag: t, quasi: e })
  }
  function Tx(t, e = !1) {
    return (0, Q.default)({ type: 'TemplateElement', value: t, tail: e })
  }
  function bx(t, e) {
    return (0, Q.default)({ type: 'TemplateLiteral', quasis: t, expressions: e })
  }
  function Sx(t = null, e = !1) {
    return (0, Q.default)({ type: 'YieldExpression', argument: t, delegate: e })
  }
  function vx(t) {
    return (0, Q.default)({ type: 'AwaitExpression', argument: t })
  }
  function Ex() {
    return { type: 'Import' }
  }
  function Px(t) {
    return (0, Q.default)({ type: 'BigIntLiteral', value: t })
  }
  function wx(t) {
    return (0, Q.default)({ type: 'ExportNamespaceSpecifier', exported: t })
  }
  function Ax(t, e, r = !1, i) {
    return (0, Q.default)({ type: 'OptionalMemberExpression', object: t, property: e, computed: r, optional: i })
  }
  function Cx(t, e, r) {
    return (0, Q.default)({ type: 'OptionalCallExpression', callee: t, arguments: e, optional: r })
  }
  function xx(t, e = null, r = null, i = null, n = !1, s = !1) {
    return (0,
    Q.default)({ type: 'ClassProperty', key: t, value: e, typeAnnotation: r, decorators: i, computed: n, static: s })
  }
  function Ix(t, e = null, r = null, i = null, n = !1, s = !1) {
    return (0,
    Q.default)({ type: 'ClassAccessorProperty', key: t, value: e, typeAnnotation: r, decorators: i, computed: n, static: s })
  }
  function kx(t, e = null, r = null, i) {
    return (0, Q.default)({ type: 'ClassPrivateProperty', key: t, value: e, decorators: r, static: i })
  }
  function Nx(t = 'method', e, r, i, n = !1) {
    return (0, Q.default)({ type: 'ClassPrivateMethod', kind: t, key: e, params: r, body: i, static: n })
  }
  function Ox(t) {
    return (0, Q.default)({ type: 'PrivateName', id: t })
  }
  function Dx(t) {
    return (0, Q.default)({ type: 'StaticBlock', body: t })
  }
  function Bx() {
    return { type: 'AnyTypeAnnotation' }
  }
  function Lx(t) {
    return (0, Q.default)({ type: 'ArrayTypeAnnotation', elementType: t })
  }
  function Mx() {
    return { type: 'BooleanTypeAnnotation' }
  }
  function Fx(t) {
    return (0, Q.default)({ type: 'BooleanLiteralTypeAnnotation', value: t })
  }
  function $x() {
    return { type: 'NullLiteralTypeAnnotation' }
  }
  function Rx(t, e = null) {
    return (0, Q.default)({ type: 'ClassImplements', id: t, typeParameters: e })
  }
  function jx(t, e = null, r = null, i) {
    return (0, Q.default)({ type: 'DeclareClass', id: t, typeParameters: e, extends: r, body: i })
  }
  function _x(t) {
    return (0, Q.default)({ type: 'DeclareFunction', id: t })
  }
  function Vx(t, e = null, r = null, i) {
    return (0, Q.default)({ type: 'DeclareInterface', id: t, typeParameters: e, extends: r, body: i })
  }
  function Ux(t, e, r = null) {
    return (0, Q.default)({ type: 'DeclareModule', id: t, body: e, kind: r })
  }
  function zx(t) {
    return (0, Q.default)({ type: 'DeclareModuleExports', typeAnnotation: t })
  }
  function Kx(t, e = null, r) {
    return (0, Q.default)({ type: 'DeclareTypeAlias', id: t, typeParameters: e, right: r })
  }
  function Wx(t, e = null, r = null) {
    return (0, Q.default)({ type: 'DeclareOpaqueType', id: t, typeParameters: e, supertype: r })
  }
  function Yx(t) {
    return (0, Q.default)({ type: 'DeclareVariable', id: t })
  }
  function Hx(t = null, e = null, r = null) {
    return (0, Q.default)({ type: 'DeclareExportDeclaration', declaration: t, specifiers: e, source: r })
  }
  function qx(t) {
    return (0, Q.default)({ type: 'DeclareExportAllDeclaration', source: t })
  }
  function Xx(t) {
    return (0, Q.default)({ type: 'DeclaredPredicate', value: t })
  }
  function Gx() {
    return { type: 'ExistsTypeAnnotation' }
  }
  function Jx(t = null, e, r = null, i) {
    return (0, Q.default)({ type: 'FunctionTypeAnnotation', typeParameters: t, params: e, rest: r, returnType: i })
  }
  function Zx(t = null, e) {
    return (0, Q.default)({ type: 'FunctionTypeParam', name: t, typeAnnotation: e })
  }
  function Qx(t, e = null) {
    return (0, Q.default)({ type: 'GenericTypeAnnotation', id: t, typeParameters: e })
  }
  function e2() {
    return { type: 'InferredPredicate' }
  }
  function t2(t, e = null) {
    return (0, Q.default)({ type: 'InterfaceExtends', id: t, typeParameters: e })
  }
  function r2(t, e = null, r = null, i) {
    return (0, Q.default)({ type: 'InterfaceDeclaration', id: t, typeParameters: e, extends: r, body: i })
  }
  function i2(t = null, e) {
    return (0, Q.default)({ type: 'InterfaceTypeAnnotation', extends: t, body: e })
  }
  function n2(t) {
    return (0, Q.default)({ type: 'IntersectionTypeAnnotation', types: t })
  }
  function s2() {
    return { type: 'MixedTypeAnnotation' }
  }
  function a2() {
    return { type: 'EmptyTypeAnnotation' }
  }
  function o2(t) {
    return (0, Q.default)({ type: 'NullableTypeAnnotation', typeAnnotation: t })
  }
  function l2(t) {
    return (0, Q.default)({ type: 'NumberLiteralTypeAnnotation', value: t })
  }
  function u2() {
    return { type: 'NumberTypeAnnotation' }
  }
  function c2(t, e = [], r = [], i = [], n = !1) {
    return (0,
    Q.default)({ type: 'ObjectTypeAnnotation', properties: t, indexers: e, callProperties: r, internalSlots: i, exact: n })
  }
  function p2(t, e, r, i, n) {
    return (0, Q.default)({ type: 'ObjectTypeInternalSlot', id: t, value: e, optional: r, static: i, method: n })
  }
  function f2(t) {
    return (0, Q.default)({ type: 'ObjectTypeCallProperty', value: t, static: null })
  }
  function h2(t = null, e, r, i = null) {
    return (0, Q.default)({ type: 'ObjectTypeIndexer', id: t, key: e, value: r, variance: i, static: null })
  }
  function d2(t, e, r = null) {
    return (0,
    Q.default)({ type: 'ObjectTypeProperty', key: t, value: e, variance: r, kind: null, method: null, optional: null, proto: null, static: null })
  }
  function m2(t) {
    return (0, Q.default)({ type: 'ObjectTypeSpreadProperty', argument: t })
  }
  function y2(t, e = null, r = null, i) {
    return (0, Q.default)({ type: 'OpaqueType', id: t, typeParameters: e, supertype: r, impltype: i })
  }
  function g2(t, e) {
    return (0, Q.default)({ type: 'QualifiedTypeIdentifier', id: t, qualification: e })
  }
  function T2(t) {
    return (0, Q.default)({ type: 'StringLiteralTypeAnnotation', value: t })
  }
  function b2() {
    return { type: 'StringTypeAnnotation' }
  }
  function S2() {
    return { type: 'SymbolTypeAnnotation' }
  }
  function v2() {
    return { type: 'ThisTypeAnnotation' }
  }
  function E2(t) {
    return (0, Q.default)({ type: 'TupleTypeAnnotation', types: t })
  }
  function P2(t) {
    return (0, Q.default)({ type: 'TypeofTypeAnnotation', argument: t })
  }
  function w2(t, e = null, r) {
    return (0, Q.default)({ type: 'TypeAlias', id: t, typeParameters: e, right: r })
  }
  function A2(t) {
    return (0, Q.default)({ type: 'TypeAnnotation', typeAnnotation: t })
  }
  function C2(t, e) {
    return (0, Q.default)({ type: 'TypeCastExpression', expression: t, typeAnnotation: e })
  }
  function x2(t = null, e = null, r = null) {
    return (0, Q.default)({ type: 'TypeParameter', bound: t, default: e, variance: r, name: null })
  }
  function I2(t) {
    return (0, Q.default)({ type: 'TypeParameterDeclaration', params: t })
  }
  function k2(t) {
    return (0, Q.default)({ type: 'TypeParameterInstantiation', params: t })
  }
  function N2(t) {
    return (0, Q.default)({ type: 'UnionTypeAnnotation', types: t })
  }
  function O2(t) {
    return (0, Q.default)({ type: 'Variance', kind: t })
  }
  function D2() {
    return { type: 'VoidTypeAnnotation' }
  }
  function B2(t, e) {
    return (0, Q.default)({ type: 'EnumDeclaration', id: t, body: e })
  }
  function L2(t) {
    return (0, Q.default)({ type: 'EnumBooleanBody', members: t, explicitType: null, hasUnknownMembers: null })
  }
  function M2(t) {
    return (0, Q.default)({ type: 'EnumNumberBody', members: t, explicitType: null, hasUnknownMembers: null })
  }
  function F2(t) {
    return (0, Q.default)({ type: 'EnumStringBody', members: t, explicitType: null, hasUnknownMembers: null })
  }
  function $2(t) {
    return (0, Q.default)({ type: 'EnumSymbolBody', members: t, hasUnknownMembers: null })
  }
  function R2(t) {
    return (0, Q.default)({ type: 'EnumBooleanMember', id: t, init: null })
  }
  function j2(t, e) {
    return (0, Q.default)({ type: 'EnumNumberMember', id: t, init: e })
  }
  function _2(t, e) {
    return (0, Q.default)({ type: 'EnumStringMember', id: t, init: e })
  }
  function V2(t) {
    return (0, Q.default)({ type: 'EnumDefaultedMember', id: t })
  }
  function U2(t, e) {
    return (0, Q.default)({ type: 'IndexedAccessType', objectType: t, indexType: e })
  }
  function z2(t, e) {
    return (0, Q.default)({ type: 'OptionalIndexedAccessType', objectType: t, indexType: e, optional: null })
  }
  function K2(t, e = null) {
    return (0, Q.default)({ type: 'JSXAttribute', name: t, value: e })
  }
  function W2(t) {
    return (0, Q.default)({ type: 'JSXClosingElement', name: t })
  }
  function Y2(t, e = null, r, i = null) {
    return (0, Q.default)({ type: 'JSXElement', openingElement: t, closingElement: e, children: r, selfClosing: i })
  }
  function H2() {
    return { type: 'JSXEmptyExpression' }
  }
  function q2(t) {
    return (0, Q.default)({ type: 'JSXExpressionContainer', expression: t })
  }
  function X2(t) {
    return (0, Q.default)({ type: 'JSXSpreadChild', expression: t })
  }
  function G2(t) {
    return (0, Q.default)({ type: 'JSXIdentifier', name: t })
  }
  function J2(t, e) {
    return (0, Q.default)({ type: 'JSXMemberExpression', object: t, property: e })
  }
  function Z2(t, e) {
    return (0, Q.default)({ type: 'JSXNamespacedName', namespace: t, name: e })
  }
  function Q2(t, e, r = !1) {
    return (0, Q.default)({ type: 'JSXOpeningElement', name: t, attributes: e, selfClosing: r })
  }
  function eI(t) {
    return (0, Q.default)({ type: 'JSXSpreadAttribute', argument: t })
  }
  function tI(t) {
    return (0, Q.default)({ type: 'JSXText', value: t })
  }
  function rI(t, e, r) {
    return (0, Q.default)({ type: 'JSXFragment', openingFragment: t, closingFragment: e, children: r })
  }
  function iI() {
    return { type: 'JSXOpeningFragment' }
  }
  function nI() {
    return { type: 'JSXClosingFragment' }
  }
  function sI() {
    return { type: 'Noop' }
  }
  function aI(t, e) {
    return (0, Q.default)({ type: 'Placeholder', expectedNode: t, name: e })
  }
  function oI(t) {
    return (0, Q.default)({ type: 'V8IntrinsicIdentifier', name: t })
  }
  function lI() {
    return { type: 'ArgumentPlaceholder' }
  }
  function uI(t, e) {
    return (0, Q.default)({ type: 'BindExpression', object: t, callee: e })
  }
  function cI(t, e) {
    return (0, Q.default)({ type: 'ImportAttribute', key: t, value: e })
  }
  function pI(t) {
    return (0, Q.default)({ type: 'Decorator', expression: t })
  }
  function fI(t, e = !1) {
    return (0, Q.default)({ type: 'DoExpression', body: t, async: e })
  }
  function hI(t) {
    return (0, Q.default)({ type: 'ExportDefaultSpecifier', exported: t })
  }
  function dI(t) {
    return (0, Q.default)({ type: 'RecordExpression', properties: t })
  }
  function mI(t = []) {
    return (0, Q.default)({ type: 'TupleExpression', elements: t })
  }
  function yI(t) {
    return (0, Q.default)({ type: 'DecimalLiteral', value: t })
  }
  function gI(t) {
    return (0, Q.default)({ type: 'ModuleExpression', body: t })
  }
  function TI() {
    return { type: 'TopicReference' }
  }
  function bI(t) {
    return (0, Q.default)({ type: 'PipelineTopicExpression', expression: t })
  }
  function SI(t) {
    return (0, Q.default)({ type: 'PipelineBareFunction', callee: t })
  }
  function vI() {
    return { type: 'PipelinePrimaryTopicReference' }
  }
  function EI(t) {
    return (0, Q.default)({ type: 'TSParameterProperty', parameter: t })
  }
  function PI(t = null, e = null, r, i = null) {
    return (0, Q.default)({ type: 'TSDeclareFunction', id: t, typeParameters: e, params: r, returnType: i })
  }
  function wI(t = null, e, r = null, i, n = null) {
    return (0,
    Q.default)({ type: 'TSDeclareMethod', decorators: t, key: e, typeParameters: r, params: i, returnType: n })
  }
  function AI(t, e) {
    return (0, Q.default)({ type: 'TSQualifiedName', left: t, right: e })
  }
  function CI(t = null, e, r = null) {
    return (0, Q.default)({ type: 'TSCallSignatureDeclaration', typeParameters: t, parameters: e, typeAnnotation: r })
  }
  function xI(t = null, e, r = null) {
    return (0,
    Q.default)({ type: 'TSConstructSignatureDeclaration', typeParameters: t, parameters: e, typeAnnotation: r })
  }
  function II(t, e = null, r = null) {
    return (0, Q.default)({ type: 'TSPropertySignature', key: t, typeAnnotation: e, initializer: r, kind: null })
  }
  function kI(t, e = null, r, i = null) {
    return (0,
    Q.default)({ type: 'TSMethodSignature', key: t, typeParameters: e, parameters: r, typeAnnotation: i, kind: null })
  }
  function NI(t, e = null) {
    return (0, Q.default)({ type: 'TSIndexSignature', parameters: t, typeAnnotation: e })
  }
  function OI() {
    return { type: 'TSAnyKeyword' }
  }
  function DI() {
    return { type: 'TSBooleanKeyword' }
  }
  function BI() {
    return { type: 'TSBigIntKeyword' }
  }
  function LI() {
    return { type: 'TSIntrinsicKeyword' }
  }
  function MI() {
    return { type: 'TSNeverKeyword' }
  }
  function FI() {
    return { type: 'TSNullKeyword' }
  }
  function $I() {
    return { type: 'TSNumberKeyword' }
  }
  function RI() {
    return { type: 'TSObjectKeyword' }
  }
  function jI() {
    return { type: 'TSStringKeyword' }
  }
  function _I() {
    return { type: 'TSSymbolKeyword' }
  }
  function VI() {
    return { type: 'TSUndefinedKeyword' }
  }
  function UI() {
    return { type: 'TSUnknownKeyword' }
  }
  function zI() {
    return { type: 'TSVoidKeyword' }
  }
  function KI() {
    return { type: 'TSThisType' }
  }
  function WI(t = null, e, r = null) {
    return (0, Q.default)({ type: 'TSFunctionType', typeParameters: t, parameters: e, typeAnnotation: r })
  }
  function YI(t = null, e, r = null) {
    return (0, Q.default)({ type: 'TSConstructorType', typeParameters: t, parameters: e, typeAnnotation: r })
  }
  function HI(t, e = null) {
    return (0, Q.default)({ type: 'TSTypeReference', typeName: t, typeParameters: e })
  }
  function qI(t, e = null, r = null) {
    return (0, Q.default)({ type: 'TSTypePredicate', parameterName: t, typeAnnotation: e, asserts: r })
  }
  function XI(t, e = null) {
    return (0, Q.default)({ type: 'TSTypeQuery', exprName: t, typeParameters: e })
  }
  function GI(t) {
    return (0, Q.default)({ type: 'TSTypeLiteral', members: t })
  }
  function JI(t) {
    return (0, Q.default)({ type: 'TSArrayType', elementType: t })
  }
  function ZI(t) {
    return (0, Q.default)({ type: 'TSTupleType', elementTypes: t })
  }
  function QI(t) {
    return (0, Q.default)({ type: 'TSOptionalType', typeAnnotation: t })
  }
  function ek(t) {
    return (0, Q.default)({ type: 'TSRestType', typeAnnotation: t })
  }
  function tk(t, e, r = !1) {
    return (0, Q.default)({ type: 'TSNamedTupleMember', label: t, elementType: e, optional: r })
  }
  function rk(t) {
    return (0, Q.default)({ type: 'TSUnionType', types: t })
  }
  function ik(t) {
    return (0, Q.default)({ type: 'TSIntersectionType', types: t })
  }
  function nk(t, e, r, i) {
    return (0, Q.default)({ type: 'TSConditionalType', checkType: t, extendsType: e, trueType: r, falseType: i })
  }
  function sk(t) {
    return (0, Q.default)({ type: 'TSInferType', typeParameter: t })
  }
  function ak(t) {
    return (0, Q.default)({ type: 'TSParenthesizedType', typeAnnotation: t })
  }
  function ok(t) {
    return (0, Q.default)({ type: 'TSTypeOperator', typeAnnotation: t, operator: null })
  }
  function lk(t, e) {
    return (0, Q.default)({ type: 'TSIndexedAccessType', objectType: t, indexType: e })
  }
  function uk(t, e = null, r = null) {
    return (0, Q.default)({ type: 'TSMappedType', typeParameter: t, typeAnnotation: e, nameType: r })
  }
  function ck(t) {
    return (0, Q.default)({ type: 'TSLiteralType', literal: t })
  }
  function pk(t, e = null) {
    return (0, Q.default)({ type: 'TSExpressionWithTypeArguments', expression: t, typeParameters: e })
  }
  function fk(t, e = null, r = null, i) {
    return (0, Q.default)({ type: 'TSInterfaceDeclaration', id: t, typeParameters: e, extends: r, body: i })
  }
  function hk(t) {
    return (0, Q.default)({ type: 'TSInterfaceBody', body: t })
  }
  function dk(t, e = null, r) {
    return (0, Q.default)({ type: 'TSTypeAliasDeclaration', id: t, typeParameters: e, typeAnnotation: r })
  }
  function mk(t, e = null) {
    return (0, Q.default)({ type: 'TSInstantiationExpression', expression: t, typeParameters: e })
  }
  function yk(t, e) {
    return (0, Q.default)({ type: 'TSAsExpression', expression: t, typeAnnotation: e })
  }
  function gk(t, e) {
    return (0, Q.default)({ type: 'TSTypeAssertion', typeAnnotation: t, expression: e })
  }
  function Tk(t, e) {
    return (0, Q.default)({ type: 'TSEnumDeclaration', id: t, members: e })
  }
  function bk(t, e = null) {
    return (0, Q.default)({ type: 'TSEnumMember', id: t, initializer: e })
  }
  function Sk(t, e) {
    return (0, Q.default)({ type: 'TSModuleDeclaration', id: t, body: e })
  }
  function vk(t) {
    return (0, Q.default)({ type: 'TSModuleBlock', body: t })
  }
  function Ek(t, e = null, r = null) {
    return (0, Q.default)({ type: 'TSImportType', argument: t, qualifier: e, typeParameters: r })
  }
  function Pk(t, e) {
    return (0, Q.default)({ type: 'TSImportEqualsDeclaration', id: t, moduleReference: e, isExport: null })
  }
  function wk(t) {
    return (0, Q.default)({ type: 'TSExternalModuleReference', expression: t })
  }
  function Ak(t) {
    return (0, Q.default)({ type: 'TSNonNullExpression', expression: t })
  }
  function Ck(t) {
    return (0, Q.default)({ type: 'TSExportAssignment', expression: t })
  }
  function xk(t) {
    return (0, Q.default)({ type: 'TSNamespaceExportDeclaration', id: t })
  }
  function Ik(t) {
    return (0, Q.default)({ type: 'TSTypeAnnotation', typeAnnotation: t })
  }
  function kk(t) {
    return (0, Q.default)({ type: 'TSTypeParameterInstantiation', params: t })
  }
  function Nk(t) {
    return (0, Q.default)({ type: 'TSTypeParameterDeclaration', params: t })
  }
  function Ok(t = null, e = null, r) {
    return (0, Q.default)({ type: 'TSTypeParameter', constraint: t, default: e, name: r })
  }
  function Dk(t) {
    return console.trace('The node type NumberLiteral has been renamed to NumericLiteral'), Ud(t)
  }
  function Bk(t, e = '') {
    return console.trace('The node type RegexLiteral has been renamed to RegExpLiteral'), zd(t, e)
  }
  function Lk(t) {
    return console.trace('The node type RestProperty has been renamed to RestElement'), Kd(t)
  }
  function Mk(t) {
    return console.trace('The node type SpreadProperty has been renamed to SpreadElement'), Wd(t)
  }
  Object.defineProperty(eu, '__esModule', { value: !0 }), (eu.default = $k)
  var Fk = M
  function $k(t, e) {
    const r = t.value.split(/\r\n|\n|\r/)
    let i = 0
    for (let s = 0; s < r.length; s++) r[s].match(/[^ \t]/) && (i = s)
    let n = ''
    for (let s = 0; s < r.length; s++) {
      const a = r[s],
        o = s === 0,
        u = s === r.length - 1,
        c = s === i
      let p = a.replace(/\t/g, ' ')
      o || (p = p.replace(/^[ ]+/, '')), u || (p = p.replace(/[ ]+$/, '')), p && (c || (p += ' '), (n += p))
    }
    n && e.push((0, Fk.stringLiteral)(n))
  }
  Object.defineProperty(Ql, '__esModule', { value: !0 }), (Ql.default = jk)
  var du = $,
    Rk = eu
  function jk(t) {
    const e = []
    for (let r = 0; r < t.children.length; r++) {
      let i = t.children[r]
      if ((0, du.isJSXText)(i)) {
        ;(0, Rk.default)(i, e)
        continue
      }
      ;(0, du.isJSXExpressionContainer)(i) && (i = i.expression), !(0, du.isJSXEmptyExpression)(i) && e.push(i)
    }
    return e
  }
  var mu = {},
    Ia = {}
  Object.defineProperty(Ia, '__esModule', { value: !0 }), (Ia.default = Vk)
  var _k = fr
  function Vk(t) {
    return !!(t && _k.VISITOR_KEYS[t.type])
  }
  Object.defineProperty(mu, '__esModule', { value: !0 }), (mu.default = zk)
  var Uk = Ia
  function zk(t) {
    if (!(0, Uk.default)(t)) {
      var e
      const r = (e = t == null ? void 0 : t.type) != null ? e : JSON.stringify(t)
      throw new TypeError(`Not a valid node of type "${r}"`)
    }
  }
  var j = {}
  Object.defineProperty(j, '__esModule', { value: !0 }),
    (j.assertAccessor = iM),
    (j.assertAnyTypeAnnotation = wO),
    (j.assertArgumentPlaceholder = QD),
    (j.assertArrayExpression = Wk),
    (j.assertArrayPattern = zN),
    (j.assertArrayTypeAnnotation = AO),
    (j.assertArrowFunctionExpression = KN),
    (j.assertAssignmentExpression = Yk),
    (j.assertAssignmentPattern = UN),
    (j.assertAwaitExpression = fO),
    (j.assertBigIntLiteral = dO),
    (j.assertBinary = AL),
    (j.assertBinaryExpression = Hk),
    (j.assertBindExpression = eB),
    (j.assertBlock = IL),
    (j.assertBlockParent = xL),
    (j.assertBlockStatement = Jk),
    (j.assertBooleanLiteral = TN),
    (j.assertBooleanLiteralTypeAnnotation = xO),
    (j.assertBooleanTypeAnnotation = CO),
    (j.assertBreakStatement = Zk),
    (j.assertCallExpression = Qk),
    (j.assertCatchClause = eN),
    (j.assertClass = QL),
    (j.assertClassAccessorProperty = bO),
    (j.assertClassBody = WN),
    (j.assertClassDeclaration = HN),
    (j.assertClassExpression = YN),
    (j.assertClassImplements = kO),
    (j.assertClassMethod = nO),
    (j.assertClassPrivateMethod = vO),
    (j.assertClassPrivateProperty = SO),
    (j.assertClassProperty = TO),
    (j.assertCompletionStatement = OL),
    (j.assertConditional = DL),
    (j.assertConditionalExpression = tN),
    (j.assertContinueStatement = rN),
    (j.assertDebuggerStatement = iN),
    (j.assertDecimalLiteral = oB),
    (j.assertDeclaration = VL),
    (j.assertDeclareClass = NO),
    (j.assertDeclareExportAllDeclaration = jO),
    (j.assertDeclareExportDeclaration = RO),
    (j.assertDeclareFunction = OO),
    (j.assertDeclareInterface = DO),
    (j.assertDeclareModule = BO),
    (j.assertDeclareModuleExports = LO),
    (j.assertDeclareOpaqueType = FO),
    (j.assertDeclareTypeAlias = MO),
    (j.assertDeclareVariable = $O),
    (j.assertDeclaredPredicate = _O),
    (j.assertDecorator = rB),
    (j.assertDirective = Xk),
    (j.assertDirectiveLiteral = Gk),
    (j.assertDoExpression = iB),
    (j.assertDoWhileStatement = nN),
    (j.assertEmptyStatement = sN),
    (j.assertEmptyTypeAnnotation = JO),
    (j.assertEnumBody = cM),
    (j.assertEnumBooleanBody = AD),
    (j.assertEnumBooleanMember = kD),
    (j.assertEnumDeclaration = wD),
    (j.assertEnumDefaultedMember = DD),
    (j.assertEnumMember = pM),
    (j.assertEnumNumberBody = CD),
    (j.assertEnumNumberMember = ND),
    (j.assertEnumStringBody = xD),
    (j.assertEnumStringMember = OD),
    (j.assertEnumSymbolBody = ID),
    (j.assertExistsTypeAnnotation = VO),
    (j.assertExportAllDeclaration = qN),
    (j.assertExportDeclaration = tM),
    (j.assertExportDefaultDeclaration = XN),
    (j.assertExportDefaultSpecifier = nB),
    (j.assertExportNamedDeclaration = GN),
    (j.assertExportNamespaceSpecifier = mO),
    (j.assertExportSpecifier = JN),
    (j.assertExpression = wL),
    (j.assertExpressionStatement = aN),
    (j.assertExpressionWrapper = ML),
    (j.assertFile = oN),
    (j.assertFlow = sM),
    (j.assertFlowBaseAnnotation = oM),
    (j.assertFlowDeclaration = lM),
    (j.assertFlowPredicate = uM),
    (j.assertFlowType = aM),
    (j.assertFor = FL),
    (j.assertForInStatement = lN),
    (j.assertForOfStatement = ZN),
    (j.assertForStatement = uN),
    (j.assertForXStatement = $L),
    (j.assertFunction = RL),
    (j.assertFunctionDeclaration = cN),
    (j.assertFunctionExpression = pN),
    (j.assertFunctionParent = jL),
    (j.assertFunctionTypeAnnotation = UO),
    (j.assertFunctionTypeParam = zO),
    (j.assertGenericTypeAnnotation = KO),
    (j.assertIdentifier = fN),
    (j.assertIfStatement = hN),
    (j.assertImmutable = YL),
    (j.assertImport = hO),
    (j.assertImportAttribute = tB),
    (j.assertImportDeclaration = QN),
    (j.assertImportDefaultSpecifier = eO),
    (j.assertImportNamespaceSpecifier = tO),
    (j.assertImportSpecifier = rO),
    (j.assertIndexedAccessType = BD),
    (j.assertInferredPredicate = WO),
    (j.assertInterfaceDeclaration = HO),
    (j.assertInterfaceExtends = YO),
    (j.assertInterfaceTypeAnnotation = qO),
    (j.assertInterpreterDirective = qk),
    (j.assertIntersectionTypeAnnotation = XO),
    (j.assertJSX = fM),
    (j.assertJSXAttribute = MD),
    (j.assertJSXClosingElement = FD),
    (j.assertJSXClosingFragment = XD),
    (j.assertJSXElement = $D),
    (j.assertJSXEmptyExpression = RD),
    (j.assertJSXExpressionContainer = jD),
    (j.assertJSXFragment = HD),
    (j.assertJSXIdentifier = VD),
    (j.assertJSXMemberExpression = UD),
    (j.assertJSXNamespacedName = zD),
    (j.assertJSXOpeningElement = KD),
    (j.assertJSXOpeningFragment = qD),
    (j.assertJSXSpreadAttribute = WD),
    (j.assertJSXSpreadChild = _D),
    (j.assertJSXText = YD),
    (j.assertLVal = zL),
    (j.assertLabeledStatement = dN),
    (j.assertLiteral = WL),
    (j.assertLogicalExpression = SN),
    (j.assertLoop = BL),
    (j.assertMemberExpression = vN),
    (j.assertMetaProperty = iO),
    (j.assertMethod = qL),
    (j.assertMiscellaneous = hM),
    (j.assertMixedTypeAnnotation = GO),
    (j.assertModuleDeclaration = eM),
    (j.assertModuleExpression = lB),
    (j.assertModuleSpecifier = rM),
    (j.assertNewExpression = EN),
    (j.assertNoop = GD),
    (j.assertNullLiteral = gN),
    (j.assertNullLiteralTypeAnnotation = IO),
    (j.assertNullableTypeAnnotation = ZO),
    (j.assertNumberLiteral = TM),
    (j.assertNumberLiteralTypeAnnotation = QO),
    (j.assertNumberTypeAnnotation = eD),
    (j.assertNumericLiteral = yN),
    (j.assertObjectExpression = wN),
    (j.assertObjectMember = XL),
    (j.assertObjectMethod = AN),
    (j.assertObjectPattern = sO),
    (j.assertObjectProperty = CN),
    (j.assertObjectTypeAnnotation = tD),
    (j.assertObjectTypeCallProperty = iD),
    (j.assertObjectTypeIndexer = nD),
    (j.assertObjectTypeInternalSlot = rD),
    (j.assertObjectTypeProperty = sD),
    (j.assertObjectTypeSpreadProperty = aD),
    (j.assertOpaqueType = oD),
    (j.assertOptionalCallExpression = gO),
    (j.assertOptionalIndexedAccessType = LD),
    (j.assertOptionalMemberExpression = yO),
    (j.assertParenthesizedExpression = NN),
    (j.assertPattern = ZL),
    (j.assertPatternLike = UL),
    (j.assertPipelineBareFunction = pB),
    (j.assertPipelinePrimaryTopicReference = fB),
    (j.assertPipelineTopicExpression = cB),
    (j.assertPlaceholder = JD),
    (j.assertPrivate = nM),
    (j.assertPrivateName = EO),
    (j.assertProgram = PN),
    (j.assertProperty = GL),
    (j.assertPureish = _L),
    (j.assertQualifiedTypeIdentifier = lD),
    (j.assertRecordExpression = sB),
    (j.assertRegExpLiteral = bN),
    (j.assertRegexLiteral = bM),
    (j.assertRestElement = xN),
    (j.assertRestProperty = SM),
    (j.assertReturnStatement = IN),
    (j.assertScopable = CL),
    (j.assertSequenceExpression = kN),
    (j.assertSpreadElement = aO),
    (j.assertSpreadProperty = vM),
    (j.assertStandardized = PL),
    (j.assertStatement = kL),
    (j.assertStaticBlock = PO),
    (j.assertStringLiteral = mN),
    (j.assertStringLiteralTypeAnnotation = uD),
    (j.assertStringTypeAnnotation = cD),
    (j.assertSuper = oO),
    (j.assertSwitchCase = ON),
    (j.assertSwitchStatement = DN),
    (j.assertSymbolTypeAnnotation = pD),
    (j.assertTSAnyKeyword = EB),
    (j.assertTSArrayType = UB),
    (j.assertTSAsExpression = oL),
    (j.assertTSBaseType = gM),
    (j.assertTSBigIntKeyword = wB),
    (j.assertTSBooleanKeyword = PB),
    (j.assertTSCallSignatureDeclaration = gB),
    (j.assertTSConditionalType = XB),
    (j.assertTSConstructSignatureDeclaration = TB),
    (j.assertTSConstructorType = $B),
    (j.assertTSDeclareFunction = dB),
    (j.assertTSDeclareMethod = mB),
    (j.assertTSEntityName = KL),
    (j.assertTSEnumDeclaration = uL),
    (j.assertTSEnumMember = cL),
    (j.assertTSExportAssignment = gL),
    (j.assertTSExpressionWithTypeArguments = rL),
    (j.assertTSExternalModuleReference = mL),
    (j.assertTSFunctionType = FB),
    (j.assertTSImportEqualsDeclaration = dL),
    (j.assertTSImportType = hL),
    (j.assertTSIndexSignature = vB),
    (j.assertTSIndexedAccessType = QB),
    (j.assertTSInferType = GB),
    (j.assertTSInstantiationExpression = aL),
    (j.assertTSInterfaceBody = nL),
    (j.assertTSInterfaceDeclaration = iL),
    (j.assertTSIntersectionType = qB),
    (j.assertTSIntrinsicKeyword = AB),
    (j.assertTSLiteralType = tL),
    (j.assertTSMappedType = eL),
    (j.assertTSMethodSignature = SB),
    (j.assertTSModuleBlock = fL),
    (j.assertTSModuleDeclaration = pL),
    (j.assertTSNamedTupleMember = YB),
    (j.assertTSNamespaceExportDeclaration = TL),
    (j.assertTSNeverKeyword = CB),
    (j.assertTSNonNullExpression = yL),
    (j.assertTSNullKeyword = xB),
    (j.assertTSNumberKeyword = IB),
    (j.assertTSObjectKeyword = kB),
    (j.assertTSOptionalType = KB),
    (j.assertTSParameterProperty = hB),
    (j.assertTSParenthesizedType = JB),
    (j.assertTSPropertySignature = bB),
    (j.assertTSQualifiedName = yB),
    (j.assertTSRestType = WB),
    (j.assertTSStringKeyword = NB),
    (j.assertTSSymbolKeyword = OB),
    (j.assertTSThisType = MB),
    (j.assertTSTupleType = zB),
    (j.assertTSType = yM),
    (j.assertTSTypeAliasDeclaration = sL),
    (j.assertTSTypeAnnotation = bL),
    (j.assertTSTypeAssertion = lL),
    (j.assertTSTypeElement = mM),
    (j.assertTSTypeLiteral = VB),
    (j.assertTSTypeOperator = ZB),
    (j.assertTSTypeParameter = EL),
    (j.assertTSTypeParameterDeclaration = vL),
    (j.assertTSTypeParameterInstantiation = SL),
    (j.assertTSTypePredicate = jB),
    (j.assertTSTypeQuery = _B),
    (j.assertTSTypeReference = RB),
    (j.assertTSUndefinedKeyword = DB),
    (j.assertTSUnionType = HB),
    (j.assertTSUnknownKeyword = BB),
    (j.assertTSVoidKeyword = LB),
    (j.assertTaggedTemplateExpression = lO),
    (j.assertTemplateElement = uO),
    (j.assertTemplateLiteral = cO),
    (j.assertTerminatorless = NL),
    (j.assertThisExpression = BN),
    (j.assertThisTypeAnnotation = fD),
    (j.assertThrowStatement = LN),
    (j.assertTopicReference = uB),
    (j.assertTryStatement = MN),
    (j.assertTupleExpression = aB),
    (j.assertTupleTypeAnnotation = hD),
    (j.assertTypeAlias = mD),
    (j.assertTypeAnnotation = yD),
    (j.assertTypeCastExpression = gD),
    (j.assertTypeParameter = TD),
    (j.assertTypeParameterDeclaration = bD),
    (j.assertTypeParameterInstantiation = SD),
    (j.assertTypeScript = dM),
    (j.assertTypeofTypeAnnotation = dD),
    (j.assertUnaryExpression = FN),
    (j.assertUnaryLike = JL),
    (j.assertUnionTypeAnnotation = vD),
    (j.assertUpdateExpression = $N),
    (j.assertUserWhitespacable = HL),
    (j.assertV8IntrinsicIdentifier = ZD),
    (j.assertVariableDeclaration = RN),
    (j.assertVariableDeclarator = jN),
    (j.assertVariance = ED),
    (j.assertVoidTypeAnnotation = PD),
    (j.assertWhile = LL),
    (j.assertWhileStatement = _N),
    (j.assertWithStatement = VN),
    (j.assertYieldExpression = pO)
  var Kk = Vi
  function V(t, e, r) {
    if (!(0, Kk.default)(t, e, r))
      throw new Error(`Expected type "${t}" with option ${JSON.stringify(r)}, but instead got "${e.type}".`)
  }
  function Wk(t, e) {
    V('ArrayExpression', t, e)
  }
  function Yk(t, e) {
    V('AssignmentExpression', t, e)
  }
  function Hk(t, e) {
    V('BinaryExpression', t, e)
  }
  function qk(t, e) {
    V('InterpreterDirective', t, e)
  }
  function Xk(t, e) {
    V('Directive', t, e)
  }
  function Gk(t, e) {
    V('DirectiveLiteral', t, e)
  }
  function Jk(t, e) {
    V('BlockStatement', t, e)
  }
  function Zk(t, e) {
    V('BreakStatement', t, e)
  }
  function Qk(t, e) {
    V('CallExpression', t, e)
  }
  function eN(t, e) {
    V('CatchClause', t, e)
  }
  function tN(t, e) {
    V('ConditionalExpression', t, e)
  }
  function rN(t, e) {
    V('ContinueStatement', t, e)
  }
  function iN(t, e) {
    V('DebuggerStatement', t, e)
  }
  function nN(t, e) {
    V('DoWhileStatement', t, e)
  }
  function sN(t, e) {
    V('EmptyStatement', t, e)
  }
  function aN(t, e) {
    V('ExpressionStatement', t, e)
  }
  function oN(t, e) {
    V('File', t, e)
  }
  function lN(t, e) {
    V('ForInStatement', t, e)
  }
  function uN(t, e) {
    V('ForStatement', t, e)
  }
  function cN(t, e) {
    V('FunctionDeclaration', t, e)
  }
  function pN(t, e) {
    V('FunctionExpression', t, e)
  }
  function fN(t, e) {
    V('Identifier', t, e)
  }
  function hN(t, e) {
    V('IfStatement', t, e)
  }
  function dN(t, e) {
    V('LabeledStatement', t, e)
  }
  function mN(t, e) {
    V('StringLiteral', t, e)
  }
  function yN(t, e) {
    V('NumericLiteral', t, e)
  }
  function gN(t, e) {
    V('NullLiteral', t, e)
  }
  function TN(t, e) {
    V('BooleanLiteral', t, e)
  }
  function bN(t, e) {
    V('RegExpLiteral', t, e)
  }
  function SN(t, e) {
    V('LogicalExpression', t, e)
  }
  function vN(t, e) {
    V('MemberExpression', t, e)
  }
  function EN(t, e) {
    V('NewExpression', t, e)
  }
  function PN(t, e) {
    V('Program', t, e)
  }
  function wN(t, e) {
    V('ObjectExpression', t, e)
  }
  function AN(t, e) {
    V('ObjectMethod', t, e)
  }
  function CN(t, e) {
    V('ObjectProperty', t, e)
  }
  function xN(t, e) {
    V('RestElement', t, e)
  }
  function IN(t, e) {
    V('ReturnStatement', t, e)
  }
  function kN(t, e) {
    V('SequenceExpression', t, e)
  }
  function NN(t, e) {
    V('ParenthesizedExpression', t, e)
  }
  function ON(t, e) {
    V('SwitchCase', t, e)
  }
  function DN(t, e) {
    V('SwitchStatement', t, e)
  }
  function BN(t, e) {
    V('ThisExpression', t, e)
  }
  function LN(t, e) {
    V('ThrowStatement', t, e)
  }
  function MN(t, e) {
    V('TryStatement', t, e)
  }
  function FN(t, e) {
    V('UnaryExpression', t, e)
  }
  function $N(t, e) {
    V('UpdateExpression', t, e)
  }
  function RN(t, e) {
    V('VariableDeclaration', t, e)
  }
  function jN(t, e) {
    V('VariableDeclarator', t, e)
  }
  function _N(t, e) {
    V('WhileStatement', t, e)
  }
  function VN(t, e) {
    V('WithStatement', t, e)
  }
  function UN(t, e) {
    V('AssignmentPattern', t, e)
  }
  function zN(t, e) {
    V('ArrayPattern', t, e)
  }
  function KN(t, e) {
    V('ArrowFunctionExpression', t, e)
  }
  function WN(t, e) {
    V('ClassBody', t, e)
  }
  function YN(t, e) {
    V('ClassExpression', t, e)
  }
  function HN(t, e) {
    V('ClassDeclaration', t, e)
  }
  function qN(t, e) {
    V('ExportAllDeclaration', t, e)
  }
  function XN(t, e) {
    V('ExportDefaultDeclaration', t, e)
  }
  function GN(t, e) {
    V('ExportNamedDeclaration', t, e)
  }
  function JN(t, e) {
    V('ExportSpecifier', t, e)
  }
  function ZN(t, e) {
    V('ForOfStatement', t, e)
  }
  function QN(t, e) {
    V('ImportDeclaration', t, e)
  }
  function eO(t, e) {
    V('ImportDefaultSpecifier', t, e)
  }
  function tO(t, e) {
    V('ImportNamespaceSpecifier', t, e)
  }
  function rO(t, e) {
    V('ImportSpecifier', t, e)
  }
  function iO(t, e) {
    V('MetaProperty', t, e)
  }
  function nO(t, e) {
    V('ClassMethod', t, e)
  }
  function sO(t, e) {
    V('ObjectPattern', t, e)
  }
  function aO(t, e) {
    V('SpreadElement', t, e)
  }
  function oO(t, e) {
    V('Super', t, e)
  }
  function lO(t, e) {
    V('TaggedTemplateExpression', t, e)
  }
  function uO(t, e) {
    V('TemplateElement', t, e)
  }
  function cO(t, e) {
    V('TemplateLiteral', t, e)
  }
  function pO(t, e) {
    V('YieldExpression', t, e)
  }
  function fO(t, e) {
    V('AwaitExpression', t, e)
  }
  function hO(t, e) {
    V('Import', t, e)
  }
  function dO(t, e) {
    V('BigIntLiteral', t, e)
  }
  function mO(t, e) {
    V('ExportNamespaceSpecifier', t, e)
  }
  function yO(t, e) {
    V('OptionalMemberExpression', t, e)
  }
  function gO(t, e) {
    V('OptionalCallExpression', t, e)
  }
  function TO(t, e) {
    V('ClassProperty', t, e)
  }
  function bO(t, e) {
    V('ClassAccessorProperty', t, e)
  }
  function SO(t, e) {
    V('ClassPrivateProperty', t, e)
  }
  function vO(t, e) {
    V('ClassPrivateMethod', t, e)
  }
  function EO(t, e) {
    V('PrivateName', t, e)
  }
  function PO(t, e) {
    V('StaticBlock', t, e)
  }
  function wO(t, e) {
    V('AnyTypeAnnotation', t, e)
  }
  function AO(t, e) {
    V('ArrayTypeAnnotation', t, e)
  }
  function CO(t, e) {
    V('BooleanTypeAnnotation', t, e)
  }
  function xO(t, e) {
    V('BooleanLiteralTypeAnnotation', t, e)
  }
  function IO(t, e) {
    V('NullLiteralTypeAnnotation', t, e)
  }
  function kO(t, e) {
    V('ClassImplements', t, e)
  }
  function NO(t, e) {
    V('DeclareClass', t, e)
  }
  function OO(t, e) {
    V('DeclareFunction', t, e)
  }
  function DO(t, e) {
    V('DeclareInterface', t, e)
  }
  function BO(t, e) {
    V('DeclareModule', t, e)
  }
  function LO(t, e) {
    V('DeclareModuleExports', t, e)
  }
  function MO(t, e) {
    V('DeclareTypeAlias', t, e)
  }
  function FO(t, e) {
    V('DeclareOpaqueType', t, e)
  }
  function $O(t, e) {
    V('DeclareVariable', t, e)
  }
  function RO(t, e) {
    V('DeclareExportDeclaration', t, e)
  }
  function jO(t, e) {
    V('DeclareExportAllDeclaration', t, e)
  }
  function _O(t, e) {
    V('DeclaredPredicate', t, e)
  }
  function VO(t, e) {
    V('ExistsTypeAnnotation', t, e)
  }
  function UO(t, e) {
    V('FunctionTypeAnnotation', t, e)
  }
  function zO(t, e) {
    V('FunctionTypeParam', t, e)
  }
  function KO(t, e) {
    V('GenericTypeAnnotation', t, e)
  }
  function WO(t, e) {
    V('InferredPredicate', t, e)
  }
  function YO(t, e) {
    V('InterfaceExtends', t, e)
  }
  function HO(t, e) {
    V('InterfaceDeclaration', t, e)
  }
  function qO(t, e) {
    V('InterfaceTypeAnnotation', t, e)
  }
  function XO(t, e) {
    V('IntersectionTypeAnnotation', t, e)
  }
  function GO(t, e) {
    V('MixedTypeAnnotation', t, e)
  }
  function JO(t, e) {
    V('EmptyTypeAnnotation', t, e)
  }
  function ZO(t, e) {
    V('NullableTypeAnnotation', t, e)
  }
  function QO(t, e) {
    V('NumberLiteralTypeAnnotation', t, e)
  }
  function eD(t, e) {
    V('NumberTypeAnnotation', t, e)
  }
  function tD(t, e) {
    V('ObjectTypeAnnotation', t, e)
  }
  function rD(t, e) {
    V('ObjectTypeInternalSlot', t, e)
  }
  function iD(t, e) {
    V('ObjectTypeCallProperty', t, e)
  }
  function nD(t, e) {
    V('ObjectTypeIndexer', t, e)
  }
  function sD(t, e) {
    V('ObjectTypeProperty', t, e)
  }
  function aD(t, e) {
    V('ObjectTypeSpreadProperty', t, e)
  }
  function oD(t, e) {
    V('OpaqueType', t, e)
  }
  function lD(t, e) {
    V('QualifiedTypeIdentifier', t, e)
  }
  function uD(t, e) {
    V('StringLiteralTypeAnnotation', t, e)
  }
  function cD(t, e) {
    V('StringTypeAnnotation', t, e)
  }
  function pD(t, e) {
    V('SymbolTypeAnnotation', t, e)
  }
  function fD(t, e) {
    V('ThisTypeAnnotation', t, e)
  }
  function hD(t, e) {
    V('TupleTypeAnnotation', t, e)
  }
  function dD(t, e) {
    V('TypeofTypeAnnotation', t, e)
  }
  function mD(t, e) {
    V('TypeAlias', t, e)
  }
  function yD(t, e) {
    V('TypeAnnotation', t, e)
  }
  function gD(t, e) {
    V('TypeCastExpression', t, e)
  }
  function TD(t, e) {
    V('TypeParameter', t, e)
  }
  function bD(t, e) {
    V('TypeParameterDeclaration', t, e)
  }
  function SD(t, e) {
    V('TypeParameterInstantiation', t, e)
  }
  function vD(t, e) {
    V('UnionTypeAnnotation', t, e)
  }
  function ED(t, e) {
    V('Variance', t, e)
  }
  function PD(t, e) {
    V('VoidTypeAnnotation', t, e)
  }
  function wD(t, e) {
    V('EnumDeclaration', t, e)
  }
  function AD(t, e) {
    V('EnumBooleanBody', t, e)
  }
  function CD(t, e) {
    V('EnumNumberBody', t, e)
  }
  function xD(t, e) {
    V('EnumStringBody', t, e)
  }
  function ID(t, e) {
    V('EnumSymbolBody', t, e)
  }
  function kD(t, e) {
    V('EnumBooleanMember', t, e)
  }
  function ND(t, e) {
    V('EnumNumberMember', t, e)
  }
  function OD(t, e) {
    V('EnumStringMember', t, e)
  }
  function DD(t, e) {
    V('EnumDefaultedMember', t, e)
  }
  function BD(t, e) {
    V('IndexedAccessType', t, e)
  }
  function LD(t, e) {
    V('OptionalIndexedAccessType', t, e)
  }
  function MD(t, e) {
    V('JSXAttribute', t, e)
  }
  function FD(t, e) {
    V('JSXClosingElement', t, e)
  }
  function $D(t, e) {
    V('JSXElement', t, e)
  }
  function RD(t, e) {
    V('JSXEmptyExpression', t, e)
  }
  function jD(t, e) {
    V('JSXExpressionContainer', t, e)
  }
  function _D(t, e) {
    V('JSXSpreadChild', t, e)
  }
  function VD(t, e) {
    V('JSXIdentifier', t, e)
  }
  function UD(t, e) {
    V('JSXMemberExpression', t, e)
  }
  function zD(t, e) {
    V('JSXNamespacedName', t, e)
  }
  function KD(t, e) {
    V('JSXOpeningElement', t, e)
  }
  function WD(t, e) {
    V('JSXSpreadAttribute', t, e)
  }
  function YD(t, e) {
    V('JSXText', t, e)
  }
  function HD(t, e) {
    V('JSXFragment', t, e)
  }
  function qD(t, e) {
    V('JSXOpeningFragment', t, e)
  }
  function XD(t, e) {
    V('JSXClosingFragment', t, e)
  }
  function GD(t, e) {
    V('Noop', t, e)
  }
  function JD(t, e) {
    V('Placeholder', t, e)
  }
  function ZD(t, e) {
    V('V8IntrinsicIdentifier', t, e)
  }
  function QD(t, e) {
    V('ArgumentPlaceholder', t, e)
  }
  function eB(t, e) {
    V('BindExpression', t, e)
  }
  function tB(t, e) {
    V('ImportAttribute', t, e)
  }
  function rB(t, e) {
    V('Decorator', t, e)
  }
  function iB(t, e) {
    V('DoExpression', t, e)
  }
  function nB(t, e) {
    V('ExportDefaultSpecifier', t, e)
  }
  function sB(t, e) {
    V('RecordExpression', t, e)
  }
  function aB(t, e) {
    V('TupleExpression', t, e)
  }
  function oB(t, e) {
    V('DecimalLiteral', t, e)
  }
  function lB(t, e) {
    V('ModuleExpression', t, e)
  }
  function uB(t, e) {
    V('TopicReference', t, e)
  }
  function cB(t, e) {
    V('PipelineTopicExpression', t, e)
  }
  function pB(t, e) {
    V('PipelineBareFunction', t, e)
  }
  function fB(t, e) {
    V('PipelinePrimaryTopicReference', t, e)
  }
  function hB(t, e) {
    V('TSParameterProperty', t, e)
  }
  function dB(t, e) {
    V('TSDeclareFunction', t, e)
  }
  function mB(t, e) {
    V('TSDeclareMethod', t, e)
  }
  function yB(t, e) {
    V('TSQualifiedName', t, e)
  }
  function gB(t, e) {
    V('TSCallSignatureDeclaration', t, e)
  }
  function TB(t, e) {
    V('TSConstructSignatureDeclaration', t, e)
  }
  function bB(t, e) {
    V('TSPropertySignature', t, e)
  }
  function SB(t, e) {
    V('TSMethodSignature', t, e)
  }
  function vB(t, e) {
    V('TSIndexSignature', t, e)
  }
  function EB(t, e) {
    V('TSAnyKeyword', t, e)
  }
  function PB(t, e) {
    V('TSBooleanKeyword', t, e)
  }
  function wB(t, e) {
    V('TSBigIntKeyword', t, e)
  }
  function AB(t, e) {
    V('TSIntrinsicKeyword', t, e)
  }
  function CB(t, e) {
    V('TSNeverKeyword', t, e)
  }
  function xB(t, e) {
    V('TSNullKeyword', t, e)
  }
  function IB(t, e) {
    V('TSNumberKeyword', t, e)
  }
  function kB(t, e) {
    V('TSObjectKeyword', t, e)
  }
  function NB(t, e) {
    V('TSStringKeyword', t, e)
  }
  function OB(t, e) {
    V('TSSymbolKeyword', t, e)
  }
  function DB(t, e) {
    V('TSUndefinedKeyword', t, e)
  }
  function BB(t, e) {
    V('TSUnknownKeyword', t, e)
  }
  function LB(t, e) {
    V('TSVoidKeyword', t, e)
  }
  function MB(t, e) {
    V('TSThisType', t, e)
  }
  function FB(t, e) {
    V('TSFunctionType', t, e)
  }
  function $B(t, e) {
    V('TSConstructorType', t, e)
  }
  function RB(t, e) {
    V('TSTypeReference', t, e)
  }
  function jB(t, e) {
    V('TSTypePredicate', t, e)
  }
  function _B(t, e) {
    V('TSTypeQuery', t, e)
  }
  function VB(t, e) {
    V('TSTypeLiteral', t, e)
  }
  function UB(t, e) {
    V('TSArrayType', t, e)
  }
  function zB(t, e) {
    V('TSTupleType', t, e)
  }
  function KB(t, e) {
    V('TSOptionalType', t, e)
  }
  function WB(t, e) {
    V('TSRestType', t, e)
  }
  function YB(t, e) {
    V('TSNamedTupleMember', t, e)
  }
  function HB(t, e) {
    V('TSUnionType', t, e)
  }
  function qB(t, e) {
    V('TSIntersectionType', t, e)
  }
  function XB(t, e) {
    V('TSConditionalType', t, e)
  }
  function GB(t, e) {
    V('TSInferType', t, e)
  }
  function JB(t, e) {
    V('TSParenthesizedType', t, e)
  }
  function ZB(t, e) {
    V('TSTypeOperator', t, e)
  }
  function QB(t, e) {
    V('TSIndexedAccessType', t, e)
  }
  function eL(t, e) {
    V('TSMappedType', t, e)
  }
  function tL(t, e) {
    V('TSLiteralType', t, e)
  }
  function rL(t, e) {
    V('TSExpressionWithTypeArguments', t, e)
  }
  function iL(t, e) {
    V('TSInterfaceDeclaration', t, e)
  }
  function nL(t, e) {
    V('TSInterfaceBody', t, e)
  }
  function sL(t, e) {
    V('TSTypeAliasDeclaration', t, e)
  }
  function aL(t, e) {
    V('TSInstantiationExpression', t, e)
  }
  function oL(t, e) {
    V('TSAsExpression', t, e)
  }
  function lL(t, e) {
    V('TSTypeAssertion', t, e)
  }
  function uL(t, e) {
    V('TSEnumDeclaration', t, e)
  }
  function cL(t, e) {
    V('TSEnumMember', t, e)
  }
  function pL(t, e) {
    V('TSModuleDeclaration', t, e)
  }
  function fL(t, e) {
    V('TSModuleBlock', t, e)
  }
  function hL(t, e) {
    V('TSImportType', t, e)
  }
  function dL(t, e) {
    V('TSImportEqualsDeclaration', t, e)
  }
  function mL(t, e) {
    V('TSExternalModuleReference', t, e)
  }
  function yL(t, e) {
    V('TSNonNullExpression', t, e)
  }
  function gL(t, e) {
    V('TSExportAssignment', t, e)
  }
  function TL(t, e) {
    V('TSNamespaceExportDeclaration', t, e)
  }
  function bL(t, e) {
    V('TSTypeAnnotation', t, e)
  }
  function SL(t, e) {
    V('TSTypeParameterInstantiation', t, e)
  }
  function vL(t, e) {
    V('TSTypeParameterDeclaration', t, e)
  }
  function EL(t, e) {
    V('TSTypeParameter', t, e)
  }
  function PL(t, e) {
    V('Standardized', t, e)
  }
  function wL(t, e) {
    V('Expression', t, e)
  }
  function AL(t, e) {
    V('Binary', t, e)
  }
  function CL(t, e) {
    V('Scopable', t, e)
  }
  function xL(t, e) {
    V('BlockParent', t, e)
  }
  function IL(t, e) {
    V('Block', t, e)
  }
  function kL(t, e) {
    V('Statement', t, e)
  }
  function NL(t, e) {
    V('Terminatorless', t, e)
  }
  function OL(t, e) {
    V('CompletionStatement', t, e)
  }
  function DL(t, e) {
    V('Conditional', t, e)
  }
  function BL(t, e) {
    V('Loop', t, e)
  }
  function LL(t, e) {
    V('While', t, e)
  }
  function ML(t, e) {
    V('ExpressionWrapper', t, e)
  }
  function FL(t, e) {
    V('For', t, e)
  }
  function $L(t, e) {
    V('ForXStatement', t, e)
  }
  function RL(t, e) {
    V('Function', t, e)
  }
  function jL(t, e) {
    V('FunctionParent', t, e)
  }
  function _L(t, e) {
    V('Pureish', t, e)
  }
  function VL(t, e) {
    V('Declaration', t, e)
  }
  function UL(t, e) {
    V('PatternLike', t, e)
  }
  function zL(t, e) {
    V('LVal', t, e)
  }
  function KL(t, e) {
    V('TSEntityName', t, e)
  }
  function WL(t, e) {
    V('Literal', t, e)
  }
  function YL(t, e) {
    V('Immutable', t, e)
  }
  function HL(t, e) {
    V('UserWhitespacable', t, e)
  }
  function qL(t, e) {
    V('Method', t, e)
  }
  function XL(t, e) {
    V('ObjectMember', t, e)
  }
  function GL(t, e) {
    V('Property', t, e)
  }
  function JL(t, e) {
    V('UnaryLike', t, e)
  }
  function ZL(t, e) {
    V('Pattern', t, e)
  }
  function QL(t, e) {
    V('Class', t, e)
  }
  function eM(t, e) {
    V('ModuleDeclaration', t, e)
  }
  function tM(t, e) {
    V('ExportDeclaration', t, e)
  }
  function rM(t, e) {
    V('ModuleSpecifier', t, e)
  }
  function iM(t, e) {
    V('Accessor', t, e)
  }
  function nM(t, e) {
    V('Private', t, e)
  }
  function sM(t, e) {
    V('Flow', t, e)
  }
  function aM(t, e) {
    V('FlowType', t, e)
  }
  function oM(t, e) {
    V('FlowBaseAnnotation', t, e)
  }
  function lM(t, e) {
    V('FlowDeclaration', t, e)
  }
  function uM(t, e) {
    V('FlowPredicate', t, e)
  }
  function cM(t, e) {
    V('EnumBody', t, e)
  }
  function pM(t, e) {
    V('EnumMember', t, e)
  }
  function fM(t, e) {
    V('JSX', t, e)
  }
  function hM(t, e) {
    V('Miscellaneous', t, e)
  }
  function dM(t, e) {
    V('TypeScript', t, e)
  }
  function mM(t, e) {
    V('TSTypeElement', t, e)
  }
  function yM(t, e) {
    V('TSType', t, e)
  }
  function gM(t, e) {
    V('TSBaseType', t, e)
  }
  function TM(t, e) {
    console.trace('The node type NumberLiteral has been renamed to NumericLiteral'), V('NumberLiteral', t, e)
  }
  function bM(t, e) {
    console.trace('The node type RegexLiteral has been renamed to RegExpLiteral'), V('RegexLiteral', t, e)
  }
  function SM(t, e) {
    console.trace('The node type RestProperty has been renamed to RestElement'), V('RestProperty', t, e)
  }
  function vM(t, e) {
    console.trace('The node type SpreadProperty has been renamed to SpreadElement'), V('SpreadProperty', t, e)
  }
  var ka = {}
  Object.defineProperty(ka, '__esModule', { value: !0 }), (ka.default = void 0)
  var Ar = M,
    EM = PM
  ka.default = EM
  function PM(t) {
    switch (t) {
      case 'string':
        return (0, Ar.stringTypeAnnotation)()
      case 'number':
        return (0, Ar.numberTypeAnnotation)()
      case 'undefined':
        return (0, Ar.voidTypeAnnotation)()
      case 'boolean':
        return (0, Ar.booleanTypeAnnotation)()
      case 'function':
        return (0, Ar.genericTypeAnnotation)((0, Ar.identifier)('Function'))
      case 'object':
        return (0, Ar.genericTypeAnnotation)((0, Ar.identifier)('Object'))
      case 'symbol':
        return (0, Ar.genericTypeAnnotation)((0, Ar.identifier)('Symbol'))
      case 'bigint':
        return (0, Ar.anyTypeAnnotation)()
    }
    throw new Error('Invalid typeof value: ' + t)
  }
  var yu = {},
    Na = {}
  Object.defineProperty(Na, '__esModule', { value: !0 }), (Na.default = Hd)
  var ds = $
  function Yd(t) {
    return (0, ds.isIdentifier)(t) ? t.name : `${t.id.name}.${Yd(t.qualification)}`
  }
  function Hd(t) {
    const e = {},
      r = {},
      i = new Set(),
      n = []
    for (let s = 0; s < t.length; s++) {
      const a = t[s]
      if (!!a && !(n.indexOf(a) >= 0)) {
        if ((0, ds.isAnyTypeAnnotation)(a)) return [a]
        if ((0, ds.isFlowBaseAnnotation)(a)) {
          r[a.type] = a
          continue
        }
        if ((0, ds.isUnionTypeAnnotation)(a)) {
          i.has(a.types) || ((t = t.concat(a.types)), i.add(a.types))
          continue
        }
        if ((0, ds.isGenericTypeAnnotation)(a)) {
          const o = Yd(a.id)
          if (e[o]) {
            let u = e[o]
            u.typeParameters
              ? a.typeParameters &&
                (u.typeParameters.params = Hd(u.typeParameters.params.concat(a.typeParameters.params)))
              : (u = a.typeParameters)
          } else e[o] = a
          continue
        }
        n.push(a)
      }
    }
    for (const s of Object.keys(r)) n.push(r[s])
    for (const s of Object.keys(e)) n.push(e[s])
    return n
  }
  Object.defineProperty(yu, '__esModule', { value: !0 }), (yu.default = CM)
  var wM = M,
    AM = Na
  function CM(t) {
    const e = (0, AM.default)(t)
    return e.length === 1 ? e[0] : (0, wM.unionTypeAnnotation)(e)
  }
  var gu = {},
    Tu = {}
  Object.defineProperty(Tu, '__esModule', { value: !0 }), (Tu.default = xM)
  var bu = $
  function xM(t) {
    const e = {},
      r = {},
      i = new Set(),
      n = []
    for (let s = 0; s < t.length; s++) {
      const a = t[s]
      if (!!a && !(n.indexOf(a) >= 0)) {
        if ((0, bu.isTSAnyKeyword)(a)) return [a]
        if ((0, bu.isTSBaseType)(a)) {
          r[a.type] = a
          continue
        }
        if ((0, bu.isTSUnionType)(a)) {
          i.has(a.types) || (t.push(...a.types), i.add(a.types))
          continue
        }
        n.push(a)
      }
    }
    for (const s of Object.keys(r)) n.push(r[s])
    for (const s of Object.keys(e)) n.push(e[s])
    return n
  }
  Object.defineProperty(gu, '__esModule', { value: !0 }), (gu.default = NM)
  var IM = M,
    kM = Tu
  function NM(t) {
    const e = t.map((i) => i.typeAnnotation),
      r = (0, kM.default)(e)
    return r.length === 1 ? r[0] : (0, IM.tsUnionType)(r)
  }
  var qd = {}
  ;(function (t) {
    Object.defineProperty(t, '__esModule', { value: !0 }),
      Object.defineProperty(t, 'AnyTypeAnnotation', {
        enumerable: !0,
        get: function () {
          return e.anyTypeAnnotation
        },
      }),
      Object.defineProperty(t, 'ArgumentPlaceholder', {
        enumerable: !0,
        get: function () {
          return e.argumentPlaceholder
        },
      }),
      Object.defineProperty(t, 'ArrayExpression', {
        enumerable: !0,
        get: function () {
          return e.arrayExpression
        },
      }),
      Object.defineProperty(t, 'ArrayPattern', {
        enumerable: !0,
        get: function () {
          return e.arrayPattern
        },
      }),
      Object.defineProperty(t, 'ArrayTypeAnnotation', {
        enumerable: !0,
        get: function () {
          return e.arrayTypeAnnotation
        },
      }),
      Object.defineProperty(t, 'ArrowFunctionExpression', {
        enumerable: !0,
        get: function () {
          return e.arrowFunctionExpression
        },
      }),
      Object.defineProperty(t, 'AssignmentExpression', {
        enumerable: !0,
        get: function () {
          return e.assignmentExpression
        },
      }),
      Object.defineProperty(t, 'AssignmentPattern', {
        enumerable: !0,
        get: function () {
          return e.assignmentPattern
        },
      }),
      Object.defineProperty(t, 'AwaitExpression', {
        enumerable: !0,
        get: function () {
          return e.awaitExpression
        },
      }),
      Object.defineProperty(t, 'BigIntLiteral', {
        enumerable: !0,
        get: function () {
          return e.bigIntLiteral
        },
      }),
      Object.defineProperty(t, 'BinaryExpression', {
        enumerable: !0,
        get: function () {
          return e.binaryExpression
        },
      }),
      Object.defineProperty(t, 'BindExpression', {
        enumerable: !0,
        get: function () {
          return e.bindExpression
        },
      }),
      Object.defineProperty(t, 'BlockStatement', {
        enumerable: !0,
        get: function () {
          return e.blockStatement
        },
      }),
      Object.defineProperty(t, 'BooleanLiteral', {
        enumerable: !0,
        get: function () {
          return e.booleanLiteral
        },
      }),
      Object.defineProperty(t, 'BooleanLiteralTypeAnnotation', {
        enumerable: !0,
        get: function () {
          return e.booleanLiteralTypeAnnotation
        },
      }),
      Object.defineProperty(t, 'BooleanTypeAnnotation', {
        enumerable: !0,
        get: function () {
          return e.booleanTypeAnnotation
        },
      }),
      Object.defineProperty(t, 'BreakStatement', {
        enumerable: !0,
        get: function () {
          return e.breakStatement
        },
      }),
      Object.defineProperty(t, 'CallExpression', {
        enumerable: !0,
        get: function () {
          return e.callExpression
        },
      }),
      Object.defineProperty(t, 'CatchClause', {
        enumerable: !0,
        get: function () {
          return e.catchClause
        },
      }),
      Object.defineProperty(t, 'ClassAccessorProperty', {
        enumerable: !0,
        get: function () {
          return e.classAccessorProperty
        },
      }),
      Object.defineProperty(t, 'ClassBody', {
        enumerable: !0,
        get: function () {
          return e.classBody
        },
      }),
      Object.defineProperty(t, 'ClassDeclaration', {
        enumerable: !0,
        get: function () {
          return e.classDeclaration
        },
      }),
      Object.defineProperty(t, 'ClassExpression', {
        enumerable: !0,
        get: function () {
          return e.classExpression
        },
      }),
      Object.defineProperty(t, 'ClassImplements', {
        enumerable: !0,
        get: function () {
          return e.classImplements
        },
      }),
      Object.defineProperty(t, 'ClassMethod', {
        enumerable: !0,
        get: function () {
          return e.classMethod
        },
      }),
      Object.defineProperty(t, 'ClassPrivateMethod', {
        enumerable: !0,
        get: function () {
          return e.classPrivateMethod
        },
      }),
      Object.defineProperty(t, 'ClassPrivateProperty', {
        enumerable: !0,
        get: function () {
          return e.classPrivateProperty
        },
      }),
      Object.defineProperty(t, 'ClassProperty', {
        enumerable: !0,
        get: function () {
          return e.classProperty
        },
      }),
      Object.defineProperty(t, 'ConditionalExpression', {
        enumerable: !0,
        get: function () {
          return e.conditionalExpression
        },
      }),
      Object.defineProperty(t, 'ContinueStatement', {
        enumerable: !0,
        get: function () {
          return e.continueStatement
        },
      }),
      Object.defineProperty(t, 'DebuggerStatement', {
        enumerable: !0,
        get: function () {
          return e.debuggerStatement
        },
      }),
      Object.defineProperty(t, 'DecimalLiteral', {
        enumerable: !0,
        get: function () {
          return e.decimalLiteral
        },
      }),
      Object.defineProperty(t, 'DeclareClass', {
        enumerable: !0,
        get: function () {
          return e.declareClass
        },
      }),
      Object.defineProperty(t, 'DeclareExportAllDeclaration', {
        enumerable: !0,
        get: function () {
          return e.declareExportAllDeclaration
        },
      }),
      Object.defineProperty(t, 'DeclareExportDeclaration', {
        enumerable: !0,
        get: function () {
          return e.declareExportDeclaration
        },
      }),
      Object.defineProperty(t, 'DeclareFunction', {
        enumerable: !0,
        get: function () {
          return e.declareFunction
        },
      }),
      Object.defineProperty(t, 'DeclareInterface', {
        enumerable: !0,
        get: function () {
          return e.declareInterface
        },
      }),
      Object.defineProperty(t, 'DeclareModule', {
        enumerable: !0,
        get: function () {
          return e.declareModule
        },
      }),
      Object.defineProperty(t, 'DeclareModuleExports', {
        enumerable: !0,
        get: function () {
          return e.declareModuleExports
        },
      }),
      Object.defineProperty(t, 'DeclareOpaqueType', {
        enumerable: !0,
        get: function () {
          return e.declareOpaqueType
        },
      }),
      Object.defineProperty(t, 'DeclareTypeAlias', {
        enumerable: !0,
        get: function () {
          return e.declareTypeAlias
        },
      }),
      Object.defineProperty(t, 'DeclareVariable', {
        enumerable: !0,
        get: function () {
          return e.declareVariable
        },
      }),
      Object.defineProperty(t, 'DeclaredPredicate', {
        enumerable: !0,
        get: function () {
          return e.declaredPredicate
        },
      }),
      Object.defineProperty(t, 'Decorator', {
        enumerable: !0,
        get: function () {
          return e.decorator
        },
      }),
      Object.defineProperty(t, 'Directive', {
        enumerable: !0,
        get: function () {
          return e.directive
        },
      }),
      Object.defineProperty(t, 'DirectiveLiteral', {
        enumerable: !0,
        get: function () {
          return e.directiveLiteral
        },
      }),
      Object.defineProperty(t, 'DoExpression', {
        enumerable: !0,
        get: function () {
          return e.doExpression
        },
      }),
      Object.defineProperty(t, 'DoWhileStatement', {
        enumerable: !0,
        get: function () {
          return e.doWhileStatement
        },
      }),
      Object.defineProperty(t, 'EmptyStatement', {
        enumerable: !0,
        get: function () {
          return e.emptyStatement
        },
      }),
      Object.defineProperty(t, 'EmptyTypeAnnotation', {
        enumerable: !0,
        get: function () {
          return e.emptyTypeAnnotation
        },
      }),
      Object.defineProperty(t, 'EnumBooleanBody', {
        enumerable: !0,
        get: function () {
          return e.enumBooleanBody
        },
      }),
      Object.defineProperty(t, 'EnumBooleanMember', {
        enumerable: !0,
        get: function () {
          return e.enumBooleanMember
        },
      }),
      Object.defineProperty(t, 'EnumDeclaration', {
        enumerable: !0,
        get: function () {
          return e.enumDeclaration
        },
      }),
      Object.defineProperty(t, 'EnumDefaultedMember', {
        enumerable: !0,
        get: function () {
          return e.enumDefaultedMember
        },
      }),
      Object.defineProperty(t, 'EnumNumberBody', {
        enumerable: !0,
        get: function () {
          return e.enumNumberBody
        },
      }),
      Object.defineProperty(t, 'EnumNumberMember', {
        enumerable: !0,
        get: function () {
          return e.enumNumberMember
        },
      }),
      Object.defineProperty(t, 'EnumStringBody', {
        enumerable: !0,
        get: function () {
          return e.enumStringBody
        },
      }),
      Object.defineProperty(t, 'EnumStringMember', {
        enumerable: !0,
        get: function () {
          return e.enumStringMember
        },
      }),
      Object.defineProperty(t, 'EnumSymbolBody', {
        enumerable: !0,
        get: function () {
          return e.enumSymbolBody
        },
      }),
      Object.defineProperty(t, 'ExistsTypeAnnotation', {
        enumerable: !0,
        get: function () {
          return e.existsTypeAnnotation
        },
      }),
      Object.defineProperty(t, 'ExportAllDeclaration', {
        enumerable: !0,
        get: function () {
          return e.exportAllDeclaration
        },
      }),
      Object.defineProperty(t, 'ExportDefaultDeclaration', {
        enumerable: !0,
        get: function () {
          return e.exportDefaultDeclaration
        },
      }),
      Object.defineProperty(t, 'ExportDefaultSpecifier', {
        enumerable: !0,
        get: function () {
          return e.exportDefaultSpecifier
        },
      }),
      Object.defineProperty(t, 'ExportNamedDeclaration', {
        enumerable: !0,
        get: function () {
          return e.exportNamedDeclaration
        },
      }),
      Object.defineProperty(t, 'ExportNamespaceSpecifier', {
        enumerable: !0,
        get: function () {
          return e.exportNamespaceSpecifier
        },
      }),
      Object.defineProperty(t, 'ExportSpecifier', {
        enumerable: !0,
        get: function () {
          return e.exportSpecifier
        },
      }),
      Object.defineProperty(t, 'ExpressionStatement', {
        enumerable: !0,
        get: function () {
          return e.expressionStatement
        },
      }),
      Object.defineProperty(t, 'File', {
        enumerable: !0,
        get: function () {
          return e.file
        },
      }),
      Object.defineProperty(t, 'ForInStatement', {
        enumerable: !0,
        get: function () {
          return e.forInStatement
        },
      }),
      Object.defineProperty(t, 'ForOfStatement', {
        enumerable: !0,
        get: function () {
          return e.forOfStatement
        },
      }),
      Object.defineProperty(t, 'ForStatement', {
        enumerable: !0,
        get: function () {
          return e.forStatement
        },
      }),
      Object.defineProperty(t, 'FunctionDeclaration', {
        enumerable: !0,
        get: function () {
          return e.functionDeclaration
        },
      }),
      Object.defineProperty(t, 'FunctionExpression', {
        enumerable: !0,
        get: function () {
          return e.functionExpression
        },
      }),
      Object.defineProperty(t, 'FunctionTypeAnnotation', {
        enumerable: !0,
        get: function () {
          return e.functionTypeAnnotation
        },
      }),
      Object.defineProperty(t, 'FunctionTypeParam', {
        enumerable: !0,
        get: function () {
          return e.functionTypeParam
        },
      }),
      Object.defineProperty(t, 'GenericTypeAnnotation', {
        enumerable: !0,
        get: function () {
          return e.genericTypeAnnotation
        },
      }),
      Object.defineProperty(t, 'Identifier', {
        enumerable: !0,
        get: function () {
          return e.identifier
        },
      }),
      Object.defineProperty(t, 'IfStatement', {
        enumerable: !0,
        get: function () {
          return e.ifStatement
        },
      }),
      Object.defineProperty(t, 'Import', {
        enumerable: !0,
        get: function () {
          return e.import
        },
      }),
      Object.defineProperty(t, 'ImportAttribute', {
        enumerable: !0,
        get: function () {
          return e.importAttribute
        },
      }),
      Object.defineProperty(t, 'ImportDeclaration', {
        enumerable: !0,
        get: function () {
          return e.importDeclaration
        },
      }),
      Object.defineProperty(t, 'ImportDefaultSpecifier', {
        enumerable: !0,
        get: function () {
          return e.importDefaultSpecifier
        },
      }),
      Object.defineProperty(t, 'ImportNamespaceSpecifier', {
        enumerable: !0,
        get: function () {
          return e.importNamespaceSpecifier
        },
      }),
      Object.defineProperty(t, 'ImportSpecifier', {
        enumerable: !0,
        get: function () {
          return e.importSpecifier
        },
      }),
      Object.defineProperty(t, 'IndexedAccessType', {
        enumerable: !0,
        get: function () {
          return e.indexedAccessType
        },
      }),
      Object.defineProperty(t, 'InferredPredicate', {
        enumerable: !0,
        get: function () {
          return e.inferredPredicate
        },
      }),
      Object.defineProperty(t, 'InterfaceDeclaration', {
        enumerable: !0,
        get: function () {
          return e.interfaceDeclaration
        },
      }),
      Object.defineProperty(t, 'InterfaceExtends', {
        enumerable: !0,
        get: function () {
          return e.interfaceExtends
        },
      }),
      Object.defineProperty(t, 'InterfaceTypeAnnotation', {
        enumerable: !0,
        get: function () {
          return e.interfaceTypeAnnotation
        },
      }),
      Object.defineProperty(t, 'InterpreterDirective', {
        enumerable: !0,
        get: function () {
          return e.interpreterDirective
        },
      }),
      Object.defineProperty(t, 'IntersectionTypeAnnotation', {
        enumerable: !0,
        get: function () {
          return e.intersectionTypeAnnotation
        },
      }),
      Object.defineProperty(t, 'JSXAttribute', {
        enumerable: !0,
        get: function () {
          return e.jsxAttribute
        },
      }),
      Object.defineProperty(t, 'JSXClosingElement', {
        enumerable: !0,
        get: function () {
          return e.jsxClosingElement
        },
      }),
      Object.defineProperty(t, 'JSXClosingFragment', {
        enumerable: !0,
        get: function () {
          return e.jsxClosingFragment
        },
      }),
      Object.defineProperty(t, 'JSXElement', {
        enumerable: !0,
        get: function () {
          return e.jsxElement
        },
      }),
      Object.defineProperty(t, 'JSXEmptyExpression', {
        enumerable: !0,
        get: function () {
          return e.jsxEmptyExpression
        },
      }),
      Object.defineProperty(t, 'JSXExpressionContainer', {
        enumerable: !0,
        get: function () {
          return e.jsxExpressionContainer
        },
      }),
      Object.defineProperty(t, 'JSXFragment', {
        enumerable: !0,
        get: function () {
          return e.jsxFragment
        },
      }),
      Object.defineProperty(t, 'JSXIdentifier', {
        enumerable: !0,
        get: function () {
          return e.jsxIdentifier
        },
      }),
      Object.defineProperty(t, 'JSXMemberExpression', {
        enumerable: !0,
        get: function () {
          return e.jsxMemberExpression
        },
      }),
      Object.defineProperty(t, 'JSXNamespacedName', {
        enumerable: !0,
        get: function () {
          return e.jsxNamespacedName
        },
      }),
      Object.defineProperty(t, 'JSXOpeningElement', {
        enumerable: !0,
        get: function () {
          return e.jsxOpeningElement
        },
      }),
      Object.defineProperty(t, 'JSXOpeningFragment', {
        enumerable: !0,
        get: function () {
          return e.jsxOpeningFragment
        },
      }),
      Object.defineProperty(t, 'JSXSpreadAttribute', {
        enumerable: !0,
        get: function () {
          return e.jsxSpreadAttribute
        },
      }),
      Object.defineProperty(t, 'JSXSpreadChild', {
        enumerable: !0,
        get: function () {
          return e.jsxSpreadChild
        },
      }),
      Object.defineProperty(t, 'JSXText', {
        enumerable: !0,
        get: function () {
          return e.jsxText
        },
      }),
      Object.defineProperty(t, 'LabeledStatement', {
        enumerable: !0,
        get: function () {
          return e.labeledStatement
        },
      }),
      Object.defineProperty(t, 'LogicalExpression', {
        enumerable: !0,
        get: function () {
          return e.logicalExpression
        },
      }),
      Object.defineProperty(t, 'MemberExpression', {
        enumerable: !0,
        get: function () {
          return e.memberExpression
        },
      }),
      Object.defineProperty(t, 'MetaProperty', {
        enumerable: !0,
        get: function () {
          return e.metaProperty
        },
      }),
      Object.defineProperty(t, 'MixedTypeAnnotation', {
        enumerable: !0,
        get: function () {
          return e.mixedTypeAnnotation
        },
      }),
      Object.defineProperty(t, 'ModuleExpression', {
        enumerable: !0,
        get: function () {
          return e.moduleExpression
        },
      }),
      Object.defineProperty(t, 'NewExpression', {
        enumerable: !0,
        get: function () {
          return e.newExpression
        },
      }),
      Object.defineProperty(t, 'Noop', {
        enumerable: !0,
        get: function () {
          return e.noop
        },
      }),
      Object.defineProperty(t, 'NullLiteral', {
        enumerable: !0,
        get: function () {
          return e.nullLiteral
        },
      }),
      Object.defineProperty(t, 'NullLiteralTypeAnnotation', {
        enumerable: !0,
        get: function () {
          return e.nullLiteralTypeAnnotation
        },
      }),
      Object.defineProperty(t, 'NullableTypeAnnotation', {
        enumerable: !0,
        get: function () {
          return e.nullableTypeAnnotation
        },
      }),
      Object.defineProperty(t, 'NumberLiteral', {
        enumerable: !0,
        get: function () {
          return e.numberLiteral
        },
      }),
      Object.defineProperty(t, 'NumberLiteralTypeAnnotation', {
        enumerable: !0,
        get: function () {
          return e.numberLiteralTypeAnnotation
        },
      }),
      Object.defineProperty(t, 'NumberTypeAnnotation', {
        enumerable: !0,
        get: function () {
          return e.numberTypeAnnotation
        },
      }),
      Object.defineProperty(t, 'NumericLiteral', {
        enumerable: !0,
        get: function () {
          return e.numericLiteral
        },
      }),
      Object.defineProperty(t, 'ObjectExpression', {
        enumerable: !0,
        get: function () {
          return e.objectExpression
        },
      }),
      Object.defineProperty(t, 'ObjectMethod', {
        enumerable: !0,
        get: function () {
          return e.objectMethod
        },
      }),
      Object.defineProperty(t, 'ObjectPattern', {
        enumerable: !0,
        get: function () {
          return e.objectPattern
        },
      }),
      Object.defineProperty(t, 'ObjectProperty', {
        enumerable: !0,
        get: function () {
          return e.objectProperty
        },
      }),
      Object.defineProperty(t, 'ObjectTypeAnnotation', {
        enumerable: !0,
        get: function () {
          return e.objectTypeAnnotation
        },
      }),
      Object.defineProperty(t, 'ObjectTypeCallProperty', {
        enumerable: !0,
        get: function () {
          return e.objectTypeCallProperty
        },
      }),
      Object.defineProperty(t, 'ObjectTypeIndexer', {
        enumerable: !0,
        get: function () {
          return e.objectTypeIndexer
        },
      }),
      Object.defineProperty(t, 'ObjectTypeInternalSlot', {
        enumerable: !0,
        get: function () {
          return e.objectTypeInternalSlot
        },
      }),
      Object.defineProperty(t, 'ObjectTypeProperty', {
        enumerable: !0,
        get: function () {
          return e.objectTypeProperty
        },
      }),
      Object.defineProperty(t, 'ObjectTypeSpreadProperty', {
        enumerable: !0,
        get: function () {
          return e.objectTypeSpreadProperty
        },
      }),
      Object.defineProperty(t, 'OpaqueType', {
        enumerable: !0,
        get: function () {
          return e.opaqueType
        },
      }),
      Object.defineProperty(t, 'OptionalCallExpression', {
        enumerable: !0,
        get: function () {
          return e.optionalCallExpression
        },
      }),
      Object.defineProperty(t, 'OptionalIndexedAccessType', {
        enumerable: !0,
        get: function () {
          return e.optionalIndexedAccessType
        },
      }),
      Object.defineProperty(t, 'OptionalMemberExpression', {
        enumerable: !0,
        get: function () {
          return e.optionalMemberExpression
        },
      }),
      Object.defineProperty(t, 'ParenthesizedExpression', {
        enumerable: !0,
        get: function () {
          return e.parenthesizedExpression
        },
      }),
      Object.defineProperty(t, 'PipelineBareFunction', {
        enumerable: !0,
        get: function () {
          return e.pipelineBareFunction
        },
      }),
      Object.defineProperty(t, 'PipelinePrimaryTopicReference', {
        enumerable: !0,
        get: function () {
          return e.pipelinePrimaryTopicReference
        },
      }),
      Object.defineProperty(t, 'PipelineTopicExpression', {
        enumerable: !0,
        get: function () {
          return e.pipelineTopicExpression
        },
      }),
      Object.defineProperty(t, 'Placeholder', {
        enumerable: !0,
        get: function () {
          return e.placeholder
        },
      }),
      Object.defineProperty(t, 'PrivateName', {
        enumerable: !0,
        get: function () {
          return e.privateName
        },
      }),
      Object.defineProperty(t, 'Program', {
        enumerable: !0,
        get: function () {
          return e.program
        },
      }),
      Object.defineProperty(t, 'QualifiedTypeIdentifier', {
        enumerable: !0,
        get: function () {
          return e.qualifiedTypeIdentifier
        },
      }),
      Object.defineProperty(t, 'RecordExpression', {
        enumerable: !0,
        get: function () {
          return e.recordExpression
        },
      }),
      Object.defineProperty(t, 'RegExpLiteral', {
        enumerable: !0,
        get: function () {
          return e.regExpLiteral
        },
      }),
      Object.defineProperty(t, 'RegexLiteral', {
        enumerable: !0,
        get: function () {
          return e.regexLiteral
        },
      }),
      Object.defineProperty(t, 'RestElement', {
        enumerable: !0,
        get: function () {
          return e.restElement
        },
      }),
      Object.defineProperty(t, 'RestProperty', {
        enumerable: !0,
        get: function () {
          return e.restProperty
        },
      }),
      Object.defineProperty(t, 'ReturnStatement', {
        enumerable: !0,
        get: function () {
          return e.returnStatement
        },
      }),
      Object.defineProperty(t, 'SequenceExpression', {
        enumerable: !0,
        get: function () {
          return e.sequenceExpression
        },
      }),
      Object.defineProperty(t, 'SpreadElement', {
        enumerable: !0,
        get: function () {
          return e.spreadElement
        },
      }),
      Object.defineProperty(t, 'SpreadProperty', {
        enumerable: !0,
        get: function () {
          return e.spreadProperty
        },
      }),
      Object.defineProperty(t, 'StaticBlock', {
        enumerable: !0,
        get: function () {
          return e.staticBlock
        },
      }),
      Object.defineProperty(t, 'StringLiteral', {
        enumerable: !0,
        get: function () {
          return e.stringLiteral
        },
      }),
      Object.defineProperty(t, 'StringLiteralTypeAnnotation', {
        enumerable: !0,
        get: function () {
          return e.stringLiteralTypeAnnotation
        },
      }),
      Object.defineProperty(t, 'StringTypeAnnotation', {
        enumerable: !0,
        get: function () {
          return e.stringTypeAnnotation
        },
      }),
      Object.defineProperty(t, 'Super', {
        enumerable: !0,
        get: function () {
          return e.super
        },
      }),
      Object.defineProperty(t, 'SwitchCase', {
        enumerable: !0,
        get: function () {
          return e.switchCase
        },
      }),
      Object.defineProperty(t, 'SwitchStatement', {
        enumerable: !0,
        get: function () {
          return e.switchStatement
        },
      }),
      Object.defineProperty(t, 'SymbolTypeAnnotation', {
        enumerable: !0,
        get: function () {
          return e.symbolTypeAnnotation
        },
      }),
      Object.defineProperty(t, 'TSAnyKeyword', {
        enumerable: !0,
        get: function () {
          return e.tsAnyKeyword
        },
      }),
      Object.defineProperty(t, 'TSArrayType', {
        enumerable: !0,
        get: function () {
          return e.tsArrayType
        },
      }),
      Object.defineProperty(t, 'TSAsExpression', {
        enumerable: !0,
        get: function () {
          return e.tsAsExpression
        },
      }),
      Object.defineProperty(t, 'TSBigIntKeyword', {
        enumerable: !0,
        get: function () {
          return e.tsBigIntKeyword
        },
      }),
      Object.defineProperty(t, 'TSBooleanKeyword', {
        enumerable: !0,
        get: function () {
          return e.tsBooleanKeyword
        },
      }),
      Object.defineProperty(t, 'TSCallSignatureDeclaration', {
        enumerable: !0,
        get: function () {
          return e.tsCallSignatureDeclaration
        },
      }),
      Object.defineProperty(t, 'TSConditionalType', {
        enumerable: !0,
        get: function () {
          return e.tsConditionalType
        },
      }),
      Object.defineProperty(t, 'TSConstructSignatureDeclaration', {
        enumerable: !0,
        get: function () {
          return e.tsConstructSignatureDeclaration
        },
      }),
      Object.defineProperty(t, 'TSConstructorType', {
        enumerable: !0,
        get: function () {
          return e.tsConstructorType
        },
      }),
      Object.defineProperty(t, 'TSDeclareFunction', {
        enumerable: !0,
        get: function () {
          return e.tsDeclareFunction
        },
      }),
      Object.defineProperty(t, 'TSDeclareMethod', {
        enumerable: !0,
        get: function () {
          return e.tsDeclareMethod
        },
      }),
      Object.defineProperty(t, 'TSEnumDeclaration', {
        enumerable: !0,
        get: function () {
          return e.tsEnumDeclaration
        },
      }),
      Object.defineProperty(t, 'TSEnumMember', {
        enumerable: !0,
        get: function () {
          return e.tsEnumMember
        },
      }),
      Object.defineProperty(t, 'TSExportAssignment', {
        enumerable: !0,
        get: function () {
          return e.tsExportAssignment
        },
      }),
      Object.defineProperty(t, 'TSExpressionWithTypeArguments', {
        enumerable: !0,
        get: function () {
          return e.tsExpressionWithTypeArguments
        },
      }),
      Object.defineProperty(t, 'TSExternalModuleReference', {
        enumerable: !0,
        get: function () {
          return e.tsExternalModuleReference
        },
      }),
      Object.defineProperty(t, 'TSFunctionType', {
        enumerable: !0,
        get: function () {
          return e.tsFunctionType
        },
      }),
      Object.defineProperty(t, 'TSImportEqualsDeclaration', {
        enumerable: !0,
        get: function () {
          return e.tsImportEqualsDeclaration
        },
      }),
      Object.defineProperty(t, 'TSImportType', {
        enumerable: !0,
        get: function () {
          return e.tsImportType
        },
      }),
      Object.defineProperty(t, 'TSIndexSignature', {
        enumerable: !0,
        get: function () {
          return e.tsIndexSignature
        },
      }),
      Object.defineProperty(t, 'TSIndexedAccessType', {
        enumerable: !0,
        get: function () {
          return e.tsIndexedAccessType
        },
      }),
      Object.defineProperty(t, 'TSInferType', {
        enumerable: !0,
        get: function () {
          return e.tsInferType
        },
      }),
      Object.defineProperty(t, 'TSInstantiationExpression', {
        enumerable: !0,
        get: function () {
          return e.tsInstantiationExpression
        },
      }),
      Object.defineProperty(t, 'TSInterfaceBody', {
        enumerable: !0,
        get: function () {
          return e.tsInterfaceBody
        },
      }),
      Object.defineProperty(t, 'TSInterfaceDeclaration', {
        enumerable: !0,
        get: function () {
          return e.tsInterfaceDeclaration
        },
      }),
      Object.defineProperty(t, 'TSIntersectionType', {
        enumerable: !0,
        get: function () {
          return e.tsIntersectionType
        },
      }),
      Object.defineProperty(t, 'TSIntrinsicKeyword', {
        enumerable: !0,
        get: function () {
          return e.tsIntrinsicKeyword
        },
      }),
      Object.defineProperty(t, 'TSLiteralType', {
        enumerable: !0,
        get: function () {
          return e.tsLiteralType
        },
      }),
      Object.defineProperty(t, 'TSMappedType', {
        enumerable: !0,
        get: function () {
          return e.tsMappedType
        },
      }),
      Object.defineProperty(t, 'TSMethodSignature', {
        enumerable: !0,
        get: function () {
          return e.tsMethodSignature
        },
      }),
      Object.defineProperty(t, 'TSModuleBlock', {
        enumerable: !0,
        get: function () {
          return e.tsModuleBlock
        },
      }),
      Object.defineProperty(t, 'TSModuleDeclaration', {
        enumerable: !0,
        get: function () {
          return e.tsModuleDeclaration
        },
      }),
      Object.defineProperty(t, 'TSNamedTupleMember', {
        enumerable: !0,
        get: function () {
          return e.tsNamedTupleMember
        },
      }),
      Object.defineProperty(t, 'TSNamespaceExportDeclaration', {
        enumerable: !0,
        get: function () {
          return e.tsNamespaceExportDeclaration
        },
      }),
      Object.defineProperty(t, 'TSNeverKeyword', {
        enumerable: !0,
        get: function () {
          return e.tsNeverKeyword
        },
      }),
      Object.defineProperty(t, 'TSNonNullExpression', {
        enumerable: !0,
        get: function () {
          return e.tsNonNullExpression
        },
      }),
      Object.defineProperty(t, 'TSNullKeyword', {
        enumerable: !0,
        get: function () {
          return e.tsNullKeyword
        },
      }),
      Object.defineProperty(t, 'TSNumberKeyword', {
        enumerable: !0,
        get: function () {
          return e.tsNumberKeyword
        },
      }),
      Object.defineProperty(t, 'TSObjectKeyword', {
        enumerable: !0,
        get: function () {
          return e.tsObjectKeyword
        },
      }),
      Object.defineProperty(t, 'TSOptionalType', {
        enumerable: !0,
        get: function () {
          return e.tsOptionalType
        },
      }),
      Object.defineProperty(t, 'TSParameterProperty', {
        enumerable: !0,
        get: function () {
          return e.tsParameterProperty
        },
      }),
      Object.defineProperty(t, 'TSParenthesizedType', {
        enumerable: !0,
        get: function () {
          return e.tsParenthesizedType
        },
      }),
      Object.defineProperty(t, 'TSPropertySignature', {
        enumerable: !0,
        get: function () {
          return e.tsPropertySignature
        },
      }),
      Object.defineProperty(t, 'TSQualifiedName', {
        enumerable: !0,
        get: function () {
          return e.tsQualifiedName
        },
      }),
      Object.defineProperty(t, 'TSRestType', {
        enumerable: !0,
        get: function () {
          return e.tsRestType
        },
      }),
      Object.defineProperty(t, 'TSStringKeyword', {
        enumerable: !0,
        get: function () {
          return e.tsStringKeyword
        },
      }),
      Object.defineProperty(t, 'TSSymbolKeyword', {
        enumerable: !0,
        get: function () {
          return e.tsSymbolKeyword
        },
      }),
      Object.defineProperty(t, 'TSThisType', {
        enumerable: !0,
        get: function () {
          return e.tsThisType
        },
      }),
      Object.defineProperty(t, 'TSTupleType', {
        enumerable: !0,
        get: function () {
          return e.tsTupleType
        },
      }),
      Object.defineProperty(t, 'TSTypeAliasDeclaration', {
        enumerable: !0,
        get: function () {
          return e.tsTypeAliasDeclaration
        },
      }),
      Object.defineProperty(t, 'TSTypeAnnotation', {
        enumerable: !0,
        get: function () {
          return e.tsTypeAnnotation
        },
      }),
      Object.defineProperty(t, 'TSTypeAssertion', {
        enumerable: !0,
        get: function () {
          return e.tsTypeAssertion
        },
      }),
      Object.defineProperty(t, 'TSTypeLiteral', {
        enumerable: !0,
        get: function () {
          return e.tsTypeLiteral
        },
      }),
      Object.defineProperty(t, 'TSTypeOperator', {
        enumerable: !0,
        get: function () {
          return e.tsTypeOperator
        },
      }),
      Object.defineProperty(t, 'TSTypeParameter', {
        enumerable: !0,
        get: function () {
          return e.tsTypeParameter
        },
      }),
      Object.defineProperty(t, 'TSTypeParameterDeclaration', {
        enumerable: !0,
        get: function () {
          return e.tsTypeParameterDeclaration
        },
      }),
      Object.defineProperty(t, 'TSTypeParameterInstantiation', {
        enumerable: !0,
        get: function () {
          return e.tsTypeParameterInstantiation
        },
      }),
      Object.defineProperty(t, 'TSTypePredicate', {
        enumerable: !0,
        get: function () {
          return e.tsTypePredicate
        },
      }),
      Object.defineProperty(t, 'TSTypeQuery', {
        enumerable: !0,
        get: function () {
          return e.tsTypeQuery
        },
      }),
      Object.defineProperty(t, 'TSTypeReference', {
        enumerable: !0,
        get: function () {
          return e.tsTypeReference
        },
      }),
      Object.defineProperty(t, 'TSUndefinedKeyword', {
        enumerable: !0,
        get: function () {
          return e.tsUndefinedKeyword
        },
      }),
      Object.defineProperty(t, 'TSUnionType', {
        enumerable: !0,
        get: function () {
          return e.tsUnionType
        },
      }),
      Object.defineProperty(t, 'TSUnknownKeyword', {
        enumerable: !0,
        get: function () {
          return e.tsUnknownKeyword
        },
      }),
      Object.defineProperty(t, 'TSVoidKeyword', {
        enumerable: !0,
        get: function () {
          return e.tsVoidKeyword
        },
      }),
      Object.defineProperty(t, 'TaggedTemplateExpression', {
        enumerable: !0,
        get: function () {
          return e.taggedTemplateExpression
        },
      }),
      Object.defineProperty(t, 'TemplateElement', {
        enumerable: !0,
        get: function () {
          return e.templateElement
        },
      }),
      Object.defineProperty(t, 'TemplateLiteral', {
        enumerable: !0,
        get: function () {
          return e.templateLiteral
        },
      }),
      Object.defineProperty(t, 'ThisExpression', {
        enumerable: !0,
        get: function () {
          return e.thisExpression
        },
      }),
      Object.defineProperty(t, 'ThisTypeAnnotation', {
        enumerable: !0,
        get: function () {
          return e.thisTypeAnnotation
        },
      }),
      Object.defineProperty(t, 'ThrowStatement', {
        enumerable: !0,
        get: function () {
          return e.throwStatement
        },
      }),
      Object.defineProperty(t, 'TopicReference', {
        enumerable: !0,
        get: function () {
          return e.topicReference
        },
      }),
      Object.defineProperty(t, 'TryStatement', {
        enumerable: !0,
        get: function () {
          return e.tryStatement
        },
      }),
      Object.defineProperty(t, 'TupleExpression', {
        enumerable: !0,
        get: function () {
          return e.tupleExpression
        },
      }),
      Object.defineProperty(t, 'TupleTypeAnnotation', {
        enumerable: !0,
        get: function () {
          return e.tupleTypeAnnotation
        },
      }),
      Object.defineProperty(t, 'TypeAlias', {
        enumerable: !0,
        get: function () {
          return e.typeAlias
        },
      }),
      Object.defineProperty(t, 'TypeAnnotation', {
        enumerable: !0,
        get: function () {
          return e.typeAnnotation
        },
      }),
      Object.defineProperty(t, 'TypeCastExpression', {
        enumerable: !0,
        get: function () {
          return e.typeCastExpression
        },
      }),
      Object.defineProperty(t, 'TypeParameter', {
        enumerable: !0,
        get: function () {
          return e.typeParameter
        },
      }),
      Object.defineProperty(t, 'TypeParameterDeclaration', {
        enumerable: !0,
        get: function () {
          return e.typeParameterDeclaration
        },
      }),
      Object.defineProperty(t, 'TypeParameterInstantiation', {
        enumerable: !0,
        get: function () {
          return e.typeParameterInstantiation
        },
      }),
      Object.defineProperty(t, 'TypeofTypeAnnotation', {
        enumerable: !0,
        get: function () {
          return e.typeofTypeAnnotation
        },
      }),
      Object.defineProperty(t, 'UnaryExpression', {
        enumerable: !0,
        get: function () {
          return e.unaryExpression
        },
      }),
      Object.defineProperty(t, 'UnionTypeAnnotation', {
        enumerable: !0,
        get: function () {
          return e.unionTypeAnnotation
        },
      }),
      Object.defineProperty(t, 'UpdateExpression', {
        enumerable: !0,
        get: function () {
          return e.updateExpression
        },
      }),
      Object.defineProperty(t, 'V8IntrinsicIdentifier', {
        enumerable: !0,
        get: function () {
          return e.v8IntrinsicIdentifier
        },
      }),
      Object.defineProperty(t, 'VariableDeclaration', {
        enumerable: !0,
        get: function () {
          return e.variableDeclaration
        },
      }),
      Object.defineProperty(t, 'VariableDeclarator', {
        enumerable: !0,
        get: function () {
          return e.variableDeclarator
        },
      }),
      Object.defineProperty(t, 'Variance', {
        enumerable: !0,
        get: function () {
          return e.variance
        },
      }),
      Object.defineProperty(t, 'VoidTypeAnnotation', {
        enumerable: !0,
        get: function () {
          return e.voidTypeAnnotation
        },
      }),
      Object.defineProperty(t, 'WhileStatement', {
        enumerable: !0,
        get: function () {
          return e.whileStatement
        },
      }),
      Object.defineProperty(t, 'WithStatement', {
        enumerable: !0,
        get: function () {
          return e.withStatement
        },
      }),
      Object.defineProperty(t, 'YieldExpression', {
        enumerable: !0,
        get: function () {
          return e.yieldExpression
        },
      })
    var e = M
  })(qd)
  var Vr = {}
  Object.defineProperty(Vr, '__esModule', { value: !0 }), (Vr.default = OM)
  var Xd = fr,
    Gd = $
  const Ur = Function.call.bind(Object.prototype.hasOwnProperty)
  function Jd(t, e, r, i) {
    return t && typeof t.type == 'string' ? Qd(t, e, r, i) : t
  }
  function Zd(t, e, r, i) {
    return Array.isArray(t) ? t.map((n) => Jd(n, e, r, i)) : Jd(t, e, r, i)
  }
  function OM(t, e = !0, r = !1) {
    return Qd(t, e, r, new Map())
  }
  function Qd(t, e = !0, r = !1, i) {
    if (!t) return t
    const { type: n } = t,
      s = { type: t.type }
    if ((0, Gd.isIdentifier)(t))
      (s.name = t.name),
        Ur(t, 'optional') && typeof t.optional == 'boolean' && (s.optional = t.optional),
        Ur(t, 'typeAnnotation') && (s.typeAnnotation = e ? Zd(t.typeAnnotation, !0, r, i) : t.typeAnnotation)
    else if (Ur(Xd.NODE_FIELDS, n))
      for (const a of Object.keys(Xd.NODE_FIELDS[n]))
        Ur(t, a) &&
          (e
            ? (s[a] = (0, Gd.isFile)(t) && a === 'comments' ? Oa(t.comments, e, r, i) : Zd(t[a], !0, r, i))
            : (s[a] = t[a]))
    else throw new Error(`Unknown node type: "${n}"`)
    return (
      Ur(t, 'loc') && (r ? (s.loc = null) : (s.loc = t.loc)),
      Ur(t, 'leadingComments') && (s.leadingComments = Oa(t.leadingComments, e, r, i)),
      Ur(t, 'innerComments') && (s.innerComments = Oa(t.innerComments, e, r, i)),
      Ur(t, 'trailingComments') && (s.trailingComments = Oa(t.trailingComments, e, r, i)),
      Ur(t, 'extra') && (s.extra = Object.assign({}, t.extra)),
      s
    )
  }
  function Oa(t, e, r, i) {
    return !t || !e
      ? t
      : t.map((n) => {
          const s = i.get(n)
          if (s) return s
          const { type: a, value: o, loc: u } = n,
            c = { type: a, value: o, loc: u }
          return r && (c.loc = null), i.set(n, c), c
        })
  }
  var Su = {}
  Object.defineProperty(Su, '__esModule', { value: !0 }), (Su.default = BM)
  var DM = Vr
  function BM(t) {
    return (0, DM.default)(t, !1)
  }
  var vu = {}
  Object.defineProperty(vu, '__esModule', { value: !0 }), (vu.default = MM)
  var LM = Vr
  function MM(t) {
    return (0, LM.default)(t)
  }
  var Eu = {}
  Object.defineProperty(Eu, '__esModule', { value: !0 }), (Eu.default = $M)
  var FM = Vr
  function $M(t) {
    return (0, FM.default)(t, !0, !0)
  }
  var Pu = {}
  Object.defineProperty(Pu, '__esModule', { value: !0 }), (Pu.default = jM)
  var RM = Vr
  function jM(t) {
    return (0, RM.default)(t, !1, !0)
  }
  var wu = {},
    Da = {}
  Object.defineProperty(Da, '__esModule', { value: !0 }), (Da.default = _M)
  function _M(t, e, r) {
    if (!r || !t) return t
    const i = `${e}Comments`
    return t[i] ? (e === 'leading' ? (t[i] = r.concat(t[i])) : t[i].push(...r)) : (t[i] = r), t
  }
  Object.defineProperty(wu, '__esModule', { value: !0 }), (wu.default = UM)
  var VM = Da
  function UM(t, e, r, i) {
    return (0, VM.default)(t, e, [{ type: i ? 'CommentLine' : 'CommentBlock', value: r }])
  }
  var Ba = {},
    ms = {}
  Object.defineProperty(ms, '__esModule', { value: !0 }), (ms.default = zM)
  function zM(t, e, r) {
    e && r && (e[t] = Array.from(new Set([].concat(e[t], r[t]).filter(Boolean))))
  }
  Object.defineProperty(Ba, '__esModule', { value: !0 }), (Ba.default = WM)
  var KM = ms
  function WM(t, e) {
    ;(0, KM.default)('innerComments', t, e)
  }
  var La = {}
  Object.defineProperty(La, '__esModule', { value: !0 }), (La.default = HM)
  var YM = ms
  function HM(t, e) {
    ;(0, YM.default)('leadingComments', t, e)
  }
  var Ma = {},
    Fa = {}
  Object.defineProperty(Fa, '__esModule', { value: !0 }), (Fa.default = XM)
  var qM = ms
  function XM(t, e) {
    ;(0, qM.default)('trailingComments', t, e)
  }
  Object.defineProperty(Ma, '__esModule', { value: !0 }), (Ma.default = QM)
  var GM = Fa,
    JM = La,
    ZM = Ba
  function QM(t, e) {
    return (0, GM.default)(t, e), (0, JM.default)(t, e), (0, ZM.default)(t, e), t
  }
  var Au = {}
  Object.defineProperty(Au, '__esModule', { value: !0 }), (Au.default = t3)
  var e3 = Je
  function t3(t) {
    return (
      e3.COMMENT_KEYS.forEach((e) => {
        t[e] = null
      }),
      t
    )
  }
  var Ce = {}
  Object.defineProperty(Ce, '__esModule', { value: !0 }),
    (Ce.WHILE_TYPES =
      Ce.USERWHITESPACABLE_TYPES =
      Ce.UNARYLIKE_TYPES =
      Ce.TYPESCRIPT_TYPES =
      Ce.TSTYPE_TYPES =
      Ce.TSTYPEELEMENT_TYPES =
      Ce.TSENTITYNAME_TYPES =
      Ce.TSBASETYPE_TYPES =
      Ce.TERMINATORLESS_TYPES =
      Ce.STATEMENT_TYPES =
      Ce.STANDARDIZED_TYPES =
      Ce.SCOPABLE_TYPES =
      Ce.PUREISH_TYPES =
      Ce.PROPERTY_TYPES =
      Ce.PRIVATE_TYPES =
      Ce.PATTERN_TYPES =
      Ce.PATTERNLIKE_TYPES =
      Ce.OBJECTMEMBER_TYPES =
      Ce.MODULESPECIFIER_TYPES =
      Ce.MODULEDECLARATION_TYPES =
      Ce.MISCELLANEOUS_TYPES =
      Ce.METHOD_TYPES =
      Ce.LVAL_TYPES =
      Ce.LOOP_TYPES =
      Ce.LITERAL_TYPES =
      Ce.JSX_TYPES =
      Ce.IMMUTABLE_TYPES =
      Ce.FUNCTION_TYPES =
      Ce.FUNCTIONPARENT_TYPES =
      Ce.FOR_TYPES =
      Ce.FORXSTATEMENT_TYPES =
      Ce.FLOW_TYPES =
      Ce.FLOWTYPE_TYPES =
      Ce.FLOWPREDICATE_TYPES =
      Ce.FLOWDECLARATION_TYPES =
      Ce.FLOWBASEANNOTATION_TYPES =
      Ce.EXPRESSION_TYPES =
      Ce.EXPRESSIONWRAPPER_TYPES =
      Ce.EXPORTDECLARATION_TYPES =
      Ce.ENUMMEMBER_TYPES =
      Ce.ENUMBODY_TYPES =
      Ce.DECLARATION_TYPES =
      Ce.CONDITIONAL_TYPES =
      Ce.COMPLETIONSTATEMENT_TYPES =
      Ce.CLASS_TYPES =
      Ce.BLOCK_TYPES =
      Ce.BLOCKPARENT_TYPES =
      Ce.BINARY_TYPES =
      Ce.ACCESSOR_TYPES =
        void 0)
  var Ge = fr
  const r3 = Ge.FLIPPED_ALIAS_KEYS.Standardized
  Ce.STANDARDIZED_TYPES = r3
  const i3 = Ge.FLIPPED_ALIAS_KEYS.Expression
  Ce.EXPRESSION_TYPES = i3
  const n3 = Ge.FLIPPED_ALIAS_KEYS.Binary
  Ce.BINARY_TYPES = n3
  const s3 = Ge.FLIPPED_ALIAS_KEYS.Scopable
  Ce.SCOPABLE_TYPES = s3
  const a3 = Ge.FLIPPED_ALIAS_KEYS.BlockParent
  Ce.BLOCKPARENT_TYPES = a3
  const o3 = Ge.FLIPPED_ALIAS_KEYS.Block
  Ce.BLOCK_TYPES = o3
  const l3 = Ge.FLIPPED_ALIAS_KEYS.Statement
  Ce.STATEMENT_TYPES = l3
  const u3 = Ge.FLIPPED_ALIAS_KEYS.Terminatorless
  Ce.TERMINATORLESS_TYPES = u3
  const c3 = Ge.FLIPPED_ALIAS_KEYS.CompletionStatement
  Ce.COMPLETIONSTATEMENT_TYPES = c3
  const p3 = Ge.FLIPPED_ALIAS_KEYS.Conditional
  Ce.CONDITIONAL_TYPES = p3
  const f3 = Ge.FLIPPED_ALIAS_KEYS.Loop
  Ce.LOOP_TYPES = f3
  const h3 = Ge.FLIPPED_ALIAS_KEYS.While
  Ce.WHILE_TYPES = h3
  const d3 = Ge.FLIPPED_ALIAS_KEYS.ExpressionWrapper
  Ce.EXPRESSIONWRAPPER_TYPES = d3
  const m3 = Ge.FLIPPED_ALIAS_KEYS.For
  Ce.FOR_TYPES = m3
  const y3 = Ge.FLIPPED_ALIAS_KEYS.ForXStatement
  Ce.FORXSTATEMENT_TYPES = y3
  const g3 = Ge.FLIPPED_ALIAS_KEYS.Function
  Ce.FUNCTION_TYPES = g3
  const T3 = Ge.FLIPPED_ALIAS_KEYS.FunctionParent
  Ce.FUNCTIONPARENT_TYPES = T3
  const b3 = Ge.FLIPPED_ALIAS_KEYS.Pureish
  Ce.PUREISH_TYPES = b3
  const S3 = Ge.FLIPPED_ALIAS_KEYS.Declaration
  Ce.DECLARATION_TYPES = S3
  const v3 = Ge.FLIPPED_ALIAS_KEYS.PatternLike
  Ce.PATTERNLIKE_TYPES = v3
  const E3 = Ge.FLIPPED_ALIAS_KEYS.LVal
  Ce.LVAL_TYPES = E3
  const P3 = Ge.FLIPPED_ALIAS_KEYS.TSEntityName
  Ce.TSENTITYNAME_TYPES = P3
  const w3 = Ge.FLIPPED_ALIAS_KEYS.Literal
  Ce.LITERAL_TYPES = w3
  const A3 = Ge.FLIPPED_ALIAS_KEYS.Immutable
  Ce.IMMUTABLE_TYPES = A3
  const C3 = Ge.FLIPPED_ALIAS_KEYS.UserWhitespacable
  Ce.USERWHITESPACABLE_TYPES = C3
  const x3 = Ge.FLIPPED_ALIAS_KEYS.Method
  Ce.METHOD_TYPES = x3
  const I3 = Ge.FLIPPED_ALIAS_KEYS.ObjectMember
  Ce.OBJECTMEMBER_TYPES = I3
  const k3 = Ge.FLIPPED_ALIAS_KEYS.Property
  Ce.PROPERTY_TYPES = k3
  const N3 = Ge.FLIPPED_ALIAS_KEYS.UnaryLike
  Ce.UNARYLIKE_TYPES = N3
  const O3 = Ge.FLIPPED_ALIAS_KEYS.Pattern
  Ce.PATTERN_TYPES = O3
  const D3 = Ge.FLIPPED_ALIAS_KEYS.Class
  Ce.CLASS_TYPES = D3
  const B3 = Ge.FLIPPED_ALIAS_KEYS.ModuleDeclaration
  Ce.MODULEDECLARATION_TYPES = B3
  const L3 = Ge.FLIPPED_ALIAS_KEYS.ExportDeclaration
  Ce.EXPORTDECLARATION_TYPES = L3
  const M3 = Ge.FLIPPED_ALIAS_KEYS.ModuleSpecifier
  Ce.MODULESPECIFIER_TYPES = M3
  const F3 = Ge.FLIPPED_ALIAS_KEYS.Accessor
  Ce.ACCESSOR_TYPES = F3
  const $3 = Ge.FLIPPED_ALIAS_KEYS.Private
  Ce.PRIVATE_TYPES = $3
  const R3 = Ge.FLIPPED_ALIAS_KEYS.Flow
  Ce.FLOW_TYPES = R3
  const j3 = Ge.FLIPPED_ALIAS_KEYS.FlowType
  Ce.FLOWTYPE_TYPES = j3
  const _3 = Ge.FLIPPED_ALIAS_KEYS.FlowBaseAnnotation
  Ce.FLOWBASEANNOTATION_TYPES = _3
  const V3 = Ge.FLIPPED_ALIAS_KEYS.FlowDeclaration
  Ce.FLOWDECLARATION_TYPES = V3
  const U3 = Ge.FLIPPED_ALIAS_KEYS.FlowPredicate
  Ce.FLOWPREDICATE_TYPES = U3
  const z3 = Ge.FLIPPED_ALIAS_KEYS.EnumBody
  Ce.ENUMBODY_TYPES = z3
  const K3 = Ge.FLIPPED_ALIAS_KEYS.EnumMember
  Ce.ENUMMEMBER_TYPES = K3
  const W3 = Ge.FLIPPED_ALIAS_KEYS.JSX
  Ce.JSX_TYPES = W3
  const Y3 = Ge.FLIPPED_ALIAS_KEYS.Miscellaneous
  Ce.MISCELLANEOUS_TYPES = Y3
  const H3 = Ge.FLIPPED_ALIAS_KEYS.TypeScript
  Ce.TYPESCRIPT_TYPES = H3
  const q3 = Ge.FLIPPED_ALIAS_KEYS.TSTypeElement
  Ce.TSTYPEELEMENT_TYPES = q3
  const X3 = Ge.FLIPPED_ALIAS_KEYS.TSType
  Ce.TSTYPE_TYPES = X3
  const G3 = Ge.FLIPPED_ALIAS_KEYS.TSBaseType
  Ce.TSBASETYPE_TYPES = G3
  var Cu = {},
    $a = {}
  Object.defineProperty($a, '__esModule', { value: !0 }), ($a.default = J3)
  var Ra = $,
    xu = M
  function J3(t, e) {
    if ((0, Ra.isBlockStatement)(t)) return t
    let r = []
    return (
      (0, Ra.isEmptyStatement)(t)
        ? (r = [])
        : ((0, Ra.isStatement)(t) ||
            ((0, Ra.isFunction)(e) ? (t = (0, xu.returnStatement)(t)) : (t = (0, xu.expressionStatement)(t))),
          (r = [t])),
      (0, xu.blockStatement)(r)
    )
  }
  Object.defineProperty(Cu, '__esModule', { value: !0 }), (Cu.default = Q3)
  var Z3 = $a
  function Q3(t, e = 'body') {
    return (t[e] = (0, Z3.default)(t[e], t))
  }
  var Iu = {},
    ja = {}
  Object.defineProperty(ja, '__esModule', { value: !0 }), (ja.default = rF)
  var eF = Ui,
    tF = ps
  function rF(t) {
    t = t + ''
    let e = ''
    for (const r of t) e += (0, tF.isIdentifierChar)(r.codePointAt(0)) ? r : '-'
    return (
      (e = e.replace(/^[-0-9]+/, '')),
      (e = e.replace(/[-\s]+(.)?/g, function (r, i) {
        return i ? i.toUpperCase() : ''
      })),
      (0, eF.default)(e) || (e = `_${e}`),
      e || '_'
    )
  }
  Object.defineProperty(Iu, '__esModule', { value: !0 }), (Iu.default = nF)
  var iF = ja
  function nF(t) {
    return (t = (0, iF.default)(t)), (t === 'eval' || t === 'arguments') && (t = '_' + t), t
  }
  var ku = {}
  Object.defineProperty(ku, '__esModule', { value: !0 }), (ku.default = oF)
  var sF = $,
    aF = M
  function oF(t, e = t.key || t.property) {
    return !t.computed && (0, sF.isIdentifier)(e) && (e = (0, aF.stringLiteral)(e.name)), e
  }
  var _a = {}
  Object.defineProperty(_a, '__esModule', { value: !0 }), (_a.default = void 0)
  var ys = $,
    lF = uF
  _a.default = lF
  function uF(t) {
    if (((0, ys.isExpressionStatement)(t) && (t = t.expression), (0, ys.isExpression)(t))) return t
    if (
      ((0, ys.isClass)(t) ? (t.type = 'ClassExpression') : (0, ys.isFunction)(t) && (t.type = 'FunctionExpression'),
      !(0, ys.isExpression)(t))
    )
      throw new Error(`cannot turn ${t.type} to an expression`)
    return t
  }
  var Nu = {},
    Va = {},
    Ua = {}
  Object.defineProperty(Ua, '__esModule', { value: !0 }), (Ua.default = Ou)
  var cF = fr
  function Ou(t, e, r) {
    if (!t) return
    const i = cF.VISITOR_KEYS[t.type]
    if (!!i) {
      ;(r = r || {}), e(t, r)
      for (const n of i) {
        const s = t[n]
        if (Array.isArray(s)) for (const a of s) Ou(a, e, r)
        else Ou(s, e, r)
      }
    }
  }
  var za = {}
  Object.defineProperty(za, '__esModule', { value: !0 }), (za.default = hF)
  var pF = Je
  const em = ['tokens', 'start', 'end', 'loc', 'raw', 'rawValue'],
    fF = pF.COMMENT_KEYS.concat(['comments']).concat(em)
  function hF(t, e = {}) {
    const r = e.preserveComments ? em : fF
    for (const n of r) t[n] != null && (t[n] = void 0)
    for (const n of Object.keys(t)) n[0] === '_' && t[n] != null && (t[n] = void 0)
    const i = Object.getOwnPropertySymbols(t)
    for (const n of i) t[n] = null
  }
  Object.defineProperty(Va, '__esModule', { value: !0 }), (Va.default = yF)
  var dF = Ua,
    mF = za
  function yF(t, e) {
    return (0, dF.default)(t, mF.default, e), t
  }
  Object.defineProperty(Nu, '__esModule', { value: !0 }), (Nu.default = Wi)
  var tm = $,
    gF = Vr,
    TF = Va
  function Wi(t, e = t.key) {
    let r
    return t.kind === 'method'
      ? Wi.increment() + ''
      : ((0, tm.isIdentifier)(e)
          ? (r = e.name)
          : (0, tm.isStringLiteral)(e)
          ? (r = JSON.stringify(e.value))
          : (r = JSON.stringify((0, TF.default)((0, gF.default)(e)))),
        t.computed && (r = `[${r}]`),
        t.static && (r = `static:${r}`),
        r)
  }
  ;(Wi.uid = 0),
    (Wi.increment = function () {
      return Wi.uid >= Number.MAX_SAFE_INTEGER ? (Wi.uid = 0) : Wi.uid++
    })
  var Du = {},
    Bu = {},
    vn = {}
  Object.defineProperty(vn, '__esModule', { value: !0 }), (vn.default = Lu)
  var En = $
  function Lu(t, e, r) {
    let i = [].concat(t)
    const n = Object.create(null)
    for (; i.length; ) {
      const s = i.shift()
      if (!s) continue
      const a = Lu.keys[s.type]
      if ((0, En.isIdentifier)(s)) {
        e ? (n[s.name] = n[s.name] || []).push(s) : (n[s.name] = s)
        continue
      }
      if ((0, En.isExportDeclaration)(s) && !(0, En.isExportAllDeclaration)(s)) {
        ;(0, En.isDeclaration)(s.declaration) && i.push(s.declaration)
        continue
      }
      if (r) {
        if ((0, En.isFunctionDeclaration)(s)) {
          i.push(s.id)
          continue
        }
        if ((0, En.isFunctionExpression)(s)) continue
      }
      if (a)
        for (let o = 0; o < a.length; o++) {
          const u = a[o]
          s[u] && (i = i.concat(s[u]))
        }
    }
    return n
  }
  ;(Lu.keys = {
    DeclareClass: ['id'],
    DeclareFunction: ['id'],
    DeclareModule: ['id'],
    DeclareVariable: ['id'],
    DeclareInterface: ['id'],
    DeclareTypeAlias: ['id'],
    DeclareOpaqueType: ['id'],
    InterfaceDeclaration: ['id'],
    TypeAlias: ['id'],
    OpaqueType: ['id'],
    CatchClause: ['param'],
    LabeledStatement: ['label'],
    UnaryExpression: ['argument'],
    AssignmentExpression: ['left'],
    ImportSpecifier: ['local'],
    ImportNamespaceSpecifier: ['local'],
    ImportDefaultSpecifier: ['local'],
    ImportDeclaration: ['specifiers'],
    ExportSpecifier: ['exported'],
    ExportNamespaceSpecifier: ['exported'],
    ExportDefaultSpecifier: ['exported'],
    FunctionDeclaration: ['id', 'params'],
    FunctionExpression: ['id', 'params'],
    ArrowFunctionExpression: ['params'],
    ObjectMethod: ['params'],
    ClassMethod: ['params'],
    ClassPrivateMethod: ['params'],
    ForInStatement: ['left'],
    ForOfStatement: ['left'],
    ClassDeclaration: ['id'],
    ClassExpression: ['id'],
    RestElement: ['argument'],
    UpdateExpression: ['argument'],
    ObjectProperty: ['value'],
    AssignmentPattern: ['left'],
    ArrayPattern: ['elements'],
    ObjectPattern: ['properties'],
    VariableDeclaration: ['declarations'],
    VariableDeclarator: ['id'],
  }),
    Object.defineProperty(Bu, '__esModule', { value: !0 }),
    (Bu.default = Ka)
  var bF = vn,
    Yi = $,
    Mu = M,
    SF = Vr
  function Ka(t, e, r) {
    const i = []
    let n = !0
    for (const s of t)
      if (((0, Yi.isEmptyStatement)(s) || (n = !1), (0, Yi.isExpression)(s))) i.push(s)
      else if ((0, Yi.isExpressionStatement)(s)) i.push(s.expression)
      else if ((0, Yi.isVariableDeclaration)(s)) {
        if (s.kind !== 'var') return
        for (const a of s.declarations) {
          const o = (0, bF.default)(a)
          for (const u of Object.keys(o)) r.push({ kind: s.kind, id: (0, SF.default)(o[u]) })
          a.init && i.push((0, Mu.assignmentExpression)('=', a.id, a.init))
        }
        n = !0
      } else if ((0, Yi.isIfStatement)(s)) {
        const a = s.consequent ? Ka([s.consequent], e, r) : e.buildUndefinedNode(),
          o = s.alternate ? Ka([s.alternate], e, r) : e.buildUndefinedNode()
        if (!a || !o) return
        i.push((0, Mu.conditionalExpression)(s.test, a, o))
      } else if ((0, Yi.isBlockStatement)(s)) {
        const a = Ka(s.body, e, r)
        if (!a) return
        i.push(a)
      } else if ((0, Yi.isEmptyStatement)(s)) t.indexOf(s) === 0 && (n = !0)
      else return
    return n && i.push(e.buildUndefinedNode()), i.length === 1 ? i[0] : (0, Mu.sequenceExpression)(i)
  }
  Object.defineProperty(Du, '__esModule', { value: !0 }), (Du.default = EF)
  var vF = Bu
  function EF(t, e) {
    if (!(t != null && t.length)) return
    const r = [],
      i = (0, vF.default)(t, e, r)
    if (!!i) {
      for (const n of r) e.push(n)
      return i
    }
  }
  var Wa = {}
  Object.defineProperty(Wa, '__esModule', { value: !0 }), (Wa.default = void 0)
  var Ya = $,
    PF = M,
    wF = AF
  Wa.default = wF
  function AF(t, e) {
    if ((0, Ya.isStatement)(t)) return t
    let r = !1,
      i
    if ((0, Ya.isClass)(t)) (r = !0), (i = 'ClassDeclaration')
    else if ((0, Ya.isFunction)(t)) (r = !0), (i = 'FunctionDeclaration')
    else if ((0, Ya.isAssignmentExpression)(t)) return (0, PF.expressionStatement)(t)
    if ((r && !t.id && (i = !1), !i)) {
      if (e) return !1
      throw new Error(`cannot turn ${t.type} to a statement`)
    }
    return (t.type = i), t
  }
  var Ha = {}
  Object.defineProperty(Ha, '__esModule', { value: !0 }), (Ha.default = void 0)
  var CF = Ui,
    _t = M,
    xF = Fu
  Ha.default = xF
  const IF = Function.call.bind(Object.prototype.toString)
  function kF(t) {
    return IF(t) === '[object RegExp]'
  }
  function NF(t) {
    if (typeof t != 'object' || t === null || Object.prototype.toString.call(t) !== '[object Object]') return !1
    const e = Object.getPrototypeOf(t)
    return e === null || Object.getPrototypeOf(e) === null
  }
  function Fu(t) {
    if (t === void 0) return (0, _t.identifier)('undefined')
    if (t === !0 || t === !1) return (0, _t.booleanLiteral)(t)
    if (t === null) return (0, _t.nullLiteral)()
    if (typeof t == 'string') return (0, _t.stringLiteral)(t)
    if (typeof t == 'number') {
      let e
      if (Number.isFinite(t)) e = (0, _t.numericLiteral)(Math.abs(t))
      else {
        let r
        Number.isNaN(t) ? (r = (0, _t.numericLiteral)(0)) : (r = (0, _t.numericLiteral)(1)),
          (e = (0, _t.binaryExpression)('/', r, (0, _t.numericLiteral)(0)))
      }
      return (t < 0 || Object.is(t, -0)) && (e = (0, _t.unaryExpression)('-', e)), e
    }
    if (kF(t)) {
      const e = t.source,
        r = t.toString().match(/\/([a-z]+|)$/)[1]
      return (0, _t.regExpLiteral)(e, r)
    }
    if (Array.isArray(t)) return (0, _t.arrayExpression)(t.map(Fu))
    if (NF(t)) {
      const e = []
      for (const r of Object.keys(t)) {
        let i
        ;(0, CF.default)(r) ? (i = (0, _t.identifier)(r)) : (i = (0, _t.stringLiteral)(r)),
          e.push((0, _t.objectProperty)(i, Fu(t[r])))
      }
      return (0, _t.objectExpression)(e)
    }
    throw new Error("don't know how to turn this value into a node")
  }
  var $u = {}
  Object.defineProperty($u, '__esModule', { value: !0 }), ($u.default = DF)
  var OF = M
  function DF(t, e, r = !1) {
    return (
      (t.object = (0, OF.memberExpression)(t.object, t.property, t.computed)), (t.property = e), (t.computed = !!r), t
    )
  }
  var Ru = {}
  Object.defineProperty(Ru, '__esModule', { value: !0 }), (Ru.default = LF)
  var rm = Je,
    BF = Ma
  function LF(t, e) {
    if (!t || !e) return t
    for (const r of rm.INHERIT_KEYS.optional) t[r] == null && (t[r] = e[r])
    for (const r of Object.keys(e)) r[0] === '_' && r !== '__clone' && (t[r] = e[r])
    for (const r of rm.INHERIT_KEYS.force) t[r] = e[r]
    return (0, BF.default)(t, e), t
  }
  var ju = {}
  Object.defineProperty(ju, '__esModule', { value: !0 }), (ju.default = FF)
  var MF = M
  function FF(t, e) {
    return (t.object = (0, MF.memberExpression)(e, t.object)), t
  }
  var qa = {}
  Object.defineProperty(qa, '__esModule', { value: !0 }), (qa.default = void 0)
  var $F = vn,
    RF = jF
  qa.default = RF
  function jF(t, e) {
    return (0, $F.default)(t, e, !0)
  }
  var _u = {}
  Object.defineProperty(_u, '__esModule', { value: !0 }), (_u.default = VF)
  var _F = fr
  function VF(t, e, r) {
    typeof e == 'function' && (e = { enter: e })
    const { enter: i, exit: n } = e
    Vu(t, i, n, r, [])
  }
  function Vu(t, e, r, i, n) {
    const s = _F.VISITOR_KEYS[t.type]
    if (!!s) {
      e && e(t, n, i)
      for (const a of s) {
        const o = t[a]
        if (Array.isArray(o))
          for (let u = 0; u < o.length; u++) {
            const c = o[u]
            !c || (n.push({ node: t, key: a, index: u }), Vu(c, e, r, i, n), n.pop())
          }
        else o && (n.push({ node: t, key: a }), Vu(o, e, r, i, n), n.pop())
      }
      r && r(t, n, i)
    }
  }
  var Uu = {}
  Object.defineProperty(Uu, '__esModule', { value: !0 }), (Uu.default = zF)
  var UF = vn
  function zF(t, e, r) {
    if (r && t.type === 'Identifier' && e.type === 'ObjectProperty' && r.type === 'ObjectExpression') return !1
    const i = UF.default.keys[e.type]
    if (i)
      for (let n = 0; n < i.length; n++) {
        const s = i[n],
          a = e[s]
        if (Array.isArray(a)) {
          if (a.indexOf(t) >= 0) return !0
        } else if (a === t) return !0
      }
    return !1
  }
  var zu = {},
    Xa = {}
  Object.defineProperty(Xa, '__esModule', { value: !0 }), (Xa.default = YF)
  var KF = $,
    WF = Je
  function YF(t) {
    return (0, KF.isVariableDeclaration)(t) && (t.kind !== 'var' || t[WF.BLOCK_SCOPED_SYMBOL])
  }
  Object.defineProperty(zu, '__esModule', { value: !0 }), (zu.default = qF)
  var im = $,
    HF = Xa
  function qF(t) {
    return (0, im.isFunctionDeclaration)(t) || (0, im.isClassDeclaration)(t) || (0, HF.default)(t)
  }
  var Ku = {}
  Object.defineProperty(Ku, '__esModule', { value: !0 }), (Ku.default = JF)
  var XF = cs,
    GF = $
  function JF(t) {
    return (0, XF.default)(t.type, 'Immutable') ? !0 : (0, GF.isIdentifier)(t) ? t.name === 'undefined' : !1
  }
  var Wu = {}
  Object.defineProperty(Wu, '__esModule', { value: !0 }), (Wu.default = Yu)
  var nm = fr
  function Yu(t, e) {
    if (typeof t != 'object' || typeof e != 'object' || t == null || e == null) return t === e
    if (t.type !== e.type) return !1
    const r = Object.keys(nm.NODE_FIELDS[t.type] || t.type),
      i = nm.VISITOR_KEYS[t.type]
    for (const n of r) {
      if (typeof t[n] != typeof e[n]) return !1
      if (!(t[n] == null && e[n] == null)) {
        if (t[n] == null || e[n] == null) return !1
        if (Array.isArray(t[n])) {
          if (!Array.isArray(e[n]) || t[n].length !== e[n].length) return !1
          for (let s = 0; s < t[n].length; s++) if (!Yu(t[n][s], e[n][s])) return !1
          continue
        }
        if (typeof t[n] == 'object' && !(i != null && i.includes(n))) {
          for (const s of Object.keys(t[n])) if (t[n][s] !== e[n][s]) return !1
          continue
        }
        if (!Yu(t[n], e[n])) return !1
      }
    }
    return !0
  }
  var Hu = {}
  Object.defineProperty(Hu, '__esModule', { value: !0 }), (Hu.default = ZF)
  function ZF(t, e, r) {
    switch (e.type) {
      case 'MemberExpression':
      case 'OptionalMemberExpression':
        return e.property === t ? !!e.computed : e.object === t
      case 'JSXMemberExpression':
        return e.object === t
      case 'VariableDeclarator':
        return e.init === t
      case 'ArrowFunctionExpression':
        return e.body === t
      case 'PrivateName':
        return !1
      case 'ClassMethod':
      case 'ClassPrivateMethod':
      case 'ObjectMethod':
        return e.key === t ? !!e.computed : !1
      case 'ObjectProperty':
        return e.key === t ? !!e.computed : !r || r.type !== 'ObjectPattern'
      case 'ClassProperty':
      case 'ClassAccessorProperty':
        return e.key === t ? !!e.computed : !0
      case 'ClassPrivateProperty':
        return e.key !== t
      case 'ClassDeclaration':
      case 'ClassExpression':
        return e.superClass === t
      case 'AssignmentExpression':
        return e.right === t
      case 'AssignmentPattern':
        return e.right === t
      case 'LabeledStatement':
        return !1
      case 'CatchClause':
        return !1
      case 'RestElement':
        return !1
      case 'BreakStatement':
      case 'ContinueStatement':
        return !1
      case 'FunctionDeclaration':
      case 'FunctionExpression':
        return !1
      case 'ExportNamespaceSpecifier':
      case 'ExportDefaultSpecifier':
        return !1
      case 'ExportSpecifier':
        return r != null && r.source ? !1 : e.local === t
      case 'ImportDefaultSpecifier':
      case 'ImportNamespaceSpecifier':
      case 'ImportSpecifier':
        return !1
      case 'ImportAttribute':
        return !1
      case 'JSXAttribute':
        return !1
      case 'ObjectPattern':
      case 'ArrayPattern':
        return !1
      case 'MetaProperty':
        return !1
      case 'ObjectTypeProperty':
        return e.key !== t
      case 'TSEnumMember':
        return e.id !== t
      case 'TSPropertySignature':
        return e.key === t ? !!e.computed : !0
    }
    return !0
  }
  var qu = {}
  Object.defineProperty(qu, '__esModule', { value: !0 }), (qu.default = QF)
  var Hi = $
  function QF(t, e) {
    return (0, Hi.isBlockStatement)(t) && ((0, Hi.isFunction)(e) || (0, Hi.isCatchClause)(e))
      ? !1
      : (0, Hi.isPattern)(t) && ((0, Hi.isFunction)(e) || (0, Hi.isCatchClause)(e))
      ? !0
      : (0, Hi.isScopable)(t)
  }
  var Xu = {}
  Object.defineProperty(Xu, '__esModule', { value: !0 }), (Xu.default = e5)
  var sm = $
  function e5(t) {
    return (0, sm.isImportDefaultSpecifier)(t) || (0, sm.isIdentifier)(t.imported || t.exported, { name: 'default' })
  }
  var Gu = {}
  Object.defineProperty(Gu, '__esModule', { value: !0 }), (Gu.default = i5)
  var t5 = Ui
  const r5 = new Set([
    'abstract',
    'boolean',
    'byte',
    'char',
    'double',
    'enum',
    'final',
    'float',
    'goto',
    'implements',
    'int',
    'interface',
    'long',
    'native',
    'package',
    'private',
    'protected',
    'public',
    'short',
    'static',
    'synchronized',
    'throws',
    'transient',
    'volatile',
  ])
  function i5(t) {
    return (0, t5.default)(t) && !r5.has(t)
  }
  var Ju = {}
  Object.defineProperty(Ju, '__esModule', { value: !0 }), (Ju.default = a5)
  var n5 = $,
    s5 = Je
  function a5(t) {
    return (0, n5.isVariableDeclaration)(t, { kind: 'var' }) && !t[s5.BLOCK_SCOPED_SYMBOL]
  }
  var o5 = Object.freeze(Object.defineProperty({ __proto__: null }, Symbol.toStringTag, { value: 'Module' })),
    l5 = PS(o5)
  ;(function (t) {
    Object.defineProperty(t, '__esModule', { value: !0 })
    var e = {
      react: !0,
      assertNode: !0,
      createTypeAnnotationBasedOnTypeof: !0,
      createUnionTypeAnnotation: !0,
      createFlowUnionType: !0,
      createTSUnionType: !0,
      cloneNode: !0,
      clone: !0,
      cloneDeep: !0,
      cloneDeepWithoutLoc: !0,
      cloneWithoutLoc: !0,
      addComment: !0,
      addComments: !0,
      inheritInnerComments: !0,
      inheritLeadingComments: !0,
      inheritsComments: !0,
      inheritTrailingComments: !0,
      removeComments: !0,
      ensureBlock: !0,
      toBindingIdentifierName: !0,
      toBlock: !0,
      toComputedKey: !0,
      toExpression: !0,
      toIdentifier: !0,
      toKeyAlias: !0,
      toSequenceExpression: !0,
      toStatement: !0,
      valueToNode: !0,
      appendToMemberExpression: !0,
      inherits: !0,
      prependToMemberExpression: !0,
      removeProperties: !0,
      removePropertiesDeep: !0,
      removeTypeDuplicates: !0,
      getBindingIdentifiers: !0,
      getOuterBindingIdentifiers: !0,
      traverse: !0,
      traverseFast: !0,
      shallowEqual: !0,
      is: !0,
      isBinding: !0,
      isBlockScoped: !0,
      isImmutable: !0,
      isLet: !0,
      isNode: !0,
      isNodesEquivalent: !0,
      isPlaceholderType: !0,
      isReferenced: !0,
      isScope: !0,
      isSpecifierDefault: !0,
      isType: !0,
      isValidES3Identifier: !0,
      isValidIdentifier: !0,
      isVar: !0,
      matchesPattern: !0,
      validate: !0,
      buildMatchMemberExpression: !0,
    }
    Object.defineProperty(t, 'addComment', {
      enumerable: !0,
      get: function () {
        return m.default
      },
    }),
      Object.defineProperty(t, 'addComments', {
        enumerable: !0,
        get: function () {
          return S.default
        },
      }),
      Object.defineProperty(t, 'appendToMemberExpression', {
        enumerable: !0,
        get: function () {
          return U.default
        },
      }),
      Object.defineProperty(t, 'assertNode', {
        enumerable: !0,
        get: function () {
          return s.default
        },
      }),
      Object.defineProperty(t, 'buildMatchMemberExpression', {
        enumerable: !0,
        get: function () {
          return v.default
        },
      }),
      Object.defineProperty(t, 'clone', {
        enumerable: !0,
        get: function () {
          return d.default
        },
      }),
      Object.defineProperty(t, 'cloneDeep', {
        enumerable: !0,
        get: function () {
          return T.default
        },
      }),
      Object.defineProperty(t, 'cloneDeepWithoutLoc', {
        enumerable: !0,
        get: function () {
          return y.default
        },
      }),
      Object.defineProperty(t, 'cloneNode', {
        enumerable: !0,
        get: function () {
          return f.default
        },
      }),
      Object.defineProperty(t, 'cloneWithoutLoc', {
        enumerable: !0,
        get: function () {
          return b.default
        },
      }),
      Object.defineProperty(t, 'createFlowUnionType', {
        enumerable: !0,
        get: function () {
          return u.default
        },
      }),
      Object.defineProperty(t, 'createTSUnionType', {
        enumerable: !0,
        get: function () {
          return c.default
        },
      }),
      Object.defineProperty(t, 'createTypeAnnotationBasedOnTypeof', {
        enumerable: !0,
        get: function () {
          return o.default
        },
      }),
      Object.defineProperty(t, 'createUnionTypeAnnotation', {
        enumerable: !0,
        get: function () {
          return u.default
        },
      }),
      Object.defineProperty(t, 'ensureBlock', {
        enumerable: !0,
        get: function () {
          return K.default
        },
      }),
      Object.defineProperty(t, 'getBindingIdentifiers', {
        enumerable: !0,
        get: function () {
          return ae.default
        },
      }),
      Object.defineProperty(t, 'getOuterBindingIdentifiers', {
        enumerable: !0,
        get: function () {
          return de.default
        },
      }),
      Object.defineProperty(t, 'inheritInnerComments', {
        enumerable: !0,
        get: function () {
          return E.default
        },
      }),
      Object.defineProperty(t, 'inheritLeadingComments', {
        enumerable: !0,
        get: function () {
          return P.default
        },
      }),
      Object.defineProperty(t, 'inheritTrailingComments', {
        enumerable: !0,
        get: function () {
          return D.default
        },
      }),
      Object.defineProperty(t, 'inherits', {
        enumerable: !0,
        get: function () {
          return W.default
        },
      }),
      Object.defineProperty(t, 'inheritsComments', {
        enumerable: !0,
        get: function () {
          return x.default
        },
      }),
      Object.defineProperty(t, 'is', {
        enumerable: !0,
        get: function () {
          return Le.default
        },
      }),
      Object.defineProperty(t, 'isBinding', {
        enumerable: !0,
        get: function () {
          return We.default
        },
      }),
      Object.defineProperty(t, 'isBlockScoped', {
        enumerable: !0,
        get: function () {
          return A.default
        },
      }),
      Object.defineProperty(t, 'isImmutable', {
        enumerable: !0,
        get: function () {
          return pe.default
        },
      }),
      Object.defineProperty(t, 'isLet', {
        enumerable: !0,
        get: function () {
          return ie.default
        },
      }),
      Object.defineProperty(t, 'isNode', {
        enumerable: !0,
        get: function () {
          return L.default
        },
      }),
      Object.defineProperty(t, 'isNodesEquivalent', {
        enumerable: !0,
        get: function () {
          return F.default
        },
      }),
      Object.defineProperty(t, 'isPlaceholderType', {
        enumerable: !0,
        get: function () {
          return q.default
        },
      }),
      Object.defineProperty(t, 'isReferenced', {
        enumerable: !0,
        get: function () {
          return le.default
        },
      }),
      Object.defineProperty(t, 'isScope', {
        enumerable: !0,
        get: function () {
          return fe.default
        },
      }),
      Object.defineProperty(t, 'isSpecifierDefault', {
        enumerable: !0,
        get: function () {
          return ne.default
        },
      }),
      Object.defineProperty(t, 'isType', {
        enumerable: !0,
        get: function () {
          return Se.default
        },
      }),
      Object.defineProperty(t, 'isValidES3Identifier', {
        enumerable: !0,
        get: function () {
          return xe.default
        },
      }),
      Object.defineProperty(t, 'isValidIdentifier', {
        enumerable: !0,
        get: function () {
          return Ae.default
        },
      }),
      Object.defineProperty(t, 'isVar', {
        enumerable: !0,
        get: function () {
          return Re.default
        },
      }),
      Object.defineProperty(t, 'matchesPattern', {
        enumerable: !0,
        get: function () {
          return O.default
        },
      }),
      Object.defineProperty(t, 'prependToMemberExpression', {
        enumerable: !0,
        get: function () {
          return ge.default
        },
      }),
      (t.react = void 0),
      Object.defineProperty(t, 'removeComments', {
        enumerable: !0,
        get: function () {
          return N.default
        },
      }),
      Object.defineProperty(t, 'removeProperties', {
        enumerable: !0,
        get: function () {
          return ye.default
        },
      }),
      Object.defineProperty(t, 'removePropertiesDeep', {
        enumerable: !0,
        get: function () {
          return me.default
        },
      }),
      Object.defineProperty(t, 'removeTypeDuplicates', {
        enumerable: !0,
        get: function () {
          return ke.default
        },
      }),
      Object.defineProperty(t, 'shallowEqual', {
        enumerable: !0,
        get: function () {
          return De.default
        },
      }),
      Object.defineProperty(t, 'toBindingIdentifierName', {
        enumerable: !0,
        get: function () {
          return Y.default
        },
      }),
      Object.defineProperty(t, 'toBlock', {
        enumerable: !0,
        get: function () {
          return C.default
        },
      }),
      Object.defineProperty(t, 'toComputedKey', {
        enumerable: !0,
        get: function () {
          return H.default
        },
      }),
      Object.defineProperty(t, 'toExpression', {
        enumerable: !0,
        get: function () {
          return w.default
        },
      }),
      Object.defineProperty(t, 'toIdentifier', {
        enumerable: !0,
        get: function () {
          return J.default
        },
      }),
      Object.defineProperty(t, 'toKeyAlias', {
        enumerable: !0,
        get: function () {
          return X.default
        },
      }),
      Object.defineProperty(t, 'toSequenceExpression', {
        enumerable: !0,
        get: function () {
          return G.default
        },
      }),
      Object.defineProperty(t, 'toStatement', {
        enumerable: !0,
        get: function () {
          return Te.default
        },
      }),
      Object.defineProperty(t, 'traverse', {
        enumerable: !0,
        get: function () {
          return be.default
        },
      }),
      Object.defineProperty(t, 'traverseFast', {
        enumerable: !0,
        get: function () {
          return Pe.default
        },
      }),
      Object.defineProperty(t, 'validate', {
        enumerable: !0,
        get: function () {
          return g.default
        },
      }),
      Object.defineProperty(t, 'valueToNode', {
        enumerable: !0,
        get: function () {
          return ce.default
        },
      })
    var r = ma,
      i = Zl,
      n = Ql,
      s = mu,
      a = j
    Object.keys(a).forEach(function (Z) {
      Z === 'default' ||
        Z === '__esModule' ||
        Object.prototype.hasOwnProperty.call(e, Z) ||
        (Z in t && t[Z] === a[Z]) ||
        Object.defineProperty(t, Z, {
          enumerable: !0,
          get: function () {
            return a[Z]
          },
        })
    })
    var o = ka,
      u = yu,
      c = gu,
      p = M
    Object.keys(p).forEach(function (Z) {
      Z === 'default' ||
        Z === '__esModule' ||
        Object.prototype.hasOwnProperty.call(e, Z) ||
        (Z in t && t[Z] === p[Z]) ||
        Object.defineProperty(t, Z, {
          enumerable: !0,
          get: function () {
            return p[Z]
          },
        })
    })
    var h = qd
    Object.keys(h).forEach(function (Z) {
      Z === 'default' ||
        Z === '__esModule' ||
        Object.prototype.hasOwnProperty.call(e, Z) ||
        (Z in t && t[Z] === h[Z]) ||
        Object.defineProperty(t, Z, {
          enumerable: !0,
          get: function () {
            return h[Z]
          },
        })
    })
    var f = Vr,
      d = Su,
      T = vu,
      y = Eu,
      b = Pu,
      m = wu,
      S = Da,
      E = Ba,
      P = La,
      x = Ma,
      D = Fa,
      N = Au,
      I = Ce
    Object.keys(I).forEach(function (Z) {
      Z === 'default' ||
        Z === '__esModule' ||
        Object.prototype.hasOwnProperty.call(e, Z) ||
        (Z in t && t[Z] === I[Z]) ||
        Object.defineProperty(t, Z, {
          enumerable: !0,
          get: function () {
            return I[Z]
          },
        })
    })
    var B = Je
    Object.keys(B).forEach(function (Z) {
      Z === 'default' ||
        Z === '__esModule' ||
        Object.prototype.hasOwnProperty.call(e, Z) ||
        (Z in t && t[Z] === B[Z]) ||
        Object.defineProperty(t, Z, {
          enumerable: !0,
          get: function () {
            return B[Z]
          },
        })
    })
    var K = Cu,
      Y = Iu,
      C = $a,
      H = ku,
      w = _a,
      J = ja,
      X = Nu,
      G = Du,
      Te = Wa,
      ce = Ha,
      se = fr
    Object.keys(se).forEach(function (Z) {
      Z === 'default' ||
        Z === '__esModule' ||
        Object.prototype.hasOwnProperty.call(e, Z) ||
        (Z in t && t[Z] === se[Z]) ||
        Object.defineProperty(t, Z, {
          enumerable: !0,
          get: function () {
            return se[Z]
          },
        })
    })
    var U = $u,
      W = Ru,
      ge = ju,
      ye = za,
      me = Va,
      ke = Na,
      ae = vn,
      de = qa,
      be = _u
    Object.keys(be).forEach(function (Z) {
      Z === 'default' ||
        Z === '__esModule' ||
        Object.prototype.hasOwnProperty.call(e, Z) ||
        (Z in t && t[Z] === be[Z]) ||
        Object.defineProperty(t, Z, {
          enumerable: !0,
          get: function () {
            return be[Z]
          },
        })
    })
    var Pe = Ua,
      De = as,
      Le = Vi,
      We = Uu,
      A = zu,
      pe = Ku,
      ie = Xa,
      L = Ia,
      F = Wu,
      q = Ta,
      le = Hu,
      fe = qu,
      ne = Xu,
      Se = cs,
      xe = Gu,
      Ae = Ui,
      Re = Ju,
      O = ga,
      g = _i,
      v = ya,
      z = $
    Object.keys(z).forEach(function (Z) {
      Z === 'default' ||
        Z === '__esModule' ||
        Object.prototype.hasOwnProperty.call(e, Z) ||
        (Z in t && t[Z] === z[Z]) ||
        Object.defineProperty(t, Z, {
          enumerable: !0,
          get: function () {
            return z[Z]
          },
        })
    })
    var ee = l5
    Object.keys(ee).forEach(function (Z) {
      Z === 'default' ||
        Z === '__esModule' ||
        Object.prototype.hasOwnProperty.call(e, Z) ||
        (Z in t && t[Z] === ee[Z]) ||
        Object.defineProperty(t, Z, {
          enumerable: !0,
          get: function () {
            return ee[Z]
          },
        })
    })
    const ue = { isReactComponent: r.default, isCompatTag: i.default, buildChildren: n.default }
    t.react = ue
  })(st),
    Object.defineProperty(rt, '__esModule', { value: !0 }),
    (rt.Var =
      rt.User =
      rt.Statement =
      rt.SpreadProperty =
      rt.Scope =
      rt.RestProperty =
      rt.ReferencedMemberExpression =
      rt.ReferencedIdentifier =
      rt.Referenced =
      rt.Pure =
      rt.NumericLiteralTypeAnnotation =
      rt.Generated =
      rt.ForAwaitStatement =
      rt.Flow =
      rt.Expression =
      rt.ExistentialTypeParam =
      rt.BlockScoped =
      rt.BindingIdentifier =
        void 0)
  var u5 = st
  const {
      isBinding: c5,
      isBlockScoped: p5,
      isExportDeclaration: f5,
      isExpression: h5,
      isFlow: d5,
      isForStatement: m5,
      isForXStatement: y5,
      isIdentifier: am,
      isImportDeclaration: g5,
      isImportSpecifier: T5,
      isJSXIdentifier: b5,
      isJSXMemberExpression: S5,
      isMemberExpression: v5,
      isReferenced: Zu,
      isScope: E5,
      isStatement: P5,
      isVar: w5,
      isVariableDeclaration: A5,
      react: C5,
    } = u5,
    { isCompatTag: x5 } = C5,
    I5 = {
      types: ['Identifier', 'JSXIdentifier'],
      checkPath(t, e) {
        const { node: r, parent: i } = t
        if (!am(r, e) && !S5(i, e))
          if (b5(r, e)) {
            if (x5(r.name)) return !1
          } else return !1
        return Zu(r, i, t.parentPath.parent)
      },
    }
  rt.ReferencedIdentifier = I5
  const k5 = {
    types: ['MemberExpression'],
    checkPath({ node: t, parent: e }) {
      return v5(t) && Zu(t, e)
    },
  }
  rt.ReferencedMemberExpression = k5
  const N5 = {
    types: ['Identifier'],
    checkPath(t) {
      const { node: e, parent: r } = t,
        i = t.parentPath.parent
      return am(e) && c5(e, r, i)
    },
  }
  rt.BindingIdentifier = N5
  const O5 = {
    types: ['Statement'],
    checkPath({ node: t, parent: e }) {
      return P5(t) ? !(A5(t) && (y5(e, { left: t }) || m5(e, { init: t }))) : !1
    },
  }
  rt.Statement = O5
  const D5 = {
    types: ['Expression'],
    checkPath(t) {
      return t.isIdentifier() ? t.isReferencedIdentifier() : h5(t.node)
    },
  }
  rt.Expression = D5
  const B5 = {
    types: ['Scopable', 'Pattern'],
    checkPath(t) {
      return E5(t.node, t.parent)
    },
  }
  rt.Scope = B5
  const L5 = {
    checkPath(t) {
      return Zu(t.node, t.parent)
    },
  }
  rt.Referenced = L5
  const M5 = {
    checkPath(t) {
      return p5(t.node)
    },
  }
  rt.BlockScoped = M5
  const F5 = {
    types: ['VariableDeclaration'],
    checkPath(t) {
      return w5(t.node)
    },
  }
  rt.Var = F5
  const $5 = {
    checkPath(t) {
      return t.node && !!t.node.loc
    },
  }
  rt.User = $5
  const R5 = {
    checkPath(t) {
      return !t.isUser()
    },
  }
  rt.Generated = R5
  const j5 = {
    checkPath(t, e) {
      return t.scope.isPure(t.node, e)
    },
  }
  rt.Pure = j5
  const _5 = {
    types: ['Flow', 'ImportDeclaration', 'ExportDeclaration', 'ImportSpecifier'],
    checkPath({ node: t }) {
      return d5(t)
        ? !0
        : g5(t)
        ? t.importKind === 'type' || t.importKind === 'typeof'
        : f5(t)
        ? t.exportKind === 'type'
        : T5(t)
        ? t.importKind === 'type' || t.importKind === 'typeof'
        : !1
    },
  }
  rt.Flow = _5
  const V5 = {
    types: ['RestElement'],
    checkPath(t) {
      return t.parentPath && t.parentPath.isObjectPattern()
    },
  }
  rt.RestProperty = V5
  const U5 = {
    types: ['RestElement'],
    checkPath(t) {
      return t.parentPath && t.parentPath.isObjectExpression()
    },
  }
  rt.SpreadProperty = U5
  const z5 = { types: ['ExistsTypeAnnotation'] }
  rt.ExistentialTypeParam = z5
  const K5 = { types: ['NumberLiteralTypeAnnotation'] }
  rt.NumericLiteralTypeAnnotation = K5
  const W5 = {
    types: ['ForOfStatement'],
    checkPath({ node: t }) {
      return t.await === !0
    },
  }
  ;(rt.ForAwaitStatement = W5),
    Object.defineProperty(Tn, '__esModule', { value: !0 }),
    (Tn.explode = om),
    (Tn.merge = J5),
    (Tn.verify = lm)
  var Y5 = rt,
    H5 = st
  const { DEPRECATED_KEYS: q5, FLIPPED_ALIAS_KEYS: X5, TYPES: G5 } = H5
  function om(t) {
    if (t._exploded) return t
    t._exploded = !0
    for (const e of Object.keys(t)) {
      if (Pn(e)) continue
      const r = e.split('|')
      if (r.length === 1) continue
      const i = t[e]
      delete t[e]
      for (const n of r) t[n] = i
    }
    lm(t), delete t.__esModule, Q5(t), cm(t)
    for (const e of Object.keys(t)) {
      if (Pn(e)) continue
      const r = Y5[e]
      if (!r) continue
      const i = t[e]
      for (const n of Object.keys(i)) i[n] = e8(r, i[n])
      if ((delete t[e], r.types)) for (const n of r.types) t[n] ? Ga(t[n], i) : (t[n] = i)
      else Ga(t, i)
    }
    for (const e of Object.keys(t)) {
      if (Pn(e)) continue
      const r = t[e]
      let i = X5[e]
      const n = q5[e]
      if ((n && (console.trace(`Visitor defined for ${e} but it has been renamed to ${n}`), (i = [n])), !!i)) {
        delete t[e]
        for (const s of i) {
          const a = t[s]
          a ? Ga(a, r) : (t[s] = Object.assign({}, r))
        }
      }
    }
    for (const e of Object.keys(t)) Pn(e) || cm(t[e])
    return t
  }
  function lm(t) {
    if (!t._verified) {
      if (typeof t == 'function')
        throw new Error(
          "You passed `traverse()` a function when it expected a visitor object, are you sure you didn't mean `{ enter: Function }`?"
        )
      for (const e of Object.keys(t)) {
        if (((e === 'enter' || e === 'exit') && um(e, t[e]), Pn(e))) continue
        if (G5.indexOf(e) < 0) throw new Error(`You gave us a visitor for the node type ${e} but it's not a valid type`)
        const r = t[e]
        if (typeof r == 'object')
          for (const i of Object.keys(r))
            if (i === 'enter' || i === 'exit') um(`${e}.${i}`, r[i])
            else
              throw new Error(
                `You passed \`traverse()\` a visitor object with the property ${e} that has the invalid property ${i}`
              )
      }
      t._verified = !0
    }
  }
  function um(t, e) {
    const r = [].concat(e)
    for (const i of r)
      if (typeof i != 'function') throw new TypeError(`Non-function found defined in ${t} with type ${typeof i}`)
  }
  function J5(t, e = [], r) {
    const i = {}
    for (let n = 0; n < t.length; n++) {
      const s = t[n],
        a = e[n]
      om(s)
      for (const o of Object.keys(s)) {
        let u = s[o]
        ;(a || r) && (u = Z5(u, a, r))
        const c = (i[o] = i[o] || {})
        Ga(c, u)
      }
    }
    return i
  }
  function Z5(t, e, r) {
    const i = {}
    for (const n of Object.keys(t)) {
      let s = t[n]
      !Array.isArray(s) ||
        ((s = s.map(function (a) {
          let o = a
          return (
            e &&
              (o = function (u) {
                return a.call(e, u, e)
              }),
            r && (o = r(e.key, n, o)),
            o !== a && (o.toString = () => a.toString()),
            o
          )
        })),
        (i[n] = s))
    }
    return i
  }
  function Q5(t) {
    for (const e of Object.keys(t)) {
      if (Pn(e)) continue
      const r = t[e]
      typeof r == 'function' && (t[e] = { enter: r })
    }
  }
  function cm(t) {
    t.enter && !Array.isArray(t.enter) && (t.enter = [t.enter]), t.exit && !Array.isArray(t.exit) && (t.exit = [t.exit])
  }
  function e8(t, e) {
    const r = function (i) {
      if (t.checkPath(i)) return e.apply(this, arguments)
    }
    return (r.toString = () => e.toString()), r
  }
  function Pn(t) {
    return (
      t[0] === '_' ||
      t === 'enter' ||
      t === 'exit' ||
      t === 'shouldSkip' ||
      t === 'denylist' ||
      t === 'noScope' ||
      t === 'skipKeys' ||
      t === 'blacklist'
    )
  }
  function Ga(t, e) {
    for (const r of Object.keys(e)) t[r] = [].concat(t[r] || [], e[r])
  }
  var Vt = {}
  Object.defineProperty(Vt, '__esModule', { value: !0 }),
    (Vt.clear = t8),
    (Vt.clearPath = hm),
    (Vt.clearScope = dm),
    (Vt.scope = Vt.path = void 0)
  let pm = new WeakMap()
  Vt.path = pm
  let fm = new WeakMap()
  Vt.scope = fm
  function t8() {
    hm(), dm()
  }
  function hm() {
    Vt.path = pm = new WeakMap()
  }
  function dm() {
    Vt.scope = fm = new WeakMap()
  }
  var Ja = {},
    Za = {},
    Ut = {},
    Qu = { exports: {} },
    wn = 1e3,
    An = wn * 60,
    Cn = An * 60,
    qi = Cn * 24,
    r8 = qi * 7,
    i8 = qi * 365.25,
    n8 = function (t, e) {
      e = e || {}
      var r = typeof t
      if (r === 'string' && t.length > 0) return s8(t)
      if (r === 'number' && isFinite(t)) return e.long ? o8(t) : a8(t)
      throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(t))
    }
  function s8(t) {
    if (((t = String(t)), !(t.length > 100))) {
      var e =
        /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
          t
        )
      if (!!e) {
        var r = parseFloat(e[1]),
          i = (e[2] || 'ms').toLowerCase()
        switch (i) {
          case 'years':
          case 'year':
          case 'yrs':
          case 'yr':
          case 'y':
            return r * i8
          case 'weeks':
          case 'week':
          case 'w':
            return r * r8
          case 'days':
          case 'day':
          case 'd':
            return r * qi
          case 'hours':
          case 'hour':
          case 'hrs':
          case 'hr':
          case 'h':
            return r * Cn
          case 'minutes':
          case 'minute':
          case 'mins':
          case 'min':
          case 'm':
            return r * An
          case 'seconds':
          case 'second':
          case 'secs':
          case 'sec':
          case 's':
            return r * wn
          case 'milliseconds':
          case 'millisecond':
          case 'msecs':
          case 'msec':
          case 'ms':
            return r
          default:
            return
        }
      }
    }
  }
  function a8(t) {
    var e = Math.abs(t)
    return e >= qi
      ? Math.round(t / qi) + 'd'
      : e >= Cn
      ? Math.round(t / Cn) + 'h'
      : e >= An
      ? Math.round(t / An) + 'm'
      : e >= wn
      ? Math.round(t / wn) + 's'
      : t + 'ms'
  }
  function o8(t) {
    var e = Math.abs(t)
    return e >= qi
      ? Qa(t, e, qi, 'day')
      : e >= Cn
      ? Qa(t, e, Cn, 'hour')
      : e >= An
      ? Qa(t, e, An, 'minute')
      : e >= wn
      ? Qa(t, e, wn, 'second')
      : t + ' ms'
  }
  function Qa(t, e, r, i) {
    var n = e >= r * 1.5
    return Math.round(t / r) + ' ' + i + (n ? 's' : '')
  }
  function l8(t) {
    ;(r.debug = r),
      (r.default = r),
      (r.coerce = u),
      (r.disable = s),
      (r.enable = n),
      (r.enabled = a),
      (r.humanize = n8),
      (r.destroy = c),
      Object.keys(t).forEach((p) => {
        r[p] = t[p]
      }),
      (r.names = []),
      (r.skips = []),
      (r.formatters = {})
    function e(p) {
      let h = 0
      for (let f = 0; f < p.length; f++) (h = (h << 5) - h + p.charCodeAt(f)), (h |= 0)
      return r.colors[Math.abs(h) % r.colors.length]
    }
    r.selectColor = e
    function r(p) {
      let h,
        f = null,
        d,
        T
      function y(...b) {
        if (!y.enabled) return
        const m = y,
          S = Number(new Date()),
          E = S - (h || S)
        ;(m.diff = E),
          (m.prev = h),
          (m.curr = S),
          (h = S),
          (b[0] = r.coerce(b[0])),
          typeof b[0] != 'string' && b.unshift('%O')
        let P = 0
        ;(b[0] = b[0].replace(/%([a-zA-Z%])/g, (D, N) => {
          if (D === '%%') return '%'
          P++
          const I = r.formatters[N]
          if (typeof I == 'function') {
            const B = b[P]
            ;(D = I.call(m, B)), b.splice(P, 1), P--
          }
          return D
        })),
          r.formatArgs.call(m, b),
          (m.log || r.log).apply(m, b)
      }
      return (
        (y.namespace = p),
        (y.useColors = r.useColors()),
        (y.color = r.selectColor(p)),
        (y.extend = i),
        (y.destroy = r.destroy),
        Object.defineProperty(y, 'enabled', {
          enumerable: !0,
          configurable: !1,
          get: () => (f !== null ? f : (d !== r.namespaces && ((d = r.namespaces), (T = r.enabled(p))), T)),
          set: (b) => {
            f = b
          },
        }),
        typeof r.init == 'function' && r.init(y),
        y
      )
    }
    function i(p, h) {
      const f = r(this.namespace + (typeof h == 'undefined' ? ':' : h) + p)
      return (f.log = this.log), f
    }
    function n(p) {
      r.save(p), (r.namespaces = p), (r.names = []), (r.skips = [])
      let h
      const f = (typeof p == 'string' ? p : '').split(/[\s,]+/),
        d = f.length
      for (h = 0; h < d; h++)
        !f[h] ||
          ((p = f[h].replace(/\*/g, '.*?')),
          p[0] === '-' ? r.skips.push(new RegExp('^' + p.slice(1) + '$')) : r.names.push(new RegExp('^' + p + '$')))
    }
    function s() {
      const p = [...r.names.map(o), ...r.skips.map(o).map((h) => '-' + h)].join(',')
      return r.enable(''), p
    }
    function a(p) {
      if (p[p.length - 1] === '*') return !0
      let h, f
      for (h = 0, f = r.skips.length; h < f; h++) if (r.skips[h].test(p)) return !1
      for (h = 0, f = r.names.length; h < f; h++) if (r.names[h].test(p)) return !0
      return !1
    }
    function o(p) {
      return p
        .toString()
        .substring(2, p.toString().length - 2)
        .replace(/\.\*\?$/, '*')
    }
    function u(p) {
      return p instanceof Error ? p.stack || p.message : p
    }
    function c() {
      console.warn(
        'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'
      )
    }
    return r.enable(r.load()), r
  }
  var u8 = l8
  ;(function (t, e) {
    ;(e.formatArgs = i),
      (e.save = n),
      (e.load = s),
      (e.useColors = r),
      (e.storage = a()),
      (e.destroy = (() => {
        let u = !1
        return () => {
          u ||
            ((u = !0),
            console.warn(
              'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'
            ))
        }
      })()),
      (e.colors = [
        '#0000CC',
        '#0000FF',
        '#0033CC',
        '#0033FF',
        '#0066CC',
        '#0066FF',
        '#0099CC',
        '#0099FF',
        '#00CC00',
        '#00CC33',
        '#00CC66',
        '#00CC99',
        '#00CCCC',
        '#00CCFF',
        '#3300CC',
        '#3300FF',
        '#3333CC',
        '#3333FF',
        '#3366CC',
        '#3366FF',
        '#3399CC',
        '#3399FF',
        '#33CC00',
        '#33CC33',
        '#33CC66',
        '#33CC99',
        '#33CCCC',
        '#33CCFF',
        '#6600CC',
        '#6600FF',
        '#6633CC',
        '#6633FF',
        '#66CC00',
        '#66CC33',
        '#9900CC',
        '#9900FF',
        '#9933CC',
        '#9933FF',
        '#99CC00',
        '#99CC33',
        '#CC0000',
        '#CC0033',
        '#CC0066',
        '#CC0099',
        '#CC00CC',
        '#CC00FF',
        '#CC3300',
        '#CC3333',
        '#CC3366',
        '#CC3399',
        '#CC33CC',
        '#CC33FF',
        '#CC6600',
        '#CC6633',
        '#CC9900',
        '#CC9933',
        '#CCCC00',
        '#CCCC33',
        '#FF0000',
        '#FF0033',
        '#FF0066',
        '#FF0099',
        '#FF00CC',
        '#FF00FF',
        '#FF3300',
        '#FF3333',
        '#FF3366',
        '#FF3399',
        '#FF33CC',
        '#FF33FF',
        '#FF6600',
        '#FF6633',
        '#FF9900',
        '#FF9933',
        '#FFCC00',
        '#FFCC33',
      ])
    function r() {
      return typeof window != 'undefined' &&
        window.process &&
        (window.process.type === 'renderer' || window.process.__nwjs)
        ? !0
        : typeof navigator != 'undefined' &&
          navigator.userAgent &&
          navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)
        ? !1
        : (typeof document != 'undefined' &&
            document.documentElement &&
            document.documentElement.style &&
            document.documentElement.style.WebkitAppearance) ||
          (typeof window != 'undefined' &&
            window.console &&
            (window.console.firebug || (window.console.exception && window.console.table))) ||
          (typeof navigator != 'undefined' &&
            navigator.userAgent &&
            navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) &&
            parseInt(RegExp.$1, 10) >= 31) ||
          (typeof navigator != 'undefined' &&
            navigator.userAgent &&
            navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/))
    }
    function i(u) {
      if (
        ((u[0] =
          (this.useColors ? '%c' : '') +
          this.namespace +
          (this.useColors ? ' %c' : ' ') +
          u[0] +
          (this.useColors ? '%c ' : ' ') +
          '+' +
          t.exports.humanize(this.diff)),
        !this.useColors)
      )
        return
      const c = 'color: ' + this.color
      u.splice(1, 0, c, 'color: inherit')
      let p = 0,
        h = 0
      u[0].replace(/%[a-zA-Z%]/g, (f) => {
        f !== '%%' && (p++, f === '%c' && (h = p))
      }),
        u.splice(h, 0, c)
    }
    e.log = console.debug || console.log || (() => {})
    function n(u) {
      try {
        u ? e.storage.setItem('debug', u) : e.storage.removeItem('debug')
      } catch {}
    }
    function s() {
      let u
      try {
        u = e.storage.getItem('debug')
      } catch {}
      return !u && typeof process != 'undefined' && 'env' in process && (u = {}.DEBUG), u
    }
    function a() {
      try {
        return localStorage
      } catch {}
    }
    t.exports = u8(e)
    const { formatters: o } = t.exports
    o.j = function (u) {
      try {
        return JSON.stringify(u)
      } catch (c) {
        return '[UnexpectedJSONParseError]: ' + c.message
      }
    }
  })(Qu, Qu.exports)
  var gs = {},
    eo = {},
    to = {}
  Object.defineProperty(to, '__esModule', { value: !0 }), (to.default = void 0)
  class c8 {
    constructor({ identifier: e, scope: r, path: i, kind: n }) {
      ;(this.identifier = void 0),
        (this.scope = void 0),
        (this.path = void 0),
        (this.kind = void 0),
        (this.constantViolations = []),
        (this.constant = !0),
        (this.referencePaths = []),
        (this.referenced = !1),
        (this.references = 0),
        (this.identifier = e),
        (this.scope = r),
        (this.path = i),
        (this.kind = n),
        this.clearValue()
    }
    deoptValue() {
      this.clearValue(), (this.hasDeoptedValue = !0)
    }
    setValue(e) {
      this.hasDeoptedValue || ((this.hasValue = !0), (this.value = e))
    }
    clearValue() {
      ;(this.hasDeoptedValue = !1), (this.hasValue = !1), (this.value = null)
    }
    reassign(e) {
      ;(this.constant = !1), this.constantViolations.indexOf(e) === -1 && this.constantViolations.push(e)
    }
    reference(e) {
      this.referencePaths.indexOf(e) === -1 && ((this.referenced = !0), this.references++, this.referencePaths.push(e))
    }
    dereference() {
      this.references--, (this.referenced = !!this.references)
    }
  }
  to.default = c8
  var ec = {}
  Object.defineProperty(ec, '__esModule', { value: !0 }), (ec.default = d8)
  var p8 = st
  const {
    cloneNode: tc,
    exportNamedDeclaration: mm,
    exportSpecifier: ym,
    identifier: rc,
    variableDeclaration: f8,
    variableDeclarator: h8,
  } = p8
  function d8(t) {
    if (!t.isExportDeclaration()) throw new Error('Only export declarations can be split.')
    const e = t.isExportDefaultDeclaration(),
      r = t.get('declaration'),
      i = r.isClassDeclaration()
    if (e) {
      const o = r.isFunctionDeclaration() || i,
        u = r.isScope() ? r.scope.parent : r.scope
      let c = r.node.id,
        p = !1
      c ||
        ((p = !0),
        (c = u.generateUidIdentifier('default')),
        (o || r.isFunctionExpression() || r.isClassExpression()) && (r.node.id = tc(c)))
      const h = o ? r : f8('var', [h8(tc(c), r.node)]),
        f = mm(null, [ym(tc(c), rc('default'))])
      return t.insertAfter(f), t.replaceWith(h), p && u.registerDeclaration(t), t
    }
    if (t.get('specifiers').length > 0) throw new Error("It doesn't make sense to split exported specifiers.")
    const n = r.getOuterBindingIdentifiers(),
      s = Object.keys(n).map((o) => ym(rc(o), rc(o))),
      a = mm(null, s)
    return t.insertAfter(a), t.replaceWith(r.node), t
  }
  var Xi = {}
  Object.defineProperty(Xi, '__esModule', { value: !0 }),
    (Xi.default = void 0),
    (Xi.requeueComputedKeyAndDecorators = ic),
    (Xi.skipAllButComputedKey = m8)
  function m8(t) {
    t.skip(), t.node.computed && t.context.maybeQueue(t.get('key'))
  }
  function ic(t) {
    const { context: e, node: r } = t
    if ((r.computed && e.maybeQueue(t.get('key')), r.decorators)) for (const i of t.get('decorators')) e.maybeQueue(i)
  }
  var y8 = {
    FunctionParent(t) {
      t.isArrowFunctionExpression() || (t.skip(), t.isMethod() && ic(t))
    },
    Property(t) {
      t.isObjectProperty() || (t.skip(), ic(t))
    },
  }
  ;(Xi.default = y8), Object.defineProperty(eo, '__esModule', { value: !0 }), (eo.default = void 0)
  var g8 = ec,
    T8 = Xi
  const gm = {
    ReferencedIdentifier({ node: t }, e) {
      t.name === e.oldName && (t.name = e.newName)
    },
    Scope(t, e) {
      t.scope.bindingIdentifierEquals(e.oldName, e.binding.identifier) ||
        (t.skip(), t.isMethod() && (0, T8.requeueComputedKeyAndDecorators)(t))
    },
    'AssignmentExpression|Declaration|VariableDeclarator'(t, e) {
      if (t.isVariableDeclaration()) return
      const r = t.getOuterBindingIdentifiers()
      for (const i in r) i === e.oldName && (r[i].name = e.newName)
    },
  }
  class b8 {
    constructor(e, r, i) {
      ;(this.newName = i), (this.oldName = r), (this.binding = e)
    }
    maybeConvertFromExportDeclaration(e) {
      const r = e.parentPath
      !r.isExportDeclaration() ||
        (r.isExportDefaultDeclaration() && !r.get('declaration').node.id) ||
        (0, g8.default)(r)
    }
    maybeConvertFromClassFunctionDeclaration(e) {}
    maybeConvertFromClassFunctionExpression(e) {}
    rename(e) {
      const { binding: r, oldName: i, newName: n } = this,
        { scope: s, path: a } = r,
        o = a.find((c) => c.isDeclaration() || c.isFunctionExpression() || c.isClassExpression())
      o && o.getOuterBindingIdentifiers()[i] === r.identifier && this.maybeConvertFromExportDeclaration(o)
      const u = e || s.block
      ;(u == null ? void 0 : u.type) === 'SwitchStatement'
        ? u.cases.forEach((c) => {
            s.traverse(c, gm, this)
          })
        : s.traverse(u, gm, this),
        e || (s.removeOwnBinding(i), (s.bindings[n] = r), (this.binding.identifier.name = n)),
        o && (this.maybeConvertFromClassFunctionDeclaration(o), this.maybeConvertFromClassFunctionExpression(o))
    }
  }
  eo.default = b8
  var S8 = {
      builtin: {
        Array: !1,
        ArrayBuffer: !1,
        Atomics: !1,
        BigInt: !1,
        BigInt64Array: !1,
        BigUint64Array: !1,
        Boolean: !1,
        constructor: !1,
        DataView: !1,
        Date: !1,
        decodeURI: !1,
        decodeURIComponent: !1,
        encodeURI: !1,
        encodeURIComponent: !1,
        Error: !1,
        escape: !1,
        eval: !1,
        EvalError: !1,
        Float32Array: !1,
        Float64Array: !1,
        Function: !1,
        globalThis: !1,
        hasOwnProperty: !1,
        Infinity: !1,
        Int16Array: !1,
        Int32Array: !1,
        Int8Array: !1,
        isFinite: !1,
        isNaN: !1,
        isPrototypeOf: !1,
        JSON: !1,
        Map: !1,
        Math: !1,
        NaN: !1,
        Number: !1,
        Object: !1,
        parseFloat: !1,
        parseInt: !1,
        Promise: !1,
        propertyIsEnumerable: !1,
        Proxy: !1,
        RangeError: !1,
        ReferenceError: !1,
        Reflect: !1,
        RegExp: !1,
        Set: !1,
        SharedArrayBuffer: !1,
        String: !1,
        Symbol: !1,
        SyntaxError: !1,
        toLocaleString: !1,
        toString: !1,
        TypeError: !1,
        Uint16Array: !1,
        Uint32Array: !1,
        Uint8Array: !1,
        Uint8ClampedArray: !1,
        undefined: !1,
        unescape: !1,
        URIError: !1,
        valueOf: !1,
        WeakMap: !1,
        WeakSet: !1,
      },
      es5: {
        Array: !1,
        Boolean: !1,
        constructor: !1,
        Date: !1,
        decodeURI: !1,
        decodeURIComponent: !1,
        encodeURI: !1,
        encodeURIComponent: !1,
        Error: !1,
        escape: !1,
        eval: !1,
        EvalError: !1,
        Function: !1,
        hasOwnProperty: !1,
        Infinity: !1,
        isFinite: !1,
        isNaN: !1,
        isPrototypeOf: !1,
        JSON: !1,
        Math: !1,
        NaN: !1,
        Number: !1,
        Object: !1,
        parseFloat: !1,
        parseInt: !1,
        propertyIsEnumerable: !1,
        RangeError: !1,
        ReferenceError: !1,
        RegExp: !1,
        String: !1,
        SyntaxError: !1,
        toLocaleString: !1,
        toString: !1,
        TypeError: !1,
        undefined: !1,
        unescape: !1,
        URIError: !1,
        valueOf: !1,
      },
      es2015: {
        Array: !1,
        ArrayBuffer: !1,
        Boolean: !1,
        constructor: !1,
        DataView: !1,
        Date: !1,
        decodeURI: !1,
        decodeURIComponent: !1,
        encodeURI: !1,
        encodeURIComponent: !1,
        Error: !1,
        escape: !1,
        eval: !1,
        EvalError: !1,
        Float32Array: !1,
        Float64Array: !1,
        Function: !1,
        hasOwnProperty: !1,
        Infinity: !1,
        Int16Array: !1,
        Int32Array: !1,
        Int8Array: !1,
        isFinite: !1,
        isNaN: !1,
        isPrototypeOf: !1,
        JSON: !1,
        Map: !1,
        Math: !1,
        NaN: !1,
        Number: !1,
        Object: !1,
        parseFloat: !1,
        parseInt: !1,
        Promise: !1,
        propertyIsEnumerable: !1,
        Proxy: !1,
        RangeError: !1,
        ReferenceError: !1,
        Reflect: !1,
        RegExp: !1,
        Set: !1,
        String: !1,
        Symbol: !1,
        SyntaxError: !1,
        toLocaleString: !1,
        toString: !1,
        TypeError: !1,
        Uint16Array: !1,
        Uint32Array: !1,
        Uint8Array: !1,
        Uint8ClampedArray: !1,
        undefined: !1,
        unescape: !1,
        URIError: !1,
        valueOf: !1,
        WeakMap: !1,
        WeakSet: !1,
      },
      es2017: {
        Array: !1,
        ArrayBuffer: !1,
        Atomics: !1,
        Boolean: !1,
        constructor: !1,
        DataView: !1,
        Date: !1,
        decodeURI: !1,
        decodeURIComponent: !1,
        encodeURI: !1,
        encodeURIComponent: !1,
        Error: !1,
        escape: !1,
        eval: !1,
        EvalError: !1,
        Float32Array: !1,
        Float64Array: !1,
        Function: !1,
        hasOwnProperty: !1,
        Infinity: !1,
        Int16Array: !1,
        Int32Array: !1,
        Int8Array: !1,
        isFinite: !1,
        isNaN: !1,
        isPrototypeOf: !1,
        JSON: !1,
        Map: !1,
        Math: !1,
        NaN: !1,
        Number: !1,
        Object: !1,
        parseFloat: !1,
        parseInt: !1,
        Promise: !1,
        propertyIsEnumerable: !1,
        Proxy: !1,
        RangeError: !1,
        ReferenceError: !1,
        Reflect: !1,
        RegExp: !1,
        Set: !1,
        SharedArrayBuffer: !1,
        String: !1,
        Symbol: !1,
        SyntaxError: !1,
        toLocaleString: !1,
        toString: !1,
        TypeError: !1,
        Uint16Array: !1,
        Uint32Array: !1,
        Uint8Array: !1,
        Uint8ClampedArray: !1,
        undefined: !1,
        unescape: !1,
        URIError: !1,
        valueOf: !1,
        WeakMap: !1,
        WeakSet: !1,
      },
      browser: {
        AbortController: !1,
        AbortSignal: !1,
        addEventListener: !1,
        alert: !1,
        AnalyserNode: !1,
        Animation: !1,
        AnimationEffectReadOnly: !1,
        AnimationEffectTiming: !1,
        AnimationEffectTimingReadOnly: !1,
        AnimationEvent: !1,
        AnimationPlaybackEvent: !1,
        AnimationTimeline: !1,
        applicationCache: !1,
        ApplicationCache: !1,
        ApplicationCacheErrorEvent: !1,
        atob: !1,
        Attr: !1,
        Audio: !1,
        AudioBuffer: !1,
        AudioBufferSourceNode: !1,
        AudioContext: !1,
        AudioDestinationNode: !1,
        AudioListener: !1,
        AudioNode: !1,
        AudioParam: !1,
        AudioProcessingEvent: !1,
        AudioScheduledSourceNode: !1,
        'AudioWorkletGlobalScope ': !1,
        AudioWorkletNode: !1,
        AudioWorkletProcessor: !1,
        BarProp: !1,
        BaseAudioContext: !1,
        BatteryManager: !1,
        BeforeUnloadEvent: !1,
        BiquadFilterNode: !1,
        Blob: !1,
        BlobEvent: !1,
        blur: !1,
        BroadcastChannel: !1,
        btoa: !1,
        BudgetService: !1,
        ByteLengthQueuingStrategy: !1,
        Cache: !1,
        caches: !1,
        CacheStorage: !1,
        cancelAnimationFrame: !1,
        cancelIdleCallback: !1,
        CanvasCaptureMediaStreamTrack: !1,
        CanvasGradient: !1,
        CanvasPattern: !1,
        CanvasRenderingContext2D: !1,
        ChannelMergerNode: !1,
        ChannelSplitterNode: !1,
        CharacterData: !1,
        clearInterval: !1,
        clearTimeout: !1,
        clientInformation: !1,
        ClipboardEvent: !1,
        close: !1,
        closed: !1,
        CloseEvent: !1,
        Comment: !1,
        CompositionEvent: !1,
        confirm: !1,
        console: !1,
        ConstantSourceNode: !1,
        ConvolverNode: !1,
        CountQueuingStrategy: !1,
        createImageBitmap: !1,
        Credential: !1,
        CredentialsContainer: !1,
        crypto: !1,
        Crypto: !1,
        CryptoKey: !1,
        CSS: !1,
        CSSConditionRule: !1,
        CSSFontFaceRule: !1,
        CSSGroupingRule: !1,
        CSSImportRule: !1,
        CSSKeyframeRule: !1,
        CSSKeyframesRule: !1,
        CSSMediaRule: !1,
        CSSNamespaceRule: !1,
        CSSPageRule: !1,
        CSSRule: !1,
        CSSRuleList: !1,
        CSSStyleDeclaration: !1,
        CSSStyleRule: !1,
        CSSStyleSheet: !1,
        CSSSupportsRule: !1,
        CustomElementRegistry: !1,
        customElements: !1,
        CustomEvent: !1,
        DataTransfer: !1,
        DataTransferItem: !1,
        DataTransferItemList: !1,
        defaultstatus: !1,
        defaultStatus: !1,
        DelayNode: !1,
        DeviceMotionEvent: !1,
        DeviceOrientationEvent: !1,
        devicePixelRatio: !1,
        dispatchEvent: !1,
        document: !1,
        Document: !1,
        DocumentFragment: !1,
        DocumentType: !1,
        DOMError: !1,
        DOMException: !1,
        DOMImplementation: !1,
        DOMMatrix: !1,
        DOMMatrixReadOnly: !1,
        DOMParser: !1,
        DOMPoint: !1,
        DOMPointReadOnly: !1,
        DOMQuad: !1,
        DOMRect: !1,
        DOMRectReadOnly: !1,
        DOMStringList: !1,
        DOMStringMap: !1,
        DOMTokenList: !1,
        DragEvent: !1,
        DynamicsCompressorNode: !1,
        Element: !1,
        ErrorEvent: !1,
        event: !1,
        Event: !1,
        EventSource: !1,
        EventTarget: !1,
        external: !1,
        fetch: !1,
        File: !1,
        FileList: !1,
        FileReader: !1,
        find: !1,
        focus: !1,
        FocusEvent: !1,
        FontFace: !1,
        FontFaceSetLoadEvent: !1,
        FormData: !1,
        frameElement: !1,
        frames: !1,
        GainNode: !1,
        Gamepad: !1,
        GamepadButton: !1,
        GamepadEvent: !1,
        getComputedStyle: !1,
        getSelection: !1,
        HashChangeEvent: !1,
        Headers: !1,
        history: !1,
        History: !1,
        HTMLAllCollection: !1,
        HTMLAnchorElement: !1,
        HTMLAreaElement: !1,
        HTMLAudioElement: !1,
        HTMLBaseElement: !1,
        HTMLBodyElement: !1,
        HTMLBRElement: !1,
        HTMLButtonElement: !1,
        HTMLCanvasElement: !1,
        HTMLCollection: !1,
        HTMLContentElement: !1,
        HTMLDataElement: !1,
        HTMLDataListElement: !1,
        HTMLDetailsElement: !1,
        HTMLDialogElement: !1,
        HTMLDirectoryElement: !1,
        HTMLDivElement: !1,
        HTMLDListElement: !1,
        HTMLDocument: !1,
        HTMLElement: !1,
        HTMLEmbedElement: !1,
        HTMLFieldSetElement: !1,
        HTMLFontElement: !1,
        HTMLFormControlsCollection: !1,
        HTMLFormElement: !1,
        HTMLFrameElement: !1,
        HTMLFrameSetElement: !1,
        HTMLHeadElement: !1,
        HTMLHeadingElement: !1,
        HTMLHRElement: !1,
        HTMLHtmlElement: !1,
        HTMLIFrameElement: !1,
        HTMLImageElement: !1,
        HTMLInputElement: !1,
        HTMLLabelElement: !1,
        HTMLLegendElement: !1,
        HTMLLIElement: !1,
        HTMLLinkElement: !1,
        HTMLMapElement: !1,
        HTMLMarqueeElement: !1,
        HTMLMediaElement: !1,
        HTMLMenuElement: !1,
        HTMLMetaElement: !1,
        HTMLMeterElement: !1,
        HTMLModElement: !1,
        HTMLObjectElement: !1,
        HTMLOListElement: !1,
        HTMLOptGroupElement: !1,
        HTMLOptionElement: !1,
        HTMLOptionsCollection: !1,
        HTMLOutputElement: !1,
        HTMLParagraphElement: !1,
        HTMLParamElement: !1,
        HTMLPictureElement: !1,
        HTMLPreElement: !1,
        HTMLProgressElement: !1,
        HTMLQuoteElement: !1,
        HTMLScriptElement: !1,
        HTMLSelectElement: !1,
        HTMLShadowElement: !1,
        HTMLSlotElement: !1,
        HTMLSourceElement: !1,
        HTMLSpanElement: !1,
        HTMLStyleElement: !1,
        HTMLTableCaptionElement: !1,
        HTMLTableCellElement: !1,
        HTMLTableColElement: !1,
        HTMLTableElement: !1,
        HTMLTableRowElement: !1,
        HTMLTableSectionElement: !1,
        HTMLTemplateElement: !1,
        HTMLTextAreaElement: !1,
        HTMLTimeElement: !1,
        HTMLTitleElement: !1,
        HTMLTrackElement: !1,
        HTMLUListElement: !1,
        HTMLUnknownElement: !1,
        HTMLVideoElement: !1,
        IDBCursor: !1,
        IDBCursorWithValue: !1,
        IDBDatabase: !1,
        IDBFactory: !1,
        IDBIndex: !1,
        IDBKeyRange: !1,
        IDBObjectStore: !1,
        IDBOpenDBRequest: !1,
        IDBRequest: !1,
        IDBTransaction: !1,
        IDBVersionChangeEvent: !1,
        IdleDeadline: !1,
        IIRFilterNode: !1,
        Image: !1,
        ImageBitmap: !1,
        ImageBitmapRenderingContext: !1,
        ImageCapture: !1,
        ImageData: !1,
        indexedDB: !1,
        innerHeight: !1,
        innerWidth: !1,
        InputEvent: !1,
        IntersectionObserver: !1,
        IntersectionObserverEntry: !1,
        Intl: !1,
        isSecureContext: !1,
        KeyboardEvent: !1,
        KeyframeEffect: !1,
        KeyframeEffectReadOnly: !1,
        length: !1,
        localStorage: !1,
        location: !0,
        Location: !1,
        locationbar: !1,
        matchMedia: !1,
        MediaDeviceInfo: !1,
        MediaDevices: !1,
        MediaElementAudioSourceNode: !1,
        MediaEncryptedEvent: !1,
        MediaError: !1,
        MediaKeyMessageEvent: !1,
        MediaKeySession: !1,
        MediaKeyStatusMap: !1,
        MediaKeySystemAccess: !1,
        MediaList: !1,
        MediaQueryList: !1,
        MediaQueryListEvent: !1,
        MediaRecorder: !1,
        MediaSettingsRange: !1,
        MediaSource: !1,
        MediaStream: !1,
        MediaStreamAudioDestinationNode: !1,
        MediaStreamAudioSourceNode: !1,
        MediaStreamEvent: !1,
        MediaStreamTrack: !1,
        MediaStreamTrackEvent: !1,
        menubar: !1,
        MessageChannel: !1,
        MessageEvent: !1,
        MessagePort: !1,
        MIDIAccess: !1,
        MIDIConnectionEvent: !1,
        MIDIInput: !1,
        MIDIInputMap: !1,
        MIDIMessageEvent: !1,
        MIDIOutput: !1,
        MIDIOutputMap: !1,
        MIDIPort: !1,
        MimeType: !1,
        MimeTypeArray: !1,
        MouseEvent: !1,
        moveBy: !1,
        moveTo: !1,
        MutationEvent: !1,
        MutationObserver: !1,
        MutationRecord: !1,
        name: !1,
        NamedNodeMap: !1,
        NavigationPreloadManager: !1,
        navigator: !1,
        Navigator: !1,
        NetworkInformation: !1,
        Node: !1,
        NodeFilter: !1,
        NodeIterator: !1,
        NodeList: !1,
        Notification: !1,
        OfflineAudioCompletionEvent: !1,
        OfflineAudioContext: !1,
        offscreenBuffering: !1,
        OffscreenCanvas: !0,
        onabort: !0,
        onafterprint: !0,
        onanimationend: !0,
        onanimationiteration: !0,
        onanimationstart: !0,
        onappinstalled: !0,
        onauxclick: !0,
        onbeforeinstallprompt: !0,
        onbeforeprint: !0,
        onbeforeunload: !0,
        onblur: !0,
        oncancel: !0,
        oncanplay: !0,
        oncanplaythrough: !0,
        onchange: !0,
        onclick: !0,
        onclose: !0,
        oncontextmenu: !0,
        oncuechange: !0,
        ondblclick: !0,
        ondevicemotion: !0,
        ondeviceorientation: !0,
        ondeviceorientationabsolute: !0,
        ondrag: !0,
        ondragend: !0,
        ondragenter: !0,
        ondragleave: !0,
        ondragover: !0,
        ondragstart: !0,
        ondrop: !0,
        ondurationchange: !0,
        onemptied: !0,
        onended: !0,
        onerror: !0,
        onfocus: !0,
        ongotpointercapture: !0,
        onhashchange: !0,
        oninput: !0,
        oninvalid: !0,
        onkeydown: !0,
        onkeypress: !0,
        onkeyup: !0,
        onlanguagechange: !0,
        onload: !0,
        onloadeddata: !0,
        onloadedmetadata: !0,
        onloadstart: !0,
        onlostpointercapture: !0,
        onmessage: !0,
        onmessageerror: !0,
        onmousedown: !0,
        onmouseenter: !0,
        onmouseleave: !0,
        onmousemove: !0,
        onmouseout: !0,
        onmouseover: !0,
        onmouseup: !0,
        onmousewheel: !0,
        onoffline: !0,
        ononline: !0,
        onpagehide: !0,
        onpageshow: !0,
        onpause: !0,
        onplay: !0,
        onplaying: !0,
        onpointercancel: !0,
        onpointerdown: !0,
        onpointerenter: !0,
        onpointerleave: !0,
        onpointermove: !0,
        onpointerout: !0,
        onpointerover: !0,
        onpointerup: !0,
        onpopstate: !0,
        onprogress: !0,
        onratechange: !0,
        onrejectionhandled: !0,
        onreset: !0,
        onresize: !0,
        onscroll: !0,
        onsearch: !0,
        onseeked: !0,
        onseeking: !0,
        onselect: !0,
        onstalled: !0,
        onstorage: !0,
        onsubmit: !0,
        onsuspend: !0,
        ontimeupdate: !0,
        ontoggle: !0,
        ontransitionend: !0,
        onunhandledrejection: !0,
        onunload: !0,
        onvolumechange: !0,
        onwaiting: !0,
        onwheel: !0,
        open: !1,
        openDatabase: !1,
        opener: !1,
        Option: !1,
        origin: !1,
        OscillatorNode: !1,
        outerHeight: !1,
        outerWidth: !1,
        PageTransitionEvent: !1,
        pageXOffset: !1,
        pageYOffset: !1,
        PannerNode: !1,
        parent: !1,
        Path2D: !1,
        PaymentAddress: !1,
        PaymentRequest: !1,
        PaymentRequestUpdateEvent: !1,
        PaymentResponse: !1,
        performance: !1,
        Performance: !1,
        PerformanceEntry: !1,
        PerformanceLongTaskTiming: !1,
        PerformanceMark: !1,
        PerformanceMeasure: !1,
        PerformanceNavigation: !1,
        PerformanceNavigationTiming: !1,
        PerformanceObserver: !1,
        PerformanceObserverEntryList: !1,
        PerformancePaintTiming: !1,
        PerformanceResourceTiming: !1,
        PerformanceTiming: !1,
        PeriodicWave: !1,
        Permissions: !1,
        PermissionStatus: !1,
        personalbar: !1,
        PhotoCapabilities: !1,
        Plugin: !1,
        PluginArray: !1,
        PointerEvent: !1,
        PopStateEvent: !1,
        postMessage: !1,
        Presentation: !1,
        PresentationAvailability: !1,
        PresentationConnection: !1,
        PresentationConnectionAvailableEvent: !1,
        PresentationConnectionCloseEvent: !1,
        PresentationConnectionList: !1,
        PresentationReceiver: !1,
        PresentationRequest: !1,
        print: !1,
        ProcessingInstruction: !1,
        ProgressEvent: !1,
        PromiseRejectionEvent: !1,
        prompt: !1,
        PushManager: !1,
        PushSubscription: !1,
        PushSubscriptionOptions: !1,
        queueMicrotask: !1,
        RadioNodeList: !1,
        Range: !1,
        ReadableStream: !1,
        registerProcessor: !1,
        RemotePlayback: !1,
        removeEventListener: !1,
        Request: !1,
        requestAnimationFrame: !1,
        requestIdleCallback: !1,
        resizeBy: !1,
        ResizeObserver: !1,
        ResizeObserverEntry: !1,
        resizeTo: !1,
        Response: !1,
        RTCCertificate: !1,
        RTCDataChannel: !1,
        RTCDataChannelEvent: !1,
        RTCDtlsTransport: !1,
        RTCIceCandidate: !1,
        RTCIceGatherer: !1,
        RTCIceTransport: !1,
        RTCPeerConnection: !1,
        RTCPeerConnectionIceEvent: !1,
        RTCRtpContributingSource: !1,
        RTCRtpReceiver: !1,
        RTCRtpSender: !1,
        RTCSctpTransport: !1,
        RTCSessionDescription: !1,
        RTCStatsReport: !1,
        RTCTrackEvent: !1,
        screen: !1,
        Screen: !1,
        screenLeft: !1,
        ScreenOrientation: !1,
        screenTop: !1,
        screenX: !1,
        screenY: !1,
        ScriptProcessorNode: !1,
        scroll: !1,
        scrollbars: !1,
        scrollBy: !1,
        scrollTo: !1,
        scrollX: !1,
        scrollY: !1,
        SecurityPolicyViolationEvent: !1,
        Selection: !1,
        self: !1,
        ServiceWorker: !1,
        ServiceWorkerContainer: !1,
        ServiceWorkerRegistration: !1,
        sessionStorage: !1,
        setInterval: !1,
        setTimeout: !1,
        ShadowRoot: !1,
        SharedWorker: !1,
        SourceBuffer: !1,
        SourceBufferList: !1,
        speechSynthesis: !1,
        SpeechSynthesisEvent: !1,
        SpeechSynthesisUtterance: !1,
        StaticRange: !1,
        status: !1,
        statusbar: !1,
        StereoPannerNode: !1,
        stop: !1,
        Storage: !1,
        StorageEvent: !1,
        StorageManager: !1,
        styleMedia: !1,
        StyleSheet: !1,
        StyleSheetList: !1,
        SubtleCrypto: !1,
        SVGAElement: !1,
        SVGAngle: !1,
        SVGAnimatedAngle: !1,
        SVGAnimatedBoolean: !1,
        SVGAnimatedEnumeration: !1,
        SVGAnimatedInteger: !1,
        SVGAnimatedLength: !1,
        SVGAnimatedLengthList: !1,
        SVGAnimatedNumber: !1,
        SVGAnimatedNumberList: !1,
        SVGAnimatedPreserveAspectRatio: !1,
        SVGAnimatedRect: !1,
        SVGAnimatedString: !1,
        SVGAnimatedTransformList: !1,
        SVGAnimateElement: !1,
        SVGAnimateMotionElement: !1,
        SVGAnimateTransformElement: !1,
        SVGAnimationElement: !1,
        SVGCircleElement: !1,
        SVGClipPathElement: !1,
        SVGComponentTransferFunctionElement: !1,
        SVGDefsElement: !1,
        SVGDescElement: !1,
        SVGDiscardElement: !1,
        SVGElement: !1,
        SVGEllipseElement: !1,
        SVGFEBlendElement: !1,
        SVGFEColorMatrixElement: !1,
        SVGFEComponentTransferElement: !1,
        SVGFECompositeElement: !1,
        SVGFEConvolveMatrixElement: !1,
        SVGFEDiffuseLightingElement: !1,
        SVGFEDisplacementMapElement: !1,
        SVGFEDistantLightElement: !1,
        SVGFEDropShadowElement: !1,
        SVGFEFloodElement: !1,
        SVGFEFuncAElement: !1,
        SVGFEFuncBElement: !1,
        SVGFEFuncGElement: !1,
        SVGFEFuncRElement: !1,
        SVGFEGaussianBlurElement: !1,
        SVGFEImageElement: !1,
        SVGFEMergeElement: !1,
        SVGFEMergeNodeElement: !1,
        SVGFEMorphologyElement: !1,
        SVGFEOffsetElement: !1,
        SVGFEPointLightElement: !1,
        SVGFESpecularLightingElement: !1,
        SVGFESpotLightElement: !1,
        SVGFETileElement: !1,
        SVGFETurbulenceElement: !1,
        SVGFilterElement: !1,
        SVGForeignObjectElement: !1,
        SVGGElement: !1,
        SVGGeometryElement: !1,
        SVGGradientElement: !1,
        SVGGraphicsElement: !1,
        SVGImageElement: !1,
        SVGLength: !1,
        SVGLengthList: !1,
        SVGLinearGradientElement: !1,
        SVGLineElement: !1,
        SVGMarkerElement: !1,
        SVGMaskElement: !1,
        SVGMatrix: !1,
        SVGMetadataElement: !1,
        SVGMPathElement: !1,
        SVGNumber: !1,
        SVGNumberList: !1,
        SVGPathElement: !1,
        SVGPatternElement: !1,
        SVGPoint: !1,
        SVGPointList: !1,
        SVGPolygonElement: !1,
        SVGPolylineElement: !1,
        SVGPreserveAspectRatio: !1,
        SVGRadialGradientElement: !1,
        SVGRect: !1,
        SVGRectElement: !1,
        SVGScriptElement: !1,
        SVGSetElement: !1,
        SVGStopElement: !1,
        SVGStringList: !1,
        SVGStyleElement: !1,
        SVGSVGElement: !1,
        SVGSwitchElement: !1,
        SVGSymbolElement: !1,
        SVGTextContentElement: !1,
        SVGTextElement: !1,
        SVGTextPathElement: !1,
        SVGTextPositioningElement: !1,
        SVGTitleElement: !1,
        SVGTransform: !1,
        SVGTransformList: !1,
        SVGTSpanElement: !1,
        SVGUnitTypes: !1,
        SVGUseElement: !1,
        SVGViewElement: !1,
        TaskAttributionTiming: !1,
        Text: !1,
        TextDecoder: !1,
        TextEncoder: !1,
        TextEvent: !1,
        TextMetrics: !1,
        TextTrack: !1,
        TextTrackCue: !1,
        TextTrackCueList: !1,
        TextTrackList: !1,
        TimeRanges: !1,
        toolbar: !1,
        top: !1,
        Touch: !1,
        TouchEvent: !1,
        TouchList: !1,
        TrackEvent: !1,
        TransitionEvent: !1,
        TreeWalker: !1,
        UIEvent: !1,
        URL: !1,
        URLSearchParams: !1,
        ValidityState: !1,
        visualViewport: !1,
        VisualViewport: !1,
        VTTCue: !1,
        WaveShaperNode: !1,
        WebAssembly: !1,
        WebGL2RenderingContext: !1,
        WebGLActiveInfo: !1,
        WebGLBuffer: !1,
        WebGLContextEvent: !1,
        WebGLFramebuffer: !1,
        WebGLProgram: !1,
        WebGLQuery: !1,
        WebGLRenderbuffer: !1,
        WebGLRenderingContext: !1,
        WebGLSampler: !1,
        WebGLShader: !1,
        WebGLShaderPrecisionFormat: !1,
        WebGLSync: !1,
        WebGLTexture: !1,
        WebGLTransformFeedback: !1,
        WebGLUniformLocation: !1,
        WebGLVertexArrayObject: !1,
        WebSocket: !1,
        WheelEvent: !1,
        window: !1,
        Window: !1,
        Worker: !1,
        WritableStream: !1,
        XMLDocument: !1,
        XMLHttpRequest: !1,
        XMLHttpRequestEventTarget: !1,
        XMLHttpRequestUpload: !1,
        XMLSerializer: !1,
        XPathEvaluator: !1,
        XPathExpression: !1,
        XPathResult: !1,
        XSLTProcessor: !1,
      },
      worker: {
        addEventListener: !1,
        applicationCache: !1,
        atob: !1,
        Blob: !1,
        BroadcastChannel: !1,
        btoa: !1,
        Cache: !1,
        caches: !1,
        clearInterval: !1,
        clearTimeout: !1,
        close: !0,
        console: !1,
        fetch: !1,
        FileReaderSync: !1,
        FormData: !1,
        Headers: !1,
        IDBCursor: !1,
        IDBCursorWithValue: !1,
        IDBDatabase: !1,
        IDBFactory: !1,
        IDBIndex: !1,
        IDBKeyRange: !1,
        IDBObjectStore: !1,
        IDBOpenDBRequest: !1,
        IDBRequest: !1,
        IDBTransaction: !1,
        IDBVersionChangeEvent: !1,
        ImageData: !1,
        importScripts: !0,
        indexedDB: !1,
        location: !1,
        MessageChannel: !1,
        MessagePort: !1,
        name: !1,
        navigator: !1,
        Notification: !1,
        onclose: !0,
        onconnect: !0,
        onerror: !0,
        onlanguagechange: !0,
        onmessage: !0,
        onoffline: !0,
        ononline: !0,
        onrejectionhandled: !0,
        onunhandledrejection: !0,
        performance: !1,
        Performance: !1,
        PerformanceEntry: !1,
        PerformanceMark: !1,
        PerformanceMeasure: !1,
        PerformanceNavigation: !1,
        PerformanceResourceTiming: !1,
        PerformanceTiming: !1,
        postMessage: !0,
        Promise: !1,
        queueMicrotask: !1,
        removeEventListener: !1,
        Request: !1,
        Response: !1,
        self: !0,
        ServiceWorkerRegistration: !1,
        setInterval: !1,
        setTimeout: !1,
        TextDecoder: !1,
        TextEncoder: !1,
        URL: !1,
        URLSearchParams: !1,
        WebSocket: !1,
        Worker: !1,
        WorkerGlobalScope: !1,
        XMLHttpRequest: !1,
      },
      node: {
        __dirname: !1,
        __filename: !1,
        Buffer: !1,
        clearImmediate: !1,
        clearInterval: !1,
        clearTimeout: !1,
        console: !1,
        exports: !0,
        global: !1,
        Intl: !1,
        module: !1,
        process: !1,
        queueMicrotask: !1,
        require: !1,
        setImmediate: !1,
        setInterval: !1,
        setTimeout: !1,
        TextDecoder: !1,
        TextEncoder: !1,
        URL: !1,
        URLSearchParams: !1,
      },
      commonjs: { exports: !0, global: !1, module: !1, require: !1 },
      amd: { define: !1, require: !1 },
      mocha: {
        after: !1,
        afterEach: !1,
        before: !1,
        beforeEach: !1,
        context: !1,
        describe: !1,
        it: !1,
        mocha: !1,
        run: !1,
        setup: !1,
        specify: !1,
        suite: !1,
        suiteSetup: !1,
        suiteTeardown: !1,
        teardown: !1,
        test: !1,
        xcontext: !1,
        xdescribe: !1,
        xit: !1,
        xspecify: !1,
      },
      jasmine: {
        afterAll: !1,
        afterEach: !1,
        beforeAll: !1,
        beforeEach: !1,
        describe: !1,
        expect: !1,
        fail: !1,
        fdescribe: !1,
        fit: !1,
        it: !1,
        jasmine: !1,
        pending: !1,
        runs: !1,
        spyOn: !1,
        spyOnProperty: !1,
        waits: !1,
        waitsFor: !1,
        xdescribe: !1,
        xit: !1,
      },
      jest: {
        afterAll: !1,
        afterEach: !1,
        beforeAll: !1,
        beforeEach: !1,
        describe: !1,
        expect: !1,
        fdescribe: !1,
        fit: !1,
        it: !1,
        jest: !1,
        pit: !1,
        require: !1,
        test: !1,
        xdescribe: !1,
        xit: !1,
        xtest: !1,
      },
      qunit: {
        asyncTest: !1,
        deepEqual: !1,
        equal: !1,
        expect: !1,
        module: !1,
        notDeepEqual: !1,
        notEqual: !1,
        notOk: !1,
        notPropEqual: !1,
        notStrictEqual: !1,
        ok: !1,
        propEqual: !1,
        QUnit: !1,
        raises: !1,
        start: !1,
        stop: !1,
        strictEqual: !1,
        test: !1,
        throws: !1,
      },
      phantomjs: { console: !0, exports: !0, phantom: !0, require: !0, WebPage: !0 },
      couch: {
        emit: !1,
        exports: !1,
        getRow: !1,
        log: !1,
        module: !1,
        provides: !1,
        require: !1,
        respond: !1,
        send: !1,
        start: !1,
        sum: !1,
      },
      rhino: {
        defineClass: !1,
        deserialize: !1,
        gc: !1,
        help: !1,
        importClass: !1,
        importPackage: !1,
        java: !1,
        load: !1,
        loadClass: !1,
        Packages: !1,
        print: !1,
        quit: !1,
        readFile: !1,
        readUrl: !1,
        runCommand: !1,
        seal: !1,
        serialize: !1,
        spawn: !1,
        sync: !1,
        toint32: !1,
        version: !1,
      },
      nashorn: {
        __DIR__: !1,
        __FILE__: !1,
        __LINE__: !1,
        com: !1,
        edu: !1,
        exit: !1,
        java: !1,
        Java: !1,
        javafx: !1,
        JavaImporter: !1,
        javax: !1,
        JSAdapter: !1,
        load: !1,
        loadWithNewGlobal: !1,
        org: !1,
        Packages: !1,
        print: !1,
        quit: !1,
      },
      wsh: {
        ActiveXObject: !0,
        Enumerator: !0,
        GetObject: !0,
        ScriptEngine: !0,
        ScriptEngineBuildVersion: !0,
        ScriptEngineMajorVersion: !0,
        ScriptEngineMinorVersion: !0,
        VBArray: !0,
        WScript: !0,
        WSH: !0,
        XDomainRequest: !0,
      },
      jquery: { $: !1, jQuery: !1 },
      yui: { YAHOO: !1, YAHOO_config: !1, YUI: !1, YUI_config: !1 },
      shelljs: {
        cat: !1,
        cd: !1,
        chmod: !1,
        config: !1,
        cp: !1,
        dirs: !1,
        echo: !1,
        env: !1,
        error: !1,
        exec: !1,
        exit: !1,
        find: !1,
        grep: !1,
        ln: !1,
        ls: !1,
        mkdir: !1,
        mv: !1,
        popd: !1,
        pushd: !1,
        pwd: !1,
        rm: !1,
        sed: !1,
        set: !1,
        target: !1,
        tempdir: !1,
        test: !1,
        touch: !1,
        which: !1,
      },
      prototypejs: {
        $: !1,
        $$: !1,
        $A: !1,
        $break: !1,
        $continue: !1,
        $F: !1,
        $H: !1,
        $R: !1,
        $w: !1,
        Abstract: !1,
        Ajax: !1,
        Autocompleter: !1,
        Builder: !1,
        Class: !1,
        Control: !1,
        Draggable: !1,
        Draggables: !1,
        Droppables: !1,
        Effect: !1,
        Element: !1,
        Enumerable: !1,
        Event: !1,
        Field: !1,
        Form: !1,
        Hash: !1,
        Insertion: !1,
        ObjectRange: !1,
        PeriodicalExecuter: !1,
        Position: !1,
        Prototype: !1,
        Scriptaculous: !1,
        Selector: !1,
        Sortable: !1,
        SortableObserver: !1,
        Sound: !1,
        Template: !1,
        Toggle: !1,
        Try: !1,
      },
      meteor: {
        _: !1,
        $: !1,
        Accounts: !1,
        AccountsClient: !1,
        AccountsCommon: !1,
        AccountsServer: !1,
        App: !1,
        Assets: !1,
        Blaze: !1,
        check: !1,
        Cordova: !1,
        DDP: !1,
        DDPRateLimiter: !1,
        DDPServer: !1,
        Deps: !1,
        EJSON: !1,
        Email: !1,
        HTTP: !1,
        Log: !1,
        Match: !1,
        Meteor: !1,
        Mongo: !1,
        MongoInternals: !1,
        Npm: !1,
        Package: !1,
        Plugin: !1,
        process: !1,
        Random: !1,
        ReactiveDict: !1,
        ReactiveVar: !1,
        Router: !1,
        ServiceConfiguration: !1,
        Session: !1,
        share: !1,
        Spacebars: !1,
        Template: !1,
        Tinytest: !1,
        Tracker: !1,
        UI: !1,
        Utils: !1,
        WebApp: !1,
        WebAppInternals: !1,
      },
      mongo: {
        _isWindows: !1,
        _rand: !1,
        BulkWriteResult: !1,
        cat: !1,
        cd: !1,
        connect: !1,
        db: !1,
        getHostName: !1,
        getMemInfo: !1,
        hostname: !1,
        ISODate: !1,
        listFiles: !1,
        load: !1,
        ls: !1,
        md5sumFile: !1,
        mkdir: !1,
        Mongo: !1,
        NumberInt: !1,
        NumberLong: !1,
        ObjectId: !1,
        PlanCache: !1,
        print: !1,
        printjson: !1,
        pwd: !1,
        quit: !1,
        removeFile: !1,
        rs: !1,
        sh: !1,
        UUID: !1,
        version: !1,
        WriteResult: !1,
      },
      applescript: {
        $: !1,
        Application: !1,
        Automation: !1,
        console: !1,
        delay: !1,
        Library: !1,
        ObjC: !1,
        ObjectSpecifier: !1,
        Path: !1,
        Progress: !1,
        Ref: !1,
      },
      serviceworker: {
        addEventListener: !1,
        applicationCache: !1,
        atob: !1,
        Blob: !1,
        BroadcastChannel: !1,
        btoa: !1,
        Cache: !1,
        caches: !1,
        CacheStorage: !1,
        clearInterval: !1,
        clearTimeout: !1,
        Client: !1,
        clients: !1,
        Clients: !1,
        close: !0,
        console: !1,
        ExtendableEvent: !1,
        ExtendableMessageEvent: !1,
        fetch: !1,
        FetchEvent: !1,
        FileReaderSync: !1,
        FormData: !1,
        Headers: !1,
        IDBCursor: !1,
        IDBCursorWithValue: !1,
        IDBDatabase: !1,
        IDBFactory: !1,
        IDBIndex: !1,
        IDBKeyRange: !1,
        IDBObjectStore: !1,
        IDBOpenDBRequest: !1,
        IDBRequest: !1,
        IDBTransaction: !1,
        IDBVersionChangeEvent: !1,
        ImageData: !1,
        importScripts: !1,
        indexedDB: !1,
        location: !1,
        MessageChannel: !1,
        MessagePort: !1,
        name: !1,
        navigator: !1,
        Notification: !1,
        onclose: !0,
        onconnect: !0,
        onerror: !0,
        onfetch: !0,
        oninstall: !0,
        onlanguagechange: !0,
        onmessage: !0,
        onmessageerror: !0,
        onnotificationclick: !0,
        onnotificationclose: !0,
        onoffline: !0,
        ononline: !0,
        onpush: !0,
        onpushsubscriptionchange: !0,
        onrejectionhandled: !0,
        onsync: !0,
        onunhandledrejection: !0,
        performance: !1,
        Performance: !1,
        PerformanceEntry: !1,
        PerformanceMark: !1,
        PerformanceMeasure: !1,
        PerformanceNavigation: !1,
        PerformanceResourceTiming: !1,
        PerformanceTiming: !1,
        postMessage: !0,
        Promise: !1,
        queueMicrotask: !1,
        registration: !1,
        removeEventListener: !1,
        Request: !1,
        Response: !1,
        self: !1,
        ServiceWorker: !1,
        ServiceWorkerContainer: !1,
        ServiceWorkerGlobalScope: !1,
        ServiceWorkerMessageEvent: !1,
        ServiceWorkerRegistration: !1,
        setInterval: !1,
        setTimeout: !1,
        skipWaiting: !1,
        TextDecoder: !1,
        TextEncoder: !1,
        URL: !1,
        URLSearchParams: !1,
        WebSocket: !1,
        WindowClient: !1,
        Worker: !1,
        WorkerGlobalScope: !1,
        XMLHttpRequest: !1,
      },
      atomtest: {
        advanceClock: !1,
        fakeClearInterval: !1,
        fakeClearTimeout: !1,
        fakeSetInterval: !1,
        fakeSetTimeout: !1,
        resetTimeouts: !1,
        waitsForPromise: !1,
      },
      embertest: {
        andThen: !1,
        click: !1,
        currentPath: !1,
        currentRouteName: !1,
        currentURL: !1,
        fillIn: !1,
        find: !1,
        findAll: !1,
        findWithAssert: !1,
        keyEvent: !1,
        pauseTest: !1,
        resumeTest: !1,
        triggerEvent: !1,
        visit: !1,
        wait: !1,
      },
      protractor: { $: !1, $$: !1, browser: !1, by: !1, By: !1, DartObject: !1, element: !1, protractor: !1 },
      'shared-node-browser': {
        clearInterval: !1,
        clearTimeout: !1,
        console: !1,
        setInterval: !1,
        setTimeout: !1,
        URL: !1,
        URLSearchParams: !1,
      },
      webextensions: { browser: !1, chrome: !1, opr: !1 },
      greasemonkey: {
        cloneInto: !1,
        createObjectIn: !1,
        exportFunction: !1,
        GM: !1,
        GM_addStyle: !1,
        GM_deleteValue: !1,
        GM_getResourceText: !1,
        GM_getResourceURL: !1,
        GM_getValue: !1,
        GM_info: !1,
        GM_listValues: !1,
        GM_log: !1,
        GM_openInTab: !1,
        GM_registerMenuCommand: !1,
        GM_setClipboard: !1,
        GM_setValue: !1,
        GM_xmlhttpRequest: !1,
        unsafeWindow: !1,
      },
      devtools: {
        $: !1,
        $_: !1,
        $$: !1,
        $0: !1,
        $1: !1,
        $2: !1,
        $3: !1,
        $4: !1,
        $x: !1,
        chrome: !1,
        clear: !1,
        copy: !1,
        debug: !1,
        dir: !1,
        dirxml: !1,
        getEventListeners: !1,
        inspect: !1,
        keys: !1,
        monitor: !1,
        monitorEvents: !1,
        profile: !1,
        profileEnd: !1,
        queryObjects: !1,
        table: !1,
        undebug: !1,
        unmonitor: !1,
        unmonitorEvents: !1,
        values: !1,
      },
    },
    v8 = S8
  Object.defineProperty(gs, '__esModule', { value: !0 }), (gs.default = void 0)
  var E8 = eo,
    P8 = ss,
    w8 = to,
    A8 = v8,
    C8 = st,
    Tm = Vt
  const {
    NOT_LOCAL_BINDING: bm,
    callExpression: Sm,
    cloneNode: vm,
    getBindingIdentifiers: x8,
    identifier: xn,
    isArrayExpression: Em,
    isBinary: I8,
    isClass: k8,
    isClassBody: N8,
    isClassDeclaration: O8,
    isExportAllDeclaration: Pm,
    isExportDefaultDeclaration: D8,
    isExportNamedDeclaration: nc,
    isFunctionDeclaration: B8,
    isIdentifier: ro,
    isImportDeclaration: wm,
    isLiteral: L8,
    isMethod: M8,
    isModuleDeclaration: F8,
    isModuleSpecifier: $8,
    isObjectExpression: R8,
    isProperty: j8,
    isPureish: _8,
    isSuper: V8,
    isTaggedTemplateExpression: U8,
    isTemplateLiteral: z8,
    isThisExpression: Am,
    isUnaryExpression: K8,
    isVariableDeclaration: W8,
    matchesPattern: Y8,
    memberExpression: sc,
    numericLiteral: Cm,
    toIdentifier: H8,
    unaryExpression: q8,
    variableDeclaration: X8,
    variableDeclarator: G8,
    isRecordExpression: J8,
    isTupleExpression: Z8,
    isObjectProperty: Q8,
    isTopicReference: xm,
    isMetaProperty: e6,
    isPrivateName: t6,
  } = C8
  function Ct(t, e) {
    switch (t == null ? void 0 : t.type) {
      default:
        if (F8(t))
          if ((Pm(t) || nc(t) || wm(t)) && t.source) Ct(t.source, e)
          else if ((nc(t) || wm(t)) && t.specifiers && t.specifiers.length) for (const r of t.specifiers) Ct(r, e)
          else (D8(t) || nc(t)) && t.declaration && Ct(t.declaration, e)
        else $8(t) ? Ct(t.local, e) : L8(t) && e.push(t.value)
        break
      case 'MemberExpression':
      case 'OptionalMemberExpression':
      case 'JSXMemberExpression':
        Ct(t.object, e), Ct(t.property, e)
        break
      case 'Identifier':
      case 'JSXIdentifier':
        e.push(t.name)
        break
      case 'CallExpression':
      case 'OptionalCallExpression':
      case 'NewExpression':
        Ct(t.callee, e)
        break
      case 'ObjectExpression':
      case 'ObjectPattern':
        for (const r of t.properties) Ct(r, e)
        break
      case 'SpreadElement':
      case 'RestElement':
        Ct(t.argument, e)
        break
      case 'ObjectProperty':
      case 'ObjectMethod':
      case 'ClassProperty':
      case 'ClassMethod':
      case 'ClassPrivateProperty':
      case 'ClassPrivateMethod':
        Ct(t.key, e)
        break
      case 'ThisExpression':
        e.push('this')
        break
      case 'Super':
        e.push('super')
        break
      case 'Import':
        e.push('import')
        break
      case 'DoExpression':
        e.push('do')
        break
      case 'YieldExpression':
        e.push('yield'), Ct(t.argument, e)
        break
      case 'AwaitExpression':
        e.push('await'), Ct(t.argument, e)
        break
      case 'AssignmentExpression':
        Ct(t.left, e)
        break
      case 'VariableDeclarator':
        Ct(t.id, e)
        break
      case 'FunctionExpression':
      case 'FunctionDeclaration':
      case 'ClassExpression':
      case 'ClassDeclaration':
        Ct(t.id, e)
        break
      case 'PrivateName':
        Ct(t.id, e)
        break
      case 'ParenthesizedExpression':
        Ct(t.expression, e)
        break
      case 'UnaryExpression':
      case 'UpdateExpression':
        Ct(t.argument, e)
        break
      case 'MetaProperty':
        Ct(t.meta, e), Ct(t.property, e)
        break
      case 'JSXElement':
        Ct(t.openingElement, e)
        break
      case 'JSXOpeningElement':
        e.push(t.name)
        break
      case 'JSXFragment':
        Ct(t.openingFragment, e)
        break
      case 'JSXOpeningFragment':
        e.push('Fragment')
        break
      case 'JSXNamespacedName':
        Ct(t.namespace, e), Ct(t.name, e)
        break
    }
  }
  const io = {
    ForStatement(t) {
      const e = t.get('init')
      if (e.isVar()) {
        const { scope: r } = t
        ;(r.getFunctionParent() || r.getProgramParent()).registerBinding('var', e)
      }
    },
    Declaration(t) {
      if (t.isBlockScoped() || t.isImportDeclaration() || t.isExportDeclaration()) return
      ;(t.scope.getFunctionParent() || t.scope.getProgramParent()).registerDeclaration(t)
    },
    ImportDeclaration(t) {
      t.scope.getBlockParent().registerDeclaration(t)
    },
    ReferencedIdentifier(t, e) {
      e.references.push(t)
    },
    ForXStatement(t, e) {
      const r = t.get('left')
      if (r.isPattern() || r.isIdentifier()) e.constantViolations.push(t)
      else if (r.isVar()) {
        const { scope: i } = t
        ;(i.getFunctionParent() || i.getProgramParent()).registerBinding('var', r)
      }
    },
    ExportDeclaration: {
      exit(t) {
        const { node: e, scope: r } = t
        if (Pm(e)) return
        const i = e.declaration
        if (O8(i) || B8(i)) {
          const n = i.id
          if (!n) return
          const s = r.getBinding(n.name)
          s == null || s.reference(t)
        } else if (W8(i))
          for (const n of i.declarations)
            for (const s of Object.keys(x8(n))) {
              const a = r.getBinding(s)
              a == null || a.reference(t)
            }
      },
    },
    LabeledStatement(t) {
      t.scope.getBlockParent().registerDeclaration(t)
    },
    AssignmentExpression(t, e) {
      e.assignments.push(t)
    },
    UpdateExpression(t, e) {
      e.constantViolations.push(t)
    },
    UnaryExpression(t, e) {
      t.node.operator === 'delete' && e.constantViolations.push(t)
    },
    BlockScoped(t) {
      let e = t.scope
      if (
        (e.path === t && (e = e.parent), e.getBlockParent().registerDeclaration(t), t.isClassDeclaration() && t.node.id)
      ) {
        const n = t.node.id.name
        t.scope.bindings[n] = t.scope.parent.getBinding(n)
      }
    },
    CatchClause(t) {
      t.scope.registerBinding('let', t)
    },
    Function(t) {
      const e = t.get('params')
      for (const r of e) t.scope.registerBinding('param', r)
      t.isFunctionExpression() &&
        t.has('id') &&
        !t.get('id').node[bm] &&
        t.scope.registerBinding('local', t.get('id'), t)
    },
    ClassExpression(t) {
      t.has('id') && !t.get('id').node[bm] && t.scope.registerBinding('local', t)
    },
  }
  let r6 = 0
  class In {
    constructor(e) {
      ;(this.uid = void 0),
        (this.path = void 0),
        (this.block = void 0),
        (this.labels = void 0),
        (this.inited = void 0),
        (this.bindings = void 0),
        (this.references = void 0),
        (this.globals = void 0),
        (this.uids = void 0),
        (this.data = void 0),
        (this.crawling = void 0)
      const { node: r } = e,
        i = Tm.scope.get(r)
      if ((i == null ? void 0 : i.path) === e) return i
      Tm.scope.set(r, this),
        (this.uid = r6++),
        (this.block = r),
        (this.path = e),
        (this.labels = new Map()),
        (this.inited = !1)
    }
    get parent() {
      var e
      let r,
        i = this.path
      do {
        const n = i.key === 'key' || i.listKey === 'decorators'
        ;(i = i.parentPath), n && i.isMethod() && (i = i.parentPath), i && i.isScope() && (r = i)
      } while (i && !r)
      return (e = r) == null ? void 0 : e.scope
    }
    get parentBlock() {
      return this.path.parent
    }
    get hub() {
      return this.path.hub
    }
    traverse(e, r, i) {
      ;(0, P8.default)(e, r, this, i, this.path)
    }
    generateDeclaredUidIdentifier(e) {
      const r = this.generateUidIdentifier(e)
      return this.push({ id: r }), vm(r)
    }
    generateUidIdentifier(e) {
      return xn(this.generateUid(e))
    }
    generateUid(e = 'temp') {
      e = H8(e)
        .replace(/^_+/, '')
        .replace(/[0-9]+$/g, '')
      let r,
        i = 1
      do (r = this._generateUid(e, i)), i++
      while (this.hasLabel(r) || this.hasBinding(r) || this.hasGlobal(r) || this.hasReference(r))
      const n = this.getProgramParent()
      return (n.references[r] = !0), (n.uids[r] = !0), r
    }
    _generateUid(e, r) {
      let i = e
      return r > 1 && (i += r), `_${i}`
    }
    generateUidBasedOnNode(e, r) {
      const i = []
      Ct(e, i)
      let n = i.join('$')
      return (n = n.replace(/^_/, '') || r || 'ref'), this.generateUid(n.slice(0, 20))
    }
    generateUidIdentifierBasedOnNode(e, r) {
      return xn(this.generateUidBasedOnNode(e, r))
    }
    isStatic(e) {
      if (Am(e) || V8(e) || xm(e)) return !0
      if (ro(e)) {
        const r = this.getBinding(e.name)
        return r ? r.constant : this.hasBinding(e.name)
      }
      return !1
    }
    maybeGenerateMemoised(e, r) {
      if (this.isStatic(e)) return null
      {
        const i = this.generateUidIdentifierBasedOnNode(e)
        return r ? i : (this.push({ id: i }), vm(i))
      }
    }
    checkBlockScopedCollisions(e, r, i, n) {
      if (r === 'param' || e.kind === 'local') return
      if (
        r === 'let' ||
        e.kind === 'let' ||
        e.kind === 'const' ||
        e.kind === 'module' ||
        (e.kind === 'param' && r === 'const')
      )
        throw this.hub.buildError(n, `Duplicate declaration "${i}"`, TypeError)
    }
    rename(e, r, i) {
      const n = this.getBinding(e)
      if (n) return (r = r || this.generateUidIdentifier(e).name), new E8.default(n, e, r).rename(i)
    }
    _renameFromMap(e, r, i, n) {
      e[r] && ((e[i] = n), (e[r] = null))
    }
    dump() {
      const e = '-'.repeat(60)
      console.log(e)
      let r = this
      do {
        console.log('#', r.block.type)
        for (const i of Object.keys(r.bindings)) {
          const n = r.bindings[i]
          console.log(' -', i, {
            constant: n.constant,
            references: n.references,
            violations: n.constantViolations.length,
            kind: n.kind,
          })
        }
      } while ((r = r.parent))
      console.log(e)
    }
    toArray(e, r, i) {
      if (ro(e)) {
        const a = this.getBinding(e.name)
        if (a != null && a.constant && a.path.isGenericType('Array')) return e
      }
      if (Em(e)) return e
      if (ro(e, { name: 'arguments' }))
        return Sm(sc(sc(sc(xn('Array'), xn('prototype')), xn('slice')), xn('call')), [e])
      let n
      const s = [e]
      return (
        r === !0 ? (n = 'toConsumableArray') : r ? (s.push(Cm(r)), (n = 'slicedToArray')) : (n = 'toArray'),
        i && (s.unshift(this.hub.addHelper(n)), (n = 'maybeArrayLike')),
        Sm(this.hub.addHelper(n), s)
      )
    }
    hasLabel(e) {
      return !!this.getLabel(e)
    }
    getLabel(e) {
      return this.labels.get(e)
    }
    registerLabel(e) {
      this.labels.set(e.node.label.name, e)
    }
    registerDeclaration(e) {
      if (e.isLabeledStatement()) this.registerLabel(e)
      else if (e.isFunctionDeclaration()) this.registerBinding('hoisted', e.get('id'), e)
      else if (e.isVariableDeclaration()) {
        const r = e.get('declarations')
        for (const i of r) this.registerBinding(e.node.kind, i)
      } else if (e.isClassDeclaration()) {
        if (e.node.declare) return
        this.registerBinding('let', e)
      } else if (e.isImportDeclaration()) {
        const r = e.get('specifiers')
        for (const i of r) this.registerBinding('module', i)
      } else if (e.isExportDeclaration()) {
        const r = e.get('declaration')
        ;(r.isClassDeclaration() || r.isFunctionDeclaration() || r.isVariableDeclaration()) &&
          this.registerDeclaration(r)
      } else this.registerBinding('unknown', e)
    }
    buildUndefinedNode() {
      return q8('void', Cm(0), !0)
    }
    registerConstantViolation(e) {
      const r = e.getBindingIdentifiers()
      for (const i of Object.keys(r)) {
        const n = this.getBinding(i)
        n && n.reassign(e)
      }
    }
    registerBinding(e, r, i = r) {
      if (!e) throw new ReferenceError('no `kind`')
      if (r.isVariableDeclaration()) {
        const a = r.get('declarations')
        for (const o of a) this.registerBinding(e, o)
        return
      }
      const n = this.getProgramParent(),
        s = r.getOuterBindingIdentifiers(!0)
      for (const a of Object.keys(s)) {
        n.references[a] = !0
        for (const o of s[a]) {
          const u = this.getOwnBinding(a)
          if (u) {
            if (u.identifier === o) continue
            this.checkBlockScopedCollisions(u, e, a, o)
          }
          u
            ? this.registerConstantViolation(i)
            : (this.bindings[a] = new w8.default({ identifier: o, scope: this, path: i, kind: e }))
        }
      }
    }
    addGlobal(e) {
      this.globals[e.name] = e
    }
    hasUid(e) {
      let r = this
      do if (r.uids[e]) return !0
      while ((r = r.parent))
      return !1
    }
    hasGlobal(e) {
      let r = this
      do if (r.globals[e]) return !0
      while ((r = r.parent))
      return !1
    }
    hasReference(e) {
      return !!this.getProgramParent().references[e]
    }
    isPure(e, r) {
      if (ro(e)) {
        const a = this.getBinding(e.name)
        return a ? (r ? a.constant : !0) : !1
      } else {
        if (Am(e) || e6(e) || xm(e) || t6(e)) return !0
        if (k8(e)) {
          var i
          return (e.superClass && !this.isPure(e.superClass, r)) || ((i = e.decorators) == null ? void 0 : i.length) > 0
            ? !1
            : this.isPure(e.body, r)
        } else if (N8(e)) {
          for (const a of e.body) if (!this.isPure(a, r)) return !1
          return !0
        } else {
          if (I8(e)) return this.isPure(e.left, r) && this.isPure(e.right, r)
          if (Em(e) || Z8(e)) {
            for (const a of e.elements) if (a !== null && !this.isPure(a, r)) return !1
            return !0
          } else if (R8(e) || J8(e)) {
            for (const a of e.properties) if (!this.isPure(a, r)) return !1
            return !0
          } else if (M8(e)) {
            var n
            return !((e.computed && !this.isPure(e.key, r)) || ((n = e.decorators) == null ? void 0 : n.length) > 0)
          } else if (j8(e)) {
            var s
            return !(
              (e.computed && !this.isPure(e.key, r)) ||
              ((s = e.decorators) == null ? void 0 : s.length) > 0 ||
              ((Q8(e) || e.static) && e.value !== null && !this.isPure(e.value, r))
            )
          } else {
            if (K8(e)) return this.isPure(e.argument, r)
            if (U8(e)) return Y8(e.tag, 'String.raw') && !this.hasBinding('String', !0) && this.isPure(e.quasi, r)
            if (z8(e)) {
              for (const a of e.expressions) if (!this.isPure(a, r)) return !1
              return !0
            } else return _8(e)
          }
        }
      }
    }
    setData(e, r) {
      return (this.data[e] = r)
    }
    getData(e) {
      let r = this
      do {
        const i = r.data[e]
        if (i != null) return i
      } while ((r = r.parent))
    }
    removeData(e) {
      let r = this
      do r.data[e] != null && (r.data[e] = null)
      while ((r = r.parent))
    }
    init() {
      this.inited || ((this.inited = !0), this.crawl())
    }
    crawl() {
      const e = this.path
      ;(this.references = Object.create(null)),
        (this.bindings = Object.create(null)),
        (this.globals = Object.create(null)),
        (this.uids = Object.create(null)),
        (this.data = Object.create(null))
      const r = this.getProgramParent()
      if (r.crawling) return
      const i = { references: [], constantViolations: [], assignments: [] }
      if (((this.crawling = !0), e.type !== 'Program' && io._exploded)) {
        for (const s of io.enter) s(e, i)
        const n = io[e.type]
        if (n) for (const s of n.enter) s(e, i)
      }
      e.traverse(io, i), (this.crawling = !1)
      for (const n of i.assignments) {
        const s = n.getBindingIdentifiers()
        for (const a of Object.keys(s)) n.scope.getBinding(a) || r.addGlobal(s[a])
        n.scope.registerConstantViolation(n)
      }
      for (const n of i.references) {
        const s = n.scope.getBinding(n.node.name)
        s ? s.reference(n) : r.addGlobal(n.node)
      }
      for (const n of i.constantViolations) n.scope.registerConstantViolation(n)
    }
    push(e) {
      let r = this.path
      r.isPattern()
        ? (r = this.getPatternParent().path)
        : !r.isBlockStatement() && !r.isProgram() && (r = this.getBlockParent().path),
        r.isSwitchStatement() && (r = (this.getFunctionParent() || this.getProgramParent()).path),
        (r.isLoop() || r.isCatchClause() || r.isFunction()) && (r.ensureBlock(), (r = r.get('body')))
      const i = e.unique,
        n = e.kind || 'var',
        s = e._blockHoist == null ? 2 : e._blockHoist,
        a = `declaration:${n}:${s}`
      let o = !i && r.getData(a)
      if (!o) {
        const p = X8(n, [])
        ;(p._blockHoist = s), ([o] = r.unshiftContainer('body', [p])), i || r.setData(a, o)
      }
      const u = G8(e.id, e.init),
        c = o.node.declarations.push(u)
      r.scope.registerBinding(n, o.get('declarations')[c - 1])
    }
    getProgramParent() {
      let e = this
      do if (e.path.isProgram()) return e
      while ((e = e.parent))
      throw new Error("Couldn't find a Program")
    }
    getFunctionParent() {
      let e = this
      do if (e.path.isFunctionParent()) return e
      while ((e = e.parent))
      return null
    }
    getBlockParent() {
      let e = this
      do if (e.path.isBlockParent()) return e
      while ((e = e.parent))
      throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...")
    }
    getPatternParent() {
      let e = this
      do if (!e.path.isPattern()) return e.getBlockParent()
      while ((e = e.parent.parent))
      throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...")
    }
    getAllBindings() {
      const e = Object.create(null)
      let r = this
      do {
        for (const i of Object.keys(r.bindings)) i in e || (e[i] = r.bindings[i])
        r = r.parent
      } while (r)
      return e
    }
    getAllBindingsOfKind(...e) {
      const r = Object.create(null)
      for (const i of e) {
        let n = this
        do {
          for (const s of Object.keys(n.bindings)) {
            const a = n.bindings[s]
            a.kind === i && (r[s] = a)
          }
          n = n.parent
        } while (n)
      }
      return r
    }
    bindingIdentifierEquals(e, r) {
      return this.getBindingIdentifier(e) === r
    }
    getBinding(e) {
      let r = this,
        i
      do {
        const s = r.getOwnBinding(e)
        if (s) {
          var n
          if (!((n = i) != null && n.isPattern() && s.kind !== 'param' && s.kind !== 'local')) return s
        } else if (!s && e === 'arguments' && r.path.isFunction() && !r.path.isArrowFunctionExpression()) break
        i = r.path
      } while ((r = r.parent))
    }
    getOwnBinding(e) {
      return this.bindings[e]
    }
    getBindingIdentifier(e) {
      var r
      return (r = this.getBinding(e)) == null ? void 0 : r.identifier
    }
    getOwnBindingIdentifier(e) {
      const r = this.bindings[e]
      return r == null ? void 0 : r.identifier
    }
    hasOwnBinding(e) {
      return !!this.getOwnBinding(e)
    }
    hasBinding(e, r) {
      return e
        ? !!(
            this.hasOwnBinding(e) ||
            this.parentHasBinding(e, r) ||
            this.hasUid(e) ||
            (!r && In.globals.includes(e)) ||
            (!r && In.contextVariables.includes(e))
          )
        : !1
    }
    parentHasBinding(e, r) {
      var i
      return (i = this.parent) == null ? void 0 : i.hasBinding(e, r)
    }
    moveBindingTo(e, r) {
      const i = this.getBinding(e)
      i && (i.scope.removeOwnBinding(e), (i.scope = r), (r.bindings[e] = i))
    }
    removeOwnBinding(e) {
      delete this.bindings[e]
    }
    removeBinding(e) {
      var r
      ;(r = this.getBinding(e)) == null || r.scope.removeOwnBinding(e)
      let i = this
      do i.uids[e] && (i.uids[e] = !1)
      while ((i = i.parent))
    }
  }
  ;(gs.default = In),
    (In.globals = Object.keys(A8.builtin)),
    (In.contextVariables = ['arguments', 'undefined', 'Infinity', 'NaN'])
  var Ts = {},
    no = {},
    ac = { exports: {} },
    oc = { exports: {} }
  ;(function (t, e) {
    ;(function (r, i) {
      i(e)
    })(jt, function (r) {
      ;(r.get = void 0), (r.put = void 0), (r.pop = void 0)
      class i {
        constructor() {
          ;(this._indexes = { __proto__: null }), (this.array = [])
        }
      }
      ;(r.get = (n, s) => n._indexes[s]),
        (r.put = (n, s) => {
          const a = r.get(n, s)
          if (a !== void 0) return a
          const { array: o, _indexes: u } = n
          return (u[s] = o.push(s) - 1)
        }),
        (r.pop = (n) => {
          const { array: s, _indexes: a } = n
          if (s.length === 0) return
          const o = s.pop()
          a[o] = void 0
        }),
        (r.SetArray = i),
        Object.defineProperty(r, '__esModule', { value: !0 })
    })
  })(oc, oc.exports)
  var so = { exports: {} }
  ;(function (t, e) {
    ;(function (r, i) {
      i(e)
    })(jt, function (r) {
      const i = ','.charCodeAt(0),
        n = ';'.charCodeAt(0),
        s = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
        a = new Uint8Array(64),
        o = new Uint8Array(128)
      for (let m = 0; m < s.length; m++) {
        const S = s.charCodeAt(m)
        ;(a[m] = S), (o[S] = m)
      }
      const u =
        typeof TextDecoder != 'undefined'
          ? new TextDecoder()
          : typeof Buffer != 'undefined'
          ? {
              decode(m) {
                return Buffer.from(m.buffer, m.byteOffset, m.byteLength).toString()
              },
            }
          : {
              decode(m) {
                let S = ''
                for (let E = 0; E < m.length; E++) S += String.fromCharCode(m[E])
                return S
              },
            }
      function c(m) {
        const S = new Int32Array(5),
          E = []
        let P = 0
        do {
          const x = p(m, P),
            D = []
          let N = !0,
            I = 0
          S[0] = 0
          for (let B = P; B < x; B++) {
            let K
            B = h(m, B, S, 0)
            const Y = S[0]
            Y < I && (N = !1),
              (I = Y),
              f(m, B, x)
                ? ((B = h(m, B, S, 1)),
                  (B = h(m, B, S, 2)),
                  (B = h(m, B, S, 3)),
                  f(m, B, x) ? ((B = h(m, B, S, 4)), (K = [Y, S[1], S[2], S[3], S[4]])) : (K = [Y, S[1], S[2], S[3]]))
                : (K = [Y]),
              D.push(K)
          }
          N || d(D), E.push(D), (P = x + 1)
        } while (P <= m.length)
        return E
      }
      function p(m, S) {
        const E = m.indexOf(';', S)
        return E === -1 ? m.length : E
      }
      function h(m, S, E, P) {
        let x = 0,
          D = 0,
          N = 0
        do {
          const B = m.charCodeAt(S++)
          ;(N = o[B]), (x |= (N & 31) << D), (D += 5)
        } while (N & 32)
        const I = x & 1
        return (x >>>= 1), I && (x = -2147483648 | -x), (E[P] += x), S
      }
      function f(m, S, E) {
        return S >= E ? !1 : m.charCodeAt(S) !== i
      }
      function d(m) {
        m.sort(T)
      }
      function T(m, S) {
        return m[0] - S[0]
      }
      function y(m) {
        const S = new Int32Array(5),
          E = 1024 * 16,
          P = E - 36,
          x = new Uint8Array(E),
          D = x.subarray(0, P)
        let N = 0,
          I = ''
        for (let B = 0; B < m.length; B++) {
          const K = m[B]
          if ((B > 0 && (N === E && ((I += u.decode(x)), (N = 0)), (x[N++] = n)), K.length !== 0)) {
            S[0] = 0
            for (let Y = 0; Y < K.length; Y++) {
              const C = K[Y]
              N > P && ((I += u.decode(D)), x.copyWithin(0, P, N), (N -= P)),
                Y > 0 && (x[N++] = i),
                (N = b(x, N, S, C, 0)),
                C.length !== 1 &&
                  ((N = b(x, N, S, C, 1)),
                  (N = b(x, N, S, C, 2)),
                  (N = b(x, N, S, C, 3)),
                  C.length !== 4 && (N = b(x, N, S, C, 4)))
            }
          }
        }
        return I + u.decode(x.subarray(0, N))
      }
      function b(m, S, E, P, x) {
        const D = P[x]
        let N = D - E[x]
        ;(E[x] = D), (N = N < 0 ? (-N << 1) | 1 : N << 1)
        do {
          let I = N & 31
          ;(N >>>= 5), N > 0 && (I |= 32), (m[S++] = a[I])
        } while (N > 0)
        return S
      }
      ;(r.decode = c), (r.encode = y), Object.defineProperty(r, '__esModule', { value: !0 })
    })
  })(so, so.exports)
  var lc = { exports: {} },
    Im = { exports: {} }
  ;(function (t, e) {
    ;(function (r, i) {
      t.exports = i()
    })(jt, function () {
      const r = /^[\w+.-]+:\/\//,
        i = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?/,
        n = /^file:(?:\/\/((?![a-z]:)[^/]*)?)?(\/?.*)/i
      function s(m) {
        return r.test(m)
      }
      function a(m) {
        return m.startsWith('//')
      }
      function o(m) {
        return m.startsWith('/')
      }
      function u(m) {
        return m.startsWith('file:')
      }
      function c(m) {
        const S = i.exec(m)
        return h(S[1], S[2] || '', S[3], S[4] || '', S[5] || '/')
      }
      function p(m) {
        const S = n.exec(m),
          E = S[2]
        return h('file:', '', S[1] || '', '', o(E) ? E : '/' + E)
      }
      function h(m, S, E, P, x) {
        return { scheme: m, user: S, host: E, port: P, path: x, relativePath: !1 }
      }
      function f(m) {
        if (a(m)) {
          const E = c('http:' + m)
          return (E.scheme = ''), E
        }
        if (o(m)) {
          const E = c('http://foo.com' + m)
          return (E.scheme = ''), (E.host = ''), E
        }
        if (u(m)) return p(m)
        if (s(m)) return c(m)
        const S = c('http://foo.com/' + m)
        return (S.scheme = ''), (S.host = ''), (S.relativePath = !0), S
      }
      function d(m) {
        if (m.endsWith('/..')) return m
        const S = m.lastIndexOf('/')
        return m.slice(0, S + 1)
      }
      function T(m, S) {
        !m.relativePath ||
          (y(S), m.path === '/' ? (m.path = S.path) : (m.path = d(S.path) + m.path), (m.relativePath = S.relativePath))
      }
      function y(m) {
        const { relativePath: S } = m,
          E = m.path.split('/')
        let P = 1,
          x = 0,
          D = !1
        for (let I = 1; I < E.length; I++) {
          const B = E[I]
          if (!B) {
            D = !0
            continue
          }
          if (((D = !1), B !== '.')) {
            if (B === '..') {
              x ? ((D = !0), x--, P--) : S && (E[P++] = B)
              continue
            }
            ;(E[P++] = B), x++
          }
        }
        let N = ''
        for (let I = 1; I < P; I++) N += '/' + E[I]
        ;(!N || (D && !N.endsWith('/..'))) && (N += '/'), (m.path = N)
      }
      function b(m, S) {
        if (!m && !S) return ''
        const E = f(m)
        if (S && !E.scheme) {
          const P = f(S)
          ;(E.scheme = P.scheme), E.host || ((E.user = P.user), (E.host = P.host), (E.port = P.port)), T(E, P)
        }
        if ((y(E), E.relativePath)) {
          const P = E.path.slice(1)
          return P ? (!(S || m).startsWith('.') || P.startsWith('.') ? P : './' + P) : '.'
        }
        return !E.scheme && !E.host ? E.path : `${E.scheme}//${E.user}${E.host}${E.port}${E.path}`
      }
      return b
    })
  })(Im),
    (function (t, e) {
      ;(function (r, i) {
        i(e, so.exports, Im.exports)
      })(jt, function (r, i, n) {
        function s(ae) {
          return ae && typeof ae == 'object' && 'default' in ae ? ae : { default: ae }
        }
        var a = s(n)
        function o(ae, de) {
          return de && !de.endsWith('/') && (de += '/'), a.default(ae, de)
        }
        function u(ae) {
          if (!ae) return ''
          const de = ae.lastIndexOf('/')
          return ae.slice(0, de + 1)
        }
        const c = 0,
          p = 1,
          h = 2,
          f = 3,
          d = 4,
          T = 1,
          y = 2
        function b(ae, de) {
          const be = m(ae, 0)
          if (be === ae.length) return ae
          de || (ae = ae.slice())
          for (let Pe = be; Pe < ae.length; Pe = m(ae, Pe + 1)) ae[Pe] = E(ae[Pe], de)
          return ae
        }
        function m(ae, de) {
          for (let be = de; be < ae.length; be++) if (!S(ae[be])) return be
          return ae.length
        }
        function S(ae) {
          for (let de = 1; de < ae.length; de++) if (ae[de][c] < ae[de - 1][c]) return !1
          return !0
        }
        function E(ae, de) {
          return de || (ae = ae.slice()), ae.sort(P)
        }
        function P(ae, de) {
          return ae[c] - de[c]
        }
        let x = !1
        function D(ae, de, be, Pe) {
          for (; be <= Pe; ) {
            const De = be + ((Pe - be) >> 1),
              Le = ae[De][c] - de
            if (Le === 0) return (x = !0), De
            Le < 0 ? (be = De + 1) : (Pe = De - 1)
          }
          return (x = !1), be - 1
        }
        function N(ae, de, be) {
          for (let Pe = be + 1; Pe < ae.length && ae[Pe][c] === de; be = Pe++);
          return be
        }
        function I(ae, de, be) {
          for (let Pe = be - 1; Pe >= 0 && ae[Pe][c] === de; be = Pe--);
          return be
        }
        function B() {
          return { lastKey: -1, lastNeedle: -1, lastIndex: -1 }
        }
        function K(ae, de, be, Pe) {
          const { lastKey: De, lastNeedle: Le, lastIndex: We } = be
          let A = 0,
            pe = ae.length - 1
          if (Pe === De) {
            if (de === Le) return (x = We !== -1 && ae[We][c] === de), We
            de >= Le ? (A = We === -1 ? 0 : We) : (pe = We)
          }
          return (be.lastKey = Pe), (be.lastNeedle = de), (be.lastIndex = D(ae, de, A, pe))
        }
        function Y(ae, de) {
          const be = de.map(H)
          for (let Pe = 0; Pe < ae.length; Pe++) {
            const De = ae[Pe]
            for (let Le = 0; Le < De.length; Le++) {
              const We = De[Le]
              if (We.length === 1) continue
              const A = We[p],
                pe = We[h],
                ie = We[f],
                L = be[A],
                F = L[pe] || (L[pe] = []),
                q = de[A],
                le = N(F, ie, K(F, ie, q, pe))
              C(F, (q.lastIndex = le + 1), [ie, Pe, We[c]])
            }
          }
          return be
        }
        function C(ae, de, be) {
          for (let Pe = ae.length; Pe > de; Pe--) ae[Pe] = ae[Pe - 1]
          ae[de] = be
        }
        function H() {
          return { __proto__: null }
        }
        const w = function (ae, de) {
          const be = typeof ae == 'string' ? JSON.parse(ae) : ae
          if (!('sections' in be)) return new ge(be, de)
          const Pe = [],
            De = [],
            Le = [],
            We = []
          J(be, de, Pe, De, Le, We, 0, 0, 1 / 0, 1 / 0)
          const A = { version: 3, file: be.file, names: We, sources: De, sourcesContent: Le, mappings: Pe }
          return r.presortedDecodedMap(A)
        }
        function J(ae, de, be, Pe, De, Le, We, A, pe, ie) {
          const { sections: L } = ae
          for (let F = 0; F < L.length; F++) {
            const { map: q, offset: le } = L[F]
            let fe = pe,
              ne = ie
            if (F + 1 < L.length) {
              const Se = L[F + 1].offset
              ;(fe = Math.min(pe, We + Se.line)),
                fe === pe ? (ne = Math.min(ie, A + Se.column)) : fe < pe && (ne = A + Se.column)
            }
            X(q, de, be, Pe, De, Le, We + le.line, A + le.column, fe, ne)
          }
        }
        function X(ae, de, be, Pe, De, Le, We, A, pe, ie) {
          if ('sections' in ae) return J(...arguments)
          const L = new ge(ae, de),
            F = Pe.length,
            q = Le.length,
            le = r.decodedMappings(L),
            { resolvedSources: fe, sourcesContent: ne } = L
          if ((G(Pe, fe), G(Le, L.names), ne)) G(De, ne)
          else for (let Se = 0; Se < fe.length; Se++) De.push(null)
          for (let Se = 0; Se < le.length; Se++) {
            const xe = We + Se
            if (xe > pe) return
            const Ae = Te(be, xe),
              Re = Se === 0 ? A : 0,
              O = le[Se]
            for (let g = 0; g < O.length; g++) {
              const v = O[g],
                z = Re + v[c]
              if (xe === pe && z >= ie) return
              if (v.length === 1) {
                Ae.push([z])
                continue
              }
              const ee = F + v[p],
                ue = v[h],
                Z = v[f]
              Ae.push(v.length === 4 ? [z, ee, ue, Z] : [z, ee, ue, Z, q + v[d]])
            }
          }
        }
        function G(ae, de) {
          for (let be = 0; be < de.length; be++) ae.push(de[be])
        }
        function Te(ae, de) {
          for (let be = ae.length; be <= de; be++) ae[be] = []
          return ae[de]
        }
        const ce = '`line` must be greater than 0 (lines start at line 1)',
          se = '`column` must be greater than or equal to 0 (columns start at column 0)',
          U = -1,
          W = 1
        ;(r.encodedMappings = void 0),
          (r.decodedMappings = void 0),
          (r.traceSegment = void 0),
          (r.originalPositionFor = void 0),
          (r.generatedPositionFor = void 0),
          (r.eachMapping = void 0),
          (r.sourceContentFor = void 0),
          (r.presortedDecodedMap = void 0),
          (r.decodedMap = void 0),
          (r.encodedMap = void 0)
        class ge {
          constructor(de, be) {
            ;(this._decodedMemo = B()), (this._bySources = void 0), (this._bySourceMemos = void 0)
            const Pe = typeof de == 'string'
            if (!Pe && de._decodedMemo) return de
            const De = Pe ? JSON.parse(de) : de,
              { version: Le, file: We, names: A, sourceRoot: pe, sources: ie, sourcesContent: L } = De
            ;(this.version = Le),
              (this.file = We),
              (this.names = A),
              (this.sourceRoot = pe),
              (this.sources = ie),
              (this.sourcesContent = L)
            const F = o(pe || '', u(be))
            this.resolvedSources = ie.map((le) => o(le || '', F))
            const { mappings: q } = De
            typeof q == 'string'
              ? ((this._encoded = q), (this._decoded = void 0))
              : ((this._encoded = void 0), (this._decoded = b(q, Pe)))
          }
        }
        ;(r.encodedMappings = (ae) => {
          var de
          return (de = ae._encoded) !== null && de !== void 0 ? de : (ae._encoded = i.encode(ae._decoded))
        }),
          (r.decodedMappings = (ae) => ae._decoded || (ae._decoded = i.decode(ae._encoded))),
          (r.traceSegment = (ae, de, be) => {
            const Pe = r.decodedMappings(ae)
            return de >= Pe.length ? null : ke(Pe[de], ae._decodedMemo, de, be, W)
          }),
          (r.originalPositionFor = (ae, { line: de, column: be, bias: Pe }) => {
            if ((de--, de < 0)) throw new Error(ce)
            if (be < 0) throw new Error(se)
            const De = r.decodedMappings(ae)
            if (de >= De.length) return ye(null, null, null, null)
            const Le = ke(De[de], ae._decodedMemo, de, be, Pe || W)
            if (Le == null || Le.length == 1) return ye(null, null, null, null)
            const { names: We, resolvedSources: A } = ae
            return ye(A[Le[p]], Le[h] + 1, Le[f], Le.length === 5 ? We[Le[d]] : null)
          }),
          (r.generatedPositionFor = (ae, { source: de, line: be, column: Pe, bias: De }) => {
            if ((be--, be < 0)) throw new Error(ce)
            if (Pe < 0) throw new Error(se)
            const { sources: Le, resolvedSources: We } = ae
            let A = Le.indexOf(de)
            if ((A === -1 && (A = We.indexOf(de)), A === -1)) return me(null, null)
            const pe = ae._bySources || (ae._bySources = Y(r.decodedMappings(ae), (ae._bySourceMemos = Le.map(B)))),
              ie = ae._bySourceMemos,
              L = pe[A][be]
            if (L == null) return me(null, null)
            const F = ke(L, ie[A], be, Pe, De || W)
            return F == null ? me(null, null) : me(F[T] + 1, F[y])
          }),
          (r.eachMapping = (ae, de) => {
            const be = r.decodedMappings(ae),
              { names: Pe, resolvedSources: De } = ae
            for (let Le = 0; Le < be.length; Le++) {
              const We = be[Le]
              for (let A = 0; A < We.length; A++) {
                const pe = We[A],
                  ie = Le + 1,
                  L = pe[0]
                let F = null,
                  q = null,
                  le = null,
                  fe = null
                pe.length !== 1 && ((F = De[pe[1]]), (q = pe[2] + 1), (le = pe[3])),
                  pe.length === 5 && (fe = Pe[pe[4]]),
                  de({
                    generatedLine: ie,
                    generatedColumn: L,
                    source: F,
                    originalLine: q,
                    originalColumn: le,
                    name: fe,
                  })
              }
            }
          }),
          (r.sourceContentFor = (ae, de) => {
            const { sources: be, resolvedSources: Pe, sourcesContent: De } = ae
            if (De == null) return null
            let Le = be.indexOf(de)
            return Le === -1 && (Le = Pe.indexOf(de)), Le === -1 ? null : De[Le]
          }),
          (r.presortedDecodedMap = (ae, de) => {
            const be = Object.assign({}, ae)
            be.mappings = []
            const Pe = new ge(be, de)
            return (Pe._decoded = ae.mappings), Pe
          }),
          (r.decodedMap = (ae) => ({
            version: 3,
            file: ae.file,
            names: ae.names,
            sourceRoot: ae.sourceRoot,
            sources: ae.sources,
            sourcesContent: ae.sourcesContent,
            mappings: r.decodedMappings(ae),
          })),
          (r.encodedMap = (ae) => ({
            version: 3,
            file: ae.file,
            names: ae.names,
            sourceRoot: ae.sourceRoot,
            sources: ae.sources,
            sourcesContent: ae.sourcesContent,
            mappings: r.encodedMappings(ae),
          }))
        function ye(ae, de, be, Pe) {
          return { source: ae, line: de, column: be, name: Pe }
        }
        function me(ae, de) {
          return { line: ae, column: de }
        }
        function ke(ae, de, be, Pe, De) {
          let Le = K(ae, Pe, de, be)
          return (
            x ? (Le = (De === U ? N : I)(ae, Pe, Le)) : De === U && Le++, Le === -1 || Le === ae.length ? null : ae[Le]
          )
        }
        ;(r.AnyMap = w),
          (r.GREATEST_LOWER_BOUND = W),
          (r.LEAST_UPPER_BOUND = U),
          (r.TraceMap = ge),
          Object.defineProperty(r, '__esModule', { value: !0 })
      })
    })(lc, lc.exports),
    (function (t, e) {
      ;(function (r, i) {
        i(e, oc.exports, so.exports, lc.exports)
      })(jt, function (r, i, n, s) {
        ;(r.addSegment = void 0),
          (r.addMapping = void 0),
          (r.maybeAddSegment = void 0),
          (r.maybeAddMapping = void 0),
          (r.setSourceContent = void 0),
          (r.toDecodedMap = void 0),
          (r.toEncodedMap = void 0),
          (r.fromMap = void 0),
          (r.allMappings = void 0)
        let f
        class d {
          constructor({ file: N, sourceRoot: I } = {}) {
            ;(this._names = new i.SetArray()),
              (this._sources = new i.SetArray()),
              (this._sourcesContent = []),
              (this._mappings = []),
              (this.file = N),
              (this.sourceRoot = I)
          }
        }
        ;(r.addSegment = (D, N, I, B, K, Y, C, H) => f(!1, D, N, I, B, K, Y, C, H)),
          (r.maybeAddSegment = (D, N, I, B, K, Y, C, H) => f(!0, D, N, I, B, K, Y, C, H)),
          (r.addMapping = (D, N) => x(!1, D, N)),
          (r.maybeAddMapping = (D, N) => x(!0, D, N)),
          (r.setSourceContent = (D, N, I) => {
            const { _sources: B, _sourcesContent: K } = D
            K[i.put(B, N)] = I
          }),
          (r.toDecodedMap = (D) => {
            const { file: N, sourceRoot: I, _mappings: B, _sources: K, _sourcesContent: Y, _names: C } = D
            return (
              m(B),
              {
                version: 3,
                file: N || void 0,
                names: C.array,
                sourceRoot: I || void 0,
                sources: K.array,
                sourcesContent: Y,
                mappings: B,
              }
            )
          }),
          (r.toEncodedMap = (D) => {
            const N = r.toDecodedMap(D)
            return Object.assign(Object.assign({}, N), { mappings: n.encode(N.mappings) })
          }),
          (r.allMappings = (D) => {
            const N = [],
              { _mappings: I, _sources: B, _names: K } = D
            for (let Y = 0; Y < I.length; Y++) {
              const C = I[Y]
              for (let H = 0; H < C.length; H++) {
                const w = C[H],
                  J = { line: Y + 1, column: w[0] }
                let X, G, Te
                w.length !== 1 &&
                  ((X = B.array[w[1]]), (G = { line: w[2] + 1, column: w[3] }), w.length === 5 && (Te = K.array[w[4]])),
                  N.push({ generated: J, source: X, original: G, name: Te })
              }
            }
            return N
          }),
          (r.fromMap = (D) => {
            const N = new s.TraceMap(D),
              I = new d({ file: N.file, sourceRoot: N.sourceRoot })
            return (
              S(I._names, N.names),
              S(I._sources, N.sources),
              (I._sourcesContent = N.sourcesContent || N.sources.map(() => null)),
              (I._mappings = s.decodedMappings(N)),
              I
            )
          }),
          (f = (D, N, I, B, K, Y, C, H, w) => {
            const { _mappings: J, _sources: X, _sourcesContent: G, _names: Te } = N,
              ce = T(J, I),
              se = y(ce, B)
            if (!K) return D && E(ce, se) ? void 0 : b(ce, se, [B])
            const U = i.put(X, K),
              W = H ? i.put(Te, H) : -1
            if ((U === G.length && (G[U] = w != null ? w : null), !(D && P(ce, se, U, Y, C, W))))
              return b(ce, se, H ? [B, U, Y, C, W] : [B, U, Y, C])
          })
        function T(D, N) {
          for (let I = D.length; I <= N; I++) D[I] = []
          return D[N]
        }
        function y(D, N) {
          let I = D.length
          for (let B = I - 1; B >= 0; I = B--) {
            const K = D[B]
            if (N >= K[0]) break
          }
          return I
        }
        function b(D, N, I) {
          for (let B = D.length; B > N; B--) D[B] = D[B - 1]
          D[N] = I
        }
        function m(D) {
          const { length: N } = D
          let I = N
          for (let B = I - 1; B >= 0 && !(D[B].length > 0); I = B, B--);
          I < N && (D.length = I)
        }
        function S(D, N) {
          for (let I = 0; I < N.length; I++) i.put(D, N[I])
        }
        function E(D, N) {
          return N === 0 ? !0 : D[N - 1].length === 1
        }
        function P(D, N, I, B, K, Y) {
          if (N === 0) return !1
          const C = D[N - 1]
          return C.length === 1 ? !1 : I === C[1] && B === C[2] && K === C[3] && Y === (C.length === 5 ? C[4] : -1)
        }
        function x(D, N, I) {
          const { generated: B, source: K, original: Y, name: C, content: H } = I
          if (!K) return f(D, N, B.line - 1, B.column, null, null, null, null, null)
          const w = K
          return f(D, N, B.line - 1, B.column, w, Y.line - 1, Y.column, C, H)
        }
        ;(r.GenMapping = d), Object.defineProperty(r, '__esModule', { value: !0 })
      })
    })(ac, ac.exports),
    Object.defineProperty(no, '__esModule', { value: !0 }),
    (no.default = void 0)
  var Gi = ac.exports
  class i6 {
    constructor(e, r) {
      var i
      ;(this._map = void 0),
        (this._rawMappings = void 0),
        (this._sourceFileName = void 0),
        (this._lastGenLine = 0),
        (this._lastSourceLine = 0),
        (this._lastSourceColumn = 0)
      const n = (this._map = new Gi.GenMapping({ sourceRoot: e.sourceRoot }))
      ;(this._sourceFileName = (i = e.sourceFileName) == null ? void 0 : i.replace(/\\/g, '/')),
        (this._rawMappings = void 0),
        typeof r == 'string'
          ? (0, Gi.setSourceContent)(n, this._sourceFileName, r)
          : typeof r == 'object' &&
            Object.keys(r).forEach((s) => {
              ;(0, Gi.setSourceContent)(n, s.replace(/\\/g, '/'), r[s])
            })
    }
    get() {
      return (0, Gi.toEncodedMap)(this._map)
    }
    getDecoded() {
      return (0, Gi.toDecodedMap)(this._map)
    }
    getRawMappings() {
      return this._rawMappings || (this._rawMappings = (0, Gi.allMappings)(this._map))
    }
    mark(e, r, i, n, s) {
      ;(this._rawMappings = void 0),
        (0, Gi.maybeAddMapping)(this._map, {
          name: n,
          generated: e,
          source: r == null ? void 0 : (s == null ? void 0 : s.replace(/\\/g, '/')) || this._sourceFileName,
          original: r == null ? void 0 : { line: r, column: i },
        })
    }
  }
  no.default = i6
  var ao = {},
    oo = {}
  Object.defineProperty(oo, '__esModule', { value: !0 }), (oo.default = void 0)
  function km() {
    return { identifierName: void 0, line: void 0, column: void 0, filename: void 0 }
  }
  const n6 = /^[ \t]+$/
  class s6 {
    constructor(e) {
      ;(this._map = null),
        (this._buf = ''),
        (this._last = 0),
        (this._queue = []),
        (this._position = { line: 1, column: 0 }),
        (this._sourcePosition = km()),
        (this._disallowedPop = null),
        (this._map = e)
    }
    get() {
      this._flush()
      const e = this._map,
        r = {
          code: this._buf.trimRight(),
          decodedMap: e == null ? void 0 : e.getDecoded(),
          get map() {
            return (r.map = e ? e.get() : null)
          },
          set map(i) {
            Object.defineProperty(r, 'map', { value: i, writable: !0 })
          },
          get rawMappings() {
            return (r.rawMappings = e == null ? void 0 : e.getRawMappings())
          },
          set rawMappings(i) {
            Object.defineProperty(r, 'rawMappings', { value: i, writable: !0 })
          },
        }
      return r
    }
    append(e) {
      this._flush()
      const { line: r, column: i, filename: n, identifierName: s } = this._sourcePosition
      this._append(e, r, i, s, n)
    }
    queue(e) {
      if (
        e ===
        `
`
      )
        for (; this._queue.length > 0 && n6.test(this._queue[0][0]); ) this._queue.shift()
      const { line: r, column: i, filename: n, identifierName: s } = this._sourcePosition
      this._queue.unshift([e, r, i, s, n])
    }
    queueIndentation(e) {
      this._queue.unshift([e, void 0, void 0, void 0, void 0])
    }
    _flush() {
      let e
      for (; (e = this._queue.pop()); ) this._append(...e)
    }
    _append(e, r, i, n, s) {
      ;(this._buf += e), (this._last = e.charCodeAt(e.length - 1))
      let a = e.indexOf(`
`),
        o = 0
      for (a !== 0 && this._mark(r, i, n, s); a !== -1; )
        this._position.line++,
          (this._position.column = 0),
          (o = a + 1),
          o < e.length && this._mark(++r, 0, n, s),
          (a = e.indexOf(
            `
`,
            o
          ))
      this._position.column += e.length - o
    }
    _mark(e, r, i, n) {
      var s
      ;(s = this._map) == null || s.mark(this._position, e, r, i, n)
    }
    removeTrailingNewline() {
      this._queue.length > 0 &&
        this._queue[0][0] ===
          `
` &&
        this._queue.shift()
    }
    removeLastSemicolon() {
      this._queue.length > 0 && this._queue[0][0] === ';' && this._queue.shift()
    }
    getLastChar() {
      let e
      return this._queue.length > 0 ? (e = this._queue[0][0].charCodeAt(0)) : (e = this._last), e
    }
    endsWithCharAndNewline() {
      const e = this._queue
      if (e.length > 0) return e[0][0].charCodeAt(0) !== 10 ? void 0 : e.length > 1 ? e[1][0].charCodeAt(0) : this._last
    }
    hasContent() {
      return this._queue.length > 0 || !!this._last
    }
    exactSource(e, r) {
      this.source('start', e), r(), this.source('end', e), this._disallowPop('start', e)
    }
    source(e, r) {
      ;(e && !r) || this._normalizePosition(e, r, this._sourcePosition)
    }
    withSource(e, r, i) {
      if (!this._map) return i()
      const n = this._sourcePosition.line,
        s = this._sourcePosition.column,
        a = this._sourcePosition.filename,
        o = this._sourcePosition.identifierName
      this.source(e, r),
        i(),
        (!this._disallowedPop ||
          this._disallowedPop.line !== n ||
          this._disallowedPop.column !== s ||
          this._disallowedPop.filename !== a) &&
          ((this._sourcePosition.line = n),
          (this._sourcePosition.column = s),
          (this._sourcePosition.filename = a),
          (this._sourcePosition.identifierName = o),
          (this._disallowedPop = null))
    }
    _disallowPop(e, r) {
      ;(e && !r) || (this._disallowedPop = this._normalizePosition(e, r, km()))
    }
    _normalizePosition(e, r, i) {
      const n = r ? r[e] : null
      return (
        (i.identifierName = (e === 'start' && (r == null ? void 0 : r.identifierName)) || void 0),
        (i.line = n == null ? void 0 : n.line),
        (i.column = n == null ? void 0 : n.column),
        (i.filename = r == null ? void 0 : r.filename),
        i
      )
    }
    getCurrentColumn() {
      const e = this._queue.reduce((i, n) => n[0] + i, ''),
        r = e.lastIndexOf(`
`)
      return r === -1 ? this._position.column + e.length : e.length - 1 - r
    }
    getCurrentLine() {
      const e = this._queue.reduce((i, n) => n[0] + i, '')
      let r = 0
      for (let i = 0; i < e.length; i++)
        e[i] ===
          `
` && r++
      return this._position.line + r
    }
  }
  oo.default = s6
  var Ji = {},
    kn = {}
  Object.defineProperty(kn, '__esModule', { value: !0 }), (kn.nodes = kn.list = void 0)
  var a6 = st
  const {
    FLIPPED_ALIAS_KEYS: o6,
    isArrayExpression: l6,
    isAssignmentExpression: Nm,
    isBinary: Om,
    isBlockStatement: u6,
    isCallExpression: Dm,
    isFunction: bs,
    isIdentifier: lo,
    isLiteral: c6,
    isMemberExpression: uc,
    isObjectExpression: p6,
    isOptionalCallExpression: f6,
    isOptionalMemberExpression: h6,
    isStringLiteral: d6,
  } = a6
  function Zi(t, e = {}) {
    return (
      uc(t) || h6(t)
        ? (Zi(t.object, e), t.computed && Zi(t.property, e))
        : Om(t) || Nm(t)
        ? (Zi(t.left, e), Zi(t.right, e))
        : Dm(t) || f6(t)
        ? ((e.hasCall = !0), Zi(t.callee, e))
        : bs(t)
        ? (e.hasFunction = !0)
        : lo(t) && (e.hasHelper = e.hasHelper || zr(t.callee)),
      e
    )
  }
  function zr(t) {
    return uc(t)
      ? zr(t.object) || zr(t.property)
      : lo(t)
      ? t.name === 'require' || t.name[0] === '_'
      : Dm(t)
      ? zr(t.callee)
      : Om(t) || Nm(t)
      ? (lo(t.left) && zr(t.left)) || zr(t.right)
      : !1
  }
  function m6(t) {
    return c6(t) || p6(t) || l6(t) || lo(t) || uc(t)
  }
  const fi = {
    AssignmentExpression(t) {
      const e = Zi(t.right)
      if ((e.hasCall && e.hasHelper) || e.hasFunction) return { before: e.hasFunction, after: !0 }
    },
    SwitchCase(t, e) {
      return {
        before: !!t.consequent.length || e.cases[0] === t,
        after: !t.consequent.length && e.cases[e.cases.length - 1] === t,
      }
    },
    LogicalExpression(t) {
      if (bs(t.left) || bs(t.right)) return { after: !0 }
    },
    Literal(t) {
      if (d6(t) && t.value === 'use strict') return { after: !0 }
    },
    CallExpression(t) {
      if (bs(t.callee) || zr(t)) return { before: !0, after: !0 }
    },
    OptionalCallExpression(t) {
      if (bs(t.callee)) return { before: !0, after: !0 }
    },
    VariableDeclaration(t) {
      for (let e = 0; e < t.declarations.length; e++) {
        const r = t.declarations[e]
        let i = zr(r.id) && !m6(r.init)
        if (!i) {
          const n = Zi(r.init)
          i = (zr(r.init) && n.hasCall) || n.hasFunction
        }
        if (i) return { before: !0, after: !0 }
      }
    },
    IfStatement(t) {
      if (u6(t.consequent)) return { before: !0, after: !0 }
    },
  }
  ;(kn.nodes = fi),
    (fi.ObjectProperty =
      fi.ObjectTypeProperty =
      fi.ObjectMethod =
        function (t, e) {
          if (e.properties[0] === t) return { before: !0 }
        }),
    (fi.ObjectTypeCallProperty = function (t, e) {
      var r
      if (e.callProperties[0] === t && !((r = e.properties) != null && r.length)) return { before: !0 }
    }),
    (fi.ObjectTypeIndexer = function (t, e) {
      var r, i
      if (
        e.indexers[0] === t &&
        !((r = e.properties) != null && r.length) &&
        !((i = e.callProperties) != null && i.length)
      )
        return { before: !0 }
    }),
    (fi.ObjectTypeInternalSlot = function (t, e) {
      var r, i, n
      if (
        e.internalSlots[0] === t &&
        !((r = e.properties) != null && r.length) &&
        !((i = e.callProperties) != null && i.length) &&
        !((n = e.indexers) != null && n.length)
      )
        return { before: !0 }
    })
  const y6 = {
    VariableDeclaration(t) {
      return t.declarations.map((e) => e.init)
    },
    ArrayExpression(t) {
      return t.elements
    },
    ObjectExpression(t) {
      return t.properties
    },
  }
  ;(kn.list = y6),
    [
      ['Function', !0],
      ['Class', !0],
      ['Loop', !0],
      ['LabeledStatement', !0],
      ['SwitchStatement', !0],
      ['TryStatement', !0],
    ].forEach(function ([t, e]) {
      typeof e == 'boolean' && (e = { after: e, before: e }),
        [t].concat(o6[t] || []).forEach(function (r) {
          fi[r] = function () {
            return e
          }
        })
    })
  var yt = {}
  Object.defineProperty(yt, '__esModule', { value: !0 }),
    (yt.ArrowFunctionExpression = u4),
    (yt.AssignmentExpression = p4),
    (yt.Binary = G6),
    (yt.BinaryExpression = n4),
    (yt.ClassExpression = o4),
    (yt.ConditionalExpression = yc),
    (yt.DoExpression = X6),
    (yt.FunctionExpression = l4),
    (yt.FunctionTypeAnnotation = Y6),
    (yt.Identifier = h4),
    (yt.LogicalExpression = f4),
    (yt.NullableTypeAnnotation = W6),
    (yt.ObjectExpression = q6),
    (yt.OptionalIndexedAccessType = Z6),
    (yt.OptionalCallExpression = yt.OptionalMemberExpression = c4),
    (yt.SequenceExpression = s4),
    (yt.TSAsExpression = Q6),
    (yt.TSInferType = r4),
    (yt.TSInstantiationExpression = i4),
    (yt.TSTypeAssertion = e4),
    (yt.TSIntersectionType = yt.TSUnionType = t4),
    (yt.UnaryLike = Xm),
    (yt.IntersectionTypeAnnotation = yt.UnionTypeAnnotation = J6),
    (yt.UpdateExpression = H6),
    (yt.AwaitExpression = yt.YieldExpression = a4)
  var g6 = st
  const {
      isArrayTypeAnnotation: cc,
      isArrowFunctionExpression: Bm,
      isAssignmentExpression: Lm,
      isAwaitExpression: pc,
      isBinary: uo,
      isBinaryExpression: Mm,
      isUpdateExpression: T6,
      isCallExpression: fc,
      isClassDeclaration: b6,
      isClassExpression: Fm,
      isConditional: S6,
      isConditionalExpression: $m,
      isExportDeclaration: v6,
      isExportDefaultDeclaration: E6,
      isExpressionStatement: Rm,
      isFor: P6,
      isForInStatement: jm,
      isForOfStatement: _m,
      isForStatement: Vm,
      isFunctionExpression: w6,
      isIfStatement: A6,
      isIndexedAccessType: C6,
      isIntersectionTypeAnnotation: Um,
      isLogicalExpression: co,
      isMemberExpression: hc,
      isNewExpression: dc,
      isNullableTypeAnnotation: x6,
      isObjectPattern: I6,
      isOptionalCallExpression: zm,
      isOptionalMemberExpression: Km,
      isReturnStatement: k6,
      isSequenceExpression: N6,
      isSwitchStatement: O6,
      isTSArrayType: Wm,
      isTSAsExpression: D6,
      isTSInstantiationExpression: B6,
      isTSIntersectionType: L6,
      isTSNonNullExpression: M6,
      isTSOptionalType: Ym,
      isTSRestType: F6,
      isTSTypeAssertion: $6,
      isTSUnionType: R6,
      isTaggedTemplateExpression: j6,
      isThrowStatement: _6,
      isTypeAnnotation: V6,
      isUnaryLike: mc,
      isUnionTypeAnnotation: Hm,
      isVariableDeclarator: U6,
      isWhileStatement: z6,
      isYieldExpression: K6,
    } = g6,
    qm = {
      '||': 0,
      '??': 0,
      '&&': 1,
      '|': 2,
      '^': 3,
      '&': 4,
      '==': 5,
      '===': 5,
      '!=': 5,
      '!==': 5,
      '<': 6,
      '>': 6,
      '<=': 6,
      '>=': 6,
      in: 6,
      instanceof: 6,
      '>>': 7,
      '<<': 7,
      '>>>': 7,
      '+': 8,
      '-': 8,
      '*': 9,
      '/': 9,
      '%': 9,
      '**': 10,
    },
    po = (t, e) => (b6(e) || Fm(e)) && e.superClass === t,
    Ss = (t, e) =>
      ((hc(e) || Km(e)) && e.object === t) ||
      ((fc(e) || zm(e) || dc(e)) && e.callee === t) ||
      (j6(e) && e.tag === t) ||
      M6(e)
  function W6(t, e) {
    return cc(e)
  }
  function Y6(t, e, r) {
    return Hm(e) || Um(e) || cc(e) || (V6(e) && Bm(r[r.length - 3]))
  }
  function H6(t, e) {
    return Ss(t, e) || po(t, e)
  }
  function q6(t, e, r) {
    return vs(r, { expressionStatement: !0, arrowBody: !0 })
  }
  function X6(t, e, r) {
    return !t.async && vs(r, { expressionStatement: !0 })
  }
  function G6(t, e) {
    if (t.operator === '**' && Mm(e, { operator: '**' })) return e.left === t
    if (po(t, e) || Ss(t, e) || mc(e) || pc(e)) return !0
    if (uo(e)) {
      const r = e.operator,
        i = qm[r],
        n = t.operator,
        s = qm[n]
      if ((i === s && e.right === t && !co(e)) || i > s) return !0
    }
  }
  function J6(t, e) {
    return cc(e) || x6(e) || Um(e) || Hm(e)
  }
  function Z6(t, e) {
    return C6(e, { objectType: t })
  }
  function Q6() {
    return !0
  }
  function e4() {
    return !0
  }
  function t4(t, e) {
    return Wm(e) || Ym(e) || L6(e) || R6(e) || F6(e)
  }
  function r4(t, e) {
    return Wm(e) || Ym(e)
  }
  function i4(t, e) {
    return (fc(e) || zm(e) || dc(e) || B6(e)) && !!e.typeParameters
  }
  function n4(t, e) {
    return t.operator === 'in' && (U6(e) || P6(e))
  }
  function s4(t, e) {
    return !(
      Vm(e) ||
      _6(e) ||
      k6(e) ||
      (A6(e) && e.test === t) ||
      (z6(e) && e.test === t) ||
      (jm(e) && e.right === t) ||
      (O6(e) && e.discriminant === t) ||
      (Rm(e) && e.expression === t)
    )
  }
  function a4(t, e) {
    return uo(e) || mc(e) || Ss(t, e) || (pc(e) && K6(t)) || ($m(e) && t === e.test) || po(t, e)
  }
  function o4(t, e, r) {
    return vs(r, { expressionStatement: !0, exportDefault: !0 })
  }
  function Xm(t, e) {
    return Ss(t, e) || Mm(e, { operator: '**', left: t }) || po(t, e)
  }
  function l4(t, e, r) {
    return vs(r, { expressionStatement: !0, exportDefault: !0 })
  }
  function u4(t, e) {
    return v6(e) || yc(t, e)
  }
  function yc(t, e) {
    return mc(e) || uo(e) || $m(e, { test: t }) || pc(e) || $6(e) || D6(e) ? !0 : Xm(t, e)
  }
  function c4(t, e) {
    return fc(e, { callee: t }) || hc(e, { object: t })
  }
  function p4(t, e) {
    return I6(t.left) ? !0 : yc(t, e)
  }
  function f4(t, e) {
    switch (t.operator) {
      case '||':
        return co(e) ? e.operator === '??' || e.operator === '&&' : !1
      case '&&':
        return co(e, { operator: '??' })
      case '??':
        return co(e) && e.operator !== '??'
    }
  }
  function h4(t, e, r) {
    var i
    if (
      (i = t.extra) != null &&
      i.parenthesized &&
      Lm(e, { left: t }) &&
      (w6(e.right) || Fm(e.right)) &&
      e.right.id == null
    )
      return !0
    if (t.name === 'let') {
      const n = hc(e, { object: t, computed: !0 }) || Km(e, { object: t, computed: !0, optional: !1 })
      return vs(r, { expressionStatement: n, forHead: n, forInHead: n, forOfHead: !0 })
    }
    return t.name === 'async' && _m(e) && t === e.left
  }
  function vs(
    t,
    {
      expressionStatement: e = !1,
      arrowBody: r = !1,
      exportDefault: i = !1,
      forHead: n = !1,
      forInHead: s = !1,
      forOfHead: a = !1,
    }
  ) {
    let o = t.length - 1,
      u = t[o]
    o--
    let c = t[o]
    for (; o >= 0; ) {
      if (
        (e && Rm(c, { expression: u })) ||
        (i && E6(c, { declaration: u })) ||
        (r && Bm(c, { body: u })) ||
        (n && Vm(c, { init: u })) ||
        (s && jm(c, { left: u })) ||
        (a && _m(c, { left: u }))
      )
        return !0
      if (
        (Ss(u, c) && !dc(c)) ||
        (N6(c) && c.expressions[0] === u) ||
        (T6(c) && !c.prefix) ||
        S6(c, { test: u }) ||
        uo(c, { left: u }) ||
        Lm(c, { left: u })
      )
        (u = c), o--, (c = t[o])
      else return !1
    }
    return !1
  }
  Object.defineProperty(Ji, '__esModule', { value: !0 }),
    (Ji.needsParens = C4),
    (Ji.needsWhitespace = fo),
    (Ji.needsWhitespaceAfter = A4),
    (Ji.needsWhitespaceBefore = w4)
  var Gm = kn,
    d4 = yt,
    m4 = st
  const {
    FLIPPED_ALIAS_KEYS: y4,
    isCallExpression: g4,
    isExpressionStatement: T4,
    isMemberExpression: b4,
    isNewExpression: S4,
  } = m4
  function gc(t) {
    const e = {}
    function r(i, n) {
      const s = e[i]
      e[i] = s
        ? function (a, o, u) {
            const c = s(a, o, u)
            return c == null ? n(a, o, u) : c
          }
        : n
    }
    for (const i of Object.keys(t)) {
      const n = y4[i]
      if (n) for (const s of n) r(s, t[i])
      else r(i, t[i])
    }
    return e
  }
  const v4 = gc(d4),
    E4 = gc(Gm.nodes),
    P4 = gc(Gm.list)
  function Tc(t, e, r, i) {
    const n = t[e.type]
    return n ? n(e, r, i) : null
  }
  function Jm(t) {
    return g4(t) ? !0 : b4(t) && Jm(t.object)
  }
  function fo(t, e, r) {
    if (!t) return 0
    T4(t) && (t = t.expression)
    let i = Tc(E4, t, e)
    if (!i) {
      const n = Tc(P4, t, e)
      if (n) for (let s = 0; s < n.length && ((i = fo(n[s], t, r)), !i); s++);
    }
    return (typeof i == 'object' && i !== null && i[r]) || 0
  }
  function w4(t, e) {
    return fo(t, e, 'before')
  }
  function A4(t, e) {
    return fo(t, e, 'after')
  }
  function C4(t, e, r) {
    return e ? (S4(e) && e.callee === t && Jm(t) ? !0 : Tc(v4, t, e, r)) : !1
  }
  var Zm = {},
    Es = {}
  Object.defineProperty(Es, '__esModule', { value: !0 }),
    (Es.TaggedTemplateExpression = x4),
    (Es.TemplateElement = I4),
    (Es.TemplateLiteral = k4)
  function x4(t) {
    this.print(t.tag, t), this.print(t.typeParameters, t), this.print(t.quasi, t)
  }
  function I4(t, e) {
    const r = e.quasis[0] === t,
      i = e.quasis[e.quasis.length - 1] === t,
      n = (r ? '`' : '}') + t.value.raw + (i ? '`' : '${')
    this.token(n)
  }
  function k4(t) {
    const e = t.quasis
    for (let r = 0; r < e.length; r++) this.print(e[r], t), r + 1 < e.length && this.print(t.expressions[r], t)
  }
  var ht = {}
  Object.defineProperty(ht, '__esModule', { value: !0 }),
    (ht.LogicalExpression = ht.BinaryExpression = ht.AssignmentExpression = e$),
    (ht.AssignmentPattern = Q4),
    (ht.AwaitExpression = void 0),
    (ht.BindExpression = t$),
    (ht.CallExpression = H4),
    (ht.ConditionalExpression = R4),
    (ht.Decorator = K4),
    (ht.DoExpression = M4),
    (ht.EmptyStatement = J4),
    (ht.ExpressionStatement = Z4),
    (ht.Import = q4),
    (ht.MemberExpression = r$),
    (ht.MetaProperty = i$),
    (ht.ModuleExpression = a$),
    (ht.NewExpression = j4),
    (ht.OptionalCallExpression = Y4),
    (ht.OptionalMemberExpression = W4),
    (ht.ParenthesizedExpression = F4),
    (ht.PrivateName = n$),
    (ht.SequenceExpression = _4),
    (ht.Super = U4),
    (ht.ThisExpression = V4),
    (ht.UnaryExpression = L4),
    (ht.UpdateExpression = $4),
    (ht.V8IntrinsicIdentifier = s$),
    (ht.YieldExpression = void 0)
  var N4 = st,
    O4 = Ji
  const { isCallExpression: D4, isLiteral: Qm, isMemberExpression: bc, isNewExpression: B4 } = N4
  function L4(t) {
    t.operator === 'void' || t.operator === 'delete' || t.operator === 'typeof' || t.operator === 'throw'
      ? (this.word(t.operator), this.space())
      : this.token(t.operator),
      this.print(t.argument, t)
  }
  function M4(t) {
    t.async && (this.word('async'), this.space()), this.word('do'), this.space(), this.print(t.body, t)
  }
  function F4(t) {
    this.token('('), this.print(t.expression, t), this.token(')')
  }
  function $4(t) {
    t.prefix
      ? (this.token(t.operator), this.print(t.argument, t))
      : (this.startTerminatorless(!0), this.print(t.argument, t), this.endTerminatorless(), this.token(t.operator))
  }
  function R4(t) {
    this.print(t.test, t),
      this.space(),
      this.token('?'),
      this.space(),
      this.print(t.consequent, t),
      this.space(),
      this.token(':'),
      this.space(),
      this.print(t.alternate, t)
  }
  function j4(t, e) {
    this.word('new'),
      this.space(),
      this.print(t.callee, t),
      !(this.format.minified && t.arguments.length === 0 && !t.optional && !D4(e, { callee: t }) && !bc(e) && !B4(e)) &&
        (this.print(t.typeArguments, t),
        this.print(t.typeParameters, t),
        t.optional && this.token('?.'),
        this.token('('),
        this.printList(t.arguments, t),
        this.token(')'))
  }
  function _4(t) {
    this.printList(t.expressions, t)
  }
  function V4() {
    this.word('this')
  }
  function U4() {
    this.word('super')
  }
  function ey(t) {
    switch (t.type) {
      case 'Identifier':
        return !0
      case 'MemberExpression':
        return !t.computed && t.property.type === 'Identifier' && ey(t.object)
      default:
        return !1
    }
  }
  function z4(t) {
    return t.type === 'CallExpression' && (t = t.callee), t.type === 'ParenthesizedExpression' ? !1 : !ey(t)
  }
  function K4(t) {
    this.token('@')
    const { expression: e } = t
    z4(e) ? (this.token('('), this.print(e, t), this.token(')')) : this.print(e, t), this.newline()
  }
  function W4(t) {
    if ((this.print(t.object, t), !t.computed && bc(t.property)))
      throw new TypeError('Got a MemberExpression for MemberExpression property')
    let e = t.computed
    Qm(t.property) && typeof t.property.value == 'number' && (e = !0),
      t.optional && this.token('?.'),
      e
        ? (this.token('['), this.print(t.property, t), this.token(']'))
        : (t.optional || this.token('.'), this.print(t.property, t))
  }
  function Y4(t) {
    this.print(t.callee, t),
      this.print(t.typeArguments, t),
      this.print(t.typeParameters, t),
      t.optional && this.token('?.'),
      this.token('('),
      this.printList(t.arguments, t),
      this.token(')')
  }
  function H4(t) {
    this.print(t.callee, t),
      this.print(t.typeArguments, t),
      this.print(t.typeParameters, t),
      this.token('('),
      this.printList(t.arguments, t),
      this.token(')')
  }
  function q4() {
    this.word('import')
  }
  function ty(t) {
    return function (e) {
      if ((this.word(t), e.delegate && this.token('*'), e.argument)) {
        this.space()
        const r = this.startTerminatorless()
        this.print(e.argument, e), this.endTerminatorless(r)
      }
    }
  }
  const X4 = ty('yield')
  ht.YieldExpression = X4
  const G4 = ty('await')
  ht.AwaitExpression = G4
  function J4() {
    this.semicolon(!0)
  }
  function Z4(t) {
    this.print(t.expression, t), this.semicolon()
  }
  function Q4(t) {
    this.print(t.left, t),
      t.left.optional && this.token('?'),
      this.print(t.left.typeAnnotation, t),
      this.space(),
      this.token('='),
      this.space(),
      this.print(t.right, t)
  }
  function e$(t, e) {
    const r = this.inForStatementInitCounter && t.operator === 'in' && !O4.needsParens(t, e)
    r && this.token('('),
      this.print(t.left, t),
      this.space(),
      t.operator === 'in' || t.operator === 'instanceof' ? this.word(t.operator) : this.token(t.operator),
      this.space(),
      this.print(t.right, t),
      r && this.token(')')
  }
  function t$(t) {
    this.print(t.object, t), this.token('::'), this.print(t.callee, t)
  }
  function r$(t) {
    if ((this.print(t.object, t), !t.computed && bc(t.property)))
      throw new TypeError('Got a MemberExpression for MemberExpression property')
    let e = t.computed
    Qm(t.property) && typeof t.property.value == 'number' && (e = !0),
      e ? (this.token('['), this.print(t.property, t), this.token(']')) : (this.token('.'), this.print(t.property, t))
  }
  function i$(t) {
    this.print(t.meta, t), this.token('.'), this.print(t.property, t)
  }
  function n$(t) {
    this.token('#'), this.print(t.id, t)
  }
  function s$(t) {
    this.token('%'), this.word(t.name)
  }
  function a$(t) {
    this.word('module'),
      this.space(),
      this.token('{'),
      t.body.body.length === 0
        ? this.token('}')
        : (this.newline(), this.printSequence(t.body.body, t, { indent: !0 }), this.rightBrace())
  }
  var St = {}
  Object.defineProperty(St, '__esModule', { value: !0 }),
    (St.BreakStatement = void 0),
    (St.CatchClause = w$),
    (St.ContinueStatement = void 0),
    (St.DebuggerStatement = x$),
    (St.DoWhileStatement = g$),
    (St.ForOfStatement = St.ForInStatement = void 0),
    (St.ForStatement = h$),
    (St.IfStatement = f$),
    (St.LabeledStatement = E$),
    (St.ReturnStatement = void 0),
    (St.SwitchCase = C$),
    (St.SwitchStatement = A$),
    (St.ThrowStatement = void 0),
    (St.TryStatement = P$),
    (St.VariableDeclaration = N$),
    (St.VariableDeclarator = O$),
    (St.WhileStatement = d$),
    (St.WithStatement = p$)
  var o$ = st
  const { isFor: ry, isForStatement: l$, isIfStatement: u$, isStatement: c$ } = o$
  function p$(t) {
    this.word('with'), this.space(), this.token('('), this.print(t.object, t), this.token(')'), this.printBlock(t)
  }
  function f$(t) {
    this.word('if'), this.space(), this.token('('), this.print(t.test, t), this.token(')'), this.space()
    const e = t.alternate && u$(iy(t.consequent))
    e && (this.token('{'), this.newline(), this.indent()),
      this.printAndIndentOnComments(t.consequent, t),
      e && (this.dedent(), this.newline(), this.token('}')),
      t.alternate &&
        (this.endsWith(125) && this.space(),
        this.word('else'),
        this.space(),
        this.printAndIndentOnComments(t.alternate, t))
  }
  function iy(t) {
    return c$(t.body) ? iy(t.body) : t
  }
  function h$(t) {
    this.word('for'),
      this.space(),
      this.token('('),
      this.inForStatementInitCounter++,
      this.print(t.init, t),
      this.inForStatementInitCounter--,
      this.token(';'),
      t.test && (this.space(), this.print(t.test, t)),
      this.token(';'),
      t.update && (this.space(), this.print(t.update, t)),
      this.token(')'),
      this.printBlock(t)
  }
  function d$(t) {
    this.word('while'), this.space(), this.token('('), this.print(t.test, t), this.token(')'), this.printBlock(t)
  }
  const ny = function (t) {
      return function (e) {
        this.word('for'),
          this.space(),
          t === 'of' && e.await && (this.word('await'), this.space()),
          this.token('('),
          this.print(e.left, e),
          this.space(),
          this.word(t),
          this.space(),
          this.print(e.right, e),
          this.token(')'),
          this.printBlock(e)
      }
    },
    m$ = ny('in')
  St.ForInStatement = m$
  const y$ = ny('of')
  St.ForOfStatement = y$
  function g$(t) {
    this.word('do'),
      this.space(),
      this.print(t.body, t),
      this.space(),
      this.word('while'),
      this.space(),
      this.token('('),
      this.print(t.test, t),
      this.token(')'),
      this.semicolon()
  }
  function ho(t, e = 'label') {
    return function (r) {
      this.word(t)
      const i = r[e]
      if (i) {
        this.space()
        const n = e == 'label',
          s = this.startTerminatorless(n)
        this.print(i, r), this.endTerminatorless(s)
      }
      this.semicolon()
    }
  }
  const T$ = ho('continue')
  St.ContinueStatement = T$
  const b$ = ho('return', 'argument')
  St.ReturnStatement = b$
  const S$ = ho('break')
  St.BreakStatement = S$
  const v$ = ho('throw', 'argument')
  St.ThrowStatement = v$
  function E$(t) {
    this.print(t.label, t), this.token(':'), this.space(), this.print(t.body, t)
  }
  function P$(t) {
    this.word('try'),
      this.space(),
      this.print(t.block, t),
      this.space(),
      t.handlers ? this.print(t.handlers[0], t) : this.print(t.handler, t),
      t.finalizer && (this.space(), this.word('finally'), this.space(), this.print(t.finalizer, t))
  }
  function w$(t) {
    this.word('catch'),
      this.space(),
      t.param &&
        (this.token('('), this.print(t.param, t), this.print(t.param.typeAnnotation, t), this.token(')'), this.space()),
      this.print(t.body, t)
  }
  function A$(t) {
    this.word('switch'),
      this.space(),
      this.token('('),
      this.print(t.discriminant, t),
      this.token(')'),
      this.space(),
      this.token('{'),
      this.printSequence(t.cases, t, {
        indent: !0,
        addNewlines(e, r) {
          if (!e && t.cases[t.cases.length - 1] === r) return -1
        },
      }),
      this.token('}')
  }
  function C$(t) {
    t.test
      ? (this.word('case'), this.space(), this.print(t.test, t), this.token(':'))
      : (this.word('default'), this.token(':')),
      t.consequent.length && (this.newline(), this.printSequence(t.consequent, t, { indent: !0 }))
  }
  function x$() {
    this.word('debugger'), this.semicolon()
  }
  function I$() {
    if ((this.token(','), this.newline(), this.endsWith(10))) for (let t = 0; t < 4; t++) this.space(!0)
  }
  function k$() {
    if ((this.token(','), this.newline(), this.endsWith(10))) for (let t = 0; t < 6; t++) this.space(!0)
  }
  function N$(t, e) {
    t.declare && (this.word('declare'), this.space()), this.word(t.kind), this.space()
    let r = !1
    if (!ry(e)) for (const n of t.declarations) n.init && (r = !0)
    let i
    if ((r && (i = t.kind === 'const' ? k$ : I$), this.printList(t.declarations, t, { separator: i }), ry(e))) {
      if (l$(e)) {
        if (e.init === t) return
      } else if (e.left === t) return
    }
    this.semicolon()
  }
  function O$(t) {
    this.print(t.id, t),
      t.definite && this.token('!'),
      this.print(t.id.typeAnnotation, t),
      t.init && (this.space(), this.token('='), this.space(), this.print(t.init, t))
  }
  var hr = {}
  Object.defineProperty(hr, '__esModule', { value: !0 }),
    (hr.ClassAccessorProperty = R$),
    (hr.ClassBody = F$),
    (hr.ClassExpression = hr.ClassDeclaration = M$),
    (hr.ClassMethod = _$),
    (hr.ClassPrivateMethod = V$),
    (hr.ClassPrivateProperty = j$),
    (hr.ClassProperty = $$),
    (hr.StaticBlock = z$),
    (hr._classMethodHead = U$)
  var D$ = st
  const { isExportDefaultDeclaration: B$, isExportNamedDeclaration: L$ } = D$
  function M$(t, e) {
    ;(!this.format.decoratorsBeforeExport || (!B$(e) && !L$(e))) && this.printJoin(t.decorators, t),
      t.declare && (this.word('declare'), this.space()),
      t.abstract && (this.word('abstract'), this.space()),
      this.word('class'),
      this.printInnerComments(t),
      t.id && (this.space(), this.print(t.id, t)),
      this.print(t.typeParameters, t),
      t.superClass &&
        (this.space(),
        this.word('extends'),
        this.space(),
        this.print(t.superClass, t),
        this.print(t.superTypeParameters, t)),
      t.implements && (this.space(), this.word('implements'), this.space(), this.printList(t.implements, t)),
      this.space(),
      this.print(t.body, t)
  }
  function F$(t) {
    this.token('{'),
      this.printInnerComments(t),
      t.body.length === 0
        ? this.token('}')
        : (this.newline(),
          this.indent(),
          this.printSequence(t.body, t),
          this.dedent(),
          this.endsWith(10) || this.newline(),
          this.rightBrace())
  }
  function $$(t) {
    this.printJoin(t.decorators, t),
      this.source('end', t.key.loc),
      this.tsPrintClassMemberModifiers(t, !0),
      t.computed ? (this.token('['), this.print(t.key, t), this.token(']')) : (this._variance(t), this.print(t.key, t)),
      t.optional && this.token('?'),
      t.definite && this.token('!'),
      this.print(t.typeAnnotation, t),
      t.value && (this.space(), this.token('='), this.space(), this.print(t.value, t)),
      this.semicolon()
  }
  function R$(t) {
    this.printJoin(t.decorators, t),
      this.source('end', t.key.loc),
      this.tsPrintClassMemberModifiers(t, !0),
      this.word('accessor'),
      this.printInnerComments(t),
      this.space(),
      t.computed ? (this.token('['), this.print(t.key, t), this.token(']')) : (this._variance(t), this.print(t.key, t)),
      t.optional && this.token('?'),
      t.definite && this.token('!'),
      this.print(t.typeAnnotation, t),
      t.value && (this.space(), this.token('='), this.space(), this.print(t.value, t)),
      this.semicolon()
  }
  function j$(t) {
    this.printJoin(t.decorators, t),
      t.static && (this.word('static'), this.space()),
      this.print(t.key, t),
      this.print(t.typeAnnotation, t),
      t.value && (this.space(), this.token('='), this.space(), this.print(t.value, t)),
      this.semicolon()
  }
  function _$(t) {
    this._classMethodHead(t), this.space(), this.print(t.body, t)
  }
  function V$(t) {
    this._classMethodHead(t), this.space(), this.print(t.body, t)
  }
  function U$(t) {
    this.printJoin(t.decorators, t),
      this.source('end', t.key.loc),
      this.tsPrintClassMemberModifiers(t, !1),
      this._methodHead(t)
  }
  function z$(t) {
    this.word('static'),
      this.space(),
      this.token('{'),
      t.body.length === 0
        ? this.token('}')
        : (this.newline(), this.printSequence(t.body, t, { indent: !0 }), this.rightBrace())
  }
  var Cr = {}
  Object.defineProperty(Cr, '__esModule', { value: !0 }),
    (Cr.ArrowFunctionExpression = Q$),
    (Cr.FunctionDeclaration = Cr.FunctionExpression = Z$),
    (Cr._functionHead = J$),
    (Cr._methodHead = X$),
    (Cr._param = q$),
    (Cr._parameters = H$),
    (Cr._params = Y$),
    (Cr._predicate = G$)
  var K$ = st
  const { isIdentifier: W$ } = K$
  function Y$(t) {
    this.print(t.typeParameters, t),
      this.token('('),
      this._parameters(t.params, t),
      this.token(')'),
      this.print(t.returnType, t)
  }
  function H$(t, e) {
    for (let r = 0; r < t.length; r++) this._param(t[r], e), r < t.length - 1 && (this.token(','), this.space())
  }
  function q$(t, e) {
    this.printJoin(t.decorators, t), this.print(t, e), t.optional && this.token('?'), this.print(t.typeAnnotation, t)
  }
  function X$(t) {
    const e = t.kind,
      r = t.key
    ;(e === 'get' || e === 'set') && (this.word(e), this.space()),
      t.async && (this._catchUp('start', r.loc), this.word('async'), this.space()),
      (e === 'method' || e === 'init') && t.generator && this.token('*'),
      t.computed ? (this.token('['), this.print(r, t), this.token(']')) : this.print(r, t),
      t.optional && this.token('?'),
      this._params(t)
  }
  function G$(t) {
    t.predicate && (t.returnType || this.token(':'), this.space(), this.print(t.predicate, t))
  }
  function J$(t) {
    t.async && (this.word('async'), this.space()),
      this.word('function'),
      t.generator && this.token('*'),
      this.printInnerComments(t),
      this.space(),
      t.id && this.print(t.id, t),
      this._params(t),
      this._predicate(t)
  }
  function Z$(t) {
    this._functionHead(t), this.space(), this.print(t.body, t)
  }
  function Q$(t) {
    t.async && (this.word('async'), this.space())
    const e = t.params[0]
    !this.format.retainLines &&
    !this.format.auxiliaryCommentBefore &&
    !this.format.auxiliaryCommentAfter &&
    t.params.length === 1 &&
    W$(e) &&
    !eR(t, e)
      ? this.print(e, t)
      : this._params(t),
      this._predicate(t),
      this.space(),
      this.token('=>'),
      this.space(),
      this.print(t.body, t)
  }
  function eR(t, e) {
    var r, i
    return !!(
      t.typeParameters ||
      t.returnType ||
      t.predicate ||
      e.typeAnnotation ||
      e.optional ||
      ((r = e.leadingComments) != null && r.length) ||
      ((i = e.trailingComments) != null && i.length)
    )
  }
  var nr = {}
  Object.defineProperty(nr, '__esModule', { value: !0 }),
    (nr.ExportAllDeclaration = fR),
    (nr.ExportDefaultDeclaration = dR),
    (nr.ExportDefaultSpecifier = uR),
    (nr.ExportNamedDeclaration = hR),
    (nr.ExportNamespaceSpecifier = pR),
    (nr.ExportSpecifier = cR),
    (nr.ImportAttribute = yR),
    (nr.ImportDeclaration = mR),
    (nr.ImportDefaultSpecifier = lR),
    (nr.ImportNamespaceSpecifier = gR),
    (nr.ImportSpecifier = oR)
  var tR = st
  const {
    isClassDeclaration: sy,
    isExportDefaultSpecifier: rR,
    isExportNamespaceSpecifier: iR,
    isImportDefaultSpecifier: nR,
    isImportNamespaceSpecifier: sR,
    isStatement: aR,
  } = tR
  function oR(t) {
    ;(t.importKind === 'type' || t.importKind === 'typeof') && (this.word(t.importKind), this.space()),
      this.print(t.imported, t),
      t.local &&
        t.local.name !== t.imported.name &&
        (this.space(), this.word('as'), this.space(), this.print(t.local, t))
  }
  function lR(t) {
    this.print(t.local, t)
  }
  function uR(t) {
    this.print(t.exported, t)
  }
  function cR(t) {
    t.exportKind === 'type' && (this.word('type'), this.space()),
      this.print(t.local, t),
      t.exported &&
        t.local.name !== t.exported.name &&
        (this.space(), this.word('as'), this.space(), this.print(t.exported, t))
  }
  function pR(t) {
    this.token('*'), this.space(), this.word('as'), this.space(), this.print(t.exported, t)
  }
  function fR(t) {
    this.word('export'),
      this.space(),
      t.exportKind === 'type' && (this.word('type'), this.space()),
      this.token('*'),
      this.space(),
      this.word('from'),
      this.space(),
      this.print(t.source, t),
      this.printAssertions(t),
      this.semicolon()
  }
  function hR(t) {
    this.format.decoratorsBeforeExport && sy(t.declaration) && this.printJoin(t.declaration.decorators, t),
      this.word('export'),
      this.space(),
      ay.apply(this, arguments)
  }
  function dR(t) {
    this.format.decoratorsBeforeExport && sy(t.declaration) && this.printJoin(t.declaration.decorators, t),
      this.word('export'),
      this.space(),
      this.word('default'),
      this.space(),
      ay.apply(this, arguments)
  }
  function ay(t) {
    if (t.declaration) {
      const e = t.declaration
      this.print(e, t), aR(e) || this.semicolon()
    } else {
      t.exportKind === 'type' && (this.word('type'), this.space())
      const e = t.specifiers.slice(0)
      let r = !1
      for (;;) {
        const i = e[0]
        if (rR(i) || iR(i)) (r = !0), this.print(e.shift(), t), e.length && (this.token(','), this.space())
        else break
      }
      ;(e.length || (!e.length && !r)) &&
        (this.token('{'), e.length && (this.space(), this.printList(e, t), this.space()), this.token('}')),
        t.source && (this.space(), this.word('from'), this.space(), this.print(t.source, t), this.printAssertions(t)),
        this.semicolon()
    }
  }
  function mR(t) {
    this.word('import'), this.space()
    const e = t.importKind === 'type' || t.importKind === 'typeof'
    e && (this.word(t.importKind), this.space())
    const r = t.specifiers.slice(0),
      i = !!r.length
    for (; i; ) {
      const s = r[0]
      if (nR(s) || sR(s)) this.print(r.shift(), t), r.length && (this.token(','), this.space())
      else break
    }
    r.length
      ? (this.token('{'), this.space(), this.printList(r, t), this.space(), this.token('}'))
      : e && !i && (this.token('{'), this.token('}')),
      (i || e) && (this.space(), this.word('from'), this.space()),
      this.print(t.source, t),
      this.printAssertions(t)
    {
      var n
      ;(n = t.attributes) != null &&
        n.length &&
        (this.space(), this.word('with'), this.space(), this.printList(t.attributes, t))
    }
    this.semicolon()
  }
  function yR(t) {
    this.print(t.key), this.token(':'), this.space(), this.print(t.value)
  }
  function gR(t) {
    this.token('*'), this.space(), this.word('as'), this.space(), this.print(t.local, t)
  }
  var wt = {}
  const oy = {},
    TR = oy.hasOwnProperty,
    ly = (t, e) => {
      for (const r in t) TR.call(t, r) && e(r, t[r])
    },
    bR = (t, e) => (
      e &&
        ly(e, (r, i) => {
          t[r] = i
        }),
      t
    ),
    SR = (t, e) => {
      const r = t.length
      let i = -1
      for (; ++i < r; ) e(t[i])
    },
    Ps = oy.toString,
    vR = Array.isArray,
    ER = Buffer.isBuffer,
    PR = (t) => Ps.call(t) == '[object Object]',
    wR = (t) => typeof t == 'string' || Ps.call(t) == '[object String]',
    AR = (t) => typeof t == 'number' || Ps.call(t) == '[object Number]',
    CR = (t) => typeof t == 'function',
    xR = (t) => Ps.call(t) == '[object Map]',
    IR = (t) => Ps.call(t) == '[object Set]',
    kR = { '"': '\\"', "'": "\\'", '\\': '\\\\', '\b': '\\b', '\f': '\\f', '\n': '\\n', '\r': '\\r', '	': '\\t' },
    NR = /["'\\\b\f\n\r\t]/,
    OR = /[0-9]/,
    DR = /[ !#-&\(-\[\]-_a-~]/,
    hi = (t, e) => {
      const r = () => {
          ;(c = u), ++e.indentLevel, (u = e.indent.repeat(e.indentLevel))
        },
        i = {
          escapeEverything: !1,
          minimal: !1,
          isScriptContext: !1,
          quotes: 'single',
          wrap: !1,
          es6: !1,
          json: !1,
          compact: !0,
          lowercaseHex: !1,
          numbers: 'decimal',
          indent: '	',
          indentLevel: 0,
          __inline1__: !1,
          __inline2__: !1,
        },
        n = e && e.json
      n && ((i.quotes = 'double'), (i.wrap = !0)),
        (e = bR(i, e)),
        e.quotes != 'single' && e.quotes != 'double' && e.quotes != 'backtick' && (e.quotes = 'single')
      const s = e.quotes == 'double' ? '"' : e.quotes == 'backtick' ? '`' : "'",
        a = e.compact,
        o = e.lowercaseHex
      let u = e.indent.repeat(e.indentLevel),
        c = ''
      const p = e.__inline1__,
        h = e.__inline2__,
        f = a
          ? ''
          : `
`
      let d,
        T = !0
      const y = e.numbers == 'binary',
        b = e.numbers == 'octal',
        m = e.numbers == 'decimal',
        S = e.numbers == 'hexadecimal'
      if ((n && t && CR(t.toJSON) && (t = t.toJSON()), !wR(t))) {
        if (xR(t))
          return t.size == 0
            ? 'new Map()'
            : (a || ((e.__inline1__ = !0), (e.__inline2__ = !1)), 'new Map(' + hi(Array.from(t), e) + ')')
        if (IR(t)) return t.size == 0 ? 'new Set()' : 'new Set(' + hi(Array.from(t), e) + ')'
        if (ER(t)) return t.length == 0 ? 'Buffer.from([])' : 'Buffer.from(' + hi(Array.from(t), e) + ')'
        if (vR(t))
          return (
            (d = []),
            (e.wrap = !0),
            p && ((e.__inline1__ = !1), (e.__inline2__ = !0)),
            h || r(),
            SR(t, (D) => {
              ;(T = !1), h && (e.__inline2__ = !1), d.push((a || h ? '' : u) + hi(D, e))
            }),
            T ? '[]' : h ? '[' + d.join(', ') + ']' : '[' + f + d.join(',' + f) + f + (a ? '' : c) + ']'
          )
        if (AR(t)) {
          if (n) return JSON.stringify(t)
          if (m) return String(t)
          if (S) {
            let D = t.toString(16)
            return o || (D = D.toUpperCase()), '0x' + D
          }
          if (y) return '0b' + t.toString(2)
          if (b) return '0o' + t.toString(8)
        } else
          return PR(t)
            ? ((d = []),
              (e.wrap = !0),
              r(),
              ly(t, (D, N) => {
                ;(T = !1), d.push((a ? '' : u) + hi(D, e) + ':' + (a ? '' : ' ') + hi(N, e))
              }),
              T ? '{}' : '{' + f + d.join(',' + f) + f + (a ? '' : c) + '}')
            : n
            ? JSON.stringify(t) || 'null'
            : String(t)
      }
      const E = t
      let P = -1
      const x = E.length
      for (d = ''; ++P < x; ) {
        const D = E.charAt(P)
        if (e.es6) {
          const Y = E.charCodeAt(P)
          if (Y >= 55296 && Y <= 56319 && x > P + 1) {
            const C = E.charCodeAt(P + 1)
            if (C >= 56320 && C <= 57343) {
              let w = ((Y - 55296) * 1024 + C - 56320 + 65536).toString(16)
              o || (w = w.toUpperCase()), (d += '\\u{' + w + '}'), ++P
              continue
            }
          }
        }
        if (!e.escapeEverything) {
          if (DR.test(D)) {
            d += D
            continue
          }
          if (D == '"') {
            d += s == D ? '\\"' : D
            continue
          }
          if (D == '`') {
            d += s == D ? '\\`' : D
            continue
          }
          if (D == "'") {
            d += s == D ? "\\'" : D
            continue
          }
        }
        if (D == '\0' && !n && !OR.test(E.charAt(P + 1))) {
          d += '\\0'
          continue
        }
        if (NR.test(D)) {
          d += kR[D]
          continue
        }
        const N = D.charCodeAt(0)
        if (e.minimal && N != 8232 && N != 8233) {
          d += D
          continue
        }
        let I = N.toString(16)
        o || (I = I.toUpperCase())
        const B = I.length > 2 || n
        d += '\\' + (B ? 'u' : 'x') + ('0000' + I).slice(B ? -4 : -2)
      }
      return (
        e.wrap && (d = s + d + s),
        s == '`' && (d = d.replace(/\$\{/g, '\\${')),
        e.isScriptContext
          ? d.replace(/<\/(script|style)/gi, '<\\/$1').replace(/<!--/g, n ? '\\u003C!--' : '\\x3C!--')
          : d
      )
    }
  hi.version = '2.5.2'
  var BR = hi
  Object.defineProperty(wt, '__esModule', { value: !0 }),
    (wt.ArgumentPlaceholder = $R),
    (wt.ArrayPattern = wt.ArrayExpression = UR),
    (wt.BigIntLiteral = GR),
    (wt.BooleanLiteral = YR),
    (wt.DecimalLiteral = JR),
    (wt.Identifier = FR),
    (wt.NullLiteral = HR),
    (wt.NumericLiteral = qR),
    (wt.ObjectPattern = wt.ObjectExpression = jR),
    (wt.ObjectMethod = _R),
    (wt.ObjectProperty = VR),
    (wt.PipelineBareFunction = e9),
    (wt.PipelinePrimaryTopicReference = t9),
    (wt.PipelineTopicExpression = QR),
    (wt.RecordExpression = zR),
    (wt.RegExpLiteral = WR),
    (wt.SpreadElement = wt.RestElement = RR),
    (wt.StringLiteral = XR),
    (wt.TopicReference = ZR),
    (wt.TupleExpression = KR)
  var LR = st,
    uy = BR
  const { isAssignmentPattern: MR, isIdentifier: Sc } = LR
  function FR(t) {
    this.exactSource(t.loc, () => {
      this.word(t.name)
    })
  }
  function $R() {
    this.token('?')
  }
  function RR(t) {
    this.token('...'), this.print(t.argument, t)
  }
  function jR(t) {
    const e = t.properties
    this.token('{'),
      this.printInnerComments(t),
      e.length && (this.space(), this.printList(e, t, { indent: !0, statement: !0 }), this.space()),
      this.token('}')
  }
  function _R(t) {
    this.printJoin(t.decorators, t), this._methodHead(t), this.space(), this.print(t.body, t)
  }
  function VR(t) {
    if ((this.printJoin(t.decorators, t), t.computed)) this.token('['), this.print(t.key, t), this.token(']')
    else {
      if (MR(t.value) && Sc(t.key) && t.key.name === t.value.left.name) {
        this.print(t.value, t)
        return
      }
      if ((this.print(t.key, t), t.shorthand && Sc(t.key) && Sc(t.value) && t.key.name === t.value.name)) return
    }
    this.token(':'), this.space(), this.print(t.value, t)
  }
  function UR(t) {
    const e = t.elements,
      r = e.length
    this.token('['), this.printInnerComments(t)
    for (let i = 0; i < e.length; i++) {
      const n = e[i]
      n ? (i > 0 && this.space(), this.print(n, t), i < r - 1 && this.token(',')) : this.token(',')
    }
    this.token(']')
  }
  function zR(t) {
    const e = t.properties
    let r, i
    if (this.format.recordAndTupleSyntaxType === 'bar') (r = '{|'), (i = '|}')
    else if (this.format.recordAndTupleSyntaxType === 'hash') (r = '#{'), (i = '}')
    else
      throw new Error(
        `The "recordAndTupleSyntaxType" generator option must be "bar" or "hash" (${JSON.stringify(
          this.format.recordAndTupleSyntaxType
        )} received).`
      )
    this.token(r),
      this.printInnerComments(t),
      e.length && (this.space(), this.printList(e, t, { indent: !0, statement: !0 }), this.space()),
      this.token(i)
  }
  function KR(t) {
    const e = t.elements,
      r = e.length
    let i, n
    if (this.format.recordAndTupleSyntaxType === 'bar') (i = '[|'), (n = '|]')
    else if (this.format.recordAndTupleSyntaxType === 'hash') (i = '#['), (n = ']')
    else throw new Error(`${this.format.recordAndTupleSyntaxType} is not a valid recordAndTuple syntax type`)
    this.token(i), this.printInnerComments(t)
    for (let s = 0; s < e.length; s++) {
      const a = e[s]
      a && (s > 0 && this.space(), this.print(a, t), s < r - 1 && this.token(','))
    }
    this.token(n)
  }
  function WR(t) {
    this.word(`/${t.pattern}/${t.flags}`)
  }
  function YR(t) {
    this.word(t.value ? 'true' : 'false')
  }
  function HR() {
    this.word('null')
  }
  function qR(t) {
    const e = this.getPossibleRaw(t),
      r = this.format.jsescOption,
      i = t.value + ''
    r.numbers
      ? this.number(uy(t.value, r))
      : e == null
      ? this.number(i)
      : this.format.minified
      ? this.number(e.length < i.length ? e : i)
      : this.number(e)
  }
  function XR(t) {
    const e = this.getPossibleRaw(t)
    if (!this.format.minified && e != null) {
      this.token(e)
      return
    }
    const r = uy(t.value, Object.assign(this.format.jsescOption, this.format.jsonCompatibleStrings && { json: !0 }))
    return this.token(r)
  }
  function GR(t) {
    const e = this.getPossibleRaw(t)
    if (!this.format.minified && e != null) {
      this.word(e)
      return
    }
    this.word(t.value + 'n')
  }
  function JR(t) {
    const e = this.getPossibleRaw(t)
    if (!this.format.minified && e != null) {
      this.word(e)
      return
    }
    this.word(t.value + 'm')
  }
  const cy = new Set(['^^', '@@', '^', '%', '#'])
  function ZR() {
    const { topicToken: t } = this.format
    if (cy.has(t)) this.token(t)
    else {
      const e = JSON.stringify(t),
        r = Array.from(cy, (i) => JSON.stringify(i))
      throw new Error(`The "topicToken" generator option must be one of ${r.join(', ')} (${e} received instead).`)
    }
  }
  function QR(t) {
    this.print(t.expression, t)
  }
  function e9(t) {
    this.print(t.callee, t)
  }
  function t9() {
    this.token('#')
  }
  var py = {}
  ;(function (t) {
    Object.defineProperty(t, '__esModule', { value: !0 }),
      (t.AnyTypeAnnotation = a),
      (t.ArrayTypeAnnotation = o),
      (t.BooleanLiteralTypeAnnotation = c),
      (t.BooleanTypeAnnotation = u),
      (t.DeclareClass = h),
      (t.DeclareExportAllDeclaration = D),
      (t.DeclareExportDeclaration = x),
      (t.DeclareFunction = f),
      (t.DeclareInterface = y),
      (t.DeclareModule = b),
      (t.DeclareModuleExports = m),
      (t.DeclareOpaqueType = E),
      (t.DeclareTypeAlias = S),
      (t.DeclareVariable = P),
      (t.DeclaredPredicate = T),
      (t.EmptyTypeAnnotation = De),
      (t.EnumBooleanBody = K),
      (t.EnumBooleanMember = X),
      (t.EnumDeclaration = N),
      (t.EnumDefaultedMember = w),
      (t.EnumNumberBody = Y),
      (t.EnumNumberMember = G),
      (t.EnumStringBody = C),
      (t.EnumStringMember = Te),
      (t.EnumSymbolBody = H),
      (t.ExistsTypeAnnotation = se),
      (t.FunctionTypeAnnotation = U),
      (t.FunctionTypeParam = W),
      (t.IndexedAccessType = at),
      (t.InferredPredicate = d),
      (t.InterfaceDeclaration = ke),
      (t.GenericTypeAnnotation = t.ClassImplements = t.InterfaceExtends = ge),
      (t.InterfaceTypeAnnotation = de),
      (t.IntersectionTypeAnnotation = be),
      (t.MixedTypeAnnotation = Pe),
      (t.NullLiteralTypeAnnotation = p),
      (t.NullableTypeAnnotation = Le),
      Object.defineProperty(t, 'NumberLiteralTypeAnnotation', {
        enumerable: !0,
        get: function () {
          return i.NumericLiteral
        },
      }),
      (t.NumberTypeAnnotation = We),
      (t.ObjectTypeAnnotation = Se),
      (t.ObjectTypeCallProperty = Ae),
      (t.ObjectTypeIndexer = Re),
      (t.ObjectTypeInternalSlot = xe),
      (t.ObjectTypeProperty = O),
      (t.ObjectTypeSpreadProperty = g),
      (t.OpaqueType = ne),
      (t.OptionalIndexedAccessType = Pt),
      (t.QualifiedTypeIdentifier = v),
      Object.defineProperty(t, 'StringLiteralTypeAnnotation', {
        enumerable: !0,
        get: function () {
          return i.StringLiteral
        },
      }),
      (t.StringTypeAnnotation = A),
      (t.SymbolTypeAnnotation = z),
      (t.ThisTypeAnnotation = pe),
      (t.TupleTypeAnnotation = ie),
      (t.TypeAlias = F),
      (t.TypeAnnotation = q),
      (t.TypeCastExpression = Z),
      (t.TypeParameter = fe),
      (t.TypeParameterDeclaration = t.TypeParameterInstantiation = le),
      (t.TypeofTypeAnnotation = L),
      (t.UnionTypeAnnotation = ue),
      (t.Variance = et),
      (t.VoidTypeAnnotation = bt),
      (t._interfaceish = ye),
      (t._variance = me)
    var e = st,
      r = nr,
      i = wt
    const { isDeclareExportDeclaration: n, isStatement: s } = e
    function a() {
      this.word('any')
    }
    function o(R) {
      this.print(R.elementType, R), this.token('['), this.token(']')
    }
    function u() {
      this.word('boolean')
    }
    function c(R) {
      this.word(R.value ? 'true' : 'false')
    }
    function p() {
      this.word('null')
    }
    function h(R, Ze) {
      n(Ze) || (this.word('declare'), this.space()), this.word('class'), this.space(), this._interfaceish(R)
    }
    function f(R, Ze) {
      n(Ze) || (this.word('declare'), this.space()),
        this.word('function'),
        this.space(),
        this.print(R.id, R),
        this.print(R.id.typeAnnotation.typeAnnotation, R),
        R.predicate && (this.space(), this.print(R.predicate, R)),
        this.semicolon()
    }
    function d() {
      this.token('%'), this.word('checks')
    }
    function T(R) {
      this.token('%'), this.word('checks'), this.token('('), this.print(R.value, R), this.token(')')
    }
    function y(R) {
      this.word('declare'), this.space(), this.InterfaceDeclaration(R)
    }
    function b(R) {
      this.word('declare'),
        this.space(),
        this.word('module'),
        this.space(),
        this.print(R.id, R),
        this.space(),
        this.print(R.body, R)
    }
    function m(R) {
      this.word('declare'),
        this.space(),
        this.word('module'),
        this.token('.'),
        this.word('exports'),
        this.print(R.typeAnnotation, R)
    }
    function S(R) {
      this.word('declare'), this.space(), this.TypeAlias(R)
    }
    function E(R, Ze) {
      n(Ze) || (this.word('declare'), this.space()), this.OpaqueType(R)
    }
    function P(R, Ze) {
      n(Ze) || (this.word('declare'), this.space()),
        this.word('var'),
        this.space(),
        this.print(R.id, R),
        this.print(R.id.typeAnnotation, R),
        this.semicolon()
    }
    function x(R) {
      this.word('declare'),
        this.space(),
        this.word('export'),
        this.space(),
        R.default && (this.word('default'), this.space()),
        ce.apply(this, arguments)
    }
    function D() {
      this.word('declare'), this.space(), r.ExportAllDeclaration.apply(this, arguments)
    }
    function N(R) {
      const { id: Ze, body: Mr } = R
      this.word('enum'), this.space(), this.print(Ze, R), this.print(Mr, R)
    }
    function I(R, Ze, Mr) {
      Mr && (R.space(), R.word('of'), R.space(), R.word(Ze)), R.space()
    }
    function B(R, Ze) {
      const { members: Mr } = Ze
      R.token('{'), R.indent(), R.newline()
      for (const ns of Mr) R.print(ns, Ze), R.newline()
      Ze.hasUnknownMembers && (R.token('...'), R.newline()), R.dedent(), R.token('}')
    }
    function K(R) {
      const { explicitType: Ze } = R
      I(this, 'boolean', Ze), B(this, R)
    }
    function Y(R) {
      const { explicitType: Ze } = R
      I(this, 'number', Ze), B(this, R)
    }
    function C(R) {
      const { explicitType: Ze } = R
      I(this, 'string', Ze), B(this, R)
    }
    function H(R) {
      I(this, 'symbol', !0), B(this, R)
    }
    function w(R) {
      const { id: Ze } = R
      this.print(Ze, R), this.token(',')
    }
    function J(R, Ze) {
      const { id: Mr, init: ns } = Ze
      R.print(Mr, Ze), R.space(), R.token('='), R.space(), R.print(ns, Ze), R.token(',')
    }
    function X(R) {
      J(this, R)
    }
    function G(R) {
      J(this, R)
    }
    function Te(R) {
      J(this, R)
    }
    function ce(R) {
      if (R.declaration) {
        const Ze = R.declaration
        this.print(Ze, R), s(Ze) || this.semicolon()
      } else this.token('{'), R.specifiers.length && (this.space(), this.printList(R.specifiers, R), this.space()), this.token('}'), R.source && (this.space(), this.word('from'), this.space(), this.print(R.source, R)), this.semicolon()
    }
    function se() {
      this.token('*')
    }
    function U(R, Ze) {
      this.print(R.typeParameters, R),
        this.token('('),
        R.this &&
          (this.word('this'),
          this.token(':'),
          this.space(),
          this.print(R.this.typeAnnotation, R),
          (R.params.length || R.rest) && (this.token(','), this.space())),
        this.printList(R.params, R),
        R.rest && (R.params.length && (this.token(','), this.space()), this.token('...'), this.print(R.rest, R)),
        this.token(')'),
        Ze &&
        (Ze.type === 'ObjectTypeCallProperty' ||
          Ze.type === 'DeclareFunction' ||
          (Ze.type === 'ObjectTypeProperty' && Ze.method))
          ? this.token(':')
          : (this.space(), this.token('=>')),
        this.space(),
        this.print(R.returnType, R)
    }
    function W(R) {
      this.print(R.name, R),
        R.optional && this.token('?'),
        R.name && (this.token(':'), this.space()),
        this.print(R.typeAnnotation, R)
    }
    function ge(R) {
      this.print(R.id, R), this.print(R.typeParameters, R)
    }
    function ye(R) {
      var Ze
      this.print(R.id, R),
        this.print(R.typeParameters, R),
        (Ze = R.extends) != null &&
          Ze.length &&
          (this.space(), this.word('extends'), this.space(), this.printList(R.extends, R)),
        R.mixins && R.mixins.length && (this.space(), this.word('mixins'), this.space(), this.printList(R.mixins, R)),
        R.implements &&
          R.implements.length &&
          (this.space(), this.word('implements'), this.space(), this.printList(R.implements, R)),
        this.space(),
        this.print(R.body, R)
    }
    function me(R) {
      R.variance && (R.variance.kind === 'plus' ? this.token('+') : R.variance.kind === 'minus' && this.token('-'))
    }
    function ke(R) {
      this.word('interface'), this.space(), this._interfaceish(R)
    }
    function ae() {
      this.space(), this.token('&'), this.space()
    }
    function de(R) {
      this.word('interface'),
        R.extends &&
          R.extends.length &&
          (this.space(), this.word('extends'), this.space(), this.printList(R.extends, R)),
        this.space(),
        this.print(R.body, R)
    }
    function be(R) {
      this.printJoin(R.types, R, { separator: ae })
    }
    function Pe() {
      this.word('mixed')
    }
    function De() {
      this.word('empty')
    }
    function Le(R) {
      this.token('?'), this.print(R.typeAnnotation, R)
    }
    function We() {
      this.word('number')
    }
    function A() {
      this.word('string')
    }
    function pe() {
      this.word('this')
    }
    function ie(R) {
      this.token('['), this.printList(R.types, R), this.token(']')
    }
    function L(R) {
      this.word('typeof'), this.space(), this.print(R.argument, R)
    }
    function F(R) {
      this.word('type'),
        this.space(),
        this.print(R.id, R),
        this.print(R.typeParameters, R),
        this.space(),
        this.token('='),
        this.space(),
        this.print(R.right, R),
        this.semicolon()
    }
    function q(R) {
      this.token(':'), this.space(), R.optional && this.token('?'), this.print(R.typeAnnotation, R)
    }
    function le(R) {
      this.token('<'), this.printList(R.params, R, {}), this.token('>')
    }
    function fe(R) {
      this._variance(R),
        this.word(R.name),
        R.bound && this.print(R.bound, R),
        R.default && (this.space(), this.token('='), this.space(), this.print(R.default, R))
    }
    function ne(R) {
      this.word('opaque'),
        this.space(),
        this.word('type'),
        this.space(),
        this.print(R.id, R),
        this.print(R.typeParameters, R),
        R.supertype && (this.token(':'), this.space(), this.print(R.supertype, R)),
        R.impltype && (this.space(), this.token('='), this.space(), this.print(R.impltype, R)),
        this.semicolon()
    }
    function Se(R) {
      R.exact ? this.token('{|') : this.token('{')
      const Ze = [...R.properties, ...(R.callProperties || []), ...(R.indexers || []), ...(R.internalSlots || [])]
      Ze.length &&
        (this.space(),
        this.printJoin(Ze, R, {
          addNewlines(Mr) {
            if (Mr && !Ze[0]) return 1
          },
          indent: !0,
          statement: !0,
          iterator: () => {
            ;(Ze.length !== 1 || R.inexact) && (this.token(','), this.space())
          },
        }),
        this.space()),
        R.inexact && (this.indent(), this.token('...'), Ze.length && this.newline(), this.dedent()),
        R.exact ? this.token('|}') : this.token('}')
    }
    function xe(R) {
      R.static && (this.word('static'), this.space()),
        this.token('['),
        this.token('['),
        this.print(R.id, R),
        this.token(']'),
        this.token(']'),
        R.optional && this.token('?'),
        R.method || (this.token(':'), this.space()),
        this.print(R.value, R)
    }
    function Ae(R) {
      R.static && (this.word('static'), this.space()), this.print(R.value, R)
    }
    function Re(R) {
      R.static && (this.word('static'), this.space()),
        this._variance(R),
        this.token('['),
        R.id && (this.print(R.id, R), this.token(':'), this.space()),
        this.print(R.key, R),
        this.token(']'),
        this.token(':'),
        this.space(),
        this.print(R.value, R)
    }
    function O(R) {
      R.proto && (this.word('proto'), this.space()),
        R.static && (this.word('static'), this.space()),
        (R.kind === 'get' || R.kind === 'set') && (this.word(R.kind), this.space()),
        this._variance(R),
        this.print(R.key, R),
        R.optional && this.token('?'),
        R.method || (this.token(':'), this.space()),
        this.print(R.value, R)
    }
    function g(R) {
      this.token('...'), this.print(R.argument, R)
    }
    function v(R) {
      this.print(R.qualification, R), this.token('.'), this.print(R.id, R)
    }
    function z() {
      this.word('symbol')
    }
    function ee() {
      this.space(), this.token('|'), this.space()
    }
    function ue(R) {
      this.printJoin(R.types, R, { separator: ee })
    }
    function Z(R) {
      this.token('('), this.print(R.expression, R), this.print(R.typeAnnotation, R), this.token(')')
    }
    function et(R) {
      R.kind === 'plus' ? this.token('+') : this.token('-')
    }
    function bt() {
      this.word('void')
    }
    function at(R) {
      this.print(R.objectType, R), this.token('['), this.print(R.indexType, R), this.token(']')
    }
    function Pt(R) {
      this.print(R.objectType, R),
        R.optional && this.token('?.'),
        this.token('['),
        this.print(R.indexType, R),
        this.token(']')
    }
  })(py)
  var Kr = {}
  Object.defineProperty(Kr, '__esModule', { value: !0 }),
    (Kr.BlockStatement = n9),
    (Kr.Directive = s9),
    (Kr.DirectiveLiteral = l9),
    (Kr.File = r9),
    (Kr.InterpreterDirective = u9),
    (Kr.Placeholder = c9),
    (Kr.Program = i9)
  function r9(t) {
    t.program && this.print(t.program.interpreter, t), this.print(t.program, t)
  }
  function i9(t) {
    this.printInnerComments(t, !1),
      this.printSequence(t.directives, t),
      t.directives && t.directives.length && this.newline(),
      this.printSequence(t.body, t)
  }
  function n9(t) {
    var e
    this.token('{'), this.printInnerComments(t)
    const r = (e = t.directives) == null ? void 0 : e.length
    t.body.length || r
      ? (this.newline(),
        this.printSequence(t.directives, t, { indent: !0 }),
        r && this.newline(),
        this.printSequence(t.body, t, { indent: !0 }),
        this.removeTrailingNewline(),
        this.source('end', t.loc),
        this.endsWith(10) || this.newline(),
        this.rightBrace())
      : (this.source('end', t.loc), this.token('}'))
  }
  function s9(t) {
    this.print(t.value, t), this.semicolon()
  }
  const a9 = /(?:^|[^\\])(?:\\\\)*'/,
    o9 = /(?:^|[^\\])(?:\\\\)*"/
  function l9(t) {
    const e = this.getPossibleRaw(t)
    if (!this.format.minified && e != null) {
      this.token(e)
      return
    }
    const { value: r } = t
    if (!o9.test(r)) this.token(`"${r}"`)
    else if (!a9.test(r)) this.token(`'${r}'`)
    else
      throw new Error(
        'Malformed AST: it is not possible to print a directive containing both unescaped single and double quotes.'
      )
  }
  function u9(t) {
    this.token(`#!${t.value}
`)
  }
  function c9(t) {
    this.token('%%'), this.print(t.name), this.token('%%'), t.expectedNode === 'Statement' && this.semicolon()
  }
  var $t = {}
  Object.defineProperty($t, '__esModule', { value: !0 }),
    ($t.JSXAttribute = p9),
    ($t.JSXClosingElement = E9),
    ($t.JSXClosingFragment = C9),
    ($t.JSXElement = b9),
    ($t.JSXEmptyExpression = P9),
    ($t.JSXExpressionContainer = y9),
    ($t.JSXFragment = w9),
    ($t.JSXIdentifier = f9),
    ($t.JSXMemberExpression = d9),
    ($t.JSXNamespacedName = h9),
    ($t.JSXOpeningElement = v9),
    ($t.JSXOpeningFragment = A9),
    ($t.JSXSpreadAttribute = m9),
    ($t.JSXSpreadChild = g9),
    ($t.JSXText = T9)
  function p9(t) {
    this.print(t.name, t), t.value && (this.token('='), this.print(t.value, t))
  }
  function f9(t) {
    this.word(t.name)
  }
  function h9(t) {
    this.print(t.namespace, t), this.token(':'), this.print(t.name, t)
  }
  function d9(t) {
    this.print(t.object, t), this.token('.'), this.print(t.property, t)
  }
  function m9(t) {
    this.token('{'), this.token('...'), this.print(t.argument, t), this.token('}')
  }
  function y9(t) {
    this.token('{'), this.print(t.expression, t), this.token('}')
  }
  function g9(t) {
    this.token('{'), this.token('...'), this.print(t.expression, t), this.token('}')
  }
  function T9(t) {
    const e = this.getPossibleRaw(t)
    e != null ? this.token(e) : this.token(t.value)
  }
  function b9(t) {
    const e = t.openingElement
    if ((this.print(e, t), !e.selfClosing)) {
      this.indent()
      for (const r of t.children) this.print(r, t)
      this.dedent(), this.print(t.closingElement, t)
    }
  }
  function S9() {
    this.space()
  }
  function v9(t) {
    this.token('<'),
      this.print(t.name, t),
      this.print(t.typeParameters, t),
      t.attributes.length > 0 && (this.space(), this.printJoin(t.attributes, t, { separator: S9 })),
      t.selfClosing ? (this.space(), this.token('/>')) : this.token('>')
  }
  function E9(t) {
    this.token('</'), this.print(t.name, t), this.token('>')
  }
  function P9(t) {
    this.printInnerComments(t)
  }
  function w9(t) {
    this.print(t.openingFragment, t), this.indent()
    for (const e of t.children) this.print(e, t)
    this.dedent(), this.print(t.closingFragment, t)
  }
  function A9() {
    this.token('<'), this.token('>')
  }
  function C9() {
    this.token('</'), this.token('>')
  }
  var Be = {}
  Object.defineProperty(Be, '__esModule', { value: !0 }),
    (Be.TSAnyKeyword = _9),
    (Be.TSArrayType = uj),
    (Be.TSAsExpression = Ij),
    (Be.TSBigIntKeyword = V9),
    (Be.TSBooleanKeyword = W9),
    (Be.TSCallSignatureDeclaration = L9),
    (Be.TSConditionalType = gj),
    (Be.TSConstructSignatureDeclaration = M9),
    (Be.TSConstructorType = tj),
    (Be.TSDeclareFunction = O9),
    (Be.TSDeclareMethod = D9),
    (Be.TSEnumDeclaration = Oj),
    (Be.TSEnumMember = Dj),
    (Be.TSExportAssignment = jj),
    (Be.TSExpressionWithTypeArguments = wj),
    (Be.TSExternalModuleReference = $j),
    (Be.TSFunctionType = ej),
    (Be.TSImportEqualsDeclaration = Fj),
    (Be.TSImportType = Mj),
    (Be.TSIndexSignature = j9),
    (Be.TSIndexedAccessType = vj),
    (Be.TSInferType = Tj),
    (Be.TSInstantiationExpression = Nj),
    (Be.TSInterfaceBody = Cj),
    (Be.TSInterfaceDeclaration = Aj),
    (Be.TSIntersectionType = mj),
    (Be.TSIntrinsicKeyword = Z9),
    (Be.TSLiteralType = Pj),
    (Be.TSMappedType = Ej),
    (Be.TSMethodSignature = R9),
    (Be.TSModuleBlock = Lj),
    (Be.TSModuleDeclaration = Bj),
    (Be.TSNamedTupleMember = hj),
    (Be.TSNamespaceExportDeclaration = _j),
    (Be.TSNeverKeyword = J9),
    (Be.TSNonNullExpression = Rj),
    (Be.TSNullKeyword = G9),
    (Be.TSNumberKeyword = z9),
    (Be.TSObjectKeyword = K9),
    (Be.TSOptionalType = pj),
    (Be.TSParameterProperty = N9),
    (Be.TSParenthesizedType = bj),
    (Be.TSPropertySignature = F9),
    (Be.TSQualifiedName = B9),
    (Be.TSRestType = fj),
    (Be.TSStringKeyword = Y9),
    (Be.TSSymbolKeyword = H9),
    (Be.TSThisType = Q9),
    (Be.TSTupleType = cj),
    (Be.TSTypeAliasDeclaration = xj),
    (Be.TSTypeAnnotation = x9),
    (Be.TSTypeAssertion = kj),
    (Be.TSTypeLiteral = aj),
    (Be.TSTypeOperator = Sj),
    (Be.TSTypeParameter = k9),
    (Be.TSTypeParameterDeclaration = Be.TSTypeParameterInstantiation = I9),
    (Be.TSTypePredicate = nj),
    (Be.TSTypeQuery = sj),
    (Be.TSTypeReference = ij),
    (Be.TSUndefinedKeyword = X9),
    (Be.TSUnionType = dj),
    (Be.TSUnknownKeyword = U9),
    (Be.TSVoidKeyword = q9),
    (Be.tsPrintBraced = lj),
    (Be.tsPrintClassMemberModifiers = Uj),
    (Be.tsPrintFunctionOrConstructorType = rj),
    (Be.tsPrintPropertyOrMethodName = $9),
    (Be.tsPrintSignatureDeclarationBase = Vj),
    (Be.tsPrintTypeLiteralOrInterfaceBody = oj),
    (Be.tsPrintUnionOrIntersectionType = yj)
  function x9(t) {
    this.token(':'), this.space(), t.optional && this.token('?'), this.print(t.typeAnnotation, t)
  }
  function I9(t, e) {
    this.token('<'),
      this.printList(t.params, t, {}),
      e.type === 'ArrowFunctionExpression' && t.params.length === 1 && this.token(','),
      this.token('>')
  }
  function k9(t) {
    t.in && (this.word('in'), this.space()),
      t.out && (this.word('out'), this.space()),
      this.word(t.name),
      t.constraint && (this.space(), this.word('extends'), this.space(), this.print(t.constraint, t)),
      t.default && (this.space(), this.token('='), this.space(), this.print(t.default, t))
  }
  function N9(t) {
    t.accessibility && (this.word(t.accessibility), this.space()),
      t.readonly && (this.word('readonly'), this.space()),
      this._param(t.parameter)
  }
  function O9(t) {
    t.declare && (this.word('declare'), this.space()), this._functionHead(t), this.token(';')
  }
  function D9(t) {
    this._classMethodHead(t), this.token(';')
  }
  function B9(t) {
    this.print(t.left, t), this.token('.'), this.print(t.right, t)
  }
  function L9(t) {
    this.tsPrintSignatureDeclarationBase(t), this.token(';')
  }
  function M9(t) {
    this.word('new'), this.space(), this.tsPrintSignatureDeclarationBase(t), this.token(';')
  }
  function F9(t) {
    const { readonly: e, initializer: r } = t
    e && (this.word('readonly'), this.space()),
      this.tsPrintPropertyOrMethodName(t),
      this.print(t.typeAnnotation, t),
      r && (this.space(), this.token('='), this.space(), this.print(r, t)),
      this.token(';')
  }
  function $9(t) {
    t.computed && this.token('['), this.print(t.key, t), t.computed && this.token(']'), t.optional && this.token('?')
  }
  function R9(t) {
    const { kind: e } = t
    ;(e === 'set' || e === 'get') && (this.word(e), this.space()),
      this.tsPrintPropertyOrMethodName(t),
      this.tsPrintSignatureDeclarationBase(t),
      this.token(';')
  }
  function j9(t) {
    const { readonly: e, static: r } = t
    r && (this.word('static'), this.space()),
      e && (this.word('readonly'), this.space()),
      this.token('['),
      this._parameters(t.parameters, t),
      this.token(']'),
      this.print(t.typeAnnotation, t),
      this.token(';')
  }
  function _9() {
    this.word('any')
  }
  function V9() {
    this.word('bigint')
  }
  function U9() {
    this.word('unknown')
  }
  function z9() {
    this.word('number')
  }
  function K9() {
    this.word('object')
  }
  function W9() {
    this.word('boolean')
  }
  function Y9() {
    this.word('string')
  }
  function H9() {
    this.word('symbol')
  }
  function q9() {
    this.word('void')
  }
  function X9() {
    this.word('undefined')
  }
  function G9() {
    this.word('null')
  }
  function J9() {
    this.word('never')
  }
  function Z9() {
    this.word('intrinsic')
  }
  function Q9() {
    this.word('this')
  }
  function ej(t) {
    this.tsPrintFunctionOrConstructorType(t)
  }
  function tj(t) {
    t.abstract && (this.word('abstract'), this.space()),
      this.word('new'),
      this.space(),
      this.tsPrintFunctionOrConstructorType(t)
  }
  function rj(t) {
    const { typeParameters: e } = t,
      r = t.parameters
    this.print(e, t),
      this.token('('),
      this._parameters(r, t),
      this.token(')'),
      this.space(),
      this.token('=>'),
      this.space()
    const i = t.typeAnnotation
    this.print(i.typeAnnotation, t)
  }
  function ij(t) {
    this.print(t.typeName, t), this.print(t.typeParameters, t)
  }
  function nj(t) {
    t.asserts && (this.word('asserts'), this.space()),
      this.print(t.parameterName),
      t.typeAnnotation && (this.space(), this.word('is'), this.space(), this.print(t.typeAnnotation.typeAnnotation))
  }
  function sj(t) {
    this.word('typeof'), this.space(), this.print(t.exprName), t.typeParameters && this.print(t.typeParameters, t)
  }
  function aj(t) {
    this.tsPrintTypeLiteralOrInterfaceBody(t.members, t)
  }
  function oj(t, e) {
    this.tsPrintBraced(t, e)
  }
  function lj(t, e) {
    if ((this.token('{'), t.length)) {
      this.indent(), this.newline()
      for (const r of t) this.print(r, e), this.newline()
      this.dedent(), this.rightBrace()
    } else this.token('}')
  }
  function uj(t) {
    this.print(t.elementType, t), this.token('[]')
  }
  function cj(t) {
    this.token('['), this.printList(t.elementTypes, t), this.token(']')
  }
  function pj(t) {
    this.print(t.typeAnnotation, t), this.token('?')
  }
  function fj(t) {
    this.token('...'), this.print(t.typeAnnotation, t)
  }
  function hj(t) {
    this.print(t.label, t), t.optional && this.token('?'), this.token(':'), this.space(), this.print(t.elementType, t)
  }
  function dj(t) {
    this.tsPrintUnionOrIntersectionType(t, '|')
  }
  function mj(t) {
    this.tsPrintUnionOrIntersectionType(t, '&')
  }
  function yj(t, e) {
    this.printJoin(t.types, t, {
      separator() {
        this.space(), this.token(e), this.space()
      },
    })
  }
  function gj(t) {
    this.print(t.checkType),
      this.space(),
      this.word('extends'),
      this.space(),
      this.print(t.extendsType),
      this.space(),
      this.token('?'),
      this.space(),
      this.print(t.trueType),
      this.space(),
      this.token(':'),
      this.space(),
      this.print(t.falseType)
  }
  function Tj(t) {
    this.token('infer'), this.space(), this.print(t.typeParameter)
  }
  function bj(t) {
    this.token('('), this.print(t.typeAnnotation, t), this.token(')')
  }
  function Sj(t) {
    this.word(t.operator), this.space(), this.print(t.typeAnnotation, t)
  }
  function vj(t) {
    this.print(t.objectType, t), this.token('['), this.print(t.indexType, t), this.token(']')
  }
  function Ej(t) {
    const { nameType: e, optional: r, readonly: i, typeParameter: n } = t
    this.token('{'),
      this.space(),
      i && (fy(this, i), this.word('readonly'), this.space()),
      this.token('['),
      this.word(n.name),
      this.space(),
      this.word('in'),
      this.space(),
      this.print(n.constraint, n),
      e && (this.space(), this.word('as'), this.space(), this.print(e, t)),
      this.token(']'),
      r && (fy(this, r), this.token('?')),
      this.token(':'),
      this.space(),
      this.print(t.typeAnnotation, t),
      this.space(),
      this.token('}')
  }
  function fy(t, e) {
    e !== !0 && t.token(e)
  }
  function Pj(t) {
    this.print(t.literal, t)
  }
  function wj(t) {
    this.print(t.expression, t), this.print(t.typeParameters, t)
  }
  function Aj(t) {
    const { declare: e, id: r, typeParameters: i, extends: n, body: s } = t
    e && (this.word('declare'), this.space()),
      this.word('interface'),
      this.space(),
      this.print(r, t),
      this.print(i, t),
      n != null && n.length && (this.space(), this.word('extends'), this.space(), this.printList(n, t)),
      this.space(),
      this.print(s, t)
  }
  function Cj(t) {
    this.tsPrintTypeLiteralOrInterfaceBody(t.body, t)
  }
  function xj(t) {
    const { declare: e, id: r, typeParameters: i, typeAnnotation: n } = t
    e && (this.word('declare'), this.space()),
      this.word('type'),
      this.space(),
      this.print(r, t),
      this.print(i, t),
      this.space(),
      this.token('='),
      this.space(),
      this.print(n, t),
      this.token(';')
  }
  function Ij(t) {
    const { expression: e, typeAnnotation: r } = t
    this.print(e, t), this.space(), this.word('as'), this.space(), this.print(r, t)
  }
  function kj(t) {
    const { typeAnnotation: e, expression: r } = t
    this.token('<'), this.print(e, t), this.token('>'), this.space(), this.print(r, t)
  }
  function Nj(t) {
    this.print(t.expression, t), this.print(t.typeParameters, t)
  }
  function Oj(t) {
    const { declare: e, const: r, id: i, members: n } = t
    e && (this.word('declare'), this.space()),
      r && (this.word('const'), this.space()),
      this.word('enum'),
      this.space(),
      this.print(i, t),
      this.space(),
      this.tsPrintBraced(n, t)
  }
  function Dj(t) {
    const { id: e, initializer: r } = t
    this.print(e, t), r && (this.space(), this.token('='), this.space(), this.print(r, t)), this.token(',')
  }
  function Bj(t) {
    const { declare: e, id: r } = t
    if (
      (e && (this.word('declare'), this.space()),
      t.global || (this.word(r.type === 'Identifier' ? 'namespace' : 'module'), this.space()),
      this.print(r, t),
      !t.body)
    ) {
      this.token(';')
      return
    }
    let i = t.body
    for (; i.type === 'TSModuleDeclaration'; ) this.token('.'), this.print(i.id, i), (i = i.body)
    this.space(), this.print(i, t)
  }
  function Lj(t) {
    this.tsPrintBraced(t.body, t)
  }
  function Mj(t) {
    const { argument: e, qualifier: r, typeParameters: i } = t
    this.word('import'),
      this.token('('),
      this.print(e, t),
      this.token(')'),
      r && (this.token('.'), this.print(r, t)),
      i && this.print(i, t)
  }
  function Fj(t) {
    const { isExport: e, id: r, moduleReference: i } = t
    e && (this.word('export'), this.space()),
      this.word('import'),
      this.space(),
      this.print(r, t),
      this.space(),
      this.token('='),
      this.space(),
      this.print(i, t),
      this.token(';')
  }
  function $j(t) {
    this.token('require('), this.print(t.expression, t), this.token(')')
  }
  function Rj(t) {
    this.print(t.expression, t), this.token('!')
  }
  function jj(t) {
    this.word('export'), this.space(), this.token('='), this.space(), this.print(t.expression, t), this.token(';')
  }
  function _j(t) {
    this.word('export'),
      this.space(),
      this.word('as'),
      this.space(),
      this.word('namespace'),
      this.space(),
      this.print(t.id, t)
  }
  function Vj(t) {
    const { typeParameters: e } = t,
      r = t.parameters
    this.print(e, t), this.token('('), this._parameters(r, t), this.token(')')
    const i = t.typeAnnotation
    this.print(i, t)
  }
  function Uj(t, e) {
    e && t.declare && (this.word('declare'), this.space()),
      t.accessibility && (this.word(t.accessibility), this.space()),
      t.static && (this.word('static'), this.space()),
      t.override && (this.word('override'), this.space()),
      t.abstract && (this.word('abstract'), this.space()),
      e && t.readonly && (this.word('readonly'), this.space())
  }
  ;(function (t) {
    Object.defineProperty(t, '__esModule', { value: !0 })
    var e = Es
    Object.keys(e).forEach(function (f) {
      f === 'default' ||
        f === '__esModule' ||
        (f in t && t[f] === e[f]) ||
        Object.defineProperty(t, f, {
          enumerable: !0,
          get: function () {
            return e[f]
          },
        })
    })
    var r = ht
    Object.keys(r).forEach(function (f) {
      f === 'default' ||
        f === '__esModule' ||
        (f in t && t[f] === r[f]) ||
        Object.defineProperty(t, f, {
          enumerable: !0,
          get: function () {
            return r[f]
          },
        })
    })
    var i = St
    Object.keys(i).forEach(function (f) {
      f === 'default' ||
        f === '__esModule' ||
        (f in t && t[f] === i[f]) ||
        Object.defineProperty(t, f, {
          enumerable: !0,
          get: function () {
            return i[f]
          },
        })
    })
    var n = hr
    Object.keys(n).forEach(function (f) {
      f === 'default' ||
        f === '__esModule' ||
        (f in t && t[f] === n[f]) ||
        Object.defineProperty(t, f, {
          enumerable: !0,
          get: function () {
            return n[f]
          },
        })
    })
    var s = Cr
    Object.keys(s).forEach(function (f) {
      f === 'default' ||
        f === '__esModule' ||
        (f in t && t[f] === s[f]) ||
        Object.defineProperty(t, f, {
          enumerable: !0,
          get: function () {
            return s[f]
          },
        })
    })
    var a = nr
    Object.keys(a).forEach(function (f) {
      f === 'default' ||
        f === '__esModule' ||
        (f in t && t[f] === a[f]) ||
        Object.defineProperty(t, f, {
          enumerable: !0,
          get: function () {
            return a[f]
          },
        })
    })
    var o = wt
    Object.keys(o).forEach(function (f) {
      f === 'default' ||
        f === '__esModule' ||
        (f in t && t[f] === o[f]) ||
        Object.defineProperty(t, f, {
          enumerable: !0,
          get: function () {
            return o[f]
          },
        })
    })
    var u = py
    Object.keys(u).forEach(function (f) {
      f === 'default' ||
        f === '__esModule' ||
        (f in t && t[f] === u[f]) ||
        Object.defineProperty(t, f, {
          enumerable: !0,
          get: function () {
            return u[f]
          },
        })
    })
    var c = Kr
    Object.keys(c).forEach(function (f) {
      f === 'default' ||
        f === '__esModule' ||
        (f in t && t[f] === c[f]) ||
        Object.defineProperty(t, f, {
          enumerable: !0,
          get: function () {
            return c[f]
          },
        })
    })
    var p = $t
    Object.keys(p).forEach(function (f) {
      f === 'default' ||
        f === '__esModule' ||
        (f in t && t[f] === p[f]) ||
        Object.defineProperty(t, f, {
          enumerable: !0,
          get: function () {
            return p[f]
          },
        })
    })
    var h = Be
    Object.keys(h).forEach(function (f) {
      f === 'default' ||
        f === '__esModule' ||
        (f in t && t[f] === h[f]) ||
        Object.defineProperty(t, f, {
          enumerable: !0,
          get: function () {
            return h[f]
          },
        })
    })
  })(Zm),
    Object.defineProperty(ao, '__esModule', { value: !0 }),
    (ao.default = void 0)
  var zj = oo,
    Kj = Ji,
    Wj = st,
    Yj = Zm
  const { isProgram: Hj, isFile: qj, isEmptyStatement: Xj } = Wj,
    Gj = /e/i,
    Jj = /\.0+$/,
    Zj = /^0[box]/,
    hy = /^\s*[@#]__PURE__\s*$/,
    { needsParens: Qj, needsWhitespaceAfter: e_, needsWhitespaceBefore: t_ } = Kj
  class vc {
    constructor(e, r) {
      ;(this.inForStatementInitCounter = 0),
        (this._printStack = []),
        (this._indent = 0),
        (this._insideAux = !1),
        (this._parenPushNewlineState = null),
        (this._noLineTerminator = !1),
        (this._printAuxAfterOnNextUserNode = !1),
        (this._printedComments = new WeakSet()),
        (this._endsWithInteger = !1),
        (this._endsWithWord = !1),
        (this.format = e),
        (this._buf = new zj.default(r))
    }
    generate(e) {
      return this.print(e), this._maybeAddAuxComment(), this._buf.get()
    }
    indent() {
      this.format.compact || this.format.concise || this._indent++
    }
    dedent() {
      this.format.compact || this.format.concise || this._indent--
    }
    semicolon(e = !1) {
      this._maybeAddAuxComment(), this._append(';', !e)
    }
    rightBrace() {
      this.format.minified && this._buf.removeLastSemicolon(), this.token('}')
    }
    space(e = !1) {
      if (!this.format.compact) {
        if (e) this._space()
        else if (this._buf.hasContent()) {
          const r = this.getLastChar()
          r !== 32 && r !== 10 && this._space()
        }
      }
    }
    word(e) {
      ;(this._endsWithWord || (this.endsWith(47) && e.charCodeAt(0) === 47)) && this._space(),
        this._maybeAddAuxComment(),
        this._append(e),
        (this._endsWithWord = !0)
    }
    number(e) {
      this.word(e),
        (this._endsWithInteger =
          Number.isInteger(+e) && !Zj.test(e) && !Gj.test(e) && !Jj.test(e) && e.charCodeAt(e.length - 1) !== 46)
    }
    token(e) {
      const r = this.getLastChar(),
        i = e.charCodeAt(0)
      ;((e === '--' && r === 33) ||
        (i === 43 && r === 43) ||
        (i === 45 && r === 45) ||
        (i === 46 && this._endsWithInteger)) &&
        this._space(),
        this._maybeAddAuxComment(),
        this._append(e)
    }
    newline(e = 1) {
      if (this.format.retainLines || this.format.compact) return
      if (this.format.concise) {
        this.space()
        return
      }
      const r = this.endsWithCharAndNewline()
      if (r !== 10 && ((r === 123 || r === 58) && e--, !(e <= 0))) for (let i = 0; i < e; i++) this._newline()
    }
    endsWith(e) {
      return this.getLastChar() === e
    }
    getLastChar() {
      return this._buf.getLastChar()
    }
    endsWithCharAndNewline() {
      return this._buf.endsWithCharAndNewline()
    }
    removeTrailingNewline() {
      this._buf.removeTrailingNewline()
    }
    exactSource(e, r) {
      this._catchUp('start', e), this._buf.exactSource(e, r)
    }
    source(e, r) {
      this._catchUp(e, r), this._buf.source(e, r)
    }
    withSource(e, r, i) {
      this._catchUp(e, r), this._buf.withSource(e, r, i)
    }
    _space() {
      this._append(' ', !0)
    }
    _newline() {
      this._append(
        `
`,
        !0
      )
    }
    _append(e, r = !1) {
      this._maybeAddParen(e),
        this._maybeIndent(e),
        r ? this._buf.queue(e) : this._buf.append(e),
        (this._endsWithWord = !1),
        (this._endsWithInteger = !1)
    }
    _maybeIndent(e) {
      this._indent && this.endsWith(10) && e.charCodeAt(0) !== 10 && this._buf.queueIndentation(this._getIndent())
    }
    _maybeAddParen(e) {
      const r = this._parenPushNewlineState
      if (!r) return
      let i
      for (i = 0; i < e.length && e[i] === ' '; i++);
      if (i === e.length) return
      const n = e[i]
      if (
        n !==
        `
`
      ) {
        if (n !== '/' || i + 1 === e.length) {
          this._parenPushNewlineState = null
          return
        }
        const s = e[i + 1]
        if (s === '*') {
          if (hy.test(e.slice(i + 2, e.length - 2))) return
        } else if (s !== '/') {
          this._parenPushNewlineState = null
          return
        }
      }
      this.token('('), this.indent(), (r.printed = !0)
    }
    _catchUp(e, r) {
      if (!this.format.retainLines) return
      const i = r ? r[e] : null
      if ((i == null ? void 0 : i.line) != null) {
        const n = i.line - this._buf.getCurrentLine()
        for (let s = 0; s < n; s++) this._newline()
      }
    }
    _getIndent() {
      return this.format.indent.style.repeat(this._indent)
    }
    startTerminatorless(e = !1) {
      return e ? ((this._noLineTerminator = !0), null) : (this._parenPushNewlineState = { printed: !1 })
    }
    endTerminatorless(e) {
      ;(this._noLineTerminator = !1), e != null && e.printed && (this.dedent(), this.newline(), this.token(')'))
    }
    print(e, r) {
      if (!e) return
      const i = this.format.concise
      e._compact && (this.format.concise = !0)
      const n = this[e.type]
      if (!n)
        throw new ReferenceError(
          `unknown node of type ${JSON.stringify(e.type)} with constructor ${JSON.stringify(
            e == null ? void 0 : e.constructor.name
          )}`
        )
      this._printStack.push(e)
      const s = this._insideAux
      ;(this._insideAux = !e.loc), this._maybeAddAuxComment(this._insideAux && !s)
      let a = Qj(e, r, this._printStack)
      this.format.retainFunctionParens &&
        e.type === 'FunctionExpression' &&
        e.extra &&
        e.extra.parenthesized &&
        (a = !0),
        a && this.token('('),
        this._printLeadingComments(e)
      const o = Hj(e) || qj(e) ? null : e.loc
      this.withSource('start', o, () => {
        n.call(this, e, r)
      }),
        this._printTrailingComments(e),
        a && this.token(')'),
        this._printStack.pop(),
        (this.format.concise = i),
        (this._insideAux = s)
    }
    _maybeAddAuxComment(e) {
      e && this._printAuxBeforeComment(), this._insideAux || this._printAuxAfterComment()
    }
    _printAuxBeforeComment() {
      if (this._printAuxAfterOnNextUserNode) return
      this._printAuxAfterOnNextUserNode = !0
      const e = this.format.auxiliaryCommentBefore
      e && this._printComment({ type: 'CommentBlock', value: e })
    }
    _printAuxAfterComment() {
      if (!this._printAuxAfterOnNextUserNode) return
      this._printAuxAfterOnNextUserNode = !1
      const e = this.format.auxiliaryCommentAfter
      e && this._printComment({ type: 'CommentBlock', value: e })
    }
    getPossibleRaw(e) {
      const r = e.extra
      if (r && r.raw != null && r.rawValue != null && e.value === r.rawValue) return r.raw
    }
    printJoin(e, r, i = {}) {
      if (!(e != null && e.length)) return
      i.indent && this.indent()
      const n = { addNewlines: i.addNewlines }
      for (let s = 0; s < e.length; s++) {
        const a = e[s]
        !a ||
          (i.statement && this._printNewline(!0, a, r, n),
          this.print(a, r),
          i.iterator && i.iterator(a, s),
          i.separator && s < e.length - 1 && i.separator.call(this),
          i.statement && this._printNewline(!1, a, r, n))
      }
      i.indent && this.dedent()
    }
    printAndIndentOnComments(e, r) {
      const i = e.leadingComments && e.leadingComments.length > 0
      i && this.indent(), this.print(e, r), i && this.dedent()
    }
    printBlock(e) {
      const r = e.body
      Xj(r) || this.space(), this.print(r, e)
    }
    _printTrailingComments(e) {
      this._printComments(this._getComments(!1, e))
    }
    _printLeadingComments(e) {
      this._printComments(this._getComments(!0, e), !0)
    }
    printInnerComments(e, r = !0) {
      var i
      !((i = e.innerComments) != null && i.length) ||
        (r && this.indent(), this._printComments(e.innerComments), r && this.dedent())
    }
    printSequence(e, r, i = {}) {
      return (i.statement = !0), this.printJoin(e, r, i)
    }
    printList(e, r, i = {}) {
      return i.separator == null && (i.separator = i_), this.printJoin(e, r, i)
    }
    _printNewline(e, r, i, n) {
      if (this.format.retainLines || this.format.compact) return
      if (this.format.concise) {
        this.space()
        return
      }
      let s = 0
      this._buf.hasContent() &&
        (e || s++, n.addNewlines && (s += n.addNewlines(e, r) || 0), (e ? t_ : e_)(r, i) && s++),
        this.newline(Math.min(2, s))
    }
    _getComments(e, r) {
      return (r && (e ? r.leadingComments : r.trailingComments)) || []
    }
    _printComment(e, r) {
      if (!this.format.shouldPrintComment(e.value) || e.ignore || this._printedComments.has(e)) return
      this._printedComments.add(e)
      const i = e.type === 'CommentBlock',
        n = i && !r && !this._noLineTerminator
      n && this._buf.hasContent() && this.newline(1)
      const s = this.getLastChar()
      s !== 91 && s !== 123 && this.space()
      let a =
        !i && !this._noLineTerminator
          ? `//${e.value}
`
          : `/*${e.value}*/`
      if (i && this.format.indent.adjustMultilineComment) {
        var o
        const u = (o = e.loc) == null ? void 0 : o.start.column
        if (u) {
          const p = new RegExp('\\n\\s{1,' + u + '}', 'g')
          a = a.replace(
            p,
            `
`
          )
        }
        const c = Math.max(this._getIndent().length, this.format.retainLines ? 0 : this._buf.getCurrentColumn())
        a = a.replace(
          /\n(?!$)/g,
          `
${' '.repeat(c)}`
        )
      }
      this.endsWith(47) && this._space(),
        this.withSource('start', e.loc, () => {
          this._append(a)
        }),
        n && this.newline(1)
    }
    _printComments(e, r) {
      if (!!(e != null && e.length))
        if (r && e.length === 1 && hy.test(e[0].value))
          this._printComment(e[0], this._buf.hasContent() && !this.endsWith(10))
        else for (const i of e) this._printComment(i)
    }
    printAssertions(e) {
      var r
      ;(r = e.assertions) != null &&
        r.length &&
        (this.space(),
        this.word('assert'),
        this.space(),
        this.token('{'),
        this.space(),
        this.printList(e.assertions, e),
        this.space(),
        this.token('}'))
    }
  }
  Object.assign(vc.prototype, Yj), (vc.prototype.Noop = function () {})
  var r_ = vc
  ao.default = r_
  function i_() {
    this.token(','), this.space()
  }
  Object.defineProperty(Ts, '__esModule', { value: !0 }), (Ts.CodeGenerator = void 0)
  var n_ = (Ts.default = u_),
    s_ = no,
    a_ = ao
  class dy extends a_.default {
    constructor(e, r = {}, i) {
      const n = o_(i, r),
        s = r.sourceMaps ? new s_.default(r, i) : null
      super(n, s), (this.ast = void 0), (this.ast = e)
    }
    generate() {
      return super.generate(this.ast)
    }
  }
  function o_(t, e) {
    const r = {
      auxiliaryCommentBefore: e.auxiliaryCommentBefore,
      auxiliaryCommentAfter: e.auxiliaryCommentAfter,
      shouldPrintComment: e.shouldPrintComment,
      retainLines: e.retainLines,
      retainFunctionParens: e.retainFunctionParens,
      comments: e.comments == null || e.comments,
      compact: e.compact,
      minified: e.minified,
      concise: e.concise,
      indent: { adjustMultilineComment: !0, style: '  ', base: 0 },
      decoratorsBeforeExport: !!e.decoratorsBeforeExport,
      jsescOption: Object.assign({ quotes: 'double', wrap: !0, minimal: !1 }, e.jsescOption),
      recordAndTupleSyntaxType: e.recordAndTupleSyntaxType,
      topicToken: e.topicToken,
    }
    return (
      (r.jsonCompatibleStrings = e.jsonCompatibleStrings),
      r.minified
        ? ((r.compact = !0), (r.shouldPrintComment = r.shouldPrintComment || (() => r.comments)))
        : (r.shouldPrintComment =
            r.shouldPrintComment || ((i) => r.comments || i.indexOf('@license') >= 0 || i.indexOf('@preserve') >= 0)),
      r.compact === 'auto' &&
        ((r.compact = t.length > 5e5),
        r.compact &&
          console.error(
            `[BABEL] Note: The code generator has deoptimised the styling of ${e.filename} as it exceeds the max of 500KB.`
          )),
      r.compact && (r.indent.adjustMultilineComment = !1),
      r
    )
  }
  class l_ {
    constructor(e, r, i) {
      ;(this._generator = void 0), (this._generator = new dy(e, r, i))
    }
    generate() {
      return this._generator.generate()
    }
  }
  Ts.CodeGenerator = l_
  function u_(t, e, r) {
    return new dy(t, e, r).generate()
  }
  var dr = {}
  Object.defineProperty(dr, '__esModule', { value: !0 }),
    (dr.find = h_),
    (dr.findParent = f_),
    (dr.getAncestry = T_),
    (dr.getDeepestCommonAncestorFrom = g_),
    (dr.getEarliestCommonAncestorFrom = y_),
    (dr.getFunctionParent = d_),
    (dr.getStatementParent = m_),
    (dr.inType = v_),
    (dr.isAncestor = b_),
    (dr.isDescendant = S_)
  var c_ = st
  const { VISITOR_KEYS: p_ } = c_
  function f_(t) {
    let e = this
    for (; (e = e.parentPath); ) if (t(e)) return e
    return null
  }
  function h_(t) {
    let e = this
    do if (t(e)) return e
    while ((e = e.parentPath))
    return null
  }
  function d_() {
    return this.findParent((t) => t.isFunction())
  }
  function m_() {
    let t = this
    do {
      if (!t.parentPath || (Array.isArray(t.container) && t.isStatement())) break
      t = t.parentPath
    } while (t)
    if (t && (t.isProgram() || t.isFile()))
      throw new Error("File/Program node, we can't possibly find a statement parent to this")
    return t
  }
  function y_(t) {
    return this.getDeepestCommonAncestorFrom(t, function (e, r, i) {
      let n
      const s = p_[e.type]
      for (const a of i) {
        const o = a[r + 1]
        if (!n) {
          n = o
          continue
        }
        if (o.listKey && n.listKey === o.listKey && o.key < n.key) {
          n = o
          continue
        }
        const u = s.indexOf(n.parentKey),
          c = s.indexOf(o.parentKey)
        u > c && (n = o)
      }
      return n
    })
  }
  function g_(t, e) {
    if (!t.length) return this
    if (t.length === 1) return t[0]
    let r = 1 / 0,
      i,
      n
    const s = t.map((o) => {
        const u = []
        do u.unshift(o)
        while ((o = o.parentPath) && o !== this)
        return u.length < r && (r = u.length), u
      }),
      a = s[0]
    e: for (let o = 0; o < r; o++) {
      const u = a[o]
      for (const c of s) if (c[o] !== u) break e
      ;(i = o), (n = u)
    }
    if (n) return e ? e(n, i, s) : n
    throw new Error("Couldn't find intersection")
  }
  function T_() {
    let t = this
    const e = []
    do e.push(t)
    while ((t = t.parentPath))
    return e
  }
  function b_(t) {
    return t.isDescendant(this)
  }
  function S_(t) {
    return !!this.findParent((e) => e === t)
  }
  function v_(...t) {
    let e = this
    for (; e; ) {
      for (const r of t) if (e.node.type === r) return !0
      e = e.parentPath
    }
    return !1
  }
  var di = {},
    my = {},
    Ec = {}
  Object.defineProperty(Ec, '__esModule', { value: !0 }), (Ec.default = C_)
  var E_ = st
  const {
    BOOLEAN_NUMBER_BINARY_OPERATORS: P_,
    createFlowUnionType: mo,
    createTSUnionType: yo,
    createTypeAnnotationBasedOnTypeof: w_,
    createUnionTypeAnnotation: yy,
    isTSTypeAnnotation: gy,
    numberTypeAnnotation: Ty,
    voidTypeAnnotation: A_,
  } = E_
  function C_(t) {
    if (!this.isReferenced()) return
    const e = this.scope.getBinding(t.name)
    if (e) return e.identifier.typeAnnotation ? e.identifier.typeAnnotation : x_(e, this, t.name)
    if (t.name === 'undefined') return A_()
    if (t.name === 'NaN' || t.name === 'Infinity') return Ty()
    t.name
  }
  function x_(t, e, r) {
    const i = [],
      n = []
    let s = by(t, e, n)
    const a = Sy(t, e, r)
    if (a) {
      const o = by(t, a.ifStatement)
      ;(s = s.filter((u) => o.indexOf(u) < 0)), i.push(a.typeAnnotation)
    }
    if (s.length) {
      s.push(...n)
      for (const o of s) i.push(o.getTypeAnnotation())
    }
    if (!!i.length) return gy(i[0]) && yo ? yo(i) : mo ? mo(i) : yy(i)
  }
  function by(t, e, r) {
    const i = t.constantViolations.slice()
    return (
      i.unshift(t.path),
      i.filter((n) => {
        n = n.resolve()
        const s = n._guessExecutionStatusRelativeTo(e)
        return r && s === 'unknown' && r.push(n), s === 'before'
      })
    )
  }
  function I_(t, e) {
    const r = e.node.operator,
      i = e.get('right').resolve(),
      n = e.get('left').resolve()
    let s
    if ((n.isIdentifier({ name: t }) ? (s = i) : i.isIdentifier({ name: t }) && (s = n), s))
      return r === '===' ? s.getTypeAnnotation() : P_.indexOf(r) >= 0 ? Ty() : void 0
    if (r !== '===' && r !== '==') return
    let a, o
    if (
      (n.isUnaryExpression({ operator: 'typeof' })
        ? ((a = n), (o = i))
        : i.isUnaryExpression({ operator: 'typeof' }) && ((a = i), (o = n)),
      !a || !a.get('argument').isIdentifier({ name: t }) || ((o = o.resolve()), !o.isLiteral()))
    )
      return
    const u = o.node.value
    if (typeof u == 'string') return w_(u)
  }
  function k_(t, e, r) {
    let i
    for (; (i = e.parentPath); ) {
      if (i.isIfStatement() || i.isConditionalExpression()) return e.key === 'test' ? void 0 : i
      if (i.isFunction() && i.parentPath.scope.getBinding(r) !== t) return
      e = i
    }
  }
  function Sy(t, e, r) {
    const i = k_(t, e, r)
    if (!i) return
    const s = [i.get('test')],
      a = []
    for (let o = 0; o < s.length; o++) {
      const u = s[o]
      if (u.isLogicalExpression()) u.node.operator === '&&' && (s.push(u.get('left')), s.push(u.get('right')))
      else if (u.isBinaryExpression()) {
        const c = I_(r, u)
        c && a.push(c)
      }
    }
    return a.length
      ? gy(a[0]) && yo
        ? { typeAnnotation: yo(a), ifStatement: i }
        : mo
        ? { typeAnnotation: mo(a), ifStatement: i }
        : { typeAnnotation: yy(a), ifStatement: i }
      : Sy(i, r)
  }
  ;(function (t) {
    Object.defineProperty(t, '__esModule', { value: !0 }),
      (t.ArrayExpression = ke),
      (t.AssignmentExpression = Te),
      (t.BinaryExpression = H),
      (t.BooleanLiteral = W),
      (t.CallExpression = We),
      (t.ConditionalExpression = J),
      (t.ClassDeclaration =
        t.ClassExpression =
        t.FunctionDeclaration =
        t.ArrowFunctionExpression =
        t.FunctionExpression =
          de),
      Object.defineProperty(t, 'Identifier', {
        enumerable: !0,
        get: function () {
          return r.default
        },
      }),
      (t.LogicalExpression = w),
      (t.NewExpression = K),
      (t.NullLiteral = ge),
      (t.NumericLiteral = U),
      (t.ObjectExpression = me),
      (t.ParenthesizedExpression = G),
      (t.RegExpLiteral = ye),
      (t.RestElement = ae),
      (t.SequenceExpression = X),
      (t.StringLiteral = se),
      (t.TaggedTemplateExpression = A),
      (t.TemplateLiteral = Y),
      (t.TypeCastExpression = B),
      (t.UnaryExpression = C),
      (t.UpdateExpression = ce),
      (t.VariableDeclarator = I)
    var e = st,
      r = Ec
    const {
      BOOLEAN_BINARY_OPERATORS: i,
      BOOLEAN_UNARY_OPERATORS: n,
      NUMBER_BINARY_OPERATORS: s,
      NUMBER_UNARY_OPERATORS: a,
      STRING_UNARY_OPERATORS: o,
      anyTypeAnnotation: u,
      arrayTypeAnnotation: c,
      booleanTypeAnnotation: p,
      buildMatchMemberExpression: h,
      createFlowUnionType: f,
      createTSUnionType: d,
      createUnionTypeAnnotation: T,
      genericTypeAnnotation: y,
      identifier: b,
      isTSTypeAnnotation: m,
      nullLiteralTypeAnnotation: S,
      numberTypeAnnotation: E,
      stringTypeAnnotation: P,
      tupleTypeAnnotation: x,
      unionTypeAnnotation: D,
      voidTypeAnnotation: N,
    } = e
    function I() {
      var ie
      if (!this.get('id').isIdentifier()) return
      const F = this.get('init')
      let q = F.getTypeAnnotation()
      return (
        ((ie = q) == null ? void 0 : ie.type) === 'AnyTypeAnnotation' &&
          F.isCallExpression() &&
          F.get('callee').isIdentifier({ name: 'Array' }) &&
          !F.scope.hasBinding('Array', !0) &&
          (q = ke()),
        q
      )
    }
    function B(ie) {
      return ie.typeAnnotation
    }
    B.validParent = !0
    function K(ie) {
      if (this.get('callee').isIdentifier()) return y(ie.callee)
    }
    function Y() {
      return P()
    }
    function C(ie) {
      const L = ie.operator
      if (L === 'void') return N()
      if (a.indexOf(L) >= 0) return E()
      if (o.indexOf(L) >= 0) return P()
      if (n.indexOf(L) >= 0) return p()
    }
    function H(ie) {
      const L = ie.operator
      if (s.indexOf(L) >= 0) return E()
      if (i.indexOf(L) >= 0) return p()
      if (L === '+') {
        const F = this.get('right'),
          q = this.get('left')
        return q.isBaseType('number') && F.isBaseType('number')
          ? E()
          : q.isBaseType('string') || F.isBaseType('string')
          ? P()
          : D([P(), E()])
      }
    }
    function w() {
      const ie = [this.get('left').getTypeAnnotation(), this.get('right').getTypeAnnotation()]
      return m(ie[0]) && d ? d(ie) : f ? f(ie) : T(ie)
    }
    function J() {
      const ie = [this.get('consequent').getTypeAnnotation(), this.get('alternate').getTypeAnnotation()]
      return m(ie[0]) && d ? d(ie) : f ? f(ie) : T(ie)
    }
    function X() {
      return this.get('expressions').pop().getTypeAnnotation()
    }
    function G() {
      return this.get('expression').getTypeAnnotation()
    }
    function Te() {
      return this.get('right').getTypeAnnotation()
    }
    function ce(ie) {
      const L = ie.operator
      if (L === '++' || L === '--') return E()
    }
    function se() {
      return P()
    }
    function U() {
      return E()
    }
    function W() {
      return p()
    }
    function ge() {
      return S()
    }
    function ye() {
      return y(b('RegExp'))
    }
    function me() {
      return y(b('Object'))
    }
    function ke() {
      return y(b('Array'))
    }
    function ae() {
      return ke()
    }
    ae.validParent = !0
    function de() {
      return y(b('Function'))
    }
    const be = h('Array.from'),
      Pe = h('Object.keys'),
      De = h('Object.values'),
      Le = h('Object.entries')
    function We() {
      const { callee: ie } = this.node
      return Pe(ie) ? c(P()) : be(ie) || De(ie) ? c(u()) : Le(ie) ? c(x([P(), u()])) : pe(this.get('callee'))
    }
    function A() {
      return pe(this.get('tag'))
    }
    function pe(ie) {
      if (((ie = ie.resolve()), ie.isFunction())) {
        if (ie.is('async')) return ie.is('generator') ? y(b('AsyncIterator')) : y(b('Promise'))
        if (ie.node.returnType) return ie.node.returnType
      }
    }
  })(my),
    Object.defineProperty(di, '__esModule', { value: !0 }),
    (di._getTypeAnnotation = W_),
    (di.baseTypeStrictlyMatches = q_),
    (di.couldBeBaseType = H_),
    (di.getTypeAnnotation = K_),
    (di.isBaseType = Y_),
    (di.isGenericType = X_)
  var vy = my,
    N_ = st
  const {
    anyTypeAnnotation: Ey,
    isAnyTypeAnnotation: go,
    isBooleanTypeAnnotation: O_,
    isEmptyTypeAnnotation: D_,
    isFlowBaseAnnotation: B_,
    isGenericTypeAnnotation: L_,
    isIdentifier: M_,
    isMixedTypeAnnotation: F_,
    isNumberTypeAnnotation: $_,
    isStringTypeAnnotation: R_,
    isTypeAnnotation: j_,
    isUnionTypeAnnotation: __,
    isVoidTypeAnnotation: V_,
    stringTypeAnnotation: U_,
    voidTypeAnnotation: z_,
  } = N_
  function K_() {
    let t = this.getData('typeAnnotation')
    return (
      t != null ||
        ((t = this._getTypeAnnotation() || Ey()), j_(t) && (t = t.typeAnnotation), this.setData('typeAnnotation', t)),
      t
    )
  }
  const Pc = new WeakSet()
  function W_() {
    const t = this.node
    if (!t)
      if (this.key === 'init' && this.parentPath.isVariableDeclarator()) {
        const r = this.parentPath.parentPath,
          i = r.parentPath
        return r.key === 'left' && i.isForInStatement() ? U_() : r.key === 'left' && i.isForOfStatement() ? Ey() : z_()
      } else return
    if (t.typeAnnotation) return t.typeAnnotation
    if (!Pc.has(t)) {
      Pc.add(t)
      try {
        var e
        let r = vy[t.type]
        if (r) return r.call(this, t)
        if (((r = vy[this.parentPath.type]), (e = r) != null && e.validParent))
          return this.parentPath.getTypeAnnotation()
      } finally {
        Pc.delete(t)
      }
    }
  }
  function Y_(t, e) {
    return wc(t, this.getTypeAnnotation(), e)
  }
  function wc(t, e, r) {
    if (t === 'string') return R_(e)
    if (t === 'number') return $_(e)
    if (t === 'boolean') return O_(e)
    if (t === 'any') return go(e)
    if (t === 'mixed') return F_(e)
    if (t === 'empty') return D_(e)
    if (t === 'void') return V_(e)
    if (r) return !1
    throw new Error(`Unknown base type ${t}`)
  }
  function H_(t) {
    const e = this.getTypeAnnotation()
    if (go(e)) return !0
    if (__(e)) {
      for (const r of e.types) if (go(r) || wc(t, r, !0)) return !0
      return !1
    } else return wc(t, e, !0)
  }
  function q_(t) {
    const e = this.getTypeAnnotation(),
      r = t.getTypeAnnotation()
    return !go(e) && B_(e) ? r.type === e.type : !1
  }
  function X_(t) {
    const e = this.getTypeAnnotation()
    return L_(e) && M_(e.id, { name: t })
  }
  var mi = {},
    ws = {},
    As = {},
    To = {}
  Object.defineProperty(To, '__esModule', { value: !0 }),
    (To.default =
      /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g),
    (To.matchToToken = function (t) {
      var e = { type: 'invalid', value: t[0], closed: void 0 }
      return (
        t[1]
          ? ((e.type = 'string'), (e.closed = !!(t[3] || t[4])))
          : t[5]
          ? (e.type = 'comment')
          : t[6]
          ? ((e.type = 'comment'), (e.closed = !!t[7]))
          : t[8]
          ? (e.type = 'regex')
          : t[9]
          ? (e.type = 'number')
          : t[10]
          ? (e.type = 'name')
          : t[11]
          ? (e.type = 'punctuator')
          : t[12] && (e.type = 'whitespace'),
        e
      )
    })
  var Py = { exports: {} },
    G_ = /[|\\{}()[\]^$+*?.]/g,
    J_ = function (t) {
      if (typeof t != 'string') throw new TypeError('Expected a string')
      return t.replace(G_, '\\$&')
    },
    wy = { exports: {} },
    Ac = { exports: {} },
    Z_ = {
      aliceblue: [240, 248, 255],
      antiquewhite: [250, 235, 215],
      aqua: [0, 255, 255],
      aquamarine: [127, 255, 212],
      azure: [240, 255, 255],
      beige: [245, 245, 220],
      bisque: [255, 228, 196],
      black: [0, 0, 0],
      blanchedalmond: [255, 235, 205],
      blue: [0, 0, 255],
      blueviolet: [138, 43, 226],
      brown: [165, 42, 42],
      burlywood: [222, 184, 135],
      cadetblue: [95, 158, 160],
      chartreuse: [127, 255, 0],
      chocolate: [210, 105, 30],
      coral: [255, 127, 80],
      cornflowerblue: [100, 149, 237],
      cornsilk: [255, 248, 220],
      crimson: [220, 20, 60],
      cyan: [0, 255, 255],
      darkblue: [0, 0, 139],
      darkcyan: [0, 139, 139],
      darkgoldenrod: [184, 134, 11],
      darkgray: [169, 169, 169],
      darkgreen: [0, 100, 0],
      darkgrey: [169, 169, 169],
      darkkhaki: [189, 183, 107],
      darkmagenta: [139, 0, 139],
      darkolivegreen: [85, 107, 47],
      darkorange: [255, 140, 0],
      darkorchid: [153, 50, 204],
      darkred: [139, 0, 0],
      darksalmon: [233, 150, 122],
      darkseagreen: [143, 188, 143],
      darkslateblue: [72, 61, 139],
      darkslategray: [47, 79, 79],
      darkslategrey: [47, 79, 79],
      darkturquoise: [0, 206, 209],
      darkviolet: [148, 0, 211],
      deeppink: [255, 20, 147],
      deepskyblue: [0, 191, 255],
      dimgray: [105, 105, 105],
      dimgrey: [105, 105, 105],
      dodgerblue: [30, 144, 255],
      firebrick: [178, 34, 34],
      floralwhite: [255, 250, 240],
      forestgreen: [34, 139, 34],
      fuchsia: [255, 0, 255],
      gainsboro: [220, 220, 220],
      ghostwhite: [248, 248, 255],
      gold: [255, 215, 0],
      goldenrod: [218, 165, 32],
      gray: [128, 128, 128],
      green: [0, 128, 0],
      greenyellow: [173, 255, 47],
      grey: [128, 128, 128],
      honeydew: [240, 255, 240],
      hotpink: [255, 105, 180],
      indianred: [205, 92, 92],
      indigo: [75, 0, 130],
      ivory: [255, 255, 240],
      khaki: [240, 230, 140],
      lavender: [230, 230, 250],
      lavenderblush: [255, 240, 245],
      lawngreen: [124, 252, 0],
      lemonchiffon: [255, 250, 205],
      lightblue: [173, 216, 230],
      lightcoral: [240, 128, 128],
      lightcyan: [224, 255, 255],
      lightgoldenrodyellow: [250, 250, 210],
      lightgray: [211, 211, 211],
      lightgreen: [144, 238, 144],
      lightgrey: [211, 211, 211],
      lightpink: [255, 182, 193],
      lightsalmon: [255, 160, 122],
      lightseagreen: [32, 178, 170],
      lightskyblue: [135, 206, 250],
      lightslategray: [119, 136, 153],
      lightslategrey: [119, 136, 153],
      lightsteelblue: [176, 196, 222],
      lightyellow: [255, 255, 224],
      lime: [0, 255, 0],
      limegreen: [50, 205, 50],
      linen: [250, 240, 230],
      magenta: [255, 0, 255],
      maroon: [128, 0, 0],
      mediumaquamarine: [102, 205, 170],
      mediumblue: [0, 0, 205],
      mediumorchid: [186, 85, 211],
      mediumpurple: [147, 112, 219],
      mediumseagreen: [60, 179, 113],
      mediumslateblue: [123, 104, 238],
      mediumspringgreen: [0, 250, 154],
      mediumturquoise: [72, 209, 204],
      mediumvioletred: [199, 21, 133],
      midnightblue: [25, 25, 112],
      mintcream: [245, 255, 250],
      mistyrose: [255, 228, 225],
      moccasin: [255, 228, 181],
      navajowhite: [255, 222, 173],
      navy: [0, 0, 128],
      oldlace: [253, 245, 230],
      olive: [128, 128, 0],
      olivedrab: [107, 142, 35],
      orange: [255, 165, 0],
      orangered: [255, 69, 0],
      orchid: [218, 112, 214],
      palegoldenrod: [238, 232, 170],
      palegreen: [152, 251, 152],
      paleturquoise: [175, 238, 238],
      palevioletred: [219, 112, 147],
      papayawhip: [255, 239, 213],
      peachpuff: [255, 218, 185],
      peru: [205, 133, 63],
      pink: [255, 192, 203],
      plum: [221, 160, 221],
      powderblue: [176, 224, 230],
      purple: [128, 0, 128],
      rebeccapurple: [102, 51, 153],
      red: [255, 0, 0],
      rosybrown: [188, 143, 143],
      royalblue: [65, 105, 225],
      saddlebrown: [139, 69, 19],
      salmon: [250, 128, 114],
      sandybrown: [244, 164, 96],
      seagreen: [46, 139, 87],
      seashell: [255, 245, 238],
      sienna: [160, 82, 45],
      silver: [192, 192, 192],
      skyblue: [135, 206, 235],
      slateblue: [106, 90, 205],
      slategray: [112, 128, 144],
      slategrey: [112, 128, 144],
      snow: [255, 250, 250],
      springgreen: [0, 255, 127],
      steelblue: [70, 130, 180],
      tan: [210, 180, 140],
      teal: [0, 128, 128],
      thistle: [216, 191, 216],
      tomato: [255, 99, 71],
      turquoise: [64, 224, 208],
      violet: [238, 130, 238],
      wheat: [245, 222, 179],
      white: [255, 255, 255],
      whitesmoke: [245, 245, 245],
      yellow: [255, 255, 0],
      yellowgreen: [154, 205, 50],
    },
    Qi = Z_,
    Ay = {}
  for (var Cc in Qi) Qi.hasOwnProperty(Cc) && (Ay[Qi[Cc]] = Cc)
  var je = (Ac.exports = {
    rgb: { channels: 3, labels: 'rgb' },
    hsl: { channels: 3, labels: 'hsl' },
    hsv: { channels: 3, labels: 'hsv' },
    hwb: { channels: 3, labels: 'hwb' },
    cmyk: { channels: 4, labels: 'cmyk' },
    xyz: { channels: 3, labels: 'xyz' },
    lab: { channels: 3, labels: 'lab' },
    lch: { channels: 3, labels: 'lch' },
    hex: { channels: 1, labels: ['hex'] },
    keyword: { channels: 1, labels: ['keyword'] },
    ansi16: { channels: 1, labels: ['ansi16'] },
    ansi256: { channels: 1, labels: ['ansi256'] },
    hcg: { channels: 3, labels: ['h', 'c', 'g'] },
    apple: { channels: 3, labels: ['r16', 'g16', 'b16'] },
    gray: { channels: 1, labels: ['gray'] },
  })
  for (var sr in je)
    if (je.hasOwnProperty(sr)) {
      if (!('channels' in je[sr])) throw new Error('missing channels property: ' + sr)
      if (!('labels' in je[sr])) throw new Error('missing channel labels property: ' + sr)
      if (je[sr].labels.length !== je[sr].channels) throw new Error('channel and label counts mismatch: ' + sr)
      var Q_ = je[sr].channels,
        eV = je[sr].labels
      delete je[sr].channels,
        delete je[sr].labels,
        Object.defineProperty(je[sr], 'channels', { value: Q_ }),
        Object.defineProperty(je[sr], 'labels', { value: eV })
    }
  ;(je.rgb.hsl = function (t) {
    var e = t[0] / 255,
      r = t[1] / 255,
      i = t[2] / 255,
      n = Math.min(e, r, i),
      s = Math.max(e, r, i),
      a = s - n,
      o,
      u,
      c
    return (
      s === n
        ? (o = 0)
        : e === s
        ? (o = (r - i) / a)
        : r === s
        ? (o = 2 + (i - e) / a)
        : i === s && (o = 4 + (e - r) / a),
      (o = Math.min(o * 60, 360)),
      o < 0 && (o += 360),
      (c = (n + s) / 2),
      s === n ? (u = 0) : c <= 0.5 ? (u = a / (s + n)) : (u = a / (2 - s - n)),
      [o, u * 100, c * 100]
    )
  }),
    (je.rgb.hsv = function (t) {
      var e,
        r,
        i,
        n,
        s,
        a = t[0] / 255,
        o = t[1] / 255,
        u = t[2] / 255,
        c = Math.max(a, o, u),
        p = c - Math.min(a, o, u),
        h = function (f) {
          return (c - f) / 6 / p + 1 / 2
        }
      return (
        p === 0
          ? (n = s = 0)
          : ((s = p / c),
            (e = h(a)),
            (r = h(o)),
            (i = h(u)),
            a === c ? (n = i - r) : o === c ? (n = 1 / 3 + e - i) : u === c && (n = 2 / 3 + r - e),
            n < 0 ? (n += 1) : n > 1 && (n -= 1)),
        [n * 360, s * 100, c * 100]
      )
    }),
    (je.rgb.hwb = function (t) {
      var e = t[0],
        r = t[1],
        i = t[2],
        n = je.rgb.hsl(t)[0],
        s = (1 / 255) * Math.min(e, Math.min(r, i))
      return (i = 1 - (1 / 255) * Math.max(e, Math.max(r, i))), [n, s * 100, i * 100]
    }),
    (je.rgb.cmyk = function (t) {
      var e = t[0] / 255,
        r = t[1] / 255,
        i = t[2] / 255,
        n,
        s,
        a,
        o
      return (
        (o = Math.min(1 - e, 1 - r, 1 - i)),
        (n = (1 - e - o) / (1 - o) || 0),
        (s = (1 - r - o) / (1 - o) || 0),
        (a = (1 - i - o) / (1 - o) || 0),
        [n * 100, s * 100, a * 100, o * 100]
      )
    })
  function tV(t, e) {
    return Math.pow(t[0] - e[0], 2) + Math.pow(t[1] - e[1], 2) + Math.pow(t[2] - e[2], 2)
  }
  ;(je.rgb.keyword = function (t) {
    var e = Ay[t]
    if (e) return e
    var r = 1 / 0,
      i
    for (var n in Qi)
      if (Qi.hasOwnProperty(n)) {
        var s = Qi[n],
          a = tV(t, s)
        a < r && ((r = a), (i = n))
      }
    return i
  }),
    (je.keyword.rgb = function (t) {
      return Qi[t]
    }),
    (je.rgb.xyz = function (t) {
      var e = t[0] / 255,
        r = t[1] / 255,
        i = t[2] / 255
      ;(e = e > 0.04045 ? Math.pow((e + 0.055) / 1.055, 2.4) : e / 12.92),
        (r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92),
        (i = i > 0.04045 ? Math.pow((i + 0.055) / 1.055, 2.4) : i / 12.92)
      var n = e * 0.4124 + r * 0.3576 + i * 0.1805,
        s = e * 0.2126 + r * 0.7152 + i * 0.0722,
        a = e * 0.0193 + r * 0.1192 + i * 0.9505
      return [n * 100, s * 100, a * 100]
    }),
    (je.rgb.lab = function (t) {
      var e = je.rgb.xyz(t),
        r = e[0],
        i = e[1],
        n = e[2],
        s,
        a,
        o
      return (
        (r /= 95.047),
        (i /= 100),
        (n /= 108.883),
        (r = r > 0.008856 ? Math.pow(r, 1 / 3) : 7.787 * r + 16 / 116),
        (i = i > 0.008856 ? Math.pow(i, 1 / 3) : 7.787 * i + 16 / 116),
        (n = n > 0.008856 ? Math.pow(n, 1 / 3) : 7.787 * n + 16 / 116),
        (s = 116 * i - 16),
        (a = 500 * (r - i)),
        (o = 200 * (i - n)),
        [s, a, o]
      )
    }),
    (je.hsl.rgb = function (t) {
      var e = t[0] / 360,
        r = t[1] / 100,
        i = t[2] / 100,
        n,
        s,
        a,
        o,
        u
      if (r === 0) return (u = i * 255), [u, u, u]
      i < 0.5 ? (s = i * (1 + r)) : (s = i + r - i * r), (n = 2 * i - s), (o = [0, 0, 0])
      for (var c = 0; c < 3; c++)
        (a = e + (1 / 3) * -(c - 1)),
          a < 0 && a++,
          a > 1 && a--,
          6 * a < 1
            ? (u = n + (s - n) * 6 * a)
            : 2 * a < 1
            ? (u = s)
            : 3 * a < 2
            ? (u = n + (s - n) * (2 / 3 - a) * 6)
            : (u = n),
          (o[c] = u * 255)
      return o
    }),
    (je.hsl.hsv = function (t) {
      var e = t[0],
        r = t[1] / 100,
        i = t[2] / 100,
        n = r,
        s = Math.max(i, 0.01),
        a,
        o
      return (
        (i *= 2),
        (r *= i <= 1 ? i : 2 - i),
        (n *= s <= 1 ? s : 2 - s),
        (o = (i + r) / 2),
        (a = i === 0 ? (2 * n) / (s + n) : (2 * r) / (i + r)),
        [e, a * 100, o * 100]
      )
    }),
    (je.hsv.rgb = function (t) {
      var e = t[0] / 60,
        r = t[1] / 100,
        i = t[2] / 100,
        n = Math.floor(e) % 6,
        s = e - Math.floor(e),
        a = 255 * i * (1 - r),
        o = 255 * i * (1 - r * s),
        u = 255 * i * (1 - r * (1 - s))
      switch (((i *= 255), n)) {
        case 0:
          return [i, u, a]
        case 1:
          return [o, i, a]
        case 2:
          return [a, i, u]
        case 3:
          return [a, o, i]
        case 4:
          return [u, a, i]
        case 5:
          return [i, a, o]
      }
    }),
    (je.hsv.hsl = function (t) {
      var e = t[0],
        r = t[1] / 100,
        i = t[2] / 100,
        n = Math.max(i, 0.01),
        s,
        a,
        o
      return (
        (o = (2 - r) * i),
        (s = (2 - r) * n),
        (a = r * n),
        (a /= s <= 1 ? s : 2 - s),
        (a = a || 0),
        (o /= 2),
        [e, a * 100, o * 100]
      )
    }),
    (je.hwb.rgb = function (t) {
      var e = t[0] / 360,
        r = t[1] / 100,
        i = t[2] / 100,
        n = r + i,
        s,
        a,
        o,
        u
      n > 1 && ((r /= n), (i /= n)),
        (s = Math.floor(6 * e)),
        (a = 1 - i),
        (o = 6 * e - s),
        (s & 1) !== 0 && (o = 1 - o),
        (u = r + o * (a - r))
      var c, p, h
      switch (s) {
        default:
        case 6:
        case 0:
          ;(c = a), (p = u), (h = r)
          break
        case 1:
          ;(c = u), (p = a), (h = r)
          break
        case 2:
          ;(c = r), (p = a), (h = u)
          break
        case 3:
          ;(c = r), (p = u), (h = a)
          break
        case 4:
          ;(c = u), (p = r), (h = a)
          break
        case 5:
          ;(c = a), (p = r), (h = u)
          break
      }
      return [c * 255, p * 255, h * 255]
    }),
    (je.cmyk.rgb = function (t) {
      var e = t[0] / 100,
        r = t[1] / 100,
        i = t[2] / 100,
        n = t[3] / 100,
        s,
        a,
        o
      return (
        (s = 1 - Math.min(1, e * (1 - n) + n)),
        (a = 1 - Math.min(1, r * (1 - n) + n)),
        (o = 1 - Math.min(1, i * (1 - n) + n)),
        [s * 255, a * 255, o * 255]
      )
    }),
    (je.xyz.rgb = function (t) {
      var e = t[0] / 100,
        r = t[1] / 100,
        i = t[2] / 100,
        n,
        s,
        a
      return (
        (n = e * 3.2406 + r * -1.5372 + i * -0.4986),
        (s = e * -0.9689 + r * 1.8758 + i * 0.0415),
        (a = e * 0.0557 + r * -0.204 + i * 1.057),
        (n = n > 0.0031308 ? 1.055 * Math.pow(n, 1 / 2.4) - 0.055 : n * 12.92),
        (s = s > 0.0031308 ? 1.055 * Math.pow(s, 1 / 2.4) - 0.055 : s * 12.92),
        (a = a > 0.0031308 ? 1.055 * Math.pow(a, 1 / 2.4) - 0.055 : a * 12.92),
        (n = Math.min(Math.max(0, n), 1)),
        (s = Math.min(Math.max(0, s), 1)),
        (a = Math.min(Math.max(0, a), 1)),
        [n * 255, s * 255, a * 255]
      )
    }),
    (je.xyz.lab = function (t) {
      var e = t[0],
        r = t[1],
        i = t[2],
        n,
        s,
        a
      return (
        (e /= 95.047),
        (r /= 100),
        (i /= 108.883),
        (e = e > 0.008856 ? Math.pow(e, 1 / 3) : 7.787 * e + 16 / 116),
        (r = r > 0.008856 ? Math.pow(r, 1 / 3) : 7.787 * r + 16 / 116),
        (i = i > 0.008856 ? Math.pow(i, 1 / 3) : 7.787 * i + 16 / 116),
        (n = 116 * r - 16),
        (s = 500 * (e - r)),
        (a = 200 * (r - i)),
        [n, s, a]
      )
    }),
    (je.lab.xyz = function (t) {
      var e = t[0],
        r = t[1],
        i = t[2],
        n,
        s,
        a
      ;(s = (e + 16) / 116), (n = r / 500 + s), (a = s - i / 200)
      var o = Math.pow(s, 3),
        u = Math.pow(n, 3),
        c = Math.pow(a, 3)
      return (
        (s = o > 0.008856 ? o : (s - 16 / 116) / 7.787),
        (n = u > 0.008856 ? u : (n - 16 / 116) / 7.787),
        (a = c > 0.008856 ? c : (a - 16 / 116) / 7.787),
        (n *= 95.047),
        (s *= 100),
        (a *= 108.883),
        [n, s, a]
      )
    }),
    (je.lab.lch = function (t) {
      var e = t[0],
        r = t[1],
        i = t[2],
        n,
        s,
        a
      return (
        (n = Math.atan2(i, r)),
        (s = (n * 360) / 2 / Math.PI),
        s < 0 && (s += 360),
        (a = Math.sqrt(r * r + i * i)),
        [e, a, s]
      )
    }),
    (je.lch.lab = function (t) {
      var e = t[0],
        r = t[1],
        i = t[2],
        n,
        s,
        a
      return (a = (i / 360) * 2 * Math.PI), (n = r * Math.cos(a)), (s = r * Math.sin(a)), [e, n, s]
    }),
    (je.rgb.ansi16 = function (t) {
      var e = t[0],
        r = t[1],
        i = t[2],
        n = 1 in arguments ? arguments[1] : je.rgb.hsv(t)[2]
      if (((n = Math.round(n / 50)), n === 0)) return 30
      var s = 30 + ((Math.round(i / 255) << 2) | (Math.round(r / 255) << 1) | Math.round(e / 255))
      return n === 2 && (s += 60), s
    }),
    (je.hsv.ansi16 = function (t) {
      return je.rgb.ansi16(je.hsv.rgb(t), t[2])
    }),
    (je.rgb.ansi256 = function (t) {
      var e = t[0],
        r = t[1],
        i = t[2]
      if (e === r && r === i) return e < 8 ? 16 : e > 248 ? 231 : Math.round(((e - 8) / 247) * 24) + 232
      var n = 16 + 36 * Math.round((e / 255) * 5) + 6 * Math.round((r / 255) * 5) + Math.round((i / 255) * 5)
      return n
    }),
    (je.ansi16.rgb = function (t) {
      var e = t % 10
      if (e === 0 || e === 7) return t > 50 && (e += 3.5), (e = (e / 10.5) * 255), [e, e, e]
      var r = (~~(t > 50) + 1) * 0.5,
        i = (e & 1) * r * 255,
        n = ((e >> 1) & 1) * r * 255,
        s = ((e >> 2) & 1) * r * 255
      return [i, n, s]
    }),
    (je.ansi256.rgb = function (t) {
      if (t >= 232) {
        var e = (t - 232) * 10 + 8
        return [e, e, e]
      }
      t -= 16
      var r,
        i = (Math.floor(t / 36) / 5) * 255,
        n = (Math.floor((r = t % 36) / 6) / 5) * 255,
        s = ((r % 6) / 5) * 255
      return [i, n, s]
    }),
    (je.rgb.hex = function (t) {
      var e = ((Math.round(t[0]) & 255) << 16) + ((Math.round(t[1]) & 255) << 8) + (Math.round(t[2]) & 255),
        r = e.toString(16).toUpperCase()
      return '000000'.substring(r.length) + r
    }),
    (je.hex.rgb = function (t) {
      var e = t.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i)
      if (!e) return [0, 0, 0]
      var r = e[0]
      e[0].length === 3 &&
        (r = r
          .split('')
          .map(function (o) {
            return o + o
          })
          .join(''))
      var i = parseInt(r, 16),
        n = (i >> 16) & 255,
        s = (i >> 8) & 255,
        a = i & 255
      return [n, s, a]
    }),
    (je.rgb.hcg = function (t) {
      var e = t[0] / 255,
        r = t[1] / 255,
        i = t[2] / 255,
        n = Math.max(Math.max(e, r), i),
        s = Math.min(Math.min(e, r), i),
        a = n - s,
        o,
        u
      return (
        a < 1 ? (o = s / (1 - a)) : (o = 0),
        a <= 0
          ? (u = 0)
          : n === e
          ? (u = ((r - i) / a) % 6)
          : n === r
          ? (u = 2 + (i - e) / a)
          : (u = 4 + (e - r) / a + 4),
        (u /= 6),
        (u %= 1),
        [u * 360, a * 100, o * 100]
      )
    }),
    (je.hsl.hcg = function (t) {
      var e = t[1] / 100,
        r = t[2] / 100,
        i = 1,
        n = 0
      return (
        r < 0.5 ? (i = 2 * e * r) : (i = 2 * e * (1 - r)),
        i < 1 && (n = (r - 0.5 * i) / (1 - i)),
        [t[0], i * 100, n * 100]
      )
    }),
    (je.hsv.hcg = function (t) {
      var e = t[1] / 100,
        r = t[2] / 100,
        i = e * r,
        n = 0
      return i < 1 && (n = (r - i) / (1 - i)), [t[0], i * 100, n * 100]
    }),
    (je.hcg.rgb = function (t) {
      var e = t[0] / 360,
        r = t[1] / 100,
        i = t[2] / 100
      if (r === 0) return [i * 255, i * 255, i * 255]
      var n = [0, 0, 0],
        s = (e % 1) * 6,
        a = s % 1,
        o = 1 - a,
        u = 0
      switch (Math.floor(s)) {
        case 0:
          ;(n[0] = 1), (n[1] = a), (n[2] = 0)
          break
        case 1:
          ;(n[0] = o), (n[1] = 1), (n[2] = 0)
          break
        case 2:
          ;(n[0] = 0), (n[1] = 1), (n[2] = a)
          break
        case 3:
          ;(n[0] = 0), (n[1] = o), (n[2] = 1)
          break
        case 4:
          ;(n[0] = a), (n[1] = 0), (n[2] = 1)
          break
        default:
          ;(n[0] = 1), (n[1] = 0), (n[2] = o)
      }
      return (u = (1 - r) * i), [(r * n[0] + u) * 255, (r * n[1] + u) * 255, (r * n[2] + u) * 255]
    }),
    (je.hcg.hsv = function (t) {
      var e = t[1] / 100,
        r = t[2] / 100,
        i = e + r * (1 - e),
        n = 0
      return i > 0 && (n = e / i), [t[0], n * 100, i * 100]
    }),
    (je.hcg.hsl = function (t) {
      var e = t[1] / 100,
        r = t[2] / 100,
        i = r * (1 - e) + 0.5 * e,
        n = 0
      return (
        i > 0 && i < 0.5 ? (n = e / (2 * i)) : i >= 0.5 && i < 1 && (n = e / (2 * (1 - i))), [t[0], n * 100, i * 100]
      )
    }),
    (je.hcg.hwb = function (t) {
      var e = t[1] / 100,
        r = t[2] / 100,
        i = e + r * (1 - e)
      return [t[0], (i - e) * 100, (1 - i) * 100]
    }),
    (je.hwb.hcg = function (t) {
      var e = t[1] / 100,
        r = t[2] / 100,
        i = 1 - r,
        n = i - e,
        s = 0
      return n < 1 && (s = (i - n) / (1 - n)), [t[0], n * 100, s * 100]
    }),
    (je.apple.rgb = function (t) {
      return [(t[0] / 65535) * 255, (t[1] / 65535) * 255, (t[2] / 65535) * 255]
    }),
    (je.rgb.apple = function (t) {
      return [(t[0] / 255) * 65535, (t[1] / 255) * 65535, (t[2] / 255) * 65535]
    }),
    (je.gray.rgb = function (t) {
      return [(t[0] / 100) * 255, (t[0] / 100) * 255, (t[0] / 100) * 255]
    }),
    (je.gray.hsl = je.gray.hsv =
      function (t) {
        return [0, 0, t[0]]
      }),
    (je.gray.hwb = function (t) {
      return [0, 100, t[0]]
    }),
    (je.gray.cmyk = function (t) {
      return [0, 0, 0, t[0]]
    }),
    (je.gray.lab = function (t) {
      return [t[0], 0, 0]
    }),
    (je.gray.hex = function (t) {
      var e = Math.round((t[0] / 100) * 255) & 255,
        r = (e << 16) + (e << 8) + e,
        i = r.toString(16).toUpperCase()
      return '000000'.substring(i.length) + i
    }),
    (je.rgb.gray = function (t) {
      var e = (t[0] + t[1] + t[2]) / 3
      return [(e / 255) * 100]
    })
  var bo = Ac.exports
  function rV() {
    for (var t = {}, e = Object.keys(bo), r = e.length, i = 0; i < r; i++) t[e[i]] = { distance: -1, parent: null }
    return t
  }
  function iV(t) {
    var e = rV(),
      r = [t]
    for (e[t].distance = 0; r.length; )
      for (var i = r.pop(), n = Object.keys(bo[i]), s = n.length, a = 0; a < s; a++) {
        var o = n[a],
          u = e[o]
        u.distance === -1 && ((u.distance = e[i].distance + 1), (u.parent = i), r.unshift(o))
      }
    return e
  }
  function nV(t, e) {
    return function (r) {
      return e(t(r))
    }
  }
  function sV(t, e) {
    for (var r = [e[t].parent, t], i = bo[e[t].parent][t], n = e[t].parent; e[n].parent; )
      r.unshift(e[n].parent), (i = nV(bo[e[n].parent][n], i)), (n = e[n].parent)
    return (i.conversion = r), i
  }
  var aV = function (t) {
      for (var e = iV(t), r = {}, i = Object.keys(e), n = i.length, s = 0; s < n; s++) {
        var a = i[s],
          o = e[a]
        o.parent !== null && (r[a] = sV(a, e))
      }
      return r
    },
    xc = Ac.exports,
    oV = aV,
    Nn = {},
    lV = Object.keys(xc)
  function uV(t) {
    var e = function (r) {
      return r == null ? r : (arguments.length > 1 && (r = Array.prototype.slice.call(arguments)), t(r))
    }
    return 'conversion' in t && (e.conversion = t.conversion), e
  }
  function cV(t) {
    var e = function (r) {
      if (r == null) return r
      arguments.length > 1 && (r = Array.prototype.slice.call(arguments))
      var i = t(r)
      if (typeof i == 'object') for (var n = i.length, s = 0; s < n; s++) i[s] = Math.round(i[s])
      return i
    }
    return 'conversion' in t && (e.conversion = t.conversion), e
  }
  lV.forEach(function (t) {
    ;(Nn[t] = {}),
      Object.defineProperty(Nn[t], 'channels', { value: xc[t].channels }),
      Object.defineProperty(Nn[t], 'labels', { value: xc[t].labels })
    var e = oV(t),
      r = Object.keys(e)
    r.forEach(function (i) {
      var n = e[i]
      ;(Nn[t][i] = cV(n)), (Nn[t][i].raw = uV(n))
    })
  })
  var pV = Nn
  ;(function (t) {
    const e = pV,
      r = (a, o) =>
        function () {
          return `\x1B[${a.apply(e, arguments) + o}m`
        },
      i = (a, o) =>
        function () {
          const u = a.apply(e, arguments)
          return `\x1B[${38 + o};5;${u}m`
        },
      n = (a, o) =>
        function () {
          const u = a.apply(e, arguments)
          return `\x1B[${38 + o};2;${u[0]};${u[1]};${u[2]}m`
        }
    function s() {
      const a = new Map(),
        o = {
          modifier: {
            reset: [0, 0],
            bold: [1, 22],
            dim: [2, 22],
            italic: [3, 23],
            underline: [4, 24],
            inverse: [7, 27],
            hidden: [8, 28],
            strikethrough: [9, 29],
          },
          color: {
            black: [30, 39],
            red: [31, 39],
            green: [32, 39],
            yellow: [33, 39],
            blue: [34, 39],
            magenta: [35, 39],
            cyan: [36, 39],
            white: [37, 39],
            gray: [90, 39],
            redBright: [91, 39],
            greenBright: [92, 39],
            yellowBright: [93, 39],
            blueBright: [94, 39],
            magentaBright: [95, 39],
            cyanBright: [96, 39],
            whiteBright: [97, 39],
          },
          bgColor: {
            bgBlack: [40, 49],
            bgRed: [41, 49],
            bgGreen: [42, 49],
            bgYellow: [43, 49],
            bgBlue: [44, 49],
            bgMagenta: [45, 49],
            bgCyan: [46, 49],
            bgWhite: [47, 49],
            bgBlackBright: [100, 49],
            bgRedBright: [101, 49],
            bgGreenBright: [102, 49],
            bgYellowBright: [103, 49],
            bgBlueBright: [104, 49],
            bgMagentaBright: [105, 49],
            bgCyanBright: [106, 49],
            bgWhiteBright: [107, 49],
          },
        }
      o.color.grey = o.color.gray
      for (const p of Object.keys(o)) {
        const h = o[p]
        for (const f of Object.keys(h)) {
          const d = h[f]
          ;(o[f] = { open: `\x1B[${d[0]}m`, close: `\x1B[${d[1]}m` }), (h[f] = o[f]), a.set(d[0], d[1])
        }
        Object.defineProperty(o, p, { value: h, enumerable: !1 }),
          Object.defineProperty(o, 'codes', { value: a, enumerable: !1 })
      }
      const u = (p) => p,
        c = (p, h, f) => [p, h, f]
      ;(o.color.close = '\x1B[39m'),
        (o.bgColor.close = '\x1B[49m'),
        (o.color.ansi = { ansi: r(u, 0) }),
        (o.color.ansi256 = { ansi256: i(u, 0) }),
        (o.color.ansi16m = { rgb: n(c, 0) }),
        (o.bgColor.ansi = { ansi: r(u, 10) }),
        (o.bgColor.ansi256 = { ansi256: i(u, 10) }),
        (o.bgColor.ansi16m = { rgb: n(c, 10) })
      for (let p of Object.keys(e)) {
        if (typeof e[p] != 'object') continue
        const h = e[p]
        p === 'ansi16' && (p = 'ansi'),
          'ansi16' in h && ((o.color.ansi[p] = r(h.ansi16, 0)), (o.bgColor.ansi[p] = r(h.ansi16, 10))),
          'ansi256' in h && ((o.color.ansi256[p] = i(h.ansi256, 0)), (o.bgColor.ansi256[p] = i(h.ansi256, 10))),
          'rgb' in h && ((o.color.ansi16m[p] = n(h.rgb, 0)), (o.bgColor.ansi16m[p] = n(h.rgb, 10)))
      }
      return o
    }
    Object.defineProperty(t, 'exports', { enumerable: !0, get: s })
  })(wy)
  var fV = { stdout: !1, stderr: !1 }
  const hV =
      /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi,
    Cy = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g,
    dV = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/,
    mV = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi,
    yV = new Map([
      [
        'n',
        `
`,
      ],
      ['r', '\r'],
      ['t', '	'],
      ['b', '\b'],
      ['f', '\f'],
      ['v', '\v'],
      ['0', '\0'],
      ['\\', '\\'],
      ['e', '\x1B'],
      ['a', '\x07'],
    ])
  function xy(t) {
    return (t[0] === 'u' && t.length === 5) || (t[0] === 'x' && t.length === 3)
      ? String.fromCharCode(parseInt(t.slice(1), 16))
      : yV.get(t) || t
  }
  function gV(t, e) {
    const r = [],
      i = e.trim().split(/\s*,\s*/g)
    let n
    for (const s of i)
      if (!isNaN(s)) r.push(Number(s))
      else if ((n = s.match(dV))) r.push(n[2].replace(mV, (a, o, u) => (o ? xy(o) : u)))
      else throw new Error(`Invalid Chalk template style argument: ${s} (in style '${t}')`)
    return r
  }
  function TV(t) {
    Cy.lastIndex = 0
    const e = []
    let r
    for (; (r = Cy.exec(t)) !== null; ) {
      const i = r[1]
      if (r[2]) {
        const n = gV(i, r[2])
        e.push([i].concat(n))
      } else e.push([i])
    }
    return e
  }
  function Iy(t, e) {
    const r = {}
    for (const n of e) for (const s of n.styles) r[s[0]] = n.inverse ? null : s.slice(1)
    let i = t
    for (const n of Object.keys(r))
      if (Array.isArray(r[n])) {
        if (!(n in i)) throw new Error(`Unknown Chalk style: ${n}`)
        r[n].length > 0 ? (i = i[n].apply(i, r[n])) : (i = i[n])
      }
    return i
  }
  var bV = (t, e) => {
    const r = [],
      i = []
    let n = []
    if (
      (e.replace(hV, (s, a, o, u, c, p) => {
        if (a) n.push(xy(a))
        else if (u) {
          const h = n.join('')
          ;(n = []), i.push(r.length === 0 ? h : Iy(t, r)(h)), r.push({ inverse: o, styles: TV(u) })
        } else if (c) {
          if (r.length === 0) throw new Error('Found extraneous } in Chalk template literal')
          i.push(Iy(t, r)(n.join(''))), (n = []), r.pop()
        } else n.push(p)
      }),
      i.push(n.join('')),
      r.length > 0)
    ) {
      const s = `Chalk template literal is missing ${r.length} closing bracket${r.length === 1 ? '' : 's'} (\`}\`)`
      throw new Error(s)
    }
    return i.join('')
  }
  ;(function (t) {
    const e = J_,
      r = wy.exports,
      i = fV.stdout,
      n = bV,
      s = process.platform === 'win32' && !({}.TERM || '').toLowerCase().startsWith('xterm'),
      a = ['ansi', 'ansi', 'ansi256', 'ansi16m'],
      o = new Set(['gray']),
      u = Object.create(null)
    function c(y, b) {
      b = b || {}
      const m = 0
      ;(y.level = b.level === void 0 ? m : b.level), (y.enabled = 'enabled' in b ? b.enabled : y.level > 0)
    }
    function p(y) {
      if (!this || !(this instanceof p) || this.template) {
        const b = {}
        return (
          c(b, y),
          (b.template = function () {
            const m = [].slice.call(arguments)
            return T.apply(null, [b.template].concat(m))
          }),
          Object.setPrototypeOf(b, p.prototype),
          Object.setPrototypeOf(b.template, b),
          (b.template.constructor = p),
          b.template
        )
      }
      c(this, y)
    }
    s && (r.blue.open = '\x1B[94m')
    for (const y of Object.keys(r))
      (r[y].closeRe = new RegExp(e(r[y].close), 'g')),
        (u[y] = {
          get() {
            const b = r[y]
            return f.call(this, this._styles ? this._styles.concat(b) : [b], this._empty, y)
          },
        })
    ;(u.visible = {
      get() {
        return f.call(this, this._styles || [], !0, 'visible')
      },
    }),
      (r.color.closeRe = new RegExp(e(r.color.close), 'g'))
    for (const y of Object.keys(r.color.ansi))
      o.has(y) ||
        (u[y] = {
          get() {
            const b = this.level
            return function () {
              const S = {
                open: r.color[a[b]][y].apply(null, arguments),
                close: r.color.close,
                closeRe: r.color.closeRe,
              }
              return f.call(this, this._styles ? this._styles.concat(S) : [S], this._empty, y)
            }
          },
        })
    r.bgColor.closeRe = new RegExp(e(r.bgColor.close), 'g')
    for (const y of Object.keys(r.bgColor.ansi)) {
      if (o.has(y)) continue
      const b = 'bg' + y[0].toUpperCase() + y.slice(1)
      u[b] = {
        get() {
          const m = this.level
          return function () {
            const E = {
              open: r.bgColor[a[m]][y].apply(null, arguments),
              close: r.bgColor.close,
              closeRe: r.bgColor.closeRe,
            }
            return f.call(this, this._styles ? this._styles.concat(E) : [E], this._empty, y)
          }
        },
      }
    }
    const h = Object.defineProperties(() => {}, u)
    function f(y, b, m) {
      const S = function () {
        return d.apply(S, arguments)
      }
      ;(S._styles = y), (S._empty = b)
      const E = this
      return (
        Object.defineProperty(S, 'level', {
          enumerable: !0,
          get() {
            return E.level
          },
          set(P) {
            E.level = P
          },
        }),
        Object.defineProperty(S, 'enabled', {
          enumerable: !0,
          get() {
            return E.enabled
          },
          set(P) {
            E.enabled = P
          },
        }),
        (S.hasGrey = this.hasGrey || m === 'gray' || m === 'grey'),
        (S.__proto__ = h),
        S
      )
    }
    function d() {
      const y = arguments,
        b = y.length
      let m = String(arguments[0])
      if (b === 0) return ''
      if (b > 1) for (let E = 1; E < b; E++) m += ' ' + y[E]
      if (!this.enabled || this.level <= 0 || !m) return this._empty ? '' : m
      const S = r.dim.open
      s && this.hasGrey && (r.dim.open = '')
      for (const E of this._styles.slice().reverse())
        (m = E.open + m.replace(E.closeRe, E.open) + E.close), (m = m.replace(/\r?\n/g, `${E.close}$&${E.open}`))
      return (r.dim.open = S), m
    }
    function T(y, b) {
      if (!Array.isArray(b)) return [].slice.call(arguments, 1).join(' ')
      const m = [].slice.call(arguments, 2),
        S = [b.raw[0]]
      for (let E = 1; E < b.length; E++) S.push(String(m[E - 1]).replace(/[{}\\]/g, '\\$&')), S.push(String(b.raw[E]))
      return n(y, S.join(''))
    }
    Object.defineProperties(p.prototype, u),
      (t.exports = p()),
      (t.exports.supportsColor = i),
      (t.exports.default = t.exports)
  })(Py),
    Object.defineProperty(As, '__esModule', { value: !0 }),
    (As.default = AV),
    (As.getChalk = By),
    (As.shouldHighlight = Dy)
  var ky = To,
    Ny = ps,
    Ic = Py.exports
  const SV = new Set(['as', 'async', 'from', 'get', 'of', 'set'])
  function vV(t) {
    return {
      keyword: t.cyan,
      capitalized: t.yellow,
      jsxIdentifier: t.yellow,
      punctuator: t.yellow,
      number: t.magenta,
      string: t.green,
      regex: t.magenta,
      comment: t.grey,
      invalid: t.white.bgRed.bold,
    }
  }
  const EV = /\r\n|[\n\r\u2028\u2029]/,
    PV = /^[()[\]{}]$/
  let Oy
  {
    const t = /^[a-z][\w-]*$/i,
      e = function (r, i, n) {
        if (r.type === 'name') {
          if ((0, Ny.isKeyword)(r.value) || (0, Ny.isStrictReservedWord)(r.value, !0) || SV.has(r.value))
            return 'keyword'
          if (t.test(r.value) && (n[i - 1] === '<' || n.slice(i - 2, i) == '</')) return 'jsxIdentifier'
          if (r.value[0] !== r.value[0].toLowerCase()) return 'capitalized'
        }
        return r.type === 'punctuator' && PV.test(r.value)
          ? 'bracket'
          : r.type === 'invalid' && (r.value === '@' || r.value === '#')
          ? 'punctuator'
          : r.type
      }
    Oy = function* (r) {
      let i
      for (; (i = ky.default.exec(r)); ) {
        const n = ky.matchToToken(i)
        yield { type: e(n, i.index, r), value: n.value }
      }
    }
  }
  function wV(t, e) {
    let r = ''
    for (const { type: i, value: n } of Oy(e)) {
      const s = t[i]
      s
        ? (r += n.split(EV).map((a) => s(a)).join(`
`))
        : (r += n)
    }
    return r
  }
  function Dy(t) {
    return !!Ic.supportsColor || t.forceColor
  }
  function By(t) {
    return t.forceColor ? new Ic.constructor({ enabled: !0, level: 1 }) : Ic
  }
  function AV(t, e = {}) {
    if (t !== '' && Dy(e)) {
      const r = By(e),
        i = vV(r)
      return wV(i, t)
    } else return t
  }
  Object.defineProperty(ws, '__esModule', { value: !0 }), (ws.codeFrameColumns = Fy), (ws.default = IV)
  var kc = As
  let Ly = !1
  function CV(t) {
    return { gutter: t.grey, marker: t.red.bold, message: t.red.bold }
  }
  const My = /\r\n|[\n\r\u2028\u2029]/
  function xV(t, e, r) {
    const i = Object.assign({ column: 0, line: -1 }, t.start),
      n = Object.assign({}, i, t.end),
      { linesAbove: s = 2, linesBelow: a = 3 } = r || {},
      o = i.line,
      u = i.column,
      c = n.line,
      p = n.column
    let h = Math.max(o - (s + 1), 0),
      f = Math.min(e.length, c + a)
    o === -1 && (h = 0), c === -1 && (f = e.length)
    const d = c - o,
      T = {}
    if (d)
      for (let y = 0; y <= d; y++) {
        const b = y + o
        if (!u) T[b] = !0
        else if (y === 0) {
          const m = e[b - 1].length
          T[b] = [u, m - u + 1]
        } else if (y === d) T[b] = [0, p]
        else {
          const m = e[b - y].length
          T[b] = [0, m]
        }
      }
    else u === p ? (u ? (T[o] = [u, 0]) : (T[o] = !0)) : (T[o] = [u, p - u])
    return { start: h, end: f, markerLines: T }
  }
  function Fy(t, e, r = {}) {
    const i = (r.highlightCode || r.forceColor) && (0, kc.shouldHighlight)(r),
      n = (0, kc.getChalk)(r),
      s = CV(n),
      a = (y, b) => (i ? y(b) : b),
      o = t.split(My),
      { start: u, end: c, markerLines: p } = xV(e, o, r),
      h = e.start && typeof e.start.column == 'number',
      f = String(c).length
    let T = (i ? (0, kc.default)(t, r) : t)
      .split(My, c)
      .slice(u, c)
      .map((y, b) => {
        const m = u + 1 + b,
          E = ` ${` ${m}`.slice(-f)} |`,
          P = p[m],
          x = !p[m + 1]
        if (P) {
          let D = ''
          if (Array.isArray(P)) {
            const N = y.slice(0, Math.max(P[0] - 1, 0)).replace(/[^\t]/g, ' '),
              I = P[1] || 1
            ;(D = [
              `
 `,
              a(s.gutter, E.replace(/\d/g, ' ')),
              ' ',
              N,
              a(s.marker, '^').repeat(I),
            ].join('')),
              x && r.message && (D += ' ' + a(s.message, r.message))
          }
          return [a(s.marker, '>'), a(s.gutter, E), y.length > 0 ? ` ${y}` : '', D].join('')
        } else return ` ${a(s.gutter, E)}${y.length > 0 ? ` ${y}` : ''}`
      }).join(`
`)
    return (
      r.message &&
        !h &&
        (T = `${' '.repeat(f + 1)}${r.message}
${T}`),
      i ? n.reset(T) : T
    )
  }
  function IV(t, e, r, i = {}) {
    if (!Ly) {
      Ly = !0
      const s = 'Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.'
      if (process.emitWarning) process.emitWarning(s, 'DeprecationWarning')
      else {
        const a = new Error(s)
        ;(a.name = 'DeprecationWarning'), console.warn(new Error(s))
      }
    }
    return (r = Math.max(r, 0)), Fy(t, { start: { column: r, line: e } }, i)
  }
  var Cs = {}
  Object.defineProperty(Cs, '__esModule', { value: !0 })
  function Nc(t, e) {
    if (t == null) return {}
    var r = {},
      i = Object.keys(t),
      n,
      s
    for (s = 0; s < i.length; s++) (n = i[s]), !(e.indexOf(n) >= 0) && (r[n] = t[n])
    return r
  }
  class en {
    constructor(e, r, i) {
      ;(this.line = void 0),
        (this.column = void 0),
        (this.index = void 0),
        (this.line = e),
        (this.column = r),
        (this.index = i)
    }
  }
  class So {
    constructor(e, r) {
      ;(this.start = void 0),
        (this.end = void 0),
        (this.filename = void 0),
        (this.identifierName = void 0),
        (this.start = e),
        (this.end = r)
    }
  }
  function zt(t, e) {
    const { line: r, column: i, index: n } = t
    return new en(r, i + e, n + e)
  }
  const Oc = Object.freeze({
      SyntaxError: 'BABEL_PARSER_SYNTAX_ERROR',
      SourceTypeModuleError: 'BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED',
    }),
    kV = (t, e = t.length - 1) => ({
      get() {
        return t.reduce((r, i) => r[i], this)
      },
      set(r) {
        t.reduce((i, n, s) => (s === e ? (i[n] = r) : i[n]), this)
      },
    }),
    NV = (t, e, r) =>
      Object.keys(r)
        .map((i) => [i, r[i]])
        .filter(([, i]) => !!i)
        .map(([i, n]) => [
          i,
          typeof n == 'function'
            ? { value: n, enumerable: !1 }
            : typeof n.reflect == 'string'
            ? Object.assign({}, n, kV(n.reflect.split('.')))
            : n,
        ])
        .reduce(
          (i, [n, s]) => Object.defineProperty(i, n, Object.assign({ configurable: !0 }, s)),
          Object.assign(new t(), e)
        )
  var OV = (t) => ({
    ImportMetaOutsideModule: t(`import.meta may appear only with 'sourceType: "module"'`, {
      code: Oc.SourceTypeModuleError,
    }),
    ImportOutsideModule: t(`'import' and 'export' may appear only with 'sourceType: "module"'`, {
      code: Oc.SourceTypeModuleError,
    }),
  })
  const $y = {
      ArrayPattern: 'array destructuring pattern',
      AssignmentExpression: 'assignment expression',
      AssignmentPattern: 'assignment expression',
      ArrowFunctionExpression: 'arrow function expression',
      ConditionalExpression: 'conditional expression',
      ForOfStatement: 'for-of statement',
      ForInStatement: 'for-in statement',
      ForStatement: 'for-loop',
      FormalParameters: 'function parameter list',
      Identifier: 'identifier',
      ObjectPattern: 'object destructuring pattern',
      ParenthesizedExpression: 'parenthesized expression',
      RestElement: 'rest element',
      UpdateExpression: { true: 'prefix operation', false: 'postfix operation' },
      VariableDeclarator: 'variable declaration',
      YieldExpression: 'yield expression',
    },
    Dc = ({ type: t, prefix: e }) => (t === 'UpdateExpression' ? $y.UpdateExpression[String(e)] : $y[t])
  var DV = (t) => ({
      AccessorIsGenerator: t(({ kind: e }) => `A ${e}ter cannot be a generator.`),
      ArgumentsInClass: t("'arguments' is only allowed in functions and class methods."),
      AsyncFunctionInSingleStatementContext: t(
        'Async functions can only be declared at the top level or inside a block.'
      ),
      AwaitBindingIdentifier: t("Can not use 'await' as identifier inside an async function."),
      AwaitBindingIdentifierInStaticBlock: t("Can not use 'await' as identifier inside a static block."),
      AwaitExpressionFormalParameter: t("'await' is not allowed in async function parameters."),
      AwaitNotInAsyncContext: t("'await' is only allowed within async functions and at the top levels of modules."),
      AwaitNotInAsyncFunction: t("'await' is only allowed within async functions."),
      BadGetterArity: t("A 'get' accesor must not have any formal parameters."),
      BadSetterArity: t("A 'set' accesor must have exactly one formal parameter."),
      BadSetterRestParameter: t("A 'set' accesor function argument must not be a rest parameter."),
      ConstructorClassField: t("Classes may not have a field named 'constructor'."),
      ConstructorClassPrivateField: t("Classes may not have a private field named '#constructor'."),
      ConstructorIsAccessor: t('Class constructor may not be an accessor.'),
      ConstructorIsAsync: t("Constructor can't be an async function."),
      ConstructorIsGenerator: t("Constructor can't be a generator."),
      DeclarationMissingInitializer: t(({ kind: e }) => `Missing initializer in ${e} declaration.`),
      DecoratorBeforeExport: t(
        "Decorators must be placed *before* the 'export' keyword. You can set the 'decoratorsBeforeExport' option to false to use the 'export @decorator class {}' syntax."
      ),
      DecoratorConstructor: t("Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?"),
      DecoratorExportClass: t(
        'Using the export keyword between a decorator and a class is not allowed. Please use `export @dec class` instead.'
      ),
      DecoratorSemicolon: t('Decorators must not be followed by a semicolon.'),
      DecoratorStaticBlock: t("Decorators can't be used with a static block."),
      DeletePrivateField: t('Deleting a private field is not allowed.'),
      DestructureNamedImport: t(
        'ES2015 named imports do not destructure. Use another statement for destructuring after the import.'
      ),
      DuplicateConstructor: t('Duplicate constructor in the same class.'),
      DuplicateDefaultExport: t('Only one default export allowed per module.'),
      DuplicateExport: t(
        ({ exportName: e }) => `\`${e}\` has already been exported. Exported identifiers must be unique.`
      ),
      DuplicateProto: t('Redefinition of __proto__ property.'),
      DuplicateRegExpFlags: t('Duplicate regular expression flag.'),
      ElementAfterRest: t('Rest element must be last element.'),
      EscapedCharNotAnIdentifier: t('Invalid Unicode escape.'),
      ExportBindingIsString: t(
        ({ localName: e, exportName: r }) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${e}' as '${r}' } from 'some-module'\`?`
      ),
      ExportDefaultFromAsIdentifier: t("'from' is not allowed as an identifier after 'export default'."),
      ForInOfLoopInitializer: t(
        ({ type: e }) =>
          `'${e === 'ForInStatement' ? 'for-in' : 'for-of'}' loop variable declaration may not have an initializer.`
      ),
      ForOfAsync: t("The left-hand side of a for-of loop may not be 'async'."),
      ForOfLet: t("The left-hand side of a for-of loop may not start with 'let'."),
      GeneratorInSingleStatementContext: t('Generators can only be declared at the top level or inside a block.'),
      IllegalBreakContinue: t(({ type: e }) => `Unsyntactic ${e === 'BreakStatement' ? 'break' : 'continue'}.`),
      IllegalLanguageModeDirective: t("Illegal 'use strict' directive in function with non-simple parameter list."),
      IllegalReturn: t("'return' outside of function."),
      ImportBindingIsString: t(
        ({ importName: e }) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${e}" as foo }\`?`
      ),
      ImportCallArgumentTrailingComma: t('Trailing comma is disallowed inside import(...) arguments.'),
      ImportCallArity: t(
        ({ maxArgumentCount: e }) =>
          `\`import()\` requires exactly ${e === 1 ? 'one argument' : 'one or two arguments'}.`
      ),
      ImportCallNotNewExpression: t('Cannot use new with import(...).'),
      ImportCallSpreadArgument: t('`...` is not allowed in `import()`.'),
      IncompatibleRegExpUVFlags: t("The 'u' and 'v' regular expression flags cannot be enabled at the same time."),
      InvalidBigIntLiteral: t('Invalid BigIntLiteral.'),
      InvalidCodePoint: t('Code point out of bounds.'),
      InvalidCoverInitializedName: t('Invalid shorthand property initializer.'),
      InvalidDecimal: t('Invalid decimal.'),
      InvalidDigit: t(({ radix: e }) => `Expected number in radix ${e}.`),
      InvalidEscapeSequence: t('Bad character escape sequence.'),
      InvalidEscapeSequenceTemplate: t('Invalid escape sequence in template.'),
      InvalidEscapedReservedWord: t(({ reservedWord: e }) => `Escape sequence in keyword ${e}.`),
      InvalidIdentifier: t(({ identifierName: e }) => `Invalid identifier ${e}.`),
      InvalidLhs: t(({ ancestor: e }) => `Invalid left-hand side in ${Dc(e)}.`),
      InvalidLhsBinding: t(({ ancestor: e }) => `Binding invalid left-hand side in ${Dc(e)}.`),
      InvalidNumber: t('Invalid number.'),
      InvalidOrMissingExponent: t("Floating-point numbers require a valid exponent after the 'e'."),
      InvalidOrUnexpectedToken: t(({ unexpected: e }) => `Unexpected character '${e}'.`),
      InvalidParenthesizedAssignment: t('Invalid parenthesized assignment pattern.'),
      InvalidPrivateFieldResolution: t(({ identifierName: e }) => `Private name #${e} is not defined.`),
      InvalidPropertyBindingPattern: t('Binding member expression.'),
      InvalidRecordProperty: t('Only properties and spread elements are allowed in record definitions.'),
      InvalidRestAssignmentPattern: t("Invalid rest operator's argument."),
      LabelRedeclaration: t(({ labelName: e }) => `Label '${e}' is already declared.`),
      LetInLexicalBinding: t("'let' is not allowed to be used as a name in 'let' or 'const' declarations."),
      LineTerminatorBeforeArrow: t("No line break is allowed before '=>'."),
      MalformedRegExpFlags: t('Invalid regular expression flag.'),
      MissingClassName: t('A class name is required.'),
      MissingEqInAssignment: t("Only '=' operator can be used for specifying default value."),
      MissingSemicolon: t('Missing semicolon.'),
      MissingPlugin: t(
        ({ missingPlugin: e }) =>
          `This experimental syntax requires enabling the parser plugin: ${e.map((r) => JSON.stringify(r)).join(', ')}.`
      ),
      MissingOneOfPlugins: t(
        ({ missingPlugin: e }) =>
          `This experimental syntax requires enabling one of the following parser plugin(s): ${e
            .map((r) => JSON.stringify(r))
            .join(', ')}.`
      ),
      MissingUnicodeEscape: t('Expecting Unicode escape sequence \\uXXXX.'),
      MixingCoalesceWithLogical: t(
        'Nullish coalescing operator(??) requires parens when mixing with logical operators.'
      ),
      ModuleAttributeDifferentFromType: t('The only accepted module attribute is `type`.'),
      ModuleAttributeInvalidValue: t('Only string literals are allowed as module attribute values.'),
      ModuleAttributesWithDuplicateKeys: t(({ key: e }) => `Duplicate key "${e}" is not allowed in module attributes.`),
      ModuleExportNameHasLoneSurrogate: t(
        ({ surrogateCharCode: e }) => `An export name cannot include a lone surrogate, found '\\u${e.toString(16)}'.`
      ),
      ModuleExportUndefined: t(({ localName: e }) => `Export '${e}' is not defined.`),
      MultipleDefaultsInSwitch: t('Multiple default clauses.'),
      NewlineAfterThrow: t('Illegal newline after throw.'),
      NoCatchOrFinally: t('Missing catch or finally clause.'),
      NumberIdentifier: t('Identifier directly after number.'),
      NumericSeparatorInEscapeSequence: t(
        'Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.'
      ),
      ObsoleteAwaitStar: t("'await*' has been removed from the async functions proposal. Use Promise.all() instead."),
      OptionalChainingNoNew: t('Constructors in/after an Optional Chain are not allowed.'),
      OptionalChainingNoTemplate: t('Tagged Template Literals are not allowed in optionalChain.'),
      OverrideOnConstructor: t("'override' modifier cannot appear on a constructor declaration."),
      ParamDupe: t('Argument name clash.'),
      PatternHasAccessor: t("Object pattern can't contain getter or setter."),
      PatternHasMethod: t("Object pattern can't contain methods."),
      PrivateInExpectedIn: t(
        ({ identifierName: e }) =>
          `Private names are only allowed in property accesses (\`obj.#${e}\`) or in \`in\` expressions (\`#${e} in obj\`).`
      ),
      PrivateNameRedeclaration: t(({ identifierName: e }) => `Duplicate private name #${e}.`),
      RecordExpressionBarIncorrectEndSyntaxType: t(
        "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'."
      ),
      RecordExpressionBarIncorrectStartSyntaxType: t(
        "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'."
      ),
      RecordExpressionHashIncorrectStartSyntaxType: t(
        "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'."
      ),
      RecordNoProto: t("'__proto__' is not allowed in Record expressions."),
      RestTrailingComma: t('Unexpected trailing comma after rest element.'),
      SloppyFunction: t(
        'In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.'
      ),
      StaticPrototype: t('Classes may not have static property named prototype.'),
      SuperNotAllowed: t(
        "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?"
      ),
      SuperPrivateField: t("Private fields can't be accessed on super."),
      TrailingDecorator: t('Decorators must be attached to a class element.'),
      TupleExpressionBarIncorrectEndSyntaxType: t(
        "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'."
      ),
      TupleExpressionBarIncorrectStartSyntaxType: t(
        "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'."
      ),
      TupleExpressionHashIncorrectStartSyntaxType: t(
        "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'."
      ),
      UnexpectedArgumentPlaceholder: t('Unexpected argument placeholder.'),
      UnexpectedAwaitAfterPipelineBody: t(
        'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.'
      ),
      UnexpectedDigitAfterHash: t('Unexpected digit after hash token.'),
      UnexpectedImportExport: t("'import' and 'export' may only appear at the top level."),
      UnexpectedKeyword: t(({ keyword: e }) => `Unexpected keyword '${e}'.`),
      UnexpectedLeadingDecorator: t('Leading decorators must be attached to a class declaration.'),
      UnexpectedLexicalDeclaration: t('Lexical declaration cannot appear in a single-statement context.'),
      UnexpectedNewTarget: t('`new.target` can only be used in functions or class properties.'),
      UnexpectedNumericSeparator: t('A numeric separator is only allowed between two digits.'),
      UnexpectedPrivateField: t('Unexpected private name.'),
      UnexpectedReservedWord: t(({ reservedWord: e }) => `Unexpected reserved word '${e}'.`),
      UnexpectedSuper: t("'super' is only allowed in object methods and classes."),
      UnexpectedToken: t(
        ({ expected: e, unexpected: r }) => `Unexpected token${r ? ` '${r}'.` : ''}${e ? `, expected "${e}"` : ''}`
      ),
      UnexpectedTokenUnaryExponentiation: t(
        'Illegal expression. Wrap left hand side or entire exponentiation in parentheses.'
      ),
      UnsupportedBind: t('Binding should be performed on object property.'),
      UnsupportedDecoratorExport: t('A decorated export must export a class declaration.'),
      UnsupportedDefaultExport: t('Only expressions, functions or classes are allowed as the `default` export.'),
      UnsupportedImport: t('`import` can only be used in `import()` or `import.meta`.'),
      UnsupportedMetaProperty: t(
        ({ target: e, onlyValidPropertyName: r }) => `The only valid meta property for ${e} is ${e}.${r}.`
      ),
      UnsupportedParameterDecorator: t('Decorators cannot be used to decorate parameters.'),
      UnsupportedPropertyDecorator: t('Decorators cannot be used to decorate object literal properties.'),
      UnsupportedSuper: t(
        "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop])."
      ),
      UnterminatedComment: t('Unterminated comment.'),
      UnterminatedRegExp: t('Unterminated regular expression.'),
      UnterminatedString: t('Unterminated string constant.'),
      UnterminatedTemplate: t('Unterminated template.'),
      VarRedeclaration: t(({ identifierName: e }) => `Identifier '${e}' has already been declared.`),
      YieldBindingIdentifier: t("Can not use 'yield' as identifier inside a generator."),
      YieldInParameter: t('Yield expression is not allowed in formal parameters.'),
      ZeroDigitNumericSeparator: t('Numeric separator can not be used after leading 0.'),
    }),
    BV = (t) => ({
      StrictDelete: t('Deleting local variable in strict mode.'),
      StrictEvalArguments: t(({ referenceName: e }) => `Assigning to '${e}' in strict mode.`),
      StrictEvalArgumentsBinding: t(({ bindingName: e }) => `Binding '${e}' in strict mode.`),
      StrictFunction: t('In strict mode code, functions can only be declared at top level or inside a block.'),
      StrictNumericEscape: t("The only valid numeric escape in strict mode is '\\0'."),
      StrictOctalLiteral: t('Legacy octal literals are not allowed in strict mode.'),
      StrictWith: t("'with' in strict mode."),
    })
  const LV = new Set(['ArrowFunctionExpression', 'AssignmentExpression', 'ConditionalExpression', 'YieldExpression'])
  var MV = (t) => ({
    PipeBodyIsTighter: t(
      'Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.'
    ),
    PipeTopicRequiresHackPipes: t(
      'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.'
    ),
    PipeTopicUnbound: t('Topic reference is unbound; it must be inside a pipe body.'),
    PipeTopicUnconfiguredToken: t(
      ({ token: e }) =>
        `Invalid topic token ${e}. In order to use ${e} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${e}" }.`
    ),
    PipeTopicUnused: t(
      'Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.'
    ),
    PipeUnparenthesizedBody: t(
      ({ type: e }) =>
        `Hack-style pipe body cannot be an unparenthesized ${Dc({ type: e })}; please wrap it in parentheses.`
    ),
    PipelineBodyNoArrow: t(
      'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.'
    ),
    PipelineBodySequenceExpression: t('Pipeline body may not be a comma-separated sequence expression.'),
    PipelineHeadSequenceExpression: t('Pipeline head should not be a comma-separated sequence expression.'),
    PipelineTopicUnused: t('Pipeline is in topic style but does not use topic reference.'),
    PrimaryTopicNotAllowed: t('Topic reference was used in a lexical context without topic binding.'),
    PrimaryTopicRequiresSmartPipeline: t(
      'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.'
    ),
  })
  const FV = ['toMessage']
  function $V(t) {
    let { toMessage: e } = t,
      r = Nc(t, FV)
    return function i({ loc: n, details: s }) {
      return NV(SyntaxError, Object.assign({}, r, { loc: n }), {
        clone(a = {}) {
          const o = a.loc || {}
          return i({
            loc: new en(
              'line' in o ? o.line : this.loc.line,
              'column' in o ? o.column : this.loc.column,
              'index' in o ? o.index : this.loc.index
            ),
            details: Object.assign({}, this.details, a.details),
          })
        },
        details: { value: s, enumerable: !1 },
        message: {
          get() {
            return `${e(this.details)} (${this.loc.line}:${this.loc.column})`
          },
          set(a) {
            Object.defineProperty(this, 'message', { value: a })
          },
        },
        pos: { reflect: 'loc.index', enumerable: !0 },
        missingPlugin: 'missingPlugin' in s && { reflect: 'details.missingPlugin', enumerable: !0 },
      })
    }
  }
  function RV(t, e) {
    return Object.assign({ toMessage: typeof t == 'string' ? () => t : t }, e)
  }
  function Wr(t, e) {
    if (Array.isArray(t)) return (n) => Wr(n, t[0])
    const r = t(RV),
      i = {}
    for (const n of Object.keys(r))
      i[n] = $V(Object.assign({ code: Oc.SyntaxError, reasonCode: n }, e ? { syntaxPlugin: e } : {}, r[n]))
    return i
  }
  const te = Object.assign({}, Wr(OV), Wr(DV), Wr(BV), Wr`pipelineOperator`(MV)),
    { defineProperty: jV } = Object,
    Ry = (t, e) => jV(t, e, { enumerable: !1, value: t[e] })
  function xs(t) {
    return t.loc.start && Ry(t.loc.start, 'index'), t.loc.end && Ry(t.loc.end, 'index'), t
  }
  var _V = (t) =>
    class extends t {
      parse() {
        const e = xs(super.parse())
        return this.options.tokens && (e.tokens = e.tokens.map(xs)), e
      }
      parseRegExpLiteral({ pattern: e, flags: r }) {
        let i = null
        try {
          i = new RegExp(e, r)
        } catch {}
        const n = this.estreeParseLiteral(i)
        return (n.regex = { pattern: e, flags: r }), n
      }
      parseBigIntLiteral(e) {
        let r
        try {
          r = BigInt(e)
        } catch {
          r = null
        }
        const i = this.estreeParseLiteral(r)
        return (i.bigint = String(i.value || e)), i
      }
      parseDecimalLiteral(e) {
        const i = this.estreeParseLiteral(null)
        return (i.decimal = String(i.value || e)), i
      }
      estreeParseLiteral(e) {
        return this.parseLiteral(e, 'Literal')
      }
      parseStringLiteral(e) {
        return this.estreeParseLiteral(e)
      }
      parseNumericLiteral(e) {
        return this.estreeParseLiteral(e)
      }
      parseNullLiteral() {
        return this.estreeParseLiteral(null)
      }
      parseBooleanLiteral(e) {
        return this.estreeParseLiteral(e)
      }
      directiveToStmt(e) {
        const r = e.value,
          i = this.startNodeAt(e.start, e.loc.start),
          n = this.startNodeAt(r.start, r.loc.start)
        return (
          (n.value = r.extra.expressionValue),
          (n.raw = r.extra.raw),
          (i.expression = this.finishNodeAt(n, 'Literal', r.loc.end)),
          (i.directive = r.extra.raw.slice(1, -1)),
          this.finishNodeAt(i, 'ExpressionStatement', e.loc.end)
        )
      }
      initFunction(e, r) {
        super.initFunction(e, r), (e.expression = !1)
      }
      checkDeclaration(e) {
        e != null && this.isObjectProperty(e) ? this.checkDeclaration(e.value) : super.checkDeclaration(e)
      }
      getObjectOrClassMethodParams(e) {
        return e.value.params
      }
      isValidDirective(e) {
        var r
        return (
          e.type === 'ExpressionStatement' &&
          e.expression.type === 'Literal' &&
          typeof e.expression.value == 'string' &&
          !((r = e.expression.extra) != null && r.parenthesized)
        )
      }
      parseBlockBody(e, ...r) {
        super.parseBlockBody(e, ...r)
        const i = e.directives.map((n) => this.directiveToStmt(n))
        ;(e.body = i.concat(e.body)), delete e.directives
      }
      pushClassMethod(e, r, i, n, s, a) {
        this.parseMethod(r, i, n, s, a, 'ClassMethod', !0),
          r.typeParameters && ((r.value.typeParameters = r.typeParameters), delete r.typeParameters),
          e.body.push(r)
      }
      parsePrivateName() {
        const e = super.parsePrivateName()
        return this.getPluginOption('estree', 'classFeatures') ? this.convertPrivateNameToPrivateIdentifier(e) : e
      }
      convertPrivateNameToPrivateIdentifier(e) {
        const r = super.getPrivateNameSV(e)
        return (e = e), delete e.id, (e.name = r), (e.type = 'PrivateIdentifier'), e
      }
      isPrivateName(e) {
        return this.getPluginOption('estree', 'classFeatures') ? e.type === 'PrivateIdentifier' : super.isPrivateName(e)
      }
      getPrivateNameSV(e) {
        return this.getPluginOption('estree', 'classFeatures') ? e.name : super.getPrivateNameSV(e)
      }
      parseLiteral(e, r) {
        const i = super.parseLiteral(e, r)
        return (i.raw = i.extra.raw), delete i.extra, i
      }
      parseFunctionBody(e, r, i = !1) {
        super.parseFunctionBody(e, r, i), (e.expression = e.body.type !== 'BlockStatement')
      }
      parseMethod(e, r, i, n, s, a, o = !1) {
        let u = this.startNode()
        return (
          (u.kind = e.kind),
          (u = super.parseMethod(u, r, i, n, s, a, o)),
          (u.type = 'FunctionExpression'),
          delete u.kind,
          (e.value = u),
          a === 'ClassPrivateMethod' && (e.computed = !1),
          (a = 'MethodDefinition'),
          this.finishNode(e, a)
        )
      }
      parseClassProperty(...e) {
        const r = super.parseClassProperty(...e)
        return this.getPluginOption('estree', 'classFeatures') && (r.type = 'PropertyDefinition'), r
      }
      parseClassPrivateProperty(...e) {
        const r = super.parseClassPrivateProperty(...e)
        return (
          this.getPluginOption('estree', 'classFeatures') && ((r.type = 'PropertyDefinition'), (r.computed = !1)), r
        )
      }
      parseObjectMethod(e, r, i, n, s) {
        const a = super.parseObjectMethod(e, r, i, n, s)
        return a && ((a.type = 'Property'), a.kind === 'method' && (a.kind = 'init'), (a.shorthand = !1)), a
      }
      parseObjectProperty(e, r, i, n, s) {
        const a = super.parseObjectProperty(e, r, i, n, s)
        return a && ((a.kind = 'init'), (a.type = 'Property')), a
      }
      isValidLVal(e, ...r) {
        return e === 'Property' ? 'value' : super.isValidLVal(e, ...r)
      }
      isAssignable(e, r) {
        return e != null && this.isObjectProperty(e) ? this.isAssignable(e.value, r) : super.isAssignable(e, r)
      }
      toAssignable(e, r = !1) {
        if (e != null && this.isObjectProperty(e)) {
          const { key: i, value: n } = e
          this.isPrivateName(i) && this.classScope.usePrivateName(this.getPrivateNameSV(i), i.loc.start),
            this.toAssignable(n, r)
        } else super.toAssignable(e, r)
      }
      toAssignableObjectExpressionProp(e) {
        e.kind === 'get' || e.kind === 'set'
          ? this.raise(te.PatternHasAccessor, { at: e.key })
          : e.method
          ? this.raise(te.PatternHasMethod, { at: e.key })
          : super.toAssignableObjectExpressionProp(...arguments)
      }
      finishCallExpression(e, r) {
        if ((super.finishCallExpression(e, r), e.callee.type === 'Import')) {
          if (((e.type = 'ImportExpression'), (e.source = e.arguments[0]), this.hasPlugin('importAssertions'))) {
            var i
            e.attributes = (i = e.arguments[1]) != null ? i : null
          }
          delete e.arguments, delete e.callee
        }
        return e
      }
      toReferencedArguments(e) {
        e.type !== 'ImportExpression' && super.toReferencedArguments(e)
      }
      parseExport(e) {
        switch ((super.parseExport(e), e.type)) {
          case 'ExportAllDeclaration':
            e.exported = null
            break
          case 'ExportNamedDeclaration':
            e.specifiers.length === 1 &&
              e.specifiers[0].type === 'ExportNamespaceSpecifier' &&
              ((e.type = 'ExportAllDeclaration'), (e.exported = e.specifiers[0].exported), delete e.specifiers)
            break
        }
        return e
      }
      parseSubscript(e, r, i, n, s) {
        const a = super.parseSubscript(e, r, i, n, s)
        if (s.optionalChainMember) {
          if (
            ((a.type === 'OptionalMemberExpression' || a.type === 'OptionalCallExpression') &&
              (a.type = a.type.substring(8)),
            s.stop)
          ) {
            const o = this.startNodeAtNode(a)
            return (o.expression = a), this.finishNode(o, 'ChainExpression')
          }
        } else (a.type === 'MemberExpression' || a.type === 'CallExpression') && (a.optional = !1)
        return a
      }
      hasPropertyAsPrivateName(e) {
        return e.type === 'ChainExpression' && (e = e.expression), super.hasPropertyAsPrivateName(e)
      }
      isOptionalChain(e) {
        return e.type === 'ChainExpression'
      }
      isObjectProperty(e) {
        return e.type === 'Property' && e.kind === 'init' && !e.method
      }
      isObjectMethod(e) {
        return e.method || e.kind === 'get' || e.kind === 'set'
      }
      finishNodeAt(e, r, i) {
        return xs(super.finishNodeAt(e, r, i))
      }
      resetStartLocation(e, r, i) {
        super.resetStartLocation(e, r, i), xs(e)
      }
      resetEndLocation(e, r = this.state.lastTokEndLoc) {
        super.resetEndLocation(e, r), xs(e)
      }
    }
  class Is {
    constructor(e, r) {
      ;(this.token = void 0), (this.preserveSpace = void 0), (this.token = e), (this.preserveSpace = !!r)
    }
  }
  const gt = {
    brace: new Is('{'),
    j_oTag: new Is('<tag'),
    j_cTag: new Is('</tag'),
    j_expr: new Is('<tag>...</tag>', !0),
  }
  gt.template = new Is('`', !0)
  const it = !0,
    Ne = !0,
    Bc = !0,
    ks = !0,
    yi = !0,
    VV = !0
  class jy {
    constructor(e, r = {}) {
      ;(this.label = void 0),
        (this.keyword = void 0),
        (this.beforeExpr = void 0),
        (this.startsExpr = void 0),
        (this.rightAssociative = void 0),
        (this.isLoop = void 0),
        (this.isAssign = void 0),
        (this.prefix = void 0),
        (this.postfix = void 0),
        (this.binop = void 0),
        (this.label = e),
        (this.keyword = r.keyword),
        (this.beforeExpr = !!r.beforeExpr),
        (this.startsExpr = !!r.startsExpr),
        (this.rightAssociative = !!r.rightAssociative),
        (this.isLoop = !!r.isLoop),
        (this.isAssign = !!r.isAssign),
        (this.prefix = !!r.prefix),
        (this.postfix = !!r.postfix),
        (this.binop = r.binop != null ? r.binop : null),
        (this.updateContext = null)
    }
  }
  const Lc = new Map()
  function ot(t, e = {}) {
    e.keyword = t
    const r = Ue(t, e)
    return Lc.set(t, r), r
  }
  function Qt(t, e) {
    return Ue(t, { beforeExpr: it, binop: e })
  }
  let Ns = -1
  const Yr = [],
    Mc = [],
    vo = [],
    Fc = [],
    $c = [],
    Rc = []
  function Ue(t, e = {}) {
    var r, i, n, s
    return (
      ++Ns,
      Mc.push(t),
      vo.push((r = e.binop) != null ? r : -1),
      Fc.push((i = e.beforeExpr) != null ? i : !1),
      $c.push((n = e.startsExpr) != null ? n : !1),
      Rc.push((s = e.prefix) != null ? s : !1),
      Yr.push(new jy(t, e)),
      Ns
    )
  }
  function lt(t, e) {
    var r, i, n, s
    return (
      ++Ns,
      Lc.set(t, Ns),
      Mc.push(t),
      vo.push((r = e.binop) != null ? r : -1),
      Fc.push((i = e.beforeExpr) != null ? i : !1),
      $c.push((n = e.startsExpr) != null ? n : !1),
      Rc.push((s = e.prefix) != null ? s : !1),
      Yr.push(new jy('name', e)),
      Ns
    )
  }
  const UV = {
    bracketL: Ue('[', { beforeExpr: it, startsExpr: Ne }),
    bracketHashL: Ue('#[', { beforeExpr: it, startsExpr: Ne }),
    bracketBarL: Ue('[|', { beforeExpr: it, startsExpr: Ne }),
    bracketR: Ue(']'),
    bracketBarR: Ue('|]'),
    braceL: Ue('{', { beforeExpr: it, startsExpr: Ne }),
    braceBarL: Ue('{|', { beforeExpr: it, startsExpr: Ne }),
    braceHashL: Ue('#{', { beforeExpr: it, startsExpr: Ne }),
    braceR: Ue('}'),
    braceBarR: Ue('|}'),
    parenL: Ue('(', { beforeExpr: it, startsExpr: Ne }),
    parenR: Ue(')'),
    comma: Ue(',', { beforeExpr: it }),
    semi: Ue(';', { beforeExpr: it }),
    colon: Ue(':', { beforeExpr: it }),
    doubleColon: Ue('::', { beforeExpr: it }),
    dot: Ue('.'),
    question: Ue('?', { beforeExpr: it }),
    questionDot: Ue('?.'),
    arrow: Ue('=>', { beforeExpr: it }),
    template: Ue('template'),
    ellipsis: Ue('...', { beforeExpr: it }),
    backQuote: Ue('`', { startsExpr: Ne }),
    dollarBraceL: Ue('${', { beforeExpr: it, startsExpr: Ne }),
    templateTail: Ue('...`', { startsExpr: Ne }),
    templateNonTail: Ue('...${', { beforeExpr: it, startsExpr: Ne }),
    at: Ue('@'),
    hash: Ue('#', { startsExpr: Ne }),
    interpreterDirective: Ue('#!...'),
    eq: Ue('=', { beforeExpr: it, isAssign: ks }),
    assign: Ue('_=', { beforeExpr: it, isAssign: ks }),
    slashAssign: Ue('_=', { beforeExpr: it, isAssign: ks }),
    xorAssign: Ue('_=', { beforeExpr: it, isAssign: ks }),
    moduloAssign: Ue('_=', { beforeExpr: it, isAssign: ks }),
    incDec: Ue('++/--', { prefix: yi, postfix: VV, startsExpr: Ne }),
    bang: Ue('!', { beforeExpr: it, prefix: yi, startsExpr: Ne }),
    tilde: Ue('~', { beforeExpr: it, prefix: yi, startsExpr: Ne }),
    doubleCaret: Ue('^^', { startsExpr: Ne }),
    doubleAt: Ue('@@', { startsExpr: Ne }),
    pipeline: Qt('|>', 0),
    nullishCoalescing: Qt('??', 1),
    logicalOR: Qt('||', 1),
    logicalAND: Qt('&&', 2),
    bitwiseOR: Qt('|', 3),
    bitwiseXOR: Qt('^', 4),
    bitwiseAND: Qt('&', 5),
    equality: Qt('==/!=/===/!==', 6),
    lt: Qt('</>/<=/>=', 7),
    gt: Qt('</>/<=/>=', 7),
    relational: Qt('</>/<=/>=', 7),
    bitShift: Qt('<</>>/>>>', 8),
    bitShiftL: Qt('<</>>/>>>', 8),
    bitShiftR: Qt('<</>>/>>>', 8),
    plusMin: Ue('+/-', { beforeExpr: it, binop: 9, prefix: yi, startsExpr: Ne }),
    modulo: Ue('%', { binop: 10, startsExpr: Ne }),
    star: Ue('*', { binop: 10 }),
    slash: Qt('/', 10),
    exponent: Ue('**', { beforeExpr: it, binop: 11, rightAssociative: !0 }),
    _in: ot('in', { beforeExpr: it, binop: 7 }),
    _instanceof: ot('instanceof', { beforeExpr: it, binop: 7 }),
    _break: ot('break'),
    _case: ot('case', { beforeExpr: it }),
    _catch: ot('catch'),
    _continue: ot('continue'),
    _debugger: ot('debugger'),
    _default: ot('default', { beforeExpr: it }),
    _else: ot('else', { beforeExpr: it }),
    _finally: ot('finally'),
    _function: ot('function', { startsExpr: Ne }),
    _if: ot('if'),
    _return: ot('return', { beforeExpr: it }),
    _switch: ot('switch'),
    _throw: ot('throw', { beforeExpr: it, prefix: yi, startsExpr: Ne }),
    _try: ot('try'),
    _var: ot('var'),
    _const: ot('const'),
    _with: ot('with'),
    _new: ot('new', { beforeExpr: it, startsExpr: Ne }),
    _this: ot('this', { startsExpr: Ne }),
    _super: ot('super', { startsExpr: Ne }),
    _class: ot('class', { startsExpr: Ne }),
    _extends: ot('extends', { beforeExpr: it }),
    _export: ot('export'),
    _import: ot('import', { startsExpr: Ne }),
    _null: ot('null', { startsExpr: Ne }),
    _true: ot('true', { startsExpr: Ne }),
    _false: ot('false', { startsExpr: Ne }),
    _typeof: ot('typeof', { beforeExpr: it, prefix: yi, startsExpr: Ne }),
    _void: ot('void', { beforeExpr: it, prefix: yi, startsExpr: Ne }),
    _delete: ot('delete', { beforeExpr: it, prefix: yi, startsExpr: Ne }),
    _do: ot('do', { isLoop: Bc, beforeExpr: it }),
    _for: ot('for', { isLoop: Bc }),
    _while: ot('while', { isLoop: Bc }),
    _as: lt('as', { startsExpr: Ne }),
    _assert: lt('assert', { startsExpr: Ne }),
    _async: lt('async', { startsExpr: Ne }),
    _await: lt('await', { startsExpr: Ne }),
    _from: lt('from', { startsExpr: Ne }),
    _get: lt('get', { startsExpr: Ne }),
    _let: lt('let', { startsExpr: Ne }),
    _meta: lt('meta', { startsExpr: Ne }),
    _of: lt('of', { startsExpr: Ne }),
    _sent: lt('sent', { startsExpr: Ne }),
    _set: lt('set', { startsExpr: Ne }),
    _static: lt('static', { startsExpr: Ne }),
    _yield: lt('yield', { startsExpr: Ne }),
    _asserts: lt('asserts', { startsExpr: Ne }),
    _checks: lt('checks', { startsExpr: Ne }),
    _exports: lt('exports', { startsExpr: Ne }),
    _global: lt('global', { startsExpr: Ne }),
    _implements: lt('implements', { startsExpr: Ne }),
    _intrinsic: lt('intrinsic', { startsExpr: Ne }),
    _infer: lt('infer', { startsExpr: Ne }),
    _is: lt('is', { startsExpr: Ne }),
    _mixins: lt('mixins', { startsExpr: Ne }),
    _proto: lt('proto', { startsExpr: Ne }),
    _require: lt('require', { startsExpr: Ne }),
    _keyof: lt('keyof', { startsExpr: Ne }),
    _readonly: lt('readonly', { startsExpr: Ne }),
    _unique: lt('unique', { startsExpr: Ne }),
    _abstract: lt('abstract', { startsExpr: Ne }),
    _declare: lt('declare', { startsExpr: Ne }),
    _enum: lt('enum', { startsExpr: Ne }),
    _module: lt('module', { startsExpr: Ne }),
    _namespace: lt('namespace', { startsExpr: Ne }),
    _interface: lt('interface', { startsExpr: Ne }),
    _type: lt('type', { startsExpr: Ne }),
    _opaque: lt('opaque', { startsExpr: Ne }),
    name: Ue('name', { startsExpr: Ne }),
    string: Ue('string', { startsExpr: Ne }),
    num: Ue('num', { startsExpr: Ne }),
    bigint: Ue('bigint', { startsExpr: Ne }),
    decimal: Ue('decimal', { startsExpr: Ne }),
    regexp: Ue('regexp', { startsExpr: Ne }),
    privateName: Ue('#name', { startsExpr: Ne }),
    eof: Ue('eof'),
    jsxName: Ue('jsxName'),
    jsxText: Ue('jsxText', { beforeExpr: !0 }),
    jsxTagStart: Ue('jsxTagStart', { startsExpr: !0 }),
    jsxTagEnd: Ue('jsxTagEnd'),
    placeholder: Ue('%%', { startsExpr: !0 }),
  }
  function dt(t) {
    return t >= 93 && t <= 128
  }
  function zV(t) {
    return t <= 92
  }
  function Hr(t) {
    return t >= 58 && t <= 128
  }
  function _y(t) {
    return t >= 58 && t <= 132
  }
  function KV(t) {
    return Fc[t]
  }
  function jc(t) {
    return $c[t]
  }
  function WV(t) {
    return t >= 29 && t <= 33
  }
  function Vy(t) {
    return t >= 125 && t <= 127
  }
  function YV(t) {
    return t >= 90 && t <= 92
  }
  function _c(t) {
    return t >= 58 && t <= 92
  }
  function HV(t) {
    return t >= 39 && t <= 59
  }
  function qV(t) {
    return t === 34
  }
  function XV(t) {
    return Rc[t]
  }
  function GV(t) {
    return t >= 117 && t <= 119
  }
  function JV(t) {
    return t >= 120 && t <= 126
  }
  function gi(t) {
    return Mc[t]
  }
  function Eo(t) {
    return vo[t]
  }
  function ZV(t) {
    return vo[t] !== -1
  }
  function QV(t) {
    return t === 57
  }
  function Po(t) {
    return t >= 24 && t <= 25
  }
  function qr(t) {
    return Yr[t]
  }
  ;(Yr[8].updateContext = (t) => {
    t.pop()
  }),
    (Yr[5].updateContext =
      Yr[7].updateContext =
      Yr[23].updateContext =
        (t) => {
          t.push(gt.brace)
        }),
    (Yr[22].updateContext = (t) => {
      t[t.length - 1] === gt.template ? t.pop() : t.push(gt.template)
    }),
    (Yr[138].updateContext = (t) => {
      t.push(gt.j_expr, gt.j_oTag)
    })
  let Vc =
      '\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC',
    Uy =
      '\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F'
  const e7 = new RegExp('[' + Vc + ']'),
    t7 = new RegExp('[' + Vc + Uy + ']')
  Vc = Uy = null
  const zy = [
      0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5,
      7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10,
      21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11,
      25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72,
      56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44,
      33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2,
      9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0,
      185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16,
      0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50,
      29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2637, 96,
      16, 1070, 4050, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67,
      12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 46, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4,
      8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4,
      2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 482, 44,
      11, 6, 17, 0, 322, 29, 19, 43, 1269, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0,
      2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3,
      2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4152, 8, 221, 3, 5761, 15, 7472, 3104,
      541, 1507, 4938,
    ],
    r7 = [
      509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 50, 3,
      123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2,
      11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0,
      82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3,
      2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2,
      13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 87, 9, 39, 4, 60, 6, 26, 9,
      1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49,
      513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 357, 0, 62, 13, 1495,
      6, 110, 6, 6, 9, 4759, 9, 787719, 239,
    ]
  function Uc(t, e) {
    let r = 65536
    for (let i = 0, n = e.length; i < n; i += 2) {
      if (((r += e[i]), r > t)) return !1
      if (((r += e[i + 1]), r >= t)) return !0
    }
    return !1
  }
  function Xr(t) {
    return t < 65
      ? t === 36
      : t <= 90
      ? !0
      : t < 97
      ? t === 95
      : t <= 122
      ? !0
      : t <= 65535
      ? t >= 170 && e7.test(String.fromCharCode(t))
      : Uc(t, zy)
  }
  function On(t) {
    return t < 48
      ? t === 36
      : t < 58
      ? !0
      : t < 65
      ? !1
      : t <= 90
      ? !0
      : t < 97
      ? t === 95
      : t <= 122
      ? !0
      : t <= 65535
      ? t >= 170 && t7.test(String.fromCharCode(t))
      : Uc(t, zy) || Uc(t, r7)
  }
  const zc = {
      keyword: [
        'break',
        'case',
        'catch',
        'continue',
        'debugger',
        'default',
        'do',
        'else',
        'finally',
        'for',
        'function',
        'if',
        'return',
        'switch',
        'throw',
        'try',
        'var',
        'const',
        'while',
        'with',
        'new',
        'this',
        'super',
        'class',
        'extends',
        'export',
        'import',
        'null',
        'true',
        'false',
        'in',
        'instanceof',
        'typeof',
        'void',
        'delete',
      ],
      strict: ['implements', 'interface', 'let', 'package', 'private', 'protected', 'public', 'static', 'yield'],
      strictBind: ['eval', 'arguments'],
    },
    i7 = new Set(zc.keyword),
    n7 = new Set(zc.strict),
    s7 = new Set(zc.strictBind)
  function Ky(t, e) {
    return (e && t === 'await') || t === 'enum'
  }
  function Wy(t, e) {
    return Ky(t, e) || n7.has(t)
  }
  function Yy(t) {
    return s7.has(t)
  }
  function Hy(t, e) {
    return Wy(t, e) || Yy(t)
  }
  function a7(t) {
    return i7.has(t)
  }
  function o7(t, e, r) {
    return t === 64 && e === 64 && Xr(r)
  }
  const l7 = new Set([
    'break',
    'case',
    'catch',
    'continue',
    'debugger',
    'default',
    'do',
    'else',
    'finally',
    'for',
    'function',
    'if',
    'return',
    'switch',
    'throw',
    'try',
    'var',
    'const',
    'while',
    'with',
    'new',
    'this',
    'super',
    'class',
    'extends',
    'export',
    'import',
    'null',
    'true',
    'false',
    'in',
    'instanceof',
    'typeof',
    'void',
    'delete',
    'implements',
    'interface',
    'let',
    'package',
    'private',
    'protected',
    'public',
    'static',
    'yield',
    'eval',
    'arguments',
    'enum',
    'await',
  ])
  function u7(t) {
    return l7.has(t)
  }
  const Dn = 0,
    Os = 1,
    Gr = 2,
    Kc = 4,
    qy = 8,
    wo = 16,
    Xy = 32,
    tn = 64,
    Wc = 128,
    Ao = 256,
    Co = Os | Gr | Ao,
    Jr = 1,
    Bn = 2,
    Gy = 4,
    Ti = 8,
    xo = 16,
    Jy = 64,
    Io = 128,
    Yc = 256,
    Hc = 512,
    qc = 1024,
    Xc = 2048,
    Zy = Jr | Bn | Ti | Io,
    Zr = Jr | 0 | Ti | 0,
    ko = Jr | 0 | Gy | 0,
    Qy = Jr | 0 | xo | 0,
    c7 = 0 | Bn | 0 | Io,
    p7 = 0 | Bn | 0 | 0,
    e0 = Jr | Bn | Ti | Yc,
    t0 = 0 | qc,
    rn = 0 | Jy,
    f7 = Jr | 0 | 0 | Jy,
    h7 = e0 | Hc,
    d7 = 0 | qc,
    m7 = Xc,
    No = 4,
    Gc = 2,
    Jc = 1,
    Zc = Gc | Jc,
    y7 = Gc | No,
    g7 = Jc | No,
    T7 = Gc,
    b7 = Jc,
    Qc = 0
  class S7 {
    constructor() {
      ;(this.sawUnambiguousESM = !1), (this.ambiguousScriptDifferentAst = !1)
    }
    hasPlugin(e) {
      if (typeof e == 'string') return this.plugins.has(e)
      {
        const [r, i] = e
        if (!this.hasPlugin(r)) return !1
        const n = this.plugins.get(r)
        for (const s of Object.keys(i)) if ((n == null ? void 0 : n[s]) !== i[s]) return !1
        return !0
      }
    }
    getPluginOption(e, r) {
      var i
      return (i = this.plugins.get(e)) == null ? void 0 : i[r]
    }
  }
  function r0(t, e) {
    t.trailingComments === void 0 ? (t.trailingComments = e) : t.trailingComments.unshift(...e)
  }
  function v7(t, e) {
    t.leadingComments === void 0 ? (t.leadingComments = e) : t.leadingComments.unshift(...e)
  }
  function Ds(t, e) {
    t.innerComments === void 0 ? (t.innerComments = e) : t.innerComments.unshift(...e)
  }
  function Bs(t, e, r) {
    let i = null,
      n = e.length
    for (; i === null && n > 0; ) i = e[--n]
    i === null || i.start > r.start ? Ds(t, r.comments) : r0(i, r.comments)
  }
  class E7 extends S7 {
    addComment(e) {
      this.filename && (e.loc.filename = this.filename), this.state.comments.push(e)
    }
    processComment(e) {
      const { commentStack: r } = this.state,
        i = r.length
      if (i === 0) return
      let n = i - 1
      const s = r[n]
      s.start === e.end && ((s.leadingNode = e), n--)
      const { start: a } = e
      for (; n >= 0; n--) {
        const o = r[n],
          u = o.end
        if (u > a) (o.containingNode = e), this.finalizeComment(o), r.splice(n, 1)
        else {
          u === a && (o.trailingNode = e)
          break
        }
      }
    }
    finalizeComment(e) {
      const { comments: r } = e
      if (e.leadingNode !== null || e.trailingNode !== null)
        e.leadingNode !== null && r0(e.leadingNode, r), e.trailingNode !== null && v7(e.trailingNode, r)
      else {
        const { containingNode: i, start: n } = e
        if (this.input.charCodeAt(n - 1) === 44)
          switch (i.type) {
            case 'ObjectExpression':
            case 'ObjectPattern':
            case 'RecordExpression':
              Bs(i, i.properties, e)
              break
            case 'CallExpression':
            case 'OptionalCallExpression':
              Bs(i, i.arguments, e)
              break
            case 'FunctionDeclaration':
            case 'FunctionExpression':
            case 'ArrowFunctionExpression':
            case 'ObjectMethod':
            case 'ClassMethod':
            case 'ClassPrivateMethod':
              Bs(i, i.params, e)
              break
            case 'ArrayExpression':
            case 'ArrayPattern':
            case 'TupleExpression':
              Bs(i, i.elements, e)
              break
            case 'ExportNamedDeclaration':
            case 'ImportDeclaration':
              Bs(i, i.specifiers, e)
              break
            default:
              Ds(i, r)
          }
        else Ds(i, r)
      }
    }
    finalizeRemainingComments() {
      const { commentStack: e } = this.state
      for (let r = e.length - 1; r >= 0; r--) this.finalizeComment(e[r])
      this.state.commentStack = []
    }
    resetPreviousNodeTrailingComments(e) {
      const { commentStack: r } = this.state,
        { length: i } = r
      if (i === 0) return
      const n = r[i - 1]
      n.leadingNode === e && (n.leadingNode = null)
    }
    takeSurroundingComments(e, r, i) {
      const { commentStack: n } = this.state,
        s = n.length
      if (s === 0) return
      let a = s - 1
      for (; a >= 0; a--) {
        const o = n[a],
          u = o.end
        if (o.start === i) o.leadingNode = e
        else if (u === r) o.trailingNode = e
        else if (u < r) break
      }
    }
  }
  const ep = /\r\n?|[\n\u2028\u2029]/,
    Oo = new RegExp(ep.source, 'g')
  function nn(t) {
    switch (t) {
      case 10:
      case 13:
      case 8232:
      case 8233:
        return !0
      default:
        return !1
    }
  }
  const tp = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g,
    P7 = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/y,
    i0 = new RegExp('(?=(' + P7.source + '))\\1' + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, 'y')
  function w7(t) {
    switch (t) {
      case 9:
      case 11:
      case 12:
      case 32:
      case 160:
      case 5760:
      case 8192:
      case 8193:
      case 8194:
      case 8195:
      case 8196:
      case 8197:
      case 8198:
      case 8199:
      case 8200:
      case 8201:
      case 8202:
      case 8239:
      case 8287:
      case 12288:
      case 65279:
        return !0
      default:
        return !1
    }
  }
  class rp {
    constructor() {
      ;(this.strict = void 0),
        (this.curLine = void 0),
        (this.lineStart = void 0),
        (this.startLoc = void 0),
        (this.endLoc = void 0),
        (this.errors = []),
        (this.potentialArrowAt = -1),
        (this.noArrowAt = []),
        (this.noArrowParamsConversionAt = []),
        (this.maybeInArrowParameters = !1),
        (this.inType = !1),
        (this.noAnonFunctionType = !1),
        (this.hasFlowComment = !1),
        (this.isAmbientContext = !1),
        (this.inAbstractClass = !1),
        (this.inDisallowConditionalTypesContext = !1),
        (this.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null }),
        (this.soloAwait = !1),
        (this.inFSharpPipelineDirectBody = !1),
        (this.labels = []),
        (this.decoratorStack = [[]]),
        (this.comments = []),
        (this.commentStack = []),
        (this.pos = 0),
        (this.type = 135),
        (this.value = null),
        (this.start = 0),
        (this.end = 0),
        (this.lastTokEndLoc = null),
        (this.lastTokStartLoc = null),
        (this.lastTokStart = 0),
        (this.context = [gt.brace]),
        (this.canStartJSXElement = !0),
        (this.containsEsc = !1),
        (this.strictErrors = new Map()),
        (this.tokensLength = 0)
    }
    init({ strictMode: e, sourceType: r, startLine: i, startColumn: n }) {
      ;(this.strict = e === !1 ? !1 : e === !0 ? !0 : r === 'module'),
        (this.curLine = i),
        (this.lineStart = -n),
        (this.startLoc = this.endLoc = new en(i, n, 0))
    }
    curPosition() {
      return new en(this.curLine, this.pos - this.lineStart, this.pos)
    }
    clone(e) {
      const r = new rp(),
        i = Object.keys(this)
      for (let n = 0, s = i.length; n < s; n++) {
        const a = i[n]
        let o = this[a]
        !e && Array.isArray(o) && (o = o.slice()), (r[a] = o)
      }
      return r
    }
  }
  const A7 = ['at'],
    C7 = ['at']
  var x7 = function (e) {
    return e >= 48 && e <= 57
  }
  const I7 = new Set([103, 109, 115, 105, 121, 117, 100, 118]),
    n0 = { decBinOct: new Set([46, 66, 69, 79, 95, 98, 101, 111]), hex: new Set([46, 88, 95, 120]) },
    Do = {
      bin: (t) => t === 48 || t === 49,
      oct: (t) => t >= 48 && t <= 55,
      dec: (t) => t >= 48 && t <= 57,
      hex: (t) => (t >= 48 && t <= 57) || (t >= 65 && t <= 70) || (t >= 97 && t <= 102),
    }
  class bi {
    constructor(e) {
      ;(this.type = e.type),
        (this.value = e.value),
        (this.start = e.start),
        (this.end = e.end),
        (this.loc = new So(e.startLoc, e.endLoc))
    }
  }
  class k7 extends E7 {
    constructor(e, r) {
      super(),
        (this.isLookahead = void 0),
        (this.tokens = []),
        (this.state = new rp()),
        this.state.init(e),
        (this.input = r),
        (this.length = r.length),
        (this.isLookahead = !1)
    }
    pushToken(e) {
      ;(this.tokens.length = this.state.tokensLength), this.tokens.push(e), ++this.state.tokensLength
    }
    next() {
      this.checkKeywordEscapes(),
        this.options.tokens && this.pushToken(new bi(this.state)),
        (this.state.lastTokStart = this.state.start),
        (this.state.lastTokEndLoc = this.state.endLoc),
        (this.state.lastTokStartLoc = this.state.startLoc),
        this.nextToken()
    }
    eat(e) {
      return this.match(e) ? (this.next(), !0) : !1
    }
    match(e) {
      return this.state.type === e
    }
    createLookaheadState(e) {
      return {
        pos: e.pos,
        value: null,
        type: e.type,
        start: e.start,
        end: e.end,
        context: [this.curContext()],
        inType: e.inType,
        startLoc: e.startLoc,
        lastTokEndLoc: e.lastTokEndLoc,
        curLine: e.curLine,
        lineStart: e.lineStart,
        curPosition: e.curPosition,
      }
    }
    lookahead() {
      const e = this.state
      ;(this.state = this.createLookaheadState(e)), (this.isLookahead = !0), this.nextToken(), (this.isLookahead = !1)
      const r = this.state
      return (this.state = e), r
    }
    nextTokenStart() {
      return this.nextTokenStartSince(this.state.pos)
    }
    nextTokenStartSince(e) {
      return (tp.lastIndex = e), tp.test(this.input) ? tp.lastIndex : e
    }
    lookaheadCharCode() {
      return this.input.charCodeAt(this.nextTokenStart())
    }
    codePointAtPos(e) {
      let r = this.input.charCodeAt(e)
      if ((r & 64512) === 55296 && ++e < this.input.length) {
        const i = this.input.charCodeAt(e)
        ;(i & 64512) === 56320 && (r = 65536 + ((r & 1023) << 10) + (i & 1023))
      }
      return r
    }
    setStrict(e) {
      ;(this.state.strict = e),
        e && (this.state.strictErrors.forEach(([r, i]) => this.raise(r, { at: i })), this.state.strictErrors.clear())
    }
    curContext() {
      return this.state.context[this.state.context.length - 1]
    }
    nextToken() {
      if (
        (this.skipSpace(),
        (this.state.start = this.state.pos),
        this.isLookahead || (this.state.startLoc = this.state.curPosition()),
        this.state.pos >= this.length)
      ) {
        this.finishToken(135)
        return
      }
      this.getTokenFromCode(this.codePointAtPos(this.state.pos))
    }
    skipBlockComment() {
      let e
      this.isLookahead || (e = this.state.curPosition())
      const r = this.state.pos,
        i = this.input.indexOf('*/', r + 2)
      if (i === -1) throw this.raise(te.UnterminatedComment, { at: this.state.curPosition() })
      for (this.state.pos = i + 2, Oo.lastIndex = r + 2; Oo.test(this.input) && Oo.lastIndex <= i; )
        ++this.state.curLine, (this.state.lineStart = Oo.lastIndex)
      if (this.isLookahead) return
      const n = {
        type: 'CommentBlock',
        value: this.input.slice(r + 2, i),
        start: r,
        end: i + 2,
        loc: new So(e, this.state.curPosition()),
      }
      return this.options.tokens && this.pushToken(n), n
    }
    skipLineComment(e) {
      const r = this.state.pos
      let i
      this.isLookahead || (i = this.state.curPosition())
      let n = this.input.charCodeAt((this.state.pos += e))
      if (this.state.pos < this.length)
        for (; !nn(n) && ++this.state.pos < this.length; ) n = this.input.charCodeAt(this.state.pos)
      if (this.isLookahead) return
      const s = this.state.pos,
        a = this.input.slice(r + e, s),
        o = { type: 'CommentLine', value: a, start: r, end: s, loc: new So(i, this.state.curPosition()) }
      return this.options.tokens && this.pushToken(o), o
    }
    skipSpace() {
      const e = this.state.pos,
        r = []
      e: for (; this.state.pos < this.length; ) {
        const i = this.input.charCodeAt(this.state.pos)
        switch (i) {
          case 32:
          case 160:
          case 9:
            ++this.state.pos
            break
          case 13:
            this.input.charCodeAt(this.state.pos + 1) === 10 && ++this.state.pos
          case 10:
          case 8232:
          case 8233:
            ++this.state.pos, ++this.state.curLine, (this.state.lineStart = this.state.pos)
            break
          case 47:
            switch (this.input.charCodeAt(this.state.pos + 1)) {
              case 42: {
                const n = this.skipBlockComment()
                n !== void 0 && (this.addComment(n), this.options.attachComment && r.push(n))
                break
              }
              case 47: {
                const n = this.skipLineComment(2)
                n !== void 0 && (this.addComment(n), this.options.attachComment && r.push(n))
                break
              }
              default:
                break e
            }
            break
          default:
            if (w7(i)) ++this.state.pos
            else if (i === 45 && !this.inModule) {
              const n = this.state.pos
              if (
                this.input.charCodeAt(n + 1) === 45 &&
                this.input.charCodeAt(n + 2) === 62 &&
                (e === 0 || this.state.lineStart > e)
              ) {
                const s = this.skipLineComment(3)
                s !== void 0 && (this.addComment(s), this.options.attachComment && r.push(s))
              } else break e
            } else if (i === 60 && !this.inModule) {
              const n = this.state.pos
              if (
                this.input.charCodeAt(n + 1) === 33 &&
                this.input.charCodeAt(n + 2) === 45 &&
                this.input.charCodeAt(n + 3) === 45
              ) {
                const s = this.skipLineComment(4)
                s !== void 0 && (this.addComment(s), this.options.attachComment && r.push(s))
              } else break e
            } else break e
        }
      }
      if (r.length > 0) {
        const i = this.state.pos,
          n = { start: e, end: i, comments: r, leadingNode: null, trailingNode: null, containingNode: null }
        this.state.commentStack.push(n)
      }
    }
    finishToken(e, r) {
      ;(this.state.end = this.state.pos), (this.state.endLoc = this.state.curPosition())
      const i = this.state.type
      ;(this.state.type = e), (this.state.value = r), this.isLookahead || this.updateContext(i)
    }
    replaceToken(e) {
      ;(this.state.type = e), this.updateContext()
    }
    readToken_numberSign() {
      if (this.state.pos === 0 && this.readToken_interpreter()) return
      const e = this.state.pos + 1,
        r = this.codePointAtPos(e)
      if (r >= 48 && r <= 57) throw this.raise(te.UnexpectedDigitAfterHash, { at: this.state.curPosition() })
      if (r === 123 || (r === 91 && this.hasPlugin('recordAndTuple'))) {
        if ((this.expectPlugin('recordAndTuple'), this.getPluginOption('recordAndTuple', 'syntaxType') !== 'hash'))
          throw this.raise(
            r === 123
              ? te.RecordExpressionHashIncorrectStartSyntaxType
              : te.TupleExpressionHashIncorrectStartSyntaxType,
            { at: this.state.curPosition() }
          )
        ;(this.state.pos += 2), r === 123 ? this.finishToken(7) : this.finishToken(1)
      } else Xr(r) ? (++this.state.pos, this.finishToken(134, this.readWord1(r))) : r === 92 ? (++this.state.pos, this.finishToken(134, this.readWord1())) : this.finishOp(27, 1)
    }
    readToken_dot() {
      const e = this.input.charCodeAt(this.state.pos + 1)
      if (e >= 48 && e <= 57) {
        this.readNumber(!0)
        return
      }
      e === 46 && this.input.charCodeAt(this.state.pos + 2) === 46
        ? ((this.state.pos += 3), this.finishToken(21))
        : (++this.state.pos, this.finishToken(16))
    }
    readToken_slash() {
      this.input.charCodeAt(this.state.pos + 1) === 61 ? this.finishOp(31, 2) : this.finishOp(56, 1)
    }
    readToken_interpreter() {
      if (this.state.pos !== 0 || this.length < 2) return !1
      let e = this.input.charCodeAt(this.state.pos + 1)
      if (e !== 33) return !1
      const r = this.state.pos
      for (this.state.pos += 1; !nn(e) && ++this.state.pos < this.length; ) e = this.input.charCodeAt(this.state.pos)
      const i = this.input.slice(r + 2, this.state.pos)
      return this.finishToken(28, i), !0
    }
    readToken_mult_modulo(e) {
      let r = e === 42 ? 55 : 54,
        i = 1,
        n = this.input.charCodeAt(this.state.pos + 1)
      e === 42 && n === 42 && (i++, (n = this.input.charCodeAt(this.state.pos + 2)), (r = 57)),
        n === 61 && !this.state.inType && (i++, (r = e === 37 ? 33 : 30)),
        this.finishOp(r, i)
    }
    readToken_pipe_amp(e) {
      const r = this.input.charCodeAt(this.state.pos + 1)
      if (r === e) {
        this.input.charCodeAt(this.state.pos + 2) === 61 ? this.finishOp(30, 3) : this.finishOp(e === 124 ? 41 : 42, 2)
        return
      }
      if (e === 124) {
        if (r === 62) {
          this.finishOp(39, 2)
          return
        }
        if (this.hasPlugin('recordAndTuple') && r === 125) {
          if (this.getPluginOption('recordAndTuple', 'syntaxType') !== 'bar')
            throw this.raise(te.RecordExpressionBarIncorrectEndSyntaxType, { at: this.state.curPosition() })
          ;(this.state.pos += 2), this.finishToken(9)
          return
        }
        if (this.hasPlugin('recordAndTuple') && r === 93) {
          if (this.getPluginOption('recordAndTuple', 'syntaxType') !== 'bar')
            throw this.raise(te.TupleExpressionBarIncorrectEndSyntaxType, { at: this.state.curPosition() })
          ;(this.state.pos += 2), this.finishToken(4)
          return
        }
      }
      if (r === 61) {
        this.finishOp(30, 2)
        return
      }
      this.finishOp(e === 124 ? 43 : 45, 1)
    }
    readToken_caret() {
      const e = this.input.charCodeAt(this.state.pos + 1)
      if (e === 61 && !this.state.inType) this.finishOp(32, 2)
      else if (e === 94 && this.hasPlugin(['pipelineOperator', { proposal: 'hack', topicToken: '^^' }])) {
        if ((this.finishOp(37, 2), this.input.codePointAt(this.state.pos) === 94)) throw this.unexpected()
      } else this.finishOp(44, 1)
    }
    readToken_atSign() {
      this.input.charCodeAt(this.state.pos + 1) === 64 &&
      this.hasPlugin(['pipelineOperator', { proposal: 'hack', topicToken: '@@' }])
        ? this.finishOp(38, 2)
        : this.finishOp(26, 1)
    }
    readToken_plus_min(e) {
      const r = this.input.charCodeAt(this.state.pos + 1)
      if (r === e) {
        this.finishOp(34, 2)
        return
      }
      r === 61 ? this.finishOp(30, 2) : this.finishOp(53, 1)
    }
    readToken_lt() {
      const { pos: e } = this.state,
        r = this.input.charCodeAt(e + 1)
      if (r === 60) {
        if (this.input.charCodeAt(e + 2) === 61) {
          this.finishOp(30, 3)
          return
        }
        this.finishOp(51, 2)
        return
      }
      if (r === 61) {
        this.finishOp(49, 2)
        return
      }
      this.finishOp(47, 1)
    }
    readToken_gt() {
      const { pos: e } = this.state,
        r = this.input.charCodeAt(e + 1)
      if (r === 62) {
        const i = this.input.charCodeAt(e + 2) === 62 ? 3 : 2
        if (this.input.charCodeAt(e + i) === 61) {
          this.finishOp(30, i + 1)
          return
        }
        this.finishOp(52, i)
        return
      }
      if (r === 61) {
        this.finishOp(49, 2)
        return
      }
      this.finishOp(48, 1)
    }
    readToken_eq_excl(e) {
      const r = this.input.charCodeAt(this.state.pos + 1)
      if (r === 61) {
        this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2)
        return
      }
      if (e === 61 && r === 62) {
        ;(this.state.pos += 2), this.finishToken(19)
        return
      }
      this.finishOp(e === 61 ? 29 : 35, 1)
    }
    readToken_question() {
      const e = this.input.charCodeAt(this.state.pos + 1),
        r = this.input.charCodeAt(this.state.pos + 2)
      e === 63
        ? r === 61
          ? this.finishOp(30, 3)
          : this.finishOp(40, 2)
        : e === 46 && !(r >= 48 && r <= 57)
        ? ((this.state.pos += 2), this.finishToken(18))
        : (++this.state.pos, this.finishToken(17))
    }
    getTokenFromCode(e) {
      switch (e) {
        case 46:
          this.readToken_dot()
          return
        case 40:
          ++this.state.pos, this.finishToken(10)
          return
        case 41:
          ++this.state.pos, this.finishToken(11)
          return
        case 59:
          ++this.state.pos, this.finishToken(13)
          return
        case 44:
          ++this.state.pos, this.finishToken(12)
          return
        case 91:
          if (this.hasPlugin('recordAndTuple') && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption('recordAndTuple', 'syntaxType') !== 'bar')
              throw this.raise(te.TupleExpressionBarIncorrectStartSyntaxType, { at: this.state.curPosition() })
            ;(this.state.pos += 2), this.finishToken(2)
          } else ++this.state.pos, this.finishToken(0)
          return
        case 93:
          ++this.state.pos, this.finishToken(3)
          return
        case 123:
          if (this.hasPlugin('recordAndTuple') && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption('recordAndTuple', 'syntaxType') !== 'bar')
              throw this.raise(te.RecordExpressionBarIncorrectStartSyntaxType, { at: this.state.curPosition() })
            ;(this.state.pos += 2), this.finishToken(6)
          } else ++this.state.pos, this.finishToken(5)
          return
        case 125:
          ++this.state.pos, this.finishToken(8)
          return
        case 58:
          this.hasPlugin('functionBind') && this.input.charCodeAt(this.state.pos + 1) === 58
            ? this.finishOp(15, 2)
            : (++this.state.pos, this.finishToken(14))
          return
        case 63:
          this.readToken_question()
          return
        case 96:
          this.readTemplateToken()
          return
        case 48: {
          const r = this.input.charCodeAt(this.state.pos + 1)
          if (r === 120 || r === 88) {
            this.readRadixNumber(16)
            return
          }
          if (r === 111 || r === 79) {
            this.readRadixNumber(8)
            return
          }
          if (r === 98 || r === 66) {
            this.readRadixNumber(2)
            return
          }
        }
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          this.readNumber(!1)
          return
        case 34:
        case 39:
          this.readString(e)
          return
        case 47:
          this.readToken_slash()
          return
        case 37:
        case 42:
          this.readToken_mult_modulo(e)
          return
        case 124:
        case 38:
          this.readToken_pipe_amp(e)
          return
        case 94:
          this.readToken_caret()
          return
        case 43:
        case 45:
          this.readToken_plus_min(e)
          return
        case 60:
          this.readToken_lt()
          return
        case 62:
          this.readToken_gt()
          return
        case 61:
        case 33:
          this.readToken_eq_excl(e)
          return
        case 126:
          this.finishOp(36, 1)
          return
        case 64:
          this.readToken_atSign()
          return
        case 35:
          this.readToken_numberSign()
          return
        case 92:
          this.readWord()
          return
        default:
          if (Xr(e)) {
            this.readWord(e)
            return
          }
      }
      throw this.raise(te.InvalidOrUnexpectedToken, {
        at: this.state.curPosition(),
        unexpected: String.fromCodePoint(e),
      })
    }
    finishOp(e, r) {
      const i = this.input.slice(this.state.pos, this.state.pos + r)
      ;(this.state.pos += r), this.finishToken(e, i)
    }
    readRegexp() {
      const e = this.state.startLoc,
        r = this.state.start + 1
      let i,
        n,
        { pos: s } = this.state
      for (; ; ++s) {
        if (s >= this.length) throw this.raise(te.UnterminatedRegExp, { at: zt(e, 1) })
        const c = this.input.charCodeAt(s)
        if (nn(c)) throw this.raise(te.UnterminatedRegExp, { at: zt(e, 1) })
        if (i) i = !1
        else {
          if (c === 91) n = !0
          else if (c === 93 && n) n = !1
          else if (c === 47 && !n) break
          i = c === 92
        }
      }
      const a = this.input.slice(r, s)
      ++s
      let o = ''
      const u = () => zt(e, s + 2 - r)
      for (; s < this.length; ) {
        const c = this.codePointAtPos(s),
          p = String.fromCharCode(c)
        if (I7.has(c))
          c === 118
            ? (this.expectPlugin('regexpUnicodeSets', u()),
              o.includes('u') && this.raise(te.IncompatibleRegExpUVFlags, { at: u() }))
            : c === 117 && o.includes('v') && this.raise(te.IncompatibleRegExpUVFlags, { at: u() }),
            o.includes(p) && this.raise(te.DuplicateRegExpFlags, { at: u() })
        else if (On(c) || c === 92) this.raise(te.MalformedRegExpFlags, { at: u() })
        else break
        ++s, (o += p)
      }
      ;(this.state.pos = s), this.finishToken(133, { pattern: a, flags: o })
    }
    readInt(e, r, i, n = !0) {
      const s = this.state.pos,
        a = e === 16 ? n0.hex : n0.decBinOct,
        o = e === 16 ? Do.hex : e === 10 ? Do.dec : e === 8 ? Do.oct : Do.bin
      let u = !1,
        c = 0
      for (let p = 0, h = r == null ? 1 / 0 : r; p < h; ++p) {
        const f = this.input.charCodeAt(this.state.pos)
        let d
        if (f === 95 && n !== 'bail') {
          const T = this.input.charCodeAt(this.state.pos - 1),
            y = this.input.charCodeAt(this.state.pos + 1)
          n
            ? (Number.isNaN(y) || !o(y) || a.has(T) || a.has(y)) &&
              this.raise(te.UnexpectedNumericSeparator, { at: this.state.curPosition() })
            : this.raise(te.NumericSeparatorInEscapeSequence, { at: this.state.curPosition() }),
            ++this.state.pos
          continue
        }
        if ((f >= 97 ? (d = f - 97 + 10) : f >= 65 ? (d = f - 65 + 10) : x7(f) ? (d = f - 48) : (d = 1 / 0), d >= e))
          if (this.options.errorRecovery && d <= 9)
            (d = 0), this.raise(te.InvalidDigit, { at: this.state.curPosition(), radix: e })
          else if (i) (d = 0), (u = !0)
          else break
        ++this.state.pos, (c = c * e + d)
      }
      return this.state.pos === s || (r != null && this.state.pos - s !== r) || u ? null : c
    }
    readRadixNumber(e) {
      const r = this.state.curPosition()
      let i = !1
      this.state.pos += 2
      const n = this.readInt(e)
      n == null && this.raise(te.InvalidDigit, { at: zt(r, 2), radix: e })
      const s = this.input.charCodeAt(this.state.pos)
      if (s === 110) ++this.state.pos, (i = !0)
      else if (s === 109) throw this.raise(te.InvalidDecimal, { at: r })
      if (Xr(this.codePointAtPos(this.state.pos)))
        throw this.raise(te.NumberIdentifier, { at: this.state.curPosition() })
      if (i) {
        const a = this.input.slice(r.index, this.state.pos).replace(/[_n]/g, '')
        this.finishToken(131, a)
        return
      }
      this.finishToken(130, n)
    }
    readNumber(e) {
      const r = this.state.pos,
        i = this.state.curPosition()
      let n = !1,
        s = !1,
        a = !1,
        o = !1,
        u = !1
      !e && this.readInt(10) === null && this.raise(te.InvalidNumber, { at: this.state.curPosition() })
      const c = this.state.pos - r >= 2 && this.input.charCodeAt(r) === 48
      if (c) {
        const d = this.input.slice(r, this.state.pos)
        if ((this.recordStrictModeErrors(te.StrictOctalLiteral, { at: i }), !this.state.strict)) {
          const T = d.indexOf('_')
          T > 0 && this.raise(te.ZeroDigitNumericSeparator, { at: zt(i, T) })
        }
        u = c && !/[89]/.test(d)
      }
      let p = this.input.charCodeAt(this.state.pos)
      if (
        (p === 46 && !u && (++this.state.pos, this.readInt(10), (n = !0), (p = this.input.charCodeAt(this.state.pos))),
        (p === 69 || p === 101) &&
          !u &&
          ((p = this.input.charCodeAt(++this.state.pos)),
          (p === 43 || p === 45) && ++this.state.pos,
          this.readInt(10) === null && this.raise(te.InvalidOrMissingExponent, { at: i }),
          (n = !0),
          (o = !0),
          (p = this.input.charCodeAt(this.state.pos))),
        p === 110 && ((n || c) && this.raise(te.InvalidBigIntLiteral, { at: i }), ++this.state.pos, (s = !0)),
        p === 109 &&
          (this.expectPlugin('decimal', this.state.curPosition()),
          (o || c) && this.raise(te.InvalidDecimal, { at: i }),
          ++this.state.pos,
          (a = !0)),
        Xr(this.codePointAtPos(this.state.pos)))
      )
        throw this.raise(te.NumberIdentifier, { at: this.state.curPosition() })
      const h = this.input.slice(r, this.state.pos).replace(/[_mn]/g, '')
      if (s) {
        this.finishToken(131, h)
        return
      }
      if (a) {
        this.finishToken(132, h)
        return
      }
      const f = u ? parseInt(h, 8) : parseFloat(h)
      this.finishToken(130, f)
    }
    readCodePoint(e) {
      const r = this.input.charCodeAt(this.state.pos)
      let i
      if (r === 123) {
        if (
          (++this.state.pos,
          (i = this.readHexChar(this.input.indexOf('}', this.state.pos) - this.state.pos, !0, e)),
          ++this.state.pos,
          i !== null && i > 1114111)
        )
          if (e) this.raise(te.InvalidCodePoint, { at: this.state.curPosition() })
          else return null
      } else i = this.readHexChar(4, !1, e)
      return i
    }
    readString(e) {
      let r = '',
        i = ++this.state.pos
      for (;;) {
        if (this.state.pos >= this.length) throw this.raise(te.UnterminatedString, { at: this.state.startLoc })
        const n = this.input.charCodeAt(this.state.pos)
        if (n === e) break
        if (n === 92) (r += this.input.slice(i, this.state.pos)), (r += this.readEscapedChar(!1)), (i = this.state.pos)
        else if (n === 8232 || n === 8233)
          ++this.state.pos, ++this.state.curLine, (this.state.lineStart = this.state.pos)
        else {
          if (nn(n)) throw this.raise(te.UnterminatedString, { at: this.state.startLoc })
          ++this.state.pos
        }
      }
      ;(r += this.input.slice(i, this.state.pos++)), this.finishToken(129, r)
    }
    readTemplateContinuation() {
      this.match(8) || this.unexpected(null, 8), this.state.pos--, this.readTemplateToken()
    }
    readTemplateToken() {
      let e = '',
        r = this.state.pos,
        i = !1
      for (++this.state.pos; ; ) {
        if (this.state.pos >= this.length) throw this.raise(te.UnterminatedTemplate, { at: zt(this.state.startLoc, 1) })
        const n = this.input.charCodeAt(this.state.pos)
        if (n === 96) {
          ++this.state.pos, (e += this.input.slice(r, this.state.pos)), this.finishToken(24, i ? null : e)
          return
        }
        if (n === 36 && this.input.charCodeAt(this.state.pos + 1) === 123) {
          ;(this.state.pos += 2), (e += this.input.slice(r, this.state.pos)), this.finishToken(25, i ? null : e)
          return
        }
        if (n === 92) {
          e += this.input.slice(r, this.state.pos)
          const s = this.readEscapedChar(!0)
          s === null ? (i = !0) : (e += s), (r = this.state.pos)
        } else if (nn(n)) {
          switch (((e += this.input.slice(r, this.state.pos)), ++this.state.pos, n)) {
            case 13:
              this.input.charCodeAt(this.state.pos) === 10 && ++this.state.pos
            case 10:
              e += `
`
              break
            default:
              e += String.fromCharCode(n)
              break
          }
          ++this.state.curLine, (this.state.lineStart = this.state.pos), (r = this.state.pos)
        } else ++this.state.pos
      }
    }
    recordStrictModeErrors(e, { at: r }) {
      const i = r.index
      this.state.strict && !this.state.strictErrors.has(i)
        ? this.raise(e, { at: r })
        : this.state.strictErrors.set(i, [e, r])
    }
    readEscapedChar(e) {
      const r = !e,
        i = this.input.charCodeAt(++this.state.pos)
      switch ((++this.state.pos, i)) {
        case 110:
          return `
`
        case 114:
          return '\r'
        case 120: {
          const n = this.readHexChar(2, !1, r)
          return n === null ? null : String.fromCharCode(n)
        }
        case 117: {
          const n = this.readCodePoint(r)
          return n === null ? null : String.fromCodePoint(n)
        }
        case 116:
          return '	'
        case 98:
          return '\b'
        case 118:
          return '\v'
        case 102:
          return '\f'
        case 13:
          this.input.charCodeAt(this.state.pos) === 10 && ++this.state.pos
        case 10:
          ;(this.state.lineStart = this.state.pos), ++this.state.curLine
        case 8232:
        case 8233:
          return ''
        case 56:
        case 57:
          if (e) return null
          this.recordStrictModeErrors(te.StrictNumericEscape, { at: zt(this.state.curPosition(), -1) })
        default:
          if (i >= 48 && i <= 55) {
            const n = zt(this.state.curPosition(), -1)
            let a = this.input.slice(this.state.pos - 1, this.state.pos + 2).match(/^[0-7]+/)[0],
              o = parseInt(a, 8)
            o > 255 && ((a = a.slice(0, -1)), (o = parseInt(a, 8))), (this.state.pos += a.length - 1)
            const u = this.input.charCodeAt(this.state.pos)
            if (a !== '0' || u === 56 || u === 57) {
              if (e) return null
              this.recordStrictModeErrors(te.StrictNumericEscape, { at: n })
            }
            return String.fromCharCode(o)
          }
          return String.fromCharCode(i)
      }
    }
    readHexChar(e, r, i) {
      const n = this.state.curPosition(),
        s = this.readInt(16, e, r, !1)
      return s === null && (i ? this.raise(te.InvalidEscapeSequence, { at: n }) : (this.state.pos = n.index - 1)), s
    }
    readWord1(e) {
      this.state.containsEsc = !1
      let r = ''
      const i = this.state.pos
      let n = this.state.pos
      for (e !== void 0 && (this.state.pos += e <= 65535 ? 1 : 2); this.state.pos < this.length; ) {
        const s = this.codePointAtPos(this.state.pos)
        if (On(s)) this.state.pos += s <= 65535 ? 1 : 2
        else if (s === 92) {
          ;(this.state.containsEsc = !0), (r += this.input.slice(n, this.state.pos))
          const a = this.state.curPosition(),
            o = this.state.pos === i ? Xr : On
          if (this.input.charCodeAt(++this.state.pos) !== 117) {
            this.raise(te.MissingUnicodeEscape, { at: this.state.curPosition() }), (n = this.state.pos - 1)
            continue
          }
          ++this.state.pos
          const u = this.readCodePoint(!0)
          u !== null && (o(u) || this.raise(te.EscapedCharNotAnIdentifier, { at: a }), (r += String.fromCodePoint(u))),
            (n = this.state.pos)
        } else break
      }
      return r + this.input.slice(n, this.state.pos)
    }
    readWord(e) {
      const r = this.readWord1(e),
        i = Lc.get(r)
      i !== void 0 ? this.finishToken(i, gi(i)) : this.finishToken(128, r)
    }
    checkKeywordEscapes() {
      const { type: e } = this.state
      _c(e) &&
        this.state.containsEsc &&
        this.raise(te.InvalidEscapedReservedWord, { at: this.state.startLoc, reservedWord: gi(e) })
    }
    raise(e, r) {
      const { at: i } = r,
        n = Nc(r, A7),
        s = i instanceof en ? i : i.loc.start,
        a = e({ loc: s, details: n })
      if (!this.options.errorRecovery) throw a
      return this.isLookahead || this.state.errors.push(a), a
    }
    raiseOverwrite(e, r) {
      const { at: i } = r,
        n = Nc(r, C7),
        s = i instanceof en ? i : i.loc.start,
        a = s.index,
        o = this.state.errors
      for (let u = o.length - 1; u >= 0; u--) {
        const c = o[u]
        if (c.loc.index === a) return (o[u] = e({ loc: s, details: n }))
        if (c.loc.index < a) break
      }
      return this.raise(e, r)
    }
    updateContext(e) {}
    unexpected(e, r) {
      throw this.raise(te.UnexpectedToken, { expected: r ? gi(r) : null, at: e != null ? e : this.state.startLoc })
    }
    expectPlugin(e, r) {
      if (this.hasPlugin(e)) return !0
      throw this.raise(te.MissingPlugin, { at: r != null ? r : this.state.startLoc, missingPlugin: [e] })
    }
    expectOnePlugin(e) {
      if (!e.some((r) => this.hasPlugin(r)))
        throw this.raise(te.MissingOneOfPlugins, { at: this.state.startLoc, missingPlugin: e })
    }
  }
  class ip {
    constructor(e) {
      ;(this.var = new Set()), (this.lexical = new Set()), (this.functions = new Set()), (this.flags = e)
    }
  }
  class np {
    constructor(e, r) {
      ;(this.parser = void 0),
        (this.scopeStack = []),
        (this.inModule = void 0),
        (this.undefinedExports = new Map()),
        (this.parser = e),
        (this.inModule = r)
    }
    get inFunction() {
      return (this.currentVarScopeFlags() & Gr) > 0
    }
    get allowSuper() {
      return (this.currentThisScopeFlags() & wo) > 0
    }
    get allowDirectSuper() {
      return (this.currentThisScopeFlags() & Xy) > 0
    }
    get inClass() {
      return (this.currentThisScopeFlags() & tn) > 0
    }
    get inClassAndNotInNonArrowFunction() {
      const e = this.currentThisScopeFlags()
      return (e & tn) > 0 && (e & Gr) === 0
    }
    get inStaticBlock() {
      for (let e = this.scopeStack.length - 1; ; e--) {
        const { flags: r } = this.scopeStack[e]
        if (r & Wc) return !0
        if (r & (Co | tn)) return !1
      }
    }
    get inNonArrowFunction() {
      return (this.currentThisScopeFlags() & Gr) > 0
    }
    get treatFunctionsAsVar() {
      return this.treatFunctionsAsVarInScope(this.currentScope())
    }
    createScope(e) {
      return new ip(e)
    }
    enter(e) {
      this.scopeStack.push(this.createScope(e))
    }
    exit() {
      this.scopeStack.pop()
    }
    treatFunctionsAsVarInScope(e) {
      return !!(e.flags & (Gr | Wc) || (!this.parser.inModule && e.flags & Os))
    }
    declareName(e, r, i) {
      let n = this.currentScope()
      if (r & Ti || r & xo)
        this.checkRedeclarationInScope(n, e, r, i),
          r & xo ? n.functions.add(e) : n.lexical.add(e),
          r & Ti && this.maybeExportDefined(n, e)
      else if (r & Gy)
        for (
          let s = this.scopeStack.length - 1;
          s >= 0 &&
          ((n = this.scopeStack[s]),
          this.checkRedeclarationInScope(n, e, r, i),
          n.var.add(e),
          this.maybeExportDefined(n, e),
          !(n.flags & Co));
          --s
        );
      this.parser.inModule && n.flags & Os && this.undefinedExports.delete(e)
    }
    maybeExportDefined(e, r) {
      this.parser.inModule && e.flags & Os && this.undefinedExports.delete(r)
    }
    checkRedeclarationInScope(e, r, i, n) {
      this.isRedeclaredInScope(e, r, i) && this.parser.raise(te.VarRedeclaration, { at: n, identifierName: r })
    }
    isRedeclaredInScope(e, r, i) {
      return i & Jr
        ? i & Ti
          ? e.lexical.has(r) || e.functions.has(r) || e.var.has(r)
          : i & xo
          ? e.lexical.has(r) || (!this.treatFunctionsAsVarInScope(e) && e.var.has(r))
          : (e.lexical.has(r) && !(e.flags & qy && e.lexical.values().next().value === r)) ||
            (!this.treatFunctionsAsVarInScope(e) && e.functions.has(r))
        : !1
    }
    checkLocalExport(e) {
      const { name: r } = e,
        i = this.scopeStack[0]
      !i.lexical.has(r) && !i.var.has(r) && !i.functions.has(r) && this.undefinedExports.set(r, e.loc.start)
    }
    currentScope() {
      return this.scopeStack[this.scopeStack.length - 1]
    }
    currentVarScopeFlags() {
      for (let e = this.scopeStack.length - 1; ; e--) {
        const { flags: r } = this.scopeStack[e]
        if (r & Co) return r
      }
    }
    currentThisScopeFlags() {
      for (let e = this.scopeStack.length - 1; ; e--) {
        const { flags: r } = this.scopeStack[e]
        if (r & (Co | tn) && !(r & Kc)) return r
      }
    }
  }
  class N7 extends ip {
    constructor(...e) {
      super(...e), (this.declareFunctions = new Set())
    }
  }
  class O7 extends np {
    createScope(e) {
      return new N7(e)
    }
    declareName(e, r, i) {
      const n = this.currentScope()
      if (r & Xc) {
        this.checkRedeclarationInScope(n, e, r, i), this.maybeExportDefined(n, e), n.declareFunctions.add(e)
        return
      }
      super.declareName(...arguments)
    }
    isRedeclaredInScope(e, r, i) {
      return super.isRedeclaredInScope(...arguments)
        ? !0
        : i & Xc
        ? !e.declareFunctions.has(r) && (e.lexical.has(r) || e.functions.has(r))
        : !1
    }
    checkLocalExport(e) {
      this.scopeStack[0].declareFunctions.has(e.name) || super.checkLocalExport(e)
    }
  }
  class D7 {
    constructor() {
      ;(this.privateNames = new Set()), (this.loneAccessors = new Map()), (this.undefinedPrivateNames = new Map())
    }
  }
  class B7 {
    constructor(e) {
      ;(this.parser = void 0), (this.stack = []), (this.undefinedPrivateNames = new Map()), (this.parser = e)
    }
    current() {
      return this.stack[this.stack.length - 1]
    }
    enter() {
      this.stack.push(new D7())
    }
    exit() {
      const e = this.stack.pop(),
        r = this.current()
      for (const [i, n] of Array.from(e.undefinedPrivateNames))
        r
          ? r.undefinedPrivateNames.has(i) || r.undefinedPrivateNames.set(i, n)
          : this.parser.raise(te.InvalidPrivateFieldResolution, { at: n, identifierName: i })
    }
    declarePrivateName(e, r, i) {
      const { privateNames: n, loneAccessors: s, undefinedPrivateNames: a } = this.current()
      let o = n.has(e)
      if (r & Zc) {
        const u = o && s.get(e)
        if (u) {
          const c = u & No,
            p = r & No,
            h = u & Zc,
            f = r & Zc
          ;(o = h === f || c !== p), o || s.delete(e)
        } else o || s.set(e, r)
      }
      o && this.parser.raise(te.PrivateNameRedeclaration, { at: i, identifierName: e }), n.add(e), a.delete(e)
    }
    usePrivateName(e, r) {
      let i
      for (i of this.stack) if (i.privateNames.has(e)) return
      i
        ? i.undefinedPrivateNames.set(e, r)
        : this.parser.raise(te.InvalidPrivateFieldResolution, { at: r, identifierName: e })
    }
  }
  const L7 = 0,
    s0 = 1,
    sp = 2,
    a0 = 3
  class Bo {
    constructor(e = L7) {
      ;(this.type = void 0), (this.type = e)
    }
    canBeArrowParameterDeclaration() {
      return this.type === sp || this.type === s0
    }
    isCertainlyParameterDeclaration() {
      return this.type === a0
    }
  }
  class o0 extends Bo {
    constructor(e) {
      super(e), (this.declarationErrors = new Map())
    }
    recordDeclarationError(e, { at: r }) {
      const i = r.index
      this.declarationErrors.set(i, [e, r])
    }
    clearDeclarationError(e) {
      this.declarationErrors.delete(e)
    }
    iterateErrors(e) {
      this.declarationErrors.forEach(e)
    }
  }
  class M7 {
    constructor(e) {
      ;(this.parser = void 0), (this.stack = [new Bo()]), (this.parser = e)
    }
    enter(e) {
      this.stack.push(e)
    }
    exit() {
      this.stack.pop()
    }
    recordParameterInitializerError(e, { at: r }) {
      const i = { at: r.loc.start },
        { stack: n } = this
      let s = n.length - 1,
        a = n[s]
      for (; !a.isCertainlyParameterDeclaration(); ) {
        if (a.canBeArrowParameterDeclaration()) a.recordDeclarationError(e, i)
        else return
        a = n[--s]
      }
      this.parser.raise(e, i)
    }
    recordArrowParemeterBindingError(e, { at: r }) {
      const { stack: i } = this,
        n = i[i.length - 1],
        s = { at: r.loc.start }
      if (n.isCertainlyParameterDeclaration()) this.parser.raise(e, s)
      else if (n.canBeArrowParameterDeclaration()) n.recordDeclarationError(e, s)
      else return
    }
    recordAsyncArrowParametersError({ at: e }) {
      const { stack: r } = this
      let i = r.length - 1,
        n = r[i]
      for (; n.canBeArrowParameterDeclaration(); )
        n.type === sp && n.recordDeclarationError(te.AwaitBindingIdentifier, { at: e }), (n = r[--i])
    }
    validateAsPattern() {
      const { stack: e } = this,
        r = e[e.length - 1]
      !r.canBeArrowParameterDeclaration() ||
        r.iterateErrors(([i, n]) => {
          this.parser.raise(i, { at: n })
          let s = e.length - 2,
            a = e[s]
          for (; a.canBeArrowParameterDeclaration(); ) a.clearDeclarationError(n.index), (a = e[--s])
        })
    }
  }
  function F7() {
    return new Bo(a0)
  }
  function $7() {
    return new o0(s0)
  }
  function R7() {
    return new o0(sp)
  }
  function l0() {
    return new Bo()
  }
  const Ln = 0,
    u0 = 1,
    Lo = 2,
    c0 = 4,
    Mn = 8
  class j7 {
    constructor() {
      this.stacks = []
    }
    enter(e) {
      this.stacks.push(e)
    }
    exit() {
      this.stacks.pop()
    }
    currentFlags() {
      return this.stacks[this.stacks.length - 1]
    }
    get hasAwait() {
      return (this.currentFlags() & Lo) > 0
    }
    get hasYield() {
      return (this.currentFlags() & u0) > 0
    }
    get hasReturn() {
      return (this.currentFlags() & c0) > 0
    }
    get hasIn() {
      return (this.currentFlags() & Mn) > 0
    }
  }
  function Mo(t, e) {
    return (t ? Lo : 0) | (e ? u0 : 0)
  }
  class _7 extends k7 {
    addExtra(e, r, i, n = !0) {
      if (!e) return
      const s = (e.extra = e.extra || {})
      n ? (s[r] = i) : Object.defineProperty(s, r, { enumerable: n, value: i })
    }
    isContextual(e) {
      return this.state.type === e && !this.state.containsEsc
    }
    isUnparsedContextual(e, r) {
      const i = e + r.length
      if (this.input.slice(e, i) === r) {
        const n = this.input.charCodeAt(i)
        return !(On(n) || (n & 64512) === 55296)
      }
      return !1
    }
    isLookaheadContextual(e) {
      const r = this.nextTokenStart()
      return this.isUnparsedContextual(r, e)
    }
    eatContextual(e) {
      return this.isContextual(e) ? (this.next(), !0) : !1
    }
    expectContextual(e, r) {
      if (!this.eatContextual(e))
        throw r != null ? this.raise(r, { at: this.state.startLoc }) : this.unexpected(null, e)
    }
    canInsertSemicolon() {
      return this.match(135) || this.match(8) || this.hasPrecedingLineBreak()
    }
    hasPrecedingLineBreak() {
      return ep.test(this.input.slice(this.state.lastTokEndLoc.index, this.state.start))
    }
    hasFollowingLineBreak() {
      return (i0.lastIndex = this.state.end), i0.test(this.input)
    }
    isLineTerminator() {
      return this.eat(13) || this.canInsertSemicolon()
    }
    semicolon(e = !0) {
      ;(e ? this.isLineTerminator() : this.eat(13)) || this.raise(te.MissingSemicolon, { at: this.state.lastTokEndLoc })
    }
    expect(e, r) {
      this.eat(e) || this.unexpected(r, e)
    }
    tryParse(e, r = this.state.clone()) {
      const i = { node: null }
      try {
        const n = e((s = null) => {
          throw ((i.node = s), i)
        })
        if (this.state.errors.length > r.errors.length) {
          const s = this.state
          return (
            (this.state = r),
            (this.state.tokensLength = s.tokensLength),
            { node: n, error: s.errors[r.errors.length], thrown: !1, aborted: !1, failState: s }
          )
        }
        return { node: n, error: null, thrown: !1, aborted: !1, failState: null }
      } catch (n) {
        const s = this.state
        if (((this.state = r), n instanceof SyntaxError))
          return { node: null, error: n, thrown: !0, aborted: !1, failState: s }
        if (n === i) return { node: i.node, error: null, thrown: !1, aborted: !0, failState: s }
        throw n
      }
    }
    checkExpressionErrors(e, r) {
      if (!e) return !1
      const { shorthandAssignLoc: i, doubleProtoLoc: n, privateKeyLoc: s, optionalParametersLoc: a } = e,
        o = !!i || !!n || !!a || !!s
      if (!r) return o
      i != null && this.raise(te.InvalidCoverInitializedName, { at: i }),
        n != null && this.raise(te.DuplicateProto, { at: n }),
        s != null && this.raise(te.UnexpectedPrivateField, { at: s }),
        a != null && this.unexpected(a)
    }
    isLiteralPropertyName() {
      return _y(this.state.type)
    }
    isPrivateName(e) {
      return e.type === 'PrivateName'
    }
    getPrivateNameSV(e) {
      return e.id.name
    }
    hasPropertyAsPrivateName(e) {
      return (e.type === 'MemberExpression' || e.type === 'OptionalMemberExpression') && this.isPrivateName(e.property)
    }
    isOptionalChain(e) {
      return e.type === 'OptionalMemberExpression' || e.type === 'OptionalCallExpression'
    }
    isObjectProperty(e) {
      return e.type === 'ObjectProperty'
    }
    isObjectMethod(e) {
      return e.type === 'ObjectMethod'
    }
    initializeScopes(e = this.options.sourceType === 'module') {
      const r = this.state.labels
      this.state.labels = []
      const i = this.exportedIdentifiers
      this.exportedIdentifiers = new Set()
      const n = this.inModule
      this.inModule = e
      const s = this.scope,
        a = this.getScopeHandler()
      this.scope = new a(this, e)
      const o = this.prodParam
      this.prodParam = new j7()
      const u = this.classScope
      this.classScope = new B7(this)
      const c = this.expressionScope
      return (
        (this.expressionScope = new M7(this)),
        () => {
          ;(this.state.labels = r),
            (this.exportedIdentifiers = i),
            (this.inModule = n),
            (this.scope = s),
            (this.prodParam = o),
            (this.classScope = u),
            (this.expressionScope = c)
        }
      )
    }
    enterInitialScopes() {
      let e = Ln
      this.inModule && (e |= Lo), this.scope.enter(Os), this.prodParam.enter(e)
    }
    checkDestructuringPrivate(e) {
      const { privateKeyLoc: r } = e
      r !== null && this.expectPlugin('destructuringPrivate', r)
    }
  }
  class Fo {
    constructor() {
      ;(this.shorthandAssignLoc = null),
        (this.doubleProtoLoc = null),
        (this.privateKeyLoc = null),
        (this.optionalParametersLoc = null)
    }
  }
  class $o {
    constructor(e, r, i) {
      ;(this.type = ''),
        (this.start = r),
        (this.end = 0),
        (this.loc = new So(i)),
        e != null && e.options.ranges && (this.range = [r, 0]),
        e != null && e.filename && (this.loc.filename = e.filename)
    }
  }
  const ap = $o.prototype
  ap.__clone = function () {
    const t = new $o(),
      e = Object.keys(this)
    for (let r = 0, i = e.length; r < i; r++) {
      const n = e[r]
      n !== 'leadingComments' && n !== 'trailingComments' && n !== 'innerComments' && (t[n] = this[n])
    }
    return t
  }
  function V7(t) {
    return Qr(t)
  }
  function Qr(t) {
    const { type: e, start: r, end: i, loc: n, range: s, extra: a, name: o } = t,
      u = Object.create(ap)
    return (
      (u.type = e),
      (u.start = r),
      (u.end = i),
      (u.loc = n),
      (u.range = s),
      (u.extra = a),
      (u.name = o),
      e === 'Placeholder' && (u.expectedNode = t.expectedNode),
      u
    )
  }
  function U7(t) {
    const { type: e, start: r, end: i, loc: n, range: s, extra: a } = t
    if (e === 'Placeholder') return V7(t)
    const o = Object.create(ap)
    return (
      (o.type = e),
      (o.start = r),
      (o.end = i),
      (o.loc = n),
      (o.range = s),
      t.raw !== void 0 ? (o.raw = t.raw) : (o.extra = a),
      (o.value = t.value),
      o
    )
  }
  class z7 extends _7 {
    startNode() {
      return new $o(this, this.state.start, this.state.startLoc)
    }
    startNodeAt(e, r) {
      return new $o(this, e, r)
    }
    startNodeAtNode(e) {
      return this.startNodeAt(e.start, e.loc.start)
    }
    finishNode(e, r) {
      return this.finishNodeAt(e, r, this.state.lastTokEndLoc)
    }
    finishNodeAt(e, r, i) {
      return (
        (e.type = r),
        (e.end = i.index),
        (e.loc.end = i),
        this.options.ranges && (e.range[1] = i.index),
        this.options.attachComment && this.processComment(e),
        e
      )
    }
    resetStartLocation(e, r, i) {
      ;(e.start = r), (e.loc.start = i), this.options.ranges && (e.range[0] = r)
    }
    resetEndLocation(e, r = this.state.lastTokEndLoc) {
      ;(e.end = r.index), (e.loc.end = r), this.options.ranges && (e.range[1] = r.index)
    }
    resetStartLocationFromNode(e, r) {
      this.resetStartLocation(e, r.start, r.loc.start)
    }
  }
  const K7 = new Set([
      '_',
      'any',
      'bool',
      'boolean',
      'empty',
      'extends',
      'false',
      'interface',
      'mixed',
      'null',
      'number',
      'static',
      'string',
      'true',
      'typeof',
      'void',
    ]),
    Ye = Wr`flow`((t) => ({
      AmbiguousConditionalArrow: t('Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.'),
      AmbiguousDeclareModuleKind: t(
        'Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.'
      ),
      AssignReservedType: t(({ reservedType: e }) => `Cannot overwrite reserved type ${e}.`),
      DeclareClassElement: t('The `declare` modifier can only appear on class fields.'),
      DeclareClassFieldInitializer: t('Initializers are not allowed in fields with the `declare` modifier.'),
      DuplicateDeclareModuleExports: t('Duplicate `declare module.exports` statement.'),
      EnumBooleanMemberNotInitialized: t(
        ({ memberName: e, enumName: r }) =>
          `Boolean enum members need to be initialized. Use either \`${e} = true,\` or \`${e} = false,\` in enum \`${r}\`.`
      ),
      EnumDuplicateMemberName: t(
        ({ memberName: e, enumName: r }) =>
          `Enum member names need to be unique, but the name \`${e}\` has already been used before in enum \`${r}\`.`
      ),
      EnumInconsistentMemberValues: t(
        ({ enumName: e }) =>
          `Enum \`${e}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`
      ),
      EnumInvalidExplicitType: t(
        ({ invalidEnumType: e, enumName: r }) =>
          `Enum type \`${e}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${r}\`.`
      ),
      EnumInvalidExplicitTypeUnknownSupplied: t(
        ({ enumName: e }) =>
          `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${e}\`.`
      ),
      EnumInvalidMemberInitializerPrimaryType: t(
        ({ enumName: e, memberName: r, explicitType: i }) =>
          `Enum \`${e}\` has type \`${i}\`, so the initializer of \`${r}\` needs to be a ${i} literal.`
      ),
      EnumInvalidMemberInitializerSymbolType: t(
        ({ enumName: e, memberName: r }) => `Symbol enum members cannot be initialized. Use \`${r},\` in enum \`${e}\`.`
      ),
      EnumInvalidMemberInitializerUnknownType: t(
        ({ enumName: e, memberName: r }) =>
          `The enum member initializer for \`${r}\` needs to be a literal (either a boolean, number, or string) in enum \`${e}\`.`
      ),
      EnumInvalidMemberName: t(
        ({ enumName: e, memberName: r, suggestion: i }) =>
          `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${r}\`, consider using \`${i}\`, in enum \`${e}\`.`
      ),
      EnumNumberMemberNotInitialized: t(
        ({ enumName: e, memberName: r }) =>
          `Number enum members need to be initialized, e.g. \`${r} = 1\` in enum \`${e}\`.`
      ),
      EnumStringMemberInconsistentlyInitailized: t(
        ({ enumName: e }) =>
          `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${e}\`.`
      ),
      GetterMayNotHaveThisParam: t('A getter cannot have a `this` parameter.'),
      ImportTypeShorthandOnlyInPureImport: t(
        'The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.'
      ),
      InexactInsideExact: t('Explicit inexact syntax cannot appear inside an explicit exact object type.'),
      InexactInsideNonObject: t('Explicit inexact syntax cannot appear in class or interface definitions.'),
      InexactVariance: t('Explicit inexact syntax cannot have variance.'),
      InvalidNonTypeImportInDeclareModule: t(
        'Imports within a `declare module` body must always be `import type` or `import typeof`.'
      ),
      MissingTypeParamDefault: t(
        'Type parameter declaration needs a default, since a preceding type parameter declaration has a default.'
      ),
      NestedDeclareModule: t('`declare module` cannot be used inside another `declare module`.'),
      NestedFlowComment: t('Cannot have a flow comment inside another flow comment.'),
      PatternIsOptional: t('A binding pattern parameter cannot be optional in an implementation signature.', {
        reasonCode: 'OptionalBindingPattern',
      }),
      SetterMayNotHaveThisParam: t('A setter cannot have a `this` parameter.'),
      SpreadVariance: t('Spread properties cannot have variance.'),
      ThisParamAnnotationRequired: t('A type annotation is required for the `this` parameter.'),
      ThisParamBannedInConstructor: t(
        "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions."
      ),
      ThisParamMayNotBeOptional: t('The `this` parameter cannot be optional.'),
      ThisParamMustBeFirst: t('The `this` parameter must be the first function parameter.'),
      ThisParamNoDefault: t('The `this` parameter may not have a default value.'),
      TypeBeforeInitializer: t(
        'Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.'
      ),
      TypeCastInPattern: t('The type cast expression is expected to be wrapped with parenthesis.'),
      UnexpectedExplicitInexactInObject: t('Explicit inexact syntax must appear at the end of an inexact object.'),
      UnexpectedReservedType: t(({ reservedType: e }) => `Unexpected reserved type ${e}.`),
      UnexpectedReservedUnderscore: t('`_` is only allowed as a type argument to call or new.'),
      UnexpectedSpaceBetweenModuloChecks: t('Spaces between `%` and `checks` are not allowed here.'),
      UnexpectedSpreadType: t('Spread operator cannot appear in class or interface definitions.'),
      UnexpectedSubtractionOperand: t('Unexpected token, expected "number" or "bigint".'),
      UnexpectedTokenAfterTypeParameter: t('Expected an arrow function after this type parameter declaration.'),
      UnexpectedTypeParameterBeforeAsyncArrowFunction: t(
        'Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.'
      ),
      UnsupportedDeclareExportKind: t(
        ({ unsupportedExportKind: e, suggestion: r }) =>
          `\`declare export ${e}\` is not supported. Use \`${r}\` instead.`
      ),
      UnsupportedStatementInDeclareModule: t('Only declares and type imports are allowed inside declare module.'),
      UnterminatedFlowComment: t('Unterminated flow-comment.'),
    }))
  function W7(t) {
    return (
      t.type === 'DeclareExportAllDeclaration' ||
      (t.type === 'DeclareExportDeclaration' &&
        (!t.declaration || (t.declaration.type !== 'TypeAlias' && t.declaration.type !== 'InterfaceDeclaration')))
    )
  }
  function op(t) {
    return t.importKind === 'type' || t.importKind === 'typeof'
  }
  function p0(t) {
    return Hr(t) && t !== 97
  }
  const Y7 = {
    const: 'declare export var',
    let: 'declare export var',
    type: 'export type',
    interface: 'export interface',
  }
  function H7(t, e) {
    const r = [],
      i = []
    for (let n = 0; n < t.length; n++) (e(t[n], n, t) ? r : i).push(t[n])
    return [r, i]
  }
  const q7 = /\*?\s*@((?:no)?flow)\b/
  var X7 = (t) =>
    class extends t {
      constructor(...e) {
        super(...e), (this.flowPragma = void 0)
      }
      getScopeHandler() {
        return O7
      }
      shouldParseTypes() {
        return this.getPluginOption('flow', 'all') || this.flowPragma === 'flow'
      }
      shouldParseEnums() {
        return !!this.getPluginOption('flow', 'enums')
      }
      finishToken(e, r) {
        return (
          e !== 129 && e !== 13 && e !== 28 && this.flowPragma === void 0 && (this.flowPragma = null),
          super.finishToken(e, r)
        )
      }
      addComment(e) {
        if (this.flowPragma === void 0) {
          const r = q7.exec(e.value)
          if (r)
            if (r[1] === 'flow') this.flowPragma = 'flow'
            else if (r[1] === 'noflow') this.flowPragma = 'noflow'
            else throw new Error('Unexpected flow pragma')
        }
        return super.addComment(e)
      }
      flowParseTypeInitialiser(e) {
        const r = this.state.inType
        ;(this.state.inType = !0), this.expect(e || 14)
        const i = this.flowParseType()
        return (this.state.inType = r), i
      }
      flowParsePredicate() {
        const e = this.startNode(),
          r = this.state.startLoc
        return (
          this.next(),
          this.expectContextual(107),
          this.state.lastTokStart > r.index + 1 && this.raise(Ye.UnexpectedSpaceBetweenModuloChecks, { at: r }),
          this.eat(10)
            ? ((e.value = this.parseExpression()), this.expect(11), this.finishNode(e, 'DeclaredPredicate'))
            : this.finishNode(e, 'InferredPredicate')
        )
      }
      flowParseTypeAndPredicateInitialiser() {
        const e = this.state.inType
        ;(this.state.inType = !0), this.expect(14)
        let r = null,
          i = null
        return (
          this.match(54)
            ? ((this.state.inType = e), (i = this.flowParsePredicate()))
            : ((r = this.flowParseType()), (this.state.inType = e), this.match(54) && (i = this.flowParsePredicate())),
          [r, i]
        )
      }
      flowParseDeclareClass(e) {
        return this.next(), this.flowParseInterfaceish(e, !0), this.finishNode(e, 'DeclareClass')
      }
      flowParseDeclareFunction(e) {
        this.next()
        const r = (e.id = this.parseIdentifier()),
          i = this.startNode(),
          n = this.startNode()
        this.match(47) ? (i.typeParameters = this.flowParseTypeParameterDeclaration()) : (i.typeParameters = null),
          this.expect(10)
        const s = this.flowParseFunctionTypeParams()
        return (
          (i.params = s.params),
          (i.rest = s.rest),
          (i.this = s._this),
          this.expect(11),
          ([i.returnType, e.predicate] = this.flowParseTypeAndPredicateInitialiser()),
          (n.typeAnnotation = this.finishNode(i, 'FunctionTypeAnnotation')),
          (r.typeAnnotation = this.finishNode(n, 'TypeAnnotation')),
          this.resetEndLocation(r),
          this.semicolon(),
          this.scope.declareName(e.id.name, m7, e.id.loc.start),
          this.finishNode(e, 'DeclareFunction')
        )
      }
      flowParseDeclare(e, r) {
        if (this.match(80)) return this.flowParseDeclareClass(e)
        if (this.match(68)) return this.flowParseDeclareFunction(e)
        if (this.match(74)) return this.flowParseDeclareVariable(e)
        if (this.eatContextual(123))
          return this.match(16)
            ? this.flowParseDeclareModuleExports(e)
            : (r && this.raise(Ye.NestedDeclareModule, { at: this.state.lastTokStartLoc }),
              this.flowParseDeclareModule(e))
        if (this.isContextual(126)) return this.flowParseDeclareTypeAlias(e)
        if (this.isContextual(127)) return this.flowParseDeclareOpaqueType(e)
        if (this.isContextual(125)) return this.flowParseDeclareInterface(e)
        if (this.match(82)) return this.flowParseDeclareExportDeclaration(e, r)
        throw this.unexpected()
      }
      flowParseDeclareVariable(e) {
        return (
          this.next(),
          (e.id = this.flowParseTypeAnnotatableIdentifier(!0)),
          this.scope.declareName(e.id.name, ko, e.id.loc.start),
          this.semicolon(),
          this.finishNode(e, 'DeclareVariable')
        )
      }
      flowParseDeclareModule(e) {
        this.scope.enter(Dn), this.match(129) ? (e.id = this.parseExprAtom()) : (e.id = this.parseIdentifier())
        const r = (e.body = this.startNode()),
          i = (r.body = [])
        for (this.expect(5); !this.match(8); ) {
          let a = this.startNode()
          this.match(83)
            ? (this.next(),
              !this.isContextual(126) &&
                !this.match(87) &&
                this.raise(Ye.InvalidNonTypeImportInDeclareModule, { at: this.state.lastTokStartLoc }),
              this.parseImport(a))
            : (this.expectContextual(121, Ye.UnsupportedStatementInDeclareModule), (a = this.flowParseDeclare(a, !0))),
            i.push(a)
        }
        this.scope.exit(), this.expect(8), this.finishNode(r, 'BlockStatement')
        let n = null,
          s = !1
        return (
          i.forEach((a) => {
            W7(a)
              ? (n === 'CommonJS' && this.raise(Ye.AmbiguousDeclareModuleKind, { at: a }), (n = 'ES'))
              : a.type === 'DeclareModuleExports' &&
                (s && this.raise(Ye.DuplicateDeclareModuleExports, { at: a }),
                n === 'ES' && this.raise(Ye.AmbiguousDeclareModuleKind, { at: a }),
                (n = 'CommonJS'),
                (s = !0))
          }),
          (e.kind = n || 'CommonJS'),
          this.finishNode(e, 'DeclareModule')
        )
      }
      flowParseDeclareExportDeclaration(e, r) {
        if ((this.expect(82), this.eat(65)))
          return (
            this.match(68) || this.match(80)
              ? (e.declaration = this.flowParseDeclare(this.startNode()))
              : ((e.declaration = this.flowParseType()), this.semicolon()),
            (e.default = !0),
            this.finishNode(e, 'DeclareExportDeclaration')
          )
        if (this.match(75) || this.isLet() || ((this.isContextual(126) || this.isContextual(125)) && !r)) {
          const i = this.state.value
          throw this.raise(Ye.UnsupportedDeclareExportKind, {
            at: this.state.startLoc,
            unsupportedExportKind: i,
            suggestion: Y7[i],
          })
        }
        if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(127))
          return (
            (e.declaration = this.flowParseDeclare(this.startNode())),
            (e.default = !1),
            this.finishNode(e, 'DeclareExportDeclaration')
          )
        if (
          this.match(55) ||
          this.match(5) ||
          this.isContextual(125) ||
          this.isContextual(126) ||
          this.isContextual(127)
        )
          return (
            (e = this.parseExport(e)),
            e.type === 'ExportNamedDeclaration' &&
              ((e.type = 'ExportDeclaration'), (e.default = !1), delete e.exportKind),
            (e.type = 'Declare' + e.type),
            e
          )
        throw this.unexpected()
      }
      flowParseDeclareModuleExports(e) {
        return (
          this.next(),
          this.expectContextual(108),
          (e.typeAnnotation = this.flowParseTypeAnnotation()),
          this.semicolon(),
          this.finishNode(e, 'DeclareModuleExports')
        )
      }
      flowParseDeclareTypeAlias(e) {
        return this.next(), this.flowParseTypeAlias(e), (e.type = 'DeclareTypeAlias'), e
      }
      flowParseDeclareOpaqueType(e) {
        return this.next(), this.flowParseOpaqueType(e, !0), (e.type = 'DeclareOpaqueType'), e
      }
      flowParseDeclareInterface(e) {
        return this.next(), this.flowParseInterfaceish(e), this.finishNode(e, 'DeclareInterface')
      }
      flowParseInterfaceish(e, r = !1) {
        if (
          ((e.id = this.flowParseRestrictedIdentifier(!r, !0)),
          this.scope.declareName(e.id.name, r ? Qy : Zr, e.id.loc.start),
          this.match(47) ? (e.typeParameters = this.flowParseTypeParameterDeclaration()) : (e.typeParameters = null),
          (e.extends = []),
          (e.implements = []),
          (e.mixins = []),
          this.eat(81))
        )
          do e.extends.push(this.flowParseInterfaceExtends())
          while (!r && this.eat(12))
        if (this.isContextual(114)) {
          this.next()
          do e.mixins.push(this.flowParseInterfaceExtends())
          while (this.eat(12))
        }
        if (this.isContextual(110)) {
          this.next()
          do e.implements.push(this.flowParseInterfaceExtends())
          while (this.eat(12))
        }
        e.body = this.flowParseObjectType({
          allowStatic: r,
          allowExact: !1,
          allowSpread: !1,
          allowProto: r,
          allowInexact: !1,
        })
      }
      flowParseInterfaceExtends() {
        const e = this.startNode()
        return (
          (e.id = this.flowParseQualifiedTypeIdentifier()),
          this.match(47) ? (e.typeParameters = this.flowParseTypeParameterInstantiation()) : (e.typeParameters = null),
          this.finishNode(e, 'InterfaceExtends')
        )
      }
      flowParseInterface(e) {
        return this.flowParseInterfaceish(e), this.finishNode(e, 'InterfaceDeclaration')
      }
      checkNotUnderscore(e) {
        e === '_' && this.raise(Ye.UnexpectedReservedUnderscore, { at: this.state.startLoc })
      }
      checkReservedType(e, r, i) {
        !K7.has(e) || this.raise(i ? Ye.AssignReservedType : Ye.UnexpectedReservedType, { at: r, reservedType: e })
      }
      flowParseRestrictedIdentifier(e, r) {
        return this.checkReservedType(this.state.value, this.state.startLoc, r), this.parseIdentifier(e)
      }
      flowParseTypeAlias(e) {
        return (
          (e.id = this.flowParseRestrictedIdentifier(!1, !0)),
          this.scope.declareName(e.id.name, Zr, e.id.loc.start),
          this.match(47) ? (e.typeParameters = this.flowParseTypeParameterDeclaration()) : (e.typeParameters = null),
          (e.right = this.flowParseTypeInitialiser(29)),
          this.semicolon(),
          this.finishNode(e, 'TypeAlias')
        )
      }
      flowParseOpaqueType(e, r) {
        return (
          this.expectContextual(126),
          (e.id = this.flowParseRestrictedIdentifier(!0, !0)),
          this.scope.declareName(e.id.name, Zr, e.id.loc.start),
          this.match(47) ? (e.typeParameters = this.flowParseTypeParameterDeclaration()) : (e.typeParameters = null),
          (e.supertype = null),
          this.match(14) && (e.supertype = this.flowParseTypeInitialiser(14)),
          (e.impltype = null),
          r || (e.impltype = this.flowParseTypeInitialiser(29)),
          this.semicolon(),
          this.finishNode(e, 'OpaqueType')
        )
      }
      flowParseTypeParameter(e = !1) {
        const r = this.state.startLoc,
          i = this.startNode(),
          n = this.flowParseVariance(),
          s = this.flowParseTypeAnnotatableIdentifier()
        return (
          (i.name = s.name),
          (i.variance = n),
          (i.bound = s.typeAnnotation),
          this.match(29)
            ? (this.eat(29), (i.default = this.flowParseType()))
            : e && this.raise(Ye.MissingTypeParamDefault, { at: r }),
          this.finishNode(i, 'TypeParameter')
        )
      }
      flowParseTypeParameterDeclaration() {
        const e = this.state.inType,
          r = this.startNode()
        ;(r.params = []), (this.state.inType = !0), this.match(47) || this.match(138) ? this.next() : this.unexpected()
        let i = !1
        do {
          const n = this.flowParseTypeParameter(i)
          r.params.push(n), n.default && (i = !0), this.match(48) || this.expect(12)
        } while (!this.match(48))
        return this.expect(48), (this.state.inType = e), this.finishNode(r, 'TypeParameterDeclaration')
      }
      flowParseTypeParameterInstantiation() {
        const e = this.startNode(),
          r = this.state.inType
        ;(e.params = []), (this.state.inType = !0), this.expect(47)
        const i = this.state.noAnonFunctionType
        for (this.state.noAnonFunctionType = !1; !this.match(48); )
          e.params.push(this.flowParseType()), this.match(48) || this.expect(12)
        return (
          (this.state.noAnonFunctionType = i),
          this.expect(48),
          (this.state.inType = r),
          this.finishNode(e, 'TypeParameterInstantiation')
        )
      }
      flowParseTypeParameterInstantiationCallOrNew() {
        const e = this.startNode(),
          r = this.state.inType
        for (e.params = [], this.state.inType = !0, this.expect(47); !this.match(48); )
          e.params.push(this.flowParseTypeOrImplicitInstantiation()), this.match(48) || this.expect(12)
        return this.expect(48), (this.state.inType = r), this.finishNode(e, 'TypeParameterInstantiation')
      }
      flowParseInterfaceType() {
        const e = this.startNode()
        if ((this.expectContextual(125), (e.extends = []), this.eat(81)))
          do e.extends.push(this.flowParseInterfaceExtends())
          while (this.eat(12))
        return (
          (e.body = this.flowParseObjectType({
            allowStatic: !1,
            allowExact: !1,
            allowSpread: !1,
            allowProto: !1,
            allowInexact: !1,
          })),
          this.finishNode(e, 'InterfaceTypeAnnotation')
        )
      }
      flowParseObjectPropertyKey() {
        return this.match(130) || this.match(129) ? this.parseExprAtom() : this.parseIdentifier(!0)
      }
      flowParseObjectTypeIndexer(e, r, i) {
        return (
          (e.static = r),
          this.lookahead().type === 14
            ? ((e.id = this.flowParseObjectPropertyKey()), (e.key = this.flowParseTypeInitialiser()))
            : ((e.id = null), (e.key = this.flowParseType())),
          this.expect(3),
          (e.value = this.flowParseTypeInitialiser()),
          (e.variance = i),
          this.finishNode(e, 'ObjectTypeIndexer')
        )
      }
      flowParseObjectTypeInternalSlot(e, r) {
        return (
          (e.static = r),
          (e.id = this.flowParseObjectPropertyKey()),
          this.expect(3),
          this.expect(3),
          this.match(47) || this.match(10)
            ? ((e.method = !0),
              (e.optional = !1),
              (e.value = this.flowParseObjectTypeMethodish(this.startNodeAt(e.start, e.loc.start))))
            : ((e.method = !1), this.eat(17) && (e.optional = !0), (e.value = this.flowParseTypeInitialiser())),
          this.finishNode(e, 'ObjectTypeInternalSlot')
        )
      }
      flowParseObjectTypeMethodish(e) {
        for (
          e.params = [],
            e.rest = null,
            e.typeParameters = null,
            e.this = null,
            this.match(47) && (e.typeParameters = this.flowParseTypeParameterDeclaration()),
            this.expect(10),
            this.match(78) &&
              ((e.this = this.flowParseFunctionTypeParam(!0)), (e.this.name = null), this.match(11) || this.expect(12));
          !this.match(11) && !this.match(21);

        )
          e.params.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12)
        return (
          this.eat(21) && (e.rest = this.flowParseFunctionTypeParam(!1)),
          this.expect(11),
          (e.returnType = this.flowParseTypeInitialiser()),
          this.finishNode(e, 'FunctionTypeAnnotation')
        )
      }
      flowParseObjectTypeCallProperty(e, r) {
        const i = this.startNode()
        return (
          (e.static = r), (e.value = this.flowParseObjectTypeMethodish(i)), this.finishNode(e, 'ObjectTypeCallProperty')
        )
      }
      flowParseObjectType({ allowStatic: e, allowExact: r, allowSpread: i, allowProto: n, allowInexact: s }) {
        const a = this.state.inType
        this.state.inType = !0
        const o = this.startNode()
        ;(o.callProperties = []), (o.properties = []), (o.indexers = []), (o.internalSlots = [])
        let u,
          c,
          p = !1
        for (
          r && this.match(6) ? (this.expect(6), (u = 9), (c = !0)) : (this.expect(5), (u = 8), (c = !1)), o.exact = c;
          !this.match(u);

        ) {
          let f = !1,
            d = null,
            T = null
          const y = this.startNode()
          if (n && this.isContextual(115)) {
            const m = this.lookahead()
            m.type !== 14 && m.type !== 17 && (this.next(), (d = this.state.startLoc), (e = !1))
          }
          if (e && this.isContextual(104)) {
            const m = this.lookahead()
            m.type !== 14 && m.type !== 17 && (this.next(), (f = !0))
          }
          const b = this.flowParseVariance()
          if (this.eat(0))
            d != null && this.unexpected(d),
              this.eat(0)
                ? (b && this.unexpected(b.loc.start), o.internalSlots.push(this.flowParseObjectTypeInternalSlot(y, f)))
                : o.indexers.push(this.flowParseObjectTypeIndexer(y, f, b))
          else if (this.match(10) || this.match(47))
            d != null && this.unexpected(d),
              b && this.unexpected(b.loc.start),
              o.callProperties.push(this.flowParseObjectTypeCallProperty(y, f))
          else {
            let m = 'init'
            if (this.isContextual(98) || this.isContextual(103)) {
              const E = this.lookahead()
              _y(E.type) && ((m = this.state.value), this.next())
            }
            const S = this.flowParseObjectTypeProperty(y, f, d, b, m, i, s != null ? s : !c)
            S === null ? ((p = !0), (T = this.state.lastTokStartLoc)) : o.properties.push(S)
          }
          this.flowObjectTypeSemicolon(),
            T && !this.match(8) && !this.match(9) && this.raise(Ye.UnexpectedExplicitInexactInObject, { at: T })
        }
        this.expect(u), i && (o.inexact = p)
        const h = this.finishNode(o, 'ObjectTypeAnnotation')
        return (this.state.inType = a), h
      }
      flowParseObjectTypeProperty(e, r, i, n, s, a, o) {
        if (this.eat(21))
          return this.match(12) || this.match(13) || this.match(8) || this.match(9)
            ? (a
                ? o || this.raise(Ye.InexactInsideExact, { at: this.state.lastTokStartLoc })
                : this.raise(Ye.InexactInsideNonObject, { at: this.state.lastTokStartLoc }),
              n && this.raise(Ye.InexactVariance, { at: n }),
              null)
            : (a || this.raise(Ye.UnexpectedSpreadType, { at: this.state.lastTokStartLoc }),
              i != null && this.unexpected(i),
              n && this.raise(Ye.SpreadVariance, { at: n }),
              (e.argument = this.flowParseType()),
              this.finishNode(e, 'ObjectTypeSpreadProperty'))
        {
          ;(e.key = this.flowParseObjectPropertyKey()), (e.static = r), (e.proto = i != null), (e.kind = s)
          let u = !1
          return (
            this.match(47) || this.match(10)
              ? ((e.method = !0),
                i != null && this.unexpected(i),
                n && this.unexpected(n.loc.start),
                (e.value = this.flowParseObjectTypeMethodish(this.startNodeAt(e.start, e.loc.start))),
                (s === 'get' || s === 'set') && this.flowCheckGetterSetterParams(e),
                !a &&
                  e.key.name === 'constructor' &&
                  e.value.this &&
                  this.raise(Ye.ThisParamBannedInConstructor, { at: e.value.this }))
              : (s !== 'init' && this.unexpected(),
                (e.method = !1),
                this.eat(17) && (u = !0),
                (e.value = this.flowParseTypeInitialiser()),
                (e.variance = n)),
            (e.optional = u),
            this.finishNode(e, 'ObjectTypeProperty')
          )
        }
      }
      flowCheckGetterSetterParams(e) {
        const r = e.kind === 'get' ? 0 : 1,
          i = e.value.params.length + (e.value.rest ? 1 : 0)
        e.value.this &&
          this.raise(e.kind === 'get' ? Ye.GetterMayNotHaveThisParam : Ye.SetterMayNotHaveThisParam, {
            at: e.value.this,
          }),
          i !== r && this.raise(e.kind === 'get' ? te.BadGetterArity : te.BadSetterArity, { at: e }),
          e.kind === 'set' && e.value.rest && this.raise(te.BadSetterRestParameter, { at: e })
      }
      flowObjectTypeSemicolon() {
        !this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9) && this.unexpected()
      }
      flowParseQualifiedTypeIdentifier(e, r, i) {
        ;(e = e || this.state.start), (r = r || this.state.startLoc)
        let n = i || this.flowParseRestrictedIdentifier(!0)
        for (; this.eat(16); ) {
          const s = this.startNodeAt(e, r)
          ;(s.qualification = n),
            (s.id = this.flowParseRestrictedIdentifier(!0)),
            (n = this.finishNode(s, 'QualifiedTypeIdentifier'))
        }
        return n
      }
      flowParseGenericType(e, r, i) {
        const n = this.startNodeAt(e, r)
        return (
          (n.typeParameters = null),
          (n.id = this.flowParseQualifiedTypeIdentifier(e, r, i)),
          this.match(47) && (n.typeParameters = this.flowParseTypeParameterInstantiation()),
          this.finishNode(n, 'GenericTypeAnnotation')
        )
      }
      flowParseTypeofType() {
        const e = this.startNode()
        return this.expect(87), (e.argument = this.flowParsePrimaryType()), this.finishNode(e, 'TypeofTypeAnnotation')
      }
      flowParseTupleType() {
        const e = this.startNode()
        for (
          e.types = [], this.expect(0);
          this.state.pos < this.length && !this.match(3) && (e.types.push(this.flowParseType()), !this.match(3));

        )
          this.expect(12)
        return this.expect(3), this.finishNode(e, 'TupleTypeAnnotation')
      }
      flowParseFunctionTypeParam(e) {
        let r = null,
          i = !1,
          n = null
        const s = this.startNode(),
          a = this.lookahead(),
          o = this.state.type === 78
        return (
          a.type === 14 || a.type === 17
            ? (o && !e && this.raise(Ye.ThisParamMustBeFirst, { at: s }),
              (r = this.parseIdentifier(o)),
              this.eat(17) && ((i = !0), o && this.raise(Ye.ThisParamMayNotBeOptional, { at: s })),
              (n = this.flowParseTypeInitialiser()))
            : (n = this.flowParseType()),
          (s.name = r),
          (s.optional = i),
          (s.typeAnnotation = n),
          this.finishNode(s, 'FunctionTypeParam')
        )
      }
      reinterpretTypeAsFunctionTypeParam(e) {
        const r = this.startNodeAt(e.start, e.loc.start)
        return (r.name = null), (r.optional = !1), (r.typeAnnotation = e), this.finishNode(r, 'FunctionTypeParam')
      }
      flowParseFunctionTypeParams(e = []) {
        let r = null,
          i = null
        for (
          this.match(78) &&
          ((i = this.flowParseFunctionTypeParam(!0)), (i.name = null), this.match(11) || this.expect(12));
          !this.match(11) && !this.match(21);

        )
          e.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12)
        return this.eat(21) && (r = this.flowParseFunctionTypeParam(!1)), { params: e, rest: r, _this: i }
      }
      flowIdentToTypeAnnotation(e, r, i, n) {
        switch (n.name) {
          case 'any':
            return this.finishNode(i, 'AnyTypeAnnotation')
          case 'bool':
          case 'boolean':
            return this.finishNode(i, 'BooleanTypeAnnotation')
          case 'mixed':
            return this.finishNode(i, 'MixedTypeAnnotation')
          case 'empty':
            return this.finishNode(i, 'EmptyTypeAnnotation')
          case 'number':
            return this.finishNode(i, 'NumberTypeAnnotation')
          case 'string':
            return this.finishNode(i, 'StringTypeAnnotation')
          case 'symbol':
            return this.finishNode(i, 'SymbolTypeAnnotation')
          default:
            return this.checkNotUnderscore(n.name), this.flowParseGenericType(e, r, n)
        }
      }
      flowParsePrimaryType() {
        const e = this.state.start,
          r = this.state.startLoc,
          i = this.startNode()
        let n,
          s,
          a = !1
        const o = this.state.noAnonFunctionType
        switch (this.state.type) {
          case 5:
            return this.flowParseObjectType({
              allowStatic: !1,
              allowExact: !1,
              allowSpread: !0,
              allowProto: !1,
              allowInexact: !0,
            })
          case 6:
            return this.flowParseObjectType({
              allowStatic: !1,
              allowExact: !0,
              allowSpread: !0,
              allowProto: !1,
              allowInexact: !1,
            })
          case 0:
            return (
              (this.state.noAnonFunctionType = !1),
              (s = this.flowParseTupleType()),
              (this.state.noAnonFunctionType = o),
              s
            )
          case 47:
            return (
              (i.typeParameters = this.flowParseTypeParameterDeclaration()),
              this.expect(10),
              (n = this.flowParseFunctionTypeParams()),
              (i.params = n.params),
              (i.rest = n.rest),
              (i.this = n._this),
              this.expect(11),
              this.expect(19),
              (i.returnType = this.flowParseType()),
              this.finishNode(i, 'FunctionTypeAnnotation')
            )
          case 10:
            if ((this.next(), !this.match(11) && !this.match(21)))
              if (dt(this.state.type) || this.match(78)) {
                const u = this.lookahead().type
                a = u !== 17 && u !== 14
              } else a = !0
            if (a) {
              if (
                ((this.state.noAnonFunctionType = !1),
                (s = this.flowParseType()),
                (this.state.noAnonFunctionType = o),
                this.state.noAnonFunctionType || !(this.match(12) || (this.match(11) && this.lookahead().type === 19)))
              )
                return this.expect(11), s
              this.eat(12)
            }
            return (
              s
                ? (n = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(s)]))
                : (n = this.flowParseFunctionTypeParams()),
              (i.params = n.params),
              (i.rest = n.rest),
              (i.this = n._this),
              this.expect(11),
              this.expect(19),
              (i.returnType = this.flowParseType()),
              (i.typeParameters = null),
              this.finishNode(i, 'FunctionTypeAnnotation')
            )
          case 129:
            return this.parseLiteral(this.state.value, 'StringLiteralTypeAnnotation')
          case 85:
          case 86:
            return (i.value = this.match(85)), this.next(), this.finishNode(i, 'BooleanLiteralTypeAnnotation')
          case 53:
            if (this.state.value === '-') {
              if ((this.next(), this.match(130)))
                return this.parseLiteralAtNode(-this.state.value, 'NumberLiteralTypeAnnotation', i)
              if (this.match(131)) return this.parseLiteralAtNode(-this.state.value, 'BigIntLiteralTypeAnnotation', i)
              throw this.raise(Ye.UnexpectedSubtractionOperand, { at: this.state.startLoc })
            }
            throw this.unexpected()
          case 130:
            return this.parseLiteral(this.state.value, 'NumberLiteralTypeAnnotation')
          case 131:
            return this.parseLiteral(this.state.value, 'BigIntLiteralTypeAnnotation')
          case 88:
            return this.next(), this.finishNode(i, 'VoidTypeAnnotation')
          case 84:
            return this.next(), this.finishNode(i, 'NullLiteralTypeAnnotation')
          case 78:
            return this.next(), this.finishNode(i, 'ThisTypeAnnotation')
          case 55:
            return this.next(), this.finishNode(i, 'ExistsTypeAnnotation')
          case 87:
            return this.flowParseTypeofType()
          default:
            if (_c(this.state.type)) {
              const u = gi(this.state.type)
              return this.next(), super.createIdentifier(i, u)
            } else if (dt(this.state.type))
              return this.isContextual(125)
                ? this.flowParseInterfaceType()
                : this.flowIdentToTypeAnnotation(e, r, i, this.parseIdentifier())
        }
        throw this.unexpected()
      }
      flowParsePostfixType() {
        const e = this.state.start,
          r = this.state.startLoc
        let i = this.flowParsePrimaryType(),
          n = !1
        for (; (this.match(0) || this.match(18)) && !this.canInsertSemicolon(); ) {
          const s = this.startNodeAt(e, r),
            a = this.eat(18)
          ;(n = n || a),
            this.expect(0),
            !a && this.match(3)
              ? ((s.elementType = i), this.next(), (i = this.finishNode(s, 'ArrayTypeAnnotation')))
              : ((s.objectType = i),
                (s.indexType = this.flowParseType()),
                this.expect(3),
                n
                  ? ((s.optional = a), (i = this.finishNode(s, 'OptionalIndexedAccessType')))
                  : (i = this.finishNode(s, 'IndexedAccessType')))
        }
        return i
      }
      flowParsePrefixType() {
        const e = this.startNode()
        return this.eat(17)
          ? ((e.typeAnnotation = this.flowParsePrefixType()), this.finishNode(e, 'NullableTypeAnnotation'))
          : this.flowParsePostfixType()
      }
      flowParseAnonFunctionWithoutParens() {
        const e = this.flowParsePrefixType()
        if (!this.state.noAnonFunctionType && this.eat(19)) {
          const r = this.startNodeAt(e.start, e.loc.start)
          return (
            (r.params = [this.reinterpretTypeAsFunctionTypeParam(e)]),
            (r.rest = null),
            (r.this = null),
            (r.returnType = this.flowParseType()),
            (r.typeParameters = null),
            this.finishNode(r, 'FunctionTypeAnnotation')
          )
        }
        return e
      }
      flowParseIntersectionType() {
        const e = this.startNode()
        this.eat(45)
        const r = this.flowParseAnonFunctionWithoutParens()
        for (e.types = [r]; this.eat(45); ) e.types.push(this.flowParseAnonFunctionWithoutParens())
        return e.types.length === 1 ? r : this.finishNode(e, 'IntersectionTypeAnnotation')
      }
      flowParseUnionType() {
        const e = this.startNode()
        this.eat(43)
        const r = this.flowParseIntersectionType()
        for (e.types = [r]; this.eat(43); ) e.types.push(this.flowParseIntersectionType())
        return e.types.length === 1 ? r : this.finishNode(e, 'UnionTypeAnnotation')
      }
      flowParseType() {
        const e = this.state.inType
        this.state.inType = !0
        const r = this.flowParseUnionType()
        return (this.state.inType = e), r
      }
      flowParseTypeOrImplicitInstantiation() {
        if (this.state.type === 128 && this.state.value === '_') {
          const e = this.state.start,
            r = this.state.startLoc,
            i = this.parseIdentifier()
          return this.flowParseGenericType(e, r, i)
        } else return this.flowParseType()
      }
      flowParseTypeAnnotation() {
        const e = this.startNode()
        return (e.typeAnnotation = this.flowParseTypeInitialiser()), this.finishNode(e, 'TypeAnnotation')
      }
      flowParseTypeAnnotatableIdentifier(e) {
        const r = e ? this.parseIdentifier() : this.flowParseRestrictedIdentifier()
        return this.match(14) && ((r.typeAnnotation = this.flowParseTypeAnnotation()), this.resetEndLocation(r)), r
      }
      typeCastToParameter(e) {
        return (
          (e.expression.typeAnnotation = e.typeAnnotation),
          this.resetEndLocation(e.expression, e.typeAnnotation.loc.end),
          e.expression
        )
      }
      flowParseVariance() {
        let e = null
        return (
          this.match(53) &&
            ((e = this.startNode()),
            this.state.value === '+' ? (e.kind = 'plus') : (e.kind = 'minus'),
            this.next(),
            this.finishNode(e, 'Variance')),
          e
        )
      }
      parseFunctionBody(e, r, i = !1) {
        return r
          ? this.forwardNoArrowParamsConversionAt(e, () => super.parseFunctionBody(e, !0, i))
          : super.parseFunctionBody(e, !1, i)
      }
      parseFunctionBodyAndFinish(e, r, i = !1) {
        if (this.match(14)) {
          const n = this.startNode()
          ;([n.typeAnnotation, e.predicate] = this.flowParseTypeAndPredicateInitialiser()),
            (e.returnType = n.typeAnnotation ? this.finishNode(n, 'TypeAnnotation') : null)
        }
        super.parseFunctionBodyAndFinish(e, r, i)
      }
      parseStatement(e, r) {
        if (this.state.strict && this.isContextual(125)) {
          const n = this.lookahead()
          if (Hr(n.type)) {
            const s = this.startNode()
            return this.next(), this.flowParseInterface(s)
          }
        } else if (this.shouldParseEnums() && this.isContextual(122)) {
          const n = this.startNode()
          return this.next(), this.flowParseEnumDeclaration(n)
        }
        const i = super.parseStatement(e, r)
        return this.flowPragma === void 0 && !this.isValidDirective(i) && (this.flowPragma = null), i
      }
      parseExpressionStatement(e, r) {
        if (r.type === 'Identifier') {
          if (r.name === 'declare') {
            if (this.match(80) || dt(this.state.type) || this.match(68) || this.match(74) || this.match(82))
              return this.flowParseDeclare(e)
          } else if (dt(this.state.type)) {
            if (r.name === 'interface') return this.flowParseInterface(e)
            if (r.name === 'type') return this.flowParseTypeAlias(e)
            if (r.name === 'opaque') return this.flowParseOpaqueType(e, !1)
          }
        }
        return super.parseExpressionStatement(e, r)
      }
      shouldParseExportDeclaration() {
        const { type: e } = this.state
        return Vy(e) || (this.shouldParseEnums() && e === 122)
          ? !this.state.containsEsc
          : super.shouldParseExportDeclaration()
      }
      isExportDefaultSpecifier() {
        const { type: e } = this.state
        return Vy(e) || (this.shouldParseEnums() && e === 122)
          ? this.state.containsEsc
          : super.isExportDefaultSpecifier()
      }
      parseExportDefaultExpression() {
        if (this.shouldParseEnums() && this.isContextual(122)) {
          const e = this.startNode()
          return this.next(), this.flowParseEnumDeclaration(e)
        }
        return super.parseExportDefaultExpression()
      }
      parseConditional(e, r, i, n) {
        if (!this.match(17)) return e
        if (this.state.maybeInArrowParameters) {
          const f = this.lookaheadCharCode()
          if (f === 44 || f === 61 || f === 58 || f === 41) return this.setOptionalParametersError(n), e
        }
        this.expect(17)
        const s = this.state.clone(),
          a = this.state.noArrowAt,
          o = this.startNodeAt(r, i)
        let { consequent: u, failed: c } = this.tryParseConditionalConsequent(),
          [p, h] = this.getArrowLikeExpressions(u)
        if (c || h.length > 0) {
          const f = [...a]
          if (h.length > 0) {
            ;(this.state = s), (this.state.noArrowAt = f)
            for (let d = 0; d < h.length; d++) f.push(h[d].start)
            ;({ consequent: u, failed: c } = this.tryParseConditionalConsequent()),
              ([p, h] = this.getArrowLikeExpressions(u))
          }
          c && p.length > 1 && this.raise(Ye.AmbiguousConditionalArrow, { at: s.startLoc }),
            c &&
              p.length === 1 &&
              ((this.state = s),
              f.push(p[0].start),
              (this.state.noArrowAt = f),
              ({ consequent: u, failed: c } = this.tryParseConditionalConsequent()))
        }
        return (
          this.getArrowLikeExpressions(u, !0),
          (this.state.noArrowAt = a),
          this.expect(14),
          (o.test = e),
          (o.consequent = u),
          (o.alternate = this.forwardNoArrowParamsConversionAt(o, () => this.parseMaybeAssign(void 0, void 0))),
          this.finishNode(o, 'ConditionalExpression')
        )
      }
      tryParseConditionalConsequent() {
        this.state.noArrowParamsConversionAt.push(this.state.start)
        const e = this.parseMaybeAssignAllowIn(),
          r = !this.match(14)
        return this.state.noArrowParamsConversionAt.pop(), { consequent: e, failed: r }
      }
      getArrowLikeExpressions(e, r) {
        const i = [e],
          n = []
        for (; i.length !== 0; ) {
          const s = i.pop()
          s.type === 'ArrowFunctionExpression'
            ? (s.typeParameters || !s.returnType ? this.finishArrowValidation(s) : n.push(s), i.push(s.body))
            : s.type === 'ConditionalExpression' && (i.push(s.consequent), i.push(s.alternate))
        }
        return r
          ? (n.forEach((s) => this.finishArrowValidation(s)), [n, []])
          : H7(n, (s) => s.params.every((a) => this.isAssignable(a, !0)))
      }
      finishArrowValidation(e) {
        var r
        this.toAssignableList(e.params, (r = e.extra) == null ? void 0 : r.trailingCommaLoc, !1),
          this.scope.enter(Gr | Kc),
          super.checkParams(e, !1, !0),
          this.scope.exit()
      }
      forwardNoArrowParamsConversionAt(e, r) {
        let i
        return (
          this.state.noArrowParamsConversionAt.indexOf(e.start) !== -1
            ? (this.state.noArrowParamsConversionAt.push(this.state.start),
              (i = r()),
              this.state.noArrowParamsConversionAt.pop())
            : (i = r()),
          i
        )
      }
      parseParenItem(e, r, i) {
        if (
          ((e = super.parseParenItem(e, r, i)),
          this.eat(17) && ((e.optional = !0), this.resetEndLocation(e)),
          this.match(14))
        ) {
          const n = this.startNodeAt(r, i)
          return (
            (n.expression = e),
            (n.typeAnnotation = this.flowParseTypeAnnotation()),
            this.finishNode(n, 'TypeCastExpression')
          )
        }
        return e
      }
      assertModuleNodeAllowed(e) {
        ;(e.type === 'ImportDeclaration' && (e.importKind === 'type' || e.importKind === 'typeof')) ||
          (e.type === 'ExportNamedDeclaration' && e.exportKind === 'type') ||
          (e.type === 'ExportAllDeclaration' && e.exportKind === 'type') ||
          super.assertModuleNodeAllowed(e)
      }
      parseExport(e) {
        const r = super.parseExport(e)
        return (
          (r.type === 'ExportNamedDeclaration' || r.type === 'ExportAllDeclaration') &&
            (r.exportKind = r.exportKind || 'value'),
          r
        )
      }
      parseExportDeclaration(e) {
        if (this.isContextual(126)) {
          e.exportKind = 'type'
          const r = this.startNode()
          return (
            this.next(),
            this.match(5)
              ? ((e.specifiers = this.parseExportSpecifiers(!0)), this.parseExportFrom(e), null)
              : this.flowParseTypeAlias(r)
          )
        } else if (this.isContextual(127)) {
          e.exportKind = 'type'
          const r = this.startNode()
          return this.next(), this.flowParseOpaqueType(r, !1)
        } else if (this.isContextual(125)) {
          e.exportKind = 'type'
          const r = this.startNode()
          return this.next(), this.flowParseInterface(r)
        } else if (this.shouldParseEnums() && this.isContextual(122)) {
          e.exportKind = 'value'
          const r = this.startNode()
          return this.next(), this.flowParseEnumDeclaration(r)
        } else return super.parseExportDeclaration(e)
      }
      eatExportStar(e) {
        return super.eatExportStar(...arguments)
          ? !0
          : this.isContextual(126) && this.lookahead().type === 55
          ? ((e.exportKind = 'type'), this.next(), this.next(), !0)
          : !1
      }
      maybeParseExportNamespaceSpecifier(e) {
        const { startLoc: r } = this.state,
          i = super.maybeParseExportNamespaceSpecifier(e)
        return i && e.exportKind === 'type' && this.unexpected(r), i
      }
      parseClassId(e, r, i) {
        super.parseClassId(e, r, i), this.match(47) && (e.typeParameters = this.flowParseTypeParameterDeclaration())
      }
      parseClassMember(e, r, i) {
        const { startLoc: n } = this.state
        if (this.isContextual(121)) {
          if (this.parseClassMemberFromModifier(e, r)) return
          r.declare = !0
        }
        super.parseClassMember(e, r, i),
          r.declare &&
            (r.type !== 'ClassProperty' && r.type !== 'ClassPrivateProperty' && r.type !== 'PropertyDefinition'
              ? this.raise(Ye.DeclareClassElement, { at: n })
              : r.value && this.raise(Ye.DeclareClassFieldInitializer, { at: r.value }))
      }
      isIterator(e) {
        return e === 'iterator' || e === 'asyncIterator'
      }
      readIterator() {
        const e = super.readWord1(),
          r = '@@' + e
        ;(!this.isIterator(e) || !this.state.inType) &&
          this.raise(te.InvalidIdentifier, { at: this.state.curPosition(), identifierName: r }),
          this.finishToken(128, r)
      }
      getTokenFromCode(e) {
        const r = this.input.charCodeAt(this.state.pos + 1)
        return e === 123 && r === 124
          ? this.finishOp(6, 2)
          : this.state.inType && (e === 62 || e === 60)
          ? this.finishOp(e === 62 ? 48 : 47, 1)
          : this.state.inType && e === 63
          ? r === 46
            ? this.finishOp(18, 2)
            : this.finishOp(17, 1)
          : o7(e, r, this.input.charCodeAt(this.state.pos + 2))
          ? ((this.state.pos += 2), this.readIterator())
          : super.getTokenFromCode(e)
      }
      isAssignable(e, r) {
        return e.type === 'TypeCastExpression' ? this.isAssignable(e.expression, r) : super.isAssignable(e, r)
      }
      toAssignable(e, r = !1) {
        !r &&
          e.type === 'AssignmentExpression' &&
          e.left.type === 'TypeCastExpression' &&
          (e.left = this.typeCastToParameter(e.left)),
          super.toAssignable(...arguments)
      }
      toAssignableList(e, r, i) {
        for (let n = 0; n < e.length; n++) {
          const s = e[n]
          ;(s == null ? void 0 : s.type) === 'TypeCastExpression' && (e[n] = this.typeCastToParameter(s))
        }
        super.toAssignableList(e, r, i)
      }
      toReferencedList(e, r) {
        for (let n = 0; n < e.length; n++) {
          var i
          const s = e[n]
          s &&
            s.type === 'TypeCastExpression' &&
            !((i = s.extra) != null && i.parenthesized) &&
            (e.length > 1 || !r) &&
            this.raise(Ye.TypeCastInPattern, { at: s.typeAnnotation })
        }
        return e
      }
      parseArrayLike(e, r, i, n) {
        const s = super.parseArrayLike(e, r, i, n)
        return r && !this.state.maybeInArrowParameters && this.toReferencedList(s.elements), s
      }
      isValidLVal(e, ...r) {
        return e === 'TypeCastExpression' || super.isValidLVal(e, ...r)
      }
      parseClassProperty(e) {
        return this.match(14) && (e.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(e)
      }
      parseClassPrivateProperty(e) {
        return this.match(14) && (e.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(e)
      }
      isClassMethod() {
        return this.match(47) || super.isClassMethod()
      }
      isClassProperty() {
        return this.match(14) || super.isClassProperty()
      }
      isNonstaticConstructor(e) {
        return !this.match(14) && super.isNonstaticConstructor(e)
      }
      pushClassMethod(e, r, i, n, s, a) {
        if (
          (r.variance && this.unexpected(r.variance.loc.start),
          delete r.variance,
          this.match(47) && (r.typeParameters = this.flowParseTypeParameterDeclaration()),
          super.pushClassMethod(e, r, i, n, s, a),
          r.params && s)
        ) {
          const o = r.params
          o.length > 0 && this.isThisParam(o[0]) && this.raise(Ye.ThisParamBannedInConstructor, { at: r })
        } else if (r.type === 'MethodDefinition' && s && r.value.params) {
          const o = r.value.params
          o.length > 0 && this.isThisParam(o[0]) && this.raise(Ye.ThisParamBannedInConstructor, { at: r })
        }
      }
      pushClassPrivateMethod(e, r, i, n) {
        r.variance && this.unexpected(r.variance.loc.start),
          delete r.variance,
          this.match(47) && (r.typeParameters = this.flowParseTypeParameterDeclaration()),
          super.pushClassPrivateMethod(e, r, i, n)
      }
      parseClassSuper(e) {
        if (
          (super.parseClassSuper(e),
          e.superClass && this.match(47) && (e.superTypeParameters = this.flowParseTypeParameterInstantiation()),
          this.isContextual(110))
        ) {
          this.next()
          const r = (e.implements = [])
          do {
            const i = this.startNode()
            ;(i.id = this.flowParseRestrictedIdentifier(!0)),
              this.match(47)
                ? (i.typeParameters = this.flowParseTypeParameterInstantiation())
                : (i.typeParameters = null),
              r.push(this.finishNode(i, 'ClassImplements'))
          } while (this.eat(12))
        }
      }
      checkGetterSetterParams(e) {
        super.checkGetterSetterParams(e)
        const r = this.getObjectOrClassMethodParams(e)
        if (r.length > 0) {
          const i = r[0]
          this.isThisParam(i) && e.kind === 'get'
            ? this.raise(Ye.GetterMayNotHaveThisParam, { at: i })
            : this.isThisParam(i) && this.raise(Ye.SetterMayNotHaveThisParam, { at: i })
        }
      }
      parsePropertyNamePrefixOperator(e) {
        e.variance = this.flowParseVariance()
      }
      parseObjPropValue(e, r, i, n, s, a, o, u) {
        e.variance && this.unexpected(e.variance.loc.start), delete e.variance
        let c
        this.match(47) && !o && ((c = this.flowParseTypeParameterDeclaration()), this.match(10) || this.unexpected()),
          super.parseObjPropValue(e, r, i, n, s, a, o, u),
          c && ((e.value || e).typeParameters = c)
      }
      parseAssignableListItemTypes(e) {
        return (
          this.eat(17) &&
            (e.type !== 'Identifier' && this.raise(Ye.PatternIsOptional, { at: e }),
            this.isThisParam(e) && this.raise(Ye.ThisParamMayNotBeOptional, { at: e }),
            (e.optional = !0)),
          this.match(14)
            ? (e.typeAnnotation = this.flowParseTypeAnnotation())
            : this.isThisParam(e) && this.raise(Ye.ThisParamAnnotationRequired, { at: e }),
          this.match(29) && this.isThisParam(e) && this.raise(Ye.ThisParamNoDefault, { at: e }),
          this.resetEndLocation(e),
          e
        )
      }
      parseMaybeDefault(e, r, i) {
        const n = super.parseMaybeDefault(e, r, i)
        return (
          n.type === 'AssignmentPattern' &&
            n.typeAnnotation &&
            n.right.start < n.typeAnnotation.start &&
            this.raise(Ye.TypeBeforeInitializer, { at: n.typeAnnotation }),
          n
        )
      }
      shouldParseDefaultImport(e) {
        return op(e) ? p0(this.state.type) : super.shouldParseDefaultImport(e)
      }
      parseImportSpecifierLocal(e, r, i) {
        ;(r.local = op(e) ? this.flowParseRestrictedIdentifier(!0, !0) : this.parseIdentifier()),
          e.specifiers.push(this.finishImportSpecifier(r, i))
      }
      maybeParseDefaultImportSpecifier(e) {
        e.importKind = 'value'
        let r = null
        if ((this.match(87) ? (r = 'typeof') : this.isContextual(126) && (r = 'type'), r)) {
          const i = this.lookahead(),
            { type: n } = i
          r === 'type' && n === 55 && this.unexpected(null, i.type),
            (p0(n) || n === 5 || n === 55) && (this.next(), (e.importKind = r))
        }
        return super.maybeParseDefaultImportSpecifier(e)
      }
      parseImportSpecifier(e, r, i, n) {
        const s = e.imported
        let a = null
        s.type === 'Identifier' && (s.name === 'type' ? (a = 'type') : s.name === 'typeof' && (a = 'typeof'))
        let o = !1
        if (this.isContextual(93) && !this.isLookaheadContextual('as')) {
          const c = this.parseIdentifier(!0)
          a !== null && !Hr(this.state.type)
            ? ((e.imported = c), (e.importKind = a), (e.local = Qr(c)))
            : ((e.imported = s), (e.importKind = null), (e.local = this.parseIdentifier()))
        } else {
          if (a !== null && Hr(this.state.type)) (e.imported = this.parseIdentifier(!0)), (e.importKind = a)
          else {
            if (r) throw this.raise(te.ImportBindingIsString, { at: e, importName: s.value })
            ;(e.imported = s), (e.importKind = null)
          }
          this.eatContextual(93) ? (e.local = this.parseIdentifier()) : ((o = !0), (e.local = Qr(e.imported)))
        }
        const u = op(e)
        return (
          i && u && this.raise(Ye.ImportTypeShorthandOnlyInPureImport, { at: e }),
          (i || u) && this.checkReservedType(e.local.name, e.local.loc.start, !0),
          o && !i && !u && this.checkReservedWord(e.local.name, e.loc.start, !0, !0),
          this.finishImportSpecifier(e, 'ImportSpecifier')
        )
      }
      parseBindingAtom() {
        switch (this.state.type) {
          case 78:
            return this.parseIdentifier(!0)
          default:
            return super.parseBindingAtom()
        }
      }
      parseFunctionParams(e, r) {
        const i = e.kind
        i !== 'get' && i !== 'set' && this.match(47) && (e.typeParameters = this.flowParseTypeParameterDeclaration()),
          super.parseFunctionParams(e, r)
      }
      parseVarId(e, r) {
        super.parseVarId(e, r),
          this.match(14) && ((e.id.typeAnnotation = this.flowParseTypeAnnotation()), this.resetEndLocation(e.id))
      }
      parseAsyncArrowFromCallExpression(e, r) {
        if (this.match(14)) {
          const i = this.state.noAnonFunctionType
          ;(this.state.noAnonFunctionType = !0),
            (e.returnType = this.flowParseTypeAnnotation()),
            (this.state.noAnonFunctionType = i)
        }
        return super.parseAsyncArrowFromCallExpression(e, r)
      }
      shouldParseAsyncArrow() {
        return this.match(14) || super.shouldParseAsyncArrow()
      }
      parseMaybeAssign(e, r) {
        var i
        let n = null,
          s
        if (this.hasPlugin('jsx') && (this.match(138) || this.match(47))) {
          if (((n = this.state.clone()), (s = this.tryParse(() => super.parseMaybeAssign(e, r), n)), !s.error))
            return s.node
          const { context: u } = this.state,
            c = u[u.length - 1]
          ;(c === gt.j_oTag || c === gt.j_expr) && u.pop()
        }
        if (((i = s) != null && i.error) || this.match(47)) {
          var a, o
          n = n || this.state.clone()
          let u
          const c = this.tryParse((h) => {
            var f
            u = this.flowParseTypeParameterDeclaration()
            const d = this.forwardNoArrowParamsConversionAt(u, () => {
              const y = super.parseMaybeAssign(e, r)
              return this.resetStartLocationFromNode(y, u), y
            })
            ;(f = d.extra) != null && f.parenthesized && h()
            const T = this.maybeUnwrapTypeCastExpression(d)
            return (
              T.type !== 'ArrowFunctionExpression' && h(),
              (T.typeParameters = u),
              this.resetStartLocationFromNode(T, u),
              d
            )
          }, n)
          let p = null
          if (c.node && this.maybeUnwrapTypeCastExpression(c.node).type === 'ArrowFunctionExpression') {
            if (!c.error && !c.aborted)
              return c.node.async && this.raise(Ye.UnexpectedTypeParameterBeforeAsyncArrowFunction, { at: u }), c.node
            p = c.node
          }
          if ((a = s) != null && a.node) return (this.state = s.failState), s.node
          if (p) return (this.state = c.failState), p
          throw (o = s) != null && o.thrown
            ? s.error
            : c.thrown
            ? c.error
            : this.raise(Ye.UnexpectedTokenAfterTypeParameter, { at: u })
        }
        return super.parseMaybeAssign(e, r)
      }
      parseArrow(e) {
        if (this.match(14)) {
          const r = this.tryParse(() => {
            const i = this.state.noAnonFunctionType
            this.state.noAnonFunctionType = !0
            const n = this.startNode()
            return (
              ([n.typeAnnotation, e.predicate] = this.flowParseTypeAndPredicateInitialiser()),
              (this.state.noAnonFunctionType = i),
              this.canInsertSemicolon() && this.unexpected(),
              this.match(19) || this.unexpected(),
              n
            )
          })
          if (r.thrown) return null
          r.error && (this.state = r.failState),
            (e.returnType = r.node.typeAnnotation ? this.finishNode(r.node, 'TypeAnnotation') : null)
        }
        return super.parseArrow(e)
      }
      shouldParseArrow(e) {
        return this.match(14) || super.shouldParseArrow(e)
      }
      setArrowFunctionParameters(e, r) {
        this.state.noArrowParamsConversionAt.indexOf(e.start) !== -1
          ? (e.params = r)
          : super.setArrowFunctionParameters(e, r)
      }
      checkParams(e, r, i) {
        if (!(i && this.state.noArrowParamsConversionAt.indexOf(e.start) !== -1)) {
          for (let n = 0; n < e.params.length; n++)
            this.isThisParam(e.params[n]) && n > 0 && this.raise(Ye.ThisParamMustBeFirst, { at: e.params[n] })
          return super.checkParams(...arguments)
        }
      }
      parseParenAndDistinguishExpression(e) {
        return super.parseParenAndDistinguishExpression(e && this.state.noArrowAt.indexOf(this.state.start) === -1)
      }
      parseSubscripts(e, r, i, n) {
        if (e.type === 'Identifier' && e.name === 'async' && this.state.noArrowAt.indexOf(r) !== -1) {
          this.next()
          const s = this.startNodeAt(r, i)
          ;(s.callee = e),
            (s.arguments = this.parseCallExpressionArguments(11, !1)),
            (e = this.finishNode(s, 'CallExpression'))
        } else if (e.type === 'Identifier' && e.name === 'async' && this.match(47)) {
          const s = this.state.clone(),
            a = this.tryParse((u) => this.parseAsyncArrowWithTypeParameters(r, i) || u(), s)
          if (!a.error && !a.aborted) return a.node
          const o = this.tryParse(() => super.parseSubscripts(e, r, i, n), s)
          if (o.node && !o.error) return o.node
          if (a.node) return (this.state = a.failState), a.node
          if (o.node) return (this.state = o.failState), o.node
          throw a.error || o.error
        }
        return super.parseSubscripts(e, r, i, n)
      }
      parseSubscript(e, r, i, n, s) {
        if (this.match(18) && this.isLookaheadToken_lt()) {
          if (((s.optionalChainMember = !0), n)) return (s.stop = !0), e
          this.next()
          const a = this.startNodeAt(r, i)
          return (
            (a.callee = e),
            (a.typeArguments = this.flowParseTypeParameterInstantiation()),
            this.expect(10),
            (a.arguments = this.parseCallExpressionArguments(11, !1)),
            (a.optional = !0),
            this.finishCallExpression(a, !0)
          )
        } else if (!n && this.shouldParseTypes() && this.match(47)) {
          const a = this.startNodeAt(r, i)
          a.callee = e
          const o = this.tryParse(
            () => (
              (a.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew()),
              this.expect(10),
              (a.arguments = this.parseCallExpressionArguments(11, !1)),
              s.optionalChainMember && (a.optional = !1),
              this.finishCallExpression(a, s.optionalChainMember)
            )
          )
          if (o.node) return o.error && (this.state = o.failState), o.node
        }
        return super.parseSubscript(e, r, i, n, s)
      }
      parseNewCallee(e) {
        super.parseNewCallee(e)
        let r = null
        this.shouldParseTypes() &&
          this.match(47) &&
          (r = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node),
          (e.typeArguments = r)
      }
      parseAsyncArrowWithTypeParameters(e, r) {
        const i = this.startNodeAt(e, r)
        if ((this.parseFunctionParams(i), !!this.parseArrow(i))) return this.parseArrowExpression(i, void 0, !0)
      }
      readToken_mult_modulo(e) {
        const r = this.input.charCodeAt(this.state.pos + 1)
        if (e === 42 && r === 47 && this.state.hasFlowComment) {
          ;(this.state.hasFlowComment = !1), (this.state.pos += 2), this.nextToken()
          return
        }
        super.readToken_mult_modulo(e)
      }
      readToken_pipe_amp(e) {
        const r = this.input.charCodeAt(this.state.pos + 1)
        if (e === 124 && r === 125) {
          this.finishOp(9, 2)
          return
        }
        super.readToken_pipe_amp(e)
      }
      parseTopLevel(e, r) {
        const i = super.parseTopLevel(e, r)
        return this.state.hasFlowComment && this.raise(Ye.UnterminatedFlowComment, { at: this.state.curPosition() }), i
      }
      skipBlockComment() {
        if (this.hasPlugin('flowComments') && this.skipFlowComment()) {
          if (this.state.hasFlowComment) throw this.raise(Ye.NestedFlowComment, { at: this.state.startLoc })
          this.hasFlowCommentCompletion(), (this.state.pos += this.skipFlowComment()), (this.state.hasFlowComment = !0)
          return
        }
        if (this.state.hasFlowComment) {
          const e = this.input.indexOf('*-/', this.state.pos + 2)
          if (e === -1) throw this.raise(te.UnterminatedComment, { at: this.state.curPosition() })
          this.state.pos = e + 2 + 3
          return
        }
        return super.skipBlockComment()
      }
      skipFlowComment() {
        const { pos: e } = this.state
        let r = 2
        for (; [32, 9].includes(this.input.charCodeAt(e + r)); ) r++
        const i = this.input.charCodeAt(r + e),
          n = this.input.charCodeAt(r + e + 1)
        return i === 58 && n === 58
          ? r + 2
          : this.input.slice(r + e, r + e + 12) === 'flow-include'
          ? r + 12
          : i === 58 && n !== 58
          ? r
          : !1
      }
      hasFlowCommentCompletion() {
        if (this.input.indexOf('*/', this.state.pos) === -1)
          throw this.raise(te.UnterminatedComment, { at: this.state.curPosition() })
      }
      flowEnumErrorBooleanMemberNotInitialized(e, { enumName: r, memberName: i }) {
        this.raise(Ye.EnumBooleanMemberNotInitialized, { at: e, memberName: i, enumName: r })
      }
      flowEnumErrorInvalidMemberInitializer(e, r) {
        return this.raise(
          r.explicitType
            ? r.explicitType === 'symbol'
              ? Ye.EnumInvalidMemberInitializerSymbolType
              : Ye.EnumInvalidMemberInitializerPrimaryType
            : Ye.EnumInvalidMemberInitializerUnknownType,
          Object.assign({ at: e }, r)
        )
      }
      flowEnumErrorNumberMemberNotInitialized(e, { enumName: r, memberName: i }) {
        this.raise(Ye.EnumNumberMemberNotInitialized, { at: e, enumName: r, memberName: i })
      }
      flowEnumErrorStringMemberInconsistentlyInitailized(e, { enumName: r }) {
        this.raise(Ye.EnumStringMemberInconsistentlyInitailized, { at: e, enumName: r })
      }
      flowEnumMemberInit() {
        const e = this.state.startLoc,
          r = () => this.match(12) || this.match(8)
        switch (this.state.type) {
          case 130: {
            const i = this.parseNumericLiteral(this.state.value)
            return r() ? { type: 'number', loc: i.loc.start, value: i } : { type: 'invalid', loc: e }
          }
          case 129: {
            const i = this.parseStringLiteral(this.state.value)
            return r() ? { type: 'string', loc: i.loc.start, value: i } : { type: 'invalid', loc: e }
          }
          case 85:
          case 86: {
            const i = this.parseBooleanLiteral(this.match(85))
            return r() ? { type: 'boolean', loc: i.loc.start, value: i } : { type: 'invalid', loc: e }
          }
          default:
            return { type: 'invalid', loc: e }
        }
      }
      flowEnumMemberRaw() {
        const e = this.state.startLoc,
          r = this.parseIdentifier(!0),
          i = this.eat(29) ? this.flowEnumMemberInit() : { type: 'none', loc: e }
        return { id: r, init: i }
      }
      flowEnumCheckExplicitTypeMismatch(e, r, i) {
        const { explicitType: n } = r
        n !== null && n !== i && this.flowEnumErrorInvalidMemberInitializer(e, r)
      }
      flowEnumMembers({ enumName: e, explicitType: r }) {
        const i = new Set(),
          n = { booleanMembers: [], numberMembers: [], stringMembers: [], defaultedMembers: [] }
        let s = !1
        for (; !this.match(8); ) {
          if (this.eat(21)) {
            s = !0
            break
          }
          const a = this.startNode(),
            { id: o, init: u } = this.flowEnumMemberRaw(),
            c = o.name
          if (c === '') continue
          ;/^[a-z]/.test(c) &&
            this.raise(Ye.EnumInvalidMemberName, {
              at: o,
              memberName: c,
              suggestion: c[0].toUpperCase() + c.slice(1),
              enumName: e,
            }),
            i.has(c) && this.raise(Ye.EnumDuplicateMemberName, { at: o, memberName: c, enumName: e }),
            i.add(c)
          const p = { enumName: e, explicitType: r, memberName: c }
          switch (((a.id = o), u.type)) {
            case 'boolean': {
              this.flowEnumCheckExplicitTypeMismatch(u.loc, p, 'boolean'),
                (a.init = u.value),
                n.booleanMembers.push(this.finishNode(a, 'EnumBooleanMember'))
              break
            }
            case 'number': {
              this.flowEnumCheckExplicitTypeMismatch(u.loc, p, 'number'),
                (a.init = u.value),
                n.numberMembers.push(this.finishNode(a, 'EnumNumberMember'))
              break
            }
            case 'string': {
              this.flowEnumCheckExplicitTypeMismatch(u.loc, p, 'string'),
                (a.init = u.value),
                n.stringMembers.push(this.finishNode(a, 'EnumStringMember'))
              break
            }
            case 'invalid':
              throw this.flowEnumErrorInvalidMemberInitializer(u.loc, p)
            case 'none':
              switch (r) {
                case 'boolean':
                  this.flowEnumErrorBooleanMemberNotInitialized(u.loc, p)
                  break
                case 'number':
                  this.flowEnumErrorNumberMemberNotInitialized(u.loc, p)
                  break
                default:
                  n.defaultedMembers.push(this.finishNode(a, 'EnumDefaultedMember'))
              }
          }
          this.match(8) || this.expect(12)
        }
        return { members: n, hasUnknownMembers: s }
      }
      flowEnumStringMembers(e, r, { enumName: i }) {
        if (e.length === 0) return r
        if (r.length === 0) return e
        if (r.length > e.length) {
          for (const n of e) this.flowEnumErrorStringMemberInconsistentlyInitailized(n, { enumName: i })
          return r
        } else {
          for (const n of r) this.flowEnumErrorStringMemberInconsistentlyInitailized(n, { enumName: i })
          return e
        }
      }
      flowEnumParseExplicitType({ enumName: e }) {
        if (!this.eatContextual(101)) return null
        if (!dt(this.state.type))
          throw this.raise(Ye.EnumInvalidExplicitTypeUnknownSupplied, { at: this.state.startLoc, enumName: e })
        const { value: r } = this.state
        return (
          this.next(),
          r !== 'boolean' &&
            r !== 'number' &&
            r !== 'string' &&
            r !== 'symbol' &&
            this.raise(Ye.EnumInvalidExplicitType, { at: this.state.startLoc, enumName: e, invalidEnumType: r }),
          r
        )
      }
      flowEnumBody(e, r) {
        const i = r.name,
          n = r.loc.start,
          s = this.flowEnumParseExplicitType({ enumName: i })
        this.expect(5)
        const { members: a, hasUnknownMembers: o } = this.flowEnumMembers({ enumName: i, explicitType: s })
        switch (((e.hasUnknownMembers = o), s)) {
          case 'boolean':
            return (
              (e.explicitType = !0),
              (e.members = a.booleanMembers),
              this.expect(8),
              this.finishNode(e, 'EnumBooleanBody')
            )
          case 'number':
            return (
              (e.explicitType = !0), (e.members = a.numberMembers), this.expect(8), this.finishNode(e, 'EnumNumberBody')
            )
          case 'string':
            return (
              (e.explicitType = !0),
              (e.members = this.flowEnumStringMembers(a.stringMembers, a.defaultedMembers, { enumName: i })),
              this.expect(8),
              this.finishNode(e, 'EnumStringBody')
            )
          case 'symbol':
            return (e.members = a.defaultedMembers), this.expect(8), this.finishNode(e, 'EnumSymbolBody')
          default: {
            const u = () => ((e.members = []), this.expect(8), this.finishNode(e, 'EnumStringBody'))
            e.explicitType = !1
            const c = a.booleanMembers.length,
              p = a.numberMembers.length,
              h = a.stringMembers.length,
              f = a.defaultedMembers.length
            if (!c && !p && !h && !f) return u()
            if (!c && !p)
              return (
                (e.members = this.flowEnumStringMembers(a.stringMembers, a.defaultedMembers, { enumName: i })),
                this.expect(8),
                this.finishNode(e, 'EnumStringBody')
              )
            if (!p && !h && c >= f) {
              for (const d of a.defaultedMembers)
                this.flowEnumErrorBooleanMemberNotInitialized(d.loc.start, { enumName: i, memberName: d.id.name })
              return (e.members = a.booleanMembers), this.expect(8), this.finishNode(e, 'EnumBooleanBody')
            } else if (!c && !h && p >= f) {
              for (const d of a.defaultedMembers)
                this.flowEnumErrorNumberMemberNotInitialized(d.loc.start, { enumName: i, memberName: d.id.name })
              return (e.members = a.numberMembers), this.expect(8), this.finishNode(e, 'EnumNumberBody')
            } else return this.raise(Ye.EnumInconsistentMemberValues, { at: n, enumName: i }), u()
          }
        }
      }
      flowParseEnumDeclaration(e) {
        const r = this.parseIdentifier()
        return (e.id = r), (e.body = this.flowEnumBody(this.startNode(), r)), this.finishNode(e, 'EnumDeclaration')
      }
      isLookaheadToken_lt() {
        const e = this.nextTokenStart()
        if (this.input.charCodeAt(e) === 60) {
          const r = this.input.charCodeAt(e + 1)
          return r !== 60 && r !== 61
        }
        return !1
      }
      maybeUnwrapTypeCastExpression(e) {
        return e.type === 'TypeCastExpression' ? e.expression : e
      }
    }
  const G7 = {
      __proto__: null,
      quot: '"',
      amp: '&',
      apos: "'",
      lt: '<',
      gt: '>',
      nbsp: '\xA0',
      iexcl: '\xA1',
      cent: '\xA2',
      pound: '\xA3',
      curren: '\xA4',
      yen: '\xA5',
      brvbar: '\xA6',
      sect: '\xA7',
      uml: '\xA8',
      copy: '\xA9',
      ordf: '\xAA',
      laquo: '\xAB',
      not: '\xAC',
      shy: '\xAD',
      reg: '\xAE',
      macr: '\xAF',
      deg: '\xB0',
      plusmn: '\xB1',
      sup2: '\xB2',
      sup3: '\xB3',
      acute: '\xB4',
      micro: '\xB5',
      para: '\xB6',
      middot: '\xB7',
      cedil: '\xB8',
      sup1: '\xB9',
      ordm: '\xBA',
      raquo: '\xBB',
      frac14: '\xBC',
      frac12: '\xBD',
      frac34: '\xBE',
      iquest: '\xBF',
      Agrave: '\xC0',
      Aacute: '\xC1',
      Acirc: '\xC2',
      Atilde: '\xC3',
      Auml: '\xC4',
      Aring: '\xC5',
      AElig: '\xC6',
      Ccedil: '\xC7',
      Egrave: '\xC8',
      Eacute: '\xC9',
      Ecirc: '\xCA',
      Euml: '\xCB',
      Igrave: '\xCC',
      Iacute: '\xCD',
      Icirc: '\xCE',
      Iuml: '\xCF',
      ETH: '\xD0',
      Ntilde: '\xD1',
      Ograve: '\xD2',
      Oacute: '\xD3',
      Ocirc: '\xD4',
      Otilde: '\xD5',
      Ouml: '\xD6',
      times: '\xD7',
      Oslash: '\xD8',
      Ugrave: '\xD9',
      Uacute: '\xDA',
      Ucirc: '\xDB',
      Uuml: '\xDC',
      Yacute: '\xDD',
      THORN: '\xDE',
      szlig: '\xDF',
      agrave: '\xE0',
      aacute: '\xE1',
      acirc: '\xE2',
      atilde: '\xE3',
      auml: '\xE4',
      aring: '\xE5',
      aelig: '\xE6',
      ccedil: '\xE7',
      egrave: '\xE8',
      eacute: '\xE9',
      ecirc: '\xEA',
      euml: '\xEB',
      igrave: '\xEC',
      iacute: '\xED',
      icirc: '\xEE',
      iuml: '\xEF',
      eth: '\xF0',
      ntilde: '\xF1',
      ograve: '\xF2',
      oacute: '\xF3',
      ocirc: '\xF4',
      otilde: '\xF5',
      ouml: '\xF6',
      divide: '\xF7',
      oslash: '\xF8',
      ugrave: '\xF9',
      uacute: '\xFA',
      ucirc: '\xFB',
      uuml: '\xFC',
      yacute: '\xFD',
      thorn: '\xFE',
      yuml: '\xFF',
      OElig: '\u0152',
      oelig: '\u0153',
      Scaron: '\u0160',
      scaron: '\u0161',
      Yuml: '\u0178',
      fnof: '\u0192',
      circ: '\u02C6',
      tilde: '\u02DC',
      Alpha: '\u0391',
      Beta: '\u0392',
      Gamma: '\u0393',
      Delta: '\u0394',
      Epsilon: '\u0395',
      Zeta: '\u0396',
      Eta: '\u0397',
      Theta: '\u0398',
      Iota: '\u0399',
      Kappa: '\u039A',
      Lambda: '\u039B',
      Mu: '\u039C',
      Nu: '\u039D',
      Xi: '\u039E',
      Omicron: '\u039F',
      Pi: '\u03A0',
      Rho: '\u03A1',
      Sigma: '\u03A3',
      Tau: '\u03A4',
      Upsilon: '\u03A5',
      Phi: '\u03A6',
      Chi: '\u03A7',
      Psi: '\u03A8',
      Omega: '\u03A9',
      alpha: '\u03B1',
      beta: '\u03B2',
      gamma: '\u03B3',
      delta: '\u03B4',
      epsilon: '\u03B5',
      zeta: '\u03B6',
      eta: '\u03B7',
      theta: '\u03B8',
      iota: '\u03B9',
      kappa: '\u03BA',
      lambda: '\u03BB',
      mu: '\u03BC',
      nu: '\u03BD',
      xi: '\u03BE',
      omicron: '\u03BF',
      pi: '\u03C0',
      rho: '\u03C1',
      sigmaf: '\u03C2',
      sigma: '\u03C3',
      tau: '\u03C4',
      upsilon: '\u03C5',
      phi: '\u03C6',
      chi: '\u03C7',
      psi: '\u03C8',
      omega: '\u03C9',
      thetasym: '\u03D1',
      upsih: '\u03D2',
      piv: '\u03D6',
      ensp: '\u2002',
      emsp: '\u2003',
      thinsp: '\u2009',
      zwnj: '\u200C',
      zwj: '\u200D',
      lrm: '\u200E',
      rlm: '\u200F',
      ndash: '\u2013',
      mdash: '\u2014',
      lsquo: '\u2018',
      rsquo: '\u2019',
      sbquo: '\u201A',
      ldquo: '\u201C',
      rdquo: '\u201D',
      bdquo: '\u201E',
      dagger: '\u2020',
      Dagger: '\u2021',
      bull: '\u2022',
      hellip: '\u2026',
      permil: '\u2030',
      prime: '\u2032',
      Prime: '\u2033',
      lsaquo: '\u2039',
      rsaquo: '\u203A',
      oline: '\u203E',
      frasl: '\u2044',
      euro: '\u20AC',
      image: '\u2111',
      weierp: '\u2118',
      real: '\u211C',
      trade: '\u2122',
      alefsym: '\u2135',
      larr: '\u2190',
      uarr: '\u2191',
      rarr: '\u2192',
      darr: '\u2193',
      harr: '\u2194',
      crarr: '\u21B5',
      lArr: '\u21D0',
      uArr: '\u21D1',
      rArr: '\u21D2',
      dArr: '\u21D3',
      hArr: '\u21D4',
      forall: '\u2200',
      part: '\u2202',
      exist: '\u2203',
      empty: '\u2205',
      nabla: '\u2207',
      isin: '\u2208',
      notin: '\u2209',
      ni: '\u220B',
      prod: '\u220F',
      sum: '\u2211',
      minus: '\u2212',
      lowast: '\u2217',
      radic: '\u221A',
      prop: '\u221D',
      infin: '\u221E',
      ang: '\u2220',
      and: '\u2227',
      or: '\u2228',
      cap: '\u2229',
      cup: '\u222A',
      int: '\u222B',
      there4: '\u2234',
      sim: '\u223C',
      cong: '\u2245',
      asymp: '\u2248',
      ne: '\u2260',
      equiv: '\u2261',
      le: '\u2264',
      ge: '\u2265',
      sub: '\u2282',
      sup: '\u2283',
      nsub: '\u2284',
      sube: '\u2286',
      supe: '\u2287',
      oplus: '\u2295',
      otimes: '\u2297',
      perp: '\u22A5',
      sdot: '\u22C5',
      lceil: '\u2308',
      rceil: '\u2309',
      lfloor: '\u230A',
      rfloor: '\u230B',
      lang: '\u2329',
      rang: '\u232A',
      loz: '\u25CA',
      spades: '\u2660',
      clubs: '\u2663',
      hearts: '\u2665',
      diams: '\u2666',
    },
    sn = Wr`jsx`((t) => ({
      AttributeIsEmpty: t('JSX attributes must only be assigned a non-empty expression.'),
      MissingClosingTagElement: t(({ openingTagName: e }) => `Expected corresponding JSX closing tag for <${e}>.`),
      MissingClosingTagFragment: t('Expected corresponding JSX closing tag for <>.'),
      UnexpectedSequenceExpression: t(
        'Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?'
      ),
      UnexpectedToken: t(
        ({ unexpected: e, HTMLEntity: r }) => `Unexpected token \`${e}\`. Did you mean \`${r}\` or \`{'${e}'}\`?`
      ),
      UnsupportedJsxValue: t('JSX value should be either an expression or a quoted JSX text.'),
      UnterminatedJsxContent: t('Unterminated JSX contents.'),
      UnwrappedAdjacentJSXElements: t(
        'Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?'
      ),
    }))
  function Si(t) {
    return t ? t.type === 'JSXOpeningFragment' || t.type === 'JSXClosingFragment' : !1
  }
  function Fn(t) {
    if (t.type === 'JSXIdentifier') return t.name
    if (t.type === 'JSXNamespacedName') return t.namespace.name + ':' + t.name.name
    if (t.type === 'JSXMemberExpression') return Fn(t.object) + '.' + Fn(t.property)
    throw new Error('Node had unexpected type: ' + t.type)
  }
  var J7 = (t) =>
    class extends t {
      jsxReadToken() {
        let e = '',
          r = this.state.pos
        for (;;) {
          if (this.state.pos >= this.length) throw this.raise(sn.UnterminatedJsxContent, { at: this.state.startLoc })
          const i = this.input.charCodeAt(this.state.pos)
          switch (i) {
            case 60:
            case 123:
              return this.state.pos === this.state.start
                ? i === 60 && this.state.canStartJSXElement
                  ? (++this.state.pos, this.finishToken(138))
                  : super.getTokenFromCode(i)
                : ((e += this.input.slice(r, this.state.pos)), this.finishToken(137, e))
            case 38:
              ;(e += this.input.slice(r, this.state.pos)), (e += this.jsxReadEntity()), (r = this.state.pos)
              break
            case 62:
            case 125:
            default:
              nn(i)
                ? ((e += this.input.slice(r, this.state.pos)), (e += this.jsxReadNewLine(!0)), (r = this.state.pos))
                : ++this.state.pos
          }
        }
      }
      jsxReadNewLine(e) {
        const r = this.input.charCodeAt(this.state.pos)
        let i
        return (
          ++this.state.pos,
          r === 13 && this.input.charCodeAt(this.state.pos) === 10
            ? (++this.state.pos,
              (i = e
                ? `
`
                : `\r
`))
            : (i = String.fromCharCode(r)),
          ++this.state.curLine,
          (this.state.lineStart = this.state.pos),
          i
        )
      }
      jsxReadString(e) {
        let r = '',
          i = ++this.state.pos
        for (;;) {
          if (this.state.pos >= this.length) throw this.raise(te.UnterminatedString, { at: this.state.startLoc })
          const n = this.input.charCodeAt(this.state.pos)
          if (n === e) break
          n === 38
            ? ((r += this.input.slice(i, this.state.pos)), (r += this.jsxReadEntity()), (i = this.state.pos))
            : nn(n)
            ? ((r += this.input.slice(i, this.state.pos)), (r += this.jsxReadNewLine(!1)), (i = this.state.pos))
            : ++this.state.pos
        }
        return (r += this.input.slice(i, this.state.pos++)), this.finishToken(129, r)
      }
      jsxReadEntity() {
        const e = ++this.state.pos
        if (this.codePointAtPos(this.state.pos) === 35) {
          ++this.state.pos
          let r = 10
          this.codePointAtPos(this.state.pos) === 120 && ((r = 16), ++this.state.pos)
          const i = this.readInt(r, void 0, !1, 'bail')
          if (i !== null && this.codePointAtPos(this.state.pos) === 59) return ++this.state.pos, String.fromCodePoint(i)
        } else {
          let r = 0,
            i = !1
          for (; r++ < 10 && this.state.pos < this.length && !(i = this.codePointAtPos(this.state.pos) == 59); )
            ++this.state.pos
          if (i) {
            const n = this.input.slice(e, this.state.pos),
              s = G7[n]
            if ((++this.state.pos, s)) return s
          }
        }
        return (this.state.pos = e), '&'
      }
      jsxReadWord() {
        let e
        const r = this.state.pos
        do e = this.input.charCodeAt(++this.state.pos)
        while (On(e) || e === 45)
        return this.finishToken(136, this.input.slice(r, this.state.pos))
      }
      jsxParseIdentifier() {
        const e = this.startNode()
        return (
          this.match(136)
            ? (e.name = this.state.value)
            : _c(this.state.type)
            ? (e.name = gi(this.state.type))
            : this.unexpected(),
          this.next(),
          this.finishNode(e, 'JSXIdentifier')
        )
      }
      jsxParseNamespacedName() {
        const e = this.state.start,
          r = this.state.startLoc,
          i = this.jsxParseIdentifier()
        if (!this.eat(14)) return i
        const n = this.startNodeAt(e, r)
        return (n.namespace = i), (n.name = this.jsxParseIdentifier()), this.finishNode(n, 'JSXNamespacedName')
      }
      jsxParseElementName() {
        const e = this.state.start,
          r = this.state.startLoc
        let i = this.jsxParseNamespacedName()
        if (i.type === 'JSXNamespacedName') return i
        for (; this.eat(16); ) {
          const n = this.startNodeAt(e, r)
          ;(n.object = i), (n.property = this.jsxParseIdentifier()), (i = this.finishNode(n, 'JSXMemberExpression'))
        }
        return i
      }
      jsxParseAttributeValue() {
        let e
        switch (this.state.type) {
          case 5:
            return (
              (e = this.startNode()),
              this.setContext(gt.brace),
              this.next(),
              (e = this.jsxParseExpressionContainer(e, gt.j_oTag)),
              e.expression.type === 'JSXEmptyExpression' && this.raise(sn.AttributeIsEmpty, { at: e }),
              e
            )
          case 138:
          case 129:
            return this.parseExprAtom()
          default:
            throw this.raise(sn.UnsupportedJsxValue, { at: this.state.startLoc })
        }
      }
      jsxParseEmptyExpression() {
        const e = this.startNodeAt(this.state.lastTokEndLoc.index, this.state.lastTokEndLoc)
        return this.finishNodeAt(e, 'JSXEmptyExpression', this.state.startLoc)
      }
      jsxParseSpreadChild(e) {
        return (
          this.next(),
          (e.expression = this.parseExpression()),
          this.setContext(gt.j_oTag),
          (this.state.canStartJSXElement = !0),
          this.expect(8),
          this.finishNode(e, 'JSXSpreadChild')
        )
      }
      jsxParseExpressionContainer(e, r) {
        if (this.match(8)) e.expression = this.jsxParseEmptyExpression()
        else {
          const i = this.parseExpression()
          e.expression = i
        }
        return (
          this.setContext(r),
          (this.state.canStartJSXElement = !0),
          this.expect(8),
          this.finishNode(e, 'JSXExpressionContainer')
        )
      }
      jsxParseAttribute() {
        const e = this.startNode()
        return this.match(5)
          ? (this.setContext(gt.brace),
            this.next(),
            this.expect(21),
            (e.argument = this.parseMaybeAssignAllowIn()),
            this.setContext(gt.j_oTag),
            (this.state.canStartJSXElement = !0),
            this.expect(8),
            this.finishNode(e, 'JSXSpreadAttribute'))
          : ((e.name = this.jsxParseNamespacedName()),
            (e.value = this.eat(29) ? this.jsxParseAttributeValue() : null),
            this.finishNode(e, 'JSXAttribute'))
      }
      jsxParseOpeningElementAt(e, r) {
        const i = this.startNodeAt(e, r)
        return this.eat(139)
          ? this.finishNode(i, 'JSXOpeningFragment')
          : ((i.name = this.jsxParseElementName()), this.jsxParseOpeningElementAfterName(i))
      }
      jsxParseOpeningElementAfterName(e) {
        const r = []
        for (; !this.match(56) && !this.match(139); ) r.push(this.jsxParseAttribute())
        return (
          (e.attributes = r), (e.selfClosing = this.eat(56)), this.expect(139), this.finishNode(e, 'JSXOpeningElement')
        )
      }
      jsxParseClosingElementAt(e, r) {
        const i = this.startNodeAt(e, r)
        return this.eat(139)
          ? this.finishNode(i, 'JSXClosingFragment')
          : ((i.name = this.jsxParseElementName()), this.expect(139), this.finishNode(i, 'JSXClosingElement'))
      }
      jsxParseElementAt(e, r) {
        const i = this.startNodeAt(e, r),
          n = [],
          s = this.jsxParseOpeningElementAt(e, r)
        let a = null
        if (!s.selfClosing) {
          e: for (;;)
            switch (this.state.type) {
              case 138:
                if (((e = this.state.start), (r = this.state.startLoc), this.next(), this.eat(56))) {
                  a = this.jsxParseClosingElementAt(e, r)
                  break e
                }
                n.push(this.jsxParseElementAt(e, r))
                break
              case 137:
                n.push(this.parseExprAtom())
                break
              case 5: {
                const o = this.startNode()
                this.setContext(gt.brace),
                  this.next(),
                  this.match(21)
                    ? n.push(this.jsxParseSpreadChild(o))
                    : n.push(this.jsxParseExpressionContainer(o, gt.j_expr))
                break
              }
              default:
                throw this.unexpected()
            }
          Si(s) && !Si(a) && a !== null
            ? this.raise(sn.MissingClosingTagFragment, { at: a })
            : !Si(s) && Si(a)
            ? this.raise(sn.MissingClosingTagElement, { at: a, openingTagName: Fn(s.name) })
            : !Si(s) &&
              !Si(a) &&
              Fn(a.name) !== Fn(s.name) &&
              this.raise(sn.MissingClosingTagElement, { at: a, openingTagName: Fn(s.name) })
        }
        if (
          (Si(s)
            ? ((i.openingFragment = s), (i.closingFragment = a))
            : ((i.openingElement = s), (i.closingElement = a)),
          (i.children = n),
          this.match(47))
        )
          throw this.raise(sn.UnwrappedAdjacentJSXElements, { at: this.state.startLoc })
        return Si(s) ? this.finishNode(i, 'JSXFragment') : this.finishNode(i, 'JSXElement')
      }
      jsxParseElement() {
        const e = this.state.start,
          r = this.state.startLoc
        return this.next(), this.jsxParseElementAt(e, r)
      }
      setContext(e) {
        const { context: r } = this.state
        r[r.length - 1] = e
      }
      parseExprAtom(e) {
        return this.match(137)
          ? this.parseLiteral(this.state.value, 'JSXText')
          : this.match(138)
          ? this.jsxParseElement()
          : this.match(47) && this.input.charCodeAt(this.state.pos) !== 33
          ? (this.replaceToken(138), this.jsxParseElement())
          : super.parseExprAtom(e)
      }
      skipSpace() {
        this.curContext().preserveSpace || super.skipSpace()
      }
      getTokenFromCode(e) {
        const r = this.curContext()
        if (r === gt.j_expr) return this.jsxReadToken()
        if (r === gt.j_oTag || r === gt.j_cTag) {
          if (Xr(e)) return this.jsxReadWord()
          if (e === 62) return ++this.state.pos, this.finishToken(139)
          if ((e === 34 || e === 39) && r === gt.j_oTag) return this.jsxReadString(e)
        }
        return e === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33
          ? (++this.state.pos, this.finishToken(138))
          : super.getTokenFromCode(e)
      }
      updateContext(e) {
        const { context: r, type: i } = this.state
        if (i === 56 && e === 138) r.splice(-2, 2, gt.j_cTag), (this.state.canStartJSXElement = !1)
        else if (i === 138) r.push(gt.j_oTag)
        else if (i === 139) {
          const n = r[r.length - 1]
          ;(n === gt.j_oTag && e === 56) || n === gt.j_cTag
            ? (r.pop(), (this.state.canStartJSXElement = r[r.length - 1] === gt.j_expr))
            : (this.setContext(gt.j_expr), (this.state.canStartJSXElement = !0))
        } else this.state.canStartJSXElement = KV(i)
      }
    }
  class Z7 extends ip {
    constructor(...e) {
      super(...e),
        (this.types = new Set()),
        (this.enums = new Set()),
        (this.constEnums = new Set()),
        (this.classes = new Set()),
        (this.exportOnlyBindings = new Set())
    }
  }
  class Q7 extends np {
    createScope(e) {
      return new Z7(e)
    }
    declareName(e, r, i) {
      const n = this.currentScope()
      if (r & qc) {
        this.maybeExportDefined(n, e), n.exportOnlyBindings.add(e)
        return
      }
      super.declareName(...arguments),
        r & Bn &&
          (r & Jr || (this.checkRedeclarationInScope(n, e, r, i), this.maybeExportDefined(n, e)), n.types.add(e)),
        r & Yc && n.enums.add(e),
        r & Hc && n.constEnums.add(e),
        r & Io && n.classes.add(e)
    }
    isRedeclaredInScope(e, r, i) {
      if (e.enums.has(r)) {
        if (i & Yc) {
          const n = !!(i & Hc),
            s = e.constEnums.has(r)
          return n !== s
        }
        return !0
      }
      return i & Io && e.classes.has(r)
        ? e.lexical.has(r)
          ? !!(i & Jr)
          : !1
        : i & Bn && e.types.has(r)
        ? !0
        : super.isRedeclaredInScope(...arguments)
    }
    checkLocalExport(e) {
      const r = this.scopeStack[0],
        { name: i } = e
      !r.types.has(i) && !r.exportOnlyBindings.has(i) && super.checkLocalExport(e)
    }
  }
  const eU = (t, e) => Object.hasOwnProperty.call(t, e) && t[e]
  function tU(t) {
    if (t == null) throw new Error(`Unexpected ${t} value.`)
    return t
  }
  function f0(t) {
    if (!t) throw new Error('Assert fail')
  }
  function rU(t) {
    return jc(t) || ZV(t)
  }
  const _e = Wr`typescript`((t) => ({
    AbstractMethodHasImplementation: t(
      ({ methodName: e }) => `Method '${e}' cannot have an implementation because it is marked abstract.`
    ),
    AbstractPropertyHasInitializer: t(
      ({ propertyName: e }) => `Property '${e}' cannot have an initializer because it is marked abstract.`
    ),
    AccesorCannotDeclareThisParameter: t("'get' and 'set' accessors cannot declare 'this' parameters."),
    AccesorCannotHaveTypeParameters: t('An accessor cannot have type parameters.'),
    CannotFindName: t(({ name: e }) => `Cannot find name '${e}'.`),
    ClassMethodHasDeclare: t("Class methods cannot have the 'declare' modifier."),
    ClassMethodHasReadonly: t("Class methods cannot have the 'readonly' modifier."),
    ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: t(
      "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference."
    ),
    ConstructorHasTypeParameters: t('Type parameters cannot appear on a constructor declaration.'),
    DeclareAccessor: t(({ kind: e }) => `'declare' is not allowed in ${e}ters.`),
    DeclareClassFieldHasInitializer: t('Initializers are not allowed in ambient contexts.'),
    DeclareFunctionHasImplementation: t('An implementation cannot be declared in ambient contexts.'),
    DuplicateAccessibilityModifier: t(({ modifier: e }) => 'Accessibility modifier already seen.'),
    DuplicateModifier: t(({ modifier: e }) => `Duplicate modifier: '${e}'.`),
    EmptyHeritageClauseType: t(({ token: e }) => `'${e}' list cannot be empty.`),
    EmptyTypeArguments: t('Type argument list cannot be empty.'),
    EmptyTypeParameters: t('Type parameter list cannot be empty.'),
    ExpectedAmbientAfterExportDeclare: t("'export declare' must be followed by an ambient declaration."),
    ImportAliasHasImportType: t("An import alias can not use 'import type'."),
    IncompatibleModifiers: t(({ modifiers: e }) => `'${e[0]}' modifier cannot be used with '${e[1]}' modifier.`),
    IndexSignatureHasAbstract: t("Index signatures cannot have the 'abstract' modifier."),
    IndexSignatureHasAccessibility: t(
      ({ modifier: e }) => `Index signatures cannot have an accessibility modifier ('${e}').`
    ),
    IndexSignatureHasDeclare: t("Index signatures cannot have the 'declare' modifier."),
    IndexSignatureHasOverride: t("'override' modifier cannot appear on an index signature."),
    IndexSignatureHasStatic: t("Index signatures cannot have the 'static' modifier."),
    InitializerNotAllowedInAmbientContext: t('Initializers are not allowed in ambient contexts.'),
    InvalidModifierOnTypeMember: t(({ modifier: e }) => `'${e}' modifier cannot appear on a type member.`),
    InvalidModifierOnTypeParameter: t(({ modifier: e }) => `'${e}' modifier cannot appear on a type parameter.`),
    InvalidModifierOnTypeParameterPositions: t(
      ({ modifier: e }) => `'${e}' modifier can only appear on a type parameter of a class, interface or type alias.`
    ),
    InvalidModifiersOrder: t(({ orderedModifiers: e }) => `'${e[0]}' modifier must precede '${e[1]}' modifier.`),
    InvalidTupleMemberLabel: t('Tuple members must be labeled with a simple identifier.'),
    MissingInterfaceName: t("'interface' declarations must be followed by an identifier."),
    MixedLabeledAndUnlabeledElements: t('Tuple members must all have names or all not have names.'),
    NonAbstractClassHasAbstractMethod: t('Abstract methods can only appear within an abstract class.'),
    NonClassMethodPropertyHasAbstractModifer: t(
      "'abstract' modifier can only appear on a class, method, or property declaration."
    ),
    OptionalTypeBeforeRequired: t('A required element cannot follow an optional element.'),
    OverrideNotInSubClass: t(
      "This member cannot have an 'override' modifier because its containing class does not extend another class."
    ),
    PatternIsOptional: t('A binding pattern parameter cannot be optional in an implementation signature.'),
    PrivateElementHasAbstract: t("Private elements cannot have the 'abstract' modifier."),
    PrivateElementHasAccessibility: t(
      ({ modifier: e }) => `Private elements cannot have an accessibility modifier ('${e}').`
    ),
    ReadonlyForMethodSignature: t("'readonly' modifier can only appear on a property declaration or index signature."),
    ReservedArrowTypeParam: t(
      'This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.'
    ),
    ReservedTypeAssertion: t(
      'This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.'
    ),
    SetAccesorCannotHaveOptionalParameter: t("A 'set' accessor cannot have an optional parameter."),
    SetAccesorCannotHaveRestParameter: t("A 'set' accessor cannot have rest parameter."),
    SetAccesorCannotHaveReturnType: t("A 'set' accessor cannot have a return type annotation."),
    SingleTypeParameterWithoutTrailingComma: t(
      ({ typeParameterName: e }) => `Single type parameter ${e} should have a trailing comma. Example usage: <${e},>.`
    ),
    StaticBlockCannotHaveModifier: t('Static class blocks cannot have any modifier.'),
    TypeAnnotationAfterAssign: t(
      'Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.'
    ),
    TypeImportCannotSpecifyDefaultAndNamed: t(
      'A type-only import can specify a default import or named bindings, but not both.'
    ),
    TypeModifierIsUsedInTypeExports: t(
      "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement."
    ),
    TypeModifierIsUsedInTypeImports: t(
      "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement."
    ),
    UnexpectedParameterModifier: t('A parameter property is only allowed in a constructor implementation.'),
    UnexpectedReadonly: t("'readonly' type modifier is only permitted on array and tuple literal types."),
    UnexpectedTypeAnnotation: t('Did not expect a type annotation here.'),
    UnexpectedTypeCastInParameter: t('Unexpected type cast in parameter position.'),
    UnsupportedImportTypeArgument: t('Argument in a type import must be a string literal.'),
    UnsupportedParameterPropertyKind: t('A parameter property may not be declared using a binding pattern.'),
    UnsupportedSignatureParameterKind: t(
      ({ type: e }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${e}.`
    ),
  }))
  function iU(t) {
    switch (t) {
      case 'any':
        return 'TSAnyKeyword'
      case 'boolean':
        return 'TSBooleanKeyword'
      case 'bigint':
        return 'TSBigIntKeyword'
      case 'never':
        return 'TSNeverKeyword'
      case 'number':
        return 'TSNumberKeyword'
      case 'object':
        return 'TSObjectKeyword'
      case 'string':
        return 'TSStringKeyword'
      case 'symbol':
        return 'TSSymbolKeyword'
      case 'undefined':
        return 'TSUndefinedKeyword'
      case 'unknown':
        return 'TSUnknownKeyword'
      default:
        return
    }
  }
  function h0(t) {
    return t === 'private' || t === 'public' || t === 'protected'
  }
  function nU(t) {
    return t === 'in' || t === 'out'
  }
  var sU = (t) =>
    class extends t {
      getScopeHandler() {
        return Q7
      }
      tsIsIdentifier() {
        return dt(this.state.type)
      }
      tsTokenCanFollowModifier() {
        return (
          (this.match(0) ||
            this.match(5) ||
            this.match(55) ||
            this.match(21) ||
            this.match(134) ||
            this.isLiteralPropertyName()) &&
          !this.hasPrecedingLineBreak()
        )
      }
      tsNextTokenCanFollowModifier() {
        return this.next(), this.tsTokenCanFollowModifier()
      }
      tsParseModifier(e, r) {
        if (!dt(this.state.type) && this.state.type !== 58) return
        const i = this.state.value
        if (e.indexOf(i) !== -1) {
          if (r && this.tsIsStartOfStaticBlocks()) return
          if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) return i
        }
      }
      tsParseModifiers({
        modified: e,
        allowedModifiers: r,
        disallowedModifiers: i,
        stopOnStartOfClassStaticBlock: n,
        errorTemplate: s = _e.InvalidModifierOnTypeMember,
      }) {
        const a = (u, c, p, h) => {
            c === p && e[h] && this.raise(_e.InvalidModifiersOrder, { at: u, orderedModifiers: [p, h] })
          },
          o = (u, c, p, h) => {
            ;((e[p] && c === h) || (e[h] && c === p)) &&
              this.raise(_e.IncompatibleModifiers, { at: u, modifiers: [p, h] })
          }
        for (;;) {
          const { startLoc: u } = this.state,
            c = this.tsParseModifier(r.concat(i != null ? i : []), n)
          if (!c) break
          h0(c)
            ? e.accessibility
              ? this.raise(_e.DuplicateAccessibilityModifier, { at: u, modifier: c })
              : (a(u, c, c, 'override'), a(u, c, c, 'static'), a(u, c, c, 'readonly'), (e.accessibility = c))
            : nU(c)
            ? (e[c] && this.raise(_e.DuplicateModifier, { at: u, modifier: c }), (e[c] = !0), a(u, c, 'in', 'out'))
            : (Object.hasOwnProperty.call(e, c)
                ? this.raise(_e.DuplicateModifier, { at: u, modifier: c })
                : (a(u, c, 'static', 'readonly'),
                  a(u, c, 'static', 'override'),
                  a(u, c, 'override', 'readonly'),
                  a(u, c, 'abstract', 'override'),
                  o(u, c, 'declare', 'override'),
                  o(u, c, 'static', 'abstract')),
              (e[c] = !0)),
            i != null && i.includes(c) && this.raise(s, { at: u, modifier: c })
        }
      }
      tsIsListTerminator(e) {
        switch (e) {
          case 'EnumMembers':
          case 'TypeMembers':
            return this.match(8)
          case 'HeritageClauseElement':
            return this.match(5)
          case 'TupleElementTypes':
            return this.match(3)
          case 'TypeParametersOrArguments':
            return this.match(48)
        }
        throw new Error('Unreachable')
      }
      tsParseList(e, r) {
        const i = []
        for (; !this.tsIsListTerminator(e); ) i.push(r())
        return i
      }
      tsParseDelimitedList(e, r, i) {
        return tU(this.tsParseDelimitedListWorker(e, r, !0, i))
      }
      tsParseDelimitedListWorker(e, r, i, n) {
        const s = []
        let a = -1
        for (; !this.tsIsListTerminator(e); ) {
          a = -1
          const o = r()
          if (o == null) return
          if ((s.push(o), this.eat(12))) {
            a = this.state.lastTokStart
            continue
          }
          if (this.tsIsListTerminator(e)) break
          i && this.expect(12)
          return
        }
        return n && (n.value = a), s
      }
      tsParseBracketedList(e, r, i, n, s) {
        n || (i ? this.expect(0) : this.expect(47))
        const a = this.tsParseDelimitedList(e, r, s)
        return i ? this.expect(3) : this.expect(48), a
      }
      tsParseImportType() {
        const e = this.startNode()
        return (
          this.expect(83),
          this.expect(10),
          this.match(129) || this.raise(_e.UnsupportedImportTypeArgument, { at: this.state.startLoc }),
          (e.argument = this.parseExprAtom()),
          this.expect(11),
          this.eat(16) && (e.qualifier = this.tsParseEntityName()),
          this.match(47) && (e.typeParameters = this.tsParseTypeArguments()),
          this.finishNode(e, 'TSImportType')
        )
      }
      tsParseEntityName(e = !0) {
        let r = this.parseIdentifier(e)
        for (; this.eat(16); ) {
          const i = this.startNodeAtNode(r)
          ;(i.left = r), (i.right = this.parseIdentifier(e)), (r = this.finishNode(i, 'TSQualifiedName'))
        }
        return r
      }
      tsParseTypeReference() {
        const e = this.startNode()
        return (
          (e.typeName = this.tsParseEntityName()),
          !this.hasPrecedingLineBreak() && this.match(47) && (e.typeParameters = this.tsParseTypeArguments()),
          this.finishNode(e, 'TSTypeReference')
        )
      }
      tsParseThisTypePredicate(e) {
        this.next()
        const r = this.startNodeAtNode(e)
        return (
          (r.parameterName = e),
          (r.typeAnnotation = this.tsParseTypeAnnotation(!1)),
          (r.asserts = !1),
          this.finishNode(r, 'TSTypePredicate')
        )
      }
      tsParseThisTypeNode() {
        const e = this.startNode()
        return this.next(), this.finishNode(e, 'TSThisType')
      }
      tsParseTypeQuery() {
        const e = this.startNode()
        return (
          this.expect(87),
          this.match(83) ? (e.exprName = this.tsParseImportType()) : (e.exprName = this.tsParseEntityName()),
          !this.hasPrecedingLineBreak() && this.match(47) && (e.typeParameters = this.tsParseTypeArguments()),
          this.finishNode(e, 'TSTypeQuery')
        )
      }
      tsParseInOutModifiers(e) {
        this.tsParseModifiers({
          modified: e,
          allowedModifiers: ['in', 'out'],
          disallowedModifiers: ['public', 'private', 'protected', 'readonly', 'declare', 'abstract', 'override'],
          errorTemplate: _e.InvalidModifierOnTypeParameter,
        })
      }
      tsParseNoneModifiers(e) {
        this.tsParseModifiers({
          modified: e,
          allowedModifiers: [],
          disallowedModifiers: ['in', 'out'],
          errorTemplate: _e.InvalidModifierOnTypeParameterPositions,
        })
      }
      tsParseTypeParameter(e = this.tsParseNoneModifiers.bind(this)) {
        const r = this.startNode()
        return (
          e(r),
          (r.name = this.tsParseTypeParameterName()),
          (r.constraint = this.tsEatThenParseType(81)),
          (r.default = this.tsEatThenParseType(29)),
          this.finishNode(r, 'TSTypeParameter')
        )
      }
      tsTryParseTypeParameters(e) {
        if (this.match(47)) return this.tsParseTypeParameters(e)
      }
      tsParseTypeParameters(e) {
        const r = this.startNode()
        this.match(47) || this.match(138) ? this.next() : this.unexpected()
        const i = { value: -1 }
        return (
          (r.params = this.tsParseBracketedList(
            'TypeParametersOrArguments',
            this.tsParseTypeParameter.bind(this, e),
            !1,
            !0,
            i
          )),
          r.params.length === 0 && this.raise(_e.EmptyTypeParameters, { at: r }),
          i.value !== -1 && this.addExtra(r, 'trailingComma', i.value),
          this.finishNode(r, 'TSTypeParameterDeclaration')
        )
      }
      tsTryNextParseConstantContext() {
        if (this.lookahead().type !== 75) return null
        this.next()
        const e = this.tsParseTypeReference()
        return e.typeParameters && this.raise(_e.CannotFindName, { at: e.typeName, name: 'const' }), e
      }
      tsFillSignature(e, r) {
        const i = e === 19,
          n = 'parameters',
          s = 'typeAnnotation'
        ;(r.typeParameters = this.tsTryParseTypeParameters()),
          this.expect(10),
          (r[n] = this.tsParseBindingListForSignature()),
          i
            ? (r[s] = this.tsParseTypeOrTypePredicateAnnotation(e))
            : this.match(e) && (r[s] = this.tsParseTypeOrTypePredicateAnnotation(e))
      }
      tsParseBindingListForSignature() {
        return this.parseBindingList(11, 41).map(
          (e) => (
            e.type !== 'Identifier' &&
              e.type !== 'RestElement' &&
              e.type !== 'ObjectPattern' &&
              e.type !== 'ArrayPattern' &&
              this.raise(_e.UnsupportedSignatureParameterKind, { at: e, type: e.type }),
            e
          )
        )
      }
      tsParseTypeMemberSemicolon() {
        !this.eat(12) && !this.isLineTerminator() && this.expect(13)
      }
      tsParseSignatureMember(e, r) {
        return this.tsFillSignature(14, r), this.tsParseTypeMemberSemicolon(), this.finishNode(r, e)
      }
      tsIsUnambiguouslyIndexSignature() {
        return this.next(), dt(this.state.type) ? (this.next(), this.match(14)) : !1
      }
      tsTryParseIndexSignature(e) {
        if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) return
        this.expect(0)
        const r = this.parseIdentifier()
        ;(r.typeAnnotation = this.tsParseTypeAnnotation()),
          this.resetEndLocation(r),
          this.expect(3),
          (e.parameters = [r])
        const i = this.tsTryParseTypeAnnotation()
        return i && (e.typeAnnotation = i), this.tsParseTypeMemberSemicolon(), this.finishNode(e, 'TSIndexSignature')
      }
      tsParsePropertyOrMethodSignature(e, r) {
        this.eat(17) && (e.optional = !0)
        const i = e
        if (this.match(10) || this.match(47)) {
          r && this.raise(_e.ReadonlyForMethodSignature, { at: e })
          const n = i
          n.kind && this.match(47) && this.raise(_e.AccesorCannotHaveTypeParameters, { at: this.state.curPosition() }),
            this.tsFillSignature(14, n),
            this.tsParseTypeMemberSemicolon()
          const s = 'parameters',
            a = 'typeAnnotation'
          if (n.kind === 'get')
            n[s].length > 0 &&
              (this.raise(te.BadGetterArity, { at: this.state.curPosition() }),
              this.isThisParam(n[s][0]) &&
                this.raise(_e.AccesorCannotDeclareThisParameter, { at: this.state.curPosition() }))
          else if (n.kind === 'set') {
            if (n[s].length !== 1) this.raise(te.BadSetterArity, { at: this.state.curPosition() })
            else {
              const o = n[s][0]
              this.isThisParam(o) && this.raise(_e.AccesorCannotDeclareThisParameter, { at: this.state.curPosition() }),
                o.type === 'Identifier' &&
                  o.optional &&
                  this.raise(_e.SetAccesorCannotHaveOptionalParameter, { at: this.state.curPosition() }),
                o.type === 'RestElement' &&
                  this.raise(_e.SetAccesorCannotHaveRestParameter, { at: this.state.curPosition() })
            }
            n[a] && this.raise(_e.SetAccesorCannotHaveReturnType, { at: n[a] })
          } else n.kind = 'method'
          return this.finishNode(n, 'TSMethodSignature')
        } else {
          const n = i
          r && (n.readonly = !0)
          const s = this.tsTryParseTypeAnnotation()
          return (
            s && (n.typeAnnotation = s), this.tsParseTypeMemberSemicolon(), this.finishNode(n, 'TSPropertySignature')
          )
        }
      }
      tsParseTypeMember() {
        const e = this.startNode()
        if (this.match(10) || this.match(47)) return this.tsParseSignatureMember('TSCallSignatureDeclaration', e)
        if (this.match(77)) {
          const i = this.startNode()
          return (
            this.next(),
            this.match(10) || this.match(47)
              ? this.tsParseSignatureMember('TSConstructSignatureDeclaration', e)
              : ((e.key = this.createIdentifier(i, 'new')), this.tsParsePropertyOrMethodSignature(e, !1))
          )
        }
        this.tsParseModifiers({
          modified: e,
          allowedModifiers: ['readonly'],
          disallowedModifiers: ['declare', 'abstract', 'private', 'protected', 'public', 'static', 'override'],
        })
        const r = this.tsTryParseIndexSignature(e)
        return (
          r ||
          (this.parsePropertyName(e),
          !e.computed &&
            e.key.type === 'Identifier' &&
            (e.key.name === 'get' || e.key.name === 'set') &&
            this.tsTokenCanFollowModifier() &&
            ((e.kind = e.key.name), this.parsePropertyName(e)),
          this.tsParsePropertyOrMethodSignature(e, !!e.readonly))
        )
      }
      tsParseTypeLiteral() {
        const e = this.startNode()
        return (e.members = this.tsParseObjectTypeMembers()), this.finishNode(e, 'TSTypeLiteral')
      }
      tsParseObjectTypeMembers() {
        this.expect(5)
        const e = this.tsParseList('TypeMembers', this.tsParseTypeMember.bind(this))
        return this.expect(8), e
      }
      tsIsStartOfMappedType() {
        return (
          this.next(),
          this.eat(53)
            ? this.isContextual(118)
            : (this.isContextual(118) && this.next(),
              !this.match(0) || (this.next(), !this.tsIsIdentifier()) ? !1 : (this.next(), this.match(58)))
        )
      }
      tsParseMappedTypeParameter() {
        const e = this.startNode()
        return (
          (e.name = this.tsParseTypeParameterName()),
          (e.constraint = this.tsExpectThenParseType(58)),
          this.finishNode(e, 'TSTypeParameter')
        )
      }
      tsParseMappedType() {
        const e = this.startNode()
        return (
          this.expect(5),
          this.match(53)
            ? ((e.readonly = this.state.value), this.next(), this.expectContextual(118))
            : this.eatContextual(118) && (e.readonly = !0),
          this.expect(0),
          (e.typeParameter = this.tsParseMappedTypeParameter()),
          (e.nameType = this.eatContextual(93) ? this.tsParseType() : null),
          this.expect(3),
          this.match(53)
            ? ((e.optional = this.state.value), this.next(), this.expect(17))
            : this.eat(17) && (e.optional = !0),
          (e.typeAnnotation = this.tsTryParseType()),
          this.semicolon(),
          this.expect(8),
          this.finishNode(e, 'TSMappedType')
        )
      }
      tsParseTupleType() {
        const e = this.startNode()
        e.elementTypes = this.tsParseBracketedList('TupleElementTypes', this.tsParseTupleElementType.bind(this), !0, !1)
        let r = !1,
          i = null
        return (
          e.elementTypes.forEach((n) => {
            var s
            let { type: a } = n
            r &&
              a !== 'TSRestType' &&
              a !== 'TSOptionalType' &&
              !(a === 'TSNamedTupleMember' && n.optional) &&
              this.raise(_e.OptionalTypeBeforeRequired, { at: n }),
              (r = r || (a === 'TSNamedTupleMember' && n.optional) || a === 'TSOptionalType'),
              a === 'TSRestType' && ((n = n.typeAnnotation), (a = n.type))
            const o = a === 'TSNamedTupleMember'
            ;(i = (s = i) != null ? s : o), i !== o && this.raise(_e.MixedLabeledAndUnlabeledElements, { at: n })
          }),
          this.finishNode(e, 'TSTupleType')
        )
      }
      tsParseTupleElementType() {
        const { start: e, startLoc: r } = this.state,
          i = this.eat(21)
        let n = this.tsParseType()
        const s = this.eat(17)
        if (this.eat(14)) {
          const o = this.startNodeAtNode(n)
          ;(o.optional = s),
            n.type === 'TSTypeReference' && !n.typeParameters && n.typeName.type === 'Identifier'
              ? (o.label = n.typeName)
              : (this.raise(_e.InvalidTupleMemberLabel, { at: n }), (o.label = n)),
            (o.elementType = this.tsParseType()),
            (n = this.finishNode(o, 'TSNamedTupleMember'))
        } else if (s) {
          const o = this.startNodeAtNode(n)
          ;(o.typeAnnotation = n), (n = this.finishNode(o, 'TSOptionalType'))
        }
        if (i) {
          const o = this.startNodeAt(e, r)
          ;(o.typeAnnotation = n), (n = this.finishNode(o, 'TSRestType'))
        }
        return n
      }
      tsParseParenthesizedType() {
        const e = this.startNode()
        return (
          this.expect(10),
          (e.typeAnnotation = this.tsParseType()),
          this.expect(11),
          this.finishNode(e, 'TSParenthesizedType')
        )
      }
      tsParseFunctionOrConstructorType(e, r) {
        const i = this.startNode()
        return (
          e === 'TSConstructorType' && ((i.abstract = !!r), r && this.next(), this.next()),
          this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, i)),
          this.finishNode(i, e)
        )
      }
      tsParseLiteralTypeNode() {
        const e = this.startNode()
        return (
          (e.literal = (() => {
            switch (this.state.type) {
              case 130:
              case 131:
              case 129:
              case 85:
              case 86:
                return this.parseExprAtom()
              default:
                throw this.unexpected()
            }
          })()),
          this.finishNode(e, 'TSLiteralType')
        )
      }
      tsParseTemplateLiteralType() {
        const e = this.startNode()
        return (e.literal = this.parseTemplate(!1)), this.finishNode(e, 'TSLiteralType')
      }
      parseTemplateSubstitution() {
        return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution()
      }
      tsParseThisTypeOrThisTypePredicate() {
        const e = this.tsParseThisTypeNode()
        return this.isContextual(113) && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(e) : e
      }
      tsParseNonArrayType() {
        switch (this.state.type) {
          case 129:
          case 130:
          case 131:
          case 85:
          case 86:
            return this.tsParseLiteralTypeNode()
          case 53:
            if (this.state.value === '-') {
              const e = this.startNode(),
                r = this.lookahead()
              if (r.type !== 130 && r.type !== 131) throw this.unexpected()
              return (e.literal = this.parseMaybeUnary()), this.finishNode(e, 'TSLiteralType')
            }
            break
          case 78:
            return this.tsParseThisTypeOrThisTypePredicate()
          case 87:
            return this.tsParseTypeQuery()
          case 83:
            return this.tsParseImportType()
          case 5:
            return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this))
              ? this.tsParseMappedType()
              : this.tsParseTypeLiteral()
          case 0:
            return this.tsParseTupleType()
          case 10:
            return this.tsParseParenthesizedType()
          case 25:
          case 24:
            return this.tsParseTemplateLiteralType()
          default: {
            const { type: e } = this.state
            if (dt(e) || e === 88 || e === 84) {
              const r = e === 88 ? 'TSVoidKeyword' : e === 84 ? 'TSNullKeyword' : iU(this.state.value)
              if (r !== void 0 && this.lookaheadCharCode() !== 46) {
                const i = this.startNode()
                return this.next(), this.finishNode(i, r)
              }
              return this.tsParseTypeReference()
            }
          }
        }
        throw this.unexpected()
      }
      tsParseArrayTypeOrHigher() {
        let e = this.tsParseNonArrayType()
        for (; !this.hasPrecedingLineBreak() && this.eat(0); )
          if (this.match(3)) {
            const r = this.startNodeAtNode(e)
            ;(r.elementType = e), this.expect(3), (e = this.finishNode(r, 'TSArrayType'))
          } else {
            const r = this.startNodeAtNode(e)
            ;(r.objectType = e),
              (r.indexType = this.tsParseType()),
              this.expect(3),
              (e = this.finishNode(r, 'TSIndexedAccessType'))
          }
        return e
      }
      tsParseTypeOperator() {
        const e = this.startNode(),
          r = this.state.value
        return (
          this.next(),
          (e.operator = r),
          (e.typeAnnotation = this.tsParseTypeOperatorOrHigher()),
          r === 'readonly' && this.tsCheckTypeAnnotationForReadOnly(e),
          this.finishNode(e, 'TSTypeOperator')
        )
      }
      tsCheckTypeAnnotationForReadOnly(e) {
        switch (e.typeAnnotation.type) {
          case 'TSTupleType':
          case 'TSArrayType':
            return
          default:
            this.raise(_e.UnexpectedReadonly, { at: e })
        }
      }
      tsParseInferType() {
        const e = this.startNode()
        this.expectContextual(112)
        const r = this.startNode()
        return (
          (r.name = this.tsParseTypeParameterName()),
          (r.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType())),
          (e.typeParameter = this.finishNode(r, 'TSTypeParameter')),
          this.finishNode(e, 'TSInferType')
        )
      }
      tsParseConstraintForInferType() {
        if (this.eat(81)) {
          const e = this.tsInDisallowConditionalTypesContext(() => this.tsParseType())
          if (this.state.inDisallowConditionalTypesContext || !this.match(17)) return e
        }
      }
      tsParseTypeOperatorOrHigher() {
        return GV(this.state.type) && !this.state.containsEsc
          ? this.tsParseTypeOperator()
          : this.isContextual(112)
          ? this.tsParseInferType()
          : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher())
      }
      tsParseUnionOrIntersectionType(e, r, i) {
        const n = this.startNode(),
          s = this.eat(i),
          a = []
        do a.push(r())
        while (this.eat(i))
        return a.length === 1 && !s ? a[0] : ((n.types = a), this.finishNode(n, e))
      }
      tsParseIntersectionTypeOrHigher() {
        return this.tsParseUnionOrIntersectionType(
          'TSIntersectionType',
          this.tsParseTypeOperatorOrHigher.bind(this),
          45
        )
      }
      tsParseUnionTypeOrHigher() {
        return this.tsParseUnionOrIntersectionType('TSUnionType', this.tsParseIntersectionTypeOrHigher.bind(this), 43)
      }
      tsIsStartOfFunctionType() {
        return this.match(47)
          ? !0
          : this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this))
      }
      tsSkipParameterStart() {
        if (dt(this.state.type) || this.match(78)) return this.next(), !0
        if (this.match(5)) {
          const { errors: e } = this.state,
            r = e.length
          try {
            return this.parseObjectLike(8, !0), e.length === r
          } catch {
            return !1
          }
        }
        if (this.match(0)) {
          this.next()
          const { errors: e } = this.state,
            r = e.length
          try {
            return this.parseBindingList(3, 93, !0), e.length === r
          } catch {
            return !1
          }
        }
        return !1
      }
      tsIsUnambiguouslyStartOfFunctionType() {
        return (
          this.next(),
          !!(
            this.match(11) ||
            this.match(21) ||
            (this.tsSkipParameterStart() &&
              (this.match(14) ||
                this.match(12) ||
                this.match(17) ||
                this.match(29) ||
                (this.match(11) && (this.next(), this.match(19)))))
          )
        )
      }
      tsParseTypeOrTypePredicateAnnotation(e) {
        return this.tsInType(() => {
          const r = this.startNode()
          this.expect(e)
          const i = this.startNode(),
            n = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this))
          if (n && this.match(78)) {
            let o = this.tsParseThisTypeOrThisTypePredicate()
            return (
              o.type === 'TSThisType'
                ? ((i.parameterName = o),
                  (i.asserts = !0),
                  (i.typeAnnotation = null),
                  (o = this.finishNode(i, 'TSTypePredicate')))
                : (this.resetStartLocationFromNode(o, i), (o.asserts = !0)),
              (r.typeAnnotation = o),
              this.finishNode(r, 'TSTypeAnnotation')
            )
          }
          const s = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this))
          if (!s)
            return n
              ? ((i.parameterName = this.parseIdentifier()),
                (i.asserts = n),
                (i.typeAnnotation = null),
                (r.typeAnnotation = this.finishNode(i, 'TSTypePredicate')),
                this.finishNode(r, 'TSTypeAnnotation'))
              : this.tsParseTypeAnnotation(!1, r)
          const a = this.tsParseTypeAnnotation(!1)
          return (
            (i.parameterName = s),
            (i.typeAnnotation = a),
            (i.asserts = n),
            (r.typeAnnotation = this.finishNode(i, 'TSTypePredicate')),
            this.finishNode(r, 'TSTypeAnnotation')
          )
        })
      }
      tsTryParseTypeOrTypePredicateAnnotation() {
        return this.match(14) ? this.tsParseTypeOrTypePredicateAnnotation(14) : void 0
      }
      tsTryParseTypeAnnotation() {
        return this.match(14) ? this.tsParseTypeAnnotation() : void 0
      }
      tsTryParseType() {
        return this.tsEatThenParseType(14)
      }
      tsParseTypePredicatePrefix() {
        const e = this.parseIdentifier()
        if (this.isContextual(113) && !this.hasPrecedingLineBreak()) return this.next(), e
      }
      tsParseTypePredicateAsserts() {
        if (this.state.type !== 106) return !1
        const e = this.state.containsEsc
        return (
          this.next(),
          !dt(this.state.type) && !this.match(78)
            ? !1
            : (e &&
                this.raise(te.InvalidEscapedReservedWord, { at: this.state.lastTokStartLoc, reservedWord: 'asserts' }),
              !0)
        )
      }
      tsParseTypeAnnotation(e = !0, r = this.startNode()) {
        return (
          this.tsInType(() => {
            e && this.expect(14), (r.typeAnnotation = this.tsParseType())
          }),
          this.finishNode(r, 'TSTypeAnnotation')
        )
      }
      tsParseType() {
        f0(this.state.inType)
        const e = this.tsParseNonConditionalType()
        if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81)) return e
        const r = this.startNodeAtNode(e)
        return (
          (r.checkType = e),
          (r.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType())),
          this.expect(17),
          (r.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType())),
          this.expect(14),
          (r.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType())),
          this.finishNode(r, 'TSConditionalType')
        )
      }
      isAbstractConstructorSignature() {
        return this.isContextual(120) && this.lookahead().type === 77
      }
      tsParseNonConditionalType() {
        return this.tsIsStartOfFunctionType()
          ? this.tsParseFunctionOrConstructorType('TSFunctionType')
          : this.match(77)
          ? this.tsParseFunctionOrConstructorType('TSConstructorType')
          : this.isAbstractConstructorSignature()
          ? this.tsParseFunctionOrConstructorType('TSConstructorType', !0)
          : this.tsParseUnionTypeOrHigher()
      }
      tsParseTypeAssertion() {
        this.getPluginOption('typescript', 'disallowAmbiguousJSXLike') &&
          this.raise(_e.ReservedTypeAssertion, { at: this.state.startLoc })
        const e = this.startNode(),
          r = this.tsTryNextParseConstantContext()
        return (
          (e.typeAnnotation = r || this.tsNextThenParseType()),
          this.expect(48),
          (e.expression = this.parseMaybeUnary()),
          this.finishNode(e, 'TSTypeAssertion')
        )
      }
      tsParseHeritageClause(e) {
        const r = this.state.startLoc,
          i = this.tsParseDelimitedList('HeritageClauseElement', () => {
            const n = this.startNode()
            return (
              (n.expression = this.tsParseEntityName()),
              this.match(47) && (n.typeParameters = this.tsParseTypeArguments()),
              this.finishNode(n, 'TSExpressionWithTypeArguments')
            )
          })
        return i.length || this.raise(_e.EmptyHeritageClauseType, { at: r, token: e }), i
      }
      tsParseInterfaceDeclaration(e, r = {}) {
        if (this.hasFollowingLineBreak()) return null
        this.expectContextual(125),
          r.declare && (e.declare = !0),
          dt(this.state.type)
            ? ((e.id = this.parseIdentifier()), this.checkIdentifier(e.id, c7))
            : ((e.id = null), this.raise(_e.MissingInterfaceName, { at: this.state.startLoc })),
          (e.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this))),
          this.eat(81) && (e.extends = this.tsParseHeritageClause('extends'))
        const i = this.startNode()
        return (
          (i.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this))),
          (e.body = this.finishNode(i, 'TSInterfaceBody')),
          this.finishNode(e, 'TSInterfaceDeclaration')
        )
      }
      tsParseTypeAliasDeclaration(e) {
        return (
          (e.id = this.parseIdentifier()),
          this.checkIdentifier(e.id, p7),
          (e.typeAnnotation = this.tsInType(() => {
            if (
              ((e.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this))),
              this.expect(29),
              this.isContextual(111) && this.lookahead().type !== 16)
            ) {
              const r = this.startNode()
              return this.next(), this.finishNode(r, 'TSIntrinsicKeyword')
            }
            return this.tsParseType()
          })),
          this.semicolon(),
          this.finishNode(e, 'TSTypeAliasDeclaration')
        )
      }
      tsInNoContext(e) {
        const r = this.state.context
        this.state.context = [r[0]]
        try {
          return e()
        } finally {
          this.state.context = r
        }
      }
      tsInType(e) {
        const r = this.state.inType
        this.state.inType = !0
        try {
          return e()
        } finally {
          this.state.inType = r
        }
      }
      tsInDisallowConditionalTypesContext(e) {
        const r = this.state.inDisallowConditionalTypesContext
        this.state.inDisallowConditionalTypesContext = !0
        try {
          return e()
        } finally {
          this.state.inDisallowConditionalTypesContext = r
        }
      }
      tsInAllowConditionalTypesContext(e) {
        const r = this.state.inDisallowConditionalTypesContext
        this.state.inDisallowConditionalTypesContext = !1
        try {
          return e()
        } finally {
          this.state.inDisallowConditionalTypesContext = r
        }
      }
      tsEatThenParseType(e) {
        return this.match(e) ? this.tsNextThenParseType() : void 0
      }
      tsExpectThenParseType(e) {
        return this.tsDoThenParseType(() => this.expect(e))
      }
      tsNextThenParseType() {
        return this.tsDoThenParseType(() => this.next())
      }
      tsDoThenParseType(e) {
        return this.tsInType(() => (e(), this.tsParseType()))
      }
      tsParseEnumMember() {
        const e = this.startNode()
        return (
          (e.id = this.match(129) ? this.parseExprAtom() : this.parseIdentifier(!0)),
          this.eat(29) && (e.initializer = this.parseMaybeAssignAllowIn()),
          this.finishNode(e, 'TSEnumMember')
        )
      }
      tsParseEnumDeclaration(e, r = {}) {
        return (
          r.const && (e.const = !0),
          r.declare && (e.declare = !0),
          this.expectContextual(122),
          (e.id = this.parseIdentifier()),
          this.checkIdentifier(e.id, e.const ? h7 : e0),
          this.expect(5),
          (e.members = this.tsParseDelimitedList('EnumMembers', this.tsParseEnumMember.bind(this))),
          this.expect(8),
          this.finishNode(e, 'TSEnumDeclaration')
        )
      }
      tsParseModuleBlock() {
        const e = this.startNode()
        return (
          this.scope.enter(Dn),
          this.expect(5),
          this.parseBlockOrModuleBlockBody((e.body = []), void 0, !0, 8),
          this.scope.exit(),
          this.finishNode(e, 'TSModuleBlock')
        )
      }
      tsParseModuleOrNamespaceDeclaration(e, r = !1) {
        if (((e.id = this.parseIdentifier()), r || this.checkIdentifier(e.id, d7), this.eat(16))) {
          const i = this.startNode()
          this.tsParseModuleOrNamespaceDeclaration(i, !0), (e.body = i)
        } else
          this.scope.enter(Ao),
            this.prodParam.enter(Ln),
            (e.body = this.tsParseModuleBlock()),
            this.prodParam.exit(),
            this.scope.exit()
        return this.finishNode(e, 'TSModuleDeclaration')
      }
      tsParseAmbientExternalModuleDeclaration(e) {
        return (
          this.isContextual(109)
            ? ((e.global = !0), (e.id = this.parseIdentifier()))
            : this.match(129)
            ? (e.id = this.parseExprAtom())
            : this.unexpected(),
          this.match(5)
            ? (this.scope.enter(Ao),
              this.prodParam.enter(Ln),
              (e.body = this.tsParseModuleBlock()),
              this.prodParam.exit(),
              this.scope.exit())
            : this.semicolon(),
          this.finishNode(e, 'TSModuleDeclaration')
        )
      }
      tsParseImportEqualsDeclaration(e, r) {
        ;(e.isExport = r || !1), (e.id = this.parseIdentifier()), this.checkIdentifier(e.id, Zr), this.expect(29)
        const i = this.tsParseModuleReference()
        return (
          e.importKind === 'type' &&
            i.type !== 'TSExternalModuleReference' &&
            this.raise(_e.ImportAliasHasImportType, { at: i }),
          (e.moduleReference = i),
          this.semicolon(),
          this.finishNode(e, 'TSImportEqualsDeclaration')
        )
      }
      tsIsExternalModuleReference() {
        return this.isContextual(116) && this.lookaheadCharCode() === 40
      }
      tsParseModuleReference() {
        return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(!1)
      }
      tsParseExternalModuleReference() {
        const e = this.startNode()
        if ((this.expectContextual(116), this.expect(10), !this.match(129))) throw this.unexpected()
        return (e.expression = this.parseExprAtom()), this.expect(11), this.finishNode(e, 'TSExternalModuleReference')
      }
      tsLookAhead(e) {
        const r = this.state.clone(),
          i = e()
        return (this.state = r), i
      }
      tsTryParseAndCatch(e) {
        const r = this.tryParse((i) => e() || i())
        if (!(r.aborted || !r.node)) return r.error && (this.state = r.failState), r.node
      }
      tsTryParse(e) {
        const r = this.state.clone(),
          i = e()
        if (i !== void 0 && i !== !1) return i
        this.state = r
      }
      tsTryParseDeclare(e) {
        if (this.isLineTerminator()) return
        let r = this.state.type,
          i
        return (
          this.isContextual(99) && ((r = 74), (i = 'let')),
          this.tsInAmbientContext(() => {
            if (r === 68) return (e.declare = !0), this.parseFunctionStatement(e, !1, !0)
            if (r === 80) return (e.declare = !0), this.parseClass(e, !0, !1)
            if (r === 122) return this.tsParseEnumDeclaration(e, { declare: !0 })
            if (r === 109) return this.tsParseAmbientExternalModuleDeclaration(e)
            if (r === 75 || r === 74)
              return !this.match(75) || !this.isLookaheadContextual('enum')
                ? ((e.declare = !0), this.parseVarStatement(e, i || this.state.value, !0))
                : (this.expect(75), this.tsParseEnumDeclaration(e, { const: !0, declare: !0 }))
            if (r === 125) {
              const n = this.tsParseInterfaceDeclaration(e, { declare: !0 })
              if (n) return n
            }
            if (dt(r)) return this.tsParseDeclaration(e, this.state.value, !0)
          })
        )
      }
      tsTryParseExportDeclaration() {
        return this.tsParseDeclaration(this.startNode(), this.state.value, !0)
      }
      tsParseExpressionStatement(e, r) {
        switch (r.name) {
          case 'declare': {
            const i = this.tsTryParseDeclare(e)
            if (i) return (i.declare = !0), i
            break
          }
          case 'global':
            if (this.match(5)) {
              this.scope.enter(Ao), this.prodParam.enter(Ln)
              const i = e
              return (
                (i.global = !0),
                (i.id = r),
                (i.body = this.tsParseModuleBlock()),
                this.scope.exit(),
                this.prodParam.exit(),
                this.finishNode(i, 'TSModuleDeclaration')
              )
            }
            break
          default:
            return this.tsParseDeclaration(e, r.name, !1)
        }
      }
      tsParseDeclaration(e, r, i) {
        switch (r) {
          case 'abstract':
            if (this.tsCheckLineTerminator(i) && (this.match(80) || dt(this.state.type)))
              return this.tsParseAbstractDeclaration(e)
            break
          case 'module':
            if (this.tsCheckLineTerminator(i)) {
              if (this.match(129)) return this.tsParseAmbientExternalModuleDeclaration(e)
              if (dt(this.state.type)) return this.tsParseModuleOrNamespaceDeclaration(e)
            }
            break
          case 'namespace':
            if (this.tsCheckLineTerminator(i) && dt(this.state.type)) return this.tsParseModuleOrNamespaceDeclaration(e)
            break
          case 'type':
            if (this.tsCheckLineTerminator(i) && dt(this.state.type)) return this.tsParseTypeAliasDeclaration(e)
            break
        }
      }
      tsCheckLineTerminator(e) {
        return e ? (this.hasFollowingLineBreak() ? !1 : (this.next(), !0)) : !this.isLineTerminator()
      }
      tsTryParseGenericAsyncArrowFunction(e, r) {
        if (!this.match(47)) return
        const i = this.state.maybeInArrowParameters
        this.state.maybeInArrowParameters = !0
        const n = this.tsTryParseAndCatch(() => {
          const s = this.startNodeAt(e, r)
          return (
            (s.typeParameters = this.tsParseTypeParameters()),
            super.parseFunctionParams(s),
            (s.returnType = this.tsTryParseTypeOrTypePredicateAnnotation()),
            this.expect(19),
            s
          )
        })
        if (((this.state.maybeInArrowParameters = i), !!n)) return this.parseArrowExpression(n, null, !0)
      }
      tsParseTypeArgumentsInExpression() {
        if (this.reScan_lt() === 47) return this.tsParseTypeArguments()
      }
      tsParseTypeArguments() {
        const e = this.startNode()
        return (
          (e.params = this.tsInType(() =>
            this.tsInNoContext(
              () => (
                this.expect(47), this.tsParseDelimitedList('TypeParametersOrArguments', this.tsParseType.bind(this))
              )
            )
          )),
          e.params.length === 0 && this.raise(_e.EmptyTypeArguments, { at: e }),
          this.expect(48),
          this.finishNode(e, 'TSTypeParameterInstantiation')
        )
      }
      tsIsDeclarationStart() {
        return JV(this.state.type)
      }
      isExportDefaultSpecifier() {
        return this.tsIsDeclarationStart() ? !1 : super.isExportDefaultSpecifier()
      }
      parseAssignableListItem(e, r) {
        const i = this.state.start,
          n = this.state.startLoc
        let s,
          a = !1,
          o = !1
        if (e !== void 0) {
          const p = {}
          this.tsParseModifiers({
            modified: p,
            allowedModifiers: ['public', 'private', 'protected', 'override', 'readonly'],
          }),
            (s = p.accessibility),
            (o = p.override),
            (a = p.readonly),
            e === !1 && (s || a || o) && this.raise(_e.UnexpectedParameterModifier, { at: n })
        }
        const u = this.parseMaybeDefault()
        this.parseAssignableListItemTypes(u)
        const c = this.parseMaybeDefault(u.start, u.loc.start, u)
        if (s || a || o) {
          const p = this.startNodeAt(i, n)
          return (
            r.length && (p.decorators = r),
            s && (p.accessibility = s),
            a && (p.readonly = a),
            o && (p.override = o),
            c.type !== 'Identifier' &&
              c.type !== 'AssignmentPattern' &&
              this.raise(_e.UnsupportedParameterPropertyKind, { at: p }),
            (p.parameter = c),
            this.finishNode(p, 'TSParameterProperty')
          )
        }
        return r.length && (u.decorators = r), c
      }
      isSimpleParameter(e) {
        return (e.type === 'TSParameterProperty' && super.isSimpleParameter(e.parameter)) || super.isSimpleParameter(e)
      }
      parseFunctionBodyAndFinish(e, r, i = !1) {
        this.match(14) && (e.returnType = this.tsParseTypeOrTypePredicateAnnotation(14))
        const n =
          r === 'FunctionDeclaration'
            ? 'TSDeclareFunction'
            : r === 'ClassMethod' || r === 'ClassPrivateMethod'
            ? 'TSDeclareMethod'
            : void 0
        if (n && !this.match(5) && this.isLineTerminator()) {
          this.finishNode(e, n)
          return
        }
        if (
          n === 'TSDeclareFunction' &&
          this.state.isAmbientContext &&
          (this.raise(_e.DeclareFunctionHasImplementation, { at: e }), e.declare)
        ) {
          super.parseFunctionBodyAndFinish(e, n, i)
          return
        }
        super.parseFunctionBodyAndFinish(e, r, i)
      }
      registerFunctionStatementId(e) {
        !e.body && e.id ? this.checkIdentifier(e.id, t0) : super.registerFunctionStatementId(...arguments)
      }
      tsCheckForInvalidTypeCasts(e) {
        e.forEach((r) => {
          ;(r == null ? void 0 : r.type) === 'TSTypeCastExpression' &&
            this.raise(_e.UnexpectedTypeAnnotation, { at: r.typeAnnotation })
        })
      }
      toReferencedList(e, r) {
        return this.tsCheckForInvalidTypeCasts(e), e
      }
      parseArrayLike(...e) {
        const r = super.parseArrayLike(...e)
        return r.type === 'ArrayExpression' && this.tsCheckForInvalidTypeCasts(r.elements), r
      }
      parseSubscript(e, r, i, n, s) {
        if (!this.hasPrecedingLineBreak() && this.match(35)) {
          ;(this.state.canStartJSXElement = !1), this.next()
          const o = this.startNodeAt(r, i)
          return (o.expression = e), this.finishNode(o, 'TSNonNullExpression')
        }
        let a = !1
        if (this.match(18) && this.lookaheadCharCode() === 60) {
          if (n) return (s.stop = !0), e
          ;(s.optionalChainMember = a = !0), this.next()
        }
        if (this.match(47) || this.match(51)) {
          let o
          const u = this.tsTryParseAndCatch(() => {
            if (!n && this.atPossibleAsyncArrow(e)) {
              const h = this.tsTryParseGenericAsyncArrowFunction(r, i)
              if (h) return h
            }
            const c = this.tsParseTypeArgumentsInExpression()
            if (!c) throw this.unexpected()
            if (a && !this.match(10)) throw ((o = this.state.curPosition()), this.unexpected())
            if (Po(this.state.type)) {
              const h = this.parseTaggedTemplateExpression(e, r, i, s)
              return (h.typeParameters = c), h
            }
            if (!n && this.eat(10)) {
              const h = this.startNodeAt(r, i)
              return (
                (h.callee = e),
                (h.arguments = this.parseCallExpressionArguments(11, !1)),
                this.tsCheckForInvalidTypeCasts(h.arguments),
                (h.typeParameters = c),
                s.optionalChainMember && (h.optional = a),
                this.finishCallExpression(h, s.optionalChainMember)
              )
            }
            if (rU(this.state.type) && this.state.type !== 10) throw this.unexpected()
            const p = this.startNodeAt(r, i)
            return (p.expression = e), (p.typeParameters = c), this.finishNode(p, 'TSInstantiationExpression')
          })
          if ((o && this.unexpected(o, 10), u)) return u
        }
        return super.parseSubscript(e, r, i, n, s)
      }
      parseNewCallee(e) {
        var r
        super.parseNewCallee(e)
        const { callee: i } = e
        i.type === 'TSInstantiationExpression' &&
          !((r = i.extra) != null && r.parenthesized) &&
          ((e.typeParameters = i.typeParameters), (e.callee = i.expression))
      }
      parseExprOp(e, r, i, n) {
        if (Eo(58) > n && !this.hasPrecedingLineBreak() && this.isContextual(93)) {
          const s = this.startNodeAt(r, i)
          s.expression = e
          const a = this.tsTryNextParseConstantContext()
          return (
            a ? (s.typeAnnotation = a) : (s.typeAnnotation = this.tsNextThenParseType()),
            this.finishNode(s, 'TSAsExpression'),
            this.reScan_lt_gt(),
            this.parseExprOp(s, r, i, n)
          )
        }
        return super.parseExprOp(e, r, i, n)
      }
      checkReservedWord(e, r, i, n) {
        this.state.isAmbientContext || super.checkReservedWord(e, r, i, n)
      }
      checkDuplicateExports() {}
      parseImport(e) {
        if (((e.importKind = 'value'), dt(this.state.type) || this.match(55) || this.match(5))) {
          let i = this.lookahead()
          if (
            (this.isContextual(126) &&
              i.type !== 12 &&
              i.type !== 97 &&
              i.type !== 29 &&
              ((e.importKind = 'type'), this.next(), (i = this.lookahead())),
            dt(this.state.type) && i.type === 29)
          )
            return this.tsParseImportEqualsDeclaration(e)
        }
        const r = super.parseImport(e)
        return (
          r.importKind === 'type' &&
            r.specifiers.length > 1 &&
            r.specifiers[0].type === 'ImportDefaultSpecifier' &&
            this.raise(_e.TypeImportCannotSpecifyDefaultAndNamed, { at: r }),
          r
        )
      }
      parseExport(e) {
        if (this.match(83))
          return (
            this.next(),
            this.isContextual(126) && this.lookaheadCharCode() !== 61
              ? ((e.importKind = 'type'), this.next())
              : (e.importKind = 'value'),
            this.tsParseImportEqualsDeclaration(e, !0)
          )
        if (this.eat(29)) {
          const r = e
          return (r.expression = this.parseExpression()), this.semicolon(), this.finishNode(r, 'TSExportAssignment')
        } else if (this.eatContextual(93)) {
          const r = e
          return (
            this.expectContextual(124),
            (r.id = this.parseIdentifier()),
            this.semicolon(),
            this.finishNode(r, 'TSNamespaceExportDeclaration')
          )
        } else
          return (
            this.isContextual(126) && this.lookahead().type === 5
              ? (this.next(), (e.exportKind = 'type'))
              : (e.exportKind = 'value'),
            super.parseExport(e)
          )
      }
      isAbstractClass() {
        return this.isContextual(120) && this.lookahead().type === 80
      }
      parseExportDefaultExpression() {
        if (this.isAbstractClass()) {
          const e = this.startNode()
          return this.next(), (e.abstract = !0), this.parseClass(e, !0, !0), e
        }
        if (this.match(125)) {
          const e = this.tsParseInterfaceDeclaration(this.startNode())
          if (e) return e
        }
        return super.parseExportDefaultExpression()
      }
      parseVarStatement(e, r, i = !1) {
        const { isAmbientContext: n } = this.state,
          s = super.parseVarStatement(e, r, i || n)
        if (!n) return s
        for (const { id: a, init: o } of s.declarations)
          !o ||
            (r !== 'const' || !!a.typeAnnotation
              ? this.raise(_e.InitializerNotAllowedInAmbientContext, { at: o })
              : o.type !== 'StringLiteral' &&
                o.type !== 'BooleanLiteral' &&
                o.type !== 'NumericLiteral' &&
                o.type !== 'BigIntLiteral' &&
                (o.type !== 'TemplateLiteral' || o.expressions.length > 0) &&
                !aU(o) &&
                this.raise(_e.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference, { at: o }))
        return s
      }
      parseStatementContent(e, r) {
        if (this.match(75) && this.isLookaheadContextual('enum')) {
          const i = this.startNode()
          return this.expect(75), this.tsParseEnumDeclaration(i, { const: !0 })
        }
        if (this.isContextual(122)) return this.tsParseEnumDeclaration(this.startNode())
        if (this.isContextual(125)) {
          const i = this.tsParseInterfaceDeclaration(this.startNode())
          if (i) return i
        }
        return super.parseStatementContent(e, r)
      }
      parseAccessModifier() {
        return this.tsParseModifier(['public', 'protected', 'private'])
      }
      tsHasSomeModifiers(e, r) {
        return r.some((i) => (h0(i) ? e.accessibility === i : !!e[i]))
      }
      tsIsStartOfStaticBlocks() {
        return this.isContextual(104) && this.lookaheadCharCode() === 123
      }
      parseClassMember(e, r, i) {
        const n = ['declare', 'private', 'public', 'protected', 'override', 'abstract', 'readonly', 'static']
        this.tsParseModifiers({
          modified: r,
          allowedModifiers: n,
          disallowedModifiers: ['in', 'out'],
          stopOnStartOfClassStaticBlock: !0,
          errorTemplate: _e.InvalidModifierOnTypeParameterPositions,
        })
        const s = () => {
          this.tsIsStartOfStaticBlocks()
            ? (this.next(),
              this.next(),
              this.tsHasSomeModifiers(r, n) &&
                this.raise(_e.StaticBlockCannotHaveModifier, { at: this.state.curPosition() }),
              this.parseClassStaticBlock(e, r))
            : this.parseClassMemberWithIsStatic(e, r, i, !!r.static)
        }
        r.declare ? this.tsInAmbientContext(s) : s()
      }
      parseClassMemberWithIsStatic(e, r, i, n) {
        const s = this.tsTryParseIndexSignature(r)
        if (s) {
          e.body.push(s),
            r.abstract && this.raise(_e.IndexSignatureHasAbstract, { at: r }),
            r.accessibility && this.raise(_e.IndexSignatureHasAccessibility, { at: r, modifier: r.accessibility }),
            r.declare && this.raise(_e.IndexSignatureHasDeclare, { at: r }),
            r.override && this.raise(_e.IndexSignatureHasOverride, { at: r })
          return
        }
        !this.state.inAbstractClass && r.abstract && this.raise(_e.NonAbstractClassHasAbstractMethod, { at: r }),
          r.override && (i.hadSuperClass || this.raise(_e.OverrideNotInSubClass, { at: r })),
          super.parseClassMemberWithIsStatic(e, r, i, n)
      }
      parsePostMemberNameModifiers(e) {
        this.eat(17) && (e.optional = !0),
          e.readonly && this.match(10) && this.raise(_e.ClassMethodHasReadonly, { at: e }),
          e.declare && this.match(10) && this.raise(_e.ClassMethodHasDeclare, { at: e })
      }
      parseExpressionStatement(e, r) {
        return (
          (r.type === 'Identifier' ? this.tsParseExpressionStatement(e, r) : void 0) ||
          super.parseExpressionStatement(e, r)
        )
      }
      shouldParseExportDeclaration() {
        return this.tsIsDeclarationStart() ? !0 : super.shouldParseExportDeclaration()
      }
      parseConditional(e, r, i, n) {
        if (!this.state.maybeInArrowParameters || !this.match(17)) return super.parseConditional(e, r, i, n)
        const s = this.tryParse(() => super.parseConditional(e, r, i))
        return s.node
          ? (s.error && (this.state = s.failState), s.node)
          : (s.error && super.setOptionalParametersError(n, s.error), e)
      }
      parseParenItem(e, r, i) {
        if (
          ((e = super.parseParenItem(e, r, i)),
          this.eat(17) && ((e.optional = !0), this.resetEndLocation(e)),
          this.match(14))
        ) {
          const n = this.startNodeAt(r, i)
          return (
            (n.expression = e),
            (n.typeAnnotation = this.tsParseTypeAnnotation()),
            this.finishNode(n, 'TSTypeCastExpression')
          )
        }
        return e
      }
      parseExportDeclaration(e) {
        if (!this.state.isAmbientContext && this.isContextual(121))
          return this.tsInAmbientContext(() => this.parseExportDeclaration(e))
        const r = this.state.start,
          i = this.state.startLoc,
          n = this.eatContextual(121)
        if (n && (this.isContextual(121) || !this.shouldParseExportDeclaration()))
          throw this.raise(_e.ExpectedAmbientAfterExportDeclare, { at: this.state.startLoc })
        const a = (dt(this.state.type) && this.tsTryParseExportDeclaration()) || super.parseExportDeclaration(e)
        return a
          ? ((a.type === 'TSInterfaceDeclaration' || a.type === 'TSTypeAliasDeclaration' || n) &&
              (e.exportKind = 'type'),
            n && (this.resetStartLocation(a, r, i), (a.declare = !0)),
            a)
          : null
      }
      parseClassId(e, r, i) {
        if ((!r || i) && this.isContextual(110)) return
        super.parseClassId(e, r, i, e.declare ? t0 : Zy)
        const n = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this))
        n && (e.typeParameters = n)
      }
      parseClassPropertyAnnotation(e) {
        !e.optional && this.eat(35) && (e.definite = !0)
        const r = this.tsTryParseTypeAnnotation()
        r && (e.typeAnnotation = r)
      }
      parseClassProperty(e) {
        if (
          (this.parseClassPropertyAnnotation(e),
          this.state.isAmbientContext &&
            this.match(29) &&
            this.raise(_e.DeclareClassFieldHasInitializer, { at: this.state.startLoc }),
          e.abstract && this.match(29))
        ) {
          const { key: r } = e
          this.raise(_e.AbstractPropertyHasInitializer, {
            at: this.state.startLoc,
            propertyName: r.type === 'Identifier' && !e.computed ? r.name : `[${this.input.slice(r.start, r.end)}]`,
          })
        }
        return super.parseClassProperty(e)
      }
      parseClassPrivateProperty(e) {
        return (
          e.abstract && this.raise(_e.PrivateElementHasAbstract, { at: e }),
          e.accessibility && this.raise(_e.PrivateElementHasAccessibility, { at: e, modifier: e.accessibility }),
          this.parseClassPropertyAnnotation(e),
          super.parseClassPrivateProperty(e)
        )
      }
      pushClassMethod(e, r, i, n, s, a) {
        const o = this.tsTryParseTypeParameters()
        o && s && this.raise(_e.ConstructorHasTypeParameters, { at: o })
        const { declare: u = !1, kind: c } = r
        u && (c === 'get' || c === 'set') && this.raise(_e.DeclareAccessor, { at: r, kind: c }),
          o && (r.typeParameters = o),
          super.pushClassMethod(e, r, i, n, s, a)
      }
      pushClassPrivateMethod(e, r, i, n) {
        const s = this.tsTryParseTypeParameters()
        s && (r.typeParameters = s), super.pushClassPrivateMethod(e, r, i, n)
      }
      declareClassPrivateMethodInScope(e, r) {
        e.type !== 'TSDeclareMethod' &&
          ((e.type === 'MethodDefinition' && !e.value.body) || super.declareClassPrivateMethodInScope(e, r))
      }
      parseClassSuper(e) {
        super.parseClassSuper(e),
          e.superClass &&
            (this.match(47) || this.match(51)) &&
            (e.superTypeParameters = this.tsParseTypeArgumentsInExpression()),
          this.eatContextual(110) && (e.implements = this.tsParseHeritageClause('implements'))
      }
      parseObjPropValue(e, ...r) {
        const i = this.tsTryParseTypeParameters()
        i && (e.typeParameters = i), super.parseObjPropValue(e, ...r)
      }
      parseFunctionParams(e, r) {
        const i = this.tsTryParseTypeParameters()
        i && (e.typeParameters = i), super.parseFunctionParams(e, r)
      }
      parseVarId(e, r) {
        super.parseVarId(e, r),
          e.id.type === 'Identifier' && !this.hasPrecedingLineBreak() && this.eat(35) && (e.definite = !0)
        const i = this.tsTryParseTypeAnnotation()
        i && ((e.id.typeAnnotation = i), this.resetEndLocation(e.id))
      }
      parseAsyncArrowFromCallExpression(e, r) {
        return (
          this.match(14) && (e.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(e, r)
        )
      }
      parseMaybeAssign(...e) {
        var r, i, n, s, a, o, u
        let c, p, h
        if (this.hasPlugin('jsx') && (this.match(138) || this.match(47))) {
          if (((c = this.state.clone()), (p = this.tryParse(() => super.parseMaybeAssign(...e), c)), !p.error))
            return p.node
          const { context: T } = this.state,
            y = T[T.length - 1]
          ;(y === gt.j_oTag || y === gt.j_expr) && T.pop()
        }
        if (!((r = p) != null && r.error) && !this.match(47)) return super.parseMaybeAssign(...e)
        ;(!c || c === this.state) && (c = this.state.clone())
        let f
        const d = this.tryParse((T) => {
          var y, b
          f = this.tsParseTypeParameters()
          const m = super.parseMaybeAssign(...e)
          return (
            (m.type !== 'ArrowFunctionExpression' || ((y = m.extra) != null && y.parenthesized)) && T(),
            ((b = f) == null ? void 0 : b.params.length) !== 0 && this.resetStartLocationFromNode(m, f),
            (m.typeParameters = f),
            m
          )
        }, c)
        if (!d.error && !d.aborted) return f && this.reportReservedArrowTypeParam(f), d.node
        if (!p && (f0(!this.hasPlugin('jsx')), (h = this.tryParse(() => super.parseMaybeAssign(...e), c)), !h.error))
          return h.node
        if ((i = p) != null && i.node) return (this.state = p.failState), p.node
        if (d.node) return (this.state = d.failState), f && this.reportReservedArrowTypeParam(f), d.node
        if ((n = h) != null && n.node) return (this.state = h.failState), h.node
        throw (s = p) != null && s.thrown
          ? p.error
          : d.thrown
          ? d.error
          : (a = h) != null && a.thrown
          ? h.error
          : ((o = p) == null ? void 0 : o.error) || d.error || ((u = h) == null ? void 0 : u.error)
      }
      reportReservedArrowTypeParam(e) {
        var r
        e.params.length === 1 &&
          !((r = e.extra) != null && r.trailingComma) &&
          this.getPluginOption('typescript', 'disallowAmbiguousJSXLike') &&
          this.raise(_e.ReservedArrowTypeParam, { at: e })
      }
      parseMaybeUnary(e) {
        return !this.hasPlugin('jsx') && this.match(47) ? this.tsParseTypeAssertion() : super.parseMaybeUnary(e)
      }
      parseArrow(e) {
        if (this.match(14)) {
          const r = this.tryParse((i) => {
            const n = this.tsParseTypeOrTypePredicateAnnotation(14)
            return (this.canInsertSemicolon() || !this.match(19)) && i(), n
          })
          if (r.aborted) return
          r.thrown || (r.error && (this.state = r.failState), (e.returnType = r.node))
        }
        return super.parseArrow(e)
      }
      parseAssignableListItemTypes(e) {
        this.eat(17) &&
          (e.type !== 'Identifier' &&
            !this.state.isAmbientContext &&
            !this.state.inType &&
            this.raise(_e.PatternIsOptional, { at: e }),
          (e.optional = !0))
        const r = this.tsTryParseTypeAnnotation()
        return r && (e.typeAnnotation = r), this.resetEndLocation(e), e
      }
      isAssignable(e, r) {
        switch (e.type) {
          case 'TSTypeCastExpression':
            return this.isAssignable(e.expression, r)
          case 'TSParameterProperty':
            return !0
          default:
            return super.isAssignable(e, r)
        }
      }
      toAssignable(e, r = !1) {
        switch (e.type) {
          case 'ParenthesizedExpression':
            this.toAssignableParenthesizedExpression(e, r)
            break
          case 'TSAsExpression':
          case 'TSNonNullExpression':
          case 'TSTypeAssertion':
            r
              ? this.expressionScope.recordArrowParemeterBindingError(_e.UnexpectedTypeCastInParameter, { at: e })
              : this.raise(_e.UnexpectedTypeCastInParameter, { at: e }),
              this.toAssignable(e.expression, r)
            break
          case 'AssignmentExpression':
            !r && e.left.type === 'TSTypeCastExpression' && (e.left = this.typeCastToParameter(e.left))
          default:
            super.toAssignable(e, r)
        }
      }
      toAssignableParenthesizedExpression(e, r) {
        switch (e.expression.type) {
          case 'TSAsExpression':
          case 'TSNonNullExpression':
          case 'TSTypeAssertion':
          case 'ParenthesizedExpression':
            this.toAssignable(e.expression, r)
            break
          default:
            super.toAssignable(e, r)
        }
      }
      checkToRestConversion(e, r) {
        switch (e.type) {
          case 'TSAsExpression':
          case 'TSTypeAssertion':
          case 'TSNonNullExpression':
            this.checkToRestConversion(e.expression, !1)
            break
          default:
            super.checkToRestConversion(e, r)
        }
      }
      isValidLVal(e, r, i) {
        return (
          eU(
            {
              TSTypeCastExpression: !0,
              TSParameterProperty: 'parameter',
              TSNonNullExpression: 'expression',
              TSAsExpression: (i !== rn || !r) && ['expression', !0],
              TSTypeAssertion: (i !== rn || !r) && ['expression', !0],
            },
            e
          ) || super.isValidLVal(e, r, i)
        )
      }
      parseBindingAtom() {
        switch (this.state.type) {
          case 78:
            return this.parseIdentifier(!0)
          default:
            return super.parseBindingAtom()
        }
      }
      parseMaybeDecoratorArguments(e) {
        if (this.match(47) || this.match(51)) {
          const r = this.tsParseTypeArgumentsInExpression()
          if (this.match(10)) {
            const i = super.parseMaybeDecoratorArguments(e)
            return (i.typeParameters = r), i
          }
          this.unexpected(null, 10)
        }
        return super.parseMaybeDecoratorArguments(e)
      }
      checkCommaAfterRest(e) {
        return this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === e
          ? (this.next(), !1)
          : super.checkCommaAfterRest(e)
      }
      isClassMethod() {
        return this.match(47) || super.isClassMethod()
      }
      isClassProperty() {
        return this.match(35) || this.match(14) || super.isClassProperty()
      }
      parseMaybeDefault(...e) {
        const r = super.parseMaybeDefault(...e)
        return (
          r.type === 'AssignmentPattern' &&
            r.typeAnnotation &&
            r.right.start < r.typeAnnotation.start &&
            this.raise(_e.TypeAnnotationAfterAssign, { at: r.typeAnnotation }),
          r
        )
      }
      getTokenFromCode(e) {
        if (this.state.inType) {
          if (e === 62) return this.finishOp(48, 1)
          if (e === 60) return this.finishOp(47, 1)
        }
        return super.getTokenFromCode(e)
      }
      reScan_lt_gt() {
        const { type: e } = this.state
        e === 47
          ? ((this.state.pos -= 1), this.readToken_lt())
          : e === 48 && ((this.state.pos -= 1), this.readToken_gt())
      }
      reScan_lt() {
        const { type: e } = this.state
        return e === 51 ? ((this.state.pos -= 2), this.finishOp(47, 1), 47) : e
      }
      toAssignableList(e) {
        for (let r = 0; r < e.length; r++) {
          const i = e[r]
          ;(i == null ? void 0 : i.type) === 'TSTypeCastExpression' && (e[r] = this.typeCastToParameter(i))
        }
        super.toAssignableList(...arguments)
      }
      typeCastToParameter(e) {
        return (
          (e.expression.typeAnnotation = e.typeAnnotation),
          this.resetEndLocation(e.expression, e.typeAnnotation.loc.end),
          e.expression
        )
      }
      shouldParseArrow(e) {
        return this.match(14) ? e.every((r) => this.isAssignable(r, !0)) : super.shouldParseArrow(e)
      }
      shouldParseAsyncArrow() {
        return this.match(14) || super.shouldParseAsyncArrow()
      }
      canHaveLeadingDecorator() {
        return super.canHaveLeadingDecorator() || this.isAbstractClass()
      }
      jsxParseOpeningElementAfterName(e) {
        if (this.match(47) || this.match(51)) {
          const r = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression())
          r && (e.typeParameters = r)
        }
        return super.jsxParseOpeningElementAfterName(e)
      }
      getGetterSetterExpectedParamCount(e) {
        const r = super.getGetterSetterExpectedParamCount(e),
          n = this.getObjectOrClassMethodParams(e)[0]
        return n && this.isThisParam(n) ? r + 1 : r
      }
      parseCatchClauseParam() {
        const e = super.parseCatchClauseParam(),
          r = this.tsTryParseTypeAnnotation()
        return r && ((e.typeAnnotation = r), this.resetEndLocation(e)), e
      }
      tsInAmbientContext(e) {
        const r = this.state.isAmbientContext
        this.state.isAmbientContext = !0
        try {
          return e()
        } finally {
          this.state.isAmbientContext = r
        }
      }
      parseClass(e, ...r) {
        const i = this.state.inAbstractClass
        this.state.inAbstractClass = !!e.abstract
        try {
          return super.parseClass(e, ...r)
        } finally {
          this.state.inAbstractClass = i
        }
      }
      tsParseAbstractDeclaration(e) {
        if (this.match(80)) return (e.abstract = !0), this.parseClass(e, !0, !1)
        if (this.isContextual(125)) {
          if (!this.hasFollowingLineBreak())
            return (
              (e.abstract = !0),
              this.raise(_e.NonClassMethodPropertyHasAbstractModifer, { at: e }),
              this.tsParseInterfaceDeclaration(e)
            )
        } else this.unexpected(null, 80)
      }
      parseMethod(...e) {
        const r = super.parseMethod(...e)
        if (r.abstract && (this.hasPlugin('estree') ? !!r.value.body : !!r.body)) {
          const { key: n } = r
          this.raise(_e.AbstractMethodHasImplementation, {
            at: r,
            methodName: n.type === 'Identifier' && !r.computed ? n.name : `[${this.input.slice(n.start, n.end)}]`,
          })
        }
        return r
      }
      tsParseTypeParameterName() {
        return this.parseIdentifier().name
      }
      shouldParseAsAmbientContext() {
        return !!this.getPluginOption('typescript', 'dts')
      }
      parse() {
        return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.parse()
      }
      getExpression() {
        return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.getExpression()
      }
      parseExportSpecifier(e, r, i, n) {
        return !r && n
          ? (this.parseTypeOnlyImportExportSpecifier(e, !1, i), this.finishNode(e, 'ExportSpecifier'))
          : ((e.exportKind = 'value'), super.parseExportSpecifier(e, r, i, n))
      }
      parseImportSpecifier(e, r, i, n) {
        return !r && n
          ? (this.parseTypeOnlyImportExportSpecifier(e, !0, i), this.finishNode(e, 'ImportSpecifier'))
          : ((e.importKind = 'value'), super.parseImportSpecifier(e, r, i, n))
      }
      parseTypeOnlyImportExportSpecifier(e, r, i) {
        const n = r ? 'imported' : 'local',
          s = r ? 'local' : 'exported'
        let a = e[n],
          o,
          u = !1,
          c = !0
        const p = a.loc.start
        if (this.isContextual(93)) {
          const f = this.parseIdentifier()
          if (this.isContextual(93)) {
            const d = this.parseIdentifier()
            Hr(this.state.type)
              ? ((u = !0), (a = f), (o = r ? this.parseIdentifier() : this.parseModuleExportName()), (c = !1))
              : ((o = d), (c = !1))
          } else
            Hr(this.state.type)
              ? ((c = !1), (o = r ? this.parseIdentifier() : this.parseModuleExportName()))
              : ((u = !0), (a = f))
        } else
          Hr(this.state.type) &&
            ((u = !0),
            r
              ? ((a = this.parseIdentifier(!0)),
                this.isContextual(93) || this.checkReservedWord(a.name, a.loc.start, !0, !0))
              : (a = this.parseModuleExportName()))
        u && i && this.raise(r ? _e.TypeModifierIsUsedInTypeImports : _e.TypeModifierIsUsedInTypeExports, { at: p }),
          (e[n] = a),
          (e[s] = o)
        const h = r ? 'importKind' : 'exportKind'
        ;(e[h] = u ? 'type' : 'value'),
          c && this.eatContextual(93) && (e[s] = r ? this.parseIdentifier() : this.parseModuleExportName()),
          e[s] || (e[s] = Qr(e[n])),
          r && this.checkIdentifier(e[s], Zr)
      }
    }
  function aU(t) {
    if (t.type !== 'MemberExpression') return !1
    const { computed: e, property: r } = t
    return e && r.type !== 'StringLiteral' && (r.type !== 'TemplateLiteral' || r.expressions.length > 0)
      ? !1
      : d0(t.object)
  }
  function d0(t) {
    return t.type === 'Identifier' ? !0 : t.type !== 'MemberExpression' || t.computed ? !1 : d0(t.object)
  }
  const m0 = Wr`placeholders`((t) => ({
    ClassNameIsRequired: t('A class name is required.'),
    UnexpectedSpace: t('Unexpected space in placeholder.'),
  }))
  var oU = (t) =>
      class extends t {
        parsePlaceholder(e) {
          if (this.match(140)) {
            const r = this.startNode()
            return (
              this.next(),
              this.assertNoSpace(),
              (r.name = super.parseIdentifier(!0)),
              this.assertNoSpace(),
              this.expect(140),
              this.finishPlaceholder(r, e)
            )
          }
        }
        finishPlaceholder(e, r) {
          const i = !!(e.expectedNode && e.type === 'Placeholder')
          return (e.expectedNode = r), i ? e : this.finishNode(e, 'Placeholder')
        }
        getTokenFromCode(e) {
          return e === 37 && this.input.charCodeAt(this.state.pos + 1) === 37
            ? this.finishOp(140, 2)
            : super.getTokenFromCode(...arguments)
        }
        parseExprAtom() {
          return this.parsePlaceholder('Expression') || super.parseExprAtom(...arguments)
        }
        parseIdentifier() {
          return this.parsePlaceholder('Identifier') || super.parseIdentifier(...arguments)
        }
        checkReservedWord(e) {
          e !== void 0 && super.checkReservedWord(...arguments)
        }
        parseBindingAtom() {
          return this.parsePlaceholder('Pattern') || super.parseBindingAtom(...arguments)
        }
        isValidLVal(e, ...r) {
          return e === 'Placeholder' || super.isValidLVal(e, ...r)
        }
        toAssignable(e) {
          e && e.type === 'Placeholder' && e.expectedNode === 'Expression'
            ? (e.expectedNode = 'Pattern')
            : super.toAssignable(...arguments)
        }
        isLet(e) {
          return super.isLet(e) ? !0 : !this.isContextual(99) || e ? !1 : this.lookahead().type === 140
        }
        verifyBreakContinue(e) {
          ;(e.label && e.label.type === 'Placeholder') || super.verifyBreakContinue(...arguments)
        }
        parseExpressionStatement(e, r) {
          if (r.type !== 'Placeholder' || (r.extra && r.extra.parenthesized))
            return super.parseExpressionStatement(...arguments)
          if (this.match(14)) {
            const i = e
            return (
              (i.label = this.finishPlaceholder(r, 'Identifier')),
              this.next(),
              (i.body = this.parseStatement('label')),
              this.finishNode(i, 'LabeledStatement')
            )
          }
          return this.semicolon(), (e.name = r.name), this.finishPlaceholder(e, 'Statement')
        }
        parseBlock() {
          return this.parsePlaceholder('BlockStatement') || super.parseBlock(...arguments)
        }
        parseFunctionId() {
          return this.parsePlaceholder('Identifier') || super.parseFunctionId(...arguments)
        }
        parseClass(e, r, i) {
          const n = r ? 'ClassDeclaration' : 'ClassExpression'
          this.next(), this.takeDecorators(e)
          const s = this.state.strict,
            a = this.parsePlaceholder('Identifier')
          if (a)
            if (this.match(81) || this.match(140) || this.match(5)) e.id = a
            else {
              if (i || !r)
                return (e.id = null), (e.body = this.finishPlaceholder(a, 'ClassBody')), this.finishNode(e, n)
              throw this.raise(m0.ClassNameIsRequired, { at: this.state.startLoc })
            }
          else this.parseClassId(e, r, i)
          return (
            this.parseClassSuper(e),
            (e.body = this.parsePlaceholder('ClassBody') || this.parseClassBody(!!e.superClass, s)),
            this.finishNode(e, n)
          )
        }
        parseExport(e) {
          const r = this.parsePlaceholder('Identifier')
          if (!r) return super.parseExport(...arguments)
          if (!this.isContextual(97) && !this.match(12))
            return (
              (e.specifiers = []),
              (e.source = null),
              (e.declaration = this.finishPlaceholder(r, 'Declaration')),
              this.finishNode(e, 'ExportNamedDeclaration')
            )
          this.expectPlugin('exportDefaultFrom')
          const i = this.startNode()
          return (i.exported = r), (e.specifiers = [this.finishNode(i, 'ExportDefaultSpecifier')]), super.parseExport(e)
        }
        isExportDefaultSpecifier() {
          if (this.match(65)) {
            const e = this.nextTokenStart()
            if (this.isUnparsedContextual(e, 'from') && this.input.startsWith(gi(140), this.nextTokenStartSince(e + 4)))
              return !0
          }
          return super.isExportDefaultSpecifier()
        }
        maybeParseExportDefaultSpecifier(e) {
          return e.specifiers && e.specifiers.length > 0 ? !0 : super.maybeParseExportDefaultSpecifier(...arguments)
        }
        checkExport(e) {
          const { specifiers: r } = e
          r != null && r.length && (e.specifiers = r.filter((i) => i.exported.type === 'Placeholder')),
            super.checkExport(e),
            (e.specifiers = r)
        }
        parseImport(e) {
          const r = this.parsePlaceholder('Identifier')
          if (!r) return super.parseImport(...arguments)
          if (((e.specifiers = []), !this.isContextual(97) && !this.match(12)))
            return (
              (e.source = this.finishPlaceholder(r, 'StringLiteral')),
              this.semicolon(),
              this.finishNode(e, 'ImportDeclaration')
            )
          const i = this.startNodeAtNode(r)
          return (
            (i.local = r),
            this.finishNode(i, 'ImportDefaultSpecifier'),
            e.specifiers.push(i),
            this.eat(12) && (this.maybeParseStarImportSpecifier(e) || this.parseNamedImportSpecifiers(e)),
            this.expectContextual(97),
            (e.source = this.parseImportSource()),
            this.semicolon(),
            this.finishNode(e, 'ImportDeclaration')
          )
        }
        parseImportSource() {
          return this.parsePlaceholder('StringLiteral') || super.parseImportSource(...arguments)
        }
        assertNoSpace() {
          this.state.start > this.state.lastTokEndLoc.index &&
            this.raise(m0.UnexpectedSpace, { at: this.state.lastTokEndLoc })
        }
      },
    lU = (t) =>
      class extends t {
        parseV8Intrinsic() {
          if (this.match(54)) {
            const e = this.state.startLoc,
              r = this.startNode()
            if ((this.next(), dt(this.state.type))) {
              const i = this.parseIdentifierName(this.state.start),
                n = this.createIdentifier(r, i)
              if (((n.type = 'V8IntrinsicIdentifier'), this.match(10))) return n
            }
            this.unexpected(e)
          }
        }
        parseExprAtom() {
          return this.parseV8Intrinsic() || super.parseExprAtom(...arguments)
        }
      }
  function Kt(t, e) {
    const [r, i] = typeof e == 'string' ? [e, {}] : e,
      n = Object.keys(i),
      s = n.length === 0
    return t.some((a) => {
      if (typeof a == 'string') return s && a === r
      {
        const [o, u] = a
        if (o !== r) return !1
        for (const c of n) if (u[c] !== i[c]) return !1
        return !0
      }
    })
  }
  function Ls(t, e, r) {
    const i = t.find((n) => (Array.isArray(n) ? n[0] === e : n === e))
    return i && Array.isArray(i) ? i[1][r] : null
  }
  const y0 = ['minimal', 'fsharp', 'hack', 'smart'],
    g0 = ['^^', '@@', '^', '%', '#'],
    T0 = ['hash', 'bar']
  function uU(t) {
    if (Kt(t, 'decorators')) {
      if (Kt(t, 'decorators-legacy')) throw new Error('Cannot use the decorators and decorators-legacy plugin together')
      const e = Ls(t, 'decorators', 'decoratorsBeforeExport')
      if (e == null)
        throw new Error(
          "The 'decorators' plugin requires a 'decoratorsBeforeExport' option, whose value must be a boolean. If you are migrating from Babylon/Babel 6 or want to use the old decorators proposal, you should use the 'decorators-legacy' plugin instead of 'decorators'."
        )
      if (typeof e != 'boolean') throw new Error("'decoratorsBeforeExport' must be a boolean.")
    }
    if (Kt(t, 'flow') && Kt(t, 'typescript')) throw new Error('Cannot combine flow and typescript plugins.')
    if (Kt(t, 'placeholders') && Kt(t, 'v8intrinsic'))
      throw new Error('Cannot combine placeholders and v8intrinsic plugins.')
    if (Kt(t, 'pipelineOperator')) {
      const e = Ls(t, 'pipelineOperator', 'proposal')
      if (!y0.includes(e)) {
        const i = y0.map((n) => `"${n}"`).join(', ')
        throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${i}.`)
      }
      const r = Kt(t, ['recordAndTuple', { syntaxType: 'hash' }])
      if (e === 'hack') {
        if (Kt(t, 'placeholders')) throw new Error('Cannot combine placeholders plugin and Hack-style pipes.')
        if (Kt(t, 'v8intrinsic')) throw new Error('Cannot combine v8intrinsic plugin and Hack-style pipes.')
        const i = Ls(t, 'pipelineOperator', 'topicToken')
        if (!g0.includes(i)) {
          const n = g0.map((s) => `"${s}"`).join(', ')
          throw new Error(
            `"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${n}.`
          )
        }
        if (i === '#' && r)
          throw new Error(
            'Plugin conflict between `["pipelineOperator", { proposal: "hack", topicToken: "#" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.'
          )
      } else if (e === 'smart' && r)
        throw new Error(
          'Plugin conflict between `["pipelineOperator", { proposal: "smart" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.'
        )
    }
    if (Kt(t, 'moduleAttributes')) {
      if (Kt(t, 'importAssertions')) throw new Error('Cannot combine importAssertions and moduleAttributes plugins.')
      if (Ls(t, 'moduleAttributes', 'version') !== 'may-2020')
        throw new Error(
          "The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'."
        )
    }
    if (Kt(t, 'recordAndTuple') && !T0.includes(Ls(t, 'recordAndTuple', 'syntaxType')))
      throw new Error(
        "'recordAndTuple' requires 'syntaxType' option whose value should be one of: " +
          T0.map((e) => `'${e}'`).join(', ')
      )
    if (Kt(t, 'asyncDoExpressions') && !Kt(t, 'doExpressions')) {
      const e = new Error(
        "'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins."
      )
      throw ((e.missingPlugins = 'doExpressions'), e)
    }
  }
  const b0 = { estree: _V, jsx: J7, flow: X7, typescript: sU, v8intrinsic: lU, placeholders: oU },
    cU = Object.keys(b0),
    S0 = {
      sourceType: 'script',
      sourceFilename: void 0,
      startColumn: 0,
      startLine: 1,
      allowAwaitOutsideFunction: !1,
      allowReturnOutsideFunction: !1,
      allowImportExportEverywhere: !1,
      allowSuperOutsideMethod: !1,
      allowUndeclaredExports: !1,
      plugins: [],
      strictMode: null,
      ranges: !1,
      tokens: !1,
      createParenthesizedExpressions: !1,
      errorRecovery: !1,
      attachComment: !0,
    }
  function pU(t) {
    const e = {}
    for (const r of Object.keys(S0)) e[r] = t && t[r] != null ? t[r] : S0[r]
    return e
  }
  const fU = (t, e) => Object.hasOwnProperty.call(t, e) && t[e],
    v0 = (t) => (t.type === 'ParenthesizedExpression' ? v0(t.expression) : t)
  class hU extends z7 {
    toAssignable(e, r = !1) {
      var i, n
      let s
      switch (
        ((e.type === 'ParenthesizedExpression' || ((i = e.extra) != null && i.parenthesized)) &&
          ((s = v0(e)),
          r
            ? s.type === 'Identifier'
              ? this.expressionScope.recordArrowParemeterBindingError(te.InvalidParenthesizedAssignment, { at: e })
              : s.type !== 'MemberExpression' && this.raise(te.InvalidParenthesizedAssignment, { at: e })
            : this.raise(te.InvalidParenthesizedAssignment, { at: e })),
        e.type)
      ) {
        case 'Identifier':
        case 'ObjectPattern':
        case 'ArrayPattern':
        case 'AssignmentPattern':
        case 'RestElement':
          break
        case 'ObjectExpression':
          e.type = 'ObjectPattern'
          for (let o = 0, u = e.properties.length, c = u - 1; o < u; o++) {
            var a
            const p = e.properties[o],
              h = o === c
            this.toAssignableObjectExpressionProp(p, h, r),
              h &&
                p.type === 'RestElement' &&
                (a = e.extra) != null &&
                a.trailingCommaLoc &&
                this.raise(te.RestTrailingComma, { at: e.extra.trailingCommaLoc })
          }
          break
        case 'ObjectProperty': {
          const { key: o, value: u } = e
          this.isPrivateName(o) && this.classScope.usePrivateName(this.getPrivateNameSV(o), o.loc.start),
            this.toAssignable(u, r)
          break
        }
        case 'SpreadElement':
          throw new Error(
            "Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller."
          )
        case 'ArrayExpression':
          ;(e.type = 'ArrayPattern'),
            this.toAssignableList(e.elements, (n = e.extra) == null ? void 0 : n.trailingCommaLoc, r)
          break
        case 'AssignmentExpression':
          e.operator !== '=' && this.raise(te.MissingEqInAssignment, { at: e.left.loc.end }),
            (e.type = 'AssignmentPattern'),
            delete e.operator,
            this.toAssignable(e.left, r)
          break
        case 'ParenthesizedExpression':
          this.toAssignable(s, r)
          break
      }
    }
    toAssignableObjectExpressionProp(e, r, i) {
      if (e.type === 'ObjectMethod')
        this.raise(e.kind === 'get' || e.kind === 'set' ? te.PatternHasAccessor : te.PatternHasMethod, { at: e.key })
      else if (e.type === 'SpreadElement') {
        e.type = 'RestElement'
        const n = e.argument
        this.checkToRestConversion(n, !1), this.toAssignable(n, i), r || this.raise(te.RestTrailingComma, { at: e })
      } else this.toAssignable(e, i)
    }
    toAssignableList(e, r, i) {
      const n = e.length - 1
      for (let s = 0; s <= n; s++) {
        const a = e[s]
        if (!!a) {
          if (a.type === 'SpreadElement') {
            a.type = 'RestElement'
            const o = a.argument
            this.checkToRestConversion(o, !0), this.toAssignable(o, i)
          } else this.toAssignable(a, i)
          a.type === 'RestElement' &&
            (s < n ? this.raise(te.RestTrailingComma, { at: a }) : r && this.raise(te.RestTrailingComma, { at: r }))
        }
      }
    }
    isAssignable(e, r) {
      switch (e.type) {
        case 'Identifier':
        case 'ObjectPattern':
        case 'ArrayPattern':
        case 'AssignmentPattern':
        case 'RestElement':
          return !0
        case 'ObjectExpression': {
          const i = e.properties.length - 1
          return e.properties.every(
            (n, s) => n.type !== 'ObjectMethod' && (s === i || n.type !== 'SpreadElement') && this.isAssignable(n)
          )
        }
        case 'ObjectProperty':
          return this.isAssignable(e.value)
        case 'SpreadElement':
          return this.isAssignable(e.argument)
        case 'ArrayExpression':
          return e.elements.every((i) => i === null || this.isAssignable(i))
        case 'AssignmentExpression':
          return e.operator === '='
        case 'ParenthesizedExpression':
          return this.isAssignable(e.expression)
        case 'MemberExpression':
        case 'OptionalMemberExpression':
          return !r
        default:
          return !1
      }
    }
    toReferencedList(e, r) {
      return e
    }
    toReferencedListDeep(e, r) {
      this.toReferencedList(e, r)
      for (const i of e) (i == null ? void 0 : i.type) === 'ArrayExpression' && this.toReferencedListDeep(i.elements)
    }
    parseSpread(e, r) {
      const i = this.startNode()
      return this.next(), (i.argument = this.parseMaybeAssignAllowIn(e, void 0, r)), this.finishNode(i, 'SpreadElement')
    }
    parseRestBinding() {
      const e = this.startNode()
      return this.next(), (e.argument = this.parseBindingAtom()), this.finishNode(e, 'RestElement')
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 0: {
          const e = this.startNode()
          return this.next(), (e.elements = this.parseBindingList(3, 93, !0)), this.finishNode(e, 'ArrayPattern')
        }
        case 5:
          return this.parseObjectLike(8, !0)
      }
      return this.parseIdentifier()
    }
    parseBindingList(e, r, i, n) {
      const s = []
      let a = !0
      for (; !this.eat(e); )
        if ((a ? (a = !1) : this.expect(12), i && this.match(12))) s.push(null)
        else {
          if (this.eat(e)) break
          if (this.match(21)) {
            if ((s.push(this.parseAssignableListItemTypes(this.parseRestBinding())), !this.checkCommaAfterRest(r))) {
              this.expect(e)
              break
            }
          } else {
            const o = []
            for (
              this.match(26) &&
              this.hasPlugin('decorators') &&
              this.raise(te.UnsupportedParameterDecorator, { at: this.state.startLoc });
              this.match(26);

            )
              o.push(this.parseDecorator())
            s.push(this.parseAssignableListItem(n, o))
          }
        }
      return s
    }
    parseBindingRestProperty(e) {
      return (
        this.next(),
        (e.argument = this.parseIdentifier()),
        this.checkCommaAfterRest(125),
        this.finishNode(e, 'RestElement')
      )
    }
    parseBindingProperty() {
      const e = this.startNode(),
        { type: r, start: i, startLoc: n } = this.state
      return r === 21
        ? this.parseBindingRestProperty(e)
        : (r === 134
            ? (this.expectPlugin('destructuringPrivate', n),
              this.classScope.usePrivateName(this.state.value, n),
              (e.key = this.parsePrivateName()))
            : this.parsePropertyName(e),
          (e.method = !1),
          this.parseObjPropValue(e, i, n, !1, !1, !0, !1),
          e)
    }
    parseAssignableListItem(e, r) {
      const i = this.parseMaybeDefault()
      this.parseAssignableListItemTypes(i)
      const n = this.parseMaybeDefault(i.start, i.loc.start, i)
      return r.length && (i.decorators = r), n
    }
    parseAssignableListItemTypes(e) {
      return e
    }
    parseMaybeDefault(e, r, i) {
      var n, s, a
      if (
        ((r = (n = r) != null ? n : this.state.startLoc),
        (e = (s = e) != null ? s : this.state.start),
        (i = (a = i) != null ? a : this.parseBindingAtom()),
        !this.eat(29))
      )
        return i
      const o = this.startNodeAt(e, r)
      return (o.left = i), (o.right = this.parseMaybeAssignAllowIn()), this.finishNode(o, 'AssignmentPattern')
    }
    isValidLVal(e, r, i) {
      return fU(
        {
          AssignmentPattern: 'left',
          RestElement: 'argument',
          ObjectProperty: 'value',
          ParenthesizedExpression: 'expression',
          ArrayPattern: 'elements',
          ObjectPattern: 'properties',
        },
        e
      )
    }
    checkLVal(
      e,
      {
        in: r,
        binding: i = rn,
        checkClashes: n = !1,
        strictModeChanged: s = !1,
        allowingSloppyLetBinding: a = !(i & Ti),
        hasParenthesizedAncestor: o = !1,
      }
    ) {
      var u
      const c = e.type
      if (this.isObjectMethod(e)) return
      if (c === 'MemberExpression') {
        i !== rn && this.raise(te.InvalidPropertyBindingPattern, { at: e })
        return
      }
      if (e.type === 'Identifier') {
        this.checkIdentifier(e, i, s, a)
        const { name: T } = e
        n && (n.has(T) ? this.raise(te.ParamDupe, { at: e }) : n.add(T))
        return
      }
      const p = this.isValidLVal(
        e.type,
        !(o || ((u = e.extra) != null && u.parenthesized)) && r.type === 'AssignmentExpression',
        i
      )
      if (p === !0) return
      if (p === !1) {
        const T = i === rn ? te.InvalidLhs : te.InvalidLhsBinding
        this.raise(T, {
          at: e,
          ancestor: r.type === 'UpdateExpression' ? { type: 'UpdateExpression', prefix: r.prefix } : { type: r.type },
        })
        return
      }
      const [h, f] = Array.isArray(p) ? p : [p, c === 'ParenthesizedExpression'],
        d = e.type === 'ArrayPattern' || e.type === 'ObjectPattern' || e.type === 'ParenthesizedExpression' ? e : r
      for (const T of [].concat(e[h]))
        T &&
          this.checkLVal(T, {
            in: d,
            binding: i,
            checkClashes: n,
            allowingSloppyLetBinding: a,
            strictModeChanged: s,
            hasParenthesizedAncestor: f,
          })
    }
    checkIdentifier(e, r, i = !1, n = !(r & Ti)) {
      this.state.strict &&
        (i ? Hy(e.name, this.inModule) : Yy(e.name)) &&
        (r === rn
          ? this.raise(te.StrictEvalArguments, { at: e, referenceName: e.name })
          : this.raise(te.StrictEvalArgumentsBinding, { at: e, bindingName: e.name })),
        !n && e.name === 'let' && this.raise(te.LetInLexicalBinding, { at: e }),
        r & rn || this.declareNameFromIdentifier(e, r)
    }
    declareNameFromIdentifier(e, r) {
      this.scope.declareName(e.name, r, e.loc.start)
    }
    checkToRestConversion(e, r) {
      switch (e.type) {
        case 'ParenthesizedExpression':
          this.checkToRestConversion(e.expression, r)
          break
        case 'Identifier':
        case 'MemberExpression':
          break
        case 'ArrayExpression':
        case 'ObjectExpression':
          if (r) break
        default:
          this.raise(te.InvalidRestAssignmentPattern, { at: e })
      }
    }
    checkCommaAfterRest(e) {
      return this.match(12)
        ? (this.raise(this.lookaheadCharCode() === e ? te.RestTrailingComma : te.ElementAfterRest, {
            at: this.state.startLoc,
          }),
          !0)
        : !1
    }
  }
  class dU extends hU {
    checkProto(e, r, i, n) {
      if (e.type === 'SpreadElement' || this.isObjectMethod(e) || e.computed || e.shorthand) return
      const s = e.key
      if ((s.type === 'Identifier' ? s.name : s.value) === '__proto__') {
        if (r) {
          this.raise(te.RecordNoProto, { at: s })
          return
        }
        i.used &&
          (n
            ? n.doubleProtoLoc === null && (n.doubleProtoLoc = s.loc.start)
            : this.raise(te.DuplicateProto, { at: s })),
          (i.used = !0)
      }
    }
    shouldExitDescending(e, r) {
      return e.type === 'ArrowFunctionExpression' && e.start === r
    }
    getExpression() {
      this.enterInitialScopes(), this.nextToken()
      const e = this.parseExpression()
      return (
        this.match(135) || this.unexpected(),
        this.finalizeRemainingComments(),
        (e.comments = this.state.comments),
        (e.errors = this.state.errors),
        this.options.tokens && (e.tokens = this.tokens),
        e
      )
    }
    parseExpression(e, r) {
      return e
        ? this.disallowInAnd(() => this.parseExpressionBase(r))
        : this.allowInAnd(() => this.parseExpressionBase(r))
    }
    parseExpressionBase(e) {
      const r = this.state.start,
        i = this.state.startLoc,
        n = this.parseMaybeAssign(e)
      if (this.match(12)) {
        const s = this.startNodeAt(r, i)
        for (s.expressions = [n]; this.eat(12); ) s.expressions.push(this.parseMaybeAssign(e))
        return this.toReferencedList(s.expressions), this.finishNode(s, 'SequenceExpression')
      }
      return n
    }
    parseMaybeAssignDisallowIn(e, r) {
      return this.disallowInAnd(() => this.parseMaybeAssign(e, r))
    }
    parseMaybeAssignAllowIn(e, r) {
      return this.allowInAnd(() => this.parseMaybeAssign(e, r))
    }
    setOptionalParametersError(e, r) {
      var i
      e.optionalParametersLoc = (i = r == null ? void 0 : r.loc) != null ? i : this.state.startLoc
    }
    parseMaybeAssign(e, r) {
      const i = this.state.start,
        n = this.state.startLoc
      if (this.isContextual(105) && this.prodParam.hasYield) {
        let u = this.parseYield()
        return r && (u = r.call(this, u, i, n)), u
      }
      let s
      e ? (s = !1) : ((e = new Fo()), (s = !0))
      const { type: a } = this.state
      ;(a === 10 || dt(a)) && (this.state.potentialArrowAt = this.state.start)
      let o = this.parseMaybeConditional(e)
      if ((r && (o = r.call(this, o, i, n)), WV(this.state.type))) {
        const u = this.startNodeAt(i, n),
          c = this.state.value
        return (
          (u.operator = c),
          this.match(29)
            ? (this.toAssignable(o, !0),
              (u.left = o),
              e.doubleProtoLoc != null && e.doubleProtoLoc.index >= i && (e.doubleProtoLoc = null),
              e.shorthandAssignLoc != null && e.shorthandAssignLoc.index >= i && (e.shorthandAssignLoc = null),
              e.privateKeyLoc != null &&
                e.privateKeyLoc.index >= i &&
                (this.checkDestructuringPrivate(e), (e.privateKeyLoc = null)))
            : (u.left = o),
          this.next(),
          (u.right = this.parseMaybeAssign()),
          this.checkLVal(o, { in: this.finishNode(u, 'AssignmentExpression') }),
          u
        )
      } else s && this.checkExpressionErrors(e, !0)
      return o
    }
    parseMaybeConditional(e) {
      const r = this.state.start,
        i = this.state.startLoc,
        n = this.state.potentialArrowAt,
        s = this.parseExprOps(e)
      return this.shouldExitDescending(s, n) ? s : this.parseConditional(s, r, i, e)
    }
    parseConditional(e, r, i, n) {
      if (this.eat(17)) {
        const s = this.startNodeAt(r, i)
        return (
          (s.test = e),
          (s.consequent = this.parseMaybeAssignAllowIn()),
          this.expect(14),
          (s.alternate = this.parseMaybeAssign()),
          this.finishNode(s, 'ConditionalExpression')
        )
      }
      return e
    }
    parseMaybeUnaryOrPrivate(e) {
      return this.match(134) ? this.parsePrivateName() : this.parseMaybeUnary(e)
    }
    parseExprOps(e) {
      const r = this.state.start,
        i = this.state.startLoc,
        n = this.state.potentialArrowAt,
        s = this.parseMaybeUnaryOrPrivate(e)
      return this.shouldExitDescending(s, n) ? s : this.parseExprOp(s, r, i, -1)
    }
    parseExprOp(e, r, i, n) {
      if (this.isPrivateName(e)) {
        const a = this.getPrivateNameSV(e)
        ;(n >= Eo(58) || !this.prodParam.hasIn || !this.match(58)) &&
          this.raise(te.PrivateInExpectedIn, { at: e, identifierName: a }),
          this.classScope.usePrivateName(a, e.loc.start)
      }
      const s = this.state.type
      if (HV(s) && (this.prodParam.hasIn || !this.match(58))) {
        let a = Eo(s)
        if (a > n) {
          if (s === 39) {
            if ((this.expectPlugin('pipelineOperator'), this.state.inFSharpPipelineDirectBody)) return e
            this.checkPipelineAtInfixOperator(e, i)
          }
          const o = this.startNodeAt(r, i)
          ;(o.left = e), (o.operator = this.state.value)
          const u = s === 41 || s === 42,
            c = s === 40
          if (
            (c && (a = Eo(42)),
            this.next(),
            s === 39 &&
              this.hasPlugin(['pipelineOperator', { proposal: 'minimal' }]) &&
              this.state.type === 96 &&
              this.prodParam.hasAwait)
          )
            throw this.raise(te.UnexpectedAwaitAfterPipelineBody, { at: this.state.startLoc })
          ;(o.right = this.parseExprOpRightExpr(s, a)),
            this.finishNode(o, u || c ? 'LogicalExpression' : 'BinaryExpression')
          const p = this.state.type
          if ((c && (p === 41 || p === 42)) || (u && p === 40))
            throw this.raise(te.MixingCoalesceWithLogical, { at: this.state.startLoc })
          return this.parseExprOp(o, r, i, n)
        }
      }
      return e
    }
    parseExprOpRightExpr(e, r) {
      const i = this.state.start,
        n = this.state.startLoc
      switch (e) {
        case 39:
          switch (this.getPluginOption('pipelineOperator', 'proposal')) {
            case 'hack':
              return this.withTopicBindingContext(() => this.parseHackPipeBody())
            case 'smart':
              return this.withTopicBindingContext(() => {
                if (this.prodParam.hasYield && this.isContextual(105))
                  throw this.raise(te.PipeBodyIsTighter, { at: this.state.startLoc })
                return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(e, r), i, n)
              })
            case 'fsharp':
              return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(r))
          }
        default:
          return this.parseExprOpBaseRightExpr(e, r)
      }
    }
    parseExprOpBaseRightExpr(e, r) {
      const i = this.state.start,
        n = this.state.startLoc
      return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), i, n, QV(e) ? r - 1 : r)
    }
    parseHackPipeBody() {
      var e
      const { startLoc: r } = this.state,
        i = this.parseMaybeAssign()
      return (
        LV.has(i.type) &&
          !((e = i.extra) != null && e.parenthesized) &&
          this.raise(te.PipeUnparenthesizedBody, { at: r, type: i.type }),
        this.topicReferenceWasUsedInCurrentContext() || this.raise(te.PipeTopicUnused, { at: r }),
        i
      )
    }
    checkExponentialAfterUnary(e) {
      this.match(57) && this.raise(te.UnexpectedTokenUnaryExponentiation, { at: e.argument })
    }
    parseMaybeUnary(e, r) {
      const i = this.state.start,
        n = this.state.startLoc,
        s = this.isContextual(96)
      if (s && this.isAwaitAllowed()) {
        this.next()
        const c = this.parseAwait(i, n)
        return r || this.checkExponentialAfterUnary(c), c
      }
      const a = this.match(34),
        o = this.startNode()
      if (XV(this.state.type)) {
        ;(o.operator = this.state.value), (o.prefix = !0), this.match(72) && this.expectPlugin('throwExpressions')
        const c = this.match(89)
        if (
          (this.next(),
          (o.argument = this.parseMaybeUnary(null, !0)),
          this.checkExpressionErrors(e, !0),
          this.state.strict && c)
        ) {
          const p = o.argument
          p.type === 'Identifier'
            ? this.raise(te.StrictDelete, { at: o })
            : this.hasPropertyAsPrivateName(p) && this.raise(te.DeletePrivateField, { at: o })
        }
        if (!a) return r || this.checkExponentialAfterUnary(o), this.finishNode(o, 'UnaryExpression')
      }
      const u = this.parseUpdate(o, a, e)
      if (s) {
        const { type: c } = this.state
        if ((this.hasPlugin('v8intrinsic') ? jc(c) : jc(c) && !this.match(54)) && !this.isAmbiguousAwait())
          return this.raiseOverwrite(te.AwaitNotInAsyncContext, { at: n }), this.parseAwait(i, n)
      }
      return u
    }
    parseUpdate(e, r, i) {
      if (r) return this.checkLVal(e.argument, { in: this.finishNode(e, 'UpdateExpression') }), e
      const n = this.state.start,
        s = this.state.startLoc
      let a = this.parseExprSubscripts(i)
      if (this.checkExpressionErrors(i, !1)) return a
      for (; qV(this.state.type) && !this.canInsertSemicolon(); ) {
        const o = this.startNodeAt(n, s)
        ;(o.operator = this.state.value),
          (o.prefix = !1),
          (o.argument = a),
          this.next(),
          this.checkLVal(a, { in: (a = this.finishNode(o, 'UpdateExpression')) })
      }
      return a
    }
    parseExprSubscripts(e) {
      const r = this.state.start,
        i = this.state.startLoc,
        n = this.state.potentialArrowAt,
        s = this.parseExprAtom(e)
      return this.shouldExitDescending(s, n) ? s : this.parseSubscripts(s, r, i)
    }
    parseSubscripts(e, r, i, n) {
      const s = { optionalChainMember: !1, maybeAsyncArrow: this.atPossibleAsyncArrow(e), stop: !1 }
      do (e = this.parseSubscript(e, r, i, n, s)), (s.maybeAsyncArrow = !1)
      while (!s.stop)
      return e
    }
    parseSubscript(e, r, i, n, s) {
      const { type: a } = this.state
      if (!n && a === 15) return this.parseBind(e, r, i, n, s)
      if (Po(a)) return this.parseTaggedTemplateExpression(e, r, i, s)
      let o = !1
      if (a === 18) {
        if (n && this.lookaheadCharCode() === 40) return (s.stop = !0), e
        ;(s.optionalChainMember = o = !0), this.next()
      }
      if (!n && this.match(10)) return this.parseCoverCallAndAsyncArrowHead(e, r, i, s, o)
      {
        const u = this.eat(0)
        return u || o || this.eat(16) ? this.parseMember(e, r, i, s, u, o) : ((s.stop = !0), e)
      }
    }
    parseMember(e, r, i, n, s, a) {
      const o = this.startNodeAt(r, i)
      return (
        (o.object = e),
        (o.computed = s),
        s
          ? ((o.property = this.parseExpression()), this.expect(3))
          : this.match(134)
          ? (e.type === 'Super' && this.raise(te.SuperPrivateField, { at: i }),
            this.classScope.usePrivateName(this.state.value, this.state.startLoc),
            (o.property = this.parsePrivateName()))
          : (o.property = this.parseIdentifier(!0)),
        n.optionalChainMember
          ? ((o.optional = a), this.finishNode(o, 'OptionalMemberExpression'))
          : this.finishNode(o, 'MemberExpression')
      )
    }
    parseBind(e, r, i, n, s) {
      const a = this.startNodeAt(r, i)
      return (
        (a.object = e),
        this.next(),
        (a.callee = this.parseNoCallExpr()),
        (s.stop = !0),
        this.parseSubscripts(this.finishNode(a, 'BindExpression'), r, i, n)
      )
    }
    parseCoverCallAndAsyncArrowHead(e, r, i, n, s) {
      const a = this.state.maybeInArrowParameters
      let o = null
      ;(this.state.maybeInArrowParameters = !0), this.next()
      let u = this.startNodeAt(r, i)
      u.callee = e
      const { maybeAsyncArrow: c, optionalChainMember: p } = n
      return (
        c && (this.expressionScope.enter(R7()), (o = new Fo())),
        p && (u.optional = s),
        s
          ? (u.arguments = this.parseCallExpressionArguments(11))
          : (u.arguments = this.parseCallExpressionArguments(11, e.type === 'Import', e.type !== 'Super', u, o)),
        this.finishCallExpression(u, p),
        c && this.shouldParseAsyncArrow() && !s
          ? ((n.stop = !0),
            this.checkDestructuringPrivate(o),
            this.expressionScope.validateAsPattern(),
            this.expressionScope.exit(),
            (u = this.parseAsyncArrowFromCallExpression(this.startNodeAt(r, i), u)))
          : (c && (this.checkExpressionErrors(o, !0), this.expressionScope.exit()), this.toReferencedArguments(u)),
        (this.state.maybeInArrowParameters = a),
        u
      )
    }
    toReferencedArguments(e, r) {
      this.toReferencedListDeep(e.arguments, r)
    }
    parseTaggedTemplateExpression(e, r, i, n) {
      const s = this.startNodeAt(r, i)
      return (
        (s.tag = e),
        (s.quasi = this.parseTemplate(!0)),
        n.optionalChainMember && this.raise(te.OptionalChainingNoTemplate, { at: i }),
        this.finishNode(s, 'TaggedTemplateExpression')
      )
    }
    atPossibleAsyncArrow(e) {
      return (
        e.type === 'Identifier' &&
        e.name === 'async' &&
        this.state.lastTokEndLoc.index === e.end &&
        !this.canInsertSemicolon() &&
        e.end - e.start === 5 &&
        e.start === this.state.potentialArrowAt
      )
    }
    finishCallExpression(e, r) {
      if (e.callee.type === 'Import')
        if (
          (e.arguments.length === 2 && (this.hasPlugin('moduleAttributes') || this.expectPlugin('importAssertions')),
          e.arguments.length === 0 || e.arguments.length > 2)
        )
          this.raise(te.ImportCallArity, {
            at: e,
            maxArgumentCount: this.hasPlugin('importAssertions') || this.hasPlugin('moduleAttributes') ? 2 : 1,
          })
        else
          for (const i of e.arguments) i.type === 'SpreadElement' && this.raise(te.ImportCallSpreadArgument, { at: i })
      return this.finishNode(e, r ? 'OptionalCallExpression' : 'CallExpression')
    }
    parseCallExpressionArguments(e, r, i, n, s) {
      const a = []
      let o = !0
      const u = this.state.inFSharpPipelineDirectBody
      for (this.state.inFSharpPipelineDirectBody = !1; !this.eat(e); ) {
        if (o) o = !1
        else if ((this.expect(12), this.match(e))) {
          r &&
            !this.hasPlugin('importAssertions') &&
            !this.hasPlugin('moduleAttributes') &&
            this.raise(te.ImportCallArgumentTrailingComma, { at: this.state.lastTokStartLoc }),
            n && this.addTrailingCommaExtraToNode(n),
            this.next()
          break
        }
        a.push(this.parseExprListItem(!1, s, i))
      }
      return (this.state.inFSharpPipelineDirectBody = u), a
    }
    shouldParseAsyncArrow() {
      return this.match(19) && !this.canInsertSemicolon()
    }
    parseAsyncArrowFromCallExpression(e, r) {
      var i
      return (
        this.resetPreviousNodeTrailingComments(r),
        this.expect(19),
        this.parseArrowExpression(e, r.arguments, !0, (i = r.extra) == null ? void 0 : i.trailingCommaLoc),
        r.innerComments && Ds(e, r.innerComments),
        r.callee.trailingComments && Ds(e, r.callee.trailingComments),
        e
      )
    }
    parseNoCallExpr() {
      const e = this.state.start,
        r = this.state.startLoc
      return this.parseSubscripts(this.parseExprAtom(), e, r, !0)
    }
    parseExprAtom(e) {
      let r
      const { type: i } = this.state
      switch (i) {
        case 79:
          return this.parseSuper()
        case 83:
          return (
            (r = this.startNode()),
            this.next(),
            this.match(16)
              ? this.parseImportMetaProperty(r)
              : (this.match(10) || this.raise(te.UnsupportedImport, { at: this.state.lastTokStartLoc }),
                this.finishNode(r, 'Import'))
          )
        case 78:
          return (r = this.startNode()), this.next(), this.finishNode(r, 'ThisExpression')
        case 90:
          return this.parseDo(this.startNode(), !1)
        case 56:
        case 31:
          return this.readRegexp(), this.parseRegExpLiteral(this.state.value)
        case 130:
          return this.parseNumericLiteral(this.state.value)
        case 131:
          return this.parseBigIntLiteral(this.state.value)
        case 132:
          return this.parseDecimalLiteral(this.state.value)
        case 129:
          return this.parseStringLiteral(this.state.value)
        case 84:
          return this.parseNullLiteral()
        case 85:
          return this.parseBooleanLiteral(!0)
        case 86:
          return this.parseBooleanLiteral(!1)
        case 10: {
          const n = this.state.potentialArrowAt === this.state.start
          return this.parseParenAndDistinguishExpression(n)
        }
        case 2:
        case 1:
          return this.parseArrayLike(this.state.type === 2 ? 4 : 3, !1, !0)
        case 0:
          return this.parseArrayLike(3, !0, !1, e)
        case 6:
        case 7:
          return this.parseObjectLike(this.state.type === 6 ? 9 : 8, !1, !0)
        case 5:
          return this.parseObjectLike(8, !1, !1, e)
        case 68:
          return this.parseFunctionOrFunctionSent()
        case 26:
          this.parseDecorators()
        case 80:
          return (r = this.startNode()), this.takeDecorators(r), this.parseClass(r, !1)
        case 77:
          return this.parseNewOrNewTarget()
        case 25:
        case 24:
          return this.parseTemplate(!1)
        case 15: {
          ;(r = this.startNode()), this.next(), (r.object = null)
          const n = (r.callee = this.parseNoCallExpr())
          if (n.type === 'MemberExpression') return this.finishNode(r, 'BindExpression')
          throw this.raise(te.UnsupportedBind, { at: n })
        }
        case 134:
          return (
            this.raise(te.PrivateInExpectedIn, { at: this.state.startLoc, identifierName: this.state.value }),
            this.parsePrivateName()
          )
        case 33:
          return this.parseTopicReferenceThenEqualsSign(54, '%')
        case 32:
          return this.parseTopicReferenceThenEqualsSign(44, '^')
        case 37:
        case 38:
          return this.parseTopicReference('hack')
        case 44:
        case 54:
        case 27: {
          const n = this.getPluginOption('pipelineOperator', 'proposal')
          if (n) return this.parseTopicReference(n)
          throw this.unexpected()
        }
        case 47: {
          const n = this.input.codePointAt(this.nextTokenStart())
          if (Xr(n) || n === 62) {
            this.expectOnePlugin(['jsx', 'flow', 'typescript'])
            break
          } else throw this.unexpected()
        }
        default:
          if (dt(i)) {
            if (this.isContextual(123) && this.lookaheadCharCode() === 123 && !this.hasFollowingLineBreak())
              return this.parseModuleExpression()
            const n = this.state.potentialArrowAt === this.state.start,
              s = this.state.containsEsc,
              a = this.parseIdentifier()
            if (!s && a.name === 'async' && !this.canInsertSemicolon()) {
              const { type: o } = this.state
              if (o === 68)
                return (
                  this.resetPreviousNodeTrailingComments(a),
                  this.next(),
                  this.parseFunction(this.startNodeAtNode(a), void 0, !0)
                )
              if (dt(o))
                return this.lookaheadCharCode() === 61 ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(a)) : a
              if (o === 90) return this.resetPreviousNodeTrailingComments(a), this.parseDo(this.startNodeAtNode(a), !0)
            }
            return n && this.match(19) && !this.canInsertSemicolon()
              ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(a), [a], !1))
              : a
          } else throw this.unexpected()
      }
    }
    parseTopicReferenceThenEqualsSign(e, r) {
      const i = this.getPluginOption('pipelineOperator', 'proposal')
      if (i)
        return (
          (this.state.type = e),
          (this.state.value = r),
          this.state.pos--,
          this.state.end--,
          (this.state.endLoc = zt(this.state.endLoc, -1)),
          this.parseTopicReference(i)
        )
      throw this.unexpected()
    }
    parseTopicReference(e) {
      const r = this.startNode(),
        i = this.state.startLoc,
        n = this.state.type
      return this.next(), this.finishTopicReference(r, i, e, n)
    }
    finishTopicReference(e, r, i, n) {
      if (this.testTopicReferenceConfiguration(i, r, n)) {
        const s = i === 'smart' ? 'PipelinePrimaryTopicReference' : 'TopicReference'
        return (
          this.topicReferenceIsAllowedInCurrentContext() ||
            this.raise(i === 'smart' ? te.PrimaryTopicNotAllowed : te.PipeTopicUnbound, { at: r }),
          this.registerTopicReference(),
          this.finishNode(e, s)
        )
      } else throw this.raise(te.PipeTopicUnconfiguredToken, { at: r, token: gi(n) })
    }
    testTopicReferenceConfiguration(e, r, i) {
      switch (e) {
        case 'hack':
          return this.hasPlugin(['pipelineOperator', { topicToken: gi(i) }])
        case 'smart':
          return i === 27
        default:
          throw this.raise(te.PipeTopicRequiresHackPipes, { at: r })
      }
    }
    parseAsyncArrowUnaryFunction(e) {
      this.prodParam.enter(Mo(!0, this.prodParam.hasYield))
      const r = [this.parseIdentifier()]
      return (
        this.prodParam.exit(),
        this.hasPrecedingLineBreak() && this.raise(te.LineTerminatorBeforeArrow, { at: this.state.curPosition() }),
        this.expect(19),
        this.parseArrowExpression(e, r, !0),
        e
      )
    }
    parseDo(e, r) {
      this.expectPlugin('doExpressions'), r && this.expectPlugin('asyncDoExpressions'), (e.async = r), this.next()
      const i = this.state.labels
      return (
        (this.state.labels = []),
        r
          ? (this.prodParam.enter(Lo), (e.body = this.parseBlock()), this.prodParam.exit())
          : (e.body = this.parseBlock()),
        (this.state.labels = i),
        this.finishNode(e, 'DoExpression')
      )
    }
    parseSuper() {
      const e = this.startNode()
      return (
        this.next(),
        this.match(10) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod
          ? this.raise(te.SuperNotAllowed, { at: e })
          : !this.scope.allowSuper &&
            !this.options.allowSuperOutsideMethod &&
            this.raise(te.UnexpectedSuper, { at: e }),
        !this.match(10) && !this.match(0) && !this.match(16) && this.raise(te.UnsupportedSuper, { at: e }),
        this.finishNode(e, 'Super')
      )
    }
    parsePrivateName() {
      const e = this.startNode(),
        r = this.startNodeAt(
          this.state.start + 1,
          new en(this.state.curLine, this.state.start + 1 - this.state.lineStart, this.state.start + 1)
        ),
        i = this.state.value
      return this.next(), (e.id = this.createIdentifier(r, i)), this.finishNode(e, 'PrivateName')
    }
    parseFunctionOrFunctionSent() {
      const e = this.startNode()
      if ((this.next(), this.prodParam.hasYield && this.match(16))) {
        const r = this.createIdentifier(this.startNodeAtNode(e), 'function')
        return (
          this.next(),
          this.match(102) ? this.expectPlugin('functionSent') : this.hasPlugin('functionSent') || this.unexpected(),
          this.parseMetaProperty(e, r, 'sent')
        )
      }
      return this.parseFunction(e)
    }
    parseMetaProperty(e, r, i) {
      e.meta = r
      const n = this.state.containsEsc
      return (
        (e.property = this.parseIdentifier(!0)),
        (e.property.name !== i || n) &&
          this.raise(te.UnsupportedMetaProperty, { at: e.property, target: r.name, onlyValidPropertyName: i }),
        this.finishNode(e, 'MetaProperty')
      )
    }
    parseImportMetaProperty(e) {
      const r = this.createIdentifier(this.startNodeAtNode(e), 'import')
      return (
        this.next(),
        this.isContextual(100) &&
          (this.inModule || this.raise(te.ImportMetaOutsideModule, { at: r }), (this.sawUnambiguousESM = !0)),
        this.parseMetaProperty(e, r, 'meta')
      )
    }
    parseLiteralAtNode(e, r, i) {
      return (
        this.addExtra(i, 'rawValue', e),
        this.addExtra(i, 'raw', this.input.slice(i.start, this.state.end)),
        (i.value = e),
        this.next(),
        this.finishNode(i, r)
      )
    }
    parseLiteral(e, r) {
      const i = this.startNode()
      return this.parseLiteralAtNode(e, r, i)
    }
    parseStringLiteral(e) {
      return this.parseLiteral(e, 'StringLiteral')
    }
    parseNumericLiteral(e) {
      return this.parseLiteral(e, 'NumericLiteral')
    }
    parseBigIntLiteral(e) {
      return this.parseLiteral(e, 'BigIntLiteral')
    }
    parseDecimalLiteral(e) {
      return this.parseLiteral(e, 'DecimalLiteral')
    }
    parseRegExpLiteral(e) {
      const r = this.parseLiteral(e.value, 'RegExpLiteral')
      return (r.pattern = e.pattern), (r.flags = e.flags), r
    }
    parseBooleanLiteral(e) {
      const r = this.startNode()
      return (r.value = e), this.next(), this.finishNode(r, 'BooleanLiteral')
    }
    parseNullLiteral() {
      const e = this.startNode()
      return this.next(), this.finishNode(e, 'NullLiteral')
    }
    parseParenAndDistinguishExpression(e) {
      const r = this.state.start,
        i = this.state.startLoc
      let n
      this.next(), this.expressionScope.enter($7())
      const s = this.state.maybeInArrowParameters,
        a = this.state.inFSharpPipelineDirectBody
      ;(this.state.maybeInArrowParameters = !0), (this.state.inFSharpPipelineDirectBody = !1)
      const o = this.state.start,
        u = this.state.startLoc,
        c = [],
        p = new Fo()
      let h = !0,
        f,
        d
      for (; !this.match(11); ) {
        if (h) h = !1
        else if ((this.expect(12, p.optionalParametersLoc === null ? null : p.optionalParametersLoc), this.match(11))) {
          d = this.state.startLoc
          break
        }
        if (this.match(21)) {
          const b = this.state.start,
            m = this.state.startLoc
          if (
            ((f = this.state.startLoc),
            c.push(this.parseParenItem(this.parseRestBinding(), b, m)),
            !this.checkCommaAfterRest(41))
          )
            break
        } else c.push(this.parseMaybeAssignAllowIn(p, this.parseParenItem))
      }
      const T = this.state.lastTokEndLoc
      this.expect(11), (this.state.maybeInArrowParameters = s), (this.state.inFSharpPipelineDirectBody = a)
      let y = this.startNodeAt(r, i)
      return e && this.shouldParseArrow(c) && (y = this.parseArrow(y))
        ? (this.checkDestructuringPrivate(p),
          this.expressionScope.validateAsPattern(),
          this.expressionScope.exit(),
          this.parseArrowExpression(y, c, !1),
          y)
        : (this.expressionScope.exit(),
          c.length || this.unexpected(this.state.lastTokStartLoc),
          d && this.unexpected(d),
          f && this.unexpected(f),
          this.checkExpressionErrors(p, !0),
          this.toReferencedListDeep(c, !0),
          c.length > 1
            ? ((n = this.startNodeAt(o, u)),
              (n.expressions = c),
              this.finishNode(n, 'SequenceExpression'),
              this.resetEndLocation(n, T))
            : (n = c[0]),
          this.wrapParenthesis(r, i, n))
    }
    wrapParenthesis(e, r, i) {
      if (!this.options.createParenthesizedExpressions)
        return (
          this.addExtra(i, 'parenthesized', !0),
          this.addExtra(i, 'parenStart', e),
          this.takeSurroundingComments(i, e, this.state.lastTokEndLoc.index),
          i
        )
      const n = this.startNodeAt(e, r)
      return (n.expression = i), this.finishNode(n, 'ParenthesizedExpression'), n
    }
    shouldParseArrow(e) {
      return !this.canInsertSemicolon()
    }
    parseArrow(e) {
      if (this.eat(19)) return e
    }
    parseParenItem(e, r, i) {
      return e
    }
    parseNewOrNewTarget() {
      const e = this.startNode()
      if ((this.next(), this.match(16))) {
        const r = this.createIdentifier(this.startNodeAtNode(e), 'new')
        this.next()
        const i = this.parseMetaProperty(e, r, 'target')
        return !this.scope.inNonArrowFunction && !this.scope.inClass && this.raise(te.UnexpectedNewTarget, { at: i }), i
      }
      return this.parseNew(e)
    }
    parseNew(e) {
      if ((this.parseNewCallee(e), this.eat(10))) {
        const r = this.parseExprList(11)
        this.toReferencedList(r), (e.arguments = r)
      } else e.arguments = []
      return this.finishNode(e, 'NewExpression')
    }
    parseNewCallee(e) {
      ;(e.callee = this.parseNoCallExpr()),
        e.callee.type === 'Import'
          ? this.raise(te.ImportCallNotNewExpression, { at: e.callee })
          : this.isOptionalChain(e.callee)
          ? this.raise(te.OptionalChainingNoNew, { at: this.state.lastTokEndLoc })
          : this.eat(18) && this.raise(te.OptionalChainingNoNew, { at: this.state.startLoc })
    }
    parseTemplateElement(e) {
      const { start: r, startLoc: i, end: n, value: s } = this.state,
        a = r + 1,
        o = this.startNodeAt(a, zt(i, 1))
      s === null && (e || this.raise(te.InvalidEscapeSequenceTemplate, { at: zt(i, 2) }))
      const u = this.match(24),
        c = u ? -1 : -2,
        p = n + c
      return (
        (o.value = {
          raw: this.input.slice(a, p).replace(
            /\r\n?/g,
            `
`
          ),
          cooked: s === null ? null : s.slice(1, c),
        }),
        (o.tail = u),
        this.next(),
        this.finishNode(o, 'TemplateElement'),
        this.resetEndLocation(o, zt(this.state.lastTokEndLoc, c)),
        o
      )
    }
    parseTemplate(e) {
      const r = this.startNode()
      r.expressions = []
      let i = this.parseTemplateElement(e)
      for (r.quasis = [i]; !i.tail; )
        r.expressions.push(this.parseTemplateSubstitution()),
          this.readTemplateContinuation(),
          r.quasis.push((i = this.parseTemplateElement(e)))
      return this.finishNode(r, 'TemplateLiteral')
    }
    parseTemplateSubstitution() {
      return this.parseExpression()
    }
    parseObjectLike(e, r, i, n) {
      i && this.expectPlugin('recordAndTuple')
      const s = this.state.inFSharpPipelineDirectBody
      this.state.inFSharpPipelineDirectBody = !1
      const a = Object.create(null)
      let o = !0
      const u = this.startNode()
      for (u.properties = [], this.next(); !this.match(e); ) {
        if (o) o = !1
        else if ((this.expect(12), this.match(e))) {
          this.addTrailingCommaExtraToNode(u)
          break
        }
        let p
        r ? (p = this.parseBindingProperty()) : ((p = this.parsePropertyDefinition(n)), this.checkProto(p, i, a, n)),
          i &&
            !this.isObjectProperty(p) &&
            p.type !== 'SpreadElement' &&
            this.raise(te.InvalidRecordProperty, { at: p }),
          p.shorthand && this.addExtra(p, 'shorthand', !0),
          u.properties.push(p)
      }
      this.next(), (this.state.inFSharpPipelineDirectBody = s)
      let c = 'ObjectExpression'
      return r ? (c = 'ObjectPattern') : i && (c = 'RecordExpression'), this.finishNode(u, c)
    }
    addTrailingCommaExtraToNode(e) {
      this.addExtra(e, 'trailingComma', this.state.lastTokStart),
        this.addExtra(e, 'trailingCommaLoc', this.state.lastTokStartLoc, !1)
    }
    maybeAsyncOrAccessorProp(e) {
      return (
        !e.computed && e.key.type === 'Identifier' && (this.isLiteralPropertyName() || this.match(0) || this.match(55))
      )
    }
    parsePropertyDefinition(e) {
      let r = []
      if (this.match(26))
        for (
          this.hasPlugin('decorators') && this.raise(te.UnsupportedPropertyDecorator, { at: this.state.startLoc });
          this.match(26);

        )
          r.push(this.parseDecorator())
      const i = this.startNode()
      let n = !1,
        s = !1,
        a,
        o
      if (this.match(21)) return r.length && this.unexpected(), this.parseSpread()
      r.length && ((i.decorators = r), (r = [])),
        (i.method = !1),
        e && ((a = this.state.start), (o = this.state.startLoc))
      let u = this.eat(55)
      this.parsePropertyNamePrefixOperator(i)
      const c = this.state.containsEsc,
        p = this.parsePropertyName(i, e)
      if (!u && !c && this.maybeAsyncOrAccessorProp(i)) {
        const h = p.name
        h === 'async' &&
          !this.hasPrecedingLineBreak() &&
          ((n = !0), this.resetPreviousNodeTrailingComments(p), (u = this.eat(55)), this.parsePropertyName(i)),
          (h === 'get' || h === 'set') &&
            ((s = !0),
            this.resetPreviousNodeTrailingComments(p),
            (i.kind = h),
            this.match(55) &&
              ((u = !0), this.raise(te.AccessorIsGenerator, { at: this.state.curPosition(), kind: h }), this.next()),
            this.parsePropertyName(i))
      }
      return this.parseObjPropValue(i, a, o, u, n, !1, s, e), i
    }
    getGetterSetterExpectedParamCount(e) {
      return e.kind === 'get' ? 0 : 1
    }
    getObjectOrClassMethodParams(e) {
      return e.params
    }
    checkGetterSetterParams(e) {
      var r
      const i = this.getGetterSetterExpectedParamCount(e),
        n = this.getObjectOrClassMethodParams(e)
      n.length !== i && this.raise(e.kind === 'get' ? te.BadGetterArity : te.BadSetterArity, { at: e }),
        e.kind === 'set' &&
          ((r = n[n.length - 1]) == null ? void 0 : r.type) === 'RestElement' &&
          this.raise(te.BadSetterRestParameter, { at: e })
    }
    parseObjectMethod(e, r, i, n, s) {
      if (s) return this.parseMethod(e, r, !1, !1, !1, 'ObjectMethod'), this.checkGetterSetterParams(e), e
      if (i || r || this.match(10))
        return (
          n && this.unexpected(),
          (e.kind = 'method'),
          (e.method = !0),
          this.parseMethod(e, r, i, !1, !1, 'ObjectMethod')
        )
    }
    parseObjectProperty(e, r, i, n, s) {
      if (((e.shorthand = !1), this.eat(14)))
        return (
          (e.value = n
            ? this.parseMaybeDefault(this.state.start, this.state.startLoc)
            : this.parseMaybeAssignAllowIn(s)),
          this.finishNode(e, 'ObjectProperty')
        )
      if (!e.computed && e.key.type === 'Identifier') {
        if ((this.checkReservedWord(e.key.name, e.key.loc.start, !0, !1), n))
          e.value = this.parseMaybeDefault(r, i, Qr(e.key))
        else if (this.match(29)) {
          const a = this.state.startLoc
          s != null
            ? s.shorthandAssignLoc === null && (s.shorthandAssignLoc = a)
            : this.raise(te.InvalidCoverInitializedName, { at: a }),
            (e.value = this.parseMaybeDefault(r, i, Qr(e.key)))
        } else e.value = Qr(e.key)
        return (e.shorthand = !0), this.finishNode(e, 'ObjectProperty')
      }
    }
    parseObjPropValue(e, r, i, n, s, a, o, u) {
      const c = this.parseObjectMethod(e, n, s, a, o) || this.parseObjectProperty(e, r, i, a, u)
      return c || this.unexpected(), c
    }
    parsePropertyName(e, r) {
      if (this.eat(0)) (e.computed = !0), (e.key = this.parseMaybeAssignAllowIn()), this.expect(3)
      else {
        const { type: i, value: n } = this.state
        let s
        if (Hr(i)) s = this.parseIdentifier(!0)
        else
          switch (i) {
            case 130:
              s = this.parseNumericLiteral(n)
              break
            case 129:
              s = this.parseStringLiteral(n)
              break
            case 131:
              s = this.parseBigIntLiteral(n)
              break
            case 132:
              s = this.parseDecimalLiteral(n)
              break
            case 134: {
              const a = this.state.startLoc
              r != null
                ? r.privateKeyLoc === null && (r.privateKeyLoc = a)
                : this.raise(te.UnexpectedPrivateField, { at: a }),
                (s = this.parsePrivateName())
              break
            }
            default:
              throw this.unexpected()
          }
        ;(e.key = s), i !== 134 && (e.computed = !1)
      }
      return e.key
    }
    initFunction(e, r) {
      ;(e.id = null), (e.generator = !1), (e.async = !!r)
    }
    parseMethod(e, r, i, n, s, a, o = !1) {
      this.initFunction(e, i), (e.generator = !!r)
      const u = n
      return (
        this.scope.enter(Gr | wo | (o ? tn : 0) | (s ? Xy : 0)),
        this.prodParam.enter(Mo(i, e.generator)),
        this.parseFunctionParams(e, u),
        this.parseFunctionBodyAndFinish(e, a, !0),
        this.prodParam.exit(),
        this.scope.exit(),
        e
      )
    }
    parseArrayLike(e, r, i, n) {
      i && this.expectPlugin('recordAndTuple')
      const s = this.state.inFSharpPipelineDirectBody
      this.state.inFSharpPipelineDirectBody = !1
      const a = this.startNode()
      return (
        this.next(),
        (a.elements = this.parseExprList(e, !i, n, a)),
        (this.state.inFSharpPipelineDirectBody = s),
        this.finishNode(a, i ? 'TupleExpression' : 'ArrayExpression')
      )
    }
    parseArrowExpression(e, r, i, n) {
      this.scope.enter(Gr | Kc)
      let s = Mo(i, !1)
      !this.match(5) && this.prodParam.hasIn && (s |= Mn), this.prodParam.enter(s), this.initFunction(e, i)
      const a = this.state.maybeInArrowParameters
      return (
        r && ((this.state.maybeInArrowParameters = !0), this.setArrowFunctionParameters(e, r, n)),
        (this.state.maybeInArrowParameters = !1),
        this.parseFunctionBody(e, !0),
        this.prodParam.exit(),
        this.scope.exit(),
        (this.state.maybeInArrowParameters = a),
        this.finishNode(e, 'ArrowFunctionExpression')
      )
    }
    setArrowFunctionParameters(e, r, i) {
      this.toAssignableList(r, i, !1), (e.params = r)
    }
    parseFunctionBodyAndFinish(e, r, i = !1) {
      this.parseFunctionBody(e, !1, i), this.finishNode(e, r)
    }
    parseFunctionBody(e, r, i = !1) {
      const n = r && !this.match(5)
      if ((this.expressionScope.enter(l0()), n)) (e.body = this.parseMaybeAssign()), this.checkParams(e, !1, r, !1)
      else {
        const s = this.state.strict,
          a = this.state.labels
        ;(this.state.labels = []),
          this.prodParam.enter(this.prodParam.currentFlags() | c0),
          (e.body = this.parseBlock(!0, !1, (o) => {
            const u = !this.isSimpleParamList(e.params)
            o &&
              u &&
              this.raise(te.IllegalLanguageModeDirective, {
                at: (e.kind === 'method' || e.kind === 'constructor') && !!e.key ? e.key.loc.end : e,
              })
            const c = !s && this.state.strict
            this.checkParams(e, !this.state.strict && !r && !i && !u, r, c),
              this.state.strict && e.id && this.checkIdentifier(e.id, f7, c)
          })),
          this.prodParam.exit(),
          (this.state.labels = a)
      }
      this.expressionScope.exit()
    }
    isSimpleParameter(e) {
      return e.type === 'Identifier'
    }
    isSimpleParamList(e) {
      for (let r = 0, i = e.length; r < i; r++) if (!this.isSimpleParameter(e[r])) return !1
      return !0
    }
    checkParams(e, r, i, n = !0) {
      const s = !r && new Set(),
        a = { type: 'FormalParameters' }
      for (const o of e.params) this.checkLVal(o, { in: a, binding: ko, checkClashes: s, strictModeChanged: n })
    }
    parseExprList(e, r, i, n) {
      const s = []
      let a = !0
      for (; !this.eat(e); ) {
        if (a) a = !1
        else if ((this.expect(12), this.match(e))) {
          n && this.addTrailingCommaExtraToNode(n), this.next()
          break
        }
        s.push(this.parseExprListItem(r, i))
      }
      return s
    }
    parseExprListItem(e, r, i) {
      let n
      if (this.match(12))
        e || this.raise(te.UnexpectedToken, { at: this.state.curPosition(), unexpected: ',' }), (n = null)
      else if (this.match(21)) {
        const s = this.state.start,
          a = this.state.startLoc
        n = this.parseParenItem(this.parseSpread(r), s, a)
      } else if (this.match(17)) {
        this.expectPlugin('partialApplication'),
          i || this.raise(te.UnexpectedArgumentPlaceholder, { at: this.state.startLoc })
        const s = this.startNode()
        this.next(), (n = this.finishNode(s, 'ArgumentPlaceholder'))
      } else n = this.parseMaybeAssignAllowIn(r, this.parseParenItem)
      return n
    }
    parseIdentifier(e) {
      const r = this.startNode(),
        i = this.parseIdentifierName(r.start, e)
      return this.createIdentifier(r, i)
    }
    createIdentifier(e, r) {
      return (e.name = r), (e.loc.identifierName = r), this.finishNode(e, 'Identifier')
    }
    parseIdentifierName(e, r) {
      let i
      const { startLoc: n, type: s } = this.state
      if (Hr(s)) i = this.state.value
      else throw this.unexpected()
      const a = zV(s)
      return r ? a && this.replaceToken(128) : this.checkReservedWord(i, n, a, !1), this.next(), i
    }
    checkReservedWord(e, r, i, n) {
      if (e.length > 10 || !u7(e)) return
      if (e === 'yield') {
        if (this.prodParam.hasYield) {
          this.raise(te.YieldBindingIdentifier, { at: r })
          return
        }
      } else if (e === 'await') {
        if (this.prodParam.hasAwait) {
          this.raise(te.AwaitBindingIdentifier, { at: r })
          return
        }
        if (this.scope.inStaticBlock) {
          this.raise(te.AwaitBindingIdentifierInStaticBlock, { at: r })
          return
        }
        this.expressionScope.recordAsyncArrowParametersError({ at: r })
      } else if (e === 'arguments' && this.scope.inClassAndNotInNonArrowFunction) {
        this.raise(te.ArgumentsInClass, { at: r })
        return
      }
      if (i && a7(e)) {
        this.raise(te.UnexpectedKeyword, { at: r, keyword: e })
        return
      }
      ;(this.state.strict ? (n ? Hy : Wy) : Ky)(e, this.inModule) &&
        this.raise(te.UnexpectedReservedWord, { at: r, reservedWord: e })
    }
    isAwaitAllowed() {
      return !!(this.prodParam.hasAwait || (this.options.allowAwaitOutsideFunction && !this.scope.inFunction))
    }
    parseAwait(e, r) {
      const i = this.startNodeAt(e, r)
      return (
        this.expressionScope.recordParameterInitializerError(te.AwaitExpressionFormalParameter, { at: i }),
        this.eat(55) && this.raise(te.ObsoleteAwaitStar, { at: i }),
        !this.scope.inFunction &&
          !this.options.allowAwaitOutsideFunction &&
          (this.isAmbiguousAwait() ? (this.ambiguousScriptDifferentAst = !0) : (this.sawUnambiguousESM = !0)),
        this.state.soloAwait || (i.argument = this.parseMaybeUnary(null, !0)),
        this.finishNode(i, 'AwaitExpression')
      )
    }
    isAmbiguousAwait() {
      if (this.hasPrecedingLineBreak()) return !0
      const { type: e } = this.state
      return (
        e === 53 || e === 10 || e === 0 || Po(e) || e === 133 || e === 56 || (this.hasPlugin('v8intrinsic') && e === 54)
      )
    }
    parseYield() {
      const e = this.startNode()
      this.expressionScope.recordParameterInitializerError(te.YieldInParameter, { at: e }), this.next()
      let r = !1,
        i = null
      if (!this.hasPrecedingLineBreak())
        switch (((r = this.eat(55)), this.state.type)) {
          case 13:
          case 135:
          case 8:
          case 11:
          case 3:
          case 9:
          case 14:
          case 12:
            if (!r) break
          default:
            i = this.parseMaybeAssign()
        }
      return (e.delegate = r), (e.argument = i), this.finishNode(e, 'YieldExpression')
    }
    checkPipelineAtInfixOperator(e, r) {
      this.hasPlugin(['pipelineOperator', { proposal: 'smart' }]) &&
        e.type === 'SequenceExpression' &&
        this.raise(te.PipelineHeadSequenceExpression, { at: r })
    }
    parseSmartPipelineBodyInStyle(e, r, i) {
      const n = this.startNodeAt(r, i)
      return this.isSimpleReference(e)
        ? ((n.callee = e), this.finishNode(n, 'PipelineBareFunction'))
        : (this.checkSmartPipeTopicBodyEarlyErrors(i),
          (n.expression = e),
          this.finishNode(n, 'PipelineTopicExpression'))
    }
    isSimpleReference(e) {
      switch (e.type) {
        case 'MemberExpression':
          return !e.computed && this.isSimpleReference(e.object)
        case 'Identifier':
          return !0
        default:
          return !1
      }
    }
    checkSmartPipeTopicBodyEarlyErrors(e) {
      if (this.match(19)) throw this.raise(te.PipelineBodyNoArrow, { at: this.state.startLoc })
      this.topicReferenceWasUsedInCurrentContext() || this.raise(te.PipelineTopicUnused, { at: e })
    }
    withTopicBindingContext(e) {
      const r = this.state.topicContext
      this.state.topicContext = { maxNumOfResolvableTopics: 1, maxTopicIndex: null }
      try {
        return e()
      } finally {
        this.state.topicContext = r
      }
    }
    withSmartMixTopicForbiddingContext(e) {
      if (this.hasPlugin(['pipelineOperator', { proposal: 'smart' }])) {
        const r = this.state.topicContext
        this.state.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null }
        try {
          return e()
        } finally {
          this.state.topicContext = r
        }
      } else return e()
    }
    withSoloAwaitPermittingContext(e) {
      const r = this.state.soloAwait
      this.state.soloAwait = !0
      try {
        return e()
      } finally {
        this.state.soloAwait = r
      }
    }
    allowInAnd(e) {
      const r = this.prodParam.currentFlags()
      if (Mn & ~r) {
        this.prodParam.enter(r | Mn)
        try {
          return e()
        } finally {
          this.prodParam.exit()
        }
      }
      return e()
    }
    disallowInAnd(e) {
      const r = this.prodParam.currentFlags()
      if (Mn & r) {
        this.prodParam.enter(r & ~Mn)
        try {
          return e()
        } finally {
          this.prodParam.exit()
        }
      }
      return e()
    }
    registerTopicReference() {
      this.state.topicContext.maxTopicIndex = 0
    }
    topicReferenceIsAllowedInCurrentContext() {
      return this.state.topicContext.maxNumOfResolvableTopics >= 1
    }
    topicReferenceWasUsedInCurrentContext() {
      return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0
    }
    parseFSharpPipelineBody(e) {
      const r = this.state.start,
        i = this.state.startLoc
      this.state.potentialArrowAt = this.state.start
      const n = this.state.inFSharpPipelineDirectBody
      this.state.inFSharpPipelineDirectBody = !0
      const s = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), r, i, e)
      return (this.state.inFSharpPipelineDirectBody = n), s
    }
    parseModuleExpression() {
      this.expectPlugin('moduleBlocks')
      const e = this.startNode()
      this.next(), this.eat(5)
      const r = this.initializeScopes(!0)
      this.enterInitialScopes()
      const i = this.startNode()
      try {
        e.body = this.parseProgram(i, 8, 'module')
      } finally {
        r()
      }
      return this.eat(8), this.finishNode(e, 'ModuleExpression')
    }
    parsePropertyNamePrefixOperator(e) {}
  }
  const lp = { kind: 'loop' },
    mU = { kind: 'switch' },
    yU = 0,
    up = 1,
    E0 = 2,
    P0 = 4,
    gU = /[\uD800-\uDFFF]/u,
    cp = /in(?:stanceof)?/y
  function TU(t, e) {
    for (let r = 0; r < t.length; r++) {
      const i = t[r],
        { type: n } = i
      if (typeof n == 'number') {
        {
          if (n === 134) {
            const { loc: s, start: a, value: o, end: u } = i,
              c = a + 1,
              p = zt(s.start, 1)
            t.splice(
              r,
              1,
              new bi({ type: qr(27), value: '#', start: a, end: c, startLoc: s.start, endLoc: p }),
              new bi({ type: qr(128), value: o, start: c, end: u, startLoc: p, endLoc: s.end })
            ),
              r++
            continue
          }
          if (Po(n)) {
            const { loc: s, start: a, value: o, end: u } = i,
              c = a + 1,
              p = zt(s.start, 1)
            let h
            e.charCodeAt(a) === 96
              ? (h = new bi({ type: qr(22), value: '`', start: a, end: c, startLoc: s.start, endLoc: p }))
              : (h = new bi({ type: qr(8), value: '}', start: a, end: c, startLoc: s.start, endLoc: p }))
            let f, d, T, y
            n === 24
              ? ((d = u - 1),
                (T = zt(s.end, -1)),
                (f = o === null ? null : o.slice(1, -1)),
                (y = new bi({ type: qr(22), value: '`', start: d, end: u, startLoc: T, endLoc: s.end })))
              : ((d = u - 2),
                (T = zt(s.end, -2)),
                (f = o === null ? null : o.slice(1, -2)),
                (y = new bi({ type: qr(23), value: '${', start: d, end: u, startLoc: T, endLoc: s.end }))),
              t.splice(r, 1, h, new bi({ type: qr(20), value: f, start: c, end: d, startLoc: p, endLoc: T }), y),
              (r += 2)
            continue
          }
        }
        i.type = qr(n)
      }
    }
    return t
  }
  class bU extends dU {
    parseTopLevel(e, r) {
      return (
        (e.program = this.parseProgram(r)),
        (e.comments = this.state.comments),
        this.options.tokens && (e.tokens = TU(this.tokens, this.input)),
        this.finishNode(e, 'File')
      )
    }
    parseProgram(e, r = 135, i = this.options.sourceType) {
      if (
        ((e.sourceType = i),
        (e.interpreter = this.parseInterpreterDirective()),
        this.parseBlockBody(e, !0, !0, r),
        this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0)
      )
        for (const [n, s] of Array.from(this.scope.undefinedExports))
          this.raise(te.ModuleExportUndefined, { at: s, localName: n })
      return this.finishNode(e, 'Program')
    }
    stmtToDirective(e) {
      const r = e
      ;(r.type = 'Directive'), (r.value = r.expression), delete r.expression
      const i = r.value,
        n = i.value,
        s = this.input.slice(i.start, i.end),
        a = (i.value = s.slice(1, -1))
      return (
        this.addExtra(i, 'raw', s),
        this.addExtra(i, 'rawValue', a),
        this.addExtra(i, 'expressionValue', n),
        (i.type = 'DirectiveLiteral'),
        r
      )
    }
    parseInterpreterDirective() {
      if (!this.match(28)) return null
      const e = this.startNode()
      return (e.value = this.state.value), this.next(), this.finishNode(e, 'InterpreterDirective')
    }
    isLet(e) {
      return this.isContextual(99) ? this.isLetKeyword(e) : !1
    }
    isLetKeyword(e) {
      const r = this.nextTokenStart(),
        i = this.codePointAtPos(r)
      if (i === 92 || i === 91) return !0
      if (e) return !1
      if (i === 123) return !0
      if (Xr(i)) {
        if (((cp.lastIndex = r), cp.test(this.input))) {
          const n = this.codePointAtPos(cp.lastIndex)
          if (!On(n) && n !== 92) return !1
        }
        return !0
      }
      return !1
    }
    parseStatement(e, r) {
      return this.match(26) && this.parseDecorators(!0), this.parseStatementContent(e, r)
    }
    parseStatementContent(e, r) {
      let i = this.state.type
      const n = this.startNode()
      let s
      switch ((this.isLet(e) && ((i = 74), (s = 'let')), i)) {
        case 60:
          return this.parseBreakContinueStatement(n, !0)
        case 63:
          return this.parseBreakContinueStatement(n, !1)
        case 64:
          return this.parseDebuggerStatement(n)
        case 90:
          return this.parseDoStatement(n)
        case 91:
          return this.parseForStatement(n)
        case 68:
          if (this.lookaheadCharCode() === 46) break
          return (
            e &&
              (this.state.strict
                ? this.raise(te.StrictFunction, { at: this.state.startLoc })
                : e !== 'if' && e !== 'label' && this.raise(te.SloppyFunction, { at: this.state.startLoc })),
            this.parseFunctionStatement(n, !1, !e)
          )
        case 80:
          return e && this.unexpected(), this.parseClass(n, !0)
        case 69:
          return this.parseIfStatement(n)
        case 70:
          return this.parseReturnStatement(n)
        case 71:
          return this.parseSwitchStatement(n)
        case 72:
          return this.parseThrowStatement(n)
        case 73:
          return this.parseTryStatement(n)
        case 75:
        case 74:
          return (
            (s = s || this.state.value),
            e && s !== 'var' && this.raise(te.UnexpectedLexicalDeclaration, { at: this.state.startLoc }),
            this.parseVarStatement(n, s)
          )
        case 92:
          return this.parseWhileStatement(n)
        case 76:
          return this.parseWithStatement(n)
        case 5:
          return this.parseBlock()
        case 13:
          return this.parseEmptyStatement(n)
        case 83: {
          const u = this.lookaheadCharCode()
          if (u === 40 || u === 46) break
        }
        case 82: {
          !this.options.allowImportExportEverywhere &&
            !r &&
            this.raise(te.UnexpectedImportExport, { at: this.state.startLoc }),
            this.next()
          let u
          return (
            i === 83
              ? ((u = this.parseImport(n)),
                u.type === 'ImportDeclaration' &&
                  (!u.importKind || u.importKind === 'value') &&
                  (this.sawUnambiguousESM = !0))
              : ((u = this.parseExport(n)),
                ((u.type === 'ExportNamedDeclaration' && (!u.exportKind || u.exportKind === 'value')) ||
                  (u.type === 'ExportAllDeclaration' && (!u.exportKind || u.exportKind === 'value')) ||
                  u.type === 'ExportDefaultDeclaration') &&
                  (this.sawUnambiguousESM = !0)),
            this.assertModuleNodeAllowed(n),
            u
          )
        }
        default:
          if (this.isAsyncFunction())
            return (
              e && this.raise(te.AsyncFunctionInSingleStatementContext, { at: this.state.startLoc }),
              this.next(),
              this.parseFunctionStatement(n, !0, !e)
            )
      }
      const a = this.state.value,
        o = this.parseExpression()
      return dt(i) && o.type === 'Identifier' && this.eat(14)
        ? this.parseLabeledStatement(n, a, o, e)
        : this.parseExpressionStatement(n, o)
    }
    assertModuleNodeAllowed(e) {
      !this.options.allowImportExportEverywhere && !this.inModule && this.raise(te.ImportOutsideModule, { at: e })
    }
    takeDecorators(e) {
      const r = this.state.decoratorStack[this.state.decoratorStack.length - 1]
      r.length &&
        ((e.decorators = r),
        this.resetStartLocationFromNode(e, r[0]),
        (this.state.decoratorStack[this.state.decoratorStack.length - 1] = []))
    }
    canHaveLeadingDecorator() {
      return this.match(80)
    }
    parseDecorators(e) {
      const r = this.state.decoratorStack[this.state.decoratorStack.length - 1]
      for (; this.match(26); ) {
        const i = this.parseDecorator()
        r.push(i)
      }
      if (this.match(82))
        e || this.unexpected(),
          this.hasPlugin('decorators') &&
            !this.getPluginOption('decorators', 'decoratorsBeforeExport') &&
            this.raise(te.DecoratorExportClass, { at: this.state.startLoc })
      else if (!this.canHaveLeadingDecorator())
        throw this.raise(te.UnexpectedLeadingDecorator, { at: this.state.startLoc })
    }
    parseDecorator() {
      this.expectOnePlugin(['decorators-legacy', 'decorators'])
      const e = this.startNode()
      if ((this.next(), this.hasPlugin('decorators'))) {
        this.state.decoratorStack.push([])
        const r = this.state.start,
          i = this.state.startLoc
        let n
        if (this.match(10)) {
          const s = this.state.start,
            a = this.state.startLoc
          this.next(), (n = this.parseExpression()), this.expect(11), (n = this.wrapParenthesis(s, a, n))
        } else
          for (n = this.parseIdentifier(!1); this.eat(16); ) {
            const s = this.startNodeAt(r, i)
            ;(s.object = n),
              (s.property = this.parseIdentifier(!0)),
              (s.computed = !1),
              (n = this.finishNode(s, 'MemberExpression'))
          }
        ;(e.expression = this.parseMaybeDecoratorArguments(n)), this.state.decoratorStack.pop()
      } else e.expression = this.parseExprSubscripts()
      return this.finishNode(e, 'Decorator')
    }
    parseMaybeDecoratorArguments(e) {
      if (this.eat(10)) {
        const r = this.startNodeAtNode(e)
        return (
          (r.callee = e),
          (r.arguments = this.parseCallExpressionArguments(11, !1)),
          this.toReferencedList(r.arguments),
          this.finishNode(r, 'CallExpression')
        )
      }
      return e
    }
    parseBreakContinueStatement(e, r) {
      return (
        this.next(),
        this.isLineTerminator() ? (e.label = null) : ((e.label = this.parseIdentifier()), this.semicolon()),
        this.verifyBreakContinue(e, r),
        this.finishNode(e, r ? 'BreakStatement' : 'ContinueStatement')
      )
    }
    verifyBreakContinue(e, r) {
      let i
      for (i = 0; i < this.state.labels.length; ++i) {
        const n = this.state.labels[i]
        if (
          (e.label == null || n.name === e.label.name) &&
          ((n.kind != null && (r || n.kind === 'loop')) || (e.label && r))
        )
          break
      }
      if (i === this.state.labels.length) {
        const n = r ? 'BreakStatement' : 'ContinueStatement'
        this.raise(te.IllegalBreakContinue, { at: e, type: n })
      }
    }
    parseDebuggerStatement(e) {
      return this.next(), this.semicolon(), this.finishNode(e, 'DebuggerStatement')
    }
    parseHeaderExpression() {
      this.expect(10)
      const e = this.parseExpression()
      return this.expect(11), e
    }
    parseDoStatement(e) {
      return (
        this.next(),
        this.state.labels.push(lp),
        (e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement('do'))),
        this.state.labels.pop(),
        this.expect(92),
        (e.test = this.parseHeaderExpression()),
        this.eat(13),
        this.finishNode(e, 'DoWhileStatement')
      )
    }
    parseForStatement(e) {
      this.next(), this.state.labels.push(lp)
      let r = null
      if (
        (this.isAwaitAllowed() && this.eatContextual(96) && (r = this.state.lastTokStartLoc),
        this.scope.enter(Dn),
        this.expect(10),
        this.match(13))
      )
        return r !== null && this.unexpected(r), this.parseFor(e, null)
      const i = this.isContextual(99),
        n = i && this.isLetKeyword()
      if (this.match(74) || this.match(75) || n) {
        const c = this.startNode(),
          p = n ? 'let' : this.state.value
        return (
          this.next(),
          this.parseVar(c, !0, p),
          this.finishNode(c, 'VariableDeclaration'),
          (this.match(58) || this.isContextual(101)) && c.declarations.length === 1
            ? this.parseForIn(e, c, r)
            : (r !== null && this.unexpected(r), this.parseFor(e, c))
        )
      }
      const s = this.isContextual(95),
        a = new Fo(),
        o = this.parseExpression(!0, a),
        u = this.isContextual(101)
      if (
        (u &&
          (i && this.raise(te.ForOfLet, { at: o }),
          r === null && s && o.type === 'Identifier' && this.raise(te.ForOfAsync, { at: o })),
        u || this.match(58))
      ) {
        this.checkDestructuringPrivate(a), this.toAssignable(o, !0)
        const c = u ? 'ForOfStatement' : 'ForInStatement'
        return this.checkLVal(o, { in: { type: c } }), this.parseForIn(e, o, r)
      } else this.checkExpressionErrors(a, !0)
      return r !== null && this.unexpected(r), this.parseFor(e, o)
    }
    parseFunctionStatement(e, r, i) {
      return this.next(), this.parseFunction(e, up | (i ? 0 : E0), r)
    }
    parseIfStatement(e) {
      return (
        this.next(),
        (e.test = this.parseHeaderExpression()),
        (e.consequent = this.parseStatement('if')),
        (e.alternate = this.eat(66) ? this.parseStatement('if') : null),
        this.finishNode(e, 'IfStatement')
      )
    }
    parseReturnStatement(e) {
      return (
        !this.prodParam.hasReturn &&
          !this.options.allowReturnOutsideFunction &&
          this.raise(te.IllegalReturn, { at: this.state.startLoc }),
        this.next(),
        this.isLineTerminator() ? (e.argument = null) : ((e.argument = this.parseExpression()), this.semicolon()),
        this.finishNode(e, 'ReturnStatement')
      )
    }
    parseSwitchStatement(e) {
      this.next(), (e.discriminant = this.parseHeaderExpression())
      const r = (e.cases = [])
      this.expect(5), this.state.labels.push(mU), this.scope.enter(Dn)
      let i
      for (let n; !this.match(8); )
        if (this.match(61) || this.match(65)) {
          const s = this.match(61)
          i && this.finishNode(i, 'SwitchCase'),
            r.push((i = this.startNode())),
            (i.consequent = []),
            this.next(),
            s
              ? (i.test = this.parseExpression())
              : (n && this.raise(te.MultipleDefaultsInSwitch, { at: this.state.lastTokStartLoc }),
                (n = !0),
                (i.test = null)),
            this.expect(14)
        } else i ? i.consequent.push(this.parseStatement(null)) : this.unexpected()
      return (
        this.scope.exit(),
        i && this.finishNode(i, 'SwitchCase'),
        this.next(),
        this.state.labels.pop(),
        this.finishNode(e, 'SwitchStatement')
      )
    }
    parseThrowStatement(e) {
      return (
        this.next(),
        this.hasPrecedingLineBreak() && this.raise(te.NewlineAfterThrow, { at: this.state.lastTokEndLoc }),
        (e.argument = this.parseExpression()),
        this.semicolon(),
        this.finishNode(e, 'ThrowStatement')
      )
    }
    parseCatchClauseParam() {
      const e = this.parseBindingAtom(),
        r = e.type === 'Identifier'
      return (
        this.scope.enter(r ? qy : 0),
        this.checkLVal(e, { in: { type: 'CatchClause' }, binding: Zr, allowingSloppyLetBinding: !0 }),
        e
      )
    }
    parseTryStatement(e) {
      if ((this.next(), (e.block = this.parseBlock()), (e.handler = null), this.match(62))) {
        const r = this.startNode()
        this.next(),
          this.match(10)
            ? (this.expect(10), (r.param = this.parseCatchClauseParam()), this.expect(11))
            : ((r.param = null), this.scope.enter(Dn)),
          (r.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(!1, !1))),
          this.scope.exit(),
          (e.handler = this.finishNode(r, 'CatchClause'))
      }
      return (
        (e.finalizer = this.eat(67) ? this.parseBlock() : null),
        !e.handler && !e.finalizer && this.raise(te.NoCatchOrFinally, { at: e }),
        this.finishNode(e, 'TryStatement')
      )
    }
    parseVarStatement(e, r, i = !1) {
      return this.next(), this.parseVar(e, !1, r, i), this.semicolon(), this.finishNode(e, 'VariableDeclaration')
    }
    parseWhileStatement(e) {
      return (
        this.next(),
        (e.test = this.parseHeaderExpression()),
        this.state.labels.push(lp),
        (e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement('while'))),
        this.state.labels.pop(),
        this.finishNode(e, 'WhileStatement')
      )
    }
    parseWithStatement(e) {
      return (
        this.state.strict && this.raise(te.StrictWith, { at: this.state.startLoc }),
        this.next(),
        (e.object = this.parseHeaderExpression()),
        (e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement('with'))),
        this.finishNode(e, 'WithStatement')
      )
    }
    parseEmptyStatement(e) {
      return this.next(), this.finishNode(e, 'EmptyStatement')
    }
    parseLabeledStatement(e, r, i, n) {
      for (const a of this.state.labels) a.name === r && this.raise(te.LabelRedeclaration, { at: i, labelName: r })
      const s = YV(this.state.type) ? 'loop' : this.match(71) ? 'switch' : null
      for (let a = this.state.labels.length - 1; a >= 0; a--) {
        const o = this.state.labels[a]
        if (o.statementStart === e.start) (o.statementStart = this.state.start), (o.kind = s)
        else break
      }
      return (
        this.state.labels.push({ name: r, kind: s, statementStart: this.state.start }),
        (e.body = this.parseStatement(n ? (n.indexOf('label') === -1 ? n + 'label' : n) : 'label')),
        this.state.labels.pop(),
        (e.label = i),
        this.finishNode(e, 'LabeledStatement')
      )
    }
    parseExpressionStatement(e, r) {
      return (e.expression = r), this.semicolon(), this.finishNode(e, 'ExpressionStatement')
    }
    parseBlock(e = !1, r = !0, i) {
      const n = this.startNode()
      return (
        e && this.state.strictErrors.clear(),
        this.expect(5),
        r && this.scope.enter(Dn),
        this.parseBlockBody(n, e, !1, 8, i),
        r && this.scope.exit(),
        this.finishNode(n, 'BlockStatement')
      )
    }
    isValidDirective(e) {
      return (
        e.type === 'ExpressionStatement' && e.expression.type === 'StringLiteral' && !e.expression.extra.parenthesized
      )
    }
    parseBlockBody(e, r, i, n, s) {
      const a = (e.body = []),
        o = (e.directives = [])
      this.parseBlockOrModuleBlockBody(a, r ? o : void 0, i, n, s)
    }
    parseBlockOrModuleBlockBody(e, r, i, n, s) {
      const a = this.state.strict
      let o = !1,
        u = !1
      for (; !this.match(n); ) {
        const c = this.parseStatement(null, i)
        if (r && !u) {
          if (this.isValidDirective(c)) {
            const p = this.stmtToDirective(c)
            r.push(p), !o && p.value.value === 'use strict' && ((o = !0), this.setStrict(!0))
            continue
          }
          ;(u = !0), this.state.strictErrors.clear()
        }
        e.push(c)
      }
      s && s.call(this, o), a || this.setStrict(!1), this.next()
    }
    parseFor(e, r) {
      return (
        (e.init = r),
        this.semicolon(!1),
        (e.test = this.match(13) ? null : this.parseExpression()),
        this.semicolon(!1),
        (e.update = this.match(11) ? null : this.parseExpression()),
        this.expect(11),
        (e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement('for'))),
        this.scope.exit(),
        this.state.labels.pop(),
        this.finishNode(e, 'ForStatement')
      )
    }
    parseForIn(e, r, i) {
      const n = this.match(58)
      return (
        this.next(),
        n ? i !== null && this.unexpected(i) : (e.await = i !== null),
        r.type === 'VariableDeclaration' &&
          r.declarations[0].init != null &&
          (!n || this.state.strict || r.kind !== 'var' || r.declarations[0].id.type !== 'Identifier') &&
          this.raise(te.ForInOfLoopInitializer, { at: r, type: n ? 'ForInStatement' : 'ForOfStatement' }),
        r.type === 'AssignmentPattern' && this.raise(te.InvalidLhs, { at: r, ancestor: { type: 'ForStatement' } }),
        (e.left = r),
        (e.right = n ? this.parseExpression() : this.parseMaybeAssignAllowIn()),
        this.expect(11),
        (e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement('for'))),
        this.scope.exit(),
        this.state.labels.pop(),
        this.finishNode(e, n ? 'ForInStatement' : 'ForOfStatement')
      )
    }
    parseVar(e, r, i, n = !1) {
      const s = (e.declarations = [])
      for (e.kind = i; ; ) {
        const a = this.startNode()
        if (
          (this.parseVarId(a, i),
          (a.init = this.eat(29) ? (r ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn()) : null),
          a.init === null &&
            !n &&
            (a.id.type !== 'Identifier' && !(r && (this.match(58) || this.isContextual(101)))
              ? this.raise(te.DeclarationMissingInitializer, { at: this.state.lastTokEndLoc, kind: 'destructuring' })
              : i === 'const' &&
                !(this.match(58) || this.isContextual(101)) &&
                this.raise(te.DeclarationMissingInitializer, { at: this.state.lastTokEndLoc, kind: 'const' })),
          s.push(this.finishNode(a, 'VariableDeclarator')),
          !this.eat(12))
        )
          break
      }
      return e
    }
    parseVarId(e, r) {
      ;(e.id = this.parseBindingAtom()),
        this.checkLVal(e.id, { in: { type: 'VariableDeclarator' }, binding: r === 'var' ? ko : Zr })
    }
    parseFunction(e, r = yU, i = !1) {
      const n = r & up,
        s = r & E0,
        a = !!n && !(r & P0)
      this.initFunction(e, i),
        this.match(55) && s && this.raise(te.GeneratorInSingleStatementContext, { at: this.state.startLoc }),
        (e.generator = this.eat(55)),
        n && (e.id = this.parseFunctionId(a))
      const o = this.state.maybeInArrowParameters
      return (
        (this.state.maybeInArrowParameters = !1),
        this.scope.enter(Gr),
        this.prodParam.enter(Mo(i, e.generator)),
        n || (e.id = this.parseFunctionId()),
        this.parseFunctionParams(e, !1),
        this.withSmartMixTopicForbiddingContext(() => {
          this.parseFunctionBodyAndFinish(e, n ? 'FunctionDeclaration' : 'FunctionExpression')
        }),
        this.prodParam.exit(),
        this.scope.exit(),
        n && !s && this.registerFunctionStatementId(e),
        (this.state.maybeInArrowParameters = o),
        e
      )
    }
    parseFunctionId(e) {
      return e || dt(this.state.type) ? this.parseIdentifier() : null
    }
    parseFunctionParams(e, r) {
      this.expect(10),
        this.expressionScope.enter(F7()),
        (e.params = this.parseBindingList(11, 41, !1, r)),
        this.expressionScope.exit()
    }
    registerFunctionStatementId(e) {
      !e.id ||
        this.scope.declareName(
          e.id.name,
          this.state.strict || e.generator || e.async ? (this.scope.treatFunctionsAsVar ? ko : Zr) : Qy,
          e.id.loc.start
        )
    }
    parseClass(e, r, i) {
      this.next(), this.takeDecorators(e)
      const n = this.state.strict
      return (
        (this.state.strict = !0),
        this.parseClassId(e, r, i),
        this.parseClassSuper(e),
        (e.body = this.parseClassBody(!!e.superClass, n)),
        this.finishNode(e, r ? 'ClassDeclaration' : 'ClassExpression')
      )
    }
    isClassProperty() {
      return this.match(29) || this.match(13) || this.match(8)
    }
    isClassMethod() {
      return this.match(10)
    }
    isNonstaticConstructor(e) {
      return !e.computed && !e.static && (e.key.name === 'constructor' || e.key.value === 'constructor')
    }
    parseClassBody(e, r) {
      this.classScope.enter()
      const i = { hadConstructor: !1, hadSuperClass: e }
      let n = []
      const s = this.startNode()
      if (
        ((s.body = []),
        this.expect(5),
        this.withSmartMixTopicForbiddingContext(() => {
          for (; !this.match(8); ) {
            if (this.eat(13)) {
              if (n.length > 0) throw this.raise(te.DecoratorSemicolon, { at: this.state.lastTokEndLoc })
              continue
            }
            if (this.match(26)) {
              n.push(this.parseDecorator())
              continue
            }
            const a = this.startNode()
            n.length && ((a.decorators = n), this.resetStartLocationFromNode(a, n[0]), (n = [])),
              this.parseClassMember(s, a, i),
              a.kind === 'constructor' &&
                a.decorators &&
                a.decorators.length > 0 &&
                this.raise(te.DecoratorConstructor, { at: a })
          }
        }),
        (this.state.strict = r),
        this.next(),
        n.length)
      )
        throw this.raise(te.TrailingDecorator, { at: this.state.startLoc })
      return this.classScope.exit(), this.finishNode(s, 'ClassBody')
    }
    parseClassMemberFromModifier(e, r) {
      const i = this.parseIdentifier(!0)
      if (this.isClassMethod()) {
        const n = r
        return (
          (n.kind = 'method'),
          (n.computed = !1),
          (n.key = i),
          (n.static = !1),
          this.pushClassMethod(e, n, !1, !1, !1, !1),
          !0
        )
      } else if (this.isClassProperty()) {
        const n = r
        return (n.computed = !1), (n.key = i), (n.static = !1), e.body.push(this.parseClassProperty(n)), !0
      }
      return this.resetPreviousNodeTrailingComments(i), !1
    }
    parseClassMember(e, r, i) {
      const n = this.isContextual(104)
      if (n) {
        if (this.parseClassMemberFromModifier(e, r)) return
        if (this.eat(5)) {
          this.parseClassStaticBlock(e, r)
          return
        }
      }
      this.parseClassMemberWithIsStatic(e, r, i, n)
    }
    parseClassMemberWithIsStatic(e, r, i, n) {
      const s = r,
        a = r,
        o = r,
        u = r,
        c = r,
        p = s,
        h = s
      if (((r.static = n), this.parsePropertyNamePrefixOperator(r), this.eat(55))) {
        p.kind = 'method'
        const b = this.match(134)
        if ((this.parseClassElementName(p), b)) {
          this.pushClassPrivateMethod(e, a, !0, !1)
          return
        }
        this.isNonstaticConstructor(s) && this.raise(te.ConstructorIsGenerator, { at: s.key }),
          this.pushClassMethod(e, s, !0, !1, !1, !1)
        return
      }
      const f = dt(this.state.type) && !this.state.containsEsc,
        d = this.match(134),
        T = this.parseClassElementName(r),
        y = this.state.startLoc
      if ((this.parsePostMemberNameModifiers(h), this.isClassMethod())) {
        if (((p.kind = 'method'), d)) {
          this.pushClassPrivateMethod(e, a, !1, !1)
          return
        }
        const b = this.isNonstaticConstructor(s)
        let m = !1
        b &&
          ((s.kind = 'constructor'),
          i.hadConstructor && !this.hasPlugin('typescript') && this.raise(te.DuplicateConstructor, { at: T }),
          b && this.hasPlugin('typescript') && r.override && this.raise(te.OverrideOnConstructor, { at: T }),
          (i.hadConstructor = !0),
          (m = i.hadSuperClass)),
          this.pushClassMethod(e, s, !1, !1, b, m)
      } else if (this.isClassProperty()) d ? this.pushClassPrivateProperty(e, u) : this.pushClassProperty(e, o)
      else if (f && T.name === 'async' && !this.isLineTerminator()) {
        this.resetPreviousNodeTrailingComments(T)
        const b = this.eat(55)
        h.optional && this.unexpected(y), (p.kind = 'method')
        const m = this.match(134)
        this.parseClassElementName(p),
          this.parsePostMemberNameModifiers(h),
          m
            ? this.pushClassPrivateMethod(e, a, b, !0)
            : (this.isNonstaticConstructor(s) && this.raise(te.ConstructorIsAsync, { at: s.key }),
              this.pushClassMethod(e, s, b, !0, !1, !1))
      } else if (f && (T.name === 'get' || T.name === 'set') && !(this.match(55) && this.isLineTerminator())) {
        this.resetPreviousNodeTrailingComments(T), (p.kind = T.name)
        const b = this.match(134)
        this.parseClassElementName(s),
          b
            ? this.pushClassPrivateMethod(e, a, !1, !1)
            : (this.isNonstaticConstructor(s) && this.raise(te.ConstructorIsAccessor, { at: s.key }),
              this.pushClassMethod(e, s, !1, !1, !1, !1)),
          this.checkGetterSetterParams(s)
      } else if (f && T.name === 'accessor' && !this.isLineTerminator()) {
        this.expectPlugin('decoratorAutoAccessors'), this.resetPreviousNodeTrailingComments(T)
        const b = this.match(134)
        this.parseClassElementName(o), this.pushClassAccessorProperty(e, c, b)
      } else
        this.isLineTerminator()
          ? d
            ? this.pushClassPrivateProperty(e, u)
            : this.pushClassProperty(e, o)
          : this.unexpected()
    }
    parseClassElementName(e) {
      const { type: r, value: i } = this.state
      if (
        ((r === 128 || r === 129) &&
          e.static &&
          i === 'prototype' &&
          this.raise(te.StaticPrototype, { at: this.state.startLoc }),
        r === 134)
      ) {
        i === 'constructor' && this.raise(te.ConstructorClassPrivateField, { at: this.state.startLoc })
        const n = this.parsePrivateName()
        return (e.key = n), n
      }
      return this.parsePropertyName(e)
    }
    parseClassStaticBlock(e, r) {
      var i
      this.scope.enter(tn | Wc | wo)
      const n = this.state.labels
      ;(this.state.labels = []), this.prodParam.enter(Ln)
      const s = (r.body = [])
      this.parseBlockOrModuleBlockBody(s, void 0, !1, 8),
        this.prodParam.exit(),
        this.scope.exit(),
        (this.state.labels = n),
        e.body.push(this.finishNode(r, 'StaticBlock')),
        (i = r.decorators) != null && i.length && this.raise(te.DecoratorStaticBlock, { at: r })
    }
    pushClassProperty(e, r) {
      !r.computed &&
        (r.key.name === 'constructor' || r.key.value === 'constructor') &&
        this.raise(te.ConstructorClassField, { at: r.key }),
        e.body.push(this.parseClassProperty(r))
    }
    pushClassPrivateProperty(e, r) {
      const i = this.parseClassPrivateProperty(r)
      e.body.push(i), this.classScope.declarePrivateName(this.getPrivateNameSV(i.key), Qc, i.key.loc.start)
    }
    pushClassAccessorProperty(e, r, i) {
      if (!i && !r.computed) {
        const s = r.key
        ;(s.name === 'constructor' || s.value === 'constructor') && this.raise(te.ConstructorClassField, { at: s })
      }
      const n = this.parseClassAccessorProperty(r)
      e.body.push(n), i && this.classScope.declarePrivateName(this.getPrivateNameSV(n.key), Qc, n.key.loc.start)
    }
    pushClassMethod(e, r, i, n, s, a) {
      e.body.push(this.parseMethod(r, i, n, s, a, 'ClassMethod', !0))
    }
    pushClassPrivateMethod(e, r, i, n) {
      const s = this.parseMethod(r, i, n, !1, !1, 'ClassPrivateMethod', !0)
      e.body.push(s)
      const a = s.kind === 'get' ? (s.static ? y7 : T7) : s.kind === 'set' ? (s.static ? g7 : b7) : Qc
      this.declareClassPrivateMethodInScope(s, a)
    }
    declareClassPrivateMethodInScope(e, r) {
      this.classScope.declarePrivateName(this.getPrivateNameSV(e.key), r, e.key.loc.start)
    }
    parsePostMemberNameModifiers(e) {}
    parseClassPrivateProperty(e) {
      return this.parseInitializer(e), this.semicolon(), this.finishNode(e, 'ClassPrivateProperty')
    }
    parseClassProperty(e) {
      return this.parseInitializer(e), this.semicolon(), this.finishNode(e, 'ClassProperty')
    }
    parseClassAccessorProperty(e) {
      return this.parseInitializer(e), this.semicolon(), this.finishNode(e, 'ClassAccessorProperty')
    }
    parseInitializer(e) {
      this.scope.enter(tn | wo),
        this.expressionScope.enter(l0()),
        this.prodParam.enter(Ln),
        (e.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null),
        this.expressionScope.exit(),
        this.prodParam.exit(),
        this.scope.exit()
    }
    parseClassId(e, r, i, n = Zy) {
      if (dt(this.state.type)) (e.id = this.parseIdentifier()), r && this.declareNameFromIdentifier(e.id, n)
      else if (i || !r) e.id = null
      else throw this.raise(te.MissingClassName, { at: this.state.startLoc })
    }
    parseClassSuper(e) {
      e.superClass = this.eat(81) ? this.parseExprSubscripts() : null
    }
    parseExport(e) {
      const r = this.maybeParseExportDefaultSpecifier(e),
        i = !r || this.eat(12),
        n = i && this.eatExportStar(e),
        s = n && this.maybeParseExportNamespaceSpecifier(e),
        a = i && (!s || this.eat(12)),
        o = r || n
      if (n && !s)
        return r && this.unexpected(), this.parseExportFrom(e, !0), this.finishNode(e, 'ExportAllDeclaration')
      const u = this.maybeParseExportNamedSpecifiers(e)
      if ((r && i && !n && !u) || (s && a && !u)) throw this.unexpected(null, 5)
      let c
      if ((o || u ? ((c = !1), this.parseExportFrom(e, o)) : (c = this.maybeParseExportDeclaration(e)), o || u || c))
        return this.checkExport(e, !0, !1, !!e.source), this.finishNode(e, 'ExportNamedDeclaration')
      if (this.eat(65))
        return (
          (e.declaration = this.parseExportDefaultExpression()),
          this.checkExport(e, !0, !0),
          this.finishNode(e, 'ExportDefaultDeclaration')
        )
      throw this.unexpected(null, 5)
    }
    eatExportStar(e) {
      return this.eat(55)
    }
    maybeParseExportDefaultSpecifier(e) {
      if (this.isExportDefaultSpecifier()) {
        this.expectPlugin('exportDefaultFrom')
        const r = this.startNode()
        return (
          (r.exported = this.parseIdentifier(!0)), (e.specifiers = [this.finishNode(r, 'ExportDefaultSpecifier')]), !0
        )
      }
      return !1
    }
    maybeParseExportNamespaceSpecifier(e) {
      if (this.isContextual(93)) {
        e.specifiers || (e.specifiers = [])
        const r = this.startNodeAt(this.state.lastTokStart, this.state.lastTokStartLoc)
        return (
          this.next(),
          (r.exported = this.parseModuleExportName()),
          e.specifiers.push(this.finishNode(r, 'ExportNamespaceSpecifier')),
          !0
        )
      }
      return !1
    }
    maybeParseExportNamedSpecifiers(e) {
      if (this.match(5)) {
        e.specifiers || (e.specifiers = [])
        const r = e.exportKind === 'type'
        return (
          e.specifiers.push(...this.parseExportSpecifiers(r)),
          (e.source = null),
          (e.declaration = null),
          this.hasPlugin('importAssertions') && (e.assertions = []),
          !0
        )
      }
      return !1
    }
    maybeParseExportDeclaration(e) {
      return this.shouldParseExportDeclaration()
        ? ((e.specifiers = []),
          (e.source = null),
          this.hasPlugin('importAssertions') && (e.assertions = []),
          (e.declaration = this.parseExportDeclaration(e)),
          !0)
        : !1
    }
    isAsyncFunction() {
      if (!this.isContextual(95)) return !1
      const e = this.nextTokenStart()
      return !ep.test(this.input.slice(this.state.pos, e)) && this.isUnparsedContextual(e, 'function')
    }
    parseExportDefaultExpression() {
      const e = this.startNode(),
        r = this.isAsyncFunction()
      if (this.match(68) || r) return this.next(), r && this.next(), this.parseFunction(e, up | P0, r)
      if (this.match(80)) return this.parseClass(e, !0, !0)
      if (this.match(26))
        return (
          this.hasPlugin('decorators') &&
            this.getPluginOption('decorators', 'decoratorsBeforeExport') &&
            this.raise(te.DecoratorBeforeExport, { at: this.state.startLoc }),
          this.parseDecorators(!1),
          this.parseClass(e, !0, !0)
        )
      if (this.match(75) || this.match(74) || this.isLet())
        throw this.raise(te.UnsupportedDefaultExport, { at: this.state.startLoc })
      const i = this.parseMaybeAssignAllowIn()
      return this.semicolon(), i
    }
    parseExportDeclaration(e) {
      return this.parseStatement(null)
    }
    isExportDefaultSpecifier() {
      const { type: e } = this.state
      if (dt(e)) {
        if ((e === 95 && !this.state.containsEsc) || e === 99) return !1
        if ((e === 126 || e === 125) && !this.state.containsEsc) {
          const { type: n } = this.lookahead()
          if ((dt(n) && n !== 97) || n === 5) return this.expectOnePlugin(['flow', 'typescript']), !1
        }
      } else if (!this.match(65)) return !1
      const r = this.nextTokenStart(),
        i = this.isUnparsedContextual(r, 'from')
      if (this.input.charCodeAt(r) === 44 || (dt(this.state.type) && i)) return !0
      if (this.match(65) && i) {
        const n = this.input.charCodeAt(this.nextTokenStartSince(r + 4))
        return n === 34 || n === 39
      }
      return !1
    }
    parseExportFrom(e, r) {
      if (this.eatContextual(97)) {
        ;(e.source = this.parseImportSource()), this.checkExport(e)
        const i = this.maybeParseImportAssertions()
        i && (e.assertions = i)
      } else r && this.unexpected()
      this.semicolon()
    }
    shouldParseExportDeclaration() {
      const { type: e } = this.state
      if (e === 26 && (this.expectOnePlugin(['decorators', 'decorators-legacy']), this.hasPlugin('decorators'))) {
        if (this.getPluginOption('decorators', 'decoratorsBeforeExport'))
          throw this.raise(te.DecoratorBeforeExport, { at: this.state.startLoc })
        return !0
      }
      return e === 74 || e === 75 || e === 68 || e === 80 || this.isLet() || this.isAsyncFunction()
    }
    checkExport(e, r, i, n) {
      if (r) {
        if (i) {
          if ((this.checkDuplicateExports(e, 'default'), this.hasPlugin('exportDefaultFrom'))) {
            var s
            const o = e.declaration
            o.type === 'Identifier' &&
              o.name === 'from' &&
              o.end - o.start === 4 &&
              !((s = o.extra) != null && s.parenthesized) &&
              this.raise(te.ExportDefaultFromAsIdentifier, { at: o })
          }
        } else if (e.specifiers && e.specifiers.length)
          for (const o of e.specifiers) {
            const { exported: u } = o,
              c = u.type === 'Identifier' ? u.name : u.value
            if ((this.checkDuplicateExports(o, c), !n && o.local)) {
              const { local: p } = o
              p.type !== 'Identifier'
                ? this.raise(te.ExportBindingIsString, { at: o, localName: p.value, exportName: c })
                : (this.checkReservedWord(p.name, p.loc.start, !0, !1), this.scope.checkLocalExport(p))
            }
          }
        else if (e.declaration) {
          if (e.declaration.type === 'FunctionDeclaration' || e.declaration.type === 'ClassDeclaration') {
            const o = e.declaration.id
            if (!o) throw new Error('Assertion failure')
            this.checkDuplicateExports(e, o.name)
          } else if (e.declaration.type === 'VariableDeclaration')
            for (const o of e.declaration.declarations) this.checkDeclaration(o.id)
        }
      }
      if (this.state.decoratorStack[this.state.decoratorStack.length - 1].length)
        throw this.raise(te.UnsupportedDecoratorExport, { at: e })
    }
    checkDeclaration(e) {
      if (e.type === 'Identifier') this.checkDuplicateExports(e, e.name)
      else if (e.type === 'ObjectPattern') for (const r of e.properties) this.checkDeclaration(r)
      else if (e.type === 'ArrayPattern') for (const r of e.elements) r && this.checkDeclaration(r)
      else
        e.type === 'ObjectProperty'
          ? this.checkDeclaration(e.value)
          : e.type === 'RestElement'
          ? this.checkDeclaration(e.argument)
          : e.type === 'AssignmentPattern' && this.checkDeclaration(e.left)
    }
    checkDuplicateExports(e, r) {
      this.exportedIdentifiers.has(r) &&
        (r === 'default'
          ? this.raise(te.DuplicateDefaultExport, { at: e })
          : this.raise(te.DuplicateExport, { at: e, exportName: r })),
        this.exportedIdentifiers.add(r)
    }
    parseExportSpecifiers(e) {
      const r = []
      let i = !0
      for (this.expect(5); !this.eat(8); ) {
        if (i) i = !1
        else if ((this.expect(12), this.eat(8))) break
        const n = this.isContextual(126),
          s = this.match(129),
          a = this.startNode()
        ;(a.local = this.parseModuleExportName()), r.push(this.parseExportSpecifier(a, s, e, n))
      }
      return r
    }
    parseExportSpecifier(e, r, i, n) {
      return (
        this.eatContextual(93)
          ? (e.exported = this.parseModuleExportName())
          : r
          ? (e.exported = U7(e.local))
          : e.exported || (e.exported = Qr(e.local)),
        this.finishNode(e, 'ExportSpecifier')
      )
    }
    parseModuleExportName() {
      if (this.match(129)) {
        const e = this.parseStringLiteral(this.state.value),
          r = e.value.match(gU)
        return r && this.raise(te.ModuleExportNameHasLoneSurrogate, { at: e, surrogateCharCode: r[0].charCodeAt(0) }), e
      }
      return this.parseIdentifier(!0)
    }
    parseImport(e) {
      if (((e.specifiers = []), !this.match(129))) {
        const n = !this.maybeParseDefaultImportSpecifier(e) || this.eat(12),
          s = n && this.maybeParseStarImportSpecifier(e)
        n && !s && this.parseNamedImportSpecifiers(e), this.expectContextual(97)
      }
      e.source = this.parseImportSource()
      const r = this.maybeParseImportAssertions()
      if (r) e.assertions = r
      else {
        const i = this.maybeParseModuleAttributes()
        i && (e.attributes = i)
      }
      return this.semicolon(), this.finishNode(e, 'ImportDeclaration')
    }
    parseImportSource() {
      return this.match(129) || this.unexpected(), this.parseExprAtom()
    }
    shouldParseDefaultImport(e) {
      return dt(this.state.type)
    }
    parseImportSpecifierLocal(e, r, i) {
      ;(r.local = this.parseIdentifier()), e.specifiers.push(this.finishImportSpecifier(r, i))
    }
    finishImportSpecifier(e, r) {
      return this.checkLVal(e.local, { in: e, binding: Zr }), this.finishNode(e, r)
    }
    parseAssertEntries() {
      const e = [],
        r = new Set()
      do {
        if (this.match(8)) break
        const i = this.startNode(),
          n = this.state.value
        if (
          (r.has(n) && this.raise(te.ModuleAttributesWithDuplicateKeys, { at: this.state.startLoc, key: n }),
          r.add(n),
          this.match(129) ? (i.key = this.parseStringLiteral(n)) : (i.key = this.parseIdentifier(!0)),
          this.expect(14),
          !this.match(129))
        )
          throw this.raise(te.ModuleAttributeInvalidValue, { at: this.state.startLoc })
        ;(i.value = this.parseStringLiteral(this.state.value)), this.finishNode(i, 'ImportAttribute'), e.push(i)
      } while (this.eat(12))
      return e
    }
    maybeParseModuleAttributes() {
      if (this.match(76) && !this.hasPrecedingLineBreak()) this.expectPlugin('moduleAttributes'), this.next()
      else return this.hasPlugin('moduleAttributes') ? [] : null
      const e = [],
        r = new Set()
      do {
        const i = this.startNode()
        if (
          ((i.key = this.parseIdentifier(!0)),
          i.key.name !== 'type' && this.raise(te.ModuleAttributeDifferentFromType, { at: i.key }),
          r.has(i.key.name) && this.raise(te.ModuleAttributesWithDuplicateKeys, { at: i.key, key: i.key.name }),
          r.add(i.key.name),
          this.expect(14),
          !this.match(129))
        )
          throw this.raise(te.ModuleAttributeInvalidValue, { at: this.state.startLoc })
        ;(i.value = this.parseStringLiteral(this.state.value)), this.finishNode(i, 'ImportAttribute'), e.push(i)
      } while (this.eat(12))
      return e
    }
    maybeParseImportAssertions() {
      if (this.isContextual(94) && !this.hasPrecedingLineBreak()) this.expectPlugin('importAssertions'), this.next()
      else return this.hasPlugin('importAssertions') ? [] : null
      this.eat(5)
      const e = this.parseAssertEntries()
      return this.eat(8), e
    }
    maybeParseDefaultImportSpecifier(e) {
      return this.shouldParseDefaultImport(e)
        ? (this.parseImportSpecifierLocal(e, this.startNode(), 'ImportDefaultSpecifier'), !0)
        : !1
    }
    maybeParseStarImportSpecifier(e) {
      if (this.match(55)) {
        const r = this.startNode()
        return (
          this.next(), this.expectContextual(93), this.parseImportSpecifierLocal(e, r, 'ImportNamespaceSpecifier'), !0
        )
      }
      return !1
    }
    parseNamedImportSpecifiers(e) {
      let r = !0
      for (this.expect(5); !this.eat(8); ) {
        if (r) r = !1
        else {
          if (this.eat(14)) throw this.raise(te.DestructureNamedImport, { at: this.state.startLoc })
          if ((this.expect(12), this.eat(8))) break
        }
        const i = this.startNode(),
          n = this.match(129),
          s = this.isContextual(126)
        i.imported = this.parseModuleExportName()
        const a = this.parseImportSpecifier(i, n, e.importKind === 'type' || e.importKind === 'typeof', s)
        e.specifiers.push(a)
      }
    }
    parseImportSpecifier(e, r, i, n) {
      if (this.eatContextual(93)) e.local = this.parseIdentifier()
      else {
        const { imported: s } = e
        if (r) throw this.raise(te.ImportBindingIsString, { at: e, importName: s.value })
        this.checkReservedWord(s.name, e.loc.start, !0, !0), e.local || (e.local = Qr(s))
      }
      return this.finishImportSpecifier(e, 'ImportSpecifier')
    }
    isThisParam(e) {
      return e.type === 'Identifier' && e.name === 'this'
    }
  }
  class w0 extends bU {
    constructor(e, r) {
      ;(e = pU(e)),
        super(e, r),
        (this.options = e),
        this.initializeScopes(),
        (this.plugins = SU(this.options.plugins)),
        (this.filename = e.sourceFilename)
    }
    getScopeHandler() {
      return np
    }
    parse() {
      this.enterInitialScopes()
      const e = this.startNode(),
        r = this.startNode()
      return this.nextToken(), (e.errors = null), this.parseTopLevel(e, r), (e.errors = this.state.errors), e
    }
  }
  function SU(t) {
    const e = new Map()
    for (const r of t) {
      const [i, n] = Array.isArray(r) ? r : [r, {}]
      e.has(i) || e.set(i, n || {})
    }
    return e
  }
  function vU(t, e) {
    var r
    if (((r = e) == null ? void 0 : r.sourceType) === 'unambiguous') {
      e = Object.assign({}, e)
      try {
        e.sourceType = 'module'
        const i = Ms(e, t),
          n = i.parse()
        if (i.sawUnambiguousESM) return n
        if (i.ambiguousScriptDifferentAst)
          try {
            return (e.sourceType = 'script'), Ms(e, t).parse()
          } catch {}
        else n.program.sourceType = 'script'
        return n
      } catch (i) {
        try {
          return (e.sourceType = 'script'), Ms(e, t).parse()
        } catch {}
        throw i
      }
    } else return Ms(e, t).parse()
  }
  function EU(t, e) {
    const r = Ms(e, t)
    return r.options.strictMode && (r.state.strict = !0), r.getExpression()
  }
  function PU(t) {
    const e = {}
    for (const r of Object.keys(t)) e[r] = qr(t[r])
    return e
  }
  const wU = PU(UV)
  function Ms(t, e) {
    let r = w0
    return t != null && t.plugins && (uU(t.plugins), (r = AU(t.plugins))), new r(t, e)
  }
  const A0 = {}
  function AU(t) {
    const e = cU.filter((n) => Kt(t, n)),
      r = e.join('/')
    let i = A0[r]
    if (!i) {
      i = w0
      for (const n of e) i = b0[n](i)
      A0[r] = i
    }
    return i
  }
  var CU = (Cs.parse = vU)
  ;(Cs.parseExpression = EU), (Cs.tokTypes = wU)
  var pp = {}
  Object.defineProperty(pp, '__esModule', { value: !0 }), (pp.default = DU)
  var xU = st
  const { assignmentExpression: IU, expressionStatement: kU, identifier: NU } = xU,
    OU = {
      Scope(t, e) {
        e.kind === 'let' && t.skip()
      },
      FunctionParent(t) {
        t.skip()
      },
      VariableDeclaration(t, e) {
        if (e.kind && t.node.kind !== e.kind) return
        const r = [],
          i = t.get('declarations')
        let n
        for (const s of i) {
          ;(n = s.node.id), s.node.init && r.push(kU(IU('=', s.node.id, s.node.init)))
          for (const a of Object.keys(s.getBindingIdentifiers())) e.emit(NU(a), a, s.node.init !== null)
        }
        t.parentPath.isFor({ left: t.node }) ? t.replaceWith(n) : t.replaceWithMultiple(r)
      },
    }
  function DU(t, e, r = 'var') {
    t.traverse(OU, { kind: r, emit: e })
  }
  Object.defineProperty(mi, '__esModule', { value: !0 }),
    (mi._replaceWith = iz),
    (mi.replaceExpressionWithStatements = nz),
    (mi.replaceInline = sz),
    (mi.replaceWith = rz),
    (mi.replaceWithMultiple = ez),
    (mi.replaceWithSourceString = tz)
  var BU = ws,
    fp = ss,
    LU = Ut,
    C0 = Vt,
    MU = Cs,
    FU = st,
    $U = pp
  const {
    FUNCTION_TYPES: x0,
    arrowFunctionExpression: RU,
    assignmentExpression: jU,
    awaitExpression: _U,
    blockStatement: VU,
    callExpression: UU,
    cloneNode: I0,
    expressionStatement: zU,
    identifier: KU,
    inheritLeadingComments: WU,
    inheritTrailingComments: YU,
    inheritsComments: HU,
    isExpression: qU,
    isProgram: XU,
    isStatement: GU,
    removeComments: JU,
    returnStatement: k0,
    toSequenceExpression: ZU,
    validate: N0,
    yieldExpression: QU,
  } = FU
  function ez(t) {
    var e
    this.resync(),
      (t = this._verifyNodeList(t)),
      WU(t[0], this.node),
      YU(t[t.length - 1], this.node),
      (e = C0.path.get(this.parent)) == null || e.delete(this.node),
      (this.node = this.container[this.key] = null)
    const r = this.insertAfter(t)
    return this.node ? this.requeue() : this.remove(), r
  }
  function tz(t) {
    this.resync()
    try {
      ;(t = `(${t})`), (t = (0, MU.parse)(t))
    } catch (e) {
      const r = e.loc
      throw (
        (r &&
          ((e.message +=
            ` - make sure this is an expression.
` + (0, BU.codeFrameColumns)(t, { start: { line: r.line, column: r.column + 1 } })),
          (e.code = 'BABEL_REPLACE_SOURCE_ERROR')),
        e)
      )
    }
    return (t = t.program.body[0].expression), fp.default.removeProperties(t), this.replaceWith(t)
  }
  function rz(t) {
    if ((this.resync(), this.removed)) throw new Error("You can't replace this node, we've already removed it")
    if ((t instanceof LU.default && (t = t.node), !t))
      throw new Error('You passed `path.replaceWith()` a falsy node, use `path.remove()` instead')
    if (this.node === t) return [this]
    if (this.isProgram() && !XU(t))
      throw new Error('You can only replace a Program root node with another Program node')
    if (Array.isArray(t))
      throw new Error("Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`")
    if (typeof t == 'string')
      throw new Error("Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`")
    let e = ''
    if (
      (this.isNodeType('Statement') &&
        qU(t) &&
        !this.canHaveVariableDeclarationOrExpression() &&
        !this.canSwapBetweenExpressionAndStatement(t) &&
        !this.parentPath.isExportDefaultDeclaration() &&
        ((t = zU(t)), (e = 'expression')),
      this.isNodeType('Expression') &&
        GU(t) &&
        !this.canHaveVariableDeclarationOrExpression() &&
        !this.canSwapBetweenExpressionAndStatement(t))
    )
      return this.replaceExpressionWithStatements([t])
    const r = this.node
    return (
      r && (HU(t, r), JU(r)),
      this._replaceWith(t),
      (this.type = t.type),
      this.setScope(),
      this.requeue(),
      [e ? this.get(e) : this]
    )
  }
  function iz(t) {
    var e
    if (!this.container) throw new ReferenceError('Container is falsy')
    this.inList ? N0(this.parent, this.key, [t]) : N0(this.parent, this.key, t),
      this.debug(`Replace with ${t == null ? void 0 : t.type}`),
      (e = C0.path.get(this.parent)) == null || e.set(t, this).delete(this.node),
      (this.node = this.container[this.key] = t)
  }
  function nz(t) {
    this.resync()
    const e = ZU(t, this.scope)
    if (e) return this.replaceWith(e)[0].get('expressions')
    const r = this.getFunctionParent(),
      i = r == null ? void 0 : r.is('async'),
      n = r == null ? void 0 : r.is('generator'),
      s = RU([], VU(t))
    this.replaceWith(UU(s, []))
    const a = this.get('callee')
    ;(0, $U.default)(
      a.get('body'),
      (h) => {
        this.scope.push({ id: h })
      },
      'var'
    )
    const o = this.get('callee').getCompletionRecords()
    for (const h of o) {
      if (!h.isExpressionStatement()) continue
      const f = h.findParent((d) => d.isLoop())
      if (f) {
        let d = f.getData('expressionReplacementReturnUid')
        d
          ? (d = KU(d.name))
          : ((d = a.scope.generateDeclaredUidIdentifier('ret')),
            a.get('body').pushContainer('body', k0(I0(d))),
            f.setData('expressionReplacementReturnUid', d)),
          h.get('expression').replaceWith(jU('=', I0(d), h.node.expression))
      } else h.replaceWith(k0(h.node.expression))
    }
    a.arrowFunctionToExpression()
    const u = a,
      c = i && fp.default.hasType(this.get('callee.body').node, 'AwaitExpression', x0),
      p = n && fp.default.hasType(this.get('callee.body').node, 'YieldExpression', x0)
    return (
      c && (u.set('async', !0), p || this.replaceWith(_U(this.node))),
      p && (u.set('generator', !0), this.replaceWith(QU(this.node, !0))),
      u.get('body.body')
    )
  }
  function sz(t) {
    if ((this.resync(), Array.isArray(t)))
      if (Array.isArray(this.container)) {
        t = this._verifyNodeList(t)
        const e = this._containerInsertAfter(t)
        return this.remove(), e
      } else return this.replaceWithMultiple(t)
    else return this.replaceWith(t)
  }
  var Ro = {}
  Object.defineProperty(Ro, '__esModule', { value: !0 }), (Ro.evaluate = uz), (Ro.evaluateTruthy = oz)
  const O0 = ['String', 'Number', 'Math'],
    az = ['random']
  function oz() {
    const t = this.evaluate()
    if (t.confident) return !!t.value
  }
  function mr(t, e) {
    !e.confident || ((e.deoptPath = t), (e.confident = !1))
  }
  function ar(t, e) {
    const { node: r } = t,
      { seen: i } = e
    if (i.has(r)) {
      const n = i.get(r)
      if (n.resolved) return n.value
      mr(t, e)
      return
    } else {
      const n = { resolved: !1 }
      i.set(r, n)
      const s = lz(t, e)
      return e.confident && ((n.resolved = !0), (n.value = s)), s
    }
  }
  function lz(t, e) {
    if (!!e.confident) {
      if (t.isSequenceExpression()) {
        const r = t.get('expressions')
        return ar(r[r.length - 1], e)
      }
      if (t.isStringLiteral() || t.isNumericLiteral() || t.isBooleanLiteral()) return t.node.value
      if (t.isNullLiteral()) return null
      if (t.isTemplateLiteral()) return D0(t, t.node.quasis, e)
      if (t.isTaggedTemplateExpression() && t.get('tag').isMemberExpression()) {
        const r = t.get('tag.object'),
          {
            node: { name: i },
          } = r,
          n = t.get('tag.property')
        if (r.isIdentifier() && i === 'String' && !t.scope.getBinding(i) && n.isIdentifier() && n.node.name === 'raw')
          return D0(t, t.node.quasi.quasis, e, !0)
      }
      if (t.isConditionalExpression()) {
        const r = ar(t.get('test'), e)
        return e.confident ? ar(r ? t.get('consequent') : t.get('alternate'), e) : void 0
      }
      if (t.isExpressionWrapper()) return ar(t.get('expression'), e)
      if (t.isMemberExpression() && !t.parentPath.isCallExpression({ callee: t.node })) {
        const r = t.get('property'),
          i = t.get('object')
        if (i.isLiteral() && r.isIdentifier()) {
          const n = i.node.value,
            s = typeof n
          if (s === 'number' || s === 'string') return n[r.node.name]
        }
      }
      if (t.isReferencedIdentifier()) {
        const r = t.scope.getBinding(t.node.name)
        if ((r && r.constantViolations.length > 0) || (r && t.node.start < r.path.node.end)) return mr(r.path, e)
        if (r != null && r.hasValue) return r.value
        {
          if (t.node.name === 'undefined') return r ? mr(r.path, e) : void 0
          if (t.node.name === 'Infinity') return r ? mr(r.path, e) : 1 / 0
          if (t.node.name === 'NaN') return r ? mr(r.path, e) : NaN
          const i = t.resolve()
          return i === t ? mr(t, e) : ar(i, e)
        }
      }
      if (t.isUnaryExpression({ prefix: !0 })) {
        if (t.node.operator === 'void') return
        const r = t.get('argument')
        if (t.node.operator === 'typeof' && (r.isFunction() || r.isClass())) return 'function'
        const i = ar(r, e)
        if (!e.confident) return
        switch (t.node.operator) {
          case '!':
            return !i
          case '+':
            return +i
          case '-':
            return -i
          case '~':
            return ~i
          case 'typeof':
            return typeof i
        }
      }
      if (t.isArrayExpression()) {
        const r = [],
          i = t.get('elements')
        for (const n of i) {
          const s = n.evaluate()
          if (s.confident) r.push(s.value)
          else return mr(s.deopt, e)
        }
        return r
      }
      if (t.isObjectExpression()) {
        const r = {},
          i = t.get('properties')
        for (const n of i) {
          if (n.isObjectMethod() || n.isSpreadElement()) return mr(n, e)
          let a = n.get('key')
          if (n.node.computed) {
            if (((a = a.evaluate()), !a.confident)) return mr(a.deopt, e)
            a = a.value
          } else a.isIdentifier() ? (a = a.node.name) : (a = a.node.value)
          let u = n.get('value').evaluate()
          if (!u.confident) return mr(u.deopt, e)
          ;(u = u.value), (r[a] = u)
        }
        return r
      }
      if (t.isLogicalExpression()) {
        const r = e.confident,
          i = ar(t.get('left'), e),
          n = e.confident
        e.confident = r
        const s = ar(t.get('right'), e),
          a = e.confident
        switch (t.node.operator) {
          case '||':
            return (e.confident = n && (!!i || a)), e.confident ? i || s : void 0
          case '&&':
            return (e.confident = n && (!i || a)), e.confident ? i && s : void 0
        }
      }
      if (t.isBinaryExpression()) {
        const r = ar(t.get('left'), e)
        if (!e.confident) return
        const i = ar(t.get('right'), e)
        if (!e.confident) return
        switch (t.node.operator) {
          case '-':
            return r - i
          case '+':
            return r + i
          case '/':
            return r / i
          case '*':
            return r * i
          case '%':
            return r % i
          case '**':
            return Math.pow(r, i)
          case '<':
            return r < i
          case '>':
            return r > i
          case '<=':
            return r <= i
          case '>=':
            return r >= i
          case '==':
            return r == i
          case '!=':
            return r != i
          case '===':
            return r === i
          case '!==':
            return r !== i
          case '|':
            return r | i
          case '&':
            return r & i
          case '^':
            return r ^ i
          case '<<':
            return r << i
          case '>>':
            return r >> i
          case '>>>':
            return r >>> i
        }
      }
      if (t.isCallExpression()) {
        const r = t.get('callee')
        let i, n
        if (
          (r.isIdentifier() &&
            !t.scope.getBinding(r.node.name) &&
            O0.indexOf(r.node.name) >= 0 &&
            (n = jt[r.node.name]),
          r.isMemberExpression())
        ) {
          const s = r.get('object'),
            a = r.get('property')
          if (
            (s.isIdentifier() &&
              a.isIdentifier() &&
              O0.indexOf(s.node.name) >= 0 &&
              az.indexOf(a.node.name) < 0 &&
              ((i = jt[s.node.name]), (n = i[a.node.name])),
            s.isLiteral() && a.isIdentifier())
          ) {
            const o = typeof s.node.value
            ;(o === 'string' || o === 'number') && ((i = s.node.value), (n = i[a.node.name]))
          }
        }
        if (n) {
          const s = t.get('arguments').map((a) => ar(a, e))
          return e.confident ? n.apply(i, s) : void 0
        }
      }
      mr(t, e)
    }
  }
  function D0(t, e, r, i = !1) {
    let n = '',
      s = 0
    const a = t.get('expressions')
    for (const o of e) {
      if (!r.confident) break
      n += i ? o.value.raw : o.value.cooked
      const u = a[s++]
      u && (n += String(ar(u, r)))
    }
    if (!!r.confident) return n
  }
  function uz() {
    const t = { confident: !0, deoptPath: null, seen: new Map() }
    let e = ar(this, t)
    return t.confident || (e = void 0), { confident: t.confident, deopt: t.deoptPath, value: e }
  }
  var an = {},
    hp = {},
    or = {},
    yr = {}
  Object.defineProperty(yr, '__esModule', { value: !0 }),
    (yr.statements = yr.statement = yr.smart = yr.program = yr.expression = void 0)
  var cz = st
  const { assertExpressionStatement: pz } = cz
  function dp(t) {
    return {
      code: (e) => `/* @babel/template */;
${e}`,
      validate: () => {},
      unwrap: (e) => t(e.program.body.slice(1)),
    }
  }
  const fz = dp((t) => (t.length > 1 ? t : t[0]))
  yr.smart = fz
  const hz = dp((t) => t)
  yr.statements = hz
  const dz = dp((t) => {
    if (t.length === 0) throw new Error('Found nothing to return.')
    if (t.length > 1) throw new Error('Found multiple statements but wanted one')
    return t[0]
  })
  yr.statement = dz
  const B0 = {
    code: (t) => `(
${t}
)`,
    validate: (t) => {
      if (t.program.body.length > 1) throw new Error('Found multiple statements but wanted one')
      if (B0.unwrap(t).start === 0) throw new Error('Parse result included parens.')
    },
    unwrap: ({ program: t }) => {
      const [e] = t.body
      return pz(e), e.expression
    },
  }
  yr.expression = B0
  const mz = { code: (t) => t, validate: () => {}, unwrap: (t) => t.program }
  yr.program = mz
  var mp = {},
    on = {}
  Object.defineProperty(on, '__esModule', { value: !0 }),
    (on.merge = Tz),
    (on.normalizeReplacements = Sz),
    (on.validate = bz)
  const yz = ['placeholderWhitelist', 'placeholderPattern', 'preserveComments', 'syntacticPlaceholders']
  function gz(t, e) {
    if (t == null) return {}
    var r = {},
      i = Object.keys(t),
      n,
      s
    for (s = 0; s < i.length; s++) (n = i[s]), !(e.indexOf(n) >= 0) && (r[n] = t[n])
    return r
  }
  function Tz(t, e) {
    const {
      placeholderWhitelist: r = t.placeholderWhitelist,
      placeholderPattern: i = t.placeholderPattern,
      preserveComments: n = t.preserveComments,
      syntacticPlaceholders: s = t.syntacticPlaceholders,
    } = e
    return {
      parser: Object.assign({}, t.parser, e.parser),
      placeholderWhitelist: r,
      placeholderPattern: i,
      preserveComments: n,
      syntacticPlaceholders: s,
    }
  }
  function bz(t) {
    if (t != null && typeof t != 'object') throw new Error('Unknown template options.')
    const e = t || {},
      { placeholderWhitelist: r, placeholderPattern: i, preserveComments: n, syntacticPlaceholders: s } = e,
      a = gz(e, yz)
    if (r != null && !(r instanceof Set)) throw new Error("'.placeholderWhitelist' must be a Set, null, or undefined")
    if (i != null && !(i instanceof RegExp) && i !== !1)
      throw new Error("'.placeholderPattern' must be a RegExp, false, null, or undefined")
    if (n != null && typeof n != 'boolean') throw new Error("'.preserveComments' must be a boolean, null, or undefined")
    if (s != null && typeof s != 'boolean')
      throw new Error("'.syntacticPlaceholders' must be a boolean, null, or undefined")
    if (s === !0 && (r != null || i != null))
      throw new Error(
        "'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'"
      )
    return {
      parser: a,
      placeholderWhitelist: r || void 0,
      placeholderPattern: i == null ? void 0 : i,
      preserveComments: n == null ? void 0 : n,
      syntacticPlaceholders: s == null ? void 0 : s,
    }
  }
  function Sz(t) {
    if (Array.isArray(t)) return t.reduce((e, r, i) => ((e['$' + i] = r), e), {})
    if (typeof t == 'object' || t == null) return t || void 0
    throw new Error('Template replacements must be an array, object, null, or undefined')
  }
  var yp = {},
    jo = {},
    Fs = {}
  Object.defineProperty(Fs, '__esModule', { value: !0 })
  function gp(t, e) {
    if (t == null) return {}
    var r = {},
      i = Object.keys(t),
      n,
      s
    for (s = 0; s < i.length; s++) (n = i[s]), !(e.indexOf(n) >= 0) && (r[n] = t[n])
    return r
  }
  class ln {
    constructor(e, r, i) {
      ;(this.line = void 0),
        (this.column = void 0),
        (this.index = void 0),
        (this.line = e),
        (this.column = r),
        (this.index = i)
    }
  }
  class _o {
    constructor(e, r) {
      ;(this.start = void 0),
        (this.end = void 0),
        (this.filename = void 0),
        (this.identifierName = void 0),
        (this.start = e),
        (this.end = r)
    }
  }
  function Wt(t, e) {
    const { line: r, column: i, index: n } = t
    return new ln(r, i + e, n + e)
  }
  const Tp = Object.freeze({
      SyntaxError: 'BABEL_PARSER_SYNTAX_ERROR',
      SourceTypeModuleError: 'BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED',
    }),
    vz = (t, e = t.length - 1) => ({
      get() {
        return t.reduce((r, i) => r[i], this)
      },
      set(r) {
        t.reduce((i, n, s) => (s === e ? (i[n] = r) : i[n]), this)
      },
    }),
    Ez = (t, e, r) =>
      Object.keys(r)
        .map((i) => [i, r[i]])
        .filter(([, i]) => !!i)
        .map(([i, n]) => [
          i,
          typeof n == 'function'
            ? { value: n, enumerable: !1 }
            : typeof n.reflect == 'string'
            ? Object.assign({}, n, vz(n.reflect.split('.')))
            : n,
        ])
        .reduce(
          (i, [n, s]) => Object.defineProperty(i, n, Object.assign({ configurable: !0 }, s)),
          Object.assign(new t(), e)
        )
  var Pz = (t) => ({
    ImportMetaOutsideModule: t(`import.meta may appear only with 'sourceType: "module"'`, {
      code: Tp.SourceTypeModuleError,
    }),
    ImportOutsideModule: t(`'import' and 'export' may appear only with 'sourceType: "module"'`, {
      code: Tp.SourceTypeModuleError,
    }),
  })
  const L0 = {
      ArrayPattern: 'array destructuring pattern',
      AssignmentExpression: 'assignment expression',
      AssignmentPattern: 'assignment expression',
      ArrowFunctionExpression: 'arrow function expression',
      ConditionalExpression: 'conditional expression',
      ForOfStatement: 'for-of statement',
      ForInStatement: 'for-in statement',
      ForStatement: 'for-loop',
      FormalParameters: 'function parameter list',
      Identifier: 'identifier',
      ObjectPattern: 'object destructuring pattern',
      ParenthesizedExpression: 'parenthesized expression',
      RestElement: 'rest element',
      UpdateExpression: { true: 'prefix operation', false: 'postfix operation' },
      VariableDeclarator: 'variable declaration',
      YieldExpression: 'yield expression',
    },
    bp = ({ type: t, prefix: e }) => (t === 'UpdateExpression' ? L0.UpdateExpression[String(e)] : L0[t])
  var wz = (t) => ({
      AccessorIsGenerator: t(({ kind: e }) => `A ${e}ter cannot be a generator.`),
      ArgumentsInClass: t("'arguments' is only allowed in functions and class methods."),
      AsyncFunctionInSingleStatementContext: t(
        'Async functions can only be declared at the top level or inside a block.'
      ),
      AwaitBindingIdentifier: t("Can not use 'await' as identifier inside an async function."),
      AwaitBindingIdentifierInStaticBlock: t("Can not use 'await' as identifier inside a static block."),
      AwaitExpressionFormalParameter: t("'await' is not allowed in async function parameters."),
      AwaitNotInAsyncContext: t("'await' is only allowed within async functions and at the top levels of modules."),
      AwaitNotInAsyncFunction: t("'await' is only allowed within async functions."),
      BadGetterArity: t("A 'get' accesor must not have any formal parameters."),
      BadSetterArity: t("A 'set' accesor must have exactly one formal parameter."),
      BadSetterRestParameter: t("A 'set' accesor function argument must not be a rest parameter."),
      ConstructorClassField: t("Classes may not have a field named 'constructor'."),
      ConstructorClassPrivateField: t("Classes may not have a private field named '#constructor'."),
      ConstructorIsAccessor: t('Class constructor may not be an accessor.'),
      ConstructorIsAsync: t("Constructor can't be an async function."),
      ConstructorIsGenerator: t("Constructor can't be a generator."),
      DeclarationMissingInitializer: t(({ kind: e }) => `Missing initializer in ${e} declaration.`),
      DecoratorBeforeExport: t(
        "Decorators must be placed *before* the 'export' keyword. You can set the 'decoratorsBeforeExport' option to false to use the 'export @decorator class {}' syntax."
      ),
      DecoratorConstructor: t("Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?"),
      DecoratorExportClass: t(
        'Using the export keyword between a decorator and a class is not allowed. Please use `export @dec class` instead.'
      ),
      DecoratorSemicolon: t('Decorators must not be followed by a semicolon.'),
      DecoratorStaticBlock: t("Decorators can't be used with a static block."),
      DeletePrivateField: t('Deleting a private field is not allowed.'),
      DestructureNamedImport: t(
        'ES2015 named imports do not destructure. Use another statement for destructuring after the import.'
      ),
      DuplicateConstructor: t('Duplicate constructor in the same class.'),
      DuplicateDefaultExport: t('Only one default export allowed per module.'),
      DuplicateExport: t(
        ({ exportName: e }) => `\`${e}\` has already been exported. Exported identifiers must be unique.`
      ),
      DuplicateProto: t('Redefinition of __proto__ property.'),
      DuplicateRegExpFlags: t('Duplicate regular expression flag.'),
      ElementAfterRest: t('Rest element must be last element.'),
      EscapedCharNotAnIdentifier: t('Invalid Unicode escape.'),
      ExportBindingIsString: t(
        ({ localName: e, exportName: r }) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${e}' as '${r}' } from 'some-module'\`?`
      ),
      ExportDefaultFromAsIdentifier: t("'from' is not allowed as an identifier after 'export default'."),
      ForInOfLoopInitializer: t(
        ({ type: e }) =>
          `'${e === 'ForInStatement' ? 'for-in' : 'for-of'}' loop variable declaration may not have an initializer.`
      ),
      ForOfAsync: t("The left-hand side of a for-of loop may not be 'async'."),
      ForOfLet: t("The left-hand side of a for-of loop may not start with 'let'."),
      GeneratorInSingleStatementContext: t('Generators can only be declared at the top level or inside a block.'),
      IllegalBreakContinue: t(({ type: e }) => `Unsyntactic ${e === 'BreakStatement' ? 'break' : 'continue'}.`),
      IllegalLanguageModeDirective: t("Illegal 'use strict' directive in function with non-simple parameter list."),
      IllegalReturn: t("'return' outside of function."),
      ImportBindingIsString: t(
        ({ importName: e }) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${e}" as foo }\`?`
      ),
      ImportCallArgumentTrailingComma: t('Trailing comma is disallowed inside import(...) arguments.'),
      ImportCallArity: t(
        ({ maxArgumentCount: e }) =>
          `\`import()\` requires exactly ${e === 1 ? 'one argument' : 'one or two arguments'}.`
      ),
      ImportCallNotNewExpression: t('Cannot use new with import(...).'),
      ImportCallSpreadArgument: t('`...` is not allowed in `import()`.'),
      IncompatibleRegExpUVFlags: t("The 'u' and 'v' regular expression flags cannot be enabled at the same time."),
      InvalidBigIntLiteral: t('Invalid BigIntLiteral.'),
      InvalidCodePoint: t('Code point out of bounds.'),
      InvalidCoverInitializedName: t('Invalid shorthand property initializer.'),
      InvalidDecimal: t('Invalid decimal.'),
      InvalidDigit: t(({ radix: e }) => `Expected number in radix ${e}.`),
      InvalidEscapeSequence: t('Bad character escape sequence.'),
      InvalidEscapeSequenceTemplate: t('Invalid escape sequence in template.'),
      InvalidEscapedReservedWord: t(({ reservedWord: e }) => `Escape sequence in keyword ${e}.`),
      InvalidIdentifier: t(({ identifierName: e }) => `Invalid identifier ${e}.`),
      InvalidLhs: t(({ ancestor: e }) => `Invalid left-hand side in ${bp(e)}.`),
      InvalidLhsBinding: t(({ ancestor: e }) => `Binding invalid left-hand side in ${bp(e)}.`),
      InvalidNumber: t('Invalid number.'),
      InvalidOrMissingExponent: t("Floating-point numbers require a valid exponent after the 'e'."),
      InvalidOrUnexpectedToken: t(({ unexpected: e }) => `Unexpected character '${e}'.`),
      InvalidParenthesizedAssignment: t('Invalid parenthesized assignment pattern.'),
      InvalidPrivateFieldResolution: t(({ identifierName: e }) => `Private name #${e} is not defined.`),
      InvalidPropertyBindingPattern: t('Binding member expression.'),
      InvalidRecordProperty: t('Only properties and spread elements are allowed in record definitions.'),
      InvalidRestAssignmentPattern: t("Invalid rest operator's argument."),
      LabelRedeclaration: t(({ labelName: e }) => `Label '${e}' is already declared.`),
      LetInLexicalBinding: t("'let' is not allowed to be used as a name in 'let' or 'const' declarations."),
      LineTerminatorBeforeArrow: t("No line break is allowed before '=>'."),
      MalformedRegExpFlags: t('Invalid regular expression flag.'),
      MissingClassName: t('A class name is required.'),
      MissingEqInAssignment: t("Only '=' operator can be used for specifying default value."),
      MissingSemicolon: t('Missing semicolon.'),
      MissingPlugin: t(
        ({ missingPlugin: e }) =>
          `This experimental syntax requires enabling the parser plugin: ${e.map((r) => JSON.stringify(r)).join(', ')}.`
      ),
      MissingOneOfPlugins: t(
        ({ missingPlugin: e }) =>
          `This experimental syntax requires enabling one of the following parser plugin(s): ${e
            .map((r) => JSON.stringify(r))
            .join(', ')}.`
      ),
      MissingUnicodeEscape: t('Expecting Unicode escape sequence \\uXXXX.'),
      MixingCoalesceWithLogical: t(
        'Nullish coalescing operator(??) requires parens when mixing with logical operators.'
      ),
      ModuleAttributeDifferentFromType: t('The only accepted module attribute is `type`.'),
      ModuleAttributeInvalidValue: t('Only string literals are allowed as module attribute values.'),
      ModuleAttributesWithDuplicateKeys: t(({ key: e }) => `Duplicate key "${e}" is not allowed in module attributes.`),
      ModuleExportNameHasLoneSurrogate: t(
        ({ surrogateCharCode: e }) => `An export name cannot include a lone surrogate, found '\\u${e.toString(16)}'.`
      ),
      ModuleExportUndefined: t(({ localName: e }) => `Export '${e}' is not defined.`),
      MultipleDefaultsInSwitch: t('Multiple default clauses.'),
      NewlineAfterThrow: t('Illegal newline after throw.'),
      NoCatchOrFinally: t('Missing catch or finally clause.'),
      NumberIdentifier: t('Identifier directly after number.'),
      NumericSeparatorInEscapeSequence: t(
        'Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.'
      ),
      ObsoleteAwaitStar: t("'await*' has been removed from the async functions proposal. Use Promise.all() instead."),
      OptionalChainingNoNew: t('Constructors in/after an Optional Chain are not allowed.'),
      OptionalChainingNoTemplate: t('Tagged Template Literals are not allowed in optionalChain.'),
      OverrideOnConstructor: t("'override' modifier cannot appear on a constructor declaration."),
      ParamDupe: t('Argument name clash.'),
      PatternHasAccessor: t("Object pattern can't contain getter or setter."),
      PatternHasMethod: t("Object pattern can't contain methods."),
      PrivateInExpectedIn: t(
        ({ identifierName: e }) =>
          `Private names are only allowed in property accesses (\`obj.#${e}\`) or in \`in\` expressions (\`#${e} in obj\`).`
      ),
      PrivateNameRedeclaration: t(({ identifierName: e }) => `Duplicate private name #${e}.`),
      RecordExpressionBarIncorrectEndSyntaxType: t(
        "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'."
      ),
      RecordExpressionBarIncorrectStartSyntaxType: t(
        "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'."
      ),
      RecordExpressionHashIncorrectStartSyntaxType: t(
        "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'."
      ),
      RecordNoProto: t("'__proto__' is not allowed in Record expressions."),
      RestTrailingComma: t('Unexpected trailing comma after rest element.'),
      SloppyFunction: t(
        'In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.'
      ),
      StaticPrototype: t('Classes may not have static property named prototype.'),
      SuperNotAllowed: t(
        "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?"
      ),
      SuperPrivateField: t("Private fields can't be accessed on super."),
      TrailingDecorator: t('Decorators must be attached to a class element.'),
      TupleExpressionBarIncorrectEndSyntaxType: t(
        "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'."
      ),
      TupleExpressionBarIncorrectStartSyntaxType: t(
        "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'."
      ),
      TupleExpressionHashIncorrectStartSyntaxType: t(
        "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'."
      ),
      UnexpectedArgumentPlaceholder: t('Unexpected argument placeholder.'),
      UnexpectedAwaitAfterPipelineBody: t(
        'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.'
      ),
      UnexpectedDigitAfterHash: t('Unexpected digit after hash token.'),
      UnexpectedImportExport: t("'import' and 'export' may only appear at the top level."),
      UnexpectedKeyword: t(({ keyword: e }) => `Unexpected keyword '${e}'.`),
      UnexpectedLeadingDecorator: t('Leading decorators must be attached to a class declaration.'),
      UnexpectedLexicalDeclaration: t('Lexical declaration cannot appear in a single-statement context.'),
      UnexpectedNewTarget: t('`new.target` can only be used in functions or class properties.'),
      UnexpectedNumericSeparator: t('A numeric separator is only allowed between two digits.'),
      UnexpectedPrivateField: t('Unexpected private name.'),
      UnexpectedReservedWord: t(({ reservedWord: e }) => `Unexpected reserved word '${e}'.`),
      UnexpectedSuper: t("'super' is only allowed in object methods and classes."),
      UnexpectedToken: t(
        ({ expected: e, unexpected: r }) => `Unexpected token${r ? ` '${r}'.` : ''}${e ? `, expected "${e}"` : ''}`
      ),
      UnexpectedTokenUnaryExponentiation: t(
        'Illegal expression. Wrap left hand side or entire exponentiation in parentheses.'
      ),
      UnsupportedBind: t('Binding should be performed on object property.'),
      UnsupportedDecoratorExport: t('A decorated export must export a class declaration.'),
      UnsupportedDefaultExport: t('Only expressions, functions or classes are allowed as the `default` export.'),
      UnsupportedImport: t('`import` can only be used in `import()` or `import.meta`.'),
      UnsupportedMetaProperty: t(
        ({ target: e, onlyValidPropertyName: r }) => `The only valid meta property for ${e} is ${e}.${r}.`
      ),
      UnsupportedParameterDecorator: t('Decorators cannot be used to decorate parameters.'),
      UnsupportedPropertyDecorator: t('Decorators cannot be used to decorate object literal properties.'),
      UnsupportedSuper: t(
        "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop])."
      ),
      UnterminatedComment: t('Unterminated comment.'),
      UnterminatedRegExp: t('Unterminated regular expression.'),
      UnterminatedString: t('Unterminated string constant.'),
      UnterminatedTemplate: t('Unterminated template.'),
      VarRedeclaration: t(({ identifierName: e }) => `Identifier '${e}' has already been declared.`),
      YieldBindingIdentifier: t("Can not use 'yield' as identifier inside a generator."),
      YieldInParameter: t('Yield expression is not allowed in formal parameters.'),
      ZeroDigitNumericSeparator: t('Numeric separator can not be used after leading 0.'),
    }),
    Az = (t) => ({
      StrictDelete: t('Deleting local variable in strict mode.'),
      StrictEvalArguments: t(({ referenceName: e }) => `Assigning to '${e}' in strict mode.`),
      StrictEvalArgumentsBinding: t(({ bindingName: e }) => `Binding '${e}' in strict mode.`),
      StrictFunction: t('In strict mode code, functions can only be declared at top level or inside a block.'),
      StrictNumericEscape: t("The only valid numeric escape in strict mode is '\\0'."),
      StrictOctalLiteral: t('Legacy octal literals are not allowed in strict mode.'),
      StrictWith: t("'with' in strict mode."),
    })
  const Cz = new Set(['ArrowFunctionExpression', 'AssignmentExpression', 'ConditionalExpression', 'YieldExpression'])
  var xz = (t) => ({
    PipeBodyIsTighter: t(
      'Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.'
    ),
    PipeTopicRequiresHackPipes: t(
      'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.'
    ),
    PipeTopicUnbound: t('Topic reference is unbound; it must be inside a pipe body.'),
    PipeTopicUnconfiguredToken: t(
      ({ token: e }) =>
        `Invalid topic token ${e}. In order to use ${e} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${e}" }.`
    ),
    PipeTopicUnused: t(
      'Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.'
    ),
    PipeUnparenthesizedBody: t(
      ({ type: e }) =>
        `Hack-style pipe body cannot be an unparenthesized ${bp({ type: e })}; please wrap it in parentheses.`
    ),
    PipelineBodyNoArrow: t(
      'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.'
    ),
    PipelineBodySequenceExpression: t('Pipeline body may not be a comma-separated sequence expression.'),
    PipelineHeadSequenceExpression: t('Pipeline head should not be a comma-separated sequence expression.'),
    PipelineTopicUnused: t('Pipeline is in topic style but does not use topic reference.'),
    PrimaryTopicNotAllowed: t('Topic reference was used in a lexical context without topic binding.'),
    PrimaryTopicRequiresSmartPipeline: t(
      'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.'
    ),
  })
  const Iz = ['toMessage']
  function kz(t) {
    let { toMessage: e } = t,
      r = gp(t, Iz)
    return function i({ loc: n, details: s }) {
      return Ez(SyntaxError, Object.assign({}, r, { loc: n }), {
        clone(a = {}) {
          const o = a.loc || {}
          return i({
            loc: new ln(
              'line' in o ? o.line : this.loc.line,
              'column' in o ? o.column : this.loc.column,
              'index' in o ? o.index : this.loc.index
            ),
            details: Object.assign({}, this.details, a.details),
          })
        },
        details: { value: s, enumerable: !1 },
        message: {
          get() {
            return `${e(this.details)} (${this.loc.line}:${this.loc.column})`
          },
          set(a) {
            Object.defineProperty(this, 'message', { value: a })
          },
        },
        pos: { reflect: 'loc.index', enumerable: !0 },
        missingPlugin: 'missingPlugin' in s && { reflect: 'details.missingPlugin', enumerable: !0 },
      })
    }
  }
  function Nz(t, e) {
    return Object.assign({ toMessage: typeof t == 'string' ? () => t : t }, e)
  }
  function ei(t, e) {
    if (Array.isArray(t)) return (n) => ei(n, t[0])
    const r = t(Nz),
      i = {}
    for (const n of Object.keys(r))
      i[n] = kz(Object.assign({ code: Tp.SyntaxError, reasonCode: n }, e ? { syntaxPlugin: e } : {}, r[n]))
    return i
  }
  const re = Object.assign({}, ei(Pz), ei(wz), ei(Az), ei`pipelineOperator`(xz)),
    { defineProperty: Oz } = Object,
    M0 = (t, e) => Oz(t, e, { enumerable: !1, value: t[e] })
  function $s(t) {
    return t.loc.start && M0(t.loc.start, 'index'), t.loc.end && M0(t.loc.end, 'index'), t
  }
  var Dz = (t) =>
    class extends t {
      parse() {
        const e = $s(super.parse())
        return this.options.tokens && (e.tokens = e.tokens.map($s)), e
      }
      parseRegExpLiteral({ pattern: e, flags: r }) {
        let i = null
        try {
          i = new RegExp(e, r)
        } catch {}
        const n = this.estreeParseLiteral(i)
        return (n.regex = { pattern: e, flags: r }), n
      }
      parseBigIntLiteral(e) {
        let r
        try {
          r = BigInt(e)
        } catch {
          r = null
        }
        const i = this.estreeParseLiteral(r)
        return (i.bigint = String(i.value || e)), i
      }
      parseDecimalLiteral(e) {
        const i = this.estreeParseLiteral(null)
        return (i.decimal = String(i.value || e)), i
      }
      estreeParseLiteral(e) {
        return this.parseLiteral(e, 'Literal')
      }
      parseStringLiteral(e) {
        return this.estreeParseLiteral(e)
      }
      parseNumericLiteral(e) {
        return this.estreeParseLiteral(e)
      }
      parseNullLiteral() {
        return this.estreeParseLiteral(null)
      }
      parseBooleanLiteral(e) {
        return this.estreeParseLiteral(e)
      }
      directiveToStmt(e) {
        const r = e.value,
          i = this.startNodeAt(e.start, e.loc.start),
          n = this.startNodeAt(r.start, r.loc.start)
        return (
          (n.value = r.extra.expressionValue),
          (n.raw = r.extra.raw),
          (i.expression = this.finishNodeAt(n, 'Literal', r.loc.end)),
          (i.directive = r.extra.raw.slice(1, -1)),
          this.finishNodeAt(i, 'ExpressionStatement', e.loc.end)
        )
      }
      initFunction(e, r) {
        super.initFunction(e, r), (e.expression = !1)
      }
      checkDeclaration(e) {
        e != null && this.isObjectProperty(e) ? this.checkDeclaration(e.value) : super.checkDeclaration(e)
      }
      getObjectOrClassMethodParams(e) {
        return e.value.params
      }
      isValidDirective(e) {
        var r
        return (
          e.type === 'ExpressionStatement' &&
          e.expression.type === 'Literal' &&
          typeof e.expression.value == 'string' &&
          !((r = e.expression.extra) != null && r.parenthesized)
        )
      }
      parseBlockBody(e, ...r) {
        super.parseBlockBody(e, ...r)
        const i = e.directives.map((n) => this.directiveToStmt(n))
        ;(e.body = i.concat(e.body)), delete e.directives
      }
      pushClassMethod(e, r, i, n, s, a) {
        this.parseMethod(r, i, n, s, a, 'ClassMethod', !0),
          r.typeParameters && ((r.value.typeParameters = r.typeParameters), delete r.typeParameters),
          e.body.push(r)
      }
      parsePrivateName() {
        const e = super.parsePrivateName()
        return this.getPluginOption('estree', 'classFeatures') ? this.convertPrivateNameToPrivateIdentifier(e) : e
      }
      convertPrivateNameToPrivateIdentifier(e) {
        const r = super.getPrivateNameSV(e)
        return (e = e), delete e.id, (e.name = r), (e.type = 'PrivateIdentifier'), e
      }
      isPrivateName(e) {
        return this.getPluginOption('estree', 'classFeatures') ? e.type === 'PrivateIdentifier' : super.isPrivateName(e)
      }
      getPrivateNameSV(e) {
        return this.getPluginOption('estree', 'classFeatures') ? e.name : super.getPrivateNameSV(e)
      }
      parseLiteral(e, r) {
        const i = super.parseLiteral(e, r)
        return (i.raw = i.extra.raw), delete i.extra, i
      }
      parseFunctionBody(e, r, i = !1) {
        super.parseFunctionBody(e, r, i), (e.expression = e.body.type !== 'BlockStatement')
      }
      parseMethod(e, r, i, n, s, a, o = !1) {
        let u = this.startNode()
        return (
          (u.kind = e.kind),
          (u = super.parseMethod(u, r, i, n, s, a, o)),
          (u.type = 'FunctionExpression'),
          delete u.kind,
          (e.value = u),
          a === 'ClassPrivateMethod' && (e.computed = !1),
          (a = 'MethodDefinition'),
          this.finishNode(e, a)
        )
      }
      parseClassProperty(...e) {
        const r = super.parseClassProperty(...e)
        return this.getPluginOption('estree', 'classFeatures') && (r.type = 'PropertyDefinition'), r
      }
      parseClassPrivateProperty(...e) {
        const r = super.parseClassPrivateProperty(...e)
        return (
          this.getPluginOption('estree', 'classFeatures') && ((r.type = 'PropertyDefinition'), (r.computed = !1)), r
        )
      }
      parseObjectMethod(e, r, i, n, s) {
        const a = super.parseObjectMethod(e, r, i, n, s)
        return a && ((a.type = 'Property'), a.kind === 'method' && (a.kind = 'init'), (a.shorthand = !1)), a
      }
      parseObjectProperty(e, r, i, n, s) {
        const a = super.parseObjectProperty(e, r, i, n, s)
        return a && ((a.kind = 'init'), (a.type = 'Property')), a
      }
      isValidLVal(e, ...r) {
        return e === 'Property' ? 'value' : super.isValidLVal(e, ...r)
      }
      isAssignable(e, r) {
        return e != null && this.isObjectProperty(e) ? this.isAssignable(e.value, r) : super.isAssignable(e, r)
      }
      toAssignable(e, r = !1) {
        if (e != null && this.isObjectProperty(e)) {
          const { key: i, value: n } = e
          this.isPrivateName(i) && this.classScope.usePrivateName(this.getPrivateNameSV(i), i.loc.start),
            this.toAssignable(n, r)
        } else super.toAssignable(e, r)
      }
      toAssignableObjectExpressionProp(e) {
        e.kind === 'get' || e.kind === 'set'
          ? this.raise(re.PatternHasAccessor, { at: e.key })
          : e.method
          ? this.raise(re.PatternHasMethod, { at: e.key })
          : super.toAssignableObjectExpressionProp(...arguments)
      }
      finishCallExpression(e, r) {
        if ((super.finishCallExpression(e, r), e.callee.type === 'Import')) {
          if (((e.type = 'ImportExpression'), (e.source = e.arguments[0]), this.hasPlugin('importAssertions'))) {
            var i
            e.attributes = (i = e.arguments[1]) != null ? i : null
          }
          delete e.arguments, delete e.callee
        }
        return e
      }
      toReferencedArguments(e) {
        e.type !== 'ImportExpression' && super.toReferencedArguments(e)
      }
      parseExport(e) {
        switch ((super.parseExport(e), e.type)) {
          case 'ExportAllDeclaration':
            e.exported = null
            break
          case 'ExportNamedDeclaration':
            e.specifiers.length === 1 &&
              e.specifiers[0].type === 'ExportNamespaceSpecifier' &&
              ((e.type = 'ExportAllDeclaration'), (e.exported = e.specifiers[0].exported), delete e.specifiers)
            break
        }
        return e
      }
      parseSubscript(e, r, i, n, s) {
        const a = super.parseSubscript(e, r, i, n, s)
        if (s.optionalChainMember) {
          if (
            ((a.type === 'OptionalMemberExpression' || a.type === 'OptionalCallExpression') &&
              (a.type = a.type.substring(8)),
            s.stop)
          ) {
            const o = this.startNodeAtNode(a)
            return (o.expression = a), this.finishNode(o, 'ChainExpression')
          }
        } else (a.type === 'MemberExpression' || a.type === 'CallExpression') && (a.optional = !1)
        return a
      }
      hasPropertyAsPrivateName(e) {
        return e.type === 'ChainExpression' && (e = e.expression), super.hasPropertyAsPrivateName(e)
      }
      isOptionalChain(e) {
        return e.type === 'ChainExpression'
      }
      isObjectProperty(e) {
        return e.type === 'Property' && e.kind === 'init' && !e.method
      }
      isObjectMethod(e) {
        return e.method || e.kind === 'get' || e.kind === 'set'
      }
      finishNodeAt(e, r, i) {
        return $s(super.finishNodeAt(e, r, i))
      }
      resetStartLocation(e, r, i) {
        super.resetStartLocation(e, r, i), $s(e)
      }
      resetEndLocation(e, r = this.state.lastTokEndLoc) {
        super.resetEndLocation(e, r), $s(e)
      }
    }
  class Rs {
    constructor(e, r) {
      ;(this.token = void 0), (this.preserveSpace = void 0), (this.token = e), (this.preserveSpace = !!r)
    }
  }
  const Tt = {
    brace: new Rs('{'),
    j_oTag: new Rs('<tag'),
    j_cTag: new Rs('</tag'),
    j_expr: new Rs('<tag>...</tag>', !0),
  }
  Tt.template = new Rs('`', !0)
  const nt = !0,
    Oe = !0,
    Sp = !0,
    js = !0,
    vi = !0,
    Bz = !0
  class F0 {
    constructor(e, r = {}) {
      ;(this.label = void 0),
        (this.keyword = void 0),
        (this.beforeExpr = void 0),
        (this.startsExpr = void 0),
        (this.rightAssociative = void 0),
        (this.isLoop = void 0),
        (this.isAssign = void 0),
        (this.prefix = void 0),
        (this.postfix = void 0),
        (this.binop = void 0),
        (this.label = e),
        (this.keyword = r.keyword),
        (this.beforeExpr = !!r.beforeExpr),
        (this.startsExpr = !!r.startsExpr),
        (this.rightAssociative = !!r.rightAssociative),
        (this.isLoop = !!r.isLoop),
        (this.isAssign = !!r.isAssign),
        (this.prefix = !!r.prefix),
        (this.postfix = !!r.postfix),
        (this.binop = r.binop != null ? r.binop : null),
        (this.updateContext = null)
    }
  }
  const vp = new Map()
  function ut(t, e = {}) {
    e.keyword = t
    const r = ze(t, e)
    return vp.set(t, r), r
  }
  function er(t, e) {
    return ze(t, { beforeExpr: nt, binop: e })
  }
  let _s = -1
  const ti = [],
    Ep = [],
    Vo = [],
    Pp = [],
    wp = [],
    Ap = []
  function ze(t, e = {}) {
    var r, i, n, s
    return (
      ++_s,
      Ep.push(t),
      Vo.push((r = e.binop) != null ? r : -1),
      Pp.push((i = e.beforeExpr) != null ? i : !1),
      wp.push((n = e.startsExpr) != null ? n : !1),
      Ap.push((s = e.prefix) != null ? s : !1),
      ti.push(new F0(t, e)),
      _s
    )
  }
  function ct(t, e) {
    var r, i, n, s
    return (
      ++_s,
      vp.set(t, _s),
      Ep.push(t),
      Vo.push((r = e.binop) != null ? r : -1),
      Pp.push((i = e.beforeExpr) != null ? i : !1),
      wp.push((n = e.startsExpr) != null ? n : !1),
      Ap.push((s = e.prefix) != null ? s : !1),
      ti.push(new F0('name', e)),
      _s
    )
  }
  const Lz = {
    bracketL: ze('[', { beforeExpr: nt, startsExpr: Oe }),
    bracketHashL: ze('#[', { beforeExpr: nt, startsExpr: Oe }),
    bracketBarL: ze('[|', { beforeExpr: nt, startsExpr: Oe }),
    bracketR: ze(']'),
    bracketBarR: ze('|]'),
    braceL: ze('{', { beforeExpr: nt, startsExpr: Oe }),
    braceBarL: ze('{|', { beforeExpr: nt, startsExpr: Oe }),
    braceHashL: ze('#{', { beforeExpr: nt, startsExpr: Oe }),
    braceR: ze('}'),
    braceBarR: ze('|}'),
    parenL: ze('(', { beforeExpr: nt, startsExpr: Oe }),
    parenR: ze(')'),
    comma: ze(',', { beforeExpr: nt }),
    semi: ze(';', { beforeExpr: nt }),
    colon: ze(':', { beforeExpr: nt }),
    doubleColon: ze('::', { beforeExpr: nt }),
    dot: ze('.'),
    question: ze('?', { beforeExpr: nt }),
    questionDot: ze('?.'),
    arrow: ze('=>', { beforeExpr: nt }),
    template: ze('template'),
    ellipsis: ze('...', { beforeExpr: nt }),
    backQuote: ze('`', { startsExpr: Oe }),
    dollarBraceL: ze('${', { beforeExpr: nt, startsExpr: Oe }),
    templateTail: ze('...`', { startsExpr: Oe }),
    templateNonTail: ze('...${', { beforeExpr: nt, startsExpr: Oe }),
    at: ze('@'),
    hash: ze('#', { startsExpr: Oe }),
    interpreterDirective: ze('#!...'),
    eq: ze('=', { beforeExpr: nt, isAssign: js }),
    assign: ze('_=', { beforeExpr: nt, isAssign: js }),
    slashAssign: ze('_=', { beforeExpr: nt, isAssign: js }),
    xorAssign: ze('_=', { beforeExpr: nt, isAssign: js }),
    moduloAssign: ze('_=', { beforeExpr: nt, isAssign: js }),
    incDec: ze('++/--', { prefix: vi, postfix: Bz, startsExpr: Oe }),
    bang: ze('!', { beforeExpr: nt, prefix: vi, startsExpr: Oe }),
    tilde: ze('~', { beforeExpr: nt, prefix: vi, startsExpr: Oe }),
    doubleCaret: ze('^^', { startsExpr: Oe }),
    doubleAt: ze('@@', { startsExpr: Oe }),
    pipeline: er('|>', 0),
    nullishCoalescing: er('??', 1),
    logicalOR: er('||', 1),
    logicalAND: er('&&', 2),
    bitwiseOR: er('|', 3),
    bitwiseXOR: er('^', 4),
    bitwiseAND: er('&', 5),
    equality: er('==/!=/===/!==', 6),
    lt: er('</>/<=/>=', 7),
    gt: er('</>/<=/>=', 7),
    relational: er('</>/<=/>=', 7),
    bitShift: er('<</>>/>>>', 8),
    bitShiftL: er('<</>>/>>>', 8),
    bitShiftR: er('<</>>/>>>', 8),
    plusMin: ze('+/-', { beforeExpr: nt, binop: 9, prefix: vi, startsExpr: Oe }),
    modulo: ze('%', { binop: 10, startsExpr: Oe }),
    star: ze('*', { binop: 10 }),
    slash: er('/', 10),
    exponent: ze('**', { beforeExpr: nt, binop: 11, rightAssociative: !0 }),
    _in: ut('in', { beforeExpr: nt, binop: 7 }),
    _instanceof: ut('instanceof', { beforeExpr: nt, binop: 7 }),
    _break: ut('break'),
    _case: ut('case', { beforeExpr: nt }),
    _catch: ut('catch'),
    _continue: ut('continue'),
    _debugger: ut('debugger'),
    _default: ut('default', { beforeExpr: nt }),
    _else: ut('else', { beforeExpr: nt }),
    _finally: ut('finally'),
    _function: ut('function', { startsExpr: Oe }),
    _if: ut('if'),
    _return: ut('return', { beforeExpr: nt }),
    _switch: ut('switch'),
    _throw: ut('throw', { beforeExpr: nt, prefix: vi, startsExpr: Oe }),
    _try: ut('try'),
    _var: ut('var'),
    _const: ut('const'),
    _with: ut('with'),
    _new: ut('new', { beforeExpr: nt, startsExpr: Oe }),
    _this: ut('this', { startsExpr: Oe }),
    _super: ut('super', { startsExpr: Oe }),
    _class: ut('class', { startsExpr: Oe }),
    _extends: ut('extends', { beforeExpr: nt }),
    _export: ut('export'),
    _import: ut('import', { startsExpr: Oe }),
    _null: ut('null', { startsExpr: Oe }),
    _true: ut('true', { startsExpr: Oe }),
    _false: ut('false', { startsExpr: Oe }),
    _typeof: ut('typeof', { beforeExpr: nt, prefix: vi, startsExpr: Oe }),
    _void: ut('void', { beforeExpr: nt, prefix: vi, startsExpr: Oe }),
    _delete: ut('delete', { beforeExpr: nt, prefix: vi, startsExpr: Oe }),
    _do: ut('do', { isLoop: Sp, beforeExpr: nt }),
    _for: ut('for', { isLoop: Sp }),
    _while: ut('while', { isLoop: Sp }),
    _as: ct('as', { startsExpr: Oe }),
    _assert: ct('assert', { startsExpr: Oe }),
    _async: ct('async', { startsExpr: Oe }),
    _await: ct('await', { startsExpr: Oe }),
    _from: ct('from', { startsExpr: Oe }),
    _get: ct('get', { startsExpr: Oe }),
    _let: ct('let', { startsExpr: Oe }),
    _meta: ct('meta', { startsExpr: Oe }),
    _of: ct('of', { startsExpr: Oe }),
    _sent: ct('sent', { startsExpr: Oe }),
    _set: ct('set', { startsExpr: Oe }),
    _static: ct('static', { startsExpr: Oe }),
    _yield: ct('yield', { startsExpr: Oe }),
    _asserts: ct('asserts', { startsExpr: Oe }),
    _checks: ct('checks', { startsExpr: Oe }),
    _exports: ct('exports', { startsExpr: Oe }),
    _global: ct('global', { startsExpr: Oe }),
    _implements: ct('implements', { startsExpr: Oe }),
    _intrinsic: ct('intrinsic', { startsExpr: Oe }),
    _infer: ct('infer', { startsExpr: Oe }),
    _is: ct('is', { startsExpr: Oe }),
    _mixins: ct('mixins', { startsExpr: Oe }),
    _proto: ct('proto', { startsExpr: Oe }),
    _require: ct('require', { startsExpr: Oe }),
    _keyof: ct('keyof', { startsExpr: Oe }),
    _readonly: ct('readonly', { startsExpr: Oe }),
    _unique: ct('unique', { startsExpr: Oe }),
    _abstract: ct('abstract', { startsExpr: Oe }),
    _declare: ct('declare', { startsExpr: Oe }),
    _enum: ct('enum', { startsExpr: Oe }),
    _module: ct('module', { startsExpr: Oe }),
    _namespace: ct('namespace', { startsExpr: Oe }),
    _interface: ct('interface', { startsExpr: Oe }),
    _type: ct('type', { startsExpr: Oe }),
    _opaque: ct('opaque', { startsExpr: Oe }),
    name: ze('name', { startsExpr: Oe }),
    string: ze('string', { startsExpr: Oe }),
    num: ze('num', { startsExpr: Oe }),
    bigint: ze('bigint', { startsExpr: Oe }),
    decimal: ze('decimal', { startsExpr: Oe }),
    regexp: ze('regexp', { startsExpr: Oe }),
    privateName: ze('#name', { startsExpr: Oe }),
    eof: ze('eof'),
    jsxName: ze('jsxName'),
    jsxText: ze('jsxText', { beforeExpr: !0 }),
    jsxTagStart: ze('jsxTagStart', { startsExpr: !0 }),
    jsxTagEnd: ze('jsxTagEnd'),
    placeholder: ze('%%', { startsExpr: !0 }),
  }
  function mt(t) {
    return t >= 93 && t <= 128
  }
  function Mz(t) {
    return t <= 92
  }
  function ri(t) {
    return t >= 58 && t <= 128
  }
  function $0(t) {
    return t >= 58 && t <= 132
  }
  function Fz(t) {
    return Pp[t]
  }
  function Cp(t) {
    return wp[t]
  }
  function $z(t) {
    return t >= 29 && t <= 33
  }
  function R0(t) {
    return t >= 125 && t <= 127
  }
  function Rz(t) {
    return t >= 90 && t <= 92
  }
  function xp(t) {
    return t >= 58 && t <= 92
  }
  function jz(t) {
    return t >= 39 && t <= 59
  }
  function _z(t) {
    return t === 34
  }
  function Vz(t) {
    return Ap[t]
  }
  function Uz(t) {
    return t >= 117 && t <= 119
  }
  function zz(t) {
    return t >= 120 && t <= 126
  }
  function Ei(t) {
    return Ep[t]
  }
  function Uo(t) {
    return Vo[t]
  }
  function Kz(t) {
    return Vo[t] !== -1
  }
  function Wz(t) {
    return t === 57
  }
  function zo(t) {
    return t >= 24 && t <= 25
  }
  function ii(t) {
    return ti[t]
  }
  ;(ti[8].updateContext = (t) => {
    t.pop()
  }),
    (ti[5].updateContext =
      ti[7].updateContext =
      ti[23].updateContext =
        (t) => {
          t.push(Tt.brace)
        }),
    (ti[22].updateContext = (t) => {
      t[t.length - 1] === Tt.template ? t.pop() : t.push(Tt.template)
    }),
    (ti[138].updateContext = (t) => {
      t.push(Tt.j_expr, Tt.j_oTag)
    })
  let Ip =
      '\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC',
    j0 =
      '\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F'
  const Yz = new RegExp('[' + Ip + ']'),
    Hz = new RegExp('[' + Ip + j0 + ']')
  Ip = j0 = null
  const _0 = [
      0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5,
      7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10,
      21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11,
      25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72,
      56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44,
      33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2,
      9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0,
      185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16,
      0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50,
      29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2637, 96,
      16, 1070, 4050, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67,
      12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 46, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4,
      8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4,
      2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 482, 44,
      11, 6, 17, 0, 322, 29, 19, 43, 1269, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0,
      2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3,
      2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4152, 8, 221, 3, 5761, 15, 7472, 3104,
      541, 1507, 4938,
    ],
    qz = [
      509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 50, 3,
      123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2,
      11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0,
      82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3,
      2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2,
      13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 87, 9, 39, 4, 60, 6, 26, 9,
      1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49,
      513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 357, 0, 62, 13, 1495,
      6, 110, 6, 6, 9, 4759, 9, 787719, 239,
    ]
  function kp(t, e) {
    let r = 65536
    for (let i = 0, n = e.length; i < n; i += 2) {
      if (((r += e[i]), r > t)) return !1
      if (((r += e[i + 1]), r >= t)) return !0
    }
    return !1
  }
  function ni(t) {
    return t < 65
      ? t === 36
      : t <= 90
      ? !0
      : t < 97
      ? t === 95
      : t <= 122
      ? !0
      : t <= 65535
      ? t >= 170 && Yz.test(String.fromCharCode(t))
      : kp(t, _0)
  }
  function $n(t) {
    return t < 48
      ? t === 36
      : t < 58
      ? !0
      : t < 65
      ? !1
      : t <= 90
      ? !0
      : t < 97
      ? t === 95
      : t <= 122
      ? !0
      : t <= 65535
      ? t >= 170 && Hz.test(String.fromCharCode(t))
      : kp(t, _0) || kp(t, qz)
  }
  const Np = {
      keyword: [
        'break',
        'case',
        'catch',
        'continue',
        'debugger',
        'default',
        'do',
        'else',
        'finally',
        'for',
        'function',
        'if',
        'return',
        'switch',
        'throw',
        'try',
        'var',
        'const',
        'while',
        'with',
        'new',
        'this',
        'super',
        'class',
        'extends',
        'export',
        'import',
        'null',
        'true',
        'false',
        'in',
        'instanceof',
        'typeof',
        'void',
        'delete',
      ],
      strict: ['implements', 'interface', 'let', 'package', 'private', 'protected', 'public', 'static', 'yield'],
      strictBind: ['eval', 'arguments'],
    },
    Xz = new Set(Np.keyword),
    Gz = new Set(Np.strict),
    Jz = new Set(Np.strictBind)
  function V0(t, e) {
    return (e && t === 'await') || t === 'enum'
  }
  function U0(t, e) {
    return V0(t, e) || Gz.has(t)
  }
  function z0(t) {
    return Jz.has(t)
  }
  function K0(t, e) {
    return U0(t, e) || z0(t)
  }
  function Zz(t) {
    return Xz.has(t)
  }
  function Qz(t, e, r) {
    return t === 64 && e === 64 && ni(r)
  }
  const eK = new Set([
    'break',
    'case',
    'catch',
    'continue',
    'debugger',
    'default',
    'do',
    'else',
    'finally',
    'for',
    'function',
    'if',
    'return',
    'switch',
    'throw',
    'try',
    'var',
    'const',
    'while',
    'with',
    'new',
    'this',
    'super',
    'class',
    'extends',
    'export',
    'import',
    'null',
    'true',
    'false',
    'in',
    'instanceof',
    'typeof',
    'void',
    'delete',
    'implements',
    'interface',
    'let',
    'package',
    'private',
    'protected',
    'public',
    'static',
    'yield',
    'eval',
    'arguments',
    'enum',
    'await',
  ])
  function tK(t) {
    return eK.has(t)
  }
  const Rn = 0,
    Vs = 1,
    si = 2,
    Op = 4,
    W0 = 8,
    Ko = 16,
    Y0 = 32,
    un = 64,
    Dp = 128,
    Wo = 256,
    Yo = Vs | si | Wo,
    ai = 1,
    jn = 2,
    H0 = 4,
    Pi = 8,
    Ho = 16,
    q0 = 64,
    qo = 128,
    Bp = 256,
    Lp = 512,
    Mp = 1024,
    Fp = 2048,
    X0 = ai | jn | Pi | qo,
    oi = ai | 0 | Pi | 0,
    Xo = ai | 0 | H0 | 0,
    G0 = ai | 0 | Ho | 0,
    rK = 0 | jn | 0 | qo,
    iK = 0 | jn | 0 | 0,
    J0 = ai | jn | Pi | Bp,
    Z0 = 0 | Mp,
    cn = 0 | q0,
    nK = ai | 0 | 0 | q0,
    sK = J0 | Lp,
    aK = 0 | Mp,
    oK = Fp,
    Go = 4,
    $p = 2,
    Rp = 1,
    jp = $p | Rp,
    lK = $p | Go,
    uK = Rp | Go,
    cK = $p,
    pK = Rp,
    _p = 0
  class fK {
    constructor() {
      ;(this.sawUnambiguousESM = !1), (this.ambiguousScriptDifferentAst = !1)
    }
    hasPlugin(e) {
      if (typeof e == 'string') return this.plugins.has(e)
      {
        const [r, i] = e
        if (!this.hasPlugin(r)) return !1
        const n = this.plugins.get(r)
        for (const s of Object.keys(i)) if ((n == null ? void 0 : n[s]) !== i[s]) return !1
        return !0
      }
    }
    getPluginOption(e, r) {
      var i
      return (i = this.plugins.get(e)) == null ? void 0 : i[r]
    }
  }
  function Q0(t, e) {
    t.trailingComments === void 0 ? (t.trailingComments = e) : t.trailingComments.unshift(...e)
  }
  function hK(t, e) {
    t.leadingComments === void 0 ? (t.leadingComments = e) : t.leadingComments.unshift(...e)
  }
  function Us(t, e) {
    t.innerComments === void 0 ? (t.innerComments = e) : t.innerComments.unshift(...e)
  }
  function zs(t, e, r) {
    let i = null,
      n = e.length
    for (; i === null && n > 0; ) i = e[--n]
    i === null || i.start > r.start ? Us(t, r.comments) : Q0(i, r.comments)
  }
  class dK extends fK {
    addComment(e) {
      this.filename && (e.loc.filename = this.filename), this.state.comments.push(e)
    }
    processComment(e) {
      const { commentStack: r } = this.state,
        i = r.length
      if (i === 0) return
      let n = i - 1
      const s = r[n]
      s.start === e.end && ((s.leadingNode = e), n--)
      const { start: a } = e
      for (; n >= 0; n--) {
        const o = r[n],
          u = o.end
        if (u > a) (o.containingNode = e), this.finalizeComment(o), r.splice(n, 1)
        else {
          u === a && (o.trailingNode = e)
          break
        }
      }
    }
    finalizeComment(e) {
      const { comments: r } = e
      if (e.leadingNode !== null || e.trailingNode !== null)
        e.leadingNode !== null && Q0(e.leadingNode, r), e.trailingNode !== null && hK(e.trailingNode, r)
      else {
        const { containingNode: i, start: n } = e
        if (this.input.charCodeAt(n - 1) === 44)
          switch (i.type) {
            case 'ObjectExpression':
            case 'ObjectPattern':
            case 'RecordExpression':
              zs(i, i.properties, e)
              break
            case 'CallExpression':
            case 'OptionalCallExpression':
              zs(i, i.arguments, e)
              break
            case 'FunctionDeclaration':
            case 'FunctionExpression':
            case 'ArrowFunctionExpression':
            case 'ObjectMethod':
            case 'ClassMethod':
            case 'ClassPrivateMethod':
              zs(i, i.params, e)
              break
            case 'ArrayExpression':
            case 'ArrayPattern':
            case 'TupleExpression':
              zs(i, i.elements, e)
              break
            case 'ExportNamedDeclaration':
            case 'ImportDeclaration':
              zs(i, i.specifiers, e)
              break
            default:
              Us(i, r)
          }
        else Us(i, r)
      }
    }
    finalizeRemainingComments() {
      const { commentStack: e } = this.state
      for (let r = e.length - 1; r >= 0; r--) this.finalizeComment(e[r])
      this.state.commentStack = []
    }
    resetPreviousNodeTrailingComments(e) {
      const { commentStack: r } = this.state,
        { length: i } = r
      if (i === 0) return
      const n = r[i - 1]
      n.leadingNode === e && (n.leadingNode = null)
    }
    takeSurroundingComments(e, r, i) {
      const { commentStack: n } = this.state,
        s = n.length
      if (s === 0) return
      let a = s - 1
      for (; a >= 0; a--) {
        const o = n[a],
          u = o.end
        if (o.start === i) o.leadingNode = e
        else if (u === r) o.trailingNode = e
        else if (u < r) break
      }
    }
  }
  const Vp = /\r\n?|[\n\u2028\u2029]/,
    Jo = new RegExp(Vp.source, 'g')
  function pn(t) {
    switch (t) {
      case 10:
      case 13:
      case 8232:
      case 8233:
        return !0
      default:
        return !1
    }
  }
  const Up = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g,
    mK = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/y,
    eg = new RegExp('(?=(' + mK.source + '))\\1' + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, 'y')
  function yK(t) {
    switch (t) {
      case 9:
      case 11:
      case 12:
      case 32:
      case 160:
      case 5760:
      case 8192:
      case 8193:
      case 8194:
      case 8195:
      case 8196:
      case 8197:
      case 8198:
      case 8199:
      case 8200:
      case 8201:
      case 8202:
      case 8239:
      case 8287:
      case 12288:
      case 65279:
        return !0
      default:
        return !1
    }
  }
  class zp {
    constructor() {
      ;(this.strict = void 0),
        (this.curLine = void 0),
        (this.lineStart = void 0),
        (this.startLoc = void 0),
        (this.endLoc = void 0),
        (this.errors = []),
        (this.potentialArrowAt = -1),
        (this.noArrowAt = []),
        (this.noArrowParamsConversionAt = []),
        (this.maybeInArrowParameters = !1),
        (this.inType = !1),
        (this.noAnonFunctionType = !1),
        (this.hasFlowComment = !1),
        (this.isAmbientContext = !1),
        (this.inAbstractClass = !1),
        (this.inDisallowConditionalTypesContext = !1),
        (this.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null }),
        (this.soloAwait = !1),
        (this.inFSharpPipelineDirectBody = !1),
        (this.labels = []),
        (this.decoratorStack = [[]]),
        (this.comments = []),
        (this.commentStack = []),
        (this.pos = 0),
        (this.type = 135),
        (this.value = null),
        (this.start = 0),
        (this.end = 0),
        (this.lastTokEndLoc = null),
        (this.lastTokStartLoc = null),
        (this.lastTokStart = 0),
        (this.context = [Tt.brace]),
        (this.canStartJSXElement = !0),
        (this.containsEsc = !1),
        (this.strictErrors = new Map()),
        (this.tokensLength = 0)
    }
    init({ strictMode: e, sourceType: r, startLine: i, startColumn: n }) {
      ;(this.strict = e === !1 ? !1 : e === !0 ? !0 : r === 'module'),
        (this.curLine = i),
        (this.lineStart = -n),
        (this.startLoc = this.endLoc = new ln(i, n, 0))
    }
    curPosition() {
      return new ln(this.curLine, this.pos - this.lineStart, this.pos)
    }
    clone(e) {
      const r = new zp(),
        i = Object.keys(this)
      for (let n = 0, s = i.length; n < s; n++) {
        const a = i[n]
        let o = this[a]
        !e && Array.isArray(o) && (o = o.slice()), (r[a] = o)
      }
      return r
    }
  }
  const gK = ['at'],
    TK = ['at']
  var bK = function (e) {
    return e >= 48 && e <= 57
  }
  const SK = new Set([103, 109, 115, 105, 121, 117, 100, 118]),
    tg = { decBinOct: new Set([46, 66, 69, 79, 95, 98, 101, 111]), hex: new Set([46, 88, 95, 120]) },
    Zo = {
      bin: (t) => t === 48 || t === 49,
      oct: (t) => t >= 48 && t <= 55,
      dec: (t) => t >= 48 && t <= 57,
      hex: (t) => (t >= 48 && t <= 57) || (t >= 65 && t <= 70) || (t >= 97 && t <= 102),
    }
  class wi {
    constructor(e) {
      ;(this.type = e.type),
        (this.value = e.value),
        (this.start = e.start),
        (this.end = e.end),
        (this.loc = new _o(e.startLoc, e.endLoc))
    }
  }
  class vK extends dK {
    constructor(e, r) {
      super(),
        (this.isLookahead = void 0),
        (this.tokens = []),
        (this.state = new zp()),
        this.state.init(e),
        (this.input = r),
        (this.length = r.length),
        (this.isLookahead = !1)
    }
    pushToken(e) {
      ;(this.tokens.length = this.state.tokensLength), this.tokens.push(e), ++this.state.tokensLength
    }
    next() {
      this.checkKeywordEscapes(),
        this.options.tokens && this.pushToken(new wi(this.state)),
        (this.state.lastTokStart = this.state.start),
        (this.state.lastTokEndLoc = this.state.endLoc),
        (this.state.lastTokStartLoc = this.state.startLoc),
        this.nextToken()
    }
    eat(e) {
      return this.match(e) ? (this.next(), !0) : !1
    }
    match(e) {
      return this.state.type === e
    }
    createLookaheadState(e) {
      return {
        pos: e.pos,
        value: null,
        type: e.type,
        start: e.start,
        end: e.end,
        context: [this.curContext()],
        inType: e.inType,
        startLoc: e.startLoc,
        lastTokEndLoc: e.lastTokEndLoc,
        curLine: e.curLine,
        lineStart: e.lineStart,
        curPosition: e.curPosition,
      }
    }
    lookahead() {
      const e = this.state
      ;(this.state = this.createLookaheadState(e)), (this.isLookahead = !0), this.nextToken(), (this.isLookahead = !1)
      const r = this.state
      return (this.state = e), r
    }
    nextTokenStart() {
      return this.nextTokenStartSince(this.state.pos)
    }
    nextTokenStartSince(e) {
      return (Up.lastIndex = e), Up.test(this.input) ? Up.lastIndex : e
    }
    lookaheadCharCode() {
      return this.input.charCodeAt(this.nextTokenStart())
    }
    codePointAtPos(e) {
      let r = this.input.charCodeAt(e)
      if ((r & 64512) === 55296 && ++e < this.input.length) {
        const i = this.input.charCodeAt(e)
        ;(i & 64512) === 56320 && (r = 65536 + ((r & 1023) << 10) + (i & 1023))
      }
      return r
    }
    setStrict(e) {
      ;(this.state.strict = e),
        e && (this.state.strictErrors.forEach(([r, i]) => this.raise(r, { at: i })), this.state.strictErrors.clear())
    }
    curContext() {
      return this.state.context[this.state.context.length - 1]
    }
    nextToken() {
      if (
        (this.skipSpace(),
        (this.state.start = this.state.pos),
        this.isLookahead || (this.state.startLoc = this.state.curPosition()),
        this.state.pos >= this.length)
      ) {
        this.finishToken(135)
        return
      }
      this.getTokenFromCode(this.codePointAtPos(this.state.pos))
    }
    skipBlockComment() {
      let e
      this.isLookahead || (e = this.state.curPosition())
      const r = this.state.pos,
        i = this.input.indexOf('*/', r + 2)
      if (i === -1) throw this.raise(re.UnterminatedComment, { at: this.state.curPosition() })
      for (this.state.pos = i + 2, Jo.lastIndex = r + 2; Jo.test(this.input) && Jo.lastIndex <= i; )
        ++this.state.curLine, (this.state.lineStart = Jo.lastIndex)
      if (this.isLookahead) return
      const n = {
        type: 'CommentBlock',
        value: this.input.slice(r + 2, i),
        start: r,
        end: i + 2,
        loc: new _o(e, this.state.curPosition()),
      }
      return this.options.tokens && this.pushToken(n), n
    }
    skipLineComment(e) {
      const r = this.state.pos
      let i
      this.isLookahead || (i = this.state.curPosition())
      let n = this.input.charCodeAt((this.state.pos += e))
      if (this.state.pos < this.length)
        for (; !pn(n) && ++this.state.pos < this.length; ) n = this.input.charCodeAt(this.state.pos)
      if (this.isLookahead) return
      const s = this.state.pos,
        a = this.input.slice(r + e, s),
        o = { type: 'CommentLine', value: a, start: r, end: s, loc: new _o(i, this.state.curPosition()) }
      return this.options.tokens && this.pushToken(o), o
    }
    skipSpace() {
      const e = this.state.pos,
        r = []
      e: for (; this.state.pos < this.length; ) {
        const i = this.input.charCodeAt(this.state.pos)
        switch (i) {
          case 32:
          case 160:
          case 9:
            ++this.state.pos
            break
          case 13:
            this.input.charCodeAt(this.state.pos + 1) === 10 && ++this.state.pos
          case 10:
          case 8232:
          case 8233:
            ++this.state.pos, ++this.state.curLine, (this.state.lineStart = this.state.pos)
            break
          case 47:
            switch (this.input.charCodeAt(this.state.pos + 1)) {
              case 42: {
                const n = this.skipBlockComment()
                n !== void 0 && (this.addComment(n), this.options.attachComment && r.push(n))
                break
              }
              case 47: {
                const n = this.skipLineComment(2)
                n !== void 0 && (this.addComment(n), this.options.attachComment && r.push(n))
                break
              }
              default:
                break e
            }
            break
          default:
            if (yK(i)) ++this.state.pos
            else if (i === 45 && !this.inModule) {
              const n = this.state.pos
              if (
                this.input.charCodeAt(n + 1) === 45 &&
                this.input.charCodeAt(n + 2) === 62 &&
                (e === 0 || this.state.lineStart > e)
              ) {
                const s = this.skipLineComment(3)
                s !== void 0 && (this.addComment(s), this.options.attachComment && r.push(s))
              } else break e
            } else if (i === 60 && !this.inModule) {
              const n = this.state.pos
              if (
                this.input.charCodeAt(n + 1) === 33 &&
                this.input.charCodeAt(n + 2) === 45 &&
                this.input.charCodeAt(n + 3) === 45
              ) {
                const s = this.skipLineComment(4)
                s !== void 0 && (this.addComment(s), this.options.attachComment && r.push(s))
              } else break e
            } else break e
        }
      }
      if (r.length > 0) {
        const i = this.state.pos,
          n = { start: e, end: i, comments: r, leadingNode: null, trailingNode: null, containingNode: null }
        this.state.commentStack.push(n)
      }
    }
    finishToken(e, r) {
      ;(this.state.end = this.state.pos), (this.state.endLoc = this.state.curPosition())
      const i = this.state.type
      ;(this.state.type = e), (this.state.value = r), this.isLookahead || this.updateContext(i)
    }
    replaceToken(e) {
      ;(this.state.type = e), this.updateContext()
    }
    readToken_numberSign() {
      if (this.state.pos === 0 && this.readToken_interpreter()) return
      const e = this.state.pos + 1,
        r = this.codePointAtPos(e)
      if (r >= 48 && r <= 57) throw this.raise(re.UnexpectedDigitAfterHash, { at: this.state.curPosition() })
      if (r === 123 || (r === 91 && this.hasPlugin('recordAndTuple'))) {
        if ((this.expectPlugin('recordAndTuple'), this.getPluginOption('recordAndTuple', 'syntaxType') !== 'hash'))
          throw this.raise(
            r === 123
              ? re.RecordExpressionHashIncorrectStartSyntaxType
              : re.TupleExpressionHashIncorrectStartSyntaxType,
            { at: this.state.curPosition() }
          )
        ;(this.state.pos += 2), r === 123 ? this.finishToken(7) : this.finishToken(1)
      } else ni(r) ? (++this.state.pos, this.finishToken(134, this.readWord1(r))) : r === 92 ? (++this.state.pos, this.finishToken(134, this.readWord1())) : this.finishOp(27, 1)
    }
    readToken_dot() {
      const e = this.input.charCodeAt(this.state.pos + 1)
      if (e >= 48 && e <= 57) {
        this.readNumber(!0)
        return
      }
      e === 46 && this.input.charCodeAt(this.state.pos + 2) === 46
        ? ((this.state.pos += 3), this.finishToken(21))
        : (++this.state.pos, this.finishToken(16))
    }
    readToken_slash() {
      this.input.charCodeAt(this.state.pos + 1) === 61 ? this.finishOp(31, 2) : this.finishOp(56, 1)
    }
    readToken_interpreter() {
      if (this.state.pos !== 0 || this.length < 2) return !1
      let e = this.input.charCodeAt(this.state.pos + 1)
      if (e !== 33) return !1
      const r = this.state.pos
      for (this.state.pos += 1; !pn(e) && ++this.state.pos < this.length; ) e = this.input.charCodeAt(this.state.pos)
      const i = this.input.slice(r + 2, this.state.pos)
      return this.finishToken(28, i), !0
    }
    readToken_mult_modulo(e) {
      let r = e === 42 ? 55 : 54,
        i = 1,
        n = this.input.charCodeAt(this.state.pos + 1)
      e === 42 && n === 42 && (i++, (n = this.input.charCodeAt(this.state.pos + 2)), (r = 57)),
        n === 61 && !this.state.inType && (i++, (r = e === 37 ? 33 : 30)),
        this.finishOp(r, i)
    }
    readToken_pipe_amp(e) {
      const r = this.input.charCodeAt(this.state.pos + 1)
      if (r === e) {
        this.input.charCodeAt(this.state.pos + 2) === 61 ? this.finishOp(30, 3) : this.finishOp(e === 124 ? 41 : 42, 2)
        return
      }
      if (e === 124) {
        if (r === 62) {
          this.finishOp(39, 2)
          return
        }
        if (this.hasPlugin('recordAndTuple') && r === 125) {
          if (this.getPluginOption('recordAndTuple', 'syntaxType') !== 'bar')
            throw this.raise(re.RecordExpressionBarIncorrectEndSyntaxType, { at: this.state.curPosition() })
          ;(this.state.pos += 2), this.finishToken(9)
          return
        }
        if (this.hasPlugin('recordAndTuple') && r === 93) {
          if (this.getPluginOption('recordAndTuple', 'syntaxType') !== 'bar')
            throw this.raise(re.TupleExpressionBarIncorrectEndSyntaxType, { at: this.state.curPosition() })
          ;(this.state.pos += 2), this.finishToken(4)
          return
        }
      }
      if (r === 61) {
        this.finishOp(30, 2)
        return
      }
      this.finishOp(e === 124 ? 43 : 45, 1)
    }
    readToken_caret() {
      const e = this.input.charCodeAt(this.state.pos + 1)
      if (e === 61 && !this.state.inType) this.finishOp(32, 2)
      else if (e === 94 && this.hasPlugin(['pipelineOperator', { proposal: 'hack', topicToken: '^^' }])) {
        if ((this.finishOp(37, 2), this.input.codePointAt(this.state.pos) === 94)) throw this.unexpected()
      } else this.finishOp(44, 1)
    }
    readToken_atSign() {
      this.input.charCodeAt(this.state.pos + 1) === 64 &&
      this.hasPlugin(['pipelineOperator', { proposal: 'hack', topicToken: '@@' }])
        ? this.finishOp(38, 2)
        : this.finishOp(26, 1)
    }
    readToken_plus_min(e) {
      const r = this.input.charCodeAt(this.state.pos + 1)
      if (r === e) {
        this.finishOp(34, 2)
        return
      }
      r === 61 ? this.finishOp(30, 2) : this.finishOp(53, 1)
    }
    readToken_lt() {
      const { pos: e } = this.state,
        r = this.input.charCodeAt(e + 1)
      if (r === 60) {
        if (this.input.charCodeAt(e + 2) === 61) {
          this.finishOp(30, 3)
          return
        }
        this.finishOp(51, 2)
        return
      }
      if (r === 61) {
        this.finishOp(49, 2)
        return
      }
      this.finishOp(47, 1)
    }
    readToken_gt() {
      const { pos: e } = this.state,
        r = this.input.charCodeAt(e + 1)
      if (r === 62) {
        const i = this.input.charCodeAt(e + 2) === 62 ? 3 : 2
        if (this.input.charCodeAt(e + i) === 61) {
          this.finishOp(30, i + 1)
          return
        }
        this.finishOp(52, i)
        return
      }
      if (r === 61) {
        this.finishOp(49, 2)
        return
      }
      this.finishOp(48, 1)
    }
    readToken_eq_excl(e) {
      const r = this.input.charCodeAt(this.state.pos + 1)
      if (r === 61) {
        this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2)
        return
      }
      if (e === 61 && r === 62) {
        ;(this.state.pos += 2), this.finishToken(19)
        return
      }
      this.finishOp(e === 61 ? 29 : 35, 1)
    }
    readToken_question() {
      const e = this.input.charCodeAt(this.state.pos + 1),
        r = this.input.charCodeAt(this.state.pos + 2)
      e === 63
        ? r === 61
          ? this.finishOp(30, 3)
          : this.finishOp(40, 2)
        : e === 46 && !(r >= 48 && r <= 57)
        ? ((this.state.pos += 2), this.finishToken(18))
        : (++this.state.pos, this.finishToken(17))
    }
    getTokenFromCode(e) {
      switch (e) {
        case 46:
          this.readToken_dot()
          return
        case 40:
          ++this.state.pos, this.finishToken(10)
          return
        case 41:
          ++this.state.pos, this.finishToken(11)
          return
        case 59:
          ++this.state.pos, this.finishToken(13)
          return
        case 44:
          ++this.state.pos, this.finishToken(12)
          return
        case 91:
          if (this.hasPlugin('recordAndTuple') && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption('recordAndTuple', 'syntaxType') !== 'bar')
              throw this.raise(re.TupleExpressionBarIncorrectStartSyntaxType, { at: this.state.curPosition() })
            ;(this.state.pos += 2), this.finishToken(2)
          } else ++this.state.pos, this.finishToken(0)
          return
        case 93:
          ++this.state.pos, this.finishToken(3)
          return
        case 123:
          if (this.hasPlugin('recordAndTuple') && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption('recordAndTuple', 'syntaxType') !== 'bar')
              throw this.raise(re.RecordExpressionBarIncorrectStartSyntaxType, { at: this.state.curPosition() })
            ;(this.state.pos += 2), this.finishToken(6)
          } else ++this.state.pos, this.finishToken(5)
          return
        case 125:
          ++this.state.pos, this.finishToken(8)
          return
        case 58:
          this.hasPlugin('functionBind') && this.input.charCodeAt(this.state.pos + 1) === 58
            ? this.finishOp(15, 2)
            : (++this.state.pos, this.finishToken(14))
          return
        case 63:
          this.readToken_question()
          return
        case 96:
          this.readTemplateToken()
          return
        case 48: {
          const r = this.input.charCodeAt(this.state.pos + 1)
          if (r === 120 || r === 88) {
            this.readRadixNumber(16)
            return
          }
          if (r === 111 || r === 79) {
            this.readRadixNumber(8)
            return
          }
          if (r === 98 || r === 66) {
            this.readRadixNumber(2)
            return
          }
        }
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          this.readNumber(!1)
          return
        case 34:
        case 39:
          this.readString(e)
          return
        case 47:
          this.readToken_slash()
          return
        case 37:
        case 42:
          this.readToken_mult_modulo(e)
          return
        case 124:
        case 38:
          this.readToken_pipe_amp(e)
          return
        case 94:
          this.readToken_caret()
          return
        case 43:
        case 45:
          this.readToken_plus_min(e)
          return
        case 60:
          this.readToken_lt()
          return
        case 62:
          this.readToken_gt()
          return
        case 61:
        case 33:
          this.readToken_eq_excl(e)
          return
        case 126:
          this.finishOp(36, 1)
          return
        case 64:
          this.readToken_atSign()
          return
        case 35:
          this.readToken_numberSign()
          return
        case 92:
          this.readWord()
          return
        default:
          if (ni(e)) {
            this.readWord(e)
            return
          }
      }
      throw this.raise(re.InvalidOrUnexpectedToken, {
        at: this.state.curPosition(),
        unexpected: String.fromCodePoint(e),
      })
    }
    finishOp(e, r) {
      const i = this.input.slice(this.state.pos, this.state.pos + r)
      ;(this.state.pos += r), this.finishToken(e, i)
    }
    readRegexp() {
      const e = this.state.startLoc,
        r = this.state.start + 1
      let i,
        n,
        { pos: s } = this.state
      for (; ; ++s) {
        if (s >= this.length) throw this.raise(re.UnterminatedRegExp, { at: Wt(e, 1) })
        const c = this.input.charCodeAt(s)
        if (pn(c)) throw this.raise(re.UnterminatedRegExp, { at: Wt(e, 1) })
        if (i) i = !1
        else {
          if (c === 91) n = !0
          else if (c === 93 && n) n = !1
          else if (c === 47 && !n) break
          i = c === 92
        }
      }
      const a = this.input.slice(r, s)
      ++s
      let o = ''
      const u = () => Wt(e, s + 2 - r)
      for (; s < this.length; ) {
        const c = this.codePointAtPos(s),
          p = String.fromCharCode(c)
        if (SK.has(c))
          c === 118
            ? (this.expectPlugin('regexpUnicodeSets', u()),
              o.includes('u') && this.raise(re.IncompatibleRegExpUVFlags, { at: u() }))
            : c === 117 && o.includes('v') && this.raise(re.IncompatibleRegExpUVFlags, { at: u() }),
            o.includes(p) && this.raise(re.DuplicateRegExpFlags, { at: u() })
        else if ($n(c) || c === 92) this.raise(re.MalformedRegExpFlags, { at: u() })
        else break
        ++s, (o += p)
      }
      ;(this.state.pos = s), this.finishToken(133, { pattern: a, flags: o })
    }
    readInt(e, r, i, n = !0) {
      const s = this.state.pos,
        a = e === 16 ? tg.hex : tg.decBinOct,
        o = e === 16 ? Zo.hex : e === 10 ? Zo.dec : e === 8 ? Zo.oct : Zo.bin
      let u = !1,
        c = 0
      for (let p = 0, h = r == null ? 1 / 0 : r; p < h; ++p) {
        const f = this.input.charCodeAt(this.state.pos)
        let d
        if (f === 95 && n !== 'bail') {
          const T = this.input.charCodeAt(this.state.pos - 1),
            y = this.input.charCodeAt(this.state.pos + 1)
          n
            ? (Number.isNaN(y) || !o(y) || a.has(T) || a.has(y)) &&
              this.raise(re.UnexpectedNumericSeparator, { at: this.state.curPosition() })
            : this.raise(re.NumericSeparatorInEscapeSequence, { at: this.state.curPosition() }),
            ++this.state.pos
          continue
        }
        if ((f >= 97 ? (d = f - 97 + 10) : f >= 65 ? (d = f - 65 + 10) : bK(f) ? (d = f - 48) : (d = 1 / 0), d >= e))
          if (this.options.errorRecovery && d <= 9)
            (d = 0), this.raise(re.InvalidDigit, { at: this.state.curPosition(), radix: e })
          else if (i) (d = 0), (u = !0)
          else break
        ++this.state.pos, (c = c * e + d)
      }
      return this.state.pos === s || (r != null && this.state.pos - s !== r) || u ? null : c
    }
    readRadixNumber(e) {
      const r = this.state.curPosition()
      let i = !1
      this.state.pos += 2
      const n = this.readInt(e)
      n == null && this.raise(re.InvalidDigit, { at: Wt(r, 2), radix: e })
      const s = this.input.charCodeAt(this.state.pos)
      if (s === 110) ++this.state.pos, (i = !0)
      else if (s === 109) throw this.raise(re.InvalidDecimal, { at: r })
      if (ni(this.codePointAtPos(this.state.pos)))
        throw this.raise(re.NumberIdentifier, { at: this.state.curPosition() })
      if (i) {
        const a = this.input.slice(r.index, this.state.pos).replace(/[_n]/g, '')
        this.finishToken(131, a)
        return
      }
      this.finishToken(130, n)
    }
    readNumber(e) {
      const r = this.state.pos,
        i = this.state.curPosition()
      let n = !1,
        s = !1,
        a = !1,
        o = !1,
        u = !1
      !e && this.readInt(10) === null && this.raise(re.InvalidNumber, { at: this.state.curPosition() })
      const c = this.state.pos - r >= 2 && this.input.charCodeAt(r) === 48
      if (c) {
        const d = this.input.slice(r, this.state.pos)
        if ((this.recordStrictModeErrors(re.StrictOctalLiteral, { at: i }), !this.state.strict)) {
          const T = d.indexOf('_')
          T > 0 && this.raise(re.ZeroDigitNumericSeparator, { at: Wt(i, T) })
        }
        u = c && !/[89]/.test(d)
      }
      let p = this.input.charCodeAt(this.state.pos)
      if (
        (p === 46 && !u && (++this.state.pos, this.readInt(10), (n = !0), (p = this.input.charCodeAt(this.state.pos))),
        (p === 69 || p === 101) &&
          !u &&
          ((p = this.input.charCodeAt(++this.state.pos)),
          (p === 43 || p === 45) && ++this.state.pos,
          this.readInt(10) === null && this.raise(re.InvalidOrMissingExponent, { at: i }),
          (n = !0),
          (o = !0),
          (p = this.input.charCodeAt(this.state.pos))),
        p === 110 && ((n || c) && this.raise(re.InvalidBigIntLiteral, { at: i }), ++this.state.pos, (s = !0)),
        p === 109 &&
          (this.expectPlugin('decimal', this.state.curPosition()),
          (o || c) && this.raise(re.InvalidDecimal, { at: i }),
          ++this.state.pos,
          (a = !0)),
        ni(this.codePointAtPos(this.state.pos)))
      )
        throw this.raise(re.NumberIdentifier, { at: this.state.curPosition() })
      const h = this.input.slice(r, this.state.pos).replace(/[_mn]/g, '')
      if (s) {
        this.finishToken(131, h)
        return
      }
      if (a) {
        this.finishToken(132, h)
        return
      }
      const f = u ? parseInt(h, 8) : parseFloat(h)
      this.finishToken(130, f)
    }
    readCodePoint(e) {
      const r = this.input.charCodeAt(this.state.pos)
      let i
      if (r === 123) {
        if (
          (++this.state.pos,
          (i = this.readHexChar(this.input.indexOf('}', this.state.pos) - this.state.pos, !0, e)),
          ++this.state.pos,
          i !== null && i > 1114111)
        )
          if (e) this.raise(re.InvalidCodePoint, { at: this.state.curPosition() })
          else return null
      } else i = this.readHexChar(4, !1, e)
      return i
    }
    readString(e) {
      let r = '',
        i = ++this.state.pos
      for (;;) {
        if (this.state.pos >= this.length) throw this.raise(re.UnterminatedString, { at: this.state.startLoc })
        const n = this.input.charCodeAt(this.state.pos)
        if (n === e) break
        if (n === 92) (r += this.input.slice(i, this.state.pos)), (r += this.readEscapedChar(!1)), (i = this.state.pos)
        else if (n === 8232 || n === 8233)
          ++this.state.pos, ++this.state.curLine, (this.state.lineStart = this.state.pos)
        else {
          if (pn(n)) throw this.raise(re.UnterminatedString, { at: this.state.startLoc })
          ++this.state.pos
        }
      }
      ;(r += this.input.slice(i, this.state.pos++)), this.finishToken(129, r)
    }
    readTemplateContinuation() {
      this.match(8) || this.unexpected(null, 8), this.state.pos--, this.readTemplateToken()
    }
    readTemplateToken() {
      let e = '',
        r = this.state.pos,
        i = !1
      for (++this.state.pos; ; ) {
        if (this.state.pos >= this.length) throw this.raise(re.UnterminatedTemplate, { at: Wt(this.state.startLoc, 1) })
        const n = this.input.charCodeAt(this.state.pos)
        if (n === 96) {
          ++this.state.pos, (e += this.input.slice(r, this.state.pos)), this.finishToken(24, i ? null : e)
          return
        }
        if (n === 36 && this.input.charCodeAt(this.state.pos + 1) === 123) {
          ;(this.state.pos += 2), (e += this.input.slice(r, this.state.pos)), this.finishToken(25, i ? null : e)
          return
        }
        if (n === 92) {
          e += this.input.slice(r, this.state.pos)
          const s = this.readEscapedChar(!0)
          s === null ? (i = !0) : (e += s), (r = this.state.pos)
        } else if (pn(n)) {
          switch (((e += this.input.slice(r, this.state.pos)), ++this.state.pos, n)) {
            case 13:
              this.input.charCodeAt(this.state.pos) === 10 && ++this.state.pos
            case 10:
              e += `
`
              break
            default:
              e += String.fromCharCode(n)
              break
          }
          ++this.state.curLine, (this.state.lineStart = this.state.pos), (r = this.state.pos)
        } else ++this.state.pos
      }
    }
    recordStrictModeErrors(e, { at: r }) {
      const i = r.index
      this.state.strict && !this.state.strictErrors.has(i)
        ? this.raise(e, { at: r })
        : this.state.strictErrors.set(i, [e, r])
    }
    readEscapedChar(e) {
      const r = !e,
        i = this.input.charCodeAt(++this.state.pos)
      switch ((++this.state.pos, i)) {
        case 110:
          return `
`
        case 114:
          return '\r'
        case 120: {
          const n = this.readHexChar(2, !1, r)
          return n === null ? null : String.fromCharCode(n)
        }
        case 117: {
          const n = this.readCodePoint(r)
          return n === null ? null : String.fromCodePoint(n)
        }
        case 116:
          return '	'
        case 98:
          return '\b'
        case 118:
          return '\v'
        case 102:
          return '\f'
        case 13:
          this.input.charCodeAt(this.state.pos) === 10 && ++this.state.pos
        case 10:
          ;(this.state.lineStart = this.state.pos), ++this.state.curLine
        case 8232:
        case 8233:
          return ''
        case 56:
        case 57:
          if (e) return null
          this.recordStrictModeErrors(re.StrictNumericEscape, { at: Wt(this.state.curPosition(), -1) })
        default:
          if (i >= 48 && i <= 55) {
            const n = Wt(this.state.curPosition(), -1)
            let a = this.input.slice(this.state.pos - 1, this.state.pos + 2).match(/^[0-7]+/)[0],
              o = parseInt(a, 8)
            o > 255 && ((a = a.slice(0, -1)), (o = parseInt(a, 8))), (this.state.pos += a.length - 1)
            const u = this.input.charCodeAt(this.state.pos)
            if (a !== '0' || u === 56 || u === 57) {
              if (e) return null
              this.recordStrictModeErrors(re.StrictNumericEscape, { at: n })
            }
            return String.fromCharCode(o)
          }
          return String.fromCharCode(i)
      }
    }
    readHexChar(e, r, i) {
      const n = this.state.curPosition(),
        s = this.readInt(16, e, r, !1)
      return s === null && (i ? this.raise(re.InvalidEscapeSequence, { at: n }) : (this.state.pos = n.index - 1)), s
    }
    readWord1(e) {
      this.state.containsEsc = !1
      let r = ''
      const i = this.state.pos
      let n = this.state.pos
      for (e !== void 0 && (this.state.pos += e <= 65535 ? 1 : 2); this.state.pos < this.length; ) {
        const s = this.codePointAtPos(this.state.pos)
        if ($n(s)) this.state.pos += s <= 65535 ? 1 : 2
        else if (s === 92) {
          ;(this.state.containsEsc = !0), (r += this.input.slice(n, this.state.pos))
          const a = this.state.curPosition(),
            o = this.state.pos === i ? ni : $n
          if (this.input.charCodeAt(++this.state.pos) !== 117) {
            this.raise(re.MissingUnicodeEscape, { at: this.state.curPosition() }), (n = this.state.pos - 1)
            continue
          }
          ++this.state.pos
          const u = this.readCodePoint(!0)
          u !== null && (o(u) || this.raise(re.EscapedCharNotAnIdentifier, { at: a }), (r += String.fromCodePoint(u))),
            (n = this.state.pos)
        } else break
      }
      return r + this.input.slice(n, this.state.pos)
    }
    readWord(e) {
      const r = this.readWord1(e),
        i = vp.get(r)
      i !== void 0 ? this.finishToken(i, Ei(i)) : this.finishToken(128, r)
    }
    checkKeywordEscapes() {
      const { type: e } = this.state
      xp(e) &&
        this.state.containsEsc &&
        this.raise(re.InvalidEscapedReservedWord, { at: this.state.startLoc, reservedWord: Ei(e) })
    }
    raise(e, r) {
      const { at: i } = r,
        n = gp(r, gK),
        s = i instanceof ln ? i : i.loc.start,
        a = e({ loc: s, details: n })
      if (!this.options.errorRecovery) throw a
      return this.isLookahead || this.state.errors.push(a), a
    }
    raiseOverwrite(e, r) {
      const { at: i } = r,
        n = gp(r, TK),
        s = i instanceof ln ? i : i.loc.start,
        a = s.index,
        o = this.state.errors
      for (let u = o.length - 1; u >= 0; u--) {
        const c = o[u]
        if (c.loc.index === a) return (o[u] = e({ loc: s, details: n }))
        if (c.loc.index < a) break
      }
      return this.raise(e, r)
    }
    updateContext(e) {}
    unexpected(e, r) {
      throw this.raise(re.UnexpectedToken, { expected: r ? Ei(r) : null, at: e != null ? e : this.state.startLoc })
    }
    expectPlugin(e, r) {
      if (this.hasPlugin(e)) return !0
      throw this.raise(re.MissingPlugin, { at: r != null ? r : this.state.startLoc, missingPlugin: [e] })
    }
    expectOnePlugin(e) {
      if (!e.some((r) => this.hasPlugin(r)))
        throw this.raise(re.MissingOneOfPlugins, { at: this.state.startLoc, missingPlugin: e })
    }
  }
  class Kp {
    constructor(e) {
      ;(this.var = new Set()), (this.lexical = new Set()), (this.functions = new Set()), (this.flags = e)
    }
  }
  class Wp {
    constructor(e, r) {
      ;(this.parser = void 0),
        (this.scopeStack = []),
        (this.inModule = void 0),
        (this.undefinedExports = new Map()),
        (this.parser = e),
        (this.inModule = r)
    }
    get inFunction() {
      return (this.currentVarScopeFlags() & si) > 0
    }
    get allowSuper() {
      return (this.currentThisScopeFlags() & Ko) > 0
    }
    get allowDirectSuper() {
      return (this.currentThisScopeFlags() & Y0) > 0
    }
    get inClass() {
      return (this.currentThisScopeFlags() & un) > 0
    }
    get inClassAndNotInNonArrowFunction() {
      const e = this.currentThisScopeFlags()
      return (e & un) > 0 && (e & si) === 0
    }
    get inStaticBlock() {
      for (let e = this.scopeStack.length - 1; ; e--) {
        const { flags: r } = this.scopeStack[e]
        if (r & Dp) return !0
        if (r & (Yo | un)) return !1
      }
    }
    get inNonArrowFunction() {
      return (this.currentThisScopeFlags() & si) > 0
    }
    get treatFunctionsAsVar() {
      return this.treatFunctionsAsVarInScope(this.currentScope())
    }
    createScope(e) {
      return new Kp(e)
    }
    enter(e) {
      this.scopeStack.push(this.createScope(e))
    }
    exit() {
      this.scopeStack.pop()
    }
    treatFunctionsAsVarInScope(e) {
      return !!(e.flags & (si | Dp) || (!this.parser.inModule && e.flags & Vs))
    }
    declareName(e, r, i) {
      let n = this.currentScope()
      if (r & Pi || r & Ho)
        this.checkRedeclarationInScope(n, e, r, i),
          r & Ho ? n.functions.add(e) : n.lexical.add(e),
          r & Pi && this.maybeExportDefined(n, e)
      else if (r & H0)
        for (
          let s = this.scopeStack.length - 1;
          s >= 0 &&
          ((n = this.scopeStack[s]),
          this.checkRedeclarationInScope(n, e, r, i),
          n.var.add(e),
          this.maybeExportDefined(n, e),
          !(n.flags & Yo));
          --s
        );
      this.parser.inModule && n.flags & Vs && this.undefinedExports.delete(e)
    }
    maybeExportDefined(e, r) {
      this.parser.inModule && e.flags & Vs && this.undefinedExports.delete(r)
    }
    checkRedeclarationInScope(e, r, i, n) {
      this.isRedeclaredInScope(e, r, i) && this.parser.raise(re.VarRedeclaration, { at: n, identifierName: r })
    }
    isRedeclaredInScope(e, r, i) {
      return i & ai
        ? i & Pi
          ? e.lexical.has(r) || e.functions.has(r) || e.var.has(r)
          : i & Ho
          ? e.lexical.has(r) || (!this.treatFunctionsAsVarInScope(e) && e.var.has(r))
          : (e.lexical.has(r) && !(e.flags & W0 && e.lexical.values().next().value === r)) ||
            (!this.treatFunctionsAsVarInScope(e) && e.functions.has(r))
        : !1
    }
    checkLocalExport(e) {
      const { name: r } = e,
        i = this.scopeStack[0]
      !i.lexical.has(r) && !i.var.has(r) && !i.functions.has(r) && this.undefinedExports.set(r, e.loc.start)
    }
    currentScope() {
      return this.scopeStack[this.scopeStack.length - 1]
    }
    currentVarScopeFlags() {
      for (let e = this.scopeStack.length - 1; ; e--) {
        const { flags: r } = this.scopeStack[e]
        if (r & Yo) return r
      }
    }
    currentThisScopeFlags() {
      for (let e = this.scopeStack.length - 1; ; e--) {
        const { flags: r } = this.scopeStack[e]
        if (r & (Yo | un) && !(r & Op)) return r
      }
    }
  }
  class EK extends Kp {
    constructor(...e) {
      super(...e), (this.declareFunctions = new Set())
    }
  }
  class PK extends Wp {
    createScope(e) {
      return new EK(e)
    }
    declareName(e, r, i) {
      const n = this.currentScope()
      if (r & Fp) {
        this.checkRedeclarationInScope(n, e, r, i), this.maybeExportDefined(n, e), n.declareFunctions.add(e)
        return
      }
      super.declareName(...arguments)
    }
    isRedeclaredInScope(e, r, i) {
      return super.isRedeclaredInScope(...arguments)
        ? !0
        : i & Fp
        ? !e.declareFunctions.has(r) && (e.lexical.has(r) || e.functions.has(r))
        : !1
    }
    checkLocalExport(e) {
      this.scopeStack[0].declareFunctions.has(e.name) || super.checkLocalExport(e)
    }
  }
  class wK {
    constructor() {
      ;(this.privateNames = new Set()), (this.loneAccessors = new Map()), (this.undefinedPrivateNames = new Map())
    }
  }
  class AK {
    constructor(e) {
      ;(this.parser = void 0), (this.stack = []), (this.undefinedPrivateNames = new Map()), (this.parser = e)
    }
    current() {
      return this.stack[this.stack.length - 1]
    }
    enter() {
      this.stack.push(new wK())
    }
    exit() {
      const e = this.stack.pop(),
        r = this.current()
      for (const [i, n] of Array.from(e.undefinedPrivateNames))
        r
          ? r.undefinedPrivateNames.has(i) || r.undefinedPrivateNames.set(i, n)
          : this.parser.raise(re.InvalidPrivateFieldResolution, { at: n, identifierName: i })
    }
    declarePrivateName(e, r, i) {
      const { privateNames: n, loneAccessors: s, undefinedPrivateNames: a } = this.current()
      let o = n.has(e)
      if (r & jp) {
        const u = o && s.get(e)
        if (u) {
          const c = u & Go,
            p = r & Go,
            h = u & jp,
            f = r & jp
          ;(o = h === f || c !== p), o || s.delete(e)
        } else o || s.set(e, r)
      }
      o && this.parser.raise(re.PrivateNameRedeclaration, { at: i, identifierName: e }), n.add(e), a.delete(e)
    }
    usePrivateName(e, r) {
      let i
      for (i of this.stack) if (i.privateNames.has(e)) return
      i
        ? i.undefinedPrivateNames.set(e, r)
        : this.parser.raise(re.InvalidPrivateFieldResolution, { at: r, identifierName: e })
    }
  }
  const CK = 0,
    rg = 1,
    Yp = 2,
    ig = 3
  class Qo {
    constructor(e = CK) {
      ;(this.type = void 0), (this.type = e)
    }
    canBeArrowParameterDeclaration() {
      return this.type === Yp || this.type === rg
    }
    isCertainlyParameterDeclaration() {
      return this.type === ig
    }
  }
  class ng extends Qo {
    constructor(e) {
      super(e), (this.declarationErrors = new Map())
    }
    recordDeclarationError(e, { at: r }) {
      const i = r.index
      this.declarationErrors.set(i, [e, r])
    }
    clearDeclarationError(e) {
      this.declarationErrors.delete(e)
    }
    iterateErrors(e) {
      this.declarationErrors.forEach(e)
    }
  }
  class xK {
    constructor(e) {
      ;(this.parser = void 0), (this.stack = [new Qo()]), (this.parser = e)
    }
    enter(e) {
      this.stack.push(e)
    }
    exit() {
      this.stack.pop()
    }
    recordParameterInitializerError(e, { at: r }) {
      const i = { at: r.loc.start },
        { stack: n } = this
      let s = n.length - 1,
        a = n[s]
      for (; !a.isCertainlyParameterDeclaration(); ) {
        if (a.canBeArrowParameterDeclaration()) a.recordDeclarationError(e, i)
        else return
        a = n[--s]
      }
      this.parser.raise(e, i)
    }
    recordArrowParemeterBindingError(e, { at: r }) {
      const { stack: i } = this,
        n = i[i.length - 1],
        s = { at: r.loc.start }
      if (n.isCertainlyParameterDeclaration()) this.parser.raise(e, s)
      else if (n.canBeArrowParameterDeclaration()) n.recordDeclarationError(e, s)
      else return
    }
    recordAsyncArrowParametersError({ at: e }) {
      const { stack: r } = this
      let i = r.length - 1,
        n = r[i]
      for (; n.canBeArrowParameterDeclaration(); )
        n.type === Yp && n.recordDeclarationError(re.AwaitBindingIdentifier, { at: e }), (n = r[--i])
    }
    validateAsPattern() {
      const { stack: e } = this,
        r = e[e.length - 1]
      !r.canBeArrowParameterDeclaration() ||
        r.iterateErrors(([i, n]) => {
          this.parser.raise(i, { at: n })
          let s = e.length - 2,
            a = e[s]
          for (; a.canBeArrowParameterDeclaration(); ) a.clearDeclarationError(n.index), (a = e[--s])
        })
    }
  }
  function IK() {
    return new Qo(ig)
  }
  function kK() {
    return new ng(rg)
  }
  function NK() {
    return new ng(Yp)
  }
  function sg() {
    return new Qo()
  }
  const _n = 0,
    ag = 1,
    el = 2,
    og = 4,
    Vn = 8
  class OK {
    constructor() {
      this.stacks = []
    }
    enter(e) {
      this.stacks.push(e)
    }
    exit() {
      this.stacks.pop()
    }
    currentFlags() {
      return this.stacks[this.stacks.length - 1]
    }
    get hasAwait() {
      return (this.currentFlags() & el) > 0
    }
    get hasYield() {
      return (this.currentFlags() & ag) > 0
    }
    get hasReturn() {
      return (this.currentFlags() & og) > 0
    }
    get hasIn() {
      return (this.currentFlags() & Vn) > 0
    }
  }
  function tl(t, e) {
    return (t ? el : 0) | (e ? ag : 0)
  }
  class DK extends vK {
    addExtra(e, r, i, n = !0) {
      if (!e) return
      const s = (e.extra = e.extra || {})
      n ? (s[r] = i) : Object.defineProperty(s, r, { enumerable: n, value: i })
    }
    isContextual(e) {
      return this.state.type === e && !this.state.containsEsc
    }
    isUnparsedContextual(e, r) {
      const i = e + r.length
      if (this.input.slice(e, i) === r) {
        const n = this.input.charCodeAt(i)
        return !($n(n) || (n & 64512) === 55296)
      }
      return !1
    }
    isLookaheadContextual(e) {
      const r = this.nextTokenStart()
      return this.isUnparsedContextual(r, e)
    }
    eatContextual(e) {
      return this.isContextual(e) ? (this.next(), !0) : !1
    }
    expectContextual(e, r) {
      if (!this.eatContextual(e))
        throw r != null ? this.raise(r, { at: this.state.startLoc }) : this.unexpected(null, e)
    }
    canInsertSemicolon() {
      return this.match(135) || this.match(8) || this.hasPrecedingLineBreak()
    }
    hasPrecedingLineBreak() {
      return Vp.test(this.input.slice(this.state.lastTokEndLoc.index, this.state.start))
    }
    hasFollowingLineBreak() {
      return (eg.lastIndex = this.state.end), eg.test(this.input)
    }
    isLineTerminator() {
      return this.eat(13) || this.canInsertSemicolon()
    }
    semicolon(e = !0) {
      ;(e ? this.isLineTerminator() : this.eat(13)) || this.raise(re.MissingSemicolon, { at: this.state.lastTokEndLoc })
    }
    expect(e, r) {
      this.eat(e) || this.unexpected(r, e)
    }
    tryParse(e, r = this.state.clone()) {
      const i = { node: null }
      try {
        const n = e((s = null) => {
          throw ((i.node = s), i)
        })
        if (this.state.errors.length > r.errors.length) {
          const s = this.state
          return (
            (this.state = r),
            (this.state.tokensLength = s.tokensLength),
            { node: n, error: s.errors[r.errors.length], thrown: !1, aborted: !1, failState: s }
          )
        }
        return { node: n, error: null, thrown: !1, aborted: !1, failState: null }
      } catch (n) {
        const s = this.state
        if (((this.state = r), n instanceof SyntaxError))
          return { node: null, error: n, thrown: !0, aborted: !1, failState: s }
        if (n === i) return { node: i.node, error: null, thrown: !1, aborted: !0, failState: s }
        throw n
      }
    }
    checkExpressionErrors(e, r) {
      if (!e) return !1
      const { shorthandAssignLoc: i, doubleProtoLoc: n, privateKeyLoc: s, optionalParametersLoc: a } = e,
        o = !!i || !!n || !!a || !!s
      if (!r) return o
      i != null && this.raise(re.InvalidCoverInitializedName, { at: i }),
        n != null && this.raise(re.DuplicateProto, { at: n }),
        s != null && this.raise(re.UnexpectedPrivateField, { at: s }),
        a != null && this.unexpected(a)
    }
    isLiteralPropertyName() {
      return $0(this.state.type)
    }
    isPrivateName(e) {
      return e.type === 'PrivateName'
    }
    getPrivateNameSV(e) {
      return e.id.name
    }
    hasPropertyAsPrivateName(e) {
      return (e.type === 'MemberExpression' || e.type === 'OptionalMemberExpression') && this.isPrivateName(e.property)
    }
    isOptionalChain(e) {
      return e.type === 'OptionalMemberExpression' || e.type === 'OptionalCallExpression'
    }
    isObjectProperty(e) {
      return e.type === 'ObjectProperty'
    }
    isObjectMethod(e) {
      return e.type === 'ObjectMethod'
    }
    initializeScopes(e = this.options.sourceType === 'module') {
      const r = this.state.labels
      this.state.labels = []
      const i = this.exportedIdentifiers
      this.exportedIdentifiers = new Set()
      const n = this.inModule
      this.inModule = e
      const s = this.scope,
        a = this.getScopeHandler()
      this.scope = new a(this, e)
      const o = this.prodParam
      this.prodParam = new OK()
      const u = this.classScope
      this.classScope = new AK(this)
      const c = this.expressionScope
      return (
        (this.expressionScope = new xK(this)),
        () => {
          ;(this.state.labels = r),
            (this.exportedIdentifiers = i),
            (this.inModule = n),
            (this.scope = s),
            (this.prodParam = o),
            (this.classScope = u),
            (this.expressionScope = c)
        }
      )
    }
    enterInitialScopes() {
      let e = _n
      this.inModule && (e |= el), this.scope.enter(Vs), this.prodParam.enter(e)
    }
    checkDestructuringPrivate(e) {
      const { privateKeyLoc: r } = e
      r !== null && this.expectPlugin('destructuringPrivate', r)
    }
  }
  class rl {
    constructor() {
      ;(this.shorthandAssignLoc = null),
        (this.doubleProtoLoc = null),
        (this.privateKeyLoc = null),
        (this.optionalParametersLoc = null)
    }
  }
  class il {
    constructor(e, r, i) {
      ;(this.type = ''),
        (this.start = r),
        (this.end = 0),
        (this.loc = new _o(i)),
        e != null && e.options.ranges && (this.range = [r, 0]),
        e != null && e.filename && (this.loc.filename = e.filename)
    }
  }
  const Hp = il.prototype
  Hp.__clone = function () {
    const t = new il(),
      e = Object.keys(this)
    for (let r = 0, i = e.length; r < i; r++) {
      const n = e[r]
      n !== 'leadingComments' && n !== 'trailingComments' && n !== 'innerComments' && (t[n] = this[n])
    }
    return t
  }
  function BK(t) {
    return li(t)
  }
  function li(t) {
    const { type: e, start: r, end: i, loc: n, range: s, extra: a, name: o } = t,
      u = Object.create(Hp)
    return (
      (u.type = e),
      (u.start = r),
      (u.end = i),
      (u.loc = n),
      (u.range = s),
      (u.extra = a),
      (u.name = o),
      e === 'Placeholder' && (u.expectedNode = t.expectedNode),
      u
    )
  }
  function LK(t) {
    const { type: e, start: r, end: i, loc: n, range: s, extra: a } = t
    if (e === 'Placeholder') return BK(t)
    const o = Object.create(Hp)
    return (
      (o.type = e),
      (o.start = r),
      (o.end = i),
      (o.loc = n),
      (o.range = s),
      t.raw !== void 0 ? (o.raw = t.raw) : (o.extra = a),
      (o.value = t.value),
      o
    )
  }
  class MK extends DK {
    startNode() {
      return new il(this, this.state.start, this.state.startLoc)
    }
    startNodeAt(e, r) {
      return new il(this, e, r)
    }
    startNodeAtNode(e) {
      return this.startNodeAt(e.start, e.loc.start)
    }
    finishNode(e, r) {
      return this.finishNodeAt(e, r, this.state.lastTokEndLoc)
    }
    finishNodeAt(e, r, i) {
      return (
        (e.type = r),
        (e.end = i.index),
        (e.loc.end = i),
        this.options.ranges && (e.range[1] = i.index),
        this.options.attachComment && this.processComment(e),
        e
      )
    }
    resetStartLocation(e, r, i) {
      ;(e.start = r), (e.loc.start = i), this.options.ranges && (e.range[0] = r)
    }
    resetEndLocation(e, r = this.state.lastTokEndLoc) {
      ;(e.end = r.index), (e.loc.end = r), this.options.ranges && (e.range[1] = r.index)
    }
    resetStartLocationFromNode(e, r) {
      this.resetStartLocation(e, r.start, r.loc.start)
    }
  }
  const FK = new Set([
      '_',
      'any',
      'bool',
      'boolean',
      'empty',
      'extends',
      'false',
      'interface',
      'mixed',
      'null',
      'number',
      'static',
      'string',
      'true',
      'typeof',
      'void',
    ]),
    He = ei`flow`((t) => ({
      AmbiguousConditionalArrow: t('Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.'),
      AmbiguousDeclareModuleKind: t(
        'Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.'
      ),
      AssignReservedType: t(({ reservedType: e }) => `Cannot overwrite reserved type ${e}.`),
      DeclareClassElement: t('The `declare` modifier can only appear on class fields.'),
      DeclareClassFieldInitializer: t('Initializers are not allowed in fields with the `declare` modifier.'),
      DuplicateDeclareModuleExports: t('Duplicate `declare module.exports` statement.'),
      EnumBooleanMemberNotInitialized: t(
        ({ memberName: e, enumName: r }) =>
          `Boolean enum members need to be initialized. Use either \`${e} = true,\` or \`${e} = false,\` in enum \`${r}\`.`
      ),
      EnumDuplicateMemberName: t(
        ({ memberName: e, enumName: r }) =>
          `Enum member names need to be unique, but the name \`${e}\` has already been used before in enum \`${r}\`.`
      ),
      EnumInconsistentMemberValues: t(
        ({ enumName: e }) =>
          `Enum \`${e}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`
      ),
      EnumInvalidExplicitType: t(
        ({ invalidEnumType: e, enumName: r }) =>
          `Enum type \`${e}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${r}\`.`
      ),
      EnumInvalidExplicitTypeUnknownSupplied: t(
        ({ enumName: e }) =>
          `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${e}\`.`
      ),
      EnumInvalidMemberInitializerPrimaryType: t(
        ({ enumName: e, memberName: r, explicitType: i }) =>
          `Enum \`${e}\` has type \`${i}\`, so the initializer of \`${r}\` needs to be a ${i} literal.`
      ),
      EnumInvalidMemberInitializerSymbolType: t(
        ({ enumName: e, memberName: r }) => `Symbol enum members cannot be initialized. Use \`${r},\` in enum \`${e}\`.`
      ),
      EnumInvalidMemberInitializerUnknownType: t(
        ({ enumName: e, memberName: r }) =>
          `The enum member initializer for \`${r}\` needs to be a literal (either a boolean, number, or string) in enum \`${e}\`.`
      ),
      EnumInvalidMemberName: t(
        ({ enumName: e, memberName: r, suggestion: i }) =>
          `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${r}\`, consider using \`${i}\`, in enum \`${e}\`.`
      ),
      EnumNumberMemberNotInitialized: t(
        ({ enumName: e, memberName: r }) =>
          `Number enum members need to be initialized, e.g. \`${r} = 1\` in enum \`${e}\`.`
      ),
      EnumStringMemberInconsistentlyInitailized: t(
        ({ enumName: e }) =>
          `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${e}\`.`
      ),
      GetterMayNotHaveThisParam: t('A getter cannot have a `this` parameter.'),
      ImportTypeShorthandOnlyInPureImport: t(
        'The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.'
      ),
      InexactInsideExact: t('Explicit inexact syntax cannot appear inside an explicit exact object type.'),
      InexactInsideNonObject: t('Explicit inexact syntax cannot appear in class or interface definitions.'),
      InexactVariance: t('Explicit inexact syntax cannot have variance.'),
      InvalidNonTypeImportInDeclareModule: t(
        'Imports within a `declare module` body must always be `import type` or `import typeof`.'
      ),
      MissingTypeParamDefault: t(
        'Type parameter declaration needs a default, since a preceding type parameter declaration has a default.'
      ),
      NestedDeclareModule: t('`declare module` cannot be used inside another `declare module`.'),
      NestedFlowComment: t('Cannot have a flow comment inside another flow comment.'),
      PatternIsOptional: t('A binding pattern parameter cannot be optional in an implementation signature.', {
        reasonCode: 'OptionalBindingPattern',
      }),
      SetterMayNotHaveThisParam: t('A setter cannot have a `this` parameter.'),
      SpreadVariance: t('Spread properties cannot have variance.'),
      ThisParamAnnotationRequired: t('A type annotation is required for the `this` parameter.'),
      ThisParamBannedInConstructor: t(
        "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions."
      ),
      ThisParamMayNotBeOptional: t('The `this` parameter cannot be optional.'),
      ThisParamMustBeFirst: t('The `this` parameter must be the first function parameter.'),
      ThisParamNoDefault: t('The `this` parameter may not have a default value.'),
      TypeBeforeInitializer: t(
        'Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.'
      ),
      TypeCastInPattern: t('The type cast expression is expected to be wrapped with parenthesis.'),
      UnexpectedExplicitInexactInObject: t('Explicit inexact syntax must appear at the end of an inexact object.'),
      UnexpectedReservedType: t(({ reservedType: e }) => `Unexpected reserved type ${e}.`),
      UnexpectedReservedUnderscore: t('`_` is only allowed as a type argument to call or new.'),
      UnexpectedSpaceBetweenModuloChecks: t('Spaces between `%` and `checks` are not allowed here.'),
      UnexpectedSpreadType: t('Spread operator cannot appear in class or interface definitions.'),
      UnexpectedSubtractionOperand: t('Unexpected token, expected "number" or "bigint".'),
      UnexpectedTokenAfterTypeParameter: t('Expected an arrow function after this type parameter declaration.'),
      UnexpectedTypeParameterBeforeAsyncArrowFunction: t(
        'Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.'
      ),
      UnsupportedDeclareExportKind: t(
        ({ unsupportedExportKind: e, suggestion: r }) =>
          `\`declare export ${e}\` is not supported. Use \`${r}\` instead.`
      ),
      UnsupportedStatementInDeclareModule: t('Only declares and type imports are allowed inside declare module.'),
      UnterminatedFlowComment: t('Unterminated flow-comment.'),
    }))
  function $K(t) {
    return (
      t.type === 'DeclareExportAllDeclaration' ||
      (t.type === 'DeclareExportDeclaration' &&
        (!t.declaration || (t.declaration.type !== 'TypeAlias' && t.declaration.type !== 'InterfaceDeclaration')))
    )
  }
  function qp(t) {
    return t.importKind === 'type' || t.importKind === 'typeof'
  }
  function lg(t) {
    return ri(t) && t !== 97
  }
  const RK = {
    const: 'declare export var',
    let: 'declare export var',
    type: 'export type',
    interface: 'export interface',
  }
  function jK(t, e) {
    const r = [],
      i = []
    for (let n = 0; n < t.length; n++) (e(t[n], n, t) ? r : i).push(t[n])
    return [r, i]
  }
  const _K = /\*?\s*@((?:no)?flow)\b/
  var VK = (t) =>
    class extends t {
      constructor(...e) {
        super(...e), (this.flowPragma = void 0)
      }
      getScopeHandler() {
        return PK
      }
      shouldParseTypes() {
        return this.getPluginOption('flow', 'all') || this.flowPragma === 'flow'
      }
      shouldParseEnums() {
        return !!this.getPluginOption('flow', 'enums')
      }
      finishToken(e, r) {
        return (
          e !== 129 && e !== 13 && e !== 28 && this.flowPragma === void 0 && (this.flowPragma = null),
          super.finishToken(e, r)
        )
      }
      addComment(e) {
        if (this.flowPragma === void 0) {
          const r = _K.exec(e.value)
          if (r)
            if (r[1] === 'flow') this.flowPragma = 'flow'
            else if (r[1] === 'noflow') this.flowPragma = 'noflow'
            else throw new Error('Unexpected flow pragma')
        }
        return super.addComment(e)
      }
      flowParseTypeInitialiser(e) {
        const r = this.state.inType
        ;(this.state.inType = !0), this.expect(e || 14)
        const i = this.flowParseType()
        return (this.state.inType = r), i
      }
      flowParsePredicate() {
        const e = this.startNode(),
          r = this.state.startLoc
        return (
          this.next(),
          this.expectContextual(107),
          this.state.lastTokStart > r.index + 1 && this.raise(He.UnexpectedSpaceBetweenModuloChecks, { at: r }),
          this.eat(10)
            ? ((e.value = this.parseExpression()), this.expect(11), this.finishNode(e, 'DeclaredPredicate'))
            : this.finishNode(e, 'InferredPredicate')
        )
      }
      flowParseTypeAndPredicateInitialiser() {
        const e = this.state.inType
        ;(this.state.inType = !0), this.expect(14)
        let r = null,
          i = null
        return (
          this.match(54)
            ? ((this.state.inType = e), (i = this.flowParsePredicate()))
            : ((r = this.flowParseType()), (this.state.inType = e), this.match(54) && (i = this.flowParsePredicate())),
          [r, i]
        )
      }
      flowParseDeclareClass(e) {
        return this.next(), this.flowParseInterfaceish(e, !0), this.finishNode(e, 'DeclareClass')
      }
      flowParseDeclareFunction(e) {
        this.next()
        const r = (e.id = this.parseIdentifier()),
          i = this.startNode(),
          n = this.startNode()
        this.match(47) ? (i.typeParameters = this.flowParseTypeParameterDeclaration()) : (i.typeParameters = null),
          this.expect(10)
        const s = this.flowParseFunctionTypeParams()
        return (
          (i.params = s.params),
          (i.rest = s.rest),
          (i.this = s._this),
          this.expect(11),
          ([i.returnType, e.predicate] = this.flowParseTypeAndPredicateInitialiser()),
          (n.typeAnnotation = this.finishNode(i, 'FunctionTypeAnnotation')),
          (r.typeAnnotation = this.finishNode(n, 'TypeAnnotation')),
          this.resetEndLocation(r),
          this.semicolon(),
          this.scope.declareName(e.id.name, oK, e.id.loc.start),
          this.finishNode(e, 'DeclareFunction')
        )
      }
      flowParseDeclare(e, r) {
        if (this.match(80)) return this.flowParseDeclareClass(e)
        if (this.match(68)) return this.flowParseDeclareFunction(e)
        if (this.match(74)) return this.flowParseDeclareVariable(e)
        if (this.eatContextual(123))
          return this.match(16)
            ? this.flowParseDeclareModuleExports(e)
            : (r && this.raise(He.NestedDeclareModule, { at: this.state.lastTokStartLoc }),
              this.flowParseDeclareModule(e))
        if (this.isContextual(126)) return this.flowParseDeclareTypeAlias(e)
        if (this.isContextual(127)) return this.flowParseDeclareOpaqueType(e)
        if (this.isContextual(125)) return this.flowParseDeclareInterface(e)
        if (this.match(82)) return this.flowParseDeclareExportDeclaration(e, r)
        throw this.unexpected()
      }
      flowParseDeclareVariable(e) {
        return (
          this.next(),
          (e.id = this.flowParseTypeAnnotatableIdentifier(!0)),
          this.scope.declareName(e.id.name, Xo, e.id.loc.start),
          this.semicolon(),
          this.finishNode(e, 'DeclareVariable')
        )
      }
      flowParseDeclareModule(e) {
        this.scope.enter(Rn), this.match(129) ? (e.id = this.parseExprAtom()) : (e.id = this.parseIdentifier())
        const r = (e.body = this.startNode()),
          i = (r.body = [])
        for (this.expect(5); !this.match(8); ) {
          let a = this.startNode()
          this.match(83)
            ? (this.next(),
              !this.isContextual(126) &&
                !this.match(87) &&
                this.raise(He.InvalidNonTypeImportInDeclareModule, { at: this.state.lastTokStartLoc }),
              this.parseImport(a))
            : (this.expectContextual(121, He.UnsupportedStatementInDeclareModule), (a = this.flowParseDeclare(a, !0))),
            i.push(a)
        }
        this.scope.exit(), this.expect(8), this.finishNode(r, 'BlockStatement')
        let n = null,
          s = !1
        return (
          i.forEach((a) => {
            $K(a)
              ? (n === 'CommonJS' && this.raise(He.AmbiguousDeclareModuleKind, { at: a }), (n = 'ES'))
              : a.type === 'DeclareModuleExports' &&
                (s && this.raise(He.DuplicateDeclareModuleExports, { at: a }),
                n === 'ES' && this.raise(He.AmbiguousDeclareModuleKind, { at: a }),
                (n = 'CommonJS'),
                (s = !0))
          }),
          (e.kind = n || 'CommonJS'),
          this.finishNode(e, 'DeclareModule')
        )
      }
      flowParseDeclareExportDeclaration(e, r) {
        if ((this.expect(82), this.eat(65)))
          return (
            this.match(68) || this.match(80)
              ? (e.declaration = this.flowParseDeclare(this.startNode()))
              : ((e.declaration = this.flowParseType()), this.semicolon()),
            (e.default = !0),
            this.finishNode(e, 'DeclareExportDeclaration')
          )
        if (this.match(75) || this.isLet() || ((this.isContextual(126) || this.isContextual(125)) && !r)) {
          const i = this.state.value
          throw this.raise(He.UnsupportedDeclareExportKind, {
            at: this.state.startLoc,
            unsupportedExportKind: i,
            suggestion: RK[i],
          })
        }
        if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(127))
          return (
            (e.declaration = this.flowParseDeclare(this.startNode())),
            (e.default = !1),
            this.finishNode(e, 'DeclareExportDeclaration')
          )
        if (
          this.match(55) ||
          this.match(5) ||
          this.isContextual(125) ||
          this.isContextual(126) ||
          this.isContextual(127)
        )
          return (
            (e = this.parseExport(e)),
            e.type === 'ExportNamedDeclaration' &&
              ((e.type = 'ExportDeclaration'), (e.default = !1), delete e.exportKind),
            (e.type = 'Declare' + e.type),
            e
          )
        throw this.unexpected()
      }
      flowParseDeclareModuleExports(e) {
        return (
          this.next(),
          this.expectContextual(108),
          (e.typeAnnotation = this.flowParseTypeAnnotation()),
          this.semicolon(),
          this.finishNode(e, 'DeclareModuleExports')
        )
      }
      flowParseDeclareTypeAlias(e) {
        return this.next(), this.flowParseTypeAlias(e), (e.type = 'DeclareTypeAlias'), e
      }
      flowParseDeclareOpaqueType(e) {
        return this.next(), this.flowParseOpaqueType(e, !0), (e.type = 'DeclareOpaqueType'), e
      }
      flowParseDeclareInterface(e) {
        return this.next(), this.flowParseInterfaceish(e), this.finishNode(e, 'DeclareInterface')
      }
      flowParseInterfaceish(e, r = !1) {
        if (
          ((e.id = this.flowParseRestrictedIdentifier(!r, !0)),
          this.scope.declareName(e.id.name, r ? G0 : oi, e.id.loc.start),
          this.match(47) ? (e.typeParameters = this.flowParseTypeParameterDeclaration()) : (e.typeParameters = null),
          (e.extends = []),
          (e.implements = []),
          (e.mixins = []),
          this.eat(81))
        )
          do e.extends.push(this.flowParseInterfaceExtends())
          while (!r && this.eat(12))
        if (this.isContextual(114)) {
          this.next()
          do e.mixins.push(this.flowParseInterfaceExtends())
          while (this.eat(12))
        }
        if (this.isContextual(110)) {
          this.next()
          do e.implements.push(this.flowParseInterfaceExtends())
          while (this.eat(12))
        }
        e.body = this.flowParseObjectType({
          allowStatic: r,
          allowExact: !1,
          allowSpread: !1,
          allowProto: r,
          allowInexact: !1,
        })
      }
      flowParseInterfaceExtends() {
        const e = this.startNode()
        return (
          (e.id = this.flowParseQualifiedTypeIdentifier()),
          this.match(47) ? (e.typeParameters = this.flowParseTypeParameterInstantiation()) : (e.typeParameters = null),
          this.finishNode(e, 'InterfaceExtends')
        )
      }
      flowParseInterface(e) {
        return this.flowParseInterfaceish(e), this.finishNode(e, 'InterfaceDeclaration')
      }
      checkNotUnderscore(e) {
        e === '_' && this.raise(He.UnexpectedReservedUnderscore, { at: this.state.startLoc })
      }
      checkReservedType(e, r, i) {
        !FK.has(e) || this.raise(i ? He.AssignReservedType : He.UnexpectedReservedType, { at: r, reservedType: e })
      }
      flowParseRestrictedIdentifier(e, r) {
        return this.checkReservedType(this.state.value, this.state.startLoc, r), this.parseIdentifier(e)
      }
      flowParseTypeAlias(e) {
        return (
          (e.id = this.flowParseRestrictedIdentifier(!1, !0)),
          this.scope.declareName(e.id.name, oi, e.id.loc.start),
          this.match(47) ? (e.typeParameters = this.flowParseTypeParameterDeclaration()) : (e.typeParameters = null),
          (e.right = this.flowParseTypeInitialiser(29)),
          this.semicolon(),
          this.finishNode(e, 'TypeAlias')
        )
      }
      flowParseOpaqueType(e, r) {
        return (
          this.expectContextual(126),
          (e.id = this.flowParseRestrictedIdentifier(!0, !0)),
          this.scope.declareName(e.id.name, oi, e.id.loc.start),
          this.match(47) ? (e.typeParameters = this.flowParseTypeParameterDeclaration()) : (e.typeParameters = null),
          (e.supertype = null),
          this.match(14) && (e.supertype = this.flowParseTypeInitialiser(14)),
          (e.impltype = null),
          r || (e.impltype = this.flowParseTypeInitialiser(29)),
          this.semicolon(),
          this.finishNode(e, 'OpaqueType')
        )
      }
      flowParseTypeParameter(e = !1) {
        const r = this.state.startLoc,
          i = this.startNode(),
          n = this.flowParseVariance(),
          s = this.flowParseTypeAnnotatableIdentifier()
        return (
          (i.name = s.name),
          (i.variance = n),
          (i.bound = s.typeAnnotation),
          this.match(29)
            ? (this.eat(29), (i.default = this.flowParseType()))
            : e && this.raise(He.MissingTypeParamDefault, { at: r }),
          this.finishNode(i, 'TypeParameter')
        )
      }
      flowParseTypeParameterDeclaration() {
        const e = this.state.inType,
          r = this.startNode()
        ;(r.params = []), (this.state.inType = !0), this.match(47) || this.match(138) ? this.next() : this.unexpected()
        let i = !1
        do {
          const n = this.flowParseTypeParameter(i)
          r.params.push(n), n.default && (i = !0), this.match(48) || this.expect(12)
        } while (!this.match(48))
        return this.expect(48), (this.state.inType = e), this.finishNode(r, 'TypeParameterDeclaration')
      }
      flowParseTypeParameterInstantiation() {
        const e = this.startNode(),
          r = this.state.inType
        ;(e.params = []), (this.state.inType = !0), this.expect(47)
        const i = this.state.noAnonFunctionType
        for (this.state.noAnonFunctionType = !1; !this.match(48); )
          e.params.push(this.flowParseType()), this.match(48) || this.expect(12)
        return (
          (this.state.noAnonFunctionType = i),
          this.expect(48),
          (this.state.inType = r),
          this.finishNode(e, 'TypeParameterInstantiation')
        )
      }
      flowParseTypeParameterInstantiationCallOrNew() {
        const e = this.startNode(),
          r = this.state.inType
        for (e.params = [], this.state.inType = !0, this.expect(47); !this.match(48); )
          e.params.push(this.flowParseTypeOrImplicitInstantiation()), this.match(48) || this.expect(12)
        return this.expect(48), (this.state.inType = r), this.finishNode(e, 'TypeParameterInstantiation')
      }
      flowParseInterfaceType() {
        const e = this.startNode()
        if ((this.expectContextual(125), (e.extends = []), this.eat(81)))
          do e.extends.push(this.flowParseInterfaceExtends())
          while (this.eat(12))
        return (
          (e.body = this.flowParseObjectType({
            allowStatic: !1,
            allowExact: !1,
            allowSpread: !1,
            allowProto: !1,
            allowInexact: !1,
          })),
          this.finishNode(e, 'InterfaceTypeAnnotation')
        )
      }
      flowParseObjectPropertyKey() {
        return this.match(130) || this.match(129) ? this.parseExprAtom() : this.parseIdentifier(!0)
      }
      flowParseObjectTypeIndexer(e, r, i) {
        return (
          (e.static = r),
          this.lookahead().type === 14
            ? ((e.id = this.flowParseObjectPropertyKey()), (e.key = this.flowParseTypeInitialiser()))
            : ((e.id = null), (e.key = this.flowParseType())),
          this.expect(3),
          (e.value = this.flowParseTypeInitialiser()),
          (e.variance = i),
          this.finishNode(e, 'ObjectTypeIndexer')
        )
      }
      flowParseObjectTypeInternalSlot(e, r) {
        return (
          (e.static = r),
          (e.id = this.flowParseObjectPropertyKey()),
          this.expect(3),
          this.expect(3),
          this.match(47) || this.match(10)
            ? ((e.method = !0),
              (e.optional = !1),
              (e.value = this.flowParseObjectTypeMethodish(this.startNodeAt(e.start, e.loc.start))))
            : ((e.method = !1), this.eat(17) && (e.optional = !0), (e.value = this.flowParseTypeInitialiser())),
          this.finishNode(e, 'ObjectTypeInternalSlot')
        )
      }
      flowParseObjectTypeMethodish(e) {
        for (
          e.params = [],
            e.rest = null,
            e.typeParameters = null,
            e.this = null,
            this.match(47) && (e.typeParameters = this.flowParseTypeParameterDeclaration()),
            this.expect(10),
            this.match(78) &&
              ((e.this = this.flowParseFunctionTypeParam(!0)), (e.this.name = null), this.match(11) || this.expect(12));
          !this.match(11) && !this.match(21);

        )
          e.params.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12)
        return (
          this.eat(21) && (e.rest = this.flowParseFunctionTypeParam(!1)),
          this.expect(11),
          (e.returnType = this.flowParseTypeInitialiser()),
          this.finishNode(e, 'FunctionTypeAnnotation')
        )
      }
      flowParseObjectTypeCallProperty(e, r) {
        const i = this.startNode()
        return (
          (e.static = r), (e.value = this.flowParseObjectTypeMethodish(i)), this.finishNode(e, 'ObjectTypeCallProperty')
        )
      }
      flowParseObjectType({ allowStatic: e, allowExact: r, allowSpread: i, allowProto: n, allowInexact: s }) {
        const a = this.state.inType
        this.state.inType = !0
        const o = this.startNode()
        ;(o.callProperties = []), (o.properties = []), (o.indexers = []), (o.internalSlots = [])
        let u,
          c,
          p = !1
        for (
          r && this.match(6) ? (this.expect(6), (u = 9), (c = !0)) : (this.expect(5), (u = 8), (c = !1)), o.exact = c;
          !this.match(u);

        ) {
          let f = !1,
            d = null,
            T = null
          const y = this.startNode()
          if (n && this.isContextual(115)) {
            const m = this.lookahead()
            m.type !== 14 && m.type !== 17 && (this.next(), (d = this.state.startLoc), (e = !1))
          }
          if (e && this.isContextual(104)) {
            const m = this.lookahead()
            m.type !== 14 && m.type !== 17 && (this.next(), (f = !0))
          }
          const b = this.flowParseVariance()
          if (this.eat(0))
            d != null && this.unexpected(d),
              this.eat(0)
                ? (b && this.unexpected(b.loc.start), o.internalSlots.push(this.flowParseObjectTypeInternalSlot(y, f)))
                : o.indexers.push(this.flowParseObjectTypeIndexer(y, f, b))
          else if (this.match(10) || this.match(47))
            d != null && this.unexpected(d),
              b && this.unexpected(b.loc.start),
              o.callProperties.push(this.flowParseObjectTypeCallProperty(y, f))
          else {
            let m = 'init'
            if (this.isContextual(98) || this.isContextual(103)) {
              const E = this.lookahead()
              $0(E.type) && ((m = this.state.value), this.next())
            }
            const S = this.flowParseObjectTypeProperty(y, f, d, b, m, i, s != null ? s : !c)
            S === null ? ((p = !0), (T = this.state.lastTokStartLoc)) : o.properties.push(S)
          }
          this.flowObjectTypeSemicolon(),
            T && !this.match(8) && !this.match(9) && this.raise(He.UnexpectedExplicitInexactInObject, { at: T })
        }
        this.expect(u), i && (o.inexact = p)
        const h = this.finishNode(o, 'ObjectTypeAnnotation')
        return (this.state.inType = a), h
      }
      flowParseObjectTypeProperty(e, r, i, n, s, a, o) {
        if (this.eat(21))
          return this.match(12) || this.match(13) || this.match(8) || this.match(9)
            ? (a
                ? o || this.raise(He.InexactInsideExact, { at: this.state.lastTokStartLoc })
                : this.raise(He.InexactInsideNonObject, { at: this.state.lastTokStartLoc }),
              n && this.raise(He.InexactVariance, { at: n }),
              null)
            : (a || this.raise(He.UnexpectedSpreadType, { at: this.state.lastTokStartLoc }),
              i != null && this.unexpected(i),
              n && this.raise(He.SpreadVariance, { at: n }),
              (e.argument = this.flowParseType()),
              this.finishNode(e, 'ObjectTypeSpreadProperty'))
        {
          ;(e.key = this.flowParseObjectPropertyKey()), (e.static = r), (e.proto = i != null), (e.kind = s)
          let u = !1
          return (
            this.match(47) || this.match(10)
              ? ((e.method = !0),
                i != null && this.unexpected(i),
                n && this.unexpected(n.loc.start),
                (e.value = this.flowParseObjectTypeMethodish(this.startNodeAt(e.start, e.loc.start))),
                (s === 'get' || s === 'set') && this.flowCheckGetterSetterParams(e),
                !a &&
                  e.key.name === 'constructor' &&
                  e.value.this &&
                  this.raise(He.ThisParamBannedInConstructor, { at: e.value.this }))
              : (s !== 'init' && this.unexpected(),
                (e.method = !1),
                this.eat(17) && (u = !0),
                (e.value = this.flowParseTypeInitialiser()),
                (e.variance = n)),
            (e.optional = u),
            this.finishNode(e, 'ObjectTypeProperty')
          )
        }
      }
      flowCheckGetterSetterParams(e) {
        const r = e.kind === 'get' ? 0 : 1,
          i = e.value.params.length + (e.value.rest ? 1 : 0)
        e.value.this &&
          this.raise(e.kind === 'get' ? He.GetterMayNotHaveThisParam : He.SetterMayNotHaveThisParam, {
            at: e.value.this,
          }),
          i !== r && this.raise(e.kind === 'get' ? re.BadGetterArity : re.BadSetterArity, { at: e }),
          e.kind === 'set' && e.value.rest && this.raise(re.BadSetterRestParameter, { at: e })
      }
      flowObjectTypeSemicolon() {
        !this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9) && this.unexpected()
      }
      flowParseQualifiedTypeIdentifier(e, r, i) {
        ;(e = e || this.state.start), (r = r || this.state.startLoc)
        let n = i || this.flowParseRestrictedIdentifier(!0)
        for (; this.eat(16); ) {
          const s = this.startNodeAt(e, r)
          ;(s.qualification = n),
            (s.id = this.flowParseRestrictedIdentifier(!0)),
            (n = this.finishNode(s, 'QualifiedTypeIdentifier'))
        }
        return n
      }
      flowParseGenericType(e, r, i) {
        const n = this.startNodeAt(e, r)
        return (
          (n.typeParameters = null),
          (n.id = this.flowParseQualifiedTypeIdentifier(e, r, i)),
          this.match(47) && (n.typeParameters = this.flowParseTypeParameterInstantiation()),
          this.finishNode(n, 'GenericTypeAnnotation')
        )
      }
      flowParseTypeofType() {
        const e = this.startNode()
        return this.expect(87), (e.argument = this.flowParsePrimaryType()), this.finishNode(e, 'TypeofTypeAnnotation')
      }
      flowParseTupleType() {
        const e = this.startNode()
        for (
          e.types = [], this.expect(0);
          this.state.pos < this.length && !this.match(3) && (e.types.push(this.flowParseType()), !this.match(3));

        )
          this.expect(12)
        return this.expect(3), this.finishNode(e, 'TupleTypeAnnotation')
      }
      flowParseFunctionTypeParam(e) {
        let r = null,
          i = !1,
          n = null
        const s = this.startNode(),
          a = this.lookahead(),
          o = this.state.type === 78
        return (
          a.type === 14 || a.type === 17
            ? (o && !e && this.raise(He.ThisParamMustBeFirst, { at: s }),
              (r = this.parseIdentifier(o)),
              this.eat(17) && ((i = !0), o && this.raise(He.ThisParamMayNotBeOptional, { at: s })),
              (n = this.flowParseTypeInitialiser()))
            : (n = this.flowParseType()),
          (s.name = r),
          (s.optional = i),
          (s.typeAnnotation = n),
          this.finishNode(s, 'FunctionTypeParam')
        )
      }
      reinterpretTypeAsFunctionTypeParam(e) {
        const r = this.startNodeAt(e.start, e.loc.start)
        return (r.name = null), (r.optional = !1), (r.typeAnnotation = e), this.finishNode(r, 'FunctionTypeParam')
      }
      flowParseFunctionTypeParams(e = []) {
        let r = null,
          i = null
        for (
          this.match(78) &&
          ((i = this.flowParseFunctionTypeParam(!0)), (i.name = null), this.match(11) || this.expect(12));
          !this.match(11) && !this.match(21);

        )
          e.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12)
        return this.eat(21) && (r = this.flowParseFunctionTypeParam(!1)), { params: e, rest: r, _this: i }
      }
      flowIdentToTypeAnnotation(e, r, i, n) {
        switch (n.name) {
          case 'any':
            return this.finishNode(i, 'AnyTypeAnnotation')
          case 'bool':
          case 'boolean':
            return this.finishNode(i, 'BooleanTypeAnnotation')
          case 'mixed':
            return this.finishNode(i, 'MixedTypeAnnotation')
          case 'empty':
            return this.finishNode(i, 'EmptyTypeAnnotation')
          case 'number':
            return this.finishNode(i, 'NumberTypeAnnotation')
          case 'string':
            return this.finishNode(i, 'StringTypeAnnotation')
          case 'symbol':
            return this.finishNode(i, 'SymbolTypeAnnotation')
          default:
            return this.checkNotUnderscore(n.name), this.flowParseGenericType(e, r, n)
        }
      }
      flowParsePrimaryType() {
        const e = this.state.start,
          r = this.state.startLoc,
          i = this.startNode()
        let n,
          s,
          a = !1
        const o = this.state.noAnonFunctionType
        switch (this.state.type) {
          case 5:
            return this.flowParseObjectType({
              allowStatic: !1,
              allowExact: !1,
              allowSpread: !0,
              allowProto: !1,
              allowInexact: !0,
            })
          case 6:
            return this.flowParseObjectType({
              allowStatic: !1,
              allowExact: !0,
              allowSpread: !0,
              allowProto: !1,
              allowInexact: !1,
            })
          case 0:
            return (
              (this.state.noAnonFunctionType = !1),
              (s = this.flowParseTupleType()),
              (this.state.noAnonFunctionType = o),
              s
            )
          case 47:
            return (
              (i.typeParameters = this.flowParseTypeParameterDeclaration()),
              this.expect(10),
              (n = this.flowParseFunctionTypeParams()),
              (i.params = n.params),
              (i.rest = n.rest),
              (i.this = n._this),
              this.expect(11),
              this.expect(19),
              (i.returnType = this.flowParseType()),
              this.finishNode(i, 'FunctionTypeAnnotation')
            )
          case 10:
            if ((this.next(), !this.match(11) && !this.match(21)))
              if (mt(this.state.type) || this.match(78)) {
                const u = this.lookahead().type
                a = u !== 17 && u !== 14
              } else a = !0
            if (a) {
              if (
                ((this.state.noAnonFunctionType = !1),
                (s = this.flowParseType()),
                (this.state.noAnonFunctionType = o),
                this.state.noAnonFunctionType || !(this.match(12) || (this.match(11) && this.lookahead().type === 19)))
              )
                return this.expect(11), s
              this.eat(12)
            }
            return (
              s
                ? (n = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(s)]))
                : (n = this.flowParseFunctionTypeParams()),
              (i.params = n.params),
              (i.rest = n.rest),
              (i.this = n._this),
              this.expect(11),
              this.expect(19),
              (i.returnType = this.flowParseType()),
              (i.typeParameters = null),
              this.finishNode(i, 'FunctionTypeAnnotation')
            )
          case 129:
            return this.parseLiteral(this.state.value, 'StringLiteralTypeAnnotation')
          case 85:
          case 86:
            return (i.value = this.match(85)), this.next(), this.finishNode(i, 'BooleanLiteralTypeAnnotation')
          case 53:
            if (this.state.value === '-') {
              if ((this.next(), this.match(130)))
                return this.parseLiteralAtNode(-this.state.value, 'NumberLiteralTypeAnnotation', i)
              if (this.match(131)) return this.parseLiteralAtNode(-this.state.value, 'BigIntLiteralTypeAnnotation', i)
              throw this.raise(He.UnexpectedSubtractionOperand, { at: this.state.startLoc })
            }
            throw this.unexpected()
          case 130:
            return this.parseLiteral(this.state.value, 'NumberLiteralTypeAnnotation')
          case 131:
            return this.parseLiteral(this.state.value, 'BigIntLiteralTypeAnnotation')
          case 88:
            return this.next(), this.finishNode(i, 'VoidTypeAnnotation')
          case 84:
            return this.next(), this.finishNode(i, 'NullLiteralTypeAnnotation')
          case 78:
            return this.next(), this.finishNode(i, 'ThisTypeAnnotation')
          case 55:
            return this.next(), this.finishNode(i, 'ExistsTypeAnnotation')
          case 87:
            return this.flowParseTypeofType()
          default:
            if (xp(this.state.type)) {
              const u = Ei(this.state.type)
              return this.next(), super.createIdentifier(i, u)
            } else if (mt(this.state.type))
              return this.isContextual(125)
                ? this.flowParseInterfaceType()
                : this.flowIdentToTypeAnnotation(e, r, i, this.parseIdentifier())
        }
        throw this.unexpected()
      }
      flowParsePostfixType() {
        const e = this.state.start,
          r = this.state.startLoc
        let i = this.flowParsePrimaryType(),
          n = !1
        for (; (this.match(0) || this.match(18)) && !this.canInsertSemicolon(); ) {
          const s = this.startNodeAt(e, r),
            a = this.eat(18)
          ;(n = n || a),
            this.expect(0),
            !a && this.match(3)
              ? ((s.elementType = i), this.next(), (i = this.finishNode(s, 'ArrayTypeAnnotation')))
              : ((s.objectType = i),
                (s.indexType = this.flowParseType()),
                this.expect(3),
                n
                  ? ((s.optional = a), (i = this.finishNode(s, 'OptionalIndexedAccessType')))
                  : (i = this.finishNode(s, 'IndexedAccessType')))
        }
        return i
      }
      flowParsePrefixType() {
        const e = this.startNode()
        return this.eat(17)
          ? ((e.typeAnnotation = this.flowParsePrefixType()), this.finishNode(e, 'NullableTypeAnnotation'))
          : this.flowParsePostfixType()
      }
      flowParseAnonFunctionWithoutParens() {
        const e = this.flowParsePrefixType()
        if (!this.state.noAnonFunctionType && this.eat(19)) {
          const r = this.startNodeAt(e.start, e.loc.start)
          return (
            (r.params = [this.reinterpretTypeAsFunctionTypeParam(e)]),
            (r.rest = null),
            (r.this = null),
            (r.returnType = this.flowParseType()),
            (r.typeParameters = null),
            this.finishNode(r, 'FunctionTypeAnnotation')
          )
        }
        return e
      }
      flowParseIntersectionType() {
        const e = this.startNode()
        this.eat(45)
        const r = this.flowParseAnonFunctionWithoutParens()
        for (e.types = [r]; this.eat(45); ) e.types.push(this.flowParseAnonFunctionWithoutParens())
        return e.types.length === 1 ? r : this.finishNode(e, 'IntersectionTypeAnnotation')
      }
      flowParseUnionType() {
        const e = this.startNode()
        this.eat(43)
        const r = this.flowParseIntersectionType()
        for (e.types = [r]; this.eat(43); ) e.types.push(this.flowParseIntersectionType())
        return e.types.length === 1 ? r : this.finishNode(e, 'UnionTypeAnnotation')
      }
      flowParseType() {
        const e = this.state.inType
        this.state.inType = !0
        const r = this.flowParseUnionType()
        return (this.state.inType = e), r
      }
      flowParseTypeOrImplicitInstantiation() {
        if (this.state.type === 128 && this.state.value === '_') {
          const e = this.state.start,
            r = this.state.startLoc,
            i = this.parseIdentifier()
          return this.flowParseGenericType(e, r, i)
        } else return this.flowParseType()
      }
      flowParseTypeAnnotation() {
        const e = this.startNode()
        return (e.typeAnnotation = this.flowParseTypeInitialiser()), this.finishNode(e, 'TypeAnnotation')
      }
      flowParseTypeAnnotatableIdentifier(e) {
        const r = e ? this.parseIdentifier() : this.flowParseRestrictedIdentifier()
        return this.match(14) && ((r.typeAnnotation = this.flowParseTypeAnnotation()), this.resetEndLocation(r)), r
      }
      typeCastToParameter(e) {
        return (
          (e.expression.typeAnnotation = e.typeAnnotation),
          this.resetEndLocation(e.expression, e.typeAnnotation.loc.end),
          e.expression
        )
      }
      flowParseVariance() {
        let e = null
        return (
          this.match(53) &&
            ((e = this.startNode()),
            this.state.value === '+' ? (e.kind = 'plus') : (e.kind = 'minus'),
            this.next(),
            this.finishNode(e, 'Variance')),
          e
        )
      }
      parseFunctionBody(e, r, i = !1) {
        return r
          ? this.forwardNoArrowParamsConversionAt(e, () => super.parseFunctionBody(e, !0, i))
          : super.parseFunctionBody(e, !1, i)
      }
      parseFunctionBodyAndFinish(e, r, i = !1) {
        if (this.match(14)) {
          const n = this.startNode()
          ;([n.typeAnnotation, e.predicate] = this.flowParseTypeAndPredicateInitialiser()),
            (e.returnType = n.typeAnnotation ? this.finishNode(n, 'TypeAnnotation') : null)
        }
        super.parseFunctionBodyAndFinish(e, r, i)
      }
      parseStatement(e, r) {
        if (this.state.strict && this.isContextual(125)) {
          const n = this.lookahead()
          if (ri(n.type)) {
            const s = this.startNode()
            return this.next(), this.flowParseInterface(s)
          }
        } else if (this.shouldParseEnums() && this.isContextual(122)) {
          const n = this.startNode()
          return this.next(), this.flowParseEnumDeclaration(n)
        }
        const i = super.parseStatement(e, r)
        return this.flowPragma === void 0 && !this.isValidDirective(i) && (this.flowPragma = null), i
      }
      parseExpressionStatement(e, r) {
        if (r.type === 'Identifier') {
          if (r.name === 'declare') {
            if (this.match(80) || mt(this.state.type) || this.match(68) || this.match(74) || this.match(82))
              return this.flowParseDeclare(e)
          } else if (mt(this.state.type)) {
            if (r.name === 'interface') return this.flowParseInterface(e)
            if (r.name === 'type') return this.flowParseTypeAlias(e)
            if (r.name === 'opaque') return this.flowParseOpaqueType(e, !1)
          }
        }
        return super.parseExpressionStatement(e, r)
      }
      shouldParseExportDeclaration() {
        const { type: e } = this.state
        return R0(e) || (this.shouldParseEnums() && e === 122)
          ? !this.state.containsEsc
          : super.shouldParseExportDeclaration()
      }
      isExportDefaultSpecifier() {
        const { type: e } = this.state
        return R0(e) || (this.shouldParseEnums() && e === 122)
          ? this.state.containsEsc
          : super.isExportDefaultSpecifier()
      }
      parseExportDefaultExpression() {
        if (this.shouldParseEnums() && this.isContextual(122)) {
          const e = this.startNode()
          return this.next(), this.flowParseEnumDeclaration(e)
        }
        return super.parseExportDefaultExpression()
      }
      parseConditional(e, r, i, n) {
        if (!this.match(17)) return e
        if (this.state.maybeInArrowParameters) {
          const f = this.lookaheadCharCode()
          if (f === 44 || f === 61 || f === 58 || f === 41) return this.setOptionalParametersError(n), e
        }
        this.expect(17)
        const s = this.state.clone(),
          a = this.state.noArrowAt,
          o = this.startNodeAt(r, i)
        let { consequent: u, failed: c } = this.tryParseConditionalConsequent(),
          [p, h] = this.getArrowLikeExpressions(u)
        if (c || h.length > 0) {
          const f = [...a]
          if (h.length > 0) {
            ;(this.state = s), (this.state.noArrowAt = f)
            for (let d = 0; d < h.length; d++) f.push(h[d].start)
            ;({ consequent: u, failed: c } = this.tryParseConditionalConsequent()),
              ([p, h] = this.getArrowLikeExpressions(u))
          }
          c && p.length > 1 && this.raise(He.AmbiguousConditionalArrow, { at: s.startLoc }),
            c &&
              p.length === 1 &&
              ((this.state = s),
              f.push(p[0].start),
              (this.state.noArrowAt = f),
              ({ consequent: u, failed: c } = this.tryParseConditionalConsequent()))
        }
        return (
          this.getArrowLikeExpressions(u, !0),
          (this.state.noArrowAt = a),
          this.expect(14),
          (o.test = e),
          (o.consequent = u),
          (o.alternate = this.forwardNoArrowParamsConversionAt(o, () => this.parseMaybeAssign(void 0, void 0))),
          this.finishNode(o, 'ConditionalExpression')
        )
      }
      tryParseConditionalConsequent() {
        this.state.noArrowParamsConversionAt.push(this.state.start)
        const e = this.parseMaybeAssignAllowIn(),
          r = !this.match(14)
        return this.state.noArrowParamsConversionAt.pop(), { consequent: e, failed: r }
      }
      getArrowLikeExpressions(e, r) {
        const i = [e],
          n = []
        for (; i.length !== 0; ) {
          const s = i.pop()
          s.type === 'ArrowFunctionExpression'
            ? (s.typeParameters || !s.returnType ? this.finishArrowValidation(s) : n.push(s), i.push(s.body))
            : s.type === 'ConditionalExpression' && (i.push(s.consequent), i.push(s.alternate))
        }
        return r
          ? (n.forEach((s) => this.finishArrowValidation(s)), [n, []])
          : jK(n, (s) => s.params.every((a) => this.isAssignable(a, !0)))
      }
      finishArrowValidation(e) {
        var r
        this.toAssignableList(e.params, (r = e.extra) == null ? void 0 : r.trailingCommaLoc, !1),
          this.scope.enter(si | Op),
          super.checkParams(e, !1, !0),
          this.scope.exit()
      }
      forwardNoArrowParamsConversionAt(e, r) {
        let i
        return (
          this.state.noArrowParamsConversionAt.indexOf(e.start) !== -1
            ? (this.state.noArrowParamsConversionAt.push(this.state.start),
              (i = r()),
              this.state.noArrowParamsConversionAt.pop())
            : (i = r()),
          i
        )
      }
      parseParenItem(e, r, i) {
        if (
          ((e = super.parseParenItem(e, r, i)),
          this.eat(17) && ((e.optional = !0), this.resetEndLocation(e)),
          this.match(14))
        ) {
          const n = this.startNodeAt(r, i)
          return (
            (n.expression = e),
            (n.typeAnnotation = this.flowParseTypeAnnotation()),
            this.finishNode(n, 'TypeCastExpression')
          )
        }
        return e
      }
      assertModuleNodeAllowed(e) {
        ;(e.type === 'ImportDeclaration' && (e.importKind === 'type' || e.importKind === 'typeof')) ||
          (e.type === 'ExportNamedDeclaration' && e.exportKind === 'type') ||
          (e.type === 'ExportAllDeclaration' && e.exportKind === 'type') ||
          super.assertModuleNodeAllowed(e)
      }
      parseExport(e) {
        const r = super.parseExport(e)
        return (
          (r.type === 'ExportNamedDeclaration' || r.type === 'ExportAllDeclaration') &&
            (r.exportKind = r.exportKind || 'value'),
          r
        )
      }
      parseExportDeclaration(e) {
        if (this.isContextual(126)) {
          e.exportKind = 'type'
          const r = this.startNode()
          return (
            this.next(),
            this.match(5)
              ? ((e.specifiers = this.parseExportSpecifiers(!0)), this.parseExportFrom(e), null)
              : this.flowParseTypeAlias(r)
          )
        } else if (this.isContextual(127)) {
          e.exportKind = 'type'
          const r = this.startNode()
          return this.next(), this.flowParseOpaqueType(r, !1)
        } else if (this.isContextual(125)) {
          e.exportKind = 'type'
          const r = this.startNode()
          return this.next(), this.flowParseInterface(r)
        } else if (this.shouldParseEnums() && this.isContextual(122)) {
          e.exportKind = 'value'
          const r = this.startNode()
          return this.next(), this.flowParseEnumDeclaration(r)
        } else return super.parseExportDeclaration(e)
      }
      eatExportStar(e) {
        return super.eatExportStar(...arguments)
          ? !0
          : this.isContextual(126) && this.lookahead().type === 55
          ? ((e.exportKind = 'type'), this.next(), this.next(), !0)
          : !1
      }
      maybeParseExportNamespaceSpecifier(e) {
        const { startLoc: r } = this.state,
          i = super.maybeParseExportNamespaceSpecifier(e)
        return i && e.exportKind === 'type' && this.unexpected(r), i
      }
      parseClassId(e, r, i) {
        super.parseClassId(e, r, i), this.match(47) && (e.typeParameters = this.flowParseTypeParameterDeclaration())
      }
      parseClassMember(e, r, i) {
        const { startLoc: n } = this.state
        if (this.isContextual(121)) {
          if (this.parseClassMemberFromModifier(e, r)) return
          r.declare = !0
        }
        super.parseClassMember(e, r, i),
          r.declare &&
            (r.type !== 'ClassProperty' && r.type !== 'ClassPrivateProperty' && r.type !== 'PropertyDefinition'
              ? this.raise(He.DeclareClassElement, { at: n })
              : r.value && this.raise(He.DeclareClassFieldInitializer, { at: r.value }))
      }
      isIterator(e) {
        return e === 'iterator' || e === 'asyncIterator'
      }
      readIterator() {
        const e = super.readWord1(),
          r = '@@' + e
        ;(!this.isIterator(e) || !this.state.inType) &&
          this.raise(re.InvalidIdentifier, { at: this.state.curPosition(), identifierName: r }),
          this.finishToken(128, r)
      }
      getTokenFromCode(e) {
        const r = this.input.charCodeAt(this.state.pos + 1)
        return e === 123 && r === 124
          ? this.finishOp(6, 2)
          : this.state.inType && (e === 62 || e === 60)
          ? this.finishOp(e === 62 ? 48 : 47, 1)
          : this.state.inType && e === 63
          ? r === 46
            ? this.finishOp(18, 2)
            : this.finishOp(17, 1)
          : Qz(e, r, this.input.charCodeAt(this.state.pos + 2))
          ? ((this.state.pos += 2), this.readIterator())
          : super.getTokenFromCode(e)
      }
      isAssignable(e, r) {
        return e.type === 'TypeCastExpression' ? this.isAssignable(e.expression, r) : super.isAssignable(e, r)
      }
      toAssignable(e, r = !1) {
        !r &&
          e.type === 'AssignmentExpression' &&
          e.left.type === 'TypeCastExpression' &&
          (e.left = this.typeCastToParameter(e.left)),
          super.toAssignable(...arguments)
      }
      toAssignableList(e, r, i) {
        for (let n = 0; n < e.length; n++) {
          const s = e[n]
          ;(s == null ? void 0 : s.type) === 'TypeCastExpression' && (e[n] = this.typeCastToParameter(s))
        }
        super.toAssignableList(e, r, i)
      }
      toReferencedList(e, r) {
        for (let n = 0; n < e.length; n++) {
          var i
          const s = e[n]
          s &&
            s.type === 'TypeCastExpression' &&
            !((i = s.extra) != null && i.parenthesized) &&
            (e.length > 1 || !r) &&
            this.raise(He.TypeCastInPattern, { at: s.typeAnnotation })
        }
        return e
      }
      parseArrayLike(e, r, i, n) {
        const s = super.parseArrayLike(e, r, i, n)
        return r && !this.state.maybeInArrowParameters && this.toReferencedList(s.elements), s
      }
      isValidLVal(e, ...r) {
        return e === 'TypeCastExpression' || super.isValidLVal(e, ...r)
      }
      parseClassProperty(e) {
        return this.match(14) && (e.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(e)
      }
      parseClassPrivateProperty(e) {
        return this.match(14) && (e.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(e)
      }
      isClassMethod() {
        return this.match(47) || super.isClassMethod()
      }
      isClassProperty() {
        return this.match(14) || super.isClassProperty()
      }
      isNonstaticConstructor(e) {
        return !this.match(14) && super.isNonstaticConstructor(e)
      }
      pushClassMethod(e, r, i, n, s, a) {
        if (
          (r.variance && this.unexpected(r.variance.loc.start),
          delete r.variance,
          this.match(47) && (r.typeParameters = this.flowParseTypeParameterDeclaration()),
          super.pushClassMethod(e, r, i, n, s, a),
          r.params && s)
        ) {
          const o = r.params
          o.length > 0 && this.isThisParam(o[0]) && this.raise(He.ThisParamBannedInConstructor, { at: r })
        } else if (r.type === 'MethodDefinition' && s && r.value.params) {
          const o = r.value.params
          o.length > 0 && this.isThisParam(o[0]) && this.raise(He.ThisParamBannedInConstructor, { at: r })
        }
      }
      pushClassPrivateMethod(e, r, i, n) {
        r.variance && this.unexpected(r.variance.loc.start),
          delete r.variance,
          this.match(47) && (r.typeParameters = this.flowParseTypeParameterDeclaration()),
          super.pushClassPrivateMethod(e, r, i, n)
      }
      parseClassSuper(e) {
        if (
          (super.parseClassSuper(e),
          e.superClass && this.match(47) && (e.superTypeParameters = this.flowParseTypeParameterInstantiation()),
          this.isContextual(110))
        ) {
          this.next()
          const r = (e.implements = [])
          do {
            const i = this.startNode()
            ;(i.id = this.flowParseRestrictedIdentifier(!0)),
              this.match(47)
                ? (i.typeParameters = this.flowParseTypeParameterInstantiation())
                : (i.typeParameters = null),
              r.push(this.finishNode(i, 'ClassImplements'))
          } while (this.eat(12))
        }
      }
      checkGetterSetterParams(e) {
        super.checkGetterSetterParams(e)
        const r = this.getObjectOrClassMethodParams(e)
        if (r.length > 0) {
          const i = r[0]
          this.isThisParam(i) && e.kind === 'get'
            ? this.raise(He.GetterMayNotHaveThisParam, { at: i })
            : this.isThisParam(i) && this.raise(He.SetterMayNotHaveThisParam, { at: i })
        }
      }
      parsePropertyNamePrefixOperator(e) {
        e.variance = this.flowParseVariance()
      }
      parseObjPropValue(e, r, i, n, s, a, o, u) {
        e.variance && this.unexpected(e.variance.loc.start), delete e.variance
        let c
        this.match(47) && !o && ((c = this.flowParseTypeParameterDeclaration()), this.match(10) || this.unexpected()),
          super.parseObjPropValue(e, r, i, n, s, a, o, u),
          c && ((e.value || e).typeParameters = c)
      }
      parseAssignableListItemTypes(e) {
        return (
          this.eat(17) &&
            (e.type !== 'Identifier' && this.raise(He.PatternIsOptional, { at: e }),
            this.isThisParam(e) && this.raise(He.ThisParamMayNotBeOptional, { at: e }),
            (e.optional = !0)),
          this.match(14)
            ? (e.typeAnnotation = this.flowParseTypeAnnotation())
            : this.isThisParam(e) && this.raise(He.ThisParamAnnotationRequired, { at: e }),
          this.match(29) && this.isThisParam(e) && this.raise(He.ThisParamNoDefault, { at: e }),
          this.resetEndLocation(e),
          e
        )
      }
      parseMaybeDefault(e, r, i) {
        const n = super.parseMaybeDefault(e, r, i)
        return (
          n.type === 'AssignmentPattern' &&
            n.typeAnnotation &&
            n.right.start < n.typeAnnotation.start &&
            this.raise(He.TypeBeforeInitializer, { at: n.typeAnnotation }),
          n
        )
      }
      shouldParseDefaultImport(e) {
        return qp(e) ? lg(this.state.type) : super.shouldParseDefaultImport(e)
      }
      parseImportSpecifierLocal(e, r, i) {
        ;(r.local = qp(e) ? this.flowParseRestrictedIdentifier(!0, !0) : this.parseIdentifier()),
          e.specifiers.push(this.finishImportSpecifier(r, i))
      }
      maybeParseDefaultImportSpecifier(e) {
        e.importKind = 'value'
        let r = null
        if ((this.match(87) ? (r = 'typeof') : this.isContextual(126) && (r = 'type'), r)) {
          const i = this.lookahead(),
            { type: n } = i
          r === 'type' && n === 55 && this.unexpected(null, i.type),
            (lg(n) || n === 5 || n === 55) && (this.next(), (e.importKind = r))
        }
        return super.maybeParseDefaultImportSpecifier(e)
      }
      parseImportSpecifier(e, r, i, n) {
        const s = e.imported
        let a = null
        s.type === 'Identifier' && (s.name === 'type' ? (a = 'type') : s.name === 'typeof' && (a = 'typeof'))
        let o = !1
        if (this.isContextual(93) && !this.isLookaheadContextual('as')) {
          const c = this.parseIdentifier(!0)
          a !== null && !ri(this.state.type)
            ? ((e.imported = c), (e.importKind = a), (e.local = li(c)))
            : ((e.imported = s), (e.importKind = null), (e.local = this.parseIdentifier()))
        } else {
          if (a !== null && ri(this.state.type)) (e.imported = this.parseIdentifier(!0)), (e.importKind = a)
          else {
            if (r) throw this.raise(re.ImportBindingIsString, { at: e, importName: s.value })
            ;(e.imported = s), (e.importKind = null)
          }
          this.eatContextual(93) ? (e.local = this.parseIdentifier()) : ((o = !0), (e.local = li(e.imported)))
        }
        const u = qp(e)
        return (
          i && u && this.raise(He.ImportTypeShorthandOnlyInPureImport, { at: e }),
          (i || u) && this.checkReservedType(e.local.name, e.local.loc.start, !0),
          o && !i && !u && this.checkReservedWord(e.local.name, e.loc.start, !0, !0),
          this.finishImportSpecifier(e, 'ImportSpecifier')
        )
      }
      parseBindingAtom() {
        switch (this.state.type) {
          case 78:
            return this.parseIdentifier(!0)
          default:
            return super.parseBindingAtom()
        }
      }
      parseFunctionParams(e, r) {
        const i = e.kind
        i !== 'get' && i !== 'set' && this.match(47) && (e.typeParameters = this.flowParseTypeParameterDeclaration()),
          super.parseFunctionParams(e, r)
      }
      parseVarId(e, r) {
        super.parseVarId(e, r),
          this.match(14) && ((e.id.typeAnnotation = this.flowParseTypeAnnotation()), this.resetEndLocation(e.id))
      }
      parseAsyncArrowFromCallExpression(e, r) {
        if (this.match(14)) {
          const i = this.state.noAnonFunctionType
          ;(this.state.noAnonFunctionType = !0),
            (e.returnType = this.flowParseTypeAnnotation()),
            (this.state.noAnonFunctionType = i)
        }
        return super.parseAsyncArrowFromCallExpression(e, r)
      }
      shouldParseAsyncArrow() {
        return this.match(14) || super.shouldParseAsyncArrow()
      }
      parseMaybeAssign(e, r) {
        var i
        let n = null,
          s
        if (this.hasPlugin('jsx') && (this.match(138) || this.match(47))) {
          if (((n = this.state.clone()), (s = this.tryParse(() => super.parseMaybeAssign(e, r), n)), !s.error))
            return s.node
          const { context: u } = this.state,
            c = u[u.length - 1]
          ;(c === Tt.j_oTag || c === Tt.j_expr) && u.pop()
        }
        if (((i = s) != null && i.error) || this.match(47)) {
          var a, o
          n = n || this.state.clone()
          let u
          const c = this.tryParse((h) => {
            var f
            u = this.flowParseTypeParameterDeclaration()
            const d = this.forwardNoArrowParamsConversionAt(u, () => {
              const y = super.parseMaybeAssign(e, r)
              return this.resetStartLocationFromNode(y, u), y
            })
            ;(f = d.extra) != null && f.parenthesized && h()
            const T = this.maybeUnwrapTypeCastExpression(d)
            return (
              T.type !== 'ArrowFunctionExpression' && h(),
              (T.typeParameters = u),
              this.resetStartLocationFromNode(T, u),
              d
            )
          }, n)
          let p = null
          if (c.node && this.maybeUnwrapTypeCastExpression(c.node).type === 'ArrowFunctionExpression') {
            if (!c.error && !c.aborted)
              return c.node.async && this.raise(He.UnexpectedTypeParameterBeforeAsyncArrowFunction, { at: u }), c.node
            p = c.node
          }
          if ((a = s) != null && a.node) return (this.state = s.failState), s.node
          if (p) return (this.state = c.failState), p
          throw (o = s) != null && o.thrown
            ? s.error
            : c.thrown
            ? c.error
            : this.raise(He.UnexpectedTokenAfterTypeParameter, { at: u })
        }
        return super.parseMaybeAssign(e, r)
      }
      parseArrow(e) {
        if (this.match(14)) {
          const r = this.tryParse(() => {
            const i = this.state.noAnonFunctionType
            this.state.noAnonFunctionType = !0
            const n = this.startNode()
            return (
              ([n.typeAnnotation, e.predicate] = this.flowParseTypeAndPredicateInitialiser()),
              (this.state.noAnonFunctionType = i),
              this.canInsertSemicolon() && this.unexpected(),
              this.match(19) || this.unexpected(),
              n
            )
          })
          if (r.thrown) return null
          r.error && (this.state = r.failState),
            (e.returnType = r.node.typeAnnotation ? this.finishNode(r.node, 'TypeAnnotation') : null)
        }
        return super.parseArrow(e)
      }
      shouldParseArrow(e) {
        return this.match(14) || super.shouldParseArrow(e)
      }
      setArrowFunctionParameters(e, r) {
        this.state.noArrowParamsConversionAt.indexOf(e.start) !== -1
          ? (e.params = r)
          : super.setArrowFunctionParameters(e, r)
      }
      checkParams(e, r, i) {
        if (!(i && this.state.noArrowParamsConversionAt.indexOf(e.start) !== -1)) {
          for (let n = 0; n < e.params.length; n++)
            this.isThisParam(e.params[n]) && n > 0 && this.raise(He.ThisParamMustBeFirst, { at: e.params[n] })
          return super.checkParams(...arguments)
        }
      }
      parseParenAndDistinguishExpression(e) {
        return super.parseParenAndDistinguishExpression(e && this.state.noArrowAt.indexOf(this.state.start) === -1)
      }
      parseSubscripts(e, r, i, n) {
        if (e.type === 'Identifier' && e.name === 'async' && this.state.noArrowAt.indexOf(r) !== -1) {
          this.next()
          const s = this.startNodeAt(r, i)
          ;(s.callee = e),
            (s.arguments = this.parseCallExpressionArguments(11, !1)),
            (e = this.finishNode(s, 'CallExpression'))
        } else if (e.type === 'Identifier' && e.name === 'async' && this.match(47)) {
          const s = this.state.clone(),
            a = this.tryParse((u) => this.parseAsyncArrowWithTypeParameters(r, i) || u(), s)
          if (!a.error && !a.aborted) return a.node
          const o = this.tryParse(() => super.parseSubscripts(e, r, i, n), s)
          if (o.node && !o.error) return o.node
          if (a.node) return (this.state = a.failState), a.node
          if (o.node) return (this.state = o.failState), o.node
          throw a.error || o.error
        }
        return super.parseSubscripts(e, r, i, n)
      }
      parseSubscript(e, r, i, n, s) {
        if (this.match(18) && this.isLookaheadToken_lt()) {
          if (((s.optionalChainMember = !0), n)) return (s.stop = !0), e
          this.next()
          const a = this.startNodeAt(r, i)
          return (
            (a.callee = e),
            (a.typeArguments = this.flowParseTypeParameterInstantiation()),
            this.expect(10),
            (a.arguments = this.parseCallExpressionArguments(11, !1)),
            (a.optional = !0),
            this.finishCallExpression(a, !0)
          )
        } else if (!n && this.shouldParseTypes() && this.match(47)) {
          const a = this.startNodeAt(r, i)
          a.callee = e
          const o = this.tryParse(
            () => (
              (a.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew()),
              this.expect(10),
              (a.arguments = this.parseCallExpressionArguments(11, !1)),
              s.optionalChainMember && (a.optional = !1),
              this.finishCallExpression(a, s.optionalChainMember)
            )
          )
          if (o.node) return o.error && (this.state = o.failState), o.node
        }
        return super.parseSubscript(e, r, i, n, s)
      }
      parseNewCallee(e) {
        super.parseNewCallee(e)
        let r = null
        this.shouldParseTypes() &&
          this.match(47) &&
          (r = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node),
          (e.typeArguments = r)
      }
      parseAsyncArrowWithTypeParameters(e, r) {
        const i = this.startNodeAt(e, r)
        if ((this.parseFunctionParams(i), !!this.parseArrow(i))) return this.parseArrowExpression(i, void 0, !0)
      }
      readToken_mult_modulo(e) {
        const r = this.input.charCodeAt(this.state.pos + 1)
        if (e === 42 && r === 47 && this.state.hasFlowComment) {
          ;(this.state.hasFlowComment = !1), (this.state.pos += 2), this.nextToken()
          return
        }
        super.readToken_mult_modulo(e)
      }
      readToken_pipe_amp(e) {
        const r = this.input.charCodeAt(this.state.pos + 1)
        if (e === 124 && r === 125) {
          this.finishOp(9, 2)
          return
        }
        super.readToken_pipe_amp(e)
      }
      parseTopLevel(e, r) {
        const i = super.parseTopLevel(e, r)
        return this.state.hasFlowComment && this.raise(He.UnterminatedFlowComment, { at: this.state.curPosition() }), i
      }
      skipBlockComment() {
        if (this.hasPlugin('flowComments') && this.skipFlowComment()) {
          if (this.state.hasFlowComment) throw this.raise(He.NestedFlowComment, { at: this.state.startLoc })
          this.hasFlowCommentCompletion(), (this.state.pos += this.skipFlowComment()), (this.state.hasFlowComment = !0)
          return
        }
        if (this.state.hasFlowComment) {
          const e = this.input.indexOf('*-/', this.state.pos + 2)
          if (e === -1) throw this.raise(re.UnterminatedComment, { at: this.state.curPosition() })
          this.state.pos = e + 2 + 3
          return
        }
        return super.skipBlockComment()
      }
      skipFlowComment() {
        const { pos: e } = this.state
        let r = 2
        for (; [32, 9].includes(this.input.charCodeAt(e + r)); ) r++
        const i = this.input.charCodeAt(r + e),
          n = this.input.charCodeAt(r + e + 1)
        return i === 58 && n === 58
          ? r + 2
          : this.input.slice(r + e, r + e + 12) === 'flow-include'
          ? r + 12
          : i === 58 && n !== 58
          ? r
          : !1
      }
      hasFlowCommentCompletion() {
        if (this.input.indexOf('*/', this.state.pos) === -1)
          throw this.raise(re.UnterminatedComment, { at: this.state.curPosition() })
      }
      flowEnumErrorBooleanMemberNotInitialized(e, { enumName: r, memberName: i }) {
        this.raise(He.EnumBooleanMemberNotInitialized, { at: e, memberName: i, enumName: r })
      }
      flowEnumErrorInvalidMemberInitializer(e, r) {
        return this.raise(
          r.explicitType
            ? r.explicitType === 'symbol'
              ? He.EnumInvalidMemberInitializerSymbolType
              : He.EnumInvalidMemberInitializerPrimaryType
            : He.EnumInvalidMemberInitializerUnknownType,
          Object.assign({ at: e }, r)
        )
      }
      flowEnumErrorNumberMemberNotInitialized(e, { enumName: r, memberName: i }) {
        this.raise(He.EnumNumberMemberNotInitialized, { at: e, enumName: r, memberName: i })
      }
      flowEnumErrorStringMemberInconsistentlyInitailized(e, { enumName: r }) {
        this.raise(He.EnumStringMemberInconsistentlyInitailized, { at: e, enumName: r })
      }
      flowEnumMemberInit() {
        const e = this.state.startLoc,
          r = () => this.match(12) || this.match(8)
        switch (this.state.type) {
          case 130: {
            const i = this.parseNumericLiteral(this.state.value)
            return r() ? { type: 'number', loc: i.loc.start, value: i } : { type: 'invalid', loc: e }
          }
          case 129: {
            const i = this.parseStringLiteral(this.state.value)
            return r() ? { type: 'string', loc: i.loc.start, value: i } : { type: 'invalid', loc: e }
          }
          case 85:
          case 86: {
            const i = this.parseBooleanLiteral(this.match(85))
            return r() ? { type: 'boolean', loc: i.loc.start, value: i } : { type: 'invalid', loc: e }
          }
          default:
            return { type: 'invalid', loc: e }
        }
      }
      flowEnumMemberRaw() {
        const e = this.state.startLoc,
          r = this.parseIdentifier(!0),
          i = this.eat(29) ? this.flowEnumMemberInit() : { type: 'none', loc: e }
        return { id: r, init: i }
      }
      flowEnumCheckExplicitTypeMismatch(e, r, i) {
        const { explicitType: n } = r
        n !== null && n !== i && this.flowEnumErrorInvalidMemberInitializer(e, r)
      }
      flowEnumMembers({ enumName: e, explicitType: r }) {
        const i = new Set(),
          n = { booleanMembers: [], numberMembers: [], stringMembers: [], defaultedMembers: [] }
        let s = !1
        for (; !this.match(8); ) {
          if (this.eat(21)) {
            s = !0
            break
          }
          const a = this.startNode(),
            { id: o, init: u } = this.flowEnumMemberRaw(),
            c = o.name
          if (c === '') continue
          ;/^[a-z]/.test(c) &&
            this.raise(He.EnumInvalidMemberName, {
              at: o,
              memberName: c,
              suggestion: c[0].toUpperCase() + c.slice(1),
              enumName: e,
            }),
            i.has(c) && this.raise(He.EnumDuplicateMemberName, { at: o, memberName: c, enumName: e }),
            i.add(c)
          const p = { enumName: e, explicitType: r, memberName: c }
          switch (((a.id = o), u.type)) {
            case 'boolean': {
              this.flowEnumCheckExplicitTypeMismatch(u.loc, p, 'boolean'),
                (a.init = u.value),
                n.booleanMembers.push(this.finishNode(a, 'EnumBooleanMember'))
              break
            }
            case 'number': {
              this.flowEnumCheckExplicitTypeMismatch(u.loc, p, 'number'),
                (a.init = u.value),
                n.numberMembers.push(this.finishNode(a, 'EnumNumberMember'))
              break
            }
            case 'string': {
              this.flowEnumCheckExplicitTypeMismatch(u.loc, p, 'string'),
                (a.init = u.value),
                n.stringMembers.push(this.finishNode(a, 'EnumStringMember'))
              break
            }
            case 'invalid':
              throw this.flowEnumErrorInvalidMemberInitializer(u.loc, p)
            case 'none':
              switch (r) {
                case 'boolean':
                  this.flowEnumErrorBooleanMemberNotInitialized(u.loc, p)
                  break
                case 'number':
                  this.flowEnumErrorNumberMemberNotInitialized(u.loc, p)
                  break
                default:
                  n.defaultedMembers.push(this.finishNode(a, 'EnumDefaultedMember'))
              }
          }
          this.match(8) || this.expect(12)
        }
        return { members: n, hasUnknownMembers: s }
      }
      flowEnumStringMembers(e, r, { enumName: i }) {
        if (e.length === 0) return r
        if (r.length === 0) return e
        if (r.length > e.length) {
          for (const n of e) this.flowEnumErrorStringMemberInconsistentlyInitailized(n, { enumName: i })
          return r
        } else {
          for (const n of r) this.flowEnumErrorStringMemberInconsistentlyInitailized(n, { enumName: i })
          return e
        }
      }
      flowEnumParseExplicitType({ enumName: e }) {
        if (!this.eatContextual(101)) return null
        if (!mt(this.state.type))
          throw this.raise(He.EnumInvalidExplicitTypeUnknownSupplied, { at: this.state.startLoc, enumName: e })
        const { value: r } = this.state
        return (
          this.next(),
          r !== 'boolean' &&
            r !== 'number' &&
            r !== 'string' &&
            r !== 'symbol' &&
            this.raise(He.EnumInvalidExplicitType, { at: this.state.startLoc, enumName: e, invalidEnumType: r }),
          r
        )
      }
      flowEnumBody(e, r) {
        const i = r.name,
          n = r.loc.start,
          s = this.flowEnumParseExplicitType({ enumName: i })
        this.expect(5)
        const { members: a, hasUnknownMembers: o } = this.flowEnumMembers({ enumName: i, explicitType: s })
        switch (((e.hasUnknownMembers = o), s)) {
          case 'boolean':
            return (
              (e.explicitType = !0),
              (e.members = a.booleanMembers),
              this.expect(8),
              this.finishNode(e, 'EnumBooleanBody')
            )
          case 'number':
            return (
              (e.explicitType = !0), (e.members = a.numberMembers), this.expect(8), this.finishNode(e, 'EnumNumberBody')
            )
          case 'string':
            return (
              (e.explicitType = !0),
              (e.members = this.flowEnumStringMembers(a.stringMembers, a.defaultedMembers, { enumName: i })),
              this.expect(8),
              this.finishNode(e, 'EnumStringBody')
            )
          case 'symbol':
            return (e.members = a.defaultedMembers), this.expect(8), this.finishNode(e, 'EnumSymbolBody')
          default: {
            const u = () => ((e.members = []), this.expect(8), this.finishNode(e, 'EnumStringBody'))
            e.explicitType = !1
            const c = a.booleanMembers.length,
              p = a.numberMembers.length,
              h = a.stringMembers.length,
              f = a.defaultedMembers.length
            if (!c && !p && !h && !f) return u()
            if (!c && !p)
              return (
                (e.members = this.flowEnumStringMembers(a.stringMembers, a.defaultedMembers, { enumName: i })),
                this.expect(8),
                this.finishNode(e, 'EnumStringBody')
              )
            if (!p && !h && c >= f) {
              for (const d of a.defaultedMembers)
                this.flowEnumErrorBooleanMemberNotInitialized(d.loc.start, { enumName: i, memberName: d.id.name })
              return (e.members = a.booleanMembers), this.expect(8), this.finishNode(e, 'EnumBooleanBody')
            } else if (!c && !h && p >= f) {
              for (const d of a.defaultedMembers)
                this.flowEnumErrorNumberMemberNotInitialized(d.loc.start, { enumName: i, memberName: d.id.name })
              return (e.members = a.numberMembers), this.expect(8), this.finishNode(e, 'EnumNumberBody')
            } else return this.raise(He.EnumInconsistentMemberValues, { at: n, enumName: i }), u()
          }
        }
      }
      flowParseEnumDeclaration(e) {
        const r = this.parseIdentifier()
        return (e.id = r), (e.body = this.flowEnumBody(this.startNode(), r)), this.finishNode(e, 'EnumDeclaration')
      }
      isLookaheadToken_lt() {
        const e = this.nextTokenStart()
        if (this.input.charCodeAt(e) === 60) {
          const r = this.input.charCodeAt(e + 1)
          return r !== 60 && r !== 61
        }
        return !1
      }
      maybeUnwrapTypeCastExpression(e) {
        return e.type === 'TypeCastExpression' ? e.expression : e
      }
    }
  const UK = {
      __proto__: null,
      quot: '"',
      amp: '&',
      apos: "'",
      lt: '<',
      gt: '>',
      nbsp: '\xA0',
      iexcl: '\xA1',
      cent: '\xA2',
      pound: '\xA3',
      curren: '\xA4',
      yen: '\xA5',
      brvbar: '\xA6',
      sect: '\xA7',
      uml: '\xA8',
      copy: '\xA9',
      ordf: '\xAA',
      laquo: '\xAB',
      not: '\xAC',
      shy: '\xAD',
      reg: '\xAE',
      macr: '\xAF',
      deg: '\xB0',
      plusmn: '\xB1',
      sup2: '\xB2',
      sup3: '\xB3',
      acute: '\xB4',
      micro: '\xB5',
      para: '\xB6',
      middot: '\xB7',
      cedil: '\xB8',
      sup1: '\xB9',
      ordm: '\xBA',
      raquo: '\xBB',
      frac14: '\xBC',
      frac12: '\xBD',
      frac34: '\xBE',
      iquest: '\xBF',
      Agrave: '\xC0',
      Aacute: '\xC1',
      Acirc: '\xC2',
      Atilde: '\xC3',
      Auml: '\xC4',
      Aring: '\xC5',
      AElig: '\xC6',
      Ccedil: '\xC7',
      Egrave: '\xC8',
      Eacute: '\xC9',
      Ecirc: '\xCA',
      Euml: '\xCB',
      Igrave: '\xCC',
      Iacute: '\xCD',
      Icirc: '\xCE',
      Iuml: '\xCF',
      ETH: '\xD0',
      Ntilde: '\xD1',
      Ograve: '\xD2',
      Oacute: '\xD3',
      Ocirc: '\xD4',
      Otilde: '\xD5',
      Ouml: '\xD6',
      times: '\xD7',
      Oslash: '\xD8',
      Ugrave: '\xD9',
      Uacute: '\xDA',
      Ucirc: '\xDB',
      Uuml: '\xDC',
      Yacute: '\xDD',
      THORN: '\xDE',
      szlig: '\xDF',
      agrave: '\xE0',
      aacute: '\xE1',
      acirc: '\xE2',
      atilde: '\xE3',
      auml: '\xE4',
      aring: '\xE5',
      aelig: '\xE6',
      ccedil: '\xE7',
      egrave: '\xE8',
      eacute: '\xE9',
      ecirc: '\xEA',
      euml: '\xEB',
      igrave: '\xEC',
      iacute: '\xED',
      icirc: '\xEE',
      iuml: '\xEF',
      eth: '\xF0',
      ntilde: '\xF1',
      ograve: '\xF2',
      oacute: '\xF3',
      ocirc: '\xF4',
      otilde: '\xF5',
      ouml: '\xF6',
      divide: '\xF7',
      oslash: '\xF8',
      ugrave: '\xF9',
      uacute: '\xFA',
      ucirc: '\xFB',
      uuml: '\xFC',
      yacute: '\xFD',
      thorn: '\xFE',
      yuml: '\xFF',
      OElig: '\u0152',
      oelig: '\u0153',
      Scaron: '\u0160',
      scaron: '\u0161',
      Yuml: '\u0178',
      fnof: '\u0192',
      circ: '\u02C6',
      tilde: '\u02DC',
      Alpha: '\u0391',
      Beta: '\u0392',
      Gamma: '\u0393',
      Delta: '\u0394',
      Epsilon: '\u0395',
      Zeta: '\u0396',
      Eta: '\u0397',
      Theta: '\u0398',
      Iota: '\u0399',
      Kappa: '\u039A',
      Lambda: '\u039B',
      Mu: '\u039C',
      Nu: '\u039D',
      Xi: '\u039E',
      Omicron: '\u039F',
      Pi: '\u03A0',
      Rho: '\u03A1',
      Sigma: '\u03A3',
      Tau: '\u03A4',
      Upsilon: '\u03A5',
      Phi: '\u03A6',
      Chi: '\u03A7',
      Psi: '\u03A8',
      Omega: '\u03A9',
      alpha: '\u03B1',
      beta: '\u03B2',
      gamma: '\u03B3',
      delta: '\u03B4',
      epsilon: '\u03B5',
      zeta: '\u03B6',
      eta: '\u03B7',
      theta: '\u03B8',
      iota: '\u03B9',
      kappa: '\u03BA',
      lambda: '\u03BB',
      mu: '\u03BC',
      nu: '\u03BD',
      xi: '\u03BE',
      omicron: '\u03BF',
      pi: '\u03C0',
      rho: '\u03C1',
      sigmaf: '\u03C2',
      sigma: '\u03C3',
      tau: '\u03C4',
      upsilon: '\u03C5',
      phi: '\u03C6',
      chi: '\u03C7',
      psi: '\u03C8',
      omega: '\u03C9',
      thetasym: '\u03D1',
      upsih: '\u03D2',
      piv: '\u03D6',
      ensp: '\u2002',
      emsp: '\u2003',
      thinsp: '\u2009',
      zwnj: '\u200C',
      zwj: '\u200D',
      lrm: '\u200E',
      rlm: '\u200F',
      ndash: '\u2013',
      mdash: '\u2014',
      lsquo: '\u2018',
      rsquo: '\u2019',
      sbquo: '\u201A',
      ldquo: '\u201C',
      rdquo: '\u201D',
      bdquo: '\u201E',
      dagger: '\u2020',
      Dagger: '\u2021',
      bull: '\u2022',
      hellip: '\u2026',
      permil: '\u2030',
      prime: '\u2032',
      Prime: '\u2033',
      lsaquo: '\u2039',
      rsaquo: '\u203A',
      oline: '\u203E',
      frasl: '\u2044',
      euro: '\u20AC',
      image: '\u2111',
      weierp: '\u2118',
      real: '\u211C',
      trade: '\u2122',
      alefsym: '\u2135',
      larr: '\u2190',
      uarr: '\u2191',
      rarr: '\u2192',
      darr: '\u2193',
      harr: '\u2194',
      crarr: '\u21B5',
      lArr: '\u21D0',
      uArr: '\u21D1',
      rArr: '\u21D2',
      dArr: '\u21D3',
      hArr: '\u21D4',
      forall: '\u2200',
      part: '\u2202',
      exist: '\u2203',
      empty: '\u2205',
      nabla: '\u2207',
      isin: '\u2208',
      notin: '\u2209',
      ni: '\u220B',
      prod: '\u220F',
      sum: '\u2211',
      minus: '\u2212',
      lowast: '\u2217',
      radic: '\u221A',
      prop: '\u221D',
      infin: '\u221E',
      ang: '\u2220',
      and: '\u2227',
      or: '\u2228',
      cap: '\u2229',
      cup: '\u222A',
      int: '\u222B',
      there4: '\u2234',
      sim: '\u223C',
      cong: '\u2245',
      asymp: '\u2248',
      ne: '\u2260',
      equiv: '\u2261',
      le: '\u2264',
      ge: '\u2265',
      sub: '\u2282',
      sup: '\u2283',
      nsub: '\u2284',
      sube: '\u2286',
      supe: '\u2287',
      oplus: '\u2295',
      otimes: '\u2297',
      perp: '\u22A5',
      sdot: '\u22C5',
      lceil: '\u2308',
      rceil: '\u2309',
      lfloor: '\u230A',
      rfloor: '\u230B',
      lang: '\u2329',
      rang: '\u232A',
      loz: '\u25CA',
      spades: '\u2660',
      clubs: '\u2663',
      hearts: '\u2665',
      diams: '\u2666',
    },
    fn = ei`jsx`((t) => ({
      AttributeIsEmpty: t('JSX attributes must only be assigned a non-empty expression.'),
      MissingClosingTagElement: t(({ openingTagName: e }) => `Expected corresponding JSX closing tag for <${e}>.`),
      MissingClosingTagFragment: t('Expected corresponding JSX closing tag for <>.'),
      UnexpectedSequenceExpression: t(
        'Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?'
      ),
      UnexpectedToken: t(
        ({ unexpected: e, HTMLEntity: r }) => `Unexpected token \`${e}\`. Did you mean \`${r}\` or \`{'${e}'}\`?`
      ),
      UnsupportedJsxValue: t('JSX value should be either an expression or a quoted JSX text.'),
      UnterminatedJsxContent: t('Unterminated JSX contents.'),
      UnwrappedAdjacentJSXElements: t(
        'Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?'
      ),
    }))
  function Ai(t) {
    return t ? t.type === 'JSXOpeningFragment' || t.type === 'JSXClosingFragment' : !1
  }
  function Un(t) {
    if (t.type === 'JSXIdentifier') return t.name
    if (t.type === 'JSXNamespacedName') return t.namespace.name + ':' + t.name.name
    if (t.type === 'JSXMemberExpression') return Un(t.object) + '.' + Un(t.property)
    throw new Error('Node had unexpected type: ' + t.type)
  }
  var zK = (t) =>
    class extends t {
      jsxReadToken() {
        let e = '',
          r = this.state.pos
        for (;;) {
          if (this.state.pos >= this.length) throw this.raise(fn.UnterminatedJsxContent, { at: this.state.startLoc })
          const i = this.input.charCodeAt(this.state.pos)
          switch (i) {
            case 60:
            case 123:
              return this.state.pos === this.state.start
                ? i === 60 && this.state.canStartJSXElement
                  ? (++this.state.pos, this.finishToken(138))
                  : super.getTokenFromCode(i)
                : ((e += this.input.slice(r, this.state.pos)), this.finishToken(137, e))
            case 38:
              ;(e += this.input.slice(r, this.state.pos)), (e += this.jsxReadEntity()), (r = this.state.pos)
              break
            case 62:
            case 125:
            default:
              pn(i)
                ? ((e += this.input.slice(r, this.state.pos)), (e += this.jsxReadNewLine(!0)), (r = this.state.pos))
                : ++this.state.pos
          }
        }
      }
      jsxReadNewLine(e) {
        const r = this.input.charCodeAt(this.state.pos)
        let i
        return (
          ++this.state.pos,
          r === 13 && this.input.charCodeAt(this.state.pos) === 10
            ? (++this.state.pos,
              (i = e
                ? `
`
                : `\r
`))
            : (i = String.fromCharCode(r)),
          ++this.state.curLine,
          (this.state.lineStart = this.state.pos),
          i
        )
      }
      jsxReadString(e) {
        let r = '',
          i = ++this.state.pos
        for (;;) {
          if (this.state.pos >= this.length) throw this.raise(re.UnterminatedString, { at: this.state.startLoc })
          const n = this.input.charCodeAt(this.state.pos)
          if (n === e) break
          n === 38
            ? ((r += this.input.slice(i, this.state.pos)), (r += this.jsxReadEntity()), (i = this.state.pos))
            : pn(n)
            ? ((r += this.input.slice(i, this.state.pos)), (r += this.jsxReadNewLine(!1)), (i = this.state.pos))
            : ++this.state.pos
        }
        return (r += this.input.slice(i, this.state.pos++)), this.finishToken(129, r)
      }
      jsxReadEntity() {
        const e = ++this.state.pos
        if (this.codePointAtPos(this.state.pos) === 35) {
          ++this.state.pos
          let r = 10
          this.codePointAtPos(this.state.pos) === 120 && ((r = 16), ++this.state.pos)
          const i = this.readInt(r, void 0, !1, 'bail')
          if (i !== null && this.codePointAtPos(this.state.pos) === 59) return ++this.state.pos, String.fromCodePoint(i)
        } else {
          let r = 0,
            i = !1
          for (; r++ < 10 && this.state.pos < this.length && !(i = this.codePointAtPos(this.state.pos) == 59); )
            ++this.state.pos
          if (i) {
            const n = this.input.slice(e, this.state.pos),
              s = UK[n]
            if ((++this.state.pos, s)) return s
          }
        }
        return (this.state.pos = e), '&'
      }
      jsxReadWord() {
        let e
        const r = this.state.pos
        do e = this.input.charCodeAt(++this.state.pos)
        while ($n(e) || e === 45)
        return this.finishToken(136, this.input.slice(r, this.state.pos))
      }
      jsxParseIdentifier() {
        const e = this.startNode()
        return (
          this.match(136)
            ? (e.name = this.state.value)
            : xp(this.state.type)
            ? (e.name = Ei(this.state.type))
            : this.unexpected(),
          this.next(),
          this.finishNode(e, 'JSXIdentifier')
        )
      }
      jsxParseNamespacedName() {
        const e = this.state.start,
          r = this.state.startLoc,
          i = this.jsxParseIdentifier()
        if (!this.eat(14)) return i
        const n = this.startNodeAt(e, r)
        return (n.namespace = i), (n.name = this.jsxParseIdentifier()), this.finishNode(n, 'JSXNamespacedName')
      }
      jsxParseElementName() {
        const e = this.state.start,
          r = this.state.startLoc
        let i = this.jsxParseNamespacedName()
        if (i.type === 'JSXNamespacedName') return i
        for (; this.eat(16); ) {
          const n = this.startNodeAt(e, r)
          ;(n.object = i), (n.property = this.jsxParseIdentifier()), (i = this.finishNode(n, 'JSXMemberExpression'))
        }
        return i
      }
      jsxParseAttributeValue() {
        let e
        switch (this.state.type) {
          case 5:
            return (
              (e = this.startNode()),
              this.setContext(Tt.brace),
              this.next(),
              (e = this.jsxParseExpressionContainer(e, Tt.j_oTag)),
              e.expression.type === 'JSXEmptyExpression' && this.raise(fn.AttributeIsEmpty, { at: e }),
              e
            )
          case 138:
          case 129:
            return this.parseExprAtom()
          default:
            throw this.raise(fn.UnsupportedJsxValue, { at: this.state.startLoc })
        }
      }
      jsxParseEmptyExpression() {
        const e = this.startNodeAt(this.state.lastTokEndLoc.index, this.state.lastTokEndLoc)
        return this.finishNodeAt(e, 'JSXEmptyExpression', this.state.startLoc)
      }
      jsxParseSpreadChild(e) {
        return (
          this.next(),
          (e.expression = this.parseExpression()),
          this.setContext(Tt.j_oTag),
          (this.state.canStartJSXElement = !0),
          this.expect(8),
          this.finishNode(e, 'JSXSpreadChild')
        )
      }
      jsxParseExpressionContainer(e, r) {
        if (this.match(8)) e.expression = this.jsxParseEmptyExpression()
        else {
          const i = this.parseExpression()
          e.expression = i
        }
        return (
          this.setContext(r),
          (this.state.canStartJSXElement = !0),
          this.expect(8),
          this.finishNode(e, 'JSXExpressionContainer')
        )
      }
      jsxParseAttribute() {
        const e = this.startNode()
        return this.match(5)
          ? (this.setContext(Tt.brace),
            this.next(),
            this.expect(21),
            (e.argument = this.parseMaybeAssignAllowIn()),
            this.setContext(Tt.j_oTag),
            (this.state.canStartJSXElement = !0),
            this.expect(8),
            this.finishNode(e, 'JSXSpreadAttribute'))
          : ((e.name = this.jsxParseNamespacedName()),
            (e.value = this.eat(29) ? this.jsxParseAttributeValue() : null),
            this.finishNode(e, 'JSXAttribute'))
      }
      jsxParseOpeningElementAt(e, r) {
        const i = this.startNodeAt(e, r)
        return this.eat(139)
          ? this.finishNode(i, 'JSXOpeningFragment')
          : ((i.name = this.jsxParseElementName()), this.jsxParseOpeningElementAfterName(i))
      }
      jsxParseOpeningElementAfterName(e) {
        const r = []
        for (; !this.match(56) && !this.match(139); ) r.push(this.jsxParseAttribute())
        return (
          (e.attributes = r), (e.selfClosing = this.eat(56)), this.expect(139), this.finishNode(e, 'JSXOpeningElement')
        )
      }
      jsxParseClosingElementAt(e, r) {
        const i = this.startNodeAt(e, r)
        return this.eat(139)
          ? this.finishNode(i, 'JSXClosingFragment')
          : ((i.name = this.jsxParseElementName()), this.expect(139), this.finishNode(i, 'JSXClosingElement'))
      }
      jsxParseElementAt(e, r) {
        const i = this.startNodeAt(e, r),
          n = [],
          s = this.jsxParseOpeningElementAt(e, r)
        let a = null
        if (!s.selfClosing) {
          e: for (;;)
            switch (this.state.type) {
              case 138:
                if (((e = this.state.start), (r = this.state.startLoc), this.next(), this.eat(56))) {
                  a = this.jsxParseClosingElementAt(e, r)
                  break e
                }
                n.push(this.jsxParseElementAt(e, r))
                break
              case 137:
                n.push(this.parseExprAtom())
                break
              case 5: {
                const o = this.startNode()
                this.setContext(Tt.brace),
                  this.next(),
                  this.match(21)
                    ? n.push(this.jsxParseSpreadChild(o))
                    : n.push(this.jsxParseExpressionContainer(o, Tt.j_expr))
                break
              }
              default:
                throw this.unexpected()
            }
          Ai(s) && !Ai(a) && a !== null
            ? this.raise(fn.MissingClosingTagFragment, { at: a })
            : !Ai(s) && Ai(a)
            ? this.raise(fn.MissingClosingTagElement, { at: a, openingTagName: Un(s.name) })
            : !Ai(s) &&
              !Ai(a) &&
              Un(a.name) !== Un(s.name) &&
              this.raise(fn.MissingClosingTagElement, { at: a, openingTagName: Un(s.name) })
        }
        if (
          (Ai(s)
            ? ((i.openingFragment = s), (i.closingFragment = a))
            : ((i.openingElement = s), (i.closingElement = a)),
          (i.children = n),
          this.match(47))
        )
          throw this.raise(fn.UnwrappedAdjacentJSXElements, { at: this.state.startLoc })
        return Ai(s) ? this.finishNode(i, 'JSXFragment') : this.finishNode(i, 'JSXElement')
      }
      jsxParseElement() {
        const e = this.state.start,
          r = this.state.startLoc
        return this.next(), this.jsxParseElementAt(e, r)
      }
      setContext(e) {
        const { context: r } = this.state
        r[r.length - 1] = e
      }
      parseExprAtom(e) {
        return this.match(137)
          ? this.parseLiteral(this.state.value, 'JSXText')
          : this.match(138)
          ? this.jsxParseElement()
          : this.match(47) && this.input.charCodeAt(this.state.pos) !== 33
          ? (this.replaceToken(138), this.jsxParseElement())
          : super.parseExprAtom(e)
      }
      skipSpace() {
        this.curContext().preserveSpace || super.skipSpace()
      }
      getTokenFromCode(e) {
        const r = this.curContext()
        if (r === Tt.j_expr) return this.jsxReadToken()
        if (r === Tt.j_oTag || r === Tt.j_cTag) {
          if (ni(e)) return this.jsxReadWord()
          if (e === 62) return ++this.state.pos, this.finishToken(139)
          if ((e === 34 || e === 39) && r === Tt.j_oTag) return this.jsxReadString(e)
        }
        return e === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33
          ? (++this.state.pos, this.finishToken(138))
          : super.getTokenFromCode(e)
      }
      updateContext(e) {
        const { context: r, type: i } = this.state
        if (i === 56 && e === 138) r.splice(-2, 2, Tt.j_cTag), (this.state.canStartJSXElement = !1)
        else if (i === 138) r.push(Tt.j_oTag)
        else if (i === 139) {
          const n = r[r.length - 1]
          ;(n === Tt.j_oTag && e === 56) || n === Tt.j_cTag
            ? (r.pop(), (this.state.canStartJSXElement = r[r.length - 1] === Tt.j_expr))
            : (this.setContext(Tt.j_expr), (this.state.canStartJSXElement = !0))
        } else this.state.canStartJSXElement = Fz(i)
      }
    }
  class KK extends Kp {
    constructor(...e) {
      super(...e),
        (this.types = new Set()),
        (this.enums = new Set()),
        (this.constEnums = new Set()),
        (this.classes = new Set()),
        (this.exportOnlyBindings = new Set())
    }
  }
  class WK extends Wp {
    createScope(e) {
      return new KK(e)
    }
    declareName(e, r, i) {
      const n = this.currentScope()
      if (r & Mp) {
        this.maybeExportDefined(n, e), n.exportOnlyBindings.add(e)
        return
      }
      super.declareName(...arguments),
        r & jn &&
          (r & ai || (this.checkRedeclarationInScope(n, e, r, i), this.maybeExportDefined(n, e)), n.types.add(e)),
        r & Bp && n.enums.add(e),
        r & Lp && n.constEnums.add(e),
        r & qo && n.classes.add(e)
    }
    isRedeclaredInScope(e, r, i) {
      if (e.enums.has(r)) {
        if (i & Bp) {
          const n = !!(i & Lp),
            s = e.constEnums.has(r)
          return n !== s
        }
        return !0
      }
      return i & qo && e.classes.has(r)
        ? e.lexical.has(r)
          ? !!(i & ai)
          : !1
        : i & jn && e.types.has(r)
        ? !0
        : super.isRedeclaredInScope(...arguments)
    }
    checkLocalExport(e) {
      const r = this.scopeStack[0],
        { name: i } = e
      !r.types.has(i) && !r.exportOnlyBindings.has(i) && super.checkLocalExport(e)
    }
  }
  const YK = (t, e) => Object.hasOwnProperty.call(t, e) && t[e]
  function HK(t) {
    if (t == null) throw new Error(`Unexpected ${t} value.`)
    return t
  }
  function ug(t) {
    if (!t) throw new Error('Assert fail')
  }
  function qK(t) {
    return Cp(t) || Kz(t)
  }
  const Ve = ei`typescript`((t) => ({
    AbstractMethodHasImplementation: t(
      ({ methodName: e }) => `Method '${e}' cannot have an implementation because it is marked abstract.`
    ),
    AbstractPropertyHasInitializer: t(
      ({ propertyName: e }) => `Property '${e}' cannot have an initializer because it is marked abstract.`
    ),
    AccesorCannotDeclareThisParameter: t("'get' and 'set' accessors cannot declare 'this' parameters."),
    AccesorCannotHaveTypeParameters: t('An accessor cannot have type parameters.'),
    CannotFindName: t(({ name: e }) => `Cannot find name '${e}'.`),
    ClassMethodHasDeclare: t("Class methods cannot have the 'declare' modifier."),
    ClassMethodHasReadonly: t("Class methods cannot have the 'readonly' modifier."),
    ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: t(
      "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference."
    ),
    ConstructorHasTypeParameters: t('Type parameters cannot appear on a constructor declaration.'),
    DeclareAccessor: t(({ kind: e }) => `'declare' is not allowed in ${e}ters.`),
    DeclareClassFieldHasInitializer: t('Initializers are not allowed in ambient contexts.'),
    DeclareFunctionHasImplementation: t('An implementation cannot be declared in ambient contexts.'),
    DuplicateAccessibilityModifier: t(({ modifier: e }) => 'Accessibility modifier already seen.'),
    DuplicateModifier: t(({ modifier: e }) => `Duplicate modifier: '${e}'.`),
    EmptyHeritageClauseType: t(({ token: e }) => `'${e}' list cannot be empty.`),
    EmptyTypeArguments: t('Type argument list cannot be empty.'),
    EmptyTypeParameters: t('Type parameter list cannot be empty.'),
    ExpectedAmbientAfterExportDeclare: t("'export declare' must be followed by an ambient declaration."),
    ImportAliasHasImportType: t("An import alias can not use 'import type'."),
    IncompatibleModifiers: t(({ modifiers: e }) => `'${e[0]}' modifier cannot be used with '${e[1]}' modifier.`),
    IndexSignatureHasAbstract: t("Index signatures cannot have the 'abstract' modifier."),
    IndexSignatureHasAccessibility: t(
      ({ modifier: e }) => `Index signatures cannot have an accessibility modifier ('${e}').`
    ),
    IndexSignatureHasDeclare: t("Index signatures cannot have the 'declare' modifier."),
    IndexSignatureHasOverride: t("'override' modifier cannot appear on an index signature."),
    IndexSignatureHasStatic: t("Index signatures cannot have the 'static' modifier."),
    InitializerNotAllowedInAmbientContext: t('Initializers are not allowed in ambient contexts.'),
    InvalidModifierOnTypeMember: t(({ modifier: e }) => `'${e}' modifier cannot appear on a type member.`),
    InvalidModifierOnTypeParameter: t(({ modifier: e }) => `'${e}' modifier cannot appear on a type parameter.`),
    InvalidModifierOnTypeParameterPositions: t(
      ({ modifier: e }) => `'${e}' modifier can only appear on a type parameter of a class, interface or type alias.`
    ),
    InvalidModifiersOrder: t(({ orderedModifiers: e }) => `'${e[0]}' modifier must precede '${e[1]}' modifier.`),
    InvalidTupleMemberLabel: t('Tuple members must be labeled with a simple identifier.'),
    MissingInterfaceName: t("'interface' declarations must be followed by an identifier."),
    MixedLabeledAndUnlabeledElements: t('Tuple members must all have names or all not have names.'),
    NonAbstractClassHasAbstractMethod: t('Abstract methods can only appear within an abstract class.'),
    NonClassMethodPropertyHasAbstractModifer: t(
      "'abstract' modifier can only appear on a class, method, or property declaration."
    ),
    OptionalTypeBeforeRequired: t('A required element cannot follow an optional element.'),
    OverrideNotInSubClass: t(
      "This member cannot have an 'override' modifier because its containing class does not extend another class."
    ),
    PatternIsOptional: t('A binding pattern parameter cannot be optional in an implementation signature.'),
    PrivateElementHasAbstract: t("Private elements cannot have the 'abstract' modifier."),
    PrivateElementHasAccessibility: t(
      ({ modifier: e }) => `Private elements cannot have an accessibility modifier ('${e}').`
    ),
    ReadonlyForMethodSignature: t("'readonly' modifier can only appear on a property declaration or index signature."),
    ReservedArrowTypeParam: t(
      'This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.'
    ),
    ReservedTypeAssertion: t(
      'This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.'
    ),
    SetAccesorCannotHaveOptionalParameter: t("A 'set' accessor cannot have an optional parameter."),
    SetAccesorCannotHaveRestParameter: t("A 'set' accessor cannot have rest parameter."),
    SetAccesorCannotHaveReturnType: t("A 'set' accessor cannot have a return type annotation."),
    SingleTypeParameterWithoutTrailingComma: t(
      ({ typeParameterName: e }) => `Single type parameter ${e} should have a trailing comma. Example usage: <${e},>.`
    ),
    StaticBlockCannotHaveModifier: t('Static class blocks cannot have any modifier.'),
    TypeAnnotationAfterAssign: t(
      'Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.'
    ),
    TypeImportCannotSpecifyDefaultAndNamed: t(
      'A type-only import can specify a default import or named bindings, but not both.'
    ),
    TypeModifierIsUsedInTypeExports: t(
      "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement."
    ),
    TypeModifierIsUsedInTypeImports: t(
      "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement."
    ),
    UnexpectedParameterModifier: t('A parameter property is only allowed in a constructor implementation.'),
    UnexpectedReadonly: t("'readonly' type modifier is only permitted on array and tuple literal types."),
    UnexpectedTypeAnnotation: t('Did not expect a type annotation here.'),
    UnexpectedTypeCastInParameter: t('Unexpected type cast in parameter position.'),
    UnsupportedImportTypeArgument: t('Argument in a type import must be a string literal.'),
    UnsupportedParameterPropertyKind: t('A parameter property may not be declared using a binding pattern.'),
    UnsupportedSignatureParameterKind: t(
      ({ type: e }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${e}.`
    ),
  }))
  function XK(t) {
    switch (t) {
      case 'any':
        return 'TSAnyKeyword'
      case 'boolean':
        return 'TSBooleanKeyword'
      case 'bigint':
        return 'TSBigIntKeyword'
      case 'never':
        return 'TSNeverKeyword'
      case 'number':
        return 'TSNumberKeyword'
      case 'object':
        return 'TSObjectKeyword'
      case 'string':
        return 'TSStringKeyword'
      case 'symbol':
        return 'TSSymbolKeyword'
      case 'undefined':
        return 'TSUndefinedKeyword'
      case 'unknown':
        return 'TSUnknownKeyword'
      default:
        return
    }
  }
  function cg(t) {
    return t === 'private' || t === 'public' || t === 'protected'
  }
  function GK(t) {
    return t === 'in' || t === 'out'
  }
  var JK = (t) =>
    class extends t {
      getScopeHandler() {
        return WK
      }
      tsIsIdentifier() {
        return mt(this.state.type)
      }
      tsTokenCanFollowModifier() {
        return (
          (this.match(0) ||
            this.match(5) ||
            this.match(55) ||
            this.match(21) ||
            this.match(134) ||
            this.isLiteralPropertyName()) &&
          !this.hasPrecedingLineBreak()
        )
      }
      tsNextTokenCanFollowModifier() {
        return this.next(), this.tsTokenCanFollowModifier()
      }
      tsParseModifier(e, r) {
        if (!mt(this.state.type) && this.state.type !== 58) return
        const i = this.state.value
        if (e.indexOf(i) !== -1) {
          if (r && this.tsIsStartOfStaticBlocks()) return
          if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) return i
        }
      }
      tsParseModifiers({
        modified: e,
        allowedModifiers: r,
        disallowedModifiers: i,
        stopOnStartOfClassStaticBlock: n,
        errorTemplate: s = Ve.InvalidModifierOnTypeMember,
      }) {
        const a = (u, c, p, h) => {
            c === p && e[h] && this.raise(Ve.InvalidModifiersOrder, { at: u, orderedModifiers: [p, h] })
          },
          o = (u, c, p, h) => {
            ;((e[p] && c === h) || (e[h] && c === p)) &&
              this.raise(Ve.IncompatibleModifiers, { at: u, modifiers: [p, h] })
          }
        for (;;) {
          const { startLoc: u } = this.state,
            c = this.tsParseModifier(r.concat(i != null ? i : []), n)
          if (!c) break
          cg(c)
            ? e.accessibility
              ? this.raise(Ve.DuplicateAccessibilityModifier, { at: u, modifier: c })
              : (a(u, c, c, 'override'), a(u, c, c, 'static'), a(u, c, c, 'readonly'), (e.accessibility = c))
            : GK(c)
            ? (e[c] && this.raise(Ve.DuplicateModifier, { at: u, modifier: c }), (e[c] = !0), a(u, c, 'in', 'out'))
            : (Object.hasOwnProperty.call(e, c)
                ? this.raise(Ve.DuplicateModifier, { at: u, modifier: c })
                : (a(u, c, 'static', 'readonly'),
                  a(u, c, 'static', 'override'),
                  a(u, c, 'override', 'readonly'),
                  a(u, c, 'abstract', 'override'),
                  o(u, c, 'declare', 'override'),
                  o(u, c, 'static', 'abstract')),
              (e[c] = !0)),
            i != null && i.includes(c) && this.raise(s, { at: u, modifier: c })
        }
      }
      tsIsListTerminator(e) {
        switch (e) {
          case 'EnumMembers':
          case 'TypeMembers':
            return this.match(8)
          case 'HeritageClauseElement':
            return this.match(5)
          case 'TupleElementTypes':
            return this.match(3)
          case 'TypeParametersOrArguments':
            return this.match(48)
        }
        throw new Error('Unreachable')
      }
      tsParseList(e, r) {
        const i = []
        for (; !this.tsIsListTerminator(e); ) i.push(r())
        return i
      }
      tsParseDelimitedList(e, r, i) {
        return HK(this.tsParseDelimitedListWorker(e, r, !0, i))
      }
      tsParseDelimitedListWorker(e, r, i, n) {
        const s = []
        let a = -1
        for (; !this.tsIsListTerminator(e); ) {
          a = -1
          const o = r()
          if (o == null) return
          if ((s.push(o), this.eat(12))) {
            a = this.state.lastTokStart
            continue
          }
          if (this.tsIsListTerminator(e)) break
          i && this.expect(12)
          return
        }
        return n && (n.value = a), s
      }
      tsParseBracketedList(e, r, i, n, s) {
        n || (i ? this.expect(0) : this.expect(47))
        const a = this.tsParseDelimitedList(e, r, s)
        return i ? this.expect(3) : this.expect(48), a
      }
      tsParseImportType() {
        const e = this.startNode()
        return (
          this.expect(83),
          this.expect(10),
          this.match(129) || this.raise(Ve.UnsupportedImportTypeArgument, { at: this.state.startLoc }),
          (e.argument = this.parseExprAtom()),
          this.expect(11),
          this.eat(16) && (e.qualifier = this.tsParseEntityName()),
          this.match(47) && (e.typeParameters = this.tsParseTypeArguments()),
          this.finishNode(e, 'TSImportType')
        )
      }
      tsParseEntityName(e = !0) {
        let r = this.parseIdentifier(e)
        for (; this.eat(16); ) {
          const i = this.startNodeAtNode(r)
          ;(i.left = r), (i.right = this.parseIdentifier(e)), (r = this.finishNode(i, 'TSQualifiedName'))
        }
        return r
      }
      tsParseTypeReference() {
        const e = this.startNode()
        return (
          (e.typeName = this.tsParseEntityName()),
          !this.hasPrecedingLineBreak() && this.match(47) && (e.typeParameters = this.tsParseTypeArguments()),
          this.finishNode(e, 'TSTypeReference')
        )
      }
      tsParseThisTypePredicate(e) {
        this.next()
        const r = this.startNodeAtNode(e)
        return (
          (r.parameterName = e),
          (r.typeAnnotation = this.tsParseTypeAnnotation(!1)),
          (r.asserts = !1),
          this.finishNode(r, 'TSTypePredicate')
        )
      }
      tsParseThisTypeNode() {
        const e = this.startNode()
        return this.next(), this.finishNode(e, 'TSThisType')
      }
      tsParseTypeQuery() {
        const e = this.startNode()
        return (
          this.expect(87),
          this.match(83) ? (e.exprName = this.tsParseImportType()) : (e.exprName = this.tsParseEntityName()),
          !this.hasPrecedingLineBreak() && this.match(47) && (e.typeParameters = this.tsParseTypeArguments()),
          this.finishNode(e, 'TSTypeQuery')
        )
      }
      tsParseInOutModifiers(e) {
        this.tsParseModifiers({
          modified: e,
          allowedModifiers: ['in', 'out'],
          disallowedModifiers: ['public', 'private', 'protected', 'readonly', 'declare', 'abstract', 'override'],
          errorTemplate: Ve.InvalidModifierOnTypeParameter,
        })
      }
      tsParseNoneModifiers(e) {
        this.tsParseModifiers({
          modified: e,
          allowedModifiers: [],
          disallowedModifiers: ['in', 'out'],
          errorTemplate: Ve.InvalidModifierOnTypeParameterPositions,
        })
      }
      tsParseTypeParameter(e = this.tsParseNoneModifiers.bind(this)) {
        const r = this.startNode()
        return (
          e(r),
          (r.name = this.tsParseTypeParameterName()),
          (r.constraint = this.tsEatThenParseType(81)),
          (r.default = this.tsEatThenParseType(29)),
          this.finishNode(r, 'TSTypeParameter')
        )
      }
      tsTryParseTypeParameters(e) {
        if (this.match(47)) return this.tsParseTypeParameters(e)
      }
      tsParseTypeParameters(e) {
        const r = this.startNode()
        this.match(47) || this.match(138) ? this.next() : this.unexpected()
        const i = { value: -1 }
        return (
          (r.params = this.tsParseBracketedList(
            'TypeParametersOrArguments',
            this.tsParseTypeParameter.bind(this, e),
            !1,
            !0,
            i
          )),
          r.params.length === 0 && this.raise(Ve.EmptyTypeParameters, { at: r }),
          i.value !== -1 && this.addExtra(r, 'trailingComma', i.value),
          this.finishNode(r, 'TSTypeParameterDeclaration')
        )
      }
      tsTryNextParseConstantContext() {
        if (this.lookahead().type !== 75) return null
        this.next()
        const e = this.tsParseTypeReference()
        return e.typeParameters && this.raise(Ve.CannotFindName, { at: e.typeName, name: 'const' }), e
      }
      tsFillSignature(e, r) {
        const i = e === 19,
          n = 'parameters',
          s = 'typeAnnotation'
        ;(r.typeParameters = this.tsTryParseTypeParameters()),
          this.expect(10),
          (r[n] = this.tsParseBindingListForSignature()),
          i
            ? (r[s] = this.tsParseTypeOrTypePredicateAnnotation(e))
            : this.match(e) && (r[s] = this.tsParseTypeOrTypePredicateAnnotation(e))
      }
      tsParseBindingListForSignature() {
        return this.parseBindingList(11, 41).map(
          (e) => (
            e.type !== 'Identifier' &&
              e.type !== 'RestElement' &&
              e.type !== 'ObjectPattern' &&
              e.type !== 'ArrayPattern' &&
              this.raise(Ve.UnsupportedSignatureParameterKind, { at: e, type: e.type }),
            e
          )
        )
      }
      tsParseTypeMemberSemicolon() {
        !this.eat(12) && !this.isLineTerminator() && this.expect(13)
      }
      tsParseSignatureMember(e, r) {
        return this.tsFillSignature(14, r), this.tsParseTypeMemberSemicolon(), this.finishNode(r, e)
      }
      tsIsUnambiguouslyIndexSignature() {
        return this.next(), mt(this.state.type) ? (this.next(), this.match(14)) : !1
      }
      tsTryParseIndexSignature(e) {
        if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) return
        this.expect(0)
        const r = this.parseIdentifier()
        ;(r.typeAnnotation = this.tsParseTypeAnnotation()),
          this.resetEndLocation(r),
          this.expect(3),
          (e.parameters = [r])
        const i = this.tsTryParseTypeAnnotation()
        return i && (e.typeAnnotation = i), this.tsParseTypeMemberSemicolon(), this.finishNode(e, 'TSIndexSignature')
      }
      tsParsePropertyOrMethodSignature(e, r) {
        this.eat(17) && (e.optional = !0)
        const i = e
        if (this.match(10) || this.match(47)) {
          r && this.raise(Ve.ReadonlyForMethodSignature, { at: e })
          const n = i
          n.kind && this.match(47) && this.raise(Ve.AccesorCannotHaveTypeParameters, { at: this.state.curPosition() }),
            this.tsFillSignature(14, n),
            this.tsParseTypeMemberSemicolon()
          const s = 'parameters',
            a = 'typeAnnotation'
          if (n.kind === 'get')
            n[s].length > 0 &&
              (this.raise(re.BadGetterArity, { at: this.state.curPosition() }),
              this.isThisParam(n[s][0]) &&
                this.raise(Ve.AccesorCannotDeclareThisParameter, { at: this.state.curPosition() }))
          else if (n.kind === 'set') {
            if (n[s].length !== 1) this.raise(re.BadSetterArity, { at: this.state.curPosition() })
            else {
              const o = n[s][0]
              this.isThisParam(o) && this.raise(Ve.AccesorCannotDeclareThisParameter, { at: this.state.curPosition() }),
                o.type === 'Identifier' &&
                  o.optional &&
                  this.raise(Ve.SetAccesorCannotHaveOptionalParameter, { at: this.state.curPosition() }),
                o.type === 'RestElement' &&
                  this.raise(Ve.SetAccesorCannotHaveRestParameter, { at: this.state.curPosition() })
            }
            n[a] && this.raise(Ve.SetAccesorCannotHaveReturnType, { at: n[a] })
          } else n.kind = 'method'
          return this.finishNode(n, 'TSMethodSignature')
        } else {
          const n = i
          r && (n.readonly = !0)
          const s = this.tsTryParseTypeAnnotation()
          return (
            s && (n.typeAnnotation = s), this.tsParseTypeMemberSemicolon(), this.finishNode(n, 'TSPropertySignature')
          )
        }
      }
      tsParseTypeMember() {
        const e = this.startNode()
        if (this.match(10) || this.match(47)) return this.tsParseSignatureMember('TSCallSignatureDeclaration', e)
        if (this.match(77)) {
          const i = this.startNode()
          return (
            this.next(),
            this.match(10) || this.match(47)
              ? this.tsParseSignatureMember('TSConstructSignatureDeclaration', e)
              : ((e.key = this.createIdentifier(i, 'new')), this.tsParsePropertyOrMethodSignature(e, !1))
          )
        }
        this.tsParseModifiers({
          modified: e,
          allowedModifiers: ['readonly'],
          disallowedModifiers: ['declare', 'abstract', 'private', 'protected', 'public', 'static', 'override'],
        })
        const r = this.tsTryParseIndexSignature(e)
        return (
          r ||
          (this.parsePropertyName(e),
          !e.computed &&
            e.key.type === 'Identifier' &&
            (e.key.name === 'get' || e.key.name === 'set') &&
            this.tsTokenCanFollowModifier() &&
            ((e.kind = e.key.name), this.parsePropertyName(e)),
          this.tsParsePropertyOrMethodSignature(e, !!e.readonly))
        )
      }
      tsParseTypeLiteral() {
        const e = this.startNode()
        return (e.members = this.tsParseObjectTypeMembers()), this.finishNode(e, 'TSTypeLiteral')
      }
      tsParseObjectTypeMembers() {
        this.expect(5)
        const e = this.tsParseList('TypeMembers', this.tsParseTypeMember.bind(this))
        return this.expect(8), e
      }
      tsIsStartOfMappedType() {
        return (
          this.next(),
          this.eat(53)
            ? this.isContextual(118)
            : (this.isContextual(118) && this.next(),
              !this.match(0) || (this.next(), !this.tsIsIdentifier()) ? !1 : (this.next(), this.match(58)))
        )
      }
      tsParseMappedTypeParameter() {
        const e = this.startNode()
        return (
          (e.name = this.tsParseTypeParameterName()),
          (e.constraint = this.tsExpectThenParseType(58)),
          this.finishNode(e, 'TSTypeParameter')
        )
      }
      tsParseMappedType() {
        const e = this.startNode()
        return (
          this.expect(5),
          this.match(53)
            ? ((e.readonly = this.state.value), this.next(), this.expectContextual(118))
            : this.eatContextual(118) && (e.readonly = !0),
          this.expect(0),
          (e.typeParameter = this.tsParseMappedTypeParameter()),
          (e.nameType = this.eatContextual(93) ? this.tsParseType() : null),
          this.expect(3),
          this.match(53)
            ? ((e.optional = this.state.value), this.next(), this.expect(17))
            : this.eat(17) && (e.optional = !0),
          (e.typeAnnotation = this.tsTryParseType()),
          this.semicolon(),
          this.expect(8),
          this.finishNode(e, 'TSMappedType')
        )
      }
      tsParseTupleType() {
        const e = this.startNode()
        e.elementTypes = this.tsParseBracketedList('TupleElementTypes', this.tsParseTupleElementType.bind(this), !0, !1)
        let r = !1,
          i = null
        return (
          e.elementTypes.forEach((n) => {
            var s
            let { type: a } = n
            r &&
              a !== 'TSRestType' &&
              a !== 'TSOptionalType' &&
              !(a === 'TSNamedTupleMember' && n.optional) &&
              this.raise(Ve.OptionalTypeBeforeRequired, { at: n }),
              (r = r || (a === 'TSNamedTupleMember' && n.optional) || a === 'TSOptionalType'),
              a === 'TSRestType' && ((n = n.typeAnnotation), (a = n.type))
            const o = a === 'TSNamedTupleMember'
            ;(i = (s = i) != null ? s : o), i !== o && this.raise(Ve.MixedLabeledAndUnlabeledElements, { at: n })
          }),
          this.finishNode(e, 'TSTupleType')
        )
      }
      tsParseTupleElementType() {
        const { start: e, startLoc: r } = this.state,
          i = this.eat(21)
        let n = this.tsParseType()
        const s = this.eat(17)
        if (this.eat(14)) {
          const o = this.startNodeAtNode(n)
          ;(o.optional = s),
            n.type === 'TSTypeReference' && !n.typeParameters && n.typeName.type === 'Identifier'
              ? (o.label = n.typeName)
              : (this.raise(Ve.InvalidTupleMemberLabel, { at: n }), (o.label = n)),
            (o.elementType = this.tsParseType()),
            (n = this.finishNode(o, 'TSNamedTupleMember'))
        } else if (s) {
          const o = this.startNodeAtNode(n)
          ;(o.typeAnnotation = n), (n = this.finishNode(o, 'TSOptionalType'))
        }
        if (i) {
          const o = this.startNodeAt(e, r)
          ;(o.typeAnnotation = n), (n = this.finishNode(o, 'TSRestType'))
        }
        return n
      }
      tsParseParenthesizedType() {
        const e = this.startNode()
        return (
          this.expect(10),
          (e.typeAnnotation = this.tsParseType()),
          this.expect(11),
          this.finishNode(e, 'TSParenthesizedType')
        )
      }
      tsParseFunctionOrConstructorType(e, r) {
        const i = this.startNode()
        return (
          e === 'TSConstructorType' && ((i.abstract = !!r), r && this.next(), this.next()),
          this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, i)),
          this.finishNode(i, e)
        )
      }
      tsParseLiteralTypeNode() {
        const e = this.startNode()
        return (
          (e.literal = (() => {
            switch (this.state.type) {
              case 130:
              case 131:
              case 129:
              case 85:
              case 86:
                return this.parseExprAtom()
              default:
                throw this.unexpected()
            }
          })()),
          this.finishNode(e, 'TSLiteralType')
        )
      }
      tsParseTemplateLiteralType() {
        const e = this.startNode()
        return (e.literal = this.parseTemplate(!1)), this.finishNode(e, 'TSLiteralType')
      }
      parseTemplateSubstitution() {
        return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution()
      }
      tsParseThisTypeOrThisTypePredicate() {
        const e = this.tsParseThisTypeNode()
        return this.isContextual(113) && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(e) : e
      }
      tsParseNonArrayType() {
        switch (this.state.type) {
          case 129:
          case 130:
          case 131:
          case 85:
          case 86:
            return this.tsParseLiteralTypeNode()
          case 53:
            if (this.state.value === '-') {
              const e = this.startNode(),
                r = this.lookahead()
              if (r.type !== 130 && r.type !== 131) throw this.unexpected()
              return (e.literal = this.parseMaybeUnary()), this.finishNode(e, 'TSLiteralType')
            }
            break
          case 78:
            return this.tsParseThisTypeOrThisTypePredicate()
          case 87:
            return this.tsParseTypeQuery()
          case 83:
            return this.tsParseImportType()
          case 5:
            return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this))
              ? this.tsParseMappedType()
              : this.tsParseTypeLiteral()
          case 0:
            return this.tsParseTupleType()
          case 10:
            return this.tsParseParenthesizedType()
          case 25:
          case 24:
            return this.tsParseTemplateLiteralType()
          default: {
            const { type: e } = this.state
            if (mt(e) || e === 88 || e === 84) {
              const r = e === 88 ? 'TSVoidKeyword' : e === 84 ? 'TSNullKeyword' : XK(this.state.value)
              if (r !== void 0 && this.lookaheadCharCode() !== 46) {
                const i = this.startNode()
                return this.next(), this.finishNode(i, r)
              }
              return this.tsParseTypeReference()
            }
          }
        }
        throw this.unexpected()
      }
      tsParseArrayTypeOrHigher() {
        let e = this.tsParseNonArrayType()
        for (; !this.hasPrecedingLineBreak() && this.eat(0); )
          if (this.match(3)) {
            const r = this.startNodeAtNode(e)
            ;(r.elementType = e), this.expect(3), (e = this.finishNode(r, 'TSArrayType'))
          } else {
            const r = this.startNodeAtNode(e)
            ;(r.objectType = e),
              (r.indexType = this.tsParseType()),
              this.expect(3),
              (e = this.finishNode(r, 'TSIndexedAccessType'))
          }
        return e
      }
      tsParseTypeOperator() {
        const e = this.startNode(),
          r = this.state.value
        return (
          this.next(),
          (e.operator = r),
          (e.typeAnnotation = this.tsParseTypeOperatorOrHigher()),
          r === 'readonly' && this.tsCheckTypeAnnotationForReadOnly(e),
          this.finishNode(e, 'TSTypeOperator')
        )
      }
      tsCheckTypeAnnotationForReadOnly(e) {
        switch (e.typeAnnotation.type) {
          case 'TSTupleType':
          case 'TSArrayType':
            return
          default:
            this.raise(Ve.UnexpectedReadonly, { at: e })
        }
      }
      tsParseInferType() {
        const e = this.startNode()
        this.expectContextual(112)
        const r = this.startNode()
        return (
          (r.name = this.tsParseTypeParameterName()),
          (r.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType())),
          (e.typeParameter = this.finishNode(r, 'TSTypeParameter')),
          this.finishNode(e, 'TSInferType')
        )
      }
      tsParseConstraintForInferType() {
        if (this.eat(81)) {
          const e = this.tsInDisallowConditionalTypesContext(() => this.tsParseType())
          if (this.state.inDisallowConditionalTypesContext || !this.match(17)) return e
        }
      }
      tsParseTypeOperatorOrHigher() {
        return Uz(this.state.type) && !this.state.containsEsc
          ? this.tsParseTypeOperator()
          : this.isContextual(112)
          ? this.tsParseInferType()
          : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher())
      }
      tsParseUnionOrIntersectionType(e, r, i) {
        const n = this.startNode(),
          s = this.eat(i),
          a = []
        do a.push(r())
        while (this.eat(i))
        return a.length === 1 && !s ? a[0] : ((n.types = a), this.finishNode(n, e))
      }
      tsParseIntersectionTypeOrHigher() {
        return this.tsParseUnionOrIntersectionType(
          'TSIntersectionType',
          this.tsParseTypeOperatorOrHigher.bind(this),
          45
        )
      }
      tsParseUnionTypeOrHigher() {
        return this.tsParseUnionOrIntersectionType('TSUnionType', this.tsParseIntersectionTypeOrHigher.bind(this), 43)
      }
      tsIsStartOfFunctionType() {
        return this.match(47)
          ? !0
          : this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this))
      }
      tsSkipParameterStart() {
        if (mt(this.state.type) || this.match(78)) return this.next(), !0
        if (this.match(5)) {
          const { errors: e } = this.state,
            r = e.length
          try {
            return this.parseObjectLike(8, !0), e.length === r
          } catch {
            return !1
          }
        }
        if (this.match(0)) {
          this.next()
          const { errors: e } = this.state,
            r = e.length
          try {
            return this.parseBindingList(3, 93, !0), e.length === r
          } catch {
            return !1
          }
        }
        return !1
      }
      tsIsUnambiguouslyStartOfFunctionType() {
        return (
          this.next(),
          !!(
            this.match(11) ||
            this.match(21) ||
            (this.tsSkipParameterStart() &&
              (this.match(14) ||
                this.match(12) ||
                this.match(17) ||
                this.match(29) ||
                (this.match(11) && (this.next(), this.match(19)))))
          )
        )
      }
      tsParseTypeOrTypePredicateAnnotation(e) {
        return this.tsInType(() => {
          const r = this.startNode()
          this.expect(e)
          const i = this.startNode(),
            n = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this))
          if (n && this.match(78)) {
            let o = this.tsParseThisTypeOrThisTypePredicate()
            return (
              o.type === 'TSThisType'
                ? ((i.parameterName = o),
                  (i.asserts = !0),
                  (i.typeAnnotation = null),
                  (o = this.finishNode(i, 'TSTypePredicate')))
                : (this.resetStartLocationFromNode(o, i), (o.asserts = !0)),
              (r.typeAnnotation = o),
              this.finishNode(r, 'TSTypeAnnotation')
            )
          }
          const s = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this))
          if (!s)
            return n
              ? ((i.parameterName = this.parseIdentifier()),
                (i.asserts = n),
                (i.typeAnnotation = null),
                (r.typeAnnotation = this.finishNode(i, 'TSTypePredicate')),
                this.finishNode(r, 'TSTypeAnnotation'))
              : this.tsParseTypeAnnotation(!1, r)
          const a = this.tsParseTypeAnnotation(!1)
          return (
            (i.parameterName = s),
            (i.typeAnnotation = a),
            (i.asserts = n),
            (r.typeAnnotation = this.finishNode(i, 'TSTypePredicate')),
            this.finishNode(r, 'TSTypeAnnotation')
          )
        })
      }
      tsTryParseTypeOrTypePredicateAnnotation() {
        return this.match(14) ? this.tsParseTypeOrTypePredicateAnnotation(14) : void 0
      }
      tsTryParseTypeAnnotation() {
        return this.match(14) ? this.tsParseTypeAnnotation() : void 0
      }
      tsTryParseType() {
        return this.tsEatThenParseType(14)
      }
      tsParseTypePredicatePrefix() {
        const e = this.parseIdentifier()
        if (this.isContextual(113) && !this.hasPrecedingLineBreak()) return this.next(), e
      }
      tsParseTypePredicateAsserts() {
        if (this.state.type !== 106) return !1
        const e = this.state.containsEsc
        return (
          this.next(),
          !mt(this.state.type) && !this.match(78)
            ? !1
            : (e &&
                this.raise(re.InvalidEscapedReservedWord, { at: this.state.lastTokStartLoc, reservedWord: 'asserts' }),
              !0)
        )
      }
      tsParseTypeAnnotation(e = !0, r = this.startNode()) {
        return (
          this.tsInType(() => {
            e && this.expect(14), (r.typeAnnotation = this.tsParseType())
          }),
          this.finishNode(r, 'TSTypeAnnotation')
        )
      }
      tsParseType() {
        ug(this.state.inType)
        const e = this.tsParseNonConditionalType()
        if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81)) return e
        const r = this.startNodeAtNode(e)
        return (
          (r.checkType = e),
          (r.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType())),
          this.expect(17),
          (r.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType())),
          this.expect(14),
          (r.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType())),
          this.finishNode(r, 'TSConditionalType')
        )
      }
      isAbstractConstructorSignature() {
        return this.isContextual(120) && this.lookahead().type === 77
      }
      tsParseNonConditionalType() {
        return this.tsIsStartOfFunctionType()
          ? this.tsParseFunctionOrConstructorType('TSFunctionType')
          : this.match(77)
          ? this.tsParseFunctionOrConstructorType('TSConstructorType')
          : this.isAbstractConstructorSignature()
          ? this.tsParseFunctionOrConstructorType('TSConstructorType', !0)
          : this.tsParseUnionTypeOrHigher()
      }
      tsParseTypeAssertion() {
        this.getPluginOption('typescript', 'disallowAmbiguousJSXLike') &&
          this.raise(Ve.ReservedTypeAssertion, { at: this.state.startLoc })
        const e = this.startNode(),
          r = this.tsTryNextParseConstantContext()
        return (
          (e.typeAnnotation = r || this.tsNextThenParseType()),
          this.expect(48),
          (e.expression = this.parseMaybeUnary()),
          this.finishNode(e, 'TSTypeAssertion')
        )
      }
      tsParseHeritageClause(e) {
        const r = this.state.startLoc,
          i = this.tsParseDelimitedList('HeritageClauseElement', () => {
            const n = this.startNode()
            return (
              (n.expression = this.tsParseEntityName()),
              this.match(47) && (n.typeParameters = this.tsParseTypeArguments()),
              this.finishNode(n, 'TSExpressionWithTypeArguments')
            )
          })
        return i.length || this.raise(Ve.EmptyHeritageClauseType, { at: r, token: e }), i
      }
      tsParseInterfaceDeclaration(e, r = {}) {
        if (this.hasFollowingLineBreak()) return null
        this.expectContextual(125),
          r.declare && (e.declare = !0),
          mt(this.state.type)
            ? ((e.id = this.parseIdentifier()), this.checkIdentifier(e.id, rK))
            : ((e.id = null), this.raise(Ve.MissingInterfaceName, { at: this.state.startLoc })),
          (e.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this))),
          this.eat(81) && (e.extends = this.tsParseHeritageClause('extends'))
        const i = this.startNode()
        return (
          (i.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this))),
          (e.body = this.finishNode(i, 'TSInterfaceBody')),
          this.finishNode(e, 'TSInterfaceDeclaration')
        )
      }
      tsParseTypeAliasDeclaration(e) {
        return (
          (e.id = this.parseIdentifier()),
          this.checkIdentifier(e.id, iK),
          (e.typeAnnotation = this.tsInType(() => {
            if (
              ((e.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this))),
              this.expect(29),
              this.isContextual(111) && this.lookahead().type !== 16)
            ) {
              const r = this.startNode()
              return this.next(), this.finishNode(r, 'TSIntrinsicKeyword')
            }
            return this.tsParseType()
          })),
          this.semicolon(),
          this.finishNode(e, 'TSTypeAliasDeclaration')
        )
      }
      tsInNoContext(e) {
        const r = this.state.context
        this.state.context = [r[0]]
        try {
          return e()
        } finally {
          this.state.context = r
        }
      }
      tsInType(e) {
        const r = this.state.inType
        this.state.inType = !0
        try {
          return e()
        } finally {
          this.state.inType = r
        }
      }
      tsInDisallowConditionalTypesContext(e) {
        const r = this.state.inDisallowConditionalTypesContext
        this.state.inDisallowConditionalTypesContext = !0
        try {
          return e()
        } finally {
          this.state.inDisallowConditionalTypesContext = r
        }
      }
      tsInAllowConditionalTypesContext(e) {
        const r = this.state.inDisallowConditionalTypesContext
        this.state.inDisallowConditionalTypesContext = !1
        try {
          return e()
        } finally {
          this.state.inDisallowConditionalTypesContext = r
        }
      }
      tsEatThenParseType(e) {
        return this.match(e) ? this.tsNextThenParseType() : void 0
      }
      tsExpectThenParseType(e) {
        return this.tsDoThenParseType(() => this.expect(e))
      }
      tsNextThenParseType() {
        return this.tsDoThenParseType(() => this.next())
      }
      tsDoThenParseType(e) {
        return this.tsInType(() => (e(), this.tsParseType()))
      }
      tsParseEnumMember() {
        const e = this.startNode()
        return (
          (e.id = this.match(129) ? this.parseExprAtom() : this.parseIdentifier(!0)),
          this.eat(29) && (e.initializer = this.parseMaybeAssignAllowIn()),
          this.finishNode(e, 'TSEnumMember')
        )
      }
      tsParseEnumDeclaration(e, r = {}) {
        return (
          r.const && (e.const = !0),
          r.declare && (e.declare = !0),
          this.expectContextual(122),
          (e.id = this.parseIdentifier()),
          this.checkIdentifier(e.id, e.const ? sK : J0),
          this.expect(5),
          (e.members = this.tsParseDelimitedList('EnumMembers', this.tsParseEnumMember.bind(this))),
          this.expect(8),
          this.finishNode(e, 'TSEnumDeclaration')
        )
      }
      tsParseModuleBlock() {
        const e = this.startNode()
        return (
          this.scope.enter(Rn),
          this.expect(5),
          this.parseBlockOrModuleBlockBody((e.body = []), void 0, !0, 8),
          this.scope.exit(),
          this.finishNode(e, 'TSModuleBlock')
        )
      }
      tsParseModuleOrNamespaceDeclaration(e, r = !1) {
        if (((e.id = this.parseIdentifier()), r || this.checkIdentifier(e.id, aK), this.eat(16))) {
          const i = this.startNode()
          this.tsParseModuleOrNamespaceDeclaration(i, !0), (e.body = i)
        } else
          this.scope.enter(Wo),
            this.prodParam.enter(_n),
            (e.body = this.tsParseModuleBlock()),
            this.prodParam.exit(),
            this.scope.exit()
        return this.finishNode(e, 'TSModuleDeclaration')
      }
      tsParseAmbientExternalModuleDeclaration(e) {
        return (
          this.isContextual(109)
            ? ((e.global = !0), (e.id = this.parseIdentifier()))
            : this.match(129)
            ? (e.id = this.parseExprAtom())
            : this.unexpected(),
          this.match(5)
            ? (this.scope.enter(Wo),
              this.prodParam.enter(_n),
              (e.body = this.tsParseModuleBlock()),
              this.prodParam.exit(),
              this.scope.exit())
            : this.semicolon(),
          this.finishNode(e, 'TSModuleDeclaration')
        )
      }
      tsParseImportEqualsDeclaration(e, r) {
        ;(e.isExport = r || !1), (e.id = this.parseIdentifier()), this.checkIdentifier(e.id, oi), this.expect(29)
        const i = this.tsParseModuleReference()
        return (
          e.importKind === 'type' &&
            i.type !== 'TSExternalModuleReference' &&
            this.raise(Ve.ImportAliasHasImportType, { at: i }),
          (e.moduleReference = i),
          this.semicolon(),
          this.finishNode(e, 'TSImportEqualsDeclaration')
        )
      }
      tsIsExternalModuleReference() {
        return this.isContextual(116) && this.lookaheadCharCode() === 40
      }
      tsParseModuleReference() {
        return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(!1)
      }
      tsParseExternalModuleReference() {
        const e = this.startNode()
        if ((this.expectContextual(116), this.expect(10), !this.match(129))) throw this.unexpected()
        return (e.expression = this.parseExprAtom()), this.expect(11), this.finishNode(e, 'TSExternalModuleReference')
      }
      tsLookAhead(e) {
        const r = this.state.clone(),
          i = e()
        return (this.state = r), i
      }
      tsTryParseAndCatch(e) {
        const r = this.tryParse((i) => e() || i())
        if (!(r.aborted || !r.node)) return r.error && (this.state = r.failState), r.node
      }
      tsTryParse(e) {
        const r = this.state.clone(),
          i = e()
        if (i !== void 0 && i !== !1) return i
        this.state = r
      }
      tsTryParseDeclare(e) {
        if (this.isLineTerminator()) return
        let r = this.state.type,
          i
        return (
          this.isContextual(99) && ((r = 74), (i = 'let')),
          this.tsInAmbientContext(() => {
            if (r === 68) return (e.declare = !0), this.parseFunctionStatement(e, !1, !0)
            if (r === 80) return (e.declare = !0), this.parseClass(e, !0, !1)
            if (r === 122) return this.tsParseEnumDeclaration(e, { declare: !0 })
            if (r === 109) return this.tsParseAmbientExternalModuleDeclaration(e)
            if (r === 75 || r === 74)
              return !this.match(75) || !this.isLookaheadContextual('enum')
                ? ((e.declare = !0), this.parseVarStatement(e, i || this.state.value, !0))
                : (this.expect(75), this.tsParseEnumDeclaration(e, { const: !0, declare: !0 }))
            if (r === 125) {
              const n = this.tsParseInterfaceDeclaration(e, { declare: !0 })
              if (n) return n
            }
            if (mt(r)) return this.tsParseDeclaration(e, this.state.value, !0)
          })
        )
      }
      tsTryParseExportDeclaration() {
        return this.tsParseDeclaration(this.startNode(), this.state.value, !0)
      }
      tsParseExpressionStatement(e, r) {
        switch (r.name) {
          case 'declare': {
            const i = this.tsTryParseDeclare(e)
            if (i) return (i.declare = !0), i
            break
          }
          case 'global':
            if (this.match(5)) {
              this.scope.enter(Wo), this.prodParam.enter(_n)
              const i = e
              return (
                (i.global = !0),
                (i.id = r),
                (i.body = this.tsParseModuleBlock()),
                this.scope.exit(),
                this.prodParam.exit(),
                this.finishNode(i, 'TSModuleDeclaration')
              )
            }
            break
          default:
            return this.tsParseDeclaration(e, r.name, !1)
        }
      }
      tsParseDeclaration(e, r, i) {
        switch (r) {
          case 'abstract':
            if (this.tsCheckLineTerminator(i) && (this.match(80) || mt(this.state.type)))
              return this.tsParseAbstractDeclaration(e)
            break
          case 'module':
            if (this.tsCheckLineTerminator(i)) {
              if (this.match(129)) return this.tsParseAmbientExternalModuleDeclaration(e)
              if (mt(this.state.type)) return this.tsParseModuleOrNamespaceDeclaration(e)
            }
            break
          case 'namespace':
            if (this.tsCheckLineTerminator(i) && mt(this.state.type)) return this.tsParseModuleOrNamespaceDeclaration(e)
            break
          case 'type':
            if (this.tsCheckLineTerminator(i) && mt(this.state.type)) return this.tsParseTypeAliasDeclaration(e)
            break
        }
      }
      tsCheckLineTerminator(e) {
        return e ? (this.hasFollowingLineBreak() ? !1 : (this.next(), !0)) : !this.isLineTerminator()
      }
      tsTryParseGenericAsyncArrowFunction(e, r) {
        if (!this.match(47)) return
        const i = this.state.maybeInArrowParameters
        this.state.maybeInArrowParameters = !0
        const n = this.tsTryParseAndCatch(() => {
          const s = this.startNodeAt(e, r)
          return (
            (s.typeParameters = this.tsParseTypeParameters()),
            super.parseFunctionParams(s),
            (s.returnType = this.tsTryParseTypeOrTypePredicateAnnotation()),
            this.expect(19),
            s
          )
        })
        if (((this.state.maybeInArrowParameters = i), !!n)) return this.parseArrowExpression(n, null, !0)
      }
      tsParseTypeArgumentsInExpression() {
        if (this.reScan_lt() === 47) return this.tsParseTypeArguments()
      }
      tsParseTypeArguments() {
        const e = this.startNode()
        return (
          (e.params = this.tsInType(() =>
            this.tsInNoContext(
              () => (
                this.expect(47), this.tsParseDelimitedList('TypeParametersOrArguments', this.tsParseType.bind(this))
              )
            )
          )),
          e.params.length === 0 && this.raise(Ve.EmptyTypeArguments, { at: e }),
          this.expect(48),
          this.finishNode(e, 'TSTypeParameterInstantiation')
        )
      }
      tsIsDeclarationStart() {
        return zz(this.state.type)
      }
      isExportDefaultSpecifier() {
        return this.tsIsDeclarationStart() ? !1 : super.isExportDefaultSpecifier()
      }
      parseAssignableListItem(e, r) {
        const i = this.state.start,
          n = this.state.startLoc
        let s,
          a = !1,
          o = !1
        if (e !== void 0) {
          const p = {}
          this.tsParseModifiers({
            modified: p,
            allowedModifiers: ['public', 'private', 'protected', 'override', 'readonly'],
          }),
            (s = p.accessibility),
            (o = p.override),
            (a = p.readonly),
            e === !1 && (s || a || o) && this.raise(Ve.UnexpectedParameterModifier, { at: n })
        }
        const u = this.parseMaybeDefault()
        this.parseAssignableListItemTypes(u)
        const c = this.parseMaybeDefault(u.start, u.loc.start, u)
        if (s || a || o) {
          const p = this.startNodeAt(i, n)
          return (
            r.length && (p.decorators = r),
            s && (p.accessibility = s),
            a && (p.readonly = a),
            o && (p.override = o),
            c.type !== 'Identifier' &&
              c.type !== 'AssignmentPattern' &&
              this.raise(Ve.UnsupportedParameterPropertyKind, { at: p }),
            (p.parameter = c),
            this.finishNode(p, 'TSParameterProperty')
          )
        }
        return r.length && (u.decorators = r), c
      }
      isSimpleParameter(e) {
        return (e.type === 'TSParameterProperty' && super.isSimpleParameter(e.parameter)) || super.isSimpleParameter(e)
      }
      parseFunctionBodyAndFinish(e, r, i = !1) {
        this.match(14) && (e.returnType = this.tsParseTypeOrTypePredicateAnnotation(14))
        const n =
          r === 'FunctionDeclaration'
            ? 'TSDeclareFunction'
            : r === 'ClassMethod' || r === 'ClassPrivateMethod'
            ? 'TSDeclareMethod'
            : void 0
        if (n && !this.match(5) && this.isLineTerminator()) {
          this.finishNode(e, n)
          return
        }
        if (
          n === 'TSDeclareFunction' &&
          this.state.isAmbientContext &&
          (this.raise(Ve.DeclareFunctionHasImplementation, { at: e }), e.declare)
        ) {
          super.parseFunctionBodyAndFinish(e, n, i)
          return
        }
        super.parseFunctionBodyAndFinish(e, r, i)
      }
      registerFunctionStatementId(e) {
        !e.body && e.id ? this.checkIdentifier(e.id, Z0) : super.registerFunctionStatementId(...arguments)
      }
      tsCheckForInvalidTypeCasts(e) {
        e.forEach((r) => {
          ;(r == null ? void 0 : r.type) === 'TSTypeCastExpression' &&
            this.raise(Ve.UnexpectedTypeAnnotation, { at: r.typeAnnotation })
        })
      }
      toReferencedList(e, r) {
        return this.tsCheckForInvalidTypeCasts(e), e
      }
      parseArrayLike(...e) {
        const r = super.parseArrayLike(...e)
        return r.type === 'ArrayExpression' && this.tsCheckForInvalidTypeCasts(r.elements), r
      }
      parseSubscript(e, r, i, n, s) {
        if (!this.hasPrecedingLineBreak() && this.match(35)) {
          ;(this.state.canStartJSXElement = !1), this.next()
          const o = this.startNodeAt(r, i)
          return (o.expression = e), this.finishNode(o, 'TSNonNullExpression')
        }
        let a = !1
        if (this.match(18) && this.lookaheadCharCode() === 60) {
          if (n) return (s.stop = !0), e
          ;(s.optionalChainMember = a = !0), this.next()
        }
        if (this.match(47) || this.match(51)) {
          let o
          const u = this.tsTryParseAndCatch(() => {
            if (!n && this.atPossibleAsyncArrow(e)) {
              const h = this.tsTryParseGenericAsyncArrowFunction(r, i)
              if (h) return h
            }
            const c = this.tsParseTypeArgumentsInExpression()
            if (!c) throw this.unexpected()
            if (a && !this.match(10)) throw ((o = this.state.curPosition()), this.unexpected())
            if (zo(this.state.type)) {
              const h = this.parseTaggedTemplateExpression(e, r, i, s)
              return (h.typeParameters = c), h
            }
            if (!n && this.eat(10)) {
              const h = this.startNodeAt(r, i)
              return (
                (h.callee = e),
                (h.arguments = this.parseCallExpressionArguments(11, !1)),
                this.tsCheckForInvalidTypeCasts(h.arguments),
                (h.typeParameters = c),
                s.optionalChainMember && (h.optional = a),
                this.finishCallExpression(h, s.optionalChainMember)
              )
            }
            if (qK(this.state.type) && this.state.type !== 10) throw this.unexpected()
            const p = this.startNodeAt(r, i)
            return (p.expression = e), (p.typeParameters = c), this.finishNode(p, 'TSInstantiationExpression')
          })
          if ((o && this.unexpected(o, 10), u)) return u
        }
        return super.parseSubscript(e, r, i, n, s)
      }
      parseNewCallee(e) {
        var r
        super.parseNewCallee(e)
        const { callee: i } = e
        i.type === 'TSInstantiationExpression' &&
          !((r = i.extra) != null && r.parenthesized) &&
          ((e.typeParameters = i.typeParameters), (e.callee = i.expression))
      }
      parseExprOp(e, r, i, n) {
        if (Uo(58) > n && !this.hasPrecedingLineBreak() && this.isContextual(93)) {
          const s = this.startNodeAt(r, i)
          s.expression = e
          const a = this.tsTryNextParseConstantContext()
          return (
            a ? (s.typeAnnotation = a) : (s.typeAnnotation = this.tsNextThenParseType()),
            this.finishNode(s, 'TSAsExpression'),
            this.reScan_lt_gt(),
            this.parseExprOp(s, r, i, n)
          )
        }
        return super.parseExprOp(e, r, i, n)
      }
      checkReservedWord(e, r, i, n) {
        this.state.isAmbientContext || super.checkReservedWord(e, r, i, n)
      }
      checkDuplicateExports() {}
      parseImport(e) {
        if (((e.importKind = 'value'), mt(this.state.type) || this.match(55) || this.match(5))) {
          let i = this.lookahead()
          if (
            (this.isContextual(126) &&
              i.type !== 12 &&
              i.type !== 97 &&
              i.type !== 29 &&
              ((e.importKind = 'type'), this.next(), (i = this.lookahead())),
            mt(this.state.type) && i.type === 29)
          )
            return this.tsParseImportEqualsDeclaration(e)
        }
        const r = super.parseImport(e)
        return (
          r.importKind === 'type' &&
            r.specifiers.length > 1 &&
            r.specifiers[0].type === 'ImportDefaultSpecifier' &&
            this.raise(Ve.TypeImportCannotSpecifyDefaultAndNamed, { at: r }),
          r
        )
      }
      parseExport(e) {
        if (this.match(83))
          return (
            this.next(),
            this.isContextual(126) && this.lookaheadCharCode() !== 61
              ? ((e.importKind = 'type'), this.next())
              : (e.importKind = 'value'),
            this.tsParseImportEqualsDeclaration(e, !0)
          )
        if (this.eat(29)) {
          const r = e
          return (r.expression = this.parseExpression()), this.semicolon(), this.finishNode(r, 'TSExportAssignment')
        } else if (this.eatContextual(93)) {
          const r = e
          return (
            this.expectContextual(124),
            (r.id = this.parseIdentifier()),
            this.semicolon(),
            this.finishNode(r, 'TSNamespaceExportDeclaration')
          )
        } else
          return (
            this.isContextual(126) && this.lookahead().type === 5
              ? (this.next(), (e.exportKind = 'type'))
              : (e.exportKind = 'value'),
            super.parseExport(e)
          )
      }
      isAbstractClass() {
        return this.isContextual(120) && this.lookahead().type === 80
      }
      parseExportDefaultExpression() {
        if (this.isAbstractClass()) {
          const e = this.startNode()
          return this.next(), (e.abstract = !0), this.parseClass(e, !0, !0), e
        }
        if (this.match(125)) {
          const e = this.tsParseInterfaceDeclaration(this.startNode())
          if (e) return e
        }
        return super.parseExportDefaultExpression()
      }
      parseVarStatement(e, r, i = !1) {
        const { isAmbientContext: n } = this.state,
          s = super.parseVarStatement(e, r, i || n)
        if (!n) return s
        for (const { id: a, init: o } of s.declarations)
          !o ||
            (r !== 'const' || !!a.typeAnnotation
              ? this.raise(Ve.InitializerNotAllowedInAmbientContext, { at: o })
              : o.type !== 'StringLiteral' &&
                o.type !== 'BooleanLiteral' &&
                o.type !== 'NumericLiteral' &&
                o.type !== 'BigIntLiteral' &&
                (o.type !== 'TemplateLiteral' || o.expressions.length > 0) &&
                !ZK(o) &&
                this.raise(Ve.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference, { at: o }))
        return s
      }
      parseStatementContent(e, r) {
        if (this.match(75) && this.isLookaheadContextual('enum')) {
          const i = this.startNode()
          return this.expect(75), this.tsParseEnumDeclaration(i, { const: !0 })
        }
        if (this.isContextual(122)) return this.tsParseEnumDeclaration(this.startNode())
        if (this.isContextual(125)) {
          const i = this.tsParseInterfaceDeclaration(this.startNode())
          if (i) return i
        }
        return super.parseStatementContent(e, r)
      }
      parseAccessModifier() {
        return this.tsParseModifier(['public', 'protected', 'private'])
      }
      tsHasSomeModifiers(e, r) {
        return r.some((i) => (cg(i) ? e.accessibility === i : !!e[i]))
      }
      tsIsStartOfStaticBlocks() {
        return this.isContextual(104) && this.lookaheadCharCode() === 123
      }
      parseClassMember(e, r, i) {
        const n = ['declare', 'private', 'public', 'protected', 'override', 'abstract', 'readonly', 'static']
        this.tsParseModifiers({
          modified: r,
          allowedModifiers: n,
          disallowedModifiers: ['in', 'out'],
          stopOnStartOfClassStaticBlock: !0,
          errorTemplate: Ve.InvalidModifierOnTypeParameterPositions,
        })
        const s = () => {
          this.tsIsStartOfStaticBlocks()
            ? (this.next(),
              this.next(),
              this.tsHasSomeModifiers(r, n) &&
                this.raise(Ve.StaticBlockCannotHaveModifier, { at: this.state.curPosition() }),
              this.parseClassStaticBlock(e, r))
            : this.parseClassMemberWithIsStatic(e, r, i, !!r.static)
        }
        r.declare ? this.tsInAmbientContext(s) : s()
      }
      parseClassMemberWithIsStatic(e, r, i, n) {
        const s = this.tsTryParseIndexSignature(r)
        if (s) {
          e.body.push(s),
            r.abstract && this.raise(Ve.IndexSignatureHasAbstract, { at: r }),
            r.accessibility && this.raise(Ve.IndexSignatureHasAccessibility, { at: r, modifier: r.accessibility }),
            r.declare && this.raise(Ve.IndexSignatureHasDeclare, { at: r }),
            r.override && this.raise(Ve.IndexSignatureHasOverride, { at: r })
          return
        }
        !this.state.inAbstractClass && r.abstract && this.raise(Ve.NonAbstractClassHasAbstractMethod, { at: r }),
          r.override && (i.hadSuperClass || this.raise(Ve.OverrideNotInSubClass, { at: r })),
          super.parseClassMemberWithIsStatic(e, r, i, n)
      }
      parsePostMemberNameModifiers(e) {
        this.eat(17) && (e.optional = !0),
          e.readonly && this.match(10) && this.raise(Ve.ClassMethodHasReadonly, { at: e }),
          e.declare && this.match(10) && this.raise(Ve.ClassMethodHasDeclare, { at: e })
      }
      parseExpressionStatement(e, r) {
        return (
          (r.type === 'Identifier' ? this.tsParseExpressionStatement(e, r) : void 0) ||
          super.parseExpressionStatement(e, r)
        )
      }
      shouldParseExportDeclaration() {
        return this.tsIsDeclarationStart() ? !0 : super.shouldParseExportDeclaration()
      }
      parseConditional(e, r, i, n) {
        if (!this.state.maybeInArrowParameters || !this.match(17)) return super.parseConditional(e, r, i, n)
        const s = this.tryParse(() => super.parseConditional(e, r, i))
        return s.node
          ? (s.error && (this.state = s.failState), s.node)
          : (s.error && super.setOptionalParametersError(n, s.error), e)
      }
      parseParenItem(e, r, i) {
        if (
          ((e = super.parseParenItem(e, r, i)),
          this.eat(17) && ((e.optional = !0), this.resetEndLocation(e)),
          this.match(14))
        ) {
          const n = this.startNodeAt(r, i)
          return (
            (n.expression = e),
            (n.typeAnnotation = this.tsParseTypeAnnotation()),
            this.finishNode(n, 'TSTypeCastExpression')
          )
        }
        return e
      }
      parseExportDeclaration(e) {
        if (!this.state.isAmbientContext && this.isContextual(121))
          return this.tsInAmbientContext(() => this.parseExportDeclaration(e))
        const r = this.state.start,
          i = this.state.startLoc,
          n = this.eatContextual(121)
        if (n && (this.isContextual(121) || !this.shouldParseExportDeclaration()))
          throw this.raise(Ve.ExpectedAmbientAfterExportDeclare, { at: this.state.startLoc })
        const a = (mt(this.state.type) && this.tsTryParseExportDeclaration()) || super.parseExportDeclaration(e)
        return a
          ? ((a.type === 'TSInterfaceDeclaration' || a.type === 'TSTypeAliasDeclaration' || n) &&
              (e.exportKind = 'type'),
            n && (this.resetStartLocation(a, r, i), (a.declare = !0)),
            a)
          : null
      }
      parseClassId(e, r, i) {
        if ((!r || i) && this.isContextual(110)) return
        super.parseClassId(e, r, i, e.declare ? Z0 : X0)
        const n = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this))
        n && (e.typeParameters = n)
      }
      parseClassPropertyAnnotation(e) {
        !e.optional && this.eat(35) && (e.definite = !0)
        const r = this.tsTryParseTypeAnnotation()
        r && (e.typeAnnotation = r)
      }
      parseClassProperty(e) {
        if (
          (this.parseClassPropertyAnnotation(e),
          this.state.isAmbientContext &&
            this.match(29) &&
            this.raise(Ve.DeclareClassFieldHasInitializer, { at: this.state.startLoc }),
          e.abstract && this.match(29))
        ) {
          const { key: r } = e
          this.raise(Ve.AbstractPropertyHasInitializer, {
            at: this.state.startLoc,
            propertyName: r.type === 'Identifier' && !e.computed ? r.name : `[${this.input.slice(r.start, r.end)}]`,
          })
        }
        return super.parseClassProperty(e)
      }
      parseClassPrivateProperty(e) {
        return (
          e.abstract && this.raise(Ve.PrivateElementHasAbstract, { at: e }),
          e.accessibility && this.raise(Ve.PrivateElementHasAccessibility, { at: e, modifier: e.accessibility }),
          this.parseClassPropertyAnnotation(e),
          super.parseClassPrivateProperty(e)
        )
      }
      pushClassMethod(e, r, i, n, s, a) {
        const o = this.tsTryParseTypeParameters()
        o && s && this.raise(Ve.ConstructorHasTypeParameters, { at: o })
        const { declare: u = !1, kind: c } = r
        u && (c === 'get' || c === 'set') && this.raise(Ve.DeclareAccessor, { at: r, kind: c }),
          o && (r.typeParameters = o),
          super.pushClassMethod(e, r, i, n, s, a)
      }
      pushClassPrivateMethod(e, r, i, n) {
        const s = this.tsTryParseTypeParameters()
        s && (r.typeParameters = s), super.pushClassPrivateMethod(e, r, i, n)
      }
      declareClassPrivateMethodInScope(e, r) {
        e.type !== 'TSDeclareMethod' &&
          ((e.type === 'MethodDefinition' && !e.value.body) || super.declareClassPrivateMethodInScope(e, r))
      }
      parseClassSuper(e) {
        super.parseClassSuper(e),
          e.superClass &&
            (this.match(47) || this.match(51)) &&
            (e.superTypeParameters = this.tsParseTypeArgumentsInExpression()),
          this.eatContextual(110) && (e.implements = this.tsParseHeritageClause('implements'))
      }
      parseObjPropValue(e, ...r) {
        const i = this.tsTryParseTypeParameters()
        i && (e.typeParameters = i), super.parseObjPropValue(e, ...r)
      }
      parseFunctionParams(e, r) {
        const i = this.tsTryParseTypeParameters()
        i && (e.typeParameters = i), super.parseFunctionParams(e, r)
      }
      parseVarId(e, r) {
        super.parseVarId(e, r),
          e.id.type === 'Identifier' && !this.hasPrecedingLineBreak() && this.eat(35) && (e.definite = !0)
        const i = this.tsTryParseTypeAnnotation()
        i && ((e.id.typeAnnotation = i), this.resetEndLocation(e.id))
      }
      parseAsyncArrowFromCallExpression(e, r) {
        return (
          this.match(14) && (e.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(e, r)
        )
      }
      parseMaybeAssign(...e) {
        var r, i, n, s, a, o, u
        let c, p, h
        if (this.hasPlugin('jsx') && (this.match(138) || this.match(47))) {
          if (((c = this.state.clone()), (p = this.tryParse(() => super.parseMaybeAssign(...e), c)), !p.error))
            return p.node
          const { context: T } = this.state,
            y = T[T.length - 1]
          ;(y === Tt.j_oTag || y === Tt.j_expr) && T.pop()
        }
        if (!((r = p) != null && r.error) && !this.match(47)) return super.parseMaybeAssign(...e)
        let f
        c = c || this.state.clone()
        const d = this.tryParse((T) => {
          var y, b, m
          f = this.tsParseTypeParameters()
          const S = super.parseMaybeAssign(...e)
          return (
            (S.type !== 'ArrowFunctionExpression' || ((y = S.extra) != null && y.parenthesized)) && T(),
            ((b = f) == null ? void 0 : b.params.length) !== 0 && this.resetStartLocationFromNode(S, f),
            (S.typeParameters = f),
            this.hasPlugin('jsx') &&
              S.typeParameters.params.length === 1 &&
              !((m = S.typeParameters.extra) != null && m.trailingComma) &&
              S.typeParameters.params[0].constraint,
            S
          )
        }, c)
        if (!d.error && !d.aborted) return f && this.reportReservedArrowTypeParam(f), d.node
        if (!p && (ug(!this.hasPlugin('jsx')), (h = this.tryParse(() => super.parseMaybeAssign(...e), c)), !h.error))
          return h.node
        if ((i = p) != null && i.node) return (this.state = p.failState), p.node
        if (d.node) return (this.state = d.failState), f && this.reportReservedArrowTypeParam(f), d.node
        if ((n = h) != null && n.node) return (this.state = h.failState), h.node
        throw (s = p) != null && s.thrown
          ? p.error
          : d.thrown
          ? d.error
          : (a = h) != null && a.thrown
          ? h.error
          : ((o = p) == null ? void 0 : o.error) || d.error || ((u = h) == null ? void 0 : u.error)
      }
      reportReservedArrowTypeParam(e) {
        var r
        e.params.length === 1 &&
          !((r = e.extra) != null && r.trailingComma) &&
          this.getPluginOption('typescript', 'disallowAmbiguousJSXLike') &&
          this.raise(Ve.ReservedArrowTypeParam, { at: e })
      }
      parseMaybeUnary(e) {
        return !this.hasPlugin('jsx') && this.match(47) ? this.tsParseTypeAssertion() : super.parseMaybeUnary(e)
      }
      parseArrow(e) {
        if (this.match(14)) {
          const r = this.tryParse((i) => {
            const n = this.tsParseTypeOrTypePredicateAnnotation(14)
            return (this.canInsertSemicolon() || !this.match(19)) && i(), n
          })
          if (r.aborted) return
          r.thrown || (r.error && (this.state = r.failState), (e.returnType = r.node))
        }
        return super.parseArrow(e)
      }
      parseAssignableListItemTypes(e) {
        this.eat(17) &&
          (e.type !== 'Identifier' &&
            !this.state.isAmbientContext &&
            !this.state.inType &&
            this.raise(Ve.PatternIsOptional, { at: e }),
          (e.optional = !0))
        const r = this.tsTryParseTypeAnnotation()
        return r && (e.typeAnnotation = r), this.resetEndLocation(e), e
      }
      isAssignable(e, r) {
        switch (e.type) {
          case 'TSTypeCastExpression':
            return this.isAssignable(e.expression, r)
          case 'TSParameterProperty':
            return !0
          default:
            return super.isAssignable(e, r)
        }
      }
      toAssignable(e, r = !1) {
        switch (e.type) {
          case 'ParenthesizedExpression':
            this.toAssignableParenthesizedExpression(e, r)
            break
          case 'TSAsExpression':
          case 'TSNonNullExpression':
          case 'TSTypeAssertion':
            r
              ? this.expressionScope.recordArrowParemeterBindingError(Ve.UnexpectedTypeCastInParameter, { at: e })
              : this.raise(Ve.UnexpectedTypeCastInParameter, { at: e }),
              this.toAssignable(e.expression, r)
            break
          case 'AssignmentExpression':
            !r && e.left.type === 'TSTypeCastExpression' && (e.left = this.typeCastToParameter(e.left))
          default:
            super.toAssignable(e, r)
        }
      }
      toAssignableParenthesizedExpression(e, r) {
        switch (e.expression.type) {
          case 'TSAsExpression':
          case 'TSNonNullExpression':
          case 'TSTypeAssertion':
          case 'ParenthesizedExpression':
            this.toAssignable(e.expression, r)
            break
          default:
            super.toAssignable(e, r)
        }
      }
      checkToRestConversion(e, r) {
        switch (e.type) {
          case 'TSAsExpression':
          case 'TSTypeAssertion':
          case 'TSNonNullExpression':
            this.checkToRestConversion(e.expression, !1)
            break
          default:
            super.checkToRestConversion(e, r)
        }
      }
      isValidLVal(e, r, i) {
        return (
          YK(
            {
              TSTypeCastExpression: !0,
              TSParameterProperty: 'parameter',
              TSNonNullExpression: 'expression',
              TSAsExpression: (i !== cn || !r) && ['expression', !0],
              TSTypeAssertion: (i !== cn || !r) && ['expression', !0],
            },
            e
          ) || super.isValidLVal(e, r, i)
        )
      }
      parseBindingAtom() {
        switch (this.state.type) {
          case 78:
            return this.parseIdentifier(!0)
          default:
            return super.parseBindingAtom()
        }
      }
      parseMaybeDecoratorArguments(e) {
        if (this.match(47) || this.match(51)) {
          const r = this.tsParseTypeArgumentsInExpression()
          if (this.match(10)) {
            const i = super.parseMaybeDecoratorArguments(e)
            return (i.typeParameters = r), i
          }
          this.unexpected(null, 10)
        }
        return super.parseMaybeDecoratorArguments(e)
      }
      checkCommaAfterRest(e) {
        return this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === e
          ? (this.next(), !1)
          : super.checkCommaAfterRest(e)
      }
      isClassMethod() {
        return this.match(47) || super.isClassMethod()
      }
      isClassProperty() {
        return this.match(35) || this.match(14) || super.isClassProperty()
      }
      parseMaybeDefault(...e) {
        const r = super.parseMaybeDefault(...e)
        return (
          r.type === 'AssignmentPattern' &&
            r.typeAnnotation &&
            r.right.start < r.typeAnnotation.start &&
            this.raise(Ve.TypeAnnotationAfterAssign, { at: r.typeAnnotation }),
          r
        )
      }
      getTokenFromCode(e) {
        if (this.state.inType) {
          if (e === 62) return this.finishOp(48, 1)
          if (e === 60) return this.finishOp(47, 1)
        }
        return super.getTokenFromCode(e)
      }
      reScan_lt_gt() {
        const { type: e } = this.state
        e === 47
          ? ((this.state.pos -= 1), this.readToken_lt())
          : e === 48 && ((this.state.pos -= 1), this.readToken_gt())
      }
      reScan_lt() {
        const { type: e } = this.state
        return e === 51 ? ((this.state.pos -= 2), this.finishOp(47, 1), 47) : e
      }
      toAssignableList(e) {
        for (let r = 0; r < e.length; r++) {
          const i = e[r]
          ;(i == null ? void 0 : i.type) === 'TSTypeCastExpression' && (e[r] = this.typeCastToParameter(i))
        }
        super.toAssignableList(...arguments)
      }
      typeCastToParameter(e) {
        return (
          (e.expression.typeAnnotation = e.typeAnnotation),
          this.resetEndLocation(e.expression, e.typeAnnotation.loc.end),
          e.expression
        )
      }
      shouldParseArrow(e) {
        return this.match(14) ? e.every((r) => this.isAssignable(r, !0)) : super.shouldParseArrow(e)
      }
      shouldParseAsyncArrow() {
        return this.match(14) || super.shouldParseAsyncArrow()
      }
      canHaveLeadingDecorator() {
        return super.canHaveLeadingDecorator() || this.isAbstractClass()
      }
      jsxParseOpeningElementAfterName(e) {
        if (this.match(47) || this.match(51)) {
          const r = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression())
          r && (e.typeParameters = r)
        }
        return super.jsxParseOpeningElementAfterName(e)
      }
      getGetterSetterExpectedParamCount(e) {
        const r = super.getGetterSetterExpectedParamCount(e),
          n = this.getObjectOrClassMethodParams(e)[0]
        return n && this.isThisParam(n) ? r + 1 : r
      }
      parseCatchClauseParam() {
        const e = super.parseCatchClauseParam(),
          r = this.tsTryParseTypeAnnotation()
        return r && ((e.typeAnnotation = r), this.resetEndLocation(e)), e
      }
      tsInAmbientContext(e) {
        const r = this.state.isAmbientContext
        this.state.isAmbientContext = !0
        try {
          return e()
        } finally {
          this.state.isAmbientContext = r
        }
      }
      parseClass(e, ...r) {
        const i = this.state.inAbstractClass
        this.state.inAbstractClass = !!e.abstract
        try {
          return super.parseClass(e, ...r)
        } finally {
          this.state.inAbstractClass = i
        }
      }
      tsParseAbstractDeclaration(e) {
        if (this.match(80)) return (e.abstract = !0), this.parseClass(e, !0, !1)
        if (this.isContextual(125)) {
          if (!this.hasFollowingLineBreak())
            return (
              (e.abstract = !0),
              this.raise(Ve.NonClassMethodPropertyHasAbstractModifer, { at: e }),
              this.tsParseInterfaceDeclaration(e)
            )
        } else this.unexpected(null, 80)
      }
      parseMethod(...e) {
        const r = super.parseMethod(...e)
        if (r.abstract && (this.hasPlugin('estree') ? !!r.value.body : !!r.body)) {
          const { key: n } = r
          this.raise(Ve.AbstractMethodHasImplementation, {
            at: r,
            methodName: n.type === 'Identifier' && !r.computed ? n.name : `[${this.input.slice(n.start, n.end)}]`,
          })
        }
        return r
      }
      tsParseTypeParameterName() {
        return this.parseIdentifier().name
      }
      shouldParseAsAmbientContext() {
        return !!this.getPluginOption('typescript', 'dts')
      }
      parse() {
        return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.parse()
      }
      getExpression() {
        return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.getExpression()
      }
      parseExportSpecifier(e, r, i, n) {
        return !r && n
          ? (this.parseTypeOnlyImportExportSpecifier(e, !1, i), this.finishNode(e, 'ExportSpecifier'))
          : ((e.exportKind = 'value'), super.parseExportSpecifier(e, r, i, n))
      }
      parseImportSpecifier(e, r, i, n) {
        return !r && n
          ? (this.parseTypeOnlyImportExportSpecifier(e, !0, i), this.finishNode(e, 'ImportSpecifier'))
          : ((e.importKind = 'value'), super.parseImportSpecifier(e, r, i, n))
      }
      parseTypeOnlyImportExportSpecifier(e, r, i) {
        const n = r ? 'imported' : 'local',
          s = r ? 'local' : 'exported'
        let a = e[n],
          o,
          u = !1,
          c = !0
        const p = a.loc.start
        if (this.isContextual(93)) {
          const f = this.parseIdentifier()
          if (this.isContextual(93)) {
            const d = this.parseIdentifier()
            ri(this.state.type)
              ? ((u = !0), (a = f), (o = r ? this.parseIdentifier() : this.parseModuleExportName()), (c = !1))
              : ((o = d), (c = !1))
          } else
            ri(this.state.type)
              ? ((c = !1), (o = r ? this.parseIdentifier() : this.parseModuleExportName()))
              : ((u = !0), (a = f))
        } else
          ri(this.state.type) &&
            ((u = !0),
            r
              ? ((a = this.parseIdentifier(!0)),
                this.isContextual(93) || this.checkReservedWord(a.name, a.loc.start, !0, !0))
              : (a = this.parseModuleExportName()))
        u && i && this.raise(r ? Ve.TypeModifierIsUsedInTypeImports : Ve.TypeModifierIsUsedInTypeExports, { at: p }),
          (e[n] = a),
          (e[s] = o)
        const h = r ? 'importKind' : 'exportKind'
        ;(e[h] = u ? 'type' : 'value'),
          c && this.eatContextual(93) && (e[s] = r ? this.parseIdentifier() : this.parseModuleExportName()),
          e[s] || (e[s] = li(e[n])),
          r && this.checkIdentifier(e[s], oi)
      }
    }
  function ZK(t) {
    if (t.type !== 'MemberExpression') return !1
    const { computed: e, property: r } = t
    return e && r.type !== 'StringLiteral' && (r.type !== 'TemplateLiteral' || r.expressions.length > 0)
      ? !1
      : pg(t.object)
  }
  function pg(t) {
    return t.type === 'Identifier' ? !0 : t.type !== 'MemberExpression' || t.computed ? !1 : pg(t.object)
  }
  const fg = ei`placeholders`((t) => ({
    ClassNameIsRequired: t('A class name is required.'),
    UnexpectedSpace: t('Unexpected space in placeholder.'),
  }))
  var QK = (t) =>
      class extends t {
        parsePlaceholder(e) {
          if (this.match(140)) {
            const r = this.startNode()
            return (
              this.next(),
              this.assertNoSpace(),
              (r.name = super.parseIdentifier(!0)),
              this.assertNoSpace(),
              this.expect(140),
              this.finishPlaceholder(r, e)
            )
          }
        }
        finishPlaceholder(e, r) {
          const i = !!(e.expectedNode && e.type === 'Placeholder')
          return (e.expectedNode = r), i ? e : this.finishNode(e, 'Placeholder')
        }
        getTokenFromCode(e) {
          return e === 37 && this.input.charCodeAt(this.state.pos + 1) === 37
            ? this.finishOp(140, 2)
            : super.getTokenFromCode(...arguments)
        }
        parseExprAtom() {
          return this.parsePlaceholder('Expression') || super.parseExprAtom(...arguments)
        }
        parseIdentifier() {
          return this.parsePlaceholder('Identifier') || super.parseIdentifier(...arguments)
        }
        checkReservedWord(e) {
          e !== void 0 && super.checkReservedWord(...arguments)
        }
        parseBindingAtom() {
          return this.parsePlaceholder('Pattern') || super.parseBindingAtom(...arguments)
        }
        isValidLVal(e, ...r) {
          return e === 'Placeholder' || super.isValidLVal(e, ...r)
        }
        toAssignable(e) {
          e && e.type === 'Placeholder' && e.expectedNode === 'Expression'
            ? (e.expectedNode = 'Pattern')
            : super.toAssignable(...arguments)
        }
        isLet(e) {
          return super.isLet(e) ? !0 : !this.isContextual(99) || e ? !1 : this.lookahead().type === 140
        }
        verifyBreakContinue(e) {
          ;(e.label && e.label.type === 'Placeholder') || super.verifyBreakContinue(...arguments)
        }
        parseExpressionStatement(e, r) {
          if (r.type !== 'Placeholder' || (r.extra && r.extra.parenthesized))
            return super.parseExpressionStatement(...arguments)
          if (this.match(14)) {
            const i = e
            return (
              (i.label = this.finishPlaceholder(r, 'Identifier')),
              this.next(),
              (i.body = this.parseStatement('label')),
              this.finishNode(i, 'LabeledStatement')
            )
          }
          return this.semicolon(), (e.name = r.name), this.finishPlaceholder(e, 'Statement')
        }
        parseBlock() {
          return this.parsePlaceholder('BlockStatement') || super.parseBlock(...arguments)
        }
        parseFunctionId() {
          return this.parsePlaceholder('Identifier') || super.parseFunctionId(...arguments)
        }
        parseClass(e, r, i) {
          const n = r ? 'ClassDeclaration' : 'ClassExpression'
          this.next(), this.takeDecorators(e)
          const s = this.state.strict,
            a = this.parsePlaceholder('Identifier')
          if (a)
            if (this.match(81) || this.match(140) || this.match(5)) e.id = a
            else {
              if (i || !r)
                return (e.id = null), (e.body = this.finishPlaceholder(a, 'ClassBody')), this.finishNode(e, n)
              throw this.raise(fg.ClassNameIsRequired, { at: this.state.startLoc })
            }
          else this.parseClassId(e, r, i)
          return (
            this.parseClassSuper(e),
            (e.body = this.parsePlaceholder('ClassBody') || this.parseClassBody(!!e.superClass, s)),
            this.finishNode(e, n)
          )
        }
        parseExport(e) {
          const r = this.parsePlaceholder('Identifier')
          if (!r) return super.parseExport(...arguments)
          if (!this.isContextual(97) && !this.match(12))
            return (
              (e.specifiers = []),
              (e.source = null),
              (e.declaration = this.finishPlaceholder(r, 'Declaration')),
              this.finishNode(e, 'ExportNamedDeclaration')
            )
          this.expectPlugin('exportDefaultFrom')
          const i = this.startNode()
          return (i.exported = r), (e.specifiers = [this.finishNode(i, 'ExportDefaultSpecifier')]), super.parseExport(e)
        }
        isExportDefaultSpecifier() {
          if (this.match(65)) {
            const e = this.nextTokenStart()
            if (this.isUnparsedContextual(e, 'from') && this.input.startsWith(Ei(140), this.nextTokenStartSince(e + 4)))
              return !0
          }
          return super.isExportDefaultSpecifier()
        }
        maybeParseExportDefaultSpecifier(e) {
          return e.specifiers && e.specifiers.length > 0 ? !0 : super.maybeParseExportDefaultSpecifier(...arguments)
        }
        checkExport(e) {
          const { specifiers: r } = e
          r != null && r.length && (e.specifiers = r.filter((i) => i.exported.type === 'Placeholder')),
            super.checkExport(e),
            (e.specifiers = r)
        }
        parseImport(e) {
          const r = this.parsePlaceholder('Identifier')
          if (!r) return super.parseImport(...arguments)
          if (((e.specifiers = []), !this.isContextual(97) && !this.match(12)))
            return (
              (e.source = this.finishPlaceholder(r, 'StringLiteral')),
              this.semicolon(),
              this.finishNode(e, 'ImportDeclaration')
            )
          const i = this.startNodeAtNode(r)
          return (
            (i.local = r),
            this.finishNode(i, 'ImportDefaultSpecifier'),
            e.specifiers.push(i),
            this.eat(12) && (this.maybeParseStarImportSpecifier(e) || this.parseNamedImportSpecifiers(e)),
            this.expectContextual(97),
            (e.source = this.parseImportSource()),
            this.semicolon(),
            this.finishNode(e, 'ImportDeclaration')
          )
        }
        parseImportSource() {
          return this.parsePlaceholder('StringLiteral') || super.parseImportSource(...arguments)
        }
        assertNoSpace() {
          this.state.start > this.state.lastTokEndLoc.index &&
            this.raise(fg.UnexpectedSpace, { at: this.state.lastTokEndLoc })
        }
      },
    eW = (t) =>
      class extends t {
        parseV8Intrinsic() {
          if (this.match(54)) {
            const e = this.state.startLoc,
              r = this.startNode()
            if ((this.next(), mt(this.state.type))) {
              const i = this.parseIdentifierName(this.state.start),
                n = this.createIdentifier(r, i)
              if (((n.type = 'V8IntrinsicIdentifier'), this.match(10))) return n
            }
            this.unexpected(e)
          }
        }
        parseExprAtom() {
          return this.parseV8Intrinsic() || super.parseExprAtom(...arguments)
        }
      }
  function Yt(t, e) {
    const [r, i] = typeof e == 'string' ? [e, {}] : e,
      n = Object.keys(i),
      s = n.length === 0
    return t.some((a) => {
      if (typeof a == 'string') return s && a === r
      {
        const [o, u] = a
        if (o !== r) return !1
        for (const c of n) if (u[c] !== i[c]) return !1
        return !0
      }
    })
  }
  function Ks(t, e, r) {
    const i = t.find((n) => (Array.isArray(n) ? n[0] === e : n === e))
    return i && Array.isArray(i) ? i[1][r] : null
  }
  const hg = ['minimal', 'fsharp', 'hack', 'smart'],
    dg = ['^^', '@@', '^', '%', '#'],
    mg = ['hash', 'bar']
  function tW(t) {
    if (Yt(t, 'decorators')) {
      if (Yt(t, 'decorators-legacy')) throw new Error('Cannot use the decorators and decorators-legacy plugin together')
      const e = Ks(t, 'decorators', 'decoratorsBeforeExport')
      if (e == null)
        throw new Error(
          "The 'decorators' plugin requires a 'decoratorsBeforeExport' option, whose value must be a boolean. If you are migrating from Babylon/Babel 6 or want to use the old decorators proposal, you should use the 'decorators-legacy' plugin instead of 'decorators'."
        )
      if (typeof e != 'boolean') throw new Error("'decoratorsBeforeExport' must be a boolean.")
    }
    if (Yt(t, 'flow') && Yt(t, 'typescript')) throw new Error('Cannot combine flow and typescript plugins.')
    if (Yt(t, 'placeholders') && Yt(t, 'v8intrinsic'))
      throw new Error('Cannot combine placeholders and v8intrinsic plugins.')
    if (Yt(t, 'pipelineOperator')) {
      const e = Ks(t, 'pipelineOperator', 'proposal')
      if (!hg.includes(e)) {
        const i = hg.map((n) => `"${n}"`).join(', ')
        throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${i}.`)
      }
      const r = Yt(t, ['recordAndTuple', { syntaxType: 'hash' }])
      if (e === 'hack') {
        if (Yt(t, 'placeholders')) throw new Error('Cannot combine placeholders plugin and Hack-style pipes.')
        if (Yt(t, 'v8intrinsic')) throw new Error('Cannot combine v8intrinsic plugin and Hack-style pipes.')
        const i = Ks(t, 'pipelineOperator', 'topicToken')
        if (!dg.includes(i)) {
          const n = dg.map((s) => `"${s}"`).join(', ')
          throw new Error(
            `"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${n}.`
          )
        }
        if (i === '#' && r)
          throw new Error(
            'Plugin conflict between `["pipelineOperator", { proposal: "hack", topicToken: "#" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.'
          )
      } else if (e === 'smart' && r)
        throw new Error(
          'Plugin conflict between `["pipelineOperator", { proposal: "smart" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.'
        )
    }
    if (Yt(t, 'moduleAttributes')) {
      if (Yt(t, 'importAssertions')) throw new Error('Cannot combine importAssertions and moduleAttributes plugins.')
      if (Ks(t, 'moduleAttributes', 'version') !== 'may-2020')
        throw new Error(
          "The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'."
        )
    }
    if (Yt(t, 'recordAndTuple') && !mg.includes(Ks(t, 'recordAndTuple', 'syntaxType')))
      throw new Error(
        "'recordAndTuple' requires 'syntaxType' option whose value should be one of: " +
          mg.map((e) => `'${e}'`).join(', ')
      )
    if (Yt(t, 'asyncDoExpressions') && !Yt(t, 'doExpressions')) {
      const e = new Error(
        "'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins."
      )
      throw ((e.missingPlugins = 'doExpressions'), e)
    }
  }
  const yg = { estree: Dz, jsx: zK, flow: VK, typescript: JK, v8intrinsic: eW, placeholders: QK },
    rW = Object.keys(yg),
    gg = {
      sourceType: 'script',
      sourceFilename: void 0,
      startColumn: 0,
      startLine: 1,
      allowAwaitOutsideFunction: !1,
      allowReturnOutsideFunction: !1,
      allowImportExportEverywhere: !1,
      allowSuperOutsideMethod: !1,
      allowUndeclaredExports: !1,
      plugins: [],
      strictMode: null,
      ranges: !1,
      tokens: !1,
      createParenthesizedExpressions: !1,
      errorRecovery: !1,
      attachComment: !0,
    }
  function iW(t) {
    const e = {}
    for (const r of Object.keys(gg)) e[r] = t && t[r] != null ? t[r] : gg[r]
    return e
  }
  const nW = (t, e) => Object.hasOwnProperty.call(t, e) && t[e],
    Tg = (t) => (t.type === 'ParenthesizedExpression' ? Tg(t.expression) : t)
  class sW extends MK {
    toAssignable(e, r = !1) {
      var i, n
      let s
      switch (
        ((e.type === 'ParenthesizedExpression' || ((i = e.extra) != null && i.parenthesized)) &&
          ((s = Tg(e)),
          r
            ? s.type === 'Identifier'
              ? this.expressionScope.recordArrowParemeterBindingError(re.InvalidParenthesizedAssignment, { at: e })
              : s.type !== 'MemberExpression' && this.raise(re.InvalidParenthesizedAssignment, { at: e })
            : this.raise(re.InvalidParenthesizedAssignment, { at: e })),
        e.type)
      ) {
        case 'Identifier':
        case 'ObjectPattern':
        case 'ArrayPattern':
        case 'AssignmentPattern':
        case 'RestElement':
          break
        case 'ObjectExpression':
          e.type = 'ObjectPattern'
          for (let o = 0, u = e.properties.length, c = u - 1; o < u; o++) {
            var a
            const p = e.properties[o],
              h = o === c
            this.toAssignableObjectExpressionProp(p, h, r),
              h &&
                p.type === 'RestElement' &&
                (a = e.extra) != null &&
                a.trailingCommaLoc &&
                this.raise(re.RestTrailingComma, { at: e.extra.trailingCommaLoc })
          }
          break
        case 'ObjectProperty': {
          const { key: o, value: u } = e
          this.isPrivateName(o) && this.classScope.usePrivateName(this.getPrivateNameSV(o), o.loc.start),
            this.toAssignable(u, r)
          break
        }
        case 'SpreadElement':
          throw new Error(
            "Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller."
          )
        case 'ArrayExpression':
          ;(e.type = 'ArrayPattern'),
            this.toAssignableList(e.elements, (n = e.extra) == null ? void 0 : n.trailingCommaLoc, r)
          break
        case 'AssignmentExpression':
          e.operator !== '=' && this.raise(re.MissingEqInAssignment, { at: e.left.loc.end }),
            (e.type = 'AssignmentPattern'),
            delete e.operator,
            this.toAssignable(e.left, r)
          break
        case 'ParenthesizedExpression':
          this.toAssignable(s, r)
          break
      }
    }
    toAssignableObjectExpressionProp(e, r, i) {
      if (e.type === 'ObjectMethod')
        this.raise(e.kind === 'get' || e.kind === 'set' ? re.PatternHasAccessor : re.PatternHasMethod, { at: e.key })
      else if (e.type === 'SpreadElement') {
        e.type = 'RestElement'
        const n = e.argument
        this.checkToRestConversion(n, !1), this.toAssignable(n, i), r || this.raise(re.RestTrailingComma, { at: e })
      } else this.toAssignable(e, i)
    }
    toAssignableList(e, r, i) {
      const n = e.length - 1
      for (let s = 0; s <= n; s++) {
        const a = e[s]
        if (!!a) {
          if (a.type === 'SpreadElement') {
            a.type = 'RestElement'
            const o = a.argument
            this.checkToRestConversion(o, !0), this.toAssignable(o, i)
          } else this.toAssignable(a, i)
          a.type === 'RestElement' &&
            (s < n ? this.raise(re.RestTrailingComma, { at: a }) : r && this.raise(re.RestTrailingComma, { at: r }))
        }
      }
    }
    isAssignable(e, r) {
      switch (e.type) {
        case 'Identifier':
        case 'ObjectPattern':
        case 'ArrayPattern':
        case 'AssignmentPattern':
        case 'RestElement':
          return !0
        case 'ObjectExpression': {
          const i = e.properties.length - 1
          return e.properties.every(
            (n, s) => n.type !== 'ObjectMethod' && (s === i || n.type !== 'SpreadElement') && this.isAssignable(n)
          )
        }
        case 'ObjectProperty':
          return this.isAssignable(e.value)
        case 'SpreadElement':
          return this.isAssignable(e.argument)
        case 'ArrayExpression':
          return e.elements.every((i) => i === null || this.isAssignable(i))
        case 'AssignmentExpression':
          return e.operator === '='
        case 'ParenthesizedExpression':
          return this.isAssignable(e.expression)
        case 'MemberExpression':
        case 'OptionalMemberExpression':
          return !r
        default:
          return !1
      }
    }
    toReferencedList(e, r) {
      return e
    }
    toReferencedListDeep(e, r) {
      this.toReferencedList(e, r)
      for (const i of e) (i == null ? void 0 : i.type) === 'ArrayExpression' && this.toReferencedListDeep(i.elements)
    }
    parseSpread(e, r) {
      const i = this.startNode()
      return this.next(), (i.argument = this.parseMaybeAssignAllowIn(e, void 0, r)), this.finishNode(i, 'SpreadElement')
    }
    parseRestBinding() {
      const e = this.startNode()
      return this.next(), (e.argument = this.parseBindingAtom()), this.finishNode(e, 'RestElement')
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 0: {
          const e = this.startNode()
          return this.next(), (e.elements = this.parseBindingList(3, 93, !0)), this.finishNode(e, 'ArrayPattern')
        }
        case 5:
          return this.parseObjectLike(8, !0)
      }
      return this.parseIdentifier()
    }
    parseBindingList(e, r, i, n) {
      const s = []
      let a = !0
      for (; !this.eat(e); )
        if ((a ? (a = !1) : this.expect(12), i && this.match(12))) s.push(null)
        else {
          if (this.eat(e)) break
          if (this.match(21)) {
            if ((s.push(this.parseAssignableListItemTypes(this.parseRestBinding())), !this.checkCommaAfterRest(r))) {
              this.expect(e)
              break
            }
          } else {
            const o = []
            for (
              this.match(26) &&
              this.hasPlugin('decorators') &&
              this.raise(re.UnsupportedParameterDecorator, { at: this.state.startLoc });
              this.match(26);

            )
              o.push(this.parseDecorator())
            s.push(this.parseAssignableListItem(n, o))
          }
        }
      return s
    }
    parseBindingRestProperty(e) {
      return (
        this.next(),
        (e.argument = this.parseIdentifier()),
        this.checkCommaAfterRest(125),
        this.finishNode(e, 'RestElement')
      )
    }
    parseBindingProperty() {
      const e = this.startNode(),
        { type: r, start: i, startLoc: n } = this.state
      return r === 21
        ? this.parseBindingRestProperty(e)
        : (r === 134
            ? (this.expectPlugin('destructuringPrivate', n),
              this.classScope.usePrivateName(this.state.value, n),
              (e.key = this.parsePrivateName()))
            : this.parsePropertyName(e),
          (e.method = !1),
          this.parseObjPropValue(e, i, n, !1, !1, !0, !1),
          e)
    }
    parseAssignableListItem(e, r) {
      const i = this.parseMaybeDefault()
      this.parseAssignableListItemTypes(i)
      const n = this.parseMaybeDefault(i.start, i.loc.start, i)
      return r.length && (i.decorators = r), n
    }
    parseAssignableListItemTypes(e) {
      return e
    }
    parseMaybeDefault(e, r, i) {
      var n, s, a
      if (
        ((r = (n = r) != null ? n : this.state.startLoc),
        (e = (s = e) != null ? s : this.state.start),
        (i = (a = i) != null ? a : this.parseBindingAtom()),
        !this.eat(29))
      )
        return i
      const o = this.startNodeAt(e, r)
      return (o.left = i), (o.right = this.parseMaybeAssignAllowIn()), this.finishNode(o, 'AssignmentPattern')
    }
    isValidLVal(e, r, i) {
      return nW(
        {
          AssignmentPattern: 'left',
          RestElement: 'argument',
          ObjectProperty: 'value',
          ParenthesizedExpression: 'expression',
          ArrayPattern: 'elements',
          ObjectPattern: 'properties',
        },
        e
      )
    }
    checkLVal(
      e,
      {
        in: r,
        binding: i = cn,
        checkClashes: n = !1,
        strictModeChanged: s = !1,
        allowingSloppyLetBinding: a = !(i & Pi),
        hasParenthesizedAncestor: o = !1,
      }
    ) {
      var u
      const c = e.type
      if (this.isObjectMethod(e)) return
      if (c === 'MemberExpression') {
        i !== cn && this.raise(re.InvalidPropertyBindingPattern, { at: e })
        return
      }
      if (e.type === 'Identifier') {
        this.checkIdentifier(e, i, s, a)
        const { name: T } = e
        n && (n.has(T) ? this.raise(re.ParamDupe, { at: e }) : n.add(T))
        return
      }
      const p = this.isValidLVal(
        e.type,
        !(o || ((u = e.extra) != null && u.parenthesized)) && r.type === 'AssignmentExpression',
        i
      )
      if (p === !0) return
      if (p === !1) {
        const T = i === cn ? re.InvalidLhs : re.InvalidLhsBinding
        this.raise(T, {
          at: e,
          ancestor: r.type === 'UpdateExpression' ? { type: 'UpdateExpression', prefix: r.prefix } : { type: r.type },
        })
        return
      }
      const [h, f] = Array.isArray(p) ? p : [p, c === 'ParenthesizedExpression'],
        d = e.type === 'ArrayPattern' || e.type === 'ObjectPattern' || e.type === 'ParenthesizedExpression' ? e : r
      for (const T of [].concat(e[h]))
        T &&
          this.checkLVal(T, {
            in: d,
            binding: i,
            checkClashes: n,
            allowingSloppyLetBinding: a,
            strictModeChanged: s,
            hasParenthesizedAncestor: f,
          })
    }
    checkIdentifier(e, r, i = !1, n = !(r & Pi)) {
      this.state.strict &&
        (i ? K0(e.name, this.inModule) : z0(e.name)) &&
        (r === cn
          ? this.raise(re.StrictEvalArguments, { at: e, referenceName: e.name })
          : this.raise(re.StrictEvalArgumentsBinding, { at: e, bindingName: e.name })),
        !n && e.name === 'let' && this.raise(re.LetInLexicalBinding, { at: e }),
        r & cn || this.declareNameFromIdentifier(e, r)
    }
    declareNameFromIdentifier(e, r) {
      this.scope.declareName(e.name, r, e.loc.start)
    }
    checkToRestConversion(e, r) {
      switch (e.type) {
        case 'ParenthesizedExpression':
          this.checkToRestConversion(e.expression, r)
          break
        case 'Identifier':
        case 'MemberExpression':
          break
        case 'ArrayExpression':
        case 'ObjectExpression':
          if (r) break
        default:
          this.raise(re.InvalidRestAssignmentPattern, { at: e })
      }
    }
    checkCommaAfterRest(e) {
      return this.match(12)
        ? (this.raise(this.lookaheadCharCode() === e ? re.RestTrailingComma : re.ElementAfterRest, {
            at: this.state.startLoc,
          }),
          !0)
        : !1
    }
  }
  class aW extends sW {
    checkProto(e, r, i, n) {
      if (e.type === 'SpreadElement' || this.isObjectMethod(e) || e.computed || e.shorthand) return
      const s = e.key
      if ((s.type === 'Identifier' ? s.name : s.value) === '__proto__') {
        if (r) {
          this.raise(re.RecordNoProto, { at: s })
          return
        }
        i.used &&
          (n
            ? n.doubleProtoLoc === null && (n.doubleProtoLoc = s.loc.start)
            : this.raise(re.DuplicateProto, { at: s })),
          (i.used = !0)
      }
    }
    shouldExitDescending(e, r) {
      return e.type === 'ArrowFunctionExpression' && e.start === r
    }
    getExpression() {
      this.enterInitialScopes(), this.nextToken()
      const e = this.parseExpression()
      return (
        this.match(135) || this.unexpected(),
        this.finalizeRemainingComments(),
        (e.comments = this.state.comments),
        (e.errors = this.state.errors),
        this.options.tokens && (e.tokens = this.tokens),
        e
      )
    }
    parseExpression(e, r) {
      return e
        ? this.disallowInAnd(() => this.parseExpressionBase(r))
        : this.allowInAnd(() => this.parseExpressionBase(r))
    }
    parseExpressionBase(e) {
      const r = this.state.start,
        i = this.state.startLoc,
        n = this.parseMaybeAssign(e)
      if (this.match(12)) {
        const s = this.startNodeAt(r, i)
        for (s.expressions = [n]; this.eat(12); ) s.expressions.push(this.parseMaybeAssign(e))
        return this.toReferencedList(s.expressions), this.finishNode(s, 'SequenceExpression')
      }
      return n
    }
    parseMaybeAssignDisallowIn(e, r) {
      return this.disallowInAnd(() => this.parseMaybeAssign(e, r))
    }
    parseMaybeAssignAllowIn(e, r) {
      return this.allowInAnd(() => this.parseMaybeAssign(e, r))
    }
    setOptionalParametersError(e, r) {
      var i
      e.optionalParametersLoc = (i = r == null ? void 0 : r.loc) != null ? i : this.state.startLoc
    }
    parseMaybeAssign(e, r) {
      const i = this.state.start,
        n = this.state.startLoc
      if (this.isContextual(105) && this.prodParam.hasYield) {
        let u = this.parseYield()
        return r && (u = r.call(this, u, i, n)), u
      }
      let s
      e ? (s = !1) : ((e = new rl()), (s = !0))
      const { type: a } = this.state
      ;(a === 10 || mt(a)) && (this.state.potentialArrowAt = this.state.start)
      let o = this.parseMaybeConditional(e)
      if ((r && (o = r.call(this, o, i, n)), $z(this.state.type))) {
        const u = this.startNodeAt(i, n),
          c = this.state.value
        return (
          (u.operator = c),
          this.match(29)
            ? (this.toAssignable(o, !0),
              (u.left = o),
              e.doubleProtoLoc != null && e.doubleProtoLoc.index >= i && (e.doubleProtoLoc = null),
              e.shorthandAssignLoc != null && e.shorthandAssignLoc.index >= i && (e.shorthandAssignLoc = null),
              e.privateKeyLoc != null &&
                e.privateKeyLoc.index >= i &&
                (this.checkDestructuringPrivate(e), (e.privateKeyLoc = null)))
            : (u.left = o),
          this.next(),
          (u.right = this.parseMaybeAssign()),
          this.checkLVal(o, { in: this.finishNode(u, 'AssignmentExpression') }),
          u
        )
      } else s && this.checkExpressionErrors(e, !0)
      return o
    }
    parseMaybeConditional(e) {
      const r = this.state.start,
        i = this.state.startLoc,
        n = this.state.potentialArrowAt,
        s = this.parseExprOps(e)
      return this.shouldExitDescending(s, n) ? s : this.parseConditional(s, r, i, e)
    }
    parseConditional(e, r, i, n) {
      if (this.eat(17)) {
        const s = this.startNodeAt(r, i)
        return (
          (s.test = e),
          (s.consequent = this.parseMaybeAssignAllowIn()),
          this.expect(14),
          (s.alternate = this.parseMaybeAssign()),
          this.finishNode(s, 'ConditionalExpression')
        )
      }
      return e
    }
    parseMaybeUnaryOrPrivate(e) {
      return this.match(134) ? this.parsePrivateName() : this.parseMaybeUnary(e)
    }
    parseExprOps(e) {
      const r = this.state.start,
        i = this.state.startLoc,
        n = this.state.potentialArrowAt,
        s = this.parseMaybeUnaryOrPrivate(e)
      return this.shouldExitDescending(s, n) ? s : this.parseExprOp(s, r, i, -1)
    }
    parseExprOp(e, r, i, n) {
      if (this.isPrivateName(e)) {
        const a = this.getPrivateNameSV(e)
        ;(n >= Uo(58) || !this.prodParam.hasIn || !this.match(58)) &&
          this.raise(re.PrivateInExpectedIn, { at: e, identifierName: a }),
          this.classScope.usePrivateName(a, e.loc.start)
      }
      const s = this.state.type
      if (jz(s) && (this.prodParam.hasIn || !this.match(58))) {
        let a = Uo(s)
        if (a > n) {
          if (s === 39) {
            if ((this.expectPlugin('pipelineOperator'), this.state.inFSharpPipelineDirectBody)) return e
            this.checkPipelineAtInfixOperator(e, i)
          }
          const o = this.startNodeAt(r, i)
          ;(o.left = e), (o.operator = this.state.value)
          const u = s === 41 || s === 42,
            c = s === 40
          if (
            (c && (a = Uo(42)),
            this.next(),
            s === 39 &&
              this.hasPlugin(['pipelineOperator', { proposal: 'minimal' }]) &&
              this.state.type === 96 &&
              this.prodParam.hasAwait)
          )
            throw this.raise(re.UnexpectedAwaitAfterPipelineBody, { at: this.state.startLoc })
          ;(o.right = this.parseExprOpRightExpr(s, a)),
            this.finishNode(o, u || c ? 'LogicalExpression' : 'BinaryExpression')
          const p = this.state.type
          if ((c && (p === 41 || p === 42)) || (u && p === 40))
            throw this.raise(re.MixingCoalesceWithLogical, { at: this.state.startLoc })
          return this.parseExprOp(o, r, i, n)
        }
      }
      return e
    }
    parseExprOpRightExpr(e, r) {
      const i = this.state.start,
        n = this.state.startLoc
      switch (e) {
        case 39:
          switch (this.getPluginOption('pipelineOperator', 'proposal')) {
            case 'hack':
              return this.withTopicBindingContext(() => this.parseHackPipeBody())
            case 'smart':
              return this.withTopicBindingContext(() => {
                if (this.prodParam.hasYield && this.isContextual(105))
                  throw this.raise(re.PipeBodyIsTighter, { at: this.state.startLoc })
                return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(e, r), i, n)
              })
            case 'fsharp':
              return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(r))
          }
        default:
          return this.parseExprOpBaseRightExpr(e, r)
      }
    }
    parseExprOpBaseRightExpr(e, r) {
      const i = this.state.start,
        n = this.state.startLoc
      return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), i, n, Wz(e) ? r - 1 : r)
    }
    parseHackPipeBody() {
      var e
      const { startLoc: r } = this.state,
        i = this.parseMaybeAssign()
      return (
        Cz.has(i.type) &&
          !((e = i.extra) != null && e.parenthesized) &&
          this.raise(re.PipeUnparenthesizedBody, { at: r, type: i.type }),
        this.topicReferenceWasUsedInCurrentContext() || this.raise(re.PipeTopicUnused, { at: r }),
        i
      )
    }
    checkExponentialAfterUnary(e) {
      this.match(57) && this.raise(re.UnexpectedTokenUnaryExponentiation, { at: e.argument })
    }
    parseMaybeUnary(e, r) {
      const i = this.state.start,
        n = this.state.startLoc,
        s = this.isContextual(96)
      if (s && this.isAwaitAllowed()) {
        this.next()
        const c = this.parseAwait(i, n)
        return r || this.checkExponentialAfterUnary(c), c
      }
      const a = this.match(34),
        o = this.startNode()
      if (Vz(this.state.type)) {
        ;(o.operator = this.state.value), (o.prefix = !0), this.match(72) && this.expectPlugin('throwExpressions')
        const c = this.match(89)
        if (
          (this.next(),
          (o.argument = this.parseMaybeUnary(null, !0)),
          this.checkExpressionErrors(e, !0),
          this.state.strict && c)
        ) {
          const p = o.argument
          p.type === 'Identifier'
            ? this.raise(re.StrictDelete, { at: o })
            : this.hasPropertyAsPrivateName(p) && this.raise(re.DeletePrivateField, { at: o })
        }
        if (!a) return r || this.checkExponentialAfterUnary(o), this.finishNode(o, 'UnaryExpression')
      }
      const u = this.parseUpdate(o, a, e)
      if (s) {
        const { type: c } = this.state
        if ((this.hasPlugin('v8intrinsic') ? Cp(c) : Cp(c) && !this.match(54)) && !this.isAmbiguousAwait())
          return this.raiseOverwrite(re.AwaitNotInAsyncContext, { at: n }), this.parseAwait(i, n)
      }
      return u
    }
    parseUpdate(e, r, i) {
      if (r) return this.checkLVal(e.argument, { in: this.finishNode(e, 'UpdateExpression') }), e
      const n = this.state.start,
        s = this.state.startLoc
      let a = this.parseExprSubscripts(i)
      if (this.checkExpressionErrors(i, !1)) return a
      for (; _z(this.state.type) && !this.canInsertSemicolon(); ) {
        const o = this.startNodeAt(n, s)
        ;(o.operator = this.state.value),
          (o.prefix = !1),
          (o.argument = a),
          this.next(),
          this.checkLVal(a, { in: (a = this.finishNode(o, 'UpdateExpression')) })
      }
      return a
    }
    parseExprSubscripts(e) {
      const r = this.state.start,
        i = this.state.startLoc,
        n = this.state.potentialArrowAt,
        s = this.parseExprAtom(e)
      return this.shouldExitDescending(s, n) ? s : this.parseSubscripts(s, r, i)
    }
    parseSubscripts(e, r, i, n) {
      const s = { optionalChainMember: !1, maybeAsyncArrow: this.atPossibleAsyncArrow(e), stop: !1 }
      do (e = this.parseSubscript(e, r, i, n, s)), (s.maybeAsyncArrow = !1)
      while (!s.stop)
      return e
    }
    parseSubscript(e, r, i, n, s) {
      const { type: a } = this.state
      if (!n && a === 15) return this.parseBind(e, r, i, n, s)
      if (zo(a)) return this.parseTaggedTemplateExpression(e, r, i, s)
      let o = !1
      if (a === 18) {
        if (n && this.lookaheadCharCode() === 40) return (s.stop = !0), e
        ;(s.optionalChainMember = o = !0), this.next()
      }
      if (!n && this.match(10)) return this.parseCoverCallAndAsyncArrowHead(e, r, i, s, o)
      {
        const u = this.eat(0)
        return u || o || this.eat(16) ? this.parseMember(e, r, i, s, u, o) : ((s.stop = !0), e)
      }
    }
    parseMember(e, r, i, n, s, a) {
      const o = this.startNodeAt(r, i)
      return (
        (o.object = e),
        (o.computed = s),
        s
          ? ((o.property = this.parseExpression()), this.expect(3))
          : this.match(134)
          ? (e.type === 'Super' && this.raise(re.SuperPrivateField, { at: i }),
            this.classScope.usePrivateName(this.state.value, this.state.startLoc),
            (o.property = this.parsePrivateName()))
          : (o.property = this.parseIdentifier(!0)),
        n.optionalChainMember
          ? ((o.optional = a), this.finishNode(o, 'OptionalMemberExpression'))
          : this.finishNode(o, 'MemberExpression')
      )
    }
    parseBind(e, r, i, n, s) {
      const a = this.startNodeAt(r, i)
      return (
        (a.object = e),
        this.next(),
        (a.callee = this.parseNoCallExpr()),
        (s.stop = !0),
        this.parseSubscripts(this.finishNode(a, 'BindExpression'), r, i, n)
      )
    }
    parseCoverCallAndAsyncArrowHead(e, r, i, n, s) {
      const a = this.state.maybeInArrowParameters
      let o = null
      ;(this.state.maybeInArrowParameters = !0), this.next()
      let u = this.startNodeAt(r, i)
      u.callee = e
      const { maybeAsyncArrow: c, optionalChainMember: p } = n
      return (
        c && (this.expressionScope.enter(NK()), (o = new rl())),
        p && (u.optional = s),
        s
          ? (u.arguments = this.parseCallExpressionArguments(11))
          : (u.arguments = this.parseCallExpressionArguments(11, e.type === 'Import', e.type !== 'Super', u, o)),
        this.finishCallExpression(u, p),
        c && this.shouldParseAsyncArrow() && !s
          ? ((n.stop = !0),
            this.checkDestructuringPrivate(o),
            this.expressionScope.validateAsPattern(),
            this.expressionScope.exit(),
            (u = this.parseAsyncArrowFromCallExpression(this.startNodeAt(r, i), u)))
          : (c && (this.checkExpressionErrors(o, !0), this.expressionScope.exit()), this.toReferencedArguments(u)),
        (this.state.maybeInArrowParameters = a),
        u
      )
    }
    toReferencedArguments(e, r) {
      this.toReferencedListDeep(e.arguments, r)
    }
    parseTaggedTemplateExpression(e, r, i, n) {
      const s = this.startNodeAt(r, i)
      return (
        (s.tag = e),
        (s.quasi = this.parseTemplate(!0)),
        n.optionalChainMember && this.raise(re.OptionalChainingNoTemplate, { at: i }),
        this.finishNode(s, 'TaggedTemplateExpression')
      )
    }
    atPossibleAsyncArrow(e) {
      return (
        e.type === 'Identifier' &&
        e.name === 'async' &&
        this.state.lastTokEndLoc.index === e.end &&
        !this.canInsertSemicolon() &&
        e.end - e.start === 5 &&
        e.start === this.state.potentialArrowAt
      )
    }
    finishCallExpression(e, r) {
      if (e.callee.type === 'Import')
        if (
          (e.arguments.length === 2 && (this.hasPlugin('moduleAttributes') || this.expectPlugin('importAssertions')),
          e.arguments.length === 0 || e.arguments.length > 2)
        )
          this.raise(re.ImportCallArity, {
            at: e,
            maxArgumentCount: this.hasPlugin('importAssertions') || this.hasPlugin('moduleAttributes') ? 2 : 1,
          })
        else
          for (const i of e.arguments) i.type === 'SpreadElement' && this.raise(re.ImportCallSpreadArgument, { at: i })
      return this.finishNode(e, r ? 'OptionalCallExpression' : 'CallExpression')
    }
    parseCallExpressionArguments(e, r, i, n, s) {
      const a = []
      let o = !0
      const u = this.state.inFSharpPipelineDirectBody
      for (this.state.inFSharpPipelineDirectBody = !1; !this.eat(e); ) {
        if (o) o = !1
        else if ((this.expect(12), this.match(e))) {
          r &&
            !this.hasPlugin('importAssertions') &&
            !this.hasPlugin('moduleAttributes') &&
            this.raise(re.ImportCallArgumentTrailingComma, { at: this.state.lastTokStartLoc }),
            n && this.addTrailingCommaExtraToNode(n),
            this.next()
          break
        }
        a.push(this.parseExprListItem(!1, s, i))
      }
      return (this.state.inFSharpPipelineDirectBody = u), a
    }
    shouldParseAsyncArrow() {
      return this.match(19) && !this.canInsertSemicolon()
    }
    parseAsyncArrowFromCallExpression(e, r) {
      var i
      return (
        this.resetPreviousNodeTrailingComments(r),
        this.expect(19),
        this.parseArrowExpression(e, r.arguments, !0, (i = r.extra) == null ? void 0 : i.trailingCommaLoc),
        r.innerComments && Us(e, r.innerComments),
        r.callee.trailingComments && Us(e, r.callee.trailingComments),
        e
      )
    }
    parseNoCallExpr() {
      const e = this.state.start,
        r = this.state.startLoc
      return this.parseSubscripts(this.parseExprAtom(), e, r, !0)
    }
    parseExprAtom(e) {
      let r
      const { type: i } = this.state
      switch (i) {
        case 79:
          return this.parseSuper()
        case 83:
          return (
            (r = this.startNode()),
            this.next(),
            this.match(16)
              ? this.parseImportMetaProperty(r)
              : (this.match(10) || this.raise(re.UnsupportedImport, { at: this.state.lastTokStartLoc }),
                this.finishNode(r, 'Import'))
          )
        case 78:
          return (r = this.startNode()), this.next(), this.finishNode(r, 'ThisExpression')
        case 90:
          return this.parseDo(this.startNode(), !1)
        case 56:
        case 31:
          return this.readRegexp(), this.parseRegExpLiteral(this.state.value)
        case 130:
          return this.parseNumericLiteral(this.state.value)
        case 131:
          return this.parseBigIntLiteral(this.state.value)
        case 132:
          return this.parseDecimalLiteral(this.state.value)
        case 129:
          return this.parseStringLiteral(this.state.value)
        case 84:
          return this.parseNullLiteral()
        case 85:
          return this.parseBooleanLiteral(!0)
        case 86:
          return this.parseBooleanLiteral(!1)
        case 10: {
          const n = this.state.potentialArrowAt === this.state.start
          return this.parseParenAndDistinguishExpression(n)
        }
        case 2:
        case 1:
          return this.parseArrayLike(this.state.type === 2 ? 4 : 3, !1, !0)
        case 0:
          return this.parseArrayLike(3, !0, !1, e)
        case 6:
        case 7:
          return this.parseObjectLike(this.state.type === 6 ? 9 : 8, !1, !0)
        case 5:
          return this.parseObjectLike(8, !1, !1, e)
        case 68:
          return this.parseFunctionOrFunctionSent()
        case 26:
          this.parseDecorators()
        case 80:
          return (r = this.startNode()), this.takeDecorators(r), this.parseClass(r, !1)
        case 77:
          return this.parseNewOrNewTarget()
        case 25:
        case 24:
          return this.parseTemplate(!1)
        case 15: {
          ;(r = this.startNode()), this.next(), (r.object = null)
          const n = (r.callee = this.parseNoCallExpr())
          if (n.type === 'MemberExpression') return this.finishNode(r, 'BindExpression')
          throw this.raise(re.UnsupportedBind, { at: n })
        }
        case 134:
          return (
            this.raise(re.PrivateInExpectedIn, { at: this.state.startLoc, identifierName: this.state.value }),
            this.parsePrivateName()
          )
        case 33:
          return this.parseTopicReferenceThenEqualsSign(54, '%')
        case 32:
          return this.parseTopicReferenceThenEqualsSign(44, '^')
        case 37:
        case 38:
          return this.parseTopicReference('hack')
        case 44:
        case 54:
        case 27: {
          const n = this.getPluginOption('pipelineOperator', 'proposal')
          if (n) return this.parseTopicReference(n)
          throw this.unexpected()
        }
        case 47: {
          const n = this.input.codePointAt(this.nextTokenStart())
          if (ni(n) || n === 62) {
            this.expectOnePlugin(['jsx', 'flow', 'typescript'])
            break
          } else throw this.unexpected()
        }
        default:
          if (mt(i)) {
            if (this.isContextual(123) && this.lookaheadCharCode() === 123 && !this.hasFollowingLineBreak())
              return this.parseModuleExpression()
            const n = this.state.potentialArrowAt === this.state.start,
              s = this.state.containsEsc,
              a = this.parseIdentifier()
            if (!s && a.name === 'async' && !this.canInsertSemicolon()) {
              const { type: o } = this.state
              if (o === 68)
                return (
                  this.resetPreviousNodeTrailingComments(a),
                  this.next(),
                  this.parseFunction(this.startNodeAtNode(a), void 0, !0)
                )
              if (mt(o))
                return this.lookaheadCharCode() === 61 ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(a)) : a
              if (o === 90) return this.resetPreviousNodeTrailingComments(a), this.parseDo(this.startNodeAtNode(a), !0)
            }
            return n && this.match(19) && !this.canInsertSemicolon()
              ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(a), [a], !1))
              : a
          } else throw this.unexpected()
      }
    }
    parseTopicReferenceThenEqualsSign(e, r) {
      const i = this.getPluginOption('pipelineOperator', 'proposal')
      if (i)
        return (
          (this.state.type = e),
          (this.state.value = r),
          this.state.pos--,
          this.state.end--,
          (this.state.endLoc = Wt(this.state.endLoc, -1)),
          this.parseTopicReference(i)
        )
      throw this.unexpected()
    }
    parseTopicReference(e) {
      const r = this.startNode(),
        i = this.state.startLoc,
        n = this.state.type
      return this.next(), this.finishTopicReference(r, i, e, n)
    }
    finishTopicReference(e, r, i, n) {
      if (this.testTopicReferenceConfiguration(i, r, n)) {
        const s = i === 'smart' ? 'PipelinePrimaryTopicReference' : 'TopicReference'
        return (
          this.topicReferenceIsAllowedInCurrentContext() ||
            this.raise(i === 'smart' ? re.PrimaryTopicNotAllowed : re.PipeTopicUnbound, { at: r }),
          this.registerTopicReference(),
          this.finishNode(e, s)
        )
      } else throw this.raise(re.PipeTopicUnconfiguredToken, { at: r, token: Ei(n) })
    }
    testTopicReferenceConfiguration(e, r, i) {
      switch (e) {
        case 'hack':
          return this.hasPlugin(['pipelineOperator', { topicToken: Ei(i) }])
        case 'smart':
          return i === 27
        default:
          throw this.raise(re.PipeTopicRequiresHackPipes, { at: r })
      }
    }
    parseAsyncArrowUnaryFunction(e) {
      this.prodParam.enter(tl(!0, this.prodParam.hasYield))
      const r = [this.parseIdentifier()]
      return (
        this.prodParam.exit(),
        this.hasPrecedingLineBreak() && this.raise(re.LineTerminatorBeforeArrow, { at: this.state.curPosition() }),
        this.expect(19),
        this.parseArrowExpression(e, r, !0),
        e
      )
    }
    parseDo(e, r) {
      this.expectPlugin('doExpressions'), r && this.expectPlugin('asyncDoExpressions'), (e.async = r), this.next()
      const i = this.state.labels
      return (
        (this.state.labels = []),
        r
          ? (this.prodParam.enter(el), (e.body = this.parseBlock()), this.prodParam.exit())
          : (e.body = this.parseBlock()),
        (this.state.labels = i),
        this.finishNode(e, 'DoExpression')
      )
    }
    parseSuper() {
      const e = this.startNode()
      return (
        this.next(),
        this.match(10) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod
          ? this.raise(re.SuperNotAllowed, { at: e })
          : !this.scope.allowSuper &&
            !this.options.allowSuperOutsideMethod &&
            this.raise(re.UnexpectedSuper, { at: e }),
        !this.match(10) && !this.match(0) && !this.match(16) && this.raise(re.UnsupportedSuper, { at: e }),
        this.finishNode(e, 'Super')
      )
    }
    parsePrivateName() {
      const e = this.startNode(),
        r = this.startNodeAt(
          this.state.start + 1,
          new ln(this.state.curLine, this.state.start + 1 - this.state.lineStart, this.state.start + 1)
        ),
        i = this.state.value
      return this.next(), (e.id = this.createIdentifier(r, i)), this.finishNode(e, 'PrivateName')
    }
    parseFunctionOrFunctionSent() {
      const e = this.startNode()
      if ((this.next(), this.prodParam.hasYield && this.match(16))) {
        const r = this.createIdentifier(this.startNodeAtNode(e), 'function')
        return (
          this.next(),
          this.match(102) ? this.expectPlugin('functionSent') : this.hasPlugin('functionSent') || this.unexpected(),
          this.parseMetaProperty(e, r, 'sent')
        )
      }
      return this.parseFunction(e)
    }
    parseMetaProperty(e, r, i) {
      e.meta = r
      const n = this.state.containsEsc
      return (
        (e.property = this.parseIdentifier(!0)),
        (e.property.name !== i || n) &&
          this.raise(re.UnsupportedMetaProperty, { at: e.property, target: r.name, onlyValidPropertyName: i }),
        this.finishNode(e, 'MetaProperty')
      )
    }
    parseImportMetaProperty(e) {
      const r = this.createIdentifier(this.startNodeAtNode(e), 'import')
      return (
        this.next(),
        this.isContextual(100) &&
          (this.inModule || this.raise(re.ImportMetaOutsideModule, { at: r }), (this.sawUnambiguousESM = !0)),
        this.parseMetaProperty(e, r, 'meta')
      )
    }
    parseLiteralAtNode(e, r, i) {
      return (
        this.addExtra(i, 'rawValue', e),
        this.addExtra(i, 'raw', this.input.slice(i.start, this.state.end)),
        (i.value = e),
        this.next(),
        this.finishNode(i, r)
      )
    }
    parseLiteral(e, r) {
      const i = this.startNode()
      return this.parseLiteralAtNode(e, r, i)
    }
    parseStringLiteral(e) {
      return this.parseLiteral(e, 'StringLiteral')
    }
    parseNumericLiteral(e) {
      return this.parseLiteral(e, 'NumericLiteral')
    }
    parseBigIntLiteral(e) {
      return this.parseLiteral(e, 'BigIntLiteral')
    }
    parseDecimalLiteral(e) {
      return this.parseLiteral(e, 'DecimalLiteral')
    }
    parseRegExpLiteral(e) {
      const r = this.parseLiteral(e.value, 'RegExpLiteral')
      return (r.pattern = e.pattern), (r.flags = e.flags), r
    }
    parseBooleanLiteral(e) {
      const r = this.startNode()
      return (r.value = e), this.next(), this.finishNode(r, 'BooleanLiteral')
    }
    parseNullLiteral() {
      const e = this.startNode()
      return this.next(), this.finishNode(e, 'NullLiteral')
    }
    parseParenAndDistinguishExpression(e) {
      const r = this.state.start,
        i = this.state.startLoc
      let n
      this.next(), this.expressionScope.enter(kK())
      const s = this.state.maybeInArrowParameters,
        a = this.state.inFSharpPipelineDirectBody
      ;(this.state.maybeInArrowParameters = !0), (this.state.inFSharpPipelineDirectBody = !1)
      const o = this.state.start,
        u = this.state.startLoc,
        c = [],
        p = new rl()
      let h = !0,
        f,
        d
      for (; !this.match(11); ) {
        if (h) h = !1
        else if ((this.expect(12, p.optionalParametersLoc === null ? null : p.optionalParametersLoc), this.match(11))) {
          d = this.state.startLoc
          break
        }
        if (this.match(21)) {
          const b = this.state.start,
            m = this.state.startLoc
          if (
            ((f = this.state.startLoc),
            c.push(this.parseParenItem(this.parseRestBinding(), b, m)),
            !this.checkCommaAfterRest(41))
          )
            break
        } else c.push(this.parseMaybeAssignAllowIn(p, this.parseParenItem))
      }
      const T = this.state.lastTokEndLoc
      this.expect(11), (this.state.maybeInArrowParameters = s), (this.state.inFSharpPipelineDirectBody = a)
      let y = this.startNodeAt(r, i)
      return e && this.shouldParseArrow(c) && (y = this.parseArrow(y))
        ? (this.checkDestructuringPrivate(p),
          this.expressionScope.validateAsPattern(),
          this.expressionScope.exit(),
          this.parseArrowExpression(y, c, !1),
          y)
        : (this.expressionScope.exit(),
          c.length || this.unexpected(this.state.lastTokStartLoc),
          d && this.unexpected(d),
          f && this.unexpected(f),
          this.checkExpressionErrors(p, !0),
          this.toReferencedListDeep(c, !0),
          c.length > 1
            ? ((n = this.startNodeAt(o, u)),
              (n.expressions = c),
              this.finishNode(n, 'SequenceExpression'),
              this.resetEndLocation(n, T))
            : (n = c[0]),
          this.wrapParenthesis(r, i, n))
    }
    wrapParenthesis(e, r, i) {
      if (!this.options.createParenthesizedExpressions)
        return (
          this.addExtra(i, 'parenthesized', !0),
          this.addExtra(i, 'parenStart', e),
          this.takeSurroundingComments(i, e, this.state.lastTokEndLoc.index),
          i
        )
      const n = this.startNodeAt(e, r)
      return (n.expression = i), this.finishNode(n, 'ParenthesizedExpression'), n
    }
    shouldParseArrow(e) {
      return !this.canInsertSemicolon()
    }
    parseArrow(e) {
      if (this.eat(19)) return e
    }
    parseParenItem(e, r, i) {
      return e
    }
    parseNewOrNewTarget() {
      const e = this.startNode()
      if ((this.next(), this.match(16))) {
        const r = this.createIdentifier(this.startNodeAtNode(e), 'new')
        this.next()
        const i = this.parseMetaProperty(e, r, 'target')
        return !this.scope.inNonArrowFunction && !this.scope.inClass && this.raise(re.UnexpectedNewTarget, { at: i }), i
      }
      return this.parseNew(e)
    }
    parseNew(e) {
      if ((this.parseNewCallee(e), this.eat(10))) {
        const r = this.parseExprList(11)
        this.toReferencedList(r), (e.arguments = r)
      } else e.arguments = []
      return this.finishNode(e, 'NewExpression')
    }
    parseNewCallee(e) {
      ;(e.callee = this.parseNoCallExpr()),
        e.callee.type === 'Import'
          ? this.raise(re.ImportCallNotNewExpression, { at: e.callee })
          : this.isOptionalChain(e.callee)
          ? this.raise(re.OptionalChainingNoNew, { at: this.state.lastTokEndLoc })
          : this.eat(18) && this.raise(re.OptionalChainingNoNew, { at: this.state.startLoc })
    }
    parseTemplateElement(e) {
      const { start: r, startLoc: i, end: n, value: s } = this.state,
        a = r + 1,
        o = this.startNodeAt(a, Wt(i, 1))
      s === null && (e || this.raise(re.InvalidEscapeSequenceTemplate, { at: Wt(i, 2) }))
      const u = this.match(24),
        c = u ? -1 : -2,
        p = n + c
      return (
        (o.value = {
          raw: this.input.slice(a, p).replace(
            /\r\n?/g,
            `
`
          ),
          cooked: s === null ? null : s.slice(1, c),
        }),
        (o.tail = u),
        this.next(),
        this.finishNode(o, 'TemplateElement'),
        this.resetEndLocation(o, Wt(this.state.lastTokEndLoc, c)),
        o
      )
    }
    parseTemplate(e) {
      const r = this.startNode()
      r.expressions = []
      let i = this.parseTemplateElement(e)
      for (r.quasis = [i]; !i.tail; )
        r.expressions.push(this.parseTemplateSubstitution()),
          this.readTemplateContinuation(),
          r.quasis.push((i = this.parseTemplateElement(e)))
      return this.finishNode(r, 'TemplateLiteral')
    }
    parseTemplateSubstitution() {
      return this.parseExpression()
    }
    parseObjectLike(e, r, i, n) {
      i && this.expectPlugin('recordAndTuple')
      const s = this.state.inFSharpPipelineDirectBody
      this.state.inFSharpPipelineDirectBody = !1
      const a = Object.create(null)
      let o = !0
      const u = this.startNode()
      for (u.properties = [], this.next(); !this.match(e); ) {
        if (o) o = !1
        else if ((this.expect(12), this.match(e))) {
          this.addTrailingCommaExtraToNode(u)
          break
        }
        let p
        r ? (p = this.parseBindingProperty()) : ((p = this.parsePropertyDefinition(n)), this.checkProto(p, i, a, n)),
          i &&
            !this.isObjectProperty(p) &&
            p.type !== 'SpreadElement' &&
            this.raise(re.InvalidRecordProperty, { at: p }),
          p.shorthand && this.addExtra(p, 'shorthand', !0),
          u.properties.push(p)
      }
      this.next(), (this.state.inFSharpPipelineDirectBody = s)
      let c = 'ObjectExpression'
      return r ? (c = 'ObjectPattern') : i && (c = 'RecordExpression'), this.finishNode(u, c)
    }
    addTrailingCommaExtraToNode(e) {
      this.addExtra(e, 'trailingComma', this.state.lastTokStart),
        this.addExtra(e, 'trailingCommaLoc', this.state.lastTokStartLoc, !1)
    }
    maybeAsyncOrAccessorProp(e) {
      return (
        !e.computed && e.key.type === 'Identifier' && (this.isLiteralPropertyName() || this.match(0) || this.match(55))
      )
    }
    parsePropertyDefinition(e) {
      let r = []
      if (this.match(26))
        for (
          this.hasPlugin('decorators') && this.raise(re.UnsupportedPropertyDecorator, { at: this.state.startLoc });
          this.match(26);

        )
          r.push(this.parseDecorator())
      const i = this.startNode()
      let n = !1,
        s = !1,
        a,
        o
      if (this.match(21)) return r.length && this.unexpected(), this.parseSpread()
      r.length && ((i.decorators = r), (r = [])),
        (i.method = !1),
        e && ((a = this.state.start), (o = this.state.startLoc))
      let u = this.eat(55)
      this.parsePropertyNamePrefixOperator(i)
      const c = this.state.containsEsc,
        p = this.parsePropertyName(i, e)
      if (!u && !c && this.maybeAsyncOrAccessorProp(i)) {
        const h = p.name
        h === 'async' &&
          !this.hasPrecedingLineBreak() &&
          ((n = !0), this.resetPreviousNodeTrailingComments(p), (u = this.eat(55)), this.parsePropertyName(i)),
          (h === 'get' || h === 'set') &&
            ((s = !0),
            this.resetPreviousNodeTrailingComments(p),
            (i.kind = h),
            this.match(55) &&
              ((u = !0), this.raise(re.AccessorIsGenerator, { at: this.state.curPosition(), kind: h }), this.next()),
            this.parsePropertyName(i))
      }
      return this.parseObjPropValue(i, a, o, u, n, !1, s, e), i
    }
    getGetterSetterExpectedParamCount(e) {
      return e.kind === 'get' ? 0 : 1
    }
    getObjectOrClassMethodParams(e) {
      return e.params
    }
    checkGetterSetterParams(e) {
      var r
      const i = this.getGetterSetterExpectedParamCount(e),
        n = this.getObjectOrClassMethodParams(e)
      n.length !== i && this.raise(e.kind === 'get' ? re.BadGetterArity : re.BadSetterArity, { at: e }),
        e.kind === 'set' &&
          ((r = n[n.length - 1]) == null ? void 0 : r.type) === 'RestElement' &&
          this.raise(re.BadSetterRestParameter, { at: e })
    }
    parseObjectMethod(e, r, i, n, s) {
      if (s) return this.parseMethod(e, r, !1, !1, !1, 'ObjectMethod'), this.checkGetterSetterParams(e), e
      if (i || r || this.match(10))
        return (
          n && this.unexpected(),
          (e.kind = 'method'),
          (e.method = !0),
          this.parseMethod(e, r, i, !1, !1, 'ObjectMethod')
        )
    }
    parseObjectProperty(e, r, i, n, s) {
      if (((e.shorthand = !1), this.eat(14)))
        return (
          (e.value = n
            ? this.parseMaybeDefault(this.state.start, this.state.startLoc)
            : this.parseMaybeAssignAllowIn(s)),
          this.finishNode(e, 'ObjectProperty')
        )
      if (!e.computed && e.key.type === 'Identifier') {
        if ((this.checkReservedWord(e.key.name, e.key.loc.start, !0, !1), n))
          e.value = this.parseMaybeDefault(r, i, li(e.key))
        else if (this.match(29)) {
          const a = this.state.startLoc
          s != null
            ? s.shorthandAssignLoc === null && (s.shorthandAssignLoc = a)
            : this.raise(re.InvalidCoverInitializedName, { at: a }),
            (e.value = this.parseMaybeDefault(r, i, li(e.key)))
        } else e.value = li(e.key)
        return (e.shorthand = !0), this.finishNode(e, 'ObjectProperty')
      }
    }
    parseObjPropValue(e, r, i, n, s, a, o, u) {
      const c = this.parseObjectMethod(e, n, s, a, o) || this.parseObjectProperty(e, r, i, a, u)
      return c || this.unexpected(), c
    }
    parsePropertyName(e, r) {
      if (this.eat(0)) (e.computed = !0), (e.key = this.parseMaybeAssignAllowIn()), this.expect(3)
      else {
        const { type: i, value: n } = this.state
        let s
        if (ri(i)) s = this.parseIdentifier(!0)
        else
          switch (i) {
            case 130:
              s = this.parseNumericLiteral(n)
              break
            case 129:
              s = this.parseStringLiteral(n)
              break
            case 131:
              s = this.parseBigIntLiteral(n)
              break
            case 132:
              s = this.parseDecimalLiteral(n)
              break
            case 134: {
              const a = this.state.startLoc
              r != null
                ? r.privateKeyLoc === null && (r.privateKeyLoc = a)
                : this.raise(re.UnexpectedPrivateField, { at: a }),
                (s = this.parsePrivateName())
              break
            }
            default:
              throw this.unexpected()
          }
        ;(e.key = s), i !== 134 && (e.computed = !1)
      }
      return e.key
    }
    initFunction(e, r) {
      ;(e.id = null), (e.generator = !1), (e.async = !!r)
    }
    parseMethod(e, r, i, n, s, a, o = !1) {
      this.initFunction(e, i), (e.generator = !!r)
      const u = n
      return (
        this.scope.enter(si | Ko | (o ? un : 0) | (s ? Y0 : 0)),
        this.prodParam.enter(tl(i, e.generator)),
        this.parseFunctionParams(e, u),
        this.parseFunctionBodyAndFinish(e, a, !0),
        this.prodParam.exit(),
        this.scope.exit(),
        e
      )
    }
    parseArrayLike(e, r, i, n) {
      i && this.expectPlugin('recordAndTuple')
      const s = this.state.inFSharpPipelineDirectBody
      this.state.inFSharpPipelineDirectBody = !1
      const a = this.startNode()
      return (
        this.next(),
        (a.elements = this.parseExprList(e, !i, n, a)),
        (this.state.inFSharpPipelineDirectBody = s),
        this.finishNode(a, i ? 'TupleExpression' : 'ArrayExpression')
      )
    }
    parseArrowExpression(e, r, i, n) {
      this.scope.enter(si | Op)
      let s = tl(i, !1)
      !this.match(5) && this.prodParam.hasIn && (s |= Vn), this.prodParam.enter(s), this.initFunction(e, i)
      const a = this.state.maybeInArrowParameters
      return (
        r && ((this.state.maybeInArrowParameters = !0), this.setArrowFunctionParameters(e, r, n)),
        (this.state.maybeInArrowParameters = !1),
        this.parseFunctionBody(e, !0),
        this.prodParam.exit(),
        this.scope.exit(),
        (this.state.maybeInArrowParameters = a),
        this.finishNode(e, 'ArrowFunctionExpression')
      )
    }
    setArrowFunctionParameters(e, r, i) {
      this.toAssignableList(r, i, !1), (e.params = r)
    }
    parseFunctionBodyAndFinish(e, r, i = !1) {
      this.parseFunctionBody(e, !1, i), this.finishNode(e, r)
    }
    parseFunctionBody(e, r, i = !1) {
      const n = r && !this.match(5)
      if ((this.expressionScope.enter(sg()), n)) (e.body = this.parseMaybeAssign()), this.checkParams(e, !1, r, !1)
      else {
        const s = this.state.strict,
          a = this.state.labels
        ;(this.state.labels = []),
          this.prodParam.enter(this.prodParam.currentFlags() | og),
          (e.body = this.parseBlock(!0, !1, (o) => {
            const u = !this.isSimpleParamList(e.params)
            o &&
              u &&
              this.raise(re.IllegalLanguageModeDirective, {
                at: (e.kind === 'method' || e.kind === 'constructor') && !!e.key ? e.key.loc.end : e,
              })
            const c = !s && this.state.strict
            this.checkParams(e, !this.state.strict && !r && !i && !u, r, c),
              this.state.strict && e.id && this.checkIdentifier(e.id, nK, c)
          })),
          this.prodParam.exit(),
          (this.state.labels = a)
      }
      this.expressionScope.exit()
    }
    isSimpleParameter(e) {
      return e.type === 'Identifier'
    }
    isSimpleParamList(e) {
      for (let r = 0, i = e.length; r < i; r++) if (!this.isSimpleParameter(e[r])) return !1
      return !0
    }
    checkParams(e, r, i, n = !0) {
      const s = !r && new Set(),
        a = { type: 'FormalParameters' }
      for (const o of e.params) this.checkLVal(o, { in: a, binding: Xo, checkClashes: s, strictModeChanged: n })
    }
    parseExprList(e, r, i, n) {
      const s = []
      let a = !0
      for (; !this.eat(e); ) {
        if (a) a = !1
        else if ((this.expect(12), this.match(e))) {
          n && this.addTrailingCommaExtraToNode(n), this.next()
          break
        }
        s.push(this.parseExprListItem(r, i))
      }
      return s
    }
    parseExprListItem(e, r, i) {
      let n
      if (this.match(12))
        e || this.raise(re.UnexpectedToken, { at: this.state.curPosition(), unexpected: ',' }), (n = null)
      else if (this.match(21)) {
        const s = this.state.start,
          a = this.state.startLoc
        n = this.parseParenItem(this.parseSpread(r), s, a)
      } else if (this.match(17)) {
        this.expectPlugin('partialApplication'),
          i || this.raise(re.UnexpectedArgumentPlaceholder, { at: this.state.startLoc })
        const s = this.startNode()
        this.next(), (n = this.finishNode(s, 'ArgumentPlaceholder'))
      } else n = this.parseMaybeAssignAllowIn(r, this.parseParenItem)
      return n
    }
    parseIdentifier(e) {
      const r = this.startNode(),
        i = this.parseIdentifierName(r.start, e)
      return this.createIdentifier(r, i)
    }
    createIdentifier(e, r) {
      return (e.name = r), (e.loc.identifierName = r), this.finishNode(e, 'Identifier')
    }
    parseIdentifierName(e, r) {
      let i
      const { startLoc: n, type: s } = this.state
      if (ri(s)) i = this.state.value
      else throw this.unexpected()
      const a = Mz(s)
      return r ? a && this.replaceToken(128) : this.checkReservedWord(i, n, a, !1), this.next(), i
    }
    checkReservedWord(e, r, i, n) {
      if (e.length > 10 || !tK(e)) return
      if (e === 'yield') {
        if (this.prodParam.hasYield) {
          this.raise(re.YieldBindingIdentifier, { at: r })
          return
        }
      } else if (e === 'await') {
        if (this.prodParam.hasAwait) {
          this.raise(re.AwaitBindingIdentifier, { at: r })
          return
        }
        if (this.scope.inStaticBlock) {
          this.raise(re.AwaitBindingIdentifierInStaticBlock, { at: r })
          return
        }
        this.expressionScope.recordAsyncArrowParametersError({ at: r })
      } else if (e === 'arguments' && this.scope.inClassAndNotInNonArrowFunction) {
        this.raise(re.ArgumentsInClass, { at: r })
        return
      }
      if (i && Zz(e)) {
        this.raise(re.UnexpectedKeyword, { at: r, keyword: e })
        return
      }
      ;(this.state.strict ? (n ? K0 : U0) : V0)(e, this.inModule) &&
        this.raise(re.UnexpectedReservedWord, { at: r, reservedWord: e })
    }
    isAwaitAllowed() {
      return !!(this.prodParam.hasAwait || (this.options.allowAwaitOutsideFunction && !this.scope.inFunction))
    }
    parseAwait(e, r) {
      const i = this.startNodeAt(e, r)
      return (
        this.expressionScope.recordParameterInitializerError(re.AwaitExpressionFormalParameter, { at: i }),
        this.eat(55) && this.raise(re.ObsoleteAwaitStar, { at: i }),
        !this.scope.inFunction &&
          !this.options.allowAwaitOutsideFunction &&
          (this.isAmbiguousAwait() ? (this.ambiguousScriptDifferentAst = !0) : (this.sawUnambiguousESM = !0)),
        this.state.soloAwait || (i.argument = this.parseMaybeUnary(null, !0)),
        this.finishNode(i, 'AwaitExpression')
      )
    }
    isAmbiguousAwait() {
      if (this.hasPrecedingLineBreak()) return !0
      const { type: e } = this.state
      return (
        e === 53 || e === 10 || e === 0 || zo(e) || e === 133 || e === 56 || (this.hasPlugin('v8intrinsic') && e === 54)
      )
    }
    parseYield() {
      const e = this.startNode()
      this.expressionScope.recordParameterInitializerError(re.YieldInParameter, { at: e }), this.next()
      let r = !1,
        i = null
      if (!this.hasPrecedingLineBreak())
        switch (((r = this.eat(55)), this.state.type)) {
          case 13:
          case 135:
          case 8:
          case 11:
          case 3:
          case 9:
          case 14:
          case 12:
            if (!r) break
          default:
            i = this.parseMaybeAssign()
        }
      return (e.delegate = r), (e.argument = i), this.finishNode(e, 'YieldExpression')
    }
    checkPipelineAtInfixOperator(e, r) {
      this.hasPlugin(['pipelineOperator', { proposal: 'smart' }]) &&
        e.type === 'SequenceExpression' &&
        this.raise(re.PipelineHeadSequenceExpression, { at: r })
    }
    parseSmartPipelineBodyInStyle(e, r, i) {
      const n = this.startNodeAt(r, i)
      return this.isSimpleReference(e)
        ? ((n.callee = e), this.finishNode(n, 'PipelineBareFunction'))
        : (this.checkSmartPipeTopicBodyEarlyErrors(i),
          (n.expression = e),
          this.finishNode(n, 'PipelineTopicExpression'))
    }
    isSimpleReference(e) {
      switch (e.type) {
        case 'MemberExpression':
          return !e.computed && this.isSimpleReference(e.object)
        case 'Identifier':
          return !0
        default:
          return !1
      }
    }
    checkSmartPipeTopicBodyEarlyErrors(e) {
      if (this.match(19)) throw this.raise(re.PipelineBodyNoArrow, { at: this.state.startLoc })
      this.topicReferenceWasUsedInCurrentContext() || this.raise(re.PipelineTopicUnused, { at: e })
    }
    withTopicBindingContext(e) {
      const r = this.state.topicContext
      this.state.topicContext = { maxNumOfResolvableTopics: 1, maxTopicIndex: null }
      try {
        return e()
      } finally {
        this.state.topicContext = r
      }
    }
    withSmartMixTopicForbiddingContext(e) {
      if (this.hasPlugin(['pipelineOperator', { proposal: 'smart' }])) {
        const r = this.state.topicContext
        this.state.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null }
        try {
          return e()
        } finally {
          this.state.topicContext = r
        }
      } else return e()
    }
    withSoloAwaitPermittingContext(e) {
      const r = this.state.soloAwait
      this.state.soloAwait = !0
      try {
        return e()
      } finally {
        this.state.soloAwait = r
      }
    }
    allowInAnd(e) {
      const r = this.prodParam.currentFlags()
      if (Vn & ~r) {
        this.prodParam.enter(r | Vn)
        try {
          return e()
        } finally {
          this.prodParam.exit()
        }
      }
      return e()
    }
    disallowInAnd(e) {
      const r = this.prodParam.currentFlags()
      if (Vn & r) {
        this.prodParam.enter(r & ~Vn)
        try {
          return e()
        } finally {
          this.prodParam.exit()
        }
      }
      return e()
    }
    registerTopicReference() {
      this.state.topicContext.maxTopicIndex = 0
    }
    topicReferenceIsAllowedInCurrentContext() {
      return this.state.topicContext.maxNumOfResolvableTopics >= 1
    }
    topicReferenceWasUsedInCurrentContext() {
      return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0
    }
    parseFSharpPipelineBody(e) {
      const r = this.state.start,
        i = this.state.startLoc
      this.state.potentialArrowAt = this.state.start
      const n = this.state.inFSharpPipelineDirectBody
      this.state.inFSharpPipelineDirectBody = !0
      const s = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), r, i, e)
      return (this.state.inFSharpPipelineDirectBody = n), s
    }
    parseModuleExpression() {
      this.expectPlugin('moduleBlocks')
      const e = this.startNode()
      this.next(), this.eat(5)
      const r = this.initializeScopes(!0)
      this.enterInitialScopes()
      const i = this.startNode()
      try {
        e.body = this.parseProgram(i, 8, 'module')
      } finally {
        r()
      }
      return this.eat(8), this.finishNode(e, 'ModuleExpression')
    }
    parsePropertyNamePrefixOperator(e) {}
  }
  const Xp = { kind: 'loop' },
    oW = { kind: 'switch' },
    lW = 0,
    Gp = 1,
    bg = 2,
    Sg = 4,
    uW = /[\uD800-\uDFFF]/u,
    Jp = /in(?:stanceof)?/y
  function cW(t, e) {
    for (let r = 0; r < t.length; r++) {
      const i = t[r],
        { type: n } = i
      if (typeof n == 'number') {
        {
          if (n === 134) {
            const { loc: s, start: a, value: o, end: u } = i,
              c = a + 1,
              p = Wt(s.start, 1)
            t.splice(
              r,
              1,
              new wi({ type: ii(27), value: '#', start: a, end: c, startLoc: s.start, endLoc: p }),
              new wi({ type: ii(128), value: o, start: c, end: u, startLoc: p, endLoc: s.end })
            ),
              r++
            continue
          }
          if (zo(n)) {
            const { loc: s, start: a, value: o, end: u } = i,
              c = a + 1,
              p = Wt(s.start, 1)
            let h
            e.charCodeAt(a) === 96
              ? (h = new wi({ type: ii(22), value: '`', start: a, end: c, startLoc: s.start, endLoc: p }))
              : (h = new wi({ type: ii(8), value: '}', start: a, end: c, startLoc: s.start, endLoc: p }))
            let f, d, T, y
            n === 24
              ? ((d = u - 1),
                (T = Wt(s.end, -1)),
                (f = o === null ? null : o.slice(1, -1)),
                (y = new wi({ type: ii(22), value: '`', start: d, end: u, startLoc: T, endLoc: s.end })))
              : ((d = u - 2),
                (T = Wt(s.end, -2)),
                (f = o === null ? null : o.slice(1, -2)),
                (y = new wi({ type: ii(23), value: '${', start: d, end: u, startLoc: T, endLoc: s.end }))),
              t.splice(r, 1, h, new wi({ type: ii(20), value: f, start: c, end: d, startLoc: p, endLoc: T }), y),
              (r += 2)
            continue
          }
        }
        i.type = ii(n)
      }
    }
    return t
  }
  class pW extends aW {
    parseTopLevel(e, r) {
      return (
        (e.program = this.parseProgram(r)),
        (e.comments = this.state.comments),
        this.options.tokens && (e.tokens = cW(this.tokens, this.input)),
        this.finishNode(e, 'File')
      )
    }
    parseProgram(e, r = 135, i = this.options.sourceType) {
      if (
        ((e.sourceType = i),
        (e.interpreter = this.parseInterpreterDirective()),
        this.parseBlockBody(e, !0, !0, r),
        this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0)
      )
        for (const [n, s] of Array.from(this.scope.undefinedExports))
          this.raise(re.ModuleExportUndefined, { at: s, localName: n })
      return this.finishNode(e, 'Program')
    }
    stmtToDirective(e) {
      const r = e
      ;(r.type = 'Directive'), (r.value = r.expression), delete r.expression
      const i = r.value,
        n = i.value,
        s = this.input.slice(i.start, i.end),
        a = (i.value = s.slice(1, -1))
      return (
        this.addExtra(i, 'raw', s),
        this.addExtra(i, 'rawValue', a),
        this.addExtra(i, 'expressionValue', n),
        (i.type = 'DirectiveLiteral'),
        r
      )
    }
    parseInterpreterDirective() {
      if (!this.match(28)) return null
      const e = this.startNode()
      return (e.value = this.state.value), this.next(), this.finishNode(e, 'InterpreterDirective')
    }
    isLet(e) {
      return this.isContextual(99) ? this.isLetKeyword(e) : !1
    }
    isLetKeyword(e) {
      const r = this.nextTokenStart(),
        i = this.codePointAtPos(r)
      if (i === 92 || i === 91) return !0
      if (e) return !1
      if (i === 123) return !0
      if (ni(i)) {
        if (((Jp.lastIndex = r), Jp.test(this.input))) {
          const n = this.codePointAtPos(Jp.lastIndex)
          if (!$n(n) && n !== 92) return !1
        }
        return !0
      }
      return !1
    }
    parseStatement(e, r) {
      return this.match(26) && this.parseDecorators(!0), this.parseStatementContent(e, r)
    }
    parseStatementContent(e, r) {
      let i = this.state.type
      const n = this.startNode()
      let s
      switch ((this.isLet(e) && ((i = 74), (s = 'let')), i)) {
        case 60:
          return this.parseBreakContinueStatement(n, !0)
        case 63:
          return this.parseBreakContinueStatement(n, !1)
        case 64:
          return this.parseDebuggerStatement(n)
        case 90:
          return this.parseDoStatement(n)
        case 91:
          return this.parseForStatement(n)
        case 68:
          if (this.lookaheadCharCode() === 46) break
          return (
            e &&
              (this.state.strict
                ? this.raise(re.StrictFunction, { at: this.state.startLoc })
                : e !== 'if' && e !== 'label' && this.raise(re.SloppyFunction, { at: this.state.startLoc })),
            this.parseFunctionStatement(n, !1, !e)
          )
        case 80:
          return e && this.unexpected(), this.parseClass(n, !0)
        case 69:
          return this.parseIfStatement(n)
        case 70:
          return this.parseReturnStatement(n)
        case 71:
          return this.parseSwitchStatement(n)
        case 72:
          return this.parseThrowStatement(n)
        case 73:
          return this.parseTryStatement(n)
        case 75:
        case 74:
          return (
            (s = s || this.state.value),
            e && s !== 'var' && this.raise(re.UnexpectedLexicalDeclaration, { at: this.state.startLoc }),
            this.parseVarStatement(n, s)
          )
        case 92:
          return this.parseWhileStatement(n)
        case 76:
          return this.parseWithStatement(n)
        case 5:
          return this.parseBlock()
        case 13:
          return this.parseEmptyStatement(n)
        case 83: {
          const u = this.lookaheadCharCode()
          if (u === 40 || u === 46) break
        }
        case 82: {
          !this.options.allowImportExportEverywhere &&
            !r &&
            this.raise(re.UnexpectedImportExport, { at: this.state.startLoc }),
            this.next()
          let u
          return (
            i === 83
              ? ((u = this.parseImport(n)),
                u.type === 'ImportDeclaration' &&
                  (!u.importKind || u.importKind === 'value') &&
                  (this.sawUnambiguousESM = !0))
              : ((u = this.parseExport(n)),
                ((u.type === 'ExportNamedDeclaration' && (!u.exportKind || u.exportKind === 'value')) ||
                  (u.type === 'ExportAllDeclaration' && (!u.exportKind || u.exportKind === 'value')) ||
                  u.type === 'ExportDefaultDeclaration') &&
                  (this.sawUnambiguousESM = !0)),
            this.assertModuleNodeAllowed(n),
            u
          )
        }
        default:
          if (this.isAsyncFunction())
            return (
              e && this.raise(re.AsyncFunctionInSingleStatementContext, { at: this.state.startLoc }),
              this.next(),
              this.parseFunctionStatement(n, !0, !e)
            )
      }
      const a = this.state.value,
        o = this.parseExpression()
      return mt(i) && o.type === 'Identifier' && this.eat(14)
        ? this.parseLabeledStatement(n, a, o, e)
        : this.parseExpressionStatement(n, o)
    }
    assertModuleNodeAllowed(e) {
      !this.options.allowImportExportEverywhere && !this.inModule && this.raise(re.ImportOutsideModule, { at: e })
    }
    takeDecorators(e) {
      const r = this.state.decoratorStack[this.state.decoratorStack.length - 1]
      r.length &&
        ((e.decorators = r),
        this.resetStartLocationFromNode(e, r[0]),
        (this.state.decoratorStack[this.state.decoratorStack.length - 1] = []))
    }
    canHaveLeadingDecorator() {
      return this.match(80)
    }
    parseDecorators(e) {
      const r = this.state.decoratorStack[this.state.decoratorStack.length - 1]
      for (; this.match(26); ) {
        const i = this.parseDecorator()
        r.push(i)
      }
      if (this.match(82))
        e || this.unexpected(),
          this.hasPlugin('decorators') &&
            !this.getPluginOption('decorators', 'decoratorsBeforeExport') &&
            this.raise(re.DecoratorExportClass, { at: this.state.startLoc })
      else if (!this.canHaveLeadingDecorator())
        throw this.raise(re.UnexpectedLeadingDecorator, { at: this.state.startLoc })
    }
    parseDecorator() {
      this.expectOnePlugin(['decorators-legacy', 'decorators'])
      const e = this.startNode()
      if ((this.next(), this.hasPlugin('decorators'))) {
        this.state.decoratorStack.push([])
        const r = this.state.start,
          i = this.state.startLoc
        let n
        if (this.match(10)) {
          const s = this.state.start,
            a = this.state.startLoc
          this.next(), (n = this.parseExpression()), this.expect(11), (n = this.wrapParenthesis(s, a, n))
        } else
          for (n = this.parseIdentifier(!1); this.eat(16); ) {
            const s = this.startNodeAt(r, i)
            ;(s.object = n),
              (s.property = this.parseIdentifier(!0)),
              (s.computed = !1),
              (n = this.finishNode(s, 'MemberExpression'))
          }
        ;(e.expression = this.parseMaybeDecoratorArguments(n)), this.state.decoratorStack.pop()
      } else e.expression = this.parseExprSubscripts()
      return this.finishNode(e, 'Decorator')
    }
    parseMaybeDecoratorArguments(e) {
      if (this.eat(10)) {
        const r = this.startNodeAtNode(e)
        return (
          (r.callee = e),
          (r.arguments = this.parseCallExpressionArguments(11, !1)),
          this.toReferencedList(r.arguments),
          this.finishNode(r, 'CallExpression')
        )
      }
      return e
    }
    parseBreakContinueStatement(e, r) {
      return (
        this.next(),
        this.isLineTerminator() ? (e.label = null) : ((e.label = this.parseIdentifier()), this.semicolon()),
        this.verifyBreakContinue(e, r),
        this.finishNode(e, r ? 'BreakStatement' : 'ContinueStatement')
      )
    }
    verifyBreakContinue(e, r) {
      let i
      for (i = 0; i < this.state.labels.length; ++i) {
        const n = this.state.labels[i]
        if (
          (e.label == null || n.name === e.label.name) &&
          ((n.kind != null && (r || n.kind === 'loop')) || (e.label && r))
        )
          break
      }
      if (i === this.state.labels.length) {
        const n = r ? 'BreakStatement' : 'ContinueStatement'
        this.raise(re.IllegalBreakContinue, { at: e, type: n })
      }
    }
    parseDebuggerStatement(e) {
      return this.next(), this.semicolon(), this.finishNode(e, 'DebuggerStatement')
    }
    parseHeaderExpression() {
      this.expect(10)
      const e = this.parseExpression()
      return this.expect(11), e
    }
    parseDoStatement(e) {
      return (
        this.next(),
        this.state.labels.push(Xp),
        (e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement('do'))),
        this.state.labels.pop(),
        this.expect(92),
        (e.test = this.parseHeaderExpression()),
        this.eat(13),
        this.finishNode(e, 'DoWhileStatement')
      )
    }
    parseForStatement(e) {
      this.next(), this.state.labels.push(Xp)
      let r = null
      if (
        (this.isAwaitAllowed() && this.eatContextual(96) && (r = this.state.lastTokStartLoc),
        this.scope.enter(Rn),
        this.expect(10),
        this.match(13))
      )
        return r !== null && this.unexpected(r), this.parseFor(e, null)
      const i = this.isContextual(99),
        n = i && this.isLetKeyword()
      if (this.match(74) || this.match(75) || n) {
        const c = this.startNode(),
          p = n ? 'let' : this.state.value
        return (
          this.next(),
          this.parseVar(c, !0, p),
          this.finishNode(c, 'VariableDeclaration'),
          (this.match(58) || this.isContextual(101)) && c.declarations.length === 1
            ? this.parseForIn(e, c, r)
            : (r !== null && this.unexpected(r), this.parseFor(e, c))
        )
      }
      const s = this.isContextual(95),
        a = new rl(),
        o = this.parseExpression(!0, a),
        u = this.isContextual(101)
      if (
        (u &&
          (i && this.raise(re.ForOfLet, { at: o }),
          r === null && s && o.type === 'Identifier' && this.raise(re.ForOfAsync, { at: o })),
        u || this.match(58))
      ) {
        this.checkDestructuringPrivate(a), this.toAssignable(o, !0)
        const c = u ? 'ForOfStatement' : 'ForInStatement'
        return this.checkLVal(o, { in: { type: c } }), this.parseForIn(e, o, r)
      } else this.checkExpressionErrors(a, !0)
      return r !== null && this.unexpected(r), this.parseFor(e, o)
    }
    parseFunctionStatement(e, r, i) {
      return this.next(), this.parseFunction(e, Gp | (i ? 0 : bg), r)
    }
    parseIfStatement(e) {
      return (
        this.next(),
        (e.test = this.parseHeaderExpression()),
        (e.consequent = this.parseStatement('if')),
        (e.alternate = this.eat(66) ? this.parseStatement('if') : null),
        this.finishNode(e, 'IfStatement')
      )
    }
    parseReturnStatement(e) {
      return (
        !this.prodParam.hasReturn &&
          !this.options.allowReturnOutsideFunction &&
          this.raise(re.IllegalReturn, { at: this.state.startLoc }),
        this.next(),
        this.isLineTerminator() ? (e.argument = null) : ((e.argument = this.parseExpression()), this.semicolon()),
        this.finishNode(e, 'ReturnStatement')
      )
    }
    parseSwitchStatement(e) {
      this.next(), (e.discriminant = this.parseHeaderExpression())
      const r = (e.cases = [])
      this.expect(5), this.state.labels.push(oW), this.scope.enter(Rn)
      let i
      for (let n; !this.match(8); )
        if (this.match(61) || this.match(65)) {
          const s = this.match(61)
          i && this.finishNode(i, 'SwitchCase'),
            r.push((i = this.startNode())),
            (i.consequent = []),
            this.next(),
            s
              ? (i.test = this.parseExpression())
              : (n && this.raise(re.MultipleDefaultsInSwitch, { at: this.state.lastTokStartLoc }),
                (n = !0),
                (i.test = null)),
            this.expect(14)
        } else i ? i.consequent.push(this.parseStatement(null)) : this.unexpected()
      return (
        this.scope.exit(),
        i && this.finishNode(i, 'SwitchCase'),
        this.next(),
        this.state.labels.pop(),
        this.finishNode(e, 'SwitchStatement')
      )
    }
    parseThrowStatement(e) {
      return (
        this.next(),
        this.hasPrecedingLineBreak() && this.raise(re.NewlineAfterThrow, { at: this.state.lastTokEndLoc }),
        (e.argument = this.parseExpression()),
        this.semicolon(),
        this.finishNode(e, 'ThrowStatement')
      )
    }
    parseCatchClauseParam() {
      const e = this.parseBindingAtom(),
        r = e.type === 'Identifier'
      return (
        this.scope.enter(r ? W0 : 0),
        this.checkLVal(e, { in: { type: 'CatchClause' }, binding: oi, allowingSloppyLetBinding: !0 }),
        e
      )
    }
    parseTryStatement(e) {
      if ((this.next(), (e.block = this.parseBlock()), (e.handler = null), this.match(62))) {
        const r = this.startNode()
        this.next(),
          this.match(10)
            ? (this.expect(10), (r.param = this.parseCatchClauseParam()), this.expect(11))
            : ((r.param = null), this.scope.enter(Rn)),
          (r.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(!1, !1))),
          this.scope.exit(),
          (e.handler = this.finishNode(r, 'CatchClause'))
      }
      return (
        (e.finalizer = this.eat(67) ? this.parseBlock() : null),
        !e.handler && !e.finalizer && this.raise(re.NoCatchOrFinally, { at: e }),
        this.finishNode(e, 'TryStatement')
      )
    }
    parseVarStatement(e, r, i = !1) {
      return this.next(), this.parseVar(e, !1, r, i), this.semicolon(), this.finishNode(e, 'VariableDeclaration')
    }
    parseWhileStatement(e) {
      return (
        this.next(),
        (e.test = this.parseHeaderExpression()),
        this.state.labels.push(Xp),
        (e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement('while'))),
        this.state.labels.pop(),
        this.finishNode(e, 'WhileStatement')
      )
    }
    parseWithStatement(e) {
      return (
        this.state.strict && this.raise(re.StrictWith, { at: this.state.startLoc }),
        this.next(),
        (e.object = this.parseHeaderExpression()),
        (e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement('with'))),
        this.finishNode(e, 'WithStatement')
      )
    }
    parseEmptyStatement(e) {
      return this.next(), this.finishNode(e, 'EmptyStatement')
    }
    parseLabeledStatement(e, r, i, n) {
      for (const a of this.state.labels) a.name === r && this.raise(re.LabelRedeclaration, { at: i, labelName: r })
      const s = Rz(this.state.type) ? 'loop' : this.match(71) ? 'switch' : null
      for (let a = this.state.labels.length - 1; a >= 0; a--) {
        const o = this.state.labels[a]
        if (o.statementStart === e.start) (o.statementStart = this.state.start), (o.kind = s)
        else break
      }
      return (
        this.state.labels.push({ name: r, kind: s, statementStart: this.state.start }),
        (e.body = this.parseStatement(n ? (n.indexOf('label') === -1 ? n + 'label' : n) : 'label')),
        this.state.labels.pop(),
        (e.label = i),
        this.finishNode(e, 'LabeledStatement')
      )
    }
    parseExpressionStatement(e, r) {
      return (e.expression = r), this.semicolon(), this.finishNode(e, 'ExpressionStatement')
    }
    parseBlock(e = !1, r = !0, i) {
      const n = this.startNode()
      return (
        e && this.state.strictErrors.clear(),
        this.expect(5),
        r && this.scope.enter(Rn),
        this.parseBlockBody(n, e, !1, 8, i),
        r && this.scope.exit(),
        this.finishNode(n, 'BlockStatement')
      )
    }
    isValidDirective(e) {
      return (
        e.type === 'ExpressionStatement' && e.expression.type === 'StringLiteral' && !e.expression.extra.parenthesized
      )
    }
    parseBlockBody(e, r, i, n, s) {
      const a = (e.body = []),
        o = (e.directives = [])
      this.parseBlockOrModuleBlockBody(a, r ? o : void 0, i, n, s)
    }
    parseBlockOrModuleBlockBody(e, r, i, n, s) {
      const a = this.state.strict
      let o = !1,
        u = !1
      for (; !this.match(n); ) {
        const c = this.parseStatement(null, i)
        if (r && !u) {
          if (this.isValidDirective(c)) {
            const p = this.stmtToDirective(c)
            r.push(p), !o && p.value.value === 'use strict' && ((o = !0), this.setStrict(!0))
            continue
          }
          ;(u = !0), this.state.strictErrors.clear()
        }
        e.push(c)
      }
      s && s.call(this, o), a || this.setStrict(!1), this.next()
    }
    parseFor(e, r) {
      return (
        (e.init = r),
        this.semicolon(!1),
        (e.test = this.match(13) ? null : this.parseExpression()),
        this.semicolon(!1),
        (e.update = this.match(11) ? null : this.parseExpression()),
        this.expect(11),
        (e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement('for'))),
        this.scope.exit(),
        this.state.labels.pop(),
        this.finishNode(e, 'ForStatement')
      )
    }
    parseForIn(e, r, i) {
      const n = this.match(58)
      return (
        this.next(),
        n ? i !== null && this.unexpected(i) : (e.await = i !== null),
        r.type === 'VariableDeclaration' &&
          r.declarations[0].init != null &&
          (!n || this.state.strict || r.kind !== 'var' || r.declarations[0].id.type !== 'Identifier') &&
          this.raise(re.ForInOfLoopInitializer, { at: r, type: n ? 'ForInStatement' : 'ForOfStatement' }),
        r.type === 'AssignmentPattern' && this.raise(re.InvalidLhs, { at: r, ancestor: { type: 'ForStatement' } }),
        (e.left = r),
        (e.right = n ? this.parseExpression() : this.parseMaybeAssignAllowIn()),
        this.expect(11),
        (e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement('for'))),
        this.scope.exit(),
        this.state.labels.pop(),
        this.finishNode(e, n ? 'ForInStatement' : 'ForOfStatement')
      )
    }
    parseVar(e, r, i, n = !1) {
      const s = (e.declarations = [])
      for (e.kind = i; ; ) {
        const a = this.startNode()
        if (
          (this.parseVarId(a, i),
          (a.init = this.eat(29) ? (r ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn()) : null),
          a.init === null &&
            !n &&
            (a.id.type !== 'Identifier' && !(r && (this.match(58) || this.isContextual(101)))
              ? this.raise(re.DeclarationMissingInitializer, { at: this.state.lastTokEndLoc, kind: 'destructuring' })
              : i === 'const' &&
                !(this.match(58) || this.isContextual(101)) &&
                this.raise(re.DeclarationMissingInitializer, { at: this.state.lastTokEndLoc, kind: 'const' })),
          s.push(this.finishNode(a, 'VariableDeclarator')),
          !this.eat(12))
        )
          break
      }
      return e
    }
    parseVarId(e, r) {
      ;(e.id = this.parseBindingAtom()),
        this.checkLVal(e.id, { in: { type: 'VariableDeclarator' }, binding: r === 'var' ? Xo : oi })
    }
    parseFunction(e, r = lW, i = !1) {
      const n = r & Gp,
        s = r & bg,
        a = !!n && !(r & Sg)
      this.initFunction(e, i),
        this.match(55) && s && this.raise(re.GeneratorInSingleStatementContext, { at: this.state.startLoc }),
        (e.generator = this.eat(55)),
        n && (e.id = this.parseFunctionId(a))
      const o = this.state.maybeInArrowParameters
      return (
        (this.state.maybeInArrowParameters = !1),
        this.scope.enter(si),
        this.prodParam.enter(tl(i, e.generator)),
        n || (e.id = this.parseFunctionId()),
        this.parseFunctionParams(e, !1),
        this.withSmartMixTopicForbiddingContext(() => {
          this.parseFunctionBodyAndFinish(e, n ? 'FunctionDeclaration' : 'FunctionExpression')
        }),
        this.prodParam.exit(),
        this.scope.exit(),
        n && !s && this.registerFunctionStatementId(e),
        (this.state.maybeInArrowParameters = o),
        e
      )
    }
    parseFunctionId(e) {
      return e || mt(this.state.type) ? this.parseIdentifier() : null
    }
    parseFunctionParams(e, r) {
      this.expect(10),
        this.expressionScope.enter(IK()),
        (e.params = this.parseBindingList(11, 41, !1, r)),
        this.expressionScope.exit()
    }
    registerFunctionStatementId(e) {
      !e.id ||
        this.scope.declareName(
          e.id.name,
          this.state.strict || e.generator || e.async ? (this.scope.treatFunctionsAsVar ? Xo : oi) : G0,
          e.id.loc.start
        )
    }
    parseClass(e, r, i) {
      this.next(), this.takeDecorators(e)
      const n = this.state.strict
      return (
        (this.state.strict = !0),
        this.parseClassId(e, r, i),
        this.parseClassSuper(e),
        (e.body = this.parseClassBody(!!e.superClass, n)),
        this.finishNode(e, r ? 'ClassDeclaration' : 'ClassExpression')
      )
    }
    isClassProperty() {
      return this.match(29) || this.match(13) || this.match(8)
    }
    isClassMethod() {
      return this.match(10)
    }
    isNonstaticConstructor(e) {
      return !e.computed && !e.static && (e.key.name === 'constructor' || e.key.value === 'constructor')
    }
    parseClassBody(e, r) {
      this.classScope.enter()
      const i = { hadConstructor: !1, hadSuperClass: e }
      let n = []
      const s = this.startNode()
      if (
        ((s.body = []),
        this.expect(5),
        this.withSmartMixTopicForbiddingContext(() => {
          for (; !this.match(8); ) {
            if (this.eat(13)) {
              if (n.length > 0) throw this.raise(re.DecoratorSemicolon, { at: this.state.lastTokEndLoc })
              continue
            }
            if (this.match(26)) {
              n.push(this.parseDecorator())
              continue
            }
            const a = this.startNode()
            n.length && ((a.decorators = n), this.resetStartLocationFromNode(a, n[0]), (n = [])),
              this.parseClassMember(s, a, i),
              a.kind === 'constructor' &&
                a.decorators &&
                a.decorators.length > 0 &&
                this.raise(re.DecoratorConstructor, { at: a })
          }
        }),
        (this.state.strict = r),
        this.next(),
        n.length)
      )
        throw this.raise(re.TrailingDecorator, { at: this.state.startLoc })
      return this.classScope.exit(), this.finishNode(s, 'ClassBody')
    }
    parseClassMemberFromModifier(e, r) {
      const i = this.parseIdentifier(!0)
      if (this.isClassMethod()) {
        const n = r
        return (
          (n.kind = 'method'),
          (n.computed = !1),
          (n.key = i),
          (n.static = !1),
          this.pushClassMethod(e, n, !1, !1, !1, !1),
          !0
        )
      } else if (this.isClassProperty()) {
        const n = r
        return (n.computed = !1), (n.key = i), (n.static = !1), e.body.push(this.parseClassProperty(n)), !0
      }
      return this.resetPreviousNodeTrailingComments(i), !1
    }
    parseClassMember(e, r, i) {
      const n = this.isContextual(104)
      if (n) {
        if (this.parseClassMemberFromModifier(e, r)) return
        if (this.eat(5)) {
          this.parseClassStaticBlock(e, r)
          return
        }
      }
      this.parseClassMemberWithIsStatic(e, r, i, n)
    }
    parseClassMemberWithIsStatic(e, r, i, n) {
      const s = r,
        a = r,
        o = r,
        u = r,
        c = r,
        p = s,
        h = s
      if (((r.static = n), this.parsePropertyNamePrefixOperator(r), this.eat(55))) {
        p.kind = 'method'
        const b = this.match(134)
        if ((this.parseClassElementName(p), b)) {
          this.pushClassPrivateMethod(e, a, !0, !1)
          return
        }
        this.isNonstaticConstructor(s) && this.raise(re.ConstructorIsGenerator, { at: s.key }),
          this.pushClassMethod(e, s, !0, !1, !1, !1)
        return
      }
      const f = mt(this.state.type) && !this.state.containsEsc,
        d = this.match(134),
        T = this.parseClassElementName(r),
        y = this.state.startLoc
      if ((this.parsePostMemberNameModifiers(h), this.isClassMethod())) {
        if (((p.kind = 'method'), d)) {
          this.pushClassPrivateMethod(e, a, !1, !1)
          return
        }
        const b = this.isNonstaticConstructor(s)
        let m = !1
        b &&
          ((s.kind = 'constructor'),
          i.hadConstructor && !this.hasPlugin('typescript') && this.raise(re.DuplicateConstructor, { at: T }),
          b && this.hasPlugin('typescript') && r.override && this.raise(re.OverrideOnConstructor, { at: T }),
          (i.hadConstructor = !0),
          (m = i.hadSuperClass)),
          this.pushClassMethod(e, s, !1, !1, b, m)
      } else if (this.isClassProperty()) d ? this.pushClassPrivateProperty(e, u) : this.pushClassProperty(e, o)
      else if (f && T.name === 'async' && !this.isLineTerminator()) {
        this.resetPreviousNodeTrailingComments(T)
        const b = this.eat(55)
        h.optional && this.unexpected(y), (p.kind = 'method')
        const m = this.match(134)
        this.parseClassElementName(p),
          this.parsePostMemberNameModifiers(h),
          m
            ? this.pushClassPrivateMethod(e, a, b, !0)
            : (this.isNonstaticConstructor(s) && this.raise(re.ConstructorIsAsync, { at: s.key }),
              this.pushClassMethod(e, s, b, !0, !1, !1))
      } else if (f && (T.name === 'get' || T.name === 'set') && !(this.match(55) && this.isLineTerminator())) {
        this.resetPreviousNodeTrailingComments(T), (p.kind = T.name)
        const b = this.match(134)
        this.parseClassElementName(s),
          b
            ? this.pushClassPrivateMethod(e, a, !1, !1)
            : (this.isNonstaticConstructor(s) && this.raise(re.ConstructorIsAccessor, { at: s.key }),
              this.pushClassMethod(e, s, !1, !1, !1, !1)),
          this.checkGetterSetterParams(s)
      } else if (f && T.name === 'accessor' && !this.isLineTerminator()) {
        this.expectPlugin('decoratorAutoAccessors'), this.resetPreviousNodeTrailingComments(T)
        const b = this.match(134)
        this.parseClassElementName(o), this.pushClassAccessorProperty(e, c, b)
      } else
        this.isLineTerminator()
          ? d
            ? this.pushClassPrivateProperty(e, u)
            : this.pushClassProperty(e, o)
          : this.unexpected()
    }
    parseClassElementName(e) {
      const { type: r, value: i } = this.state
      if (
        ((r === 128 || r === 129) &&
          e.static &&
          i === 'prototype' &&
          this.raise(re.StaticPrototype, { at: this.state.startLoc }),
        r === 134)
      ) {
        i === 'constructor' && this.raise(re.ConstructorClassPrivateField, { at: this.state.startLoc })
        const n = this.parsePrivateName()
        return (e.key = n), n
      }
      return this.parsePropertyName(e)
    }
    parseClassStaticBlock(e, r) {
      var i
      this.scope.enter(un | Dp | Ko)
      const n = this.state.labels
      ;(this.state.labels = []), this.prodParam.enter(_n)
      const s = (r.body = [])
      this.parseBlockOrModuleBlockBody(s, void 0, !1, 8),
        this.prodParam.exit(),
        this.scope.exit(),
        (this.state.labels = n),
        e.body.push(this.finishNode(r, 'StaticBlock')),
        (i = r.decorators) != null && i.length && this.raise(re.DecoratorStaticBlock, { at: r })
    }
    pushClassProperty(e, r) {
      !r.computed &&
        (r.key.name === 'constructor' || r.key.value === 'constructor') &&
        this.raise(re.ConstructorClassField, { at: r.key }),
        e.body.push(this.parseClassProperty(r))
    }
    pushClassPrivateProperty(e, r) {
      const i = this.parseClassPrivateProperty(r)
      e.body.push(i), this.classScope.declarePrivateName(this.getPrivateNameSV(i.key), _p, i.key.loc.start)
    }
    pushClassAccessorProperty(e, r, i) {
      if (!i && !r.computed) {
        const s = r.key
        ;(s.name === 'constructor' || s.value === 'constructor') && this.raise(re.ConstructorClassField, { at: s })
      }
      const n = this.parseClassAccessorProperty(r)
      e.body.push(n), i && this.classScope.declarePrivateName(this.getPrivateNameSV(n.key), _p, n.key.loc.start)
    }
    pushClassMethod(e, r, i, n, s, a) {
      e.body.push(this.parseMethod(r, i, n, s, a, 'ClassMethod', !0))
    }
    pushClassPrivateMethod(e, r, i, n) {
      const s = this.parseMethod(r, i, n, !1, !1, 'ClassPrivateMethod', !0)
      e.body.push(s)
      const a = s.kind === 'get' ? (s.static ? lK : cK) : s.kind === 'set' ? (s.static ? uK : pK) : _p
      this.declareClassPrivateMethodInScope(s, a)
    }
    declareClassPrivateMethodInScope(e, r) {
      this.classScope.declarePrivateName(this.getPrivateNameSV(e.key), r, e.key.loc.start)
    }
    parsePostMemberNameModifiers(e) {}
    parseClassPrivateProperty(e) {
      return this.parseInitializer(e), this.semicolon(), this.finishNode(e, 'ClassPrivateProperty')
    }
    parseClassProperty(e) {
      return this.parseInitializer(e), this.semicolon(), this.finishNode(e, 'ClassProperty')
    }
    parseClassAccessorProperty(e) {
      return this.parseInitializer(e), this.semicolon(), this.finishNode(e, 'ClassAccessorProperty')
    }
    parseInitializer(e) {
      this.scope.enter(un | Ko),
        this.expressionScope.enter(sg()),
        this.prodParam.enter(_n),
        (e.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null),
        this.expressionScope.exit(),
        this.prodParam.exit(),
        this.scope.exit()
    }
    parseClassId(e, r, i, n = X0) {
      if (mt(this.state.type)) (e.id = this.parseIdentifier()), r && this.declareNameFromIdentifier(e.id, n)
      else if (i || !r) e.id = null
      else throw this.raise(re.MissingClassName, { at: this.state.startLoc })
    }
    parseClassSuper(e) {
      e.superClass = this.eat(81) ? this.parseExprSubscripts() : null
    }
    parseExport(e) {
      const r = this.maybeParseExportDefaultSpecifier(e),
        i = !r || this.eat(12),
        n = i && this.eatExportStar(e),
        s = n && this.maybeParseExportNamespaceSpecifier(e),
        a = i && (!s || this.eat(12)),
        o = r || n
      if (n && !s)
        return r && this.unexpected(), this.parseExportFrom(e, !0), this.finishNode(e, 'ExportAllDeclaration')
      const u = this.maybeParseExportNamedSpecifiers(e)
      if ((r && i && !n && !u) || (s && a && !u)) throw this.unexpected(null, 5)
      let c
      if ((o || u ? ((c = !1), this.parseExportFrom(e, o)) : (c = this.maybeParseExportDeclaration(e)), o || u || c))
        return this.checkExport(e, !0, !1, !!e.source), this.finishNode(e, 'ExportNamedDeclaration')
      if (this.eat(65))
        return (
          (e.declaration = this.parseExportDefaultExpression()),
          this.checkExport(e, !0, !0),
          this.finishNode(e, 'ExportDefaultDeclaration')
        )
      throw this.unexpected(null, 5)
    }
    eatExportStar(e) {
      return this.eat(55)
    }
    maybeParseExportDefaultSpecifier(e) {
      if (this.isExportDefaultSpecifier()) {
        this.expectPlugin('exportDefaultFrom')
        const r = this.startNode()
        return (
          (r.exported = this.parseIdentifier(!0)), (e.specifiers = [this.finishNode(r, 'ExportDefaultSpecifier')]), !0
        )
      }
      return !1
    }
    maybeParseExportNamespaceSpecifier(e) {
      if (this.isContextual(93)) {
        e.specifiers || (e.specifiers = [])
        const r = this.startNodeAt(this.state.lastTokStart, this.state.lastTokStartLoc)
        return (
          this.next(),
          (r.exported = this.parseModuleExportName()),
          e.specifiers.push(this.finishNode(r, 'ExportNamespaceSpecifier')),
          !0
        )
      }
      return !1
    }
    maybeParseExportNamedSpecifiers(e) {
      if (this.match(5)) {
        e.specifiers || (e.specifiers = [])
        const r = e.exportKind === 'type'
        return (
          e.specifiers.push(...this.parseExportSpecifiers(r)),
          (e.source = null),
          (e.declaration = null),
          this.hasPlugin('importAssertions') && (e.assertions = []),
          !0
        )
      }
      return !1
    }
    maybeParseExportDeclaration(e) {
      return this.shouldParseExportDeclaration()
        ? ((e.specifiers = []),
          (e.source = null),
          this.hasPlugin('importAssertions') && (e.assertions = []),
          (e.declaration = this.parseExportDeclaration(e)),
          !0)
        : !1
    }
    isAsyncFunction() {
      if (!this.isContextual(95)) return !1
      const e = this.nextTokenStart()
      return !Vp.test(this.input.slice(this.state.pos, e)) && this.isUnparsedContextual(e, 'function')
    }
    parseExportDefaultExpression() {
      const e = this.startNode(),
        r = this.isAsyncFunction()
      if (this.match(68) || r) return this.next(), r && this.next(), this.parseFunction(e, Gp | Sg, r)
      if (this.match(80)) return this.parseClass(e, !0, !0)
      if (this.match(26))
        return (
          this.hasPlugin('decorators') &&
            this.getPluginOption('decorators', 'decoratorsBeforeExport') &&
            this.raise(re.DecoratorBeforeExport, { at: this.state.startLoc }),
          this.parseDecorators(!1),
          this.parseClass(e, !0, !0)
        )
      if (this.match(75) || this.match(74) || this.isLet())
        throw this.raise(re.UnsupportedDefaultExport, { at: this.state.startLoc })
      const i = this.parseMaybeAssignAllowIn()
      return this.semicolon(), i
    }
    parseExportDeclaration(e) {
      return this.parseStatement(null)
    }
    isExportDefaultSpecifier() {
      const { type: e } = this.state
      if (mt(e)) {
        if ((e === 95 && !this.state.containsEsc) || e === 99) return !1
        if ((e === 126 || e === 125) && !this.state.containsEsc) {
          const { type: n } = this.lookahead()
          if ((mt(n) && n !== 97) || n === 5) return this.expectOnePlugin(['flow', 'typescript']), !1
        }
      } else if (!this.match(65)) return !1
      const r = this.nextTokenStart(),
        i = this.isUnparsedContextual(r, 'from')
      if (this.input.charCodeAt(r) === 44 || (mt(this.state.type) && i)) return !0
      if (this.match(65) && i) {
        const n = this.input.charCodeAt(this.nextTokenStartSince(r + 4))
        return n === 34 || n === 39
      }
      return !1
    }
    parseExportFrom(e, r) {
      if (this.eatContextual(97)) {
        ;(e.source = this.parseImportSource()), this.checkExport(e)
        const i = this.maybeParseImportAssertions()
        i && (e.assertions = i)
      } else r && this.unexpected()
      this.semicolon()
    }
    shouldParseExportDeclaration() {
      const { type: e } = this.state
      if (e === 26 && (this.expectOnePlugin(['decorators', 'decorators-legacy']), this.hasPlugin('decorators'))) {
        if (this.getPluginOption('decorators', 'decoratorsBeforeExport'))
          throw this.raise(re.DecoratorBeforeExport, { at: this.state.startLoc })
        return !0
      }
      return e === 74 || e === 75 || e === 68 || e === 80 || this.isLet() || this.isAsyncFunction()
    }
    checkExport(e, r, i, n) {
      if (r) {
        if (i) {
          if ((this.checkDuplicateExports(e, 'default'), this.hasPlugin('exportDefaultFrom'))) {
            var s
            const o = e.declaration
            o.type === 'Identifier' &&
              o.name === 'from' &&
              o.end - o.start === 4 &&
              !((s = o.extra) != null && s.parenthesized) &&
              this.raise(re.ExportDefaultFromAsIdentifier, { at: o })
          }
        } else if (e.specifiers && e.specifiers.length)
          for (const o of e.specifiers) {
            const { exported: u } = o,
              c = u.type === 'Identifier' ? u.name : u.value
            if ((this.checkDuplicateExports(o, c), !n && o.local)) {
              const { local: p } = o
              p.type !== 'Identifier'
                ? this.raise(re.ExportBindingIsString, { at: o, localName: p.value, exportName: c })
                : (this.checkReservedWord(p.name, p.loc.start, !0, !1), this.scope.checkLocalExport(p))
            }
          }
        else if (e.declaration) {
          if (e.declaration.type === 'FunctionDeclaration' || e.declaration.type === 'ClassDeclaration') {
            const o = e.declaration.id
            if (!o) throw new Error('Assertion failure')
            this.checkDuplicateExports(e, o.name)
          } else if (e.declaration.type === 'VariableDeclaration')
            for (const o of e.declaration.declarations) this.checkDeclaration(o.id)
        }
      }
      if (this.state.decoratorStack[this.state.decoratorStack.length - 1].length)
        throw this.raise(re.UnsupportedDecoratorExport, { at: e })
    }
    checkDeclaration(e) {
      if (e.type === 'Identifier') this.checkDuplicateExports(e, e.name)
      else if (e.type === 'ObjectPattern') for (const r of e.properties) this.checkDeclaration(r)
      else if (e.type === 'ArrayPattern') for (const r of e.elements) r && this.checkDeclaration(r)
      else
        e.type === 'ObjectProperty'
          ? this.checkDeclaration(e.value)
          : e.type === 'RestElement'
          ? this.checkDeclaration(e.argument)
          : e.type === 'AssignmentPattern' && this.checkDeclaration(e.left)
    }
    checkDuplicateExports(e, r) {
      this.exportedIdentifiers.has(r) &&
        (r === 'default'
          ? this.raise(re.DuplicateDefaultExport, { at: e })
          : this.raise(re.DuplicateExport, { at: e, exportName: r })),
        this.exportedIdentifiers.add(r)
    }
    parseExportSpecifiers(e) {
      const r = []
      let i = !0
      for (this.expect(5); !this.eat(8); ) {
        if (i) i = !1
        else if ((this.expect(12), this.eat(8))) break
        const n = this.isContextual(126),
          s = this.match(129),
          a = this.startNode()
        ;(a.local = this.parseModuleExportName()), r.push(this.parseExportSpecifier(a, s, e, n))
      }
      return r
    }
    parseExportSpecifier(e, r, i, n) {
      return (
        this.eatContextual(93)
          ? (e.exported = this.parseModuleExportName())
          : r
          ? (e.exported = LK(e.local))
          : e.exported || (e.exported = li(e.local)),
        this.finishNode(e, 'ExportSpecifier')
      )
    }
    parseModuleExportName() {
      if (this.match(129)) {
        const e = this.parseStringLiteral(this.state.value),
          r = e.value.match(uW)
        return r && this.raise(re.ModuleExportNameHasLoneSurrogate, { at: e, surrogateCharCode: r[0].charCodeAt(0) }), e
      }
      return this.parseIdentifier(!0)
    }
    parseImport(e) {
      if (((e.specifiers = []), !this.match(129))) {
        const n = !this.maybeParseDefaultImportSpecifier(e) || this.eat(12),
          s = n && this.maybeParseStarImportSpecifier(e)
        n && !s && this.parseNamedImportSpecifiers(e), this.expectContextual(97)
      }
      e.source = this.parseImportSource()
      const r = this.maybeParseImportAssertions()
      if (r) e.assertions = r
      else {
        const i = this.maybeParseModuleAttributes()
        i && (e.attributes = i)
      }
      return this.semicolon(), this.finishNode(e, 'ImportDeclaration')
    }
    parseImportSource() {
      return this.match(129) || this.unexpected(), this.parseExprAtom()
    }
    shouldParseDefaultImport(e) {
      return mt(this.state.type)
    }
    parseImportSpecifierLocal(e, r, i) {
      ;(r.local = this.parseIdentifier()), e.specifiers.push(this.finishImportSpecifier(r, i))
    }
    finishImportSpecifier(e, r) {
      return this.checkLVal(e.local, { in: e, binding: oi }), this.finishNode(e, r)
    }
    parseAssertEntries() {
      const e = [],
        r = new Set()
      do {
        if (this.match(8)) break
        const i = this.startNode(),
          n = this.state.value
        if (
          (r.has(n) && this.raise(re.ModuleAttributesWithDuplicateKeys, { at: this.state.startLoc, key: n }),
          r.add(n),
          this.match(129) ? (i.key = this.parseStringLiteral(n)) : (i.key = this.parseIdentifier(!0)),
          this.expect(14),
          !this.match(129))
        )
          throw this.raise(re.ModuleAttributeInvalidValue, { at: this.state.startLoc })
        ;(i.value = this.parseStringLiteral(this.state.value)), this.finishNode(i, 'ImportAttribute'), e.push(i)
      } while (this.eat(12))
      return e
    }
    maybeParseModuleAttributes() {
      if (this.match(76) && !this.hasPrecedingLineBreak()) this.expectPlugin('moduleAttributes'), this.next()
      else return this.hasPlugin('moduleAttributes') ? [] : null
      const e = [],
        r = new Set()
      do {
        const i = this.startNode()
        if (
          ((i.key = this.parseIdentifier(!0)),
          i.key.name !== 'type' && this.raise(re.ModuleAttributeDifferentFromType, { at: i.key }),
          r.has(i.key.name) && this.raise(re.ModuleAttributesWithDuplicateKeys, { at: i.key, key: i.key.name }),
          r.add(i.key.name),
          this.expect(14),
          !this.match(129))
        )
          throw this.raise(re.ModuleAttributeInvalidValue, { at: this.state.startLoc })
        ;(i.value = this.parseStringLiteral(this.state.value)), this.finishNode(i, 'ImportAttribute'), e.push(i)
      } while (this.eat(12))
      return e
    }
    maybeParseImportAssertions() {
      if (this.isContextual(94) && !this.hasPrecedingLineBreak()) this.expectPlugin('importAssertions'), this.next()
      else return this.hasPlugin('importAssertions') ? [] : null
      this.eat(5)
      const e = this.parseAssertEntries()
      return this.eat(8), e
    }
    maybeParseDefaultImportSpecifier(e) {
      return this.shouldParseDefaultImport(e)
        ? (this.parseImportSpecifierLocal(e, this.startNode(), 'ImportDefaultSpecifier'), !0)
        : !1
    }
    maybeParseStarImportSpecifier(e) {
      if (this.match(55)) {
        const r = this.startNode()
        return (
          this.next(), this.expectContextual(93), this.parseImportSpecifierLocal(e, r, 'ImportNamespaceSpecifier'), !0
        )
      }
      return !1
    }
    parseNamedImportSpecifiers(e) {
      let r = !0
      for (this.expect(5); !this.eat(8); ) {
        if (r) r = !1
        else {
          if (this.eat(14)) throw this.raise(re.DestructureNamedImport, { at: this.state.startLoc })
          if ((this.expect(12), this.eat(8))) break
        }
        const i = this.startNode(),
          n = this.match(129),
          s = this.isContextual(126)
        i.imported = this.parseModuleExportName()
        const a = this.parseImportSpecifier(i, n, e.importKind === 'type' || e.importKind === 'typeof', s)
        e.specifiers.push(a)
      }
    }
    parseImportSpecifier(e, r, i, n) {
      if (this.eatContextual(93)) e.local = this.parseIdentifier()
      else {
        const { imported: s } = e
        if (r) throw this.raise(re.ImportBindingIsString, { at: e, importName: s.value })
        this.checkReservedWord(s.name, e.loc.start, !0, !0), e.local || (e.local = li(s))
      }
      return this.finishImportSpecifier(e, 'ImportSpecifier')
    }
    isThisParam(e) {
      return e.type === 'Identifier' && e.name === 'this'
    }
  }
  class vg extends pW {
    constructor(e, r) {
      ;(e = iW(e)),
        super(e, r),
        (this.options = e),
        this.initializeScopes(),
        (this.plugins = fW(this.options.plugins)),
        (this.filename = e.sourceFilename)
    }
    getScopeHandler() {
      return Wp
    }
    parse() {
      this.enterInitialScopes()
      const e = this.startNode(),
        r = this.startNode()
      return this.nextToken(), (e.errors = null), this.parseTopLevel(e, r), (e.errors = this.state.errors), e
    }
  }
  function fW(t) {
    const e = new Map()
    for (const r of t) {
      const [i, n] = Array.isArray(r) ? r : [r, {}]
      e.has(i) || e.set(i, n || {})
    }
    return e
  }
  function hW(t, e) {
    var r
    if (((r = e) == null ? void 0 : r.sourceType) === 'unambiguous') {
      e = Object.assign({}, e)
      try {
        e.sourceType = 'module'
        const i = Ws(e, t),
          n = i.parse()
        if (i.sawUnambiguousESM) return n
        if (i.ambiguousScriptDifferentAst)
          try {
            return (e.sourceType = 'script'), Ws(e, t).parse()
          } catch {}
        else n.program.sourceType = 'script'
        return n
      } catch (i) {
        try {
          return (e.sourceType = 'script'), Ws(e, t).parse()
        } catch {}
        throw i
      }
    } else return Ws(e, t).parse()
  }
  function dW(t, e) {
    const r = Ws(e, t)
    return r.options.strictMode && (r.state.strict = !0), r.getExpression()
  }
  function mW(t) {
    const e = {}
    for (const r of Object.keys(t)) e[r] = ii(t[r])
    return e
  }
  const yW = mW(Lz)
  function Ws(t, e) {
    let r = vg
    return t != null && t.plugins && (tW(t.plugins), (r = gW(t.plugins))), new r(t, e)
  }
  const Eg = {}
  function gW(t) {
    const e = rW.filter((n) => Yt(t, n)),
      r = e.join('/')
    let i = Eg[r]
    if (!i) {
      i = vg
      for (const n of e) i = yg[n](i)
      Eg[r] = i
    }
    return i
  }
  ;(Fs.parse = hW),
    (Fs.parseExpression = dW),
    (Fs.tokTypes = yW),
    Object.defineProperty(jo, '__esModule', { value: !0 }),
    (jo.default = OW)
  var TW = st,
    bW = Fs,
    SW = ws
  const {
      isCallExpression: vW,
      isExpressionStatement: EW,
      isFunction: PW,
      isIdentifier: wW,
      isJSXIdentifier: AW,
      isNewExpression: CW,
      isPlaceholder: nl,
      isStatement: xW,
      isStringLiteral: Pg,
      removePropertiesDeep: IW,
      traverse: kW,
    } = TW,
    NW = /^[_$A-Z0-9]+$/
  function OW(t, e, r) {
    const { placeholderWhitelist: i, placeholderPattern: n, preserveComments: s, syntacticPlaceholders: a } = r,
      o = LW(e, r.parser, a)
    IW(o, { preserveComments: s }), t.validate(o)
    const u = { placeholders: [], placeholderNames: new Set() },
      c = { placeholders: [], placeholderNames: new Set() },
      p = { value: void 0 }
    return (
      kW(o, DW, {
        syntactic: u,
        legacy: c,
        isLegacyRef: p,
        placeholderWhitelist: i,
        placeholderPattern: n,
        syntacticPlaceholders: a,
      }),
      Object.assign({ ast: o }, p.value ? c : u)
    )
  }
  function DW(t, e, r) {
    var i
    let n
    if (nl(t)) {
      if (r.syntacticPlaceholders === !1)
        throw new Error("%%foo%%-style placeholders can't be used when '.syntacticPlaceholders' is false.")
      ;(n = t.name.name), (r.isLegacyRef.value = !1)
    } else {
      if (r.isLegacyRef.value === !1 || r.syntacticPlaceholders) return
      if (wW(t) || AW(t)) (n = t.name), (r.isLegacyRef.value = !0)
      else if (Pg(t)) (n = t.value), (r.isLegacyRef.value = !0)
      else return
    }
    if (!r.isLegacyRef.value && (r.placeholderPattern != null || r.placeholderWhitelist != null))
      throw new Error(
        "'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'"
      )
    if (
      r.isLegacyRef.value &&
      (r.placeholderPattern === !1 || !(r.placeholderPattern || NW).test(n)) &&
      !((i = r.placeholderWhitelist) != null && i.has(n))
    )
      return
    e = e.slice()
    const { node: s, key: a } = e[e.length - 1]
    let o
    Pg(t) || nl(t, { expectedNode: 'StringLiteral' })
      ? (o = 'string')
      : (CW(s) && a === 'arguments') || (vW(s) && a === 'arguments') || (PW(s) && a === 'params')
      ? (o = 'param')
      : EW(s) && !nl(t)
      ? ((o = 'statement'), (e = e.slice(0, -1)))
      : xW(t) && nl(t)
      ? (o = 'statement')
      : (o = 'other')
    const { placeholders: u, placeholderNames: c } = r.isLegacyRef.value ? r.legacy : r.syntactic
    u.push({ name: n, type: o, resolve: (p) => BW(p, e), isDuplicate: c.has(n) }), c.add(n)
  }
  function BW(t, e) {
    let r = t
    for (let s = 0; s < e.length - 1; s++) {
      const { key: a, index: o } = e[s]
      o === void 0 ? (r = r[a]) : (r = r[a][o])
    }
    const { key: i, index: n } = e[e.length - 1]
    return { parent: r, key: i, index: n }
  }
  function LW(t, e, r) {
    const i = (e.plugins || []).slice()
    r !== !1 && i.push('placeholders'),
      (e = Object.assign({ allowReturnOutsideFunction: !0, allowSuperOutsideMethod: !0, sourceType: 'module' }, e, {
        plugins: i,
      }))
    try {
      return (0, bW.parse)(t, e)
    } catch (n) {
      const s = n.loc
      throw (
        (s &&
          ((n.message +=
            `
` + (0, SW.codeFrameColumns)(t, { start: s })),
          (n.code = 'BABEL_TEMPLATE_PARSE_ERROR')),
        n)
      )
    }
  }
  var sl = {}
  Object.defineProperty(sl, '__esModule', { value: !0 }), (sl.default = _W)
  var MW = st
  const {
    blockStatement: FW,
    cloneNode: Zp,
    emptyStatement: $W,
    expressionStatement: Qp,
    identifier: al,
    isStatement: wg,
    isStringLiteral: RW,
    stringLiteral: jW,
    validate: Ag,
  } = MW
  function _W(t, e) {
    const r = Zp(t.ast)
    return (
      e &&
        (t.placeholders.forEach((i) => {
          if (!Object.prototype.hasOwnProperty.call(e, i.name)) {
            const n = i.name
            throw new Error(`Error: No substitution given for "${n}". If this is not meant to be a
            placeholder you may want to consider passing one of the following options to @babel/template:
            - { placeholderPattern: false, placeholderWhitelist: new Set(['${n}'])}
            - { placeholderPattern: /^${n}$/ }`)
          }
        }),
        Object.keys(e).forEach((i) => {
          if (!t.placeholderNames.has(i)) throw new Error(`Unknown substitution "${i}" given`)
        })),
      t.placeholders
        .slice()
        .reverse()
        .forEach((i) => {
          try {
            VW(i, r, (e && e[i.name]) || null)
          } catch (n) {
            throw ((n.message = `@babel/template placeholder "${i.name}": ${n.message}`), n)
          }
        }),
      r
    )
  }
  function VW(t, e, r) {
    t.isDuplicate && (Array.isArray(r) ? (r = r.map((a) => Zp(a))) : typeof r == 'object' && (r = Zp(r)))
    const { parent: i, key: n, index: s } = t.resolve(e)
    if (t.type === 'string') {
      if ((typeof r == 'string' && (r = jW(r)), !r || !RW(r))) throw new Error('Expected string substitution')
    } else if (t.type === 'statement')
      s === void 0
        ? r
          ? Array.isArray(r)
            ? (r = FW(r))
            : typeof r == 'string'
            ? (r = Qp(al(r)))
            : wg(r) || (r = Qp(r))
          : (r = $W())
        : r && !Array.isArray(r) && (typeof r == 'string' && (r = al(r)), wg(r) || (r = Qp(r)))
    else if (t.type === 'param') {
      if ((typeof r == 'string' && (r = al(r)), s === void 0)) throw new Error('Assertion failure.')
    } else if ((typeof r == 'string' && (r = al(r)), Array.isArray(r)))
      throw new Error('Cannot replace single expression with an array.')
    if (s === void 0) Ag(i, n, r), (i[n] = r)
    else {
      const a = i[n].slice()
      t.type === 'statement' || t.type === 'param'
        ? r == null
          ? a.splice(s, 1)
          : Array.isArray(r)
          ? a.splice(s, 1, ...r)
          : (a[s] = r)
        : (a[s] = r),
        Ag(i, n, a),
        (i[n] = a)
    }
  }
  Object.defineProperty(yp, '__esModule', { value: !0 }), (yp.default = WW)
  var UW = on,
    zW = jo,
    KW = sl
  function WW(t, e, r) {
    e = t.code(e)
    let i
    return (n) => {
      const s = (0, UW.normalizeReplacements)(n)
      return i || (i = (0, zW.default)(t, e, r)), t.unwrap((0, KW.default)(i, s))
    }
  }
  var ef = {}
  Object.defineProperty(ef, '__esModule', { value: !0 }), (ef.default = XW)
  var YW = on,
    HW = jo,
    qW = sl
  function XW(t, e, r) {
    const { metadata: i, names: n } = GW(t, e, r)
    return (s) => {
      const a = {}
      return (
        s.forEach((o, u) => {
          a[n[u]] = o
        }),
        (o) => {
          const u = (0, YW.normalizeReplacements)(o)
          return (
            u &&
              Object.keys(u).forEach((c) => {
                if (Object.prototype.hasOwnProperty.call(a, c)) throw new Error('Unexpected replacement overlap.')
              }),
            t.unwrap((0, qW.default)(i, u ? Object.assign(u, a) : a))
          )
        }
      )
    }
  }
  function GW(t, e, r) {
    let i,
      n,
      s,
      a = ''
    do {
      a += '$'
      const o = JW(e, a)
      ;(i = o.names),
        (n = new Set(i)),
        (s = (0, HW.default)(t, t.code(o.code), {
          parser: r.parser,
          placeholderWhitelist: new Set(
            o.names.concat(r.placeholderWhitelist ? Array.from(r.placeholderWhitelist) : [])
          ),
          placeholderPattern: r.placeholderPattern,
          preserveComments: r.preserveComments,
          syntacticPlaceholders: r.syntacticPlaceholders,
        }))
    } while (s.placeholders.some((o) => o.isDuplicate && n.has(o.name)))
    return { metadata: s, names: i }
  }
  function JW(t, e) {
    const r = []
    let i = t[0]
    for (let n = 1; n < t.length; n++) {
      const s = `${e}${n - 1}`
      r.push(s), (i += s + t[n])
    }
    return { names: r, code: i }
  }
  Object.defineProperty(mp, '__esModule', { value: !0 }), (mp.default = kg)
  var Fr = on,
    Cg = yp,
    xg = ef
  const Ig = (0, Fr.validate)({ placeholderPattern: !1 })
  function kg(t, e) {
    const r = new WeakMap(),
      i = new WeakMap(),
      n = e || (0, Fr.validate)(null)
    return Object.assign(
      (s, ...a) => {
        if (typeof s == 'string') {
          if (a.length > 1) throw new Error('Unexpected extra params.')
          return Ng((0, Cg.default)(t, s, (0, Fr.merge)(n, (0, Fr.validate)(a[0]))))
        } else if (Array.isArray(s)) {
          let o = r.get(s)
          return o || ((o = (0, xg.default)(t, s, n)), r.set(s, o)), Ng(o(a))
        } else if (typeof s == 'object' && s) {
          if (a.length > 0) throw new Error('Unexpected extra params.')
          return kg(t, (0, Fr.merge)(n, (0, Fr.validate)(s)))
        }
        throw new Error(`Unexpected template param ${typeof s}`)
      },
      {
        ast: (s, ...a) => {
          if (typeof s == 'string') {
            if (a.length > 1) throw new Error('Unexpected extra params.')
            return (0, Cg.default)(t, s, (0, Fr.merge)((0, Fr.merge)(n, (0, Fr.validate)(a[0])), Ig))()
          } else if (Array.isArray(s)) {
            let o = i.get(s)
            return o || ((o = (0, xg.default)(t, s, (0, Fr.merge)(n, Ig))), i.set(s, o)), o(a)()
          }
          throw new Error(`Unexpected template param ${typeof s}`)
        },
      }
    )
  }
  function Ng(t) {
    let e = ''
    try {
      throw new Error()
    } catch (r) {
      r.stack &&
        (e = r.stack
          .split(
            `
`
          )
          .slice(3).join(`
`))
    }
    return (r) => {
      try {
        return t(r)
      } catch (i) {
        throw (
          ((i.stack += `
    =============
${e}`),
          i)
        )
      }
    }
  }
  Object.defineProperty(or, '__esModule', { value: !0 }),
    (or.statements = or.statement = or.smart = or.program = or.expression = or.default = void 0)
  var Ys = yr,
    Hs = mp
  const ol = (0, Hs.default)(Ys.smart)
  or.smart = ol
  const Og = (0, Hs.default)(Ys.statement)
  or.statement = Og
  const Dg = (0, Hs.default)(Ys.statements)
  or.statements = Dg
  const Bg = (0, Hs.default)(Ys.expression)
  or.expression = Bg
  const Lg = (0, Hs.default)(Ys.program)
  or.program = Lg
  var ZW = Object.assign(ol.bind(void 0), {
    smart: ol,
    statement: Og,
    statements: Dg,
    expression: Bg,
    program: Lg,
    ast: ol.ast,
  })
  ;(or.default = ZW), Object.defineProperty(hp, '__esModule', { value: !0 }), (hp.default = bY)
  var Mg = or,
    QW = st
  const {
    NOT_LOCAL_BINDING: Fg,
    cloneNode: eY,
    identifier: tY,
    isAssignmentExpression: rY,
    isAssignmentPattern: iY,
    isFunction: $g,
    isIdentifier: Rg,
    isLiteral: jg,
    isNullLiteral: nY,
    isObjectMethod: sY,
    isObjectProperty: aY,
    isRegExpLiteral: oY,
    isRestElement: lY,
    isTemplateLiteral: uY,
    isVariableDeclarator: cY,
    toBindingIdentifierName: pY,
  } = QW
  function fY(t) {
    const e = t.params.findIndex((r) => iY(r) || lY(r))
    return e === -1 ? t.params.length : e
  }
  const hY = (0, Mg.default)(`
  (function (FUNCTION_KEY) {
    function FUNCTION_ID() {
      return FUNCTION_KEY.apply(this, arguments);
    }

    FUNCTION_ID.toString = function () {
      return FUNCTION_KEY.toString();
    }

    return FUNCTION_ID;
  })(FUNCTION)
`),
    dY = (0, Mg.default)(`
  (function (FUNCTION_KEY) {
    function* FUNCTION_ID() {
      return yield* FUNCTION_KEY.apply(this, arguments);
    }

    FUNCTION_ID.toString = function () {
      return FUNCTION_KEY.toString();
    };

    return FUNCTION_ID;
  })(FUNCTION)
`),
    mY = {
      'ReferencedIdentifier|BindingIdentifier'(t, e) {
        t.node.name !== e.name ||
          t.scope.getBindingIdentifier(e.name) !== e.outerDeclar ||
          ((e.selfReference = !0), t.stop())
      },
    }
  function yY(t) {
    return nY(t)
      ? 'null'
      : oY(t)
      ? `_${t.pattern}_${t.flags}`
      : uY(t)
      ? t.quasis.map((e) => e.value.raw).join('')
      : t.value !== void 0
      ? t.value + ''
      : ''
  }
  function gY(t, e, r, i) {
    if (t.selfReference)
      if (i.hasBinding(r.name) && !i.hasGlobal(r.name)) i.rename(r.name)
      else {
        if (!$g(e)) return
        let n = hY
        e.generator && (n = dY)
        const s = n({ FUNCTION: e, FUNCTION_ID: r, FUNCTION_KEY: i.generateUidIdentifier(r.name) }).expression,
          a = s.callee.body.body[0].params
        for (let o = 0, u = fY(e); o < u; o++) a.push(i.generateUidIdentifier('x'))
        return s
      }
    ;(e.id = r), (i.getProgramParent().references[r.name] = !0)
  }
  function TY(t, e, r) {
    const i = {
        selfAssignment: !1,
        selfReference: !1,
        outerDeclar: r.getBindingIdentifier(e),
        references: [],
        name: e,
      },
      n = r.getOwnBinding(e)
    return (
      n ? n.kind === 'param' && (i.selfReference = !0) : (i.outerDeclar || r.hasGlobal(e)) && r.traverse(t, mY, i), i
    )
  }
  function bY({ node: t, parent: e, scope: r, id: i }, n = !1, s = !1) {
    if (t.id) return
    if ((aY(e) || sY(e, { kind: 'method' })) && (!e.computed || jg(e.key))) i = e.key
    else if (cY(e)) {
      if (((i = e.id), Rg(i) && !n)) {
        const u = r.parent.getBinding(i.name)
        if (u && u.constant && r.getBinding(i.name) === u) {
          ;(t.id = eY(i)), (t.id[Fg] = !0)
          return
        }
      }
    } else if (rY(e, { operator: '=' })) i = e.left
    else if (!i) return
    let a
    if (
      (i && jg(i) ? (a = yY(i)) : i && Rg(i) && (a = i.name),
      a === void 0 || (!s && $g(t) && /[\uD800-\uDFFF]/.test(a)))
    )
      return
    ;(a = pY(a)), (i = tY(a)), (i[Fg] = !0)
    const o = TY(t, a, r)
    return gY(o, t, i, r) || t
  }
  Object.defineProperty(an, '__esModule', { value: !0 }),
    (an.arrowFunctionToExpression = VY),
    (an.arrowFunctionToShadowed = jY),
    (an.ensureBlock = RY),
    (an.toComputedKey = $Y),
    (an.unwrapFunctionEnvironment = _Y)
  var SY = st,
    tf = Xi,
    vY = hp,
    rf = Tn
  const {
    arrowFunctionExpression: nf,
    assignmentExpression: hn,
    binaryExpression: sf,
    blockStatement: EY,
    callExpression: qs,
    conditionalExpression: PY,
    expressionStatement: _g,
    identifier: It,
    isIdentifier: wY,
    jsxIdentifier: AY,
    logicalExpression: CY,
    LOGICAL_OPERATORS: xY,
    memberExpression: $r,
    metaProperty: IY,
    numericLiteral: kY,
    objectExpression: NY,
    restElement: OY,
    returnStatement: DY,
    sequenceExpression: BY,
    spreadElement: LY,
    stringLiteral: Vg,
    super: af,
    thisExpression: ll,
    toExpression: MY,
    unaryExpression: FY,
  } = SY
  function $Y() {
    let t
    if (this.isMemberExpression()) t = this.node.property
    else if (this.isProperty() || this.isMethod()) t = this.node.key
    else throw new ReferenceError('todo')
    return this.node.computed || (wY(t) && (t = Vg(t.name))), t
  }
  function RY() {
    const t = this.get('body'),
      e = t.node
    if (Array.isArray(t)) throw new Error("Can't convert array path to a block statement")
    if (!e) throw new Error("Can't convert node without a body")
    if (t.isBlockStatement()) return e
    const r = []
    let i = 'body',
      n,
      s
    t.isStatement()
      ? ((s = 'body'), (n = 0), r.push(t.node))
      : ((i += '.body.0'),
        this.isFunction() ? ((n = 'argument'), r.push(DY(t.node))) : ((n = 'expression'), r.push(_g(t.node)))),
      (this.node.body = EY(r))
    const a = this.get(i)
    return t.setup(a, s ? a.node[s] : a.node, s, n), this.node
  }
  function jY() {
    !this.isArrowFunctionExpression() || this.arrowFunctionToExpression()
  }
  function _Y() {
    if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration())
      throw this.buildCodeFrameError('Can only unwrap the environment of a function.')
    Ug(this)
  }
  function VY({ allowInsertArrow: t = !0, specCompliant: e = !1, noNewArrows: r = !e } = {}) {
    if (!this.isArrowFunctionExpression())
      throw this.buildCodeFrameError('Cannot convert non-arrow function to a function expression.')
    const { thisBinding: i, fnPath: n } = Ug(this, r, t)
    if ((n.ensureBlock(), (n.node.type = 'FunctionExpression'), !r)) {
      const s = i ? null : n.scope.generateUidIdentifier('arrowCheckId')
      s && n.parentPath.scope.push({ id: s, init: NY([]) }),
        n.get('body').unshiftContainer('body', _g(qs(this.hub.addHelper('newArrowCheck'), [ll(), It(s ? s.name : i)]))),
        n.replaceWith(qs($r((0, vY.default)(this, !0) || n.node, It('bind')), [s ? It(s.name) : ll()]))
    }
  }
  const UY = (0, rf.merge)([
    {
      CallExpression(t, { allSuperCalls: e }) {
        !t.get('callee').isSuper() || e.push(t)
      },
    },
    tf.default,
  ])
  function Ug(t, e = !0, r = !0) {
    let i,
      n = t.findParent((f) => {
        if (f.isArrowFunctionExpression()) {
          var d
          return (d = i) != null || (i = f), !1
        }
        return (
          f.isFunction() ||
          f.isProgram() ||
          f.isClassProperty({ static: !1 }) ||
          f.isClassPrivateProperty({ static: !1 })
        )
      })
    const s = n.isClassMethod({ kind: 'constructor' })
    if (n.isClassProperty() || n.isClassPrivateProperty())
      if (i) n = i
      else if (r) t.replaceWith(qs(nf([], MY(t.node)), [])), (n = t.get('callee')), (t = n.get('body'))
      else throw t.buildCodeFrameError('Unable to transform arrow inside class property')
    const { thisPaths: a, argumentsPaths: o, newTargetPaths: u, superProps: c, superCalls: p } = GY(t)
    if (s && p.length > 0) {
      if (!r) throw p[0].buildCodeFrameError('Unable to handle nested super() usage in arrow')
      const f = []
      n.traverse(UY, { allSuperCalls: f })
      const d = HY(n)
      f.forEach((T) => {
        const y = It(d)
        ;(y.loc = T.node.callee.loc), T.get('callee').replaceWith(y)
      })
    }
    if (o.length > 0) {
      const f = Xs(n, 'arguments', () => {
        const d = () => It('arguments')
        return n.scope.path.isProgram()
          ? PY(sf('===', FY('typeof', d()), Vg('undefined')), n.scope.buildUndefinedNode(), d())
          : d()
      })
      o.forEach((d) => {
        const T = It(f)
        ;(T.loc = d.node.loc), d.replaceWith(T)
      })
    }
    if (u.length > 0) {
      const f = Xs(n, 'newtarget', () => IY(It('new'), It('target')))
      u.forEach((d) => {
        const T = It(f)
        ;(T.loc = d.node.loc), d.replaceWith(T)
      })
    }
    if (c.length > 0) {
      if (!r) throw c[0].buildCodeFrameError('Unable to handle nested super.prop usage')
      c.reduce((d, T) => d.concat(KY(T)), []).forEach((d) => {
        const T = d.node.computed ? '' : d.get('property').node.name,
          y = d.parentPath.isAssignmentExpression({ left: d.node }),
          b = d.parentPath.isCallExpression({ callee: d.node }),
          m = qY(n, y, T),
          S = []
        if ((d.node.computed && S.push(d.get('property').node), y)) {
          const P = d.parentPath.node.right
          S.push(P)
        }
        const E = qs(It(m), S)
        b
          ? (d.parentPath.unshiftContainer('arguments', ll()),
            d.replaceWith($r(E, It('call'))),
            a.push(d.parentPath.get('arguments.0')))
          : y
          ? d.parentPath.replaceWith(E)
          : d.replaceWith(E)
      })
    }
    let h
    return (
      (a.length > 0 || !e) &&
        ((h = YY(n, s)),
        (e || (s && zg(n))) &&
          (a.forEach((f) => {
            const d = f.isJSX() ? AY(h) : It(h)
            ;(d.loc = f.node.loc), f.replaceWith(d)
          }),
          e || (h = null))),
      { thisBinding: h, fnPath: t }
    )
  }
  function zY(t) {
    return xY.includes(t)
  }
  function KY(t) {
    if (t.parentPath.isAssignmentExpression() && t.parentPath.node.operator !== '=') {
      const r = t.parentPath,
        i = r.node.operator.slice(0, -1),
        n = r.node.right,
        s = zY(i)
      if (t.node.computed) {
        const a = t.scope.generateDeclaredUidIdentifier('tmp'),
          o = t.node.object,
          u = t.node.property
        r.get('left').replaceWith($r(o, hn('=', a, u), !0)),
          r.get('right').replaceWith(e(s ? '=' : i, $r(o, It(a.name), !0), n))
      } else {
        const a = t.node.object,
          o = t.node.property
        r.get('left').replaceWith($r(a, o)), r.get('right').replaceWith(e(s ? '=' : i, $r(a, It(o.name)), n))
      }
      return (
        s ? r.replaceWith(CY(i, r.node.left, r.node.right)) : (r.node.operator = '='),
        [r.get('left'), r.get('right').get('left')]
      )
    } else if (t.parentPath.isUpdateExpression()) {
      const r = t.parentPath,
        i = t.scope.generateDeclaredUidIdentifier('tmp'),
        n = t.node.computed ? t.scope.generateDeclaredUidIdentifier('prop') : null,
        s = [
          hn('=', i, $r(t.node.object, n ? hn('=', n, t.node.property) : t.node.property, t.node.computed)),
          hn(
            '=',
            $r(t.node.object, n ? It(n.name) : t.node.property, t.node.computed),
            sf(t.parentPath.node.operator[0], It(i.name), kY(1))
          ),
        ]
      t.parentPath.node.prefix || s.push(It(i.name)), r.replaceWith(BY(s))
      const a = r.get('expressions.0.right'),
        o = r.get('expressions.1.left')
      return [a, o]
    }
    return [t]
    function e(r, i, n) {
      return r === '=' ? hn('=', i, n) : sf(r, i, n)
    }
  }
  function zg(t) {
    return t.isClassMethod() && !!t.parentPath.parentPath.node.superClass
  }
  const WY = (0, rf.merge)([
    {
      CallExpression(t, { supers: e, thisBinding: r }) {
        !t.get('callee').isSuper() ||
          e.has(t.node) ||
          (e.add(t.node), t.replaceWithMultiple([t.node, hn('=', It(r), It('this'))]))
      },
    },
    tf.default,
  ])
  function YY(t, e) {
    return Xs(t, 'this', (r) => {
      if (!e || !zg(t)) return ll()
      t.traverse(WY, { supers: new WeakSet(), thisBinding: r })
    })
  }
  function HY(t) {
    return Xs(t, 'supercall', () => {
      const e = t.scope.generateUidIdentifier('args')
      return nf([OY(e)], qs(af(), [LY(It(e.name))]))
    })
  }
  function qY(t, e, r) {
    return Xs(t, `superprop_${e ? 'set' : 'get'}:${r || ''}`, () => {
      const n = []
      let s
      if (r) s = $r(af(), It(r))
      else {
        const a = t.scope.generateUidIdentifier('prop')
        n.unshift(a), (s = $r(af(), It(a.name), !0))
      }
      if (e) {
        const a = t.scope.generateUidIdentifier('value')
        n.push(a), (s = hn('=', s, It(a.name)))
      }
      return nf(n, s)
    })
  }
  function Xs(t, e, r) {
    const i = 'binding:' + e
    let n = t.getData(i)
    if (!n) {
      const s = t.scope.generateUidIdentifier(e)
      ;(n = s.name), t.setData(i, n), t.scope.push({ id: s, init: r(n) })
    }
    return n
  }
  const XY = (0, rf.merge)([
    {
      ThisExpression(t, { thisPaths: e }) {
        e.push(t)
      },
      JSXIdentifier(t, { thisPaths: e }) {
        t.node.name === 'this' &&
          ((!t.parentPath.isJSXMemberExpression({ object: t.node }) &&
            !t.parentPath.isJSXOpeningElement({ name: t.node })) ||
            e.push(t))
      },
      CallExpression(t, { superCalls: e }) {
        t.get('callee').isSuper() && e.push(t)
      },
      MemberExpression(t, { superProps: e }) {
        t.get('object').isSuper() && e.push(t)
      },
      Identifier(t, { argumentsPaths: e }) {
        if (!t.isReferencedIdentifier({ name: 'arguments' })) return
        let r = t.scope
        do {
          if (r.hasOwnBinding('arguments')) {
            r.rename('arguments')
            return
          }
          if (r.path.isFunction() && !r.path.isArrowFunctionExpression()) break
        } while ((r = r.parent))
        e.push(t)
      },
      MetaProperty(t, { newTargetPaths: e }) {
        !t.get('meta').isIdentifier({ name: 'new' }) || !t.get('property').isIdentifier({ name: 'target' }) || e.push(t)
      },
    },
    tf.default,
  ])
  function GY(t) {
    const e = [],
      r = [],
      i = [],
      n = [],
      s = []
    return (
      t.traverse(XY, { thisPaths: e, argumentsPaths: r, newTargetPaths: i, superProps: n, superCalls: s }),
      { thisPaths: e, argumentsPaths: r, newTargetPaths: i, superProps: n, superCalls: s }
    )
  }
  var Ot = {}
  Object.defineProperty(Ot, '__esModule', { value: !0 }),
    (Ot._guessExecutionStatusRelativeTo = SH),
    (Ot._resolve = wH),
    (Ot.canHaveVariableDeclarationOrExpression = fH),
    (Ot.canSwapBetweenExpressionAndStatement = hH),
    (Ot.equals = cH),
    (Ot.getSource = gH),
    (Ot.has = Wg),
    (Ot.is = void 0),
    (Ot.isCompletionRecord = dH),
    (Ot.isConstantExpression = AH),
    (Ot.isInStrictMode = CH),
    (Ot.isNodeType = pH),
    (Ot.isStatementOrBlock = mH),
    (Ot.isStatic = oH),
    (Ot.isnt = uH),
    (Ot.matchesPattern = aH),
    (Ot.referencesImport = yH),
    (Ot.resolve = PH),
    (Ot.willIMaybeExecuteBefore = TH)
  var JY = st
  const {
    STATEMENT_OR_BLOCK_KEYS: ZY,
    VISITOR_KEYS: QY,
    isBlockStatement: Kg,
    isExpression: eH,
    isIdentifier: tH,
    isLiteral: rH,
    isStringLiteral: iH,
    isType: nH,
    matchesPattern: sH,
  } = JY
  function aH(t, e) {
    return sH(this.node, t, e)
  }
  function Wg(t) {
    const e = this.node && this.node[t]
    return e && Array.isArray(e) ? !!e.length : !!e
  }
  function oH() {
    return this.scope.isStatic(this.node)
  }
  const lH = Wg
  Ot.is = lH
  function uH(t) {
    return !this.has(t)
  }
  function cH(t, e) {
    return this.node[t] === e
  }
  function pH(t) {
    return nH(this.type, t)
  }
  function fH() {
    return (this.key === 'init' || this.key === 'left') && this.parentPath.isFor()
  }
  function hH(t) {
    return this.key !== 'body' || !this.parentPath.isArrowFunctionExpression()
      ? !1
      : this.isExpression()
      ? Kg(t)
      : this.isBlockStatement()
      ? eH(t)
      : !1
  }
  function dH(t) {
    let e = this,
      r = !0
    do {
      const { type: i, container: n } = e
      if (!r && (e.isFunction() || i === 'StaticBlock')) return !!t
      if (((r = !1), Array.isArray(n) && e.key !== n.length - 1)) return !1
    } while ((e = e.parentPath) && !e.isProgram() && !e.isDoExpression())
    return !0
  }
  function mH() {
    return this.parentPath.isLabeledStatement() || Kg(this.container) ? !1 : ZY.includes(this.key)
  }
  function yH(t, e) {
    if (!this.isReferencedIdentifier()) {
      if (
        (this.isJSXMemberExpression() && this.node.property.name === e) ||
        ((this.isMemberExpression() || this.isOptionalMemberExpression()) &&
          (this.node.computed ? iH(this.node.property, { value: e }) : this.node.property.name === e))
      ) {
        const s = this.get('object')
        return s.isReferencedIdentifier() && s.referencesImport(t, '*')
      }
      return !1
    }
    const r = this.scope.getBinding(this.node.name)
    if (!r || r.kind !== 'module') return !1
    const i = r.path,
      n = i.parentPath
    if (!n.isImportDeclaration()) return !1
    if (n.node.source.value === t) {
      if (!e) return !0
    } else return !1
    return !!(
      (i.isImportDefaultSpecifier() && e === 'default') ||
      (i.isImportNamespaceSpecifier() && e === '*') ||
      (i.isImportSpecifier() && tH(i.node.imported, { name: e }))
    )
  }
  function gH() {
    const t = this.node
    if (t.end) {
      const e = this.hub.getCode()
      if (e) return e.slice(t.start, t.end)
    }
    return ''
  }
  function TH(t) {
    return this._guessExecutionStatusRelativeTo(t) !== 'after'
  }
  function Yg(t) {
    return (t.scope.getFunctionParent() || t.scope.getProgramParent()).path
  }
  function bH(t, e) {
    switch (t) {
      case 'LogicalExpression':
        return e === 'right'
      case 'ConditionalExpression':
      case 'IfStatement':
        return e === 'consequent' || e === 'alternate'
      case 'WhileStatement':
      case 'DoWhileStatement':
      case 'ForInStatement':
      case 'ForOfStatement':
        return e === 'body'
      case 'ForStatement':
        return e === 'body' || e === 'update'
      case 'SwitchStatement':
        return e === 'cases'
      case 'TryStatement':
        return e === 'handler'
      case 'AssignmentPattern':
        return e === 'right'
      case 'OptionalMemberExpression':
        return e === 'property'
      case 'OptionalCallExpression':
        return e === 'arguments'
      default:
        return !1
    }
  }
  function Hg(t, e) {
    for (let r = 0; r < e; r++) {
      const i = t[r]
      if (bH(i.parent.type, i.parentKey)) return !0
    }
    return !1
  }
  function SH(t) {
    return qg(this, t, new Map())
  }
  function qg(t, e, r) {
    const i = { this: Yg(t), target: Yg(e) }
    if (i.target.node !== i.this.node) return EH(t, i.target, r)
    const n = { target: e.getAncestry(), this: t.getAncestry() }
    if (n.target.indexOf(t) >= 0) return 'after'
    if (n.this.indexOf(e) >= 0) return 'before'
    let s
    const a = { target: 0, this: 0 }
    for (; !s && a.this < n.this.length; ) {
      const p = n.this[a.this]
      ;(a.target = n.target.indexOf(p)), a.target >= 0 ? (s = p) : a.this++
    }
    if (!s) throw new Error("Internal Babel error - The two compared nodes don't appear to belong to the same program.")
    if (Hg(n.this, a.this - 1) || Hg(n.target, a.target - 1)) return 'unknown'
    const o = { this: n.this[a.this - 1], target: n.target[a.target - 1] }
    if (o.target.listKey && o.this.listKey && o.target.container === o.this.container)
      return o.target.key > o.this.key ? 'before' : 'after'
    const u = QY[s.type],
      c = { this: u.indexOf(o.this.parentKey), target: u.indexOf(o.target.parentKey) }
    return c.target > c.this ? 'before' : 'after'
  }
  const of = new Set()
  function vH(t, e, r) {
    if (!e.isFunctionDeclaration() || e.parentPath.isExportDeclaration()) return 'unknown'
    const i = e.scope.getBinding(e.node.id.name)
    if (!i.references) return 'before'
    const n = i.referencePaths
    let s
    for (const a of n)
      if (!a.find((u) => u.node === e.node)) {
        if (a.key !== 'callee' || !a.parentPath.isCallExpression()) return 'unknown'
        if (!of.has(a.node)) {
          of.add(a.node)
          try {
            const u = qg(t, a, r)
            if (s && s !== u) return 'unknown'
            s = u
          } finally {
            of.delete(a.node)
          }
        }
      }
    return s
  }
  function EH(t, e, r) {
    let i = r.get(t.node)
    if (!i) r.set(t.node, (i = new Map()))
    else if (i.has(e.node)) return i.get(e.node)
    const n = vH(t, e, r)
    return i.set(e.node, n), n
  }
  function PH(t, e) {
    return this._resolve(t, e) || this
  }
  function wH(t, e) {
    if (!(e && e.indexOf(this) >= 0))
      if (((e = e || []), e.push(this), this.isVariableDeclarator())) {
        if (this.get('id').isIdentifier()) return this.get('init').resolve(t, e)
      } else if (this.isReferencedIdentifier()) {
        const r = this.scope.getBinding(this.node.name)
        if (!r || !r.constant || r.kind === 'module') return
        if (r.path !== this) {
          const i = r.path.resolve(t, e)
          return this.find((n) => n.node === i.node) ? void 0 : i
        }
      } else {
        if (this.isTypeCastExpression()) return this.get('expression').resolve(t, e)
        if (t && this.isMemberExpression()) {
          const r = this.toComputedKey()
          if (!rH(r)) return
          const i = r.value,
            n = this.get('object').resolve(t, e)
          if (n.isObjectExpression()) {
            const s = n.get('properties')
            for (const a of s) {
              if (!a.isProperty()) continue
              const o = a.get('key')
              let u = a.isnt('computed') && o.isIdentifier({ name: i })
              if (((u = u || o.isLiteral({ value: i })), u)) return a.get('value').resolve(t, e)
            }
          } else if (n.isArrayExpression() && !isNaN(+i)) {
            const a = n.get('elements')[i]
            if (a) return a.resolve(t, e)
          }
        }
      }
  }
  function AH() {
    if (this.isIdentifier()) {
      const t = this.scope.getBinding(this.node.name)
      return t ? t.constant : !1
    }
    return this.isLiteral()
      ? this.isRegExpLiteral()
        ? !1
        : this.isTemplateLiteral()
        ? this.get('expressions').every((t) => t.isConstantExpression())
        : !0
      : this.isUnaryExpression()
      ? this.node.operator !== 'void'
        ? !1
        : this.get('argument').isConstantExpression()
      : this.isBinaryExpression()
      ? this.get('left').isConstantExpression() && this.get('right').isConstantExpression()
      : !1
  }
  function CH() {
    return !!(this.isProgram() ? this : this.parentPath).find((r) => {
      if (r.isProgram({ sourceType: 'module' }) || r.isClass()) return !0
      if ((!r.isProgram() && !r.isFunction()) || (r.isArrowFunctionExpression() && !r.get('body').isBlockStatement()))
        return !1
      const i = r.isFunction() ? r.node.body : r.node
      for (const n of i.directives) if (n.value.value === 'use strict') return !0
    })
  }
  var Nt = {}
  Object.defineProperty(Nt, '__esModule', { value: !0 }),
    (Nt._call = kH),
    (Nt._getQueueContexts = HH),
    (Nt._resyncKey = jH),
    (Nt._resyncList = _H),
    (Nt._resyncParent = RH),
    (Nt._resyncRemoved = VH),
    (Nt.call = IH),
    (Nt.isBlacklisted = Nt.isDenylisted = NH),
    (Nt.popContext = UH),
    (Nt.pushContext = zH),
    (Nt.requeue = YH),
    (Nt.resync = $H),
    (Nt.setContext = FH),
    (Nt.setKey = WH),
    (Nt.setScope = MH),
    (Nt.setup = KH),
    (Nt.skip = DH),
    (Nt.skipKey = BH),
    (Nt.stop = LH),
    (Nt.visit = OH)
  var xH = Ja,
    Xg = Ut
  function IH(t) {
    const e = this.opts
    return (
      this.debug(t),
      this.node && this._call(e[t]) ? !0 : this.node ? this._call(e[this.node.type] && e[this.node.type][t]) : !1
    )
  }
  function kH(t) {
    if (!t) return !1
    for (const e of t) {
      if (!e) continue
      const r = this.node
      if (!r) return !0
      const i = e.call(this.state, this, this.state)
      if (i && typeof i == 'object' && typeof i.then == 'function')
        throw new Error(
          "You appear to be using a plugin with an async traversal visitor, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version."
        )
      if (i) throw new Error(`Unexpected return value from visitor method ${e}`)
      if (this.node !== r || this._traverseFlags > 0) return !0
    }
    return !1
  }
  function NH() {
    var t
    const e = (t = this.opts.denylist) != null ? t : this.opts.blacklist
    return e && e.indexOf(this.node.type) > -1
  }
  function Gg(t, e) {
    t.context !== e && ((t.context = e), (t.state = e.state), (t.opts = e.opts))
  }
  function OH() {
    if (!this.node || this.isDenylisted() || (this.opts.shouldSkip && this.opts.shouldSkip(this))) return !1
    const t = this.context
    return this.shouldSkip || this.call('enter')
      ? (this.debug('Skip...'), this.shouldStop)
      : (Gg(this, t),
        this.debug('Recursing into...'),
        (this.shouldStop = (0, xH.traverseNode)(this.node, this.opts, this.scope, this.state, this, this.skipKeys)),
        Gg(this, t),
        this.call('exit'),
        this.shouldStop)
  }
  function DH() {
    this.shouldSkip = !0
  }
  function BH(t) {
    this.skipKeys == null && (this.skipKeys = {}), (this.skipKeys[t] = !0)
  }
  function LH() {
    this._traverseFlags |= Xg.SHOULD_SKIP | Xg.SHOULD_STOP
  }
  function MH() {
    if (this.opts && this.opts.noScope) return
    let t = this.parentPath
    ;(this.key === 'key' || this.listKey === 'decorators') && t.isMethod() && (t = t.parentPath)
    let e
    for (; t && !e; ) {
      if (t.opts && t.opts.noScope) return
      ;(e = t.scope), (t = t.parentPath)
    }
    ;(this.scope = this.getScope(e)), this.scope && this.scope.init()
  }
  function FH(t) {
    return (
      this.skipKeys != null && (this.skipKeys = {}),
      (this._traverseFlags = 0),
      t && ((this.context = t), (this.state = t.state), (this.opts = t.opts)),
      this.setScope(),
      this
    )
  }
  function $H() {
    this.removed || (this._resyncParent(), this._resyncList(), this._resyncKey())
  }
  function RH() {
    this.parentPath && (this.parent = this.parentPath.node)
  }
  function jH() {
    if (!!this.container && this.node !== this.container[this.key]) {
      if (Array.isArray(this.container)) {
        for (let t = 0; t < this.container.length; t++) if (this.container[t] === this.node) return this.setKey(t)
      } else for (const t of Object.keys(this.container)) if (this.container[t] === this.node) return this.setKey(t)
      this.key = null
    }
  }
  function _H() {
    if (!this.parent || !this.inList) return
    const t = this.parent[this.listKey]
    this.container !== t && (this.container = t || null)
  }
  function VH() {
    ;(this.key == null || !this.container || this.container[this.key] !== this.node) && this._markRemoved()
  }
  function UH() {
    this.contexts.pop(),
      this.contexts.length > 0 ? this.setContext(this.contexts[this.contexts.length - 1]) : this.setContext(void 0)
  }
  function zH(t) {
    this.contexts.push(t), this.setContext(t)
  }
  function KH(t, e, r, i) {
    ;(this.listKey = r), (this.container = e), (this.parentPath = t || this.parentPath), this.setKey(i)
  }
  function WH(t) {
    var e
    ;(this.key = t), (this.node = this.container[this.key]), (this.type = (e = this.node) == null ? void 0 : e.type)
  }
  function YH(t = this) {
    if (t.removed) return
    const e = this.contexts
    for (const r of e) r.maybeQueue(t)
  }
  function HH() {
    let t = this,
      e = this.contexts
    for (; !e.length && ((t = t.parentPath), !!t); ) e = t.contexts
    return e
  }
  var Ci = {},
    ul = {}
  Object.defineProperty(ul, '__esModule', { value: !0 }), (ul.hooks = void 0)
  const qH = [
    function (t, e) {
      if (
        (t.key === 'test' && (e.isWhile() || e.isSwitchCase())) ||
        (t.key === 'declaration' && e.isExportDeclaration()) ||
        (t.key === 'body' && e.isLabeledStatement()) ||
        (t.listKey === 'declarations' && e.isVariableDeclaration() && e.node.declarations.length === 1) ||
        (t.key === 'expression' && e.isExpressionStatement())
      )
        return e.remove(), !0
    },
    function (t, e) {
      if (e.isSequenceExpression() && e.node.expressions.length === 1) return e.replaceWith(e.node.expressions[0]), !0
    },
    function (t, e) {
      if (e.isBinary()) return t.key === 'left' ? e.replaceWith(e.node.right) : e.replaceWith(e.node.left), !0
    },
    function (t, e) {
      if (
        (e.isIfStatement() && (t.key === 'consequent' || t.key === 'alternate')) ||
        (t.key === 'body' && (e.isLoop() || e.isArrowFunctionExpression()))
      )
        return t.replaceWith({ type: 'BlockStatement', body: [] }), !0
    },
  ]
  ;(ul.hooks = qH),
    Object.defineProperty(Ci, '__esModule', { value: !0 }),
    (Ci._assertUnremoved = rq),
    (Ci._callRemovalHooks = QH),
    (Ci._markRemoved = tq),
    (Ci._remove = eq),
    (Ci._removeFromScope = ZH),
    (Ci.remove = JH)
  var XH = ul,
    GH = Vt,
    Jg = Ut
  function JH() {
    var t
    if (
      (this._assertUnremoved(),
      this.resync(),
      ((t = this.opts) != null && t.noScope) || this._removeFromScope(),
      this._callRemovalHooks())
    ) {
      this._markRemoved()
      return
    }
    this.shareCommentsWithSiblings(), this._remove(), this._markRemoved()
  }
  function ZH() {
    const t = this.getBindingIdentifiers()
    Object.keys(t).forEach((e) => this.scope.removeBinding(e))
  }
  function QH() {
    for (const t of XH.hooks) if (t(this, this.parentPath)) return !0
  }
  function eq() {
    Array.isArray(this.container)
      ? (this.container.splice(this.key, 1), this.updateSiblingKeys(this.key, -1))
      : this._replaceWith(null)
  }
  function tq() {
    ;(this._traverseFlags |= Jg.SHOULD_SKIP | Jg.REMOVED),
      this.parent && GH.path.get(this.parent).delete(this.node),
      (this.node = null)
  }
  function rq() {
    if (this.removed) throw this.buildCodeFrameError('NodePath has been removed so is read-only.')
  }
  var gr = {},
    cl = {}
  Object.defineProperty(cl, '__esModule', { value: !0 }), (cl.default = void 0)
  var Zg = st,
    iq = Zg
  const { react: nq } = Zg,
    { cloneNode: sq, jsxExpressionContainer: aq, variableDeclaration: oq, variableDeclarator: lq } = iq,
    uq = {
      ReferencedIdentifier(t, e) {
        if (t.isJSXIdentifier() && nq.isCompatTag(t.node.name) && !t.parentPath.isJSXMemberExpression()) return
        if (t.node.name === 'this') {
          let i = t.scope
          do if (i.path.isFunction() && !i.path.isArrowFunctionExpression()) break
          while ((i = i.parent))
          i && e.breakOnScopePaths.push(i.path)
        }
        const r = t.scope.getBinding(t.node.name)
        if (!!r) {
          for (const i of r.constantViolations)
            if (i.scope !== r.path.scope) {
              ;(e.mutableBinding = !0), t.stop()
              return
            }
          r === e.scope.getBinding(t.node.name) && (e.bindings[t.node.name] = r)
        }
      },
    }
  class cq {
    constructor(e, r) {
      ;(this.breakOnScopePaths = void 0),
        (this.bindings = void 0),
        (this.mutableBinding = void 0),
        (this.scopes = void 0),
        (this.scope = void 0),
        (this.path = void 0),
        (this.attachAfter = void 0),
        (this.breakOnScopePaths = []),
        (this.bindings = {}),
        (this.mutableBinding = !1),
        (this.scopes = []),
        (this.scope = r),
        (this.path = e),
        (this.attachAfter = !1)
    }
    isCompatibleScope(e) {
      for (const r of Object.keys(this.bindings)) {
        const i = this.bindings[r]
        if (!e.bindingIdentifierEquals(r, i.identifier)) return !1
      }
      return !0
    }
    getCompatibleScopes() {
      let e = this.path.scope
      do {
        if (this.isCompatibleScope(e)) this.scopes.push(e)
        else break
        if (this.breakOnScopePaths.indexOf(e.path) >= 0) break
      } while ((e = e.parent))
    }
    getAttachmentPath() {
      let e = this._getAttachmentPath()
      if (!e) return
      let r = e.scope
      if ((r.path === e && (r = e.scope.parent), r.path.isProgram() || r.path.isFunction()))
        for (const i of Object.keys(this.bindings)) {
          if (!r.hasOwnBinding(i)) continue
          const n = this.bindings[i]
          if (n.kind === 'param' || n.path.parentKey === 'params') continue
          if (this.getAttachmentParentForPath(n.path).key >= e.key) {
            ;(this.attachAfter = !0), (e = n.path)
            for (const a of n.constantViolations) this.getAttachmentParentForPath(a).key > e.key && (e = a)
          }
        }
      return e
    }
    _getAttachmentPath() {
      const r = this.scopes.pop()
      if (!!r) {
        if (r.path.isFunction())
          if (this.hasOwnParamBindings(r)) {
            if (this.scope === r) return
            const i = r.path.get('body').get('body')
            for (let n = 0; n < i.length; n++) if (!i[n].node._blockHoist) return i[n]
          } else return this.getNextScopeAttachmentParent()
        else if (r.path.isProgram()) return this.getNextScopeAttachmentParent()
      }
    }
    getNextScopeAttachmentParent() {
      const e = this.scopes.pop()
      if (e) return this.getAttachmentParentForPath(e.path)
    }
    getAttachmentParentForPath(e) {
      do if (!e.parentPath || (Array.isArray(e.container) && e.isStatement())) return e
      while ((e = e.parentPath))
    }
    hasOwnParamBindings(e) {
      for (const r of Object.keys(this.bindings)) {
        if (!e.hasOwnBinding(r)) continue
        const i = this.bindings[r]
        if (i.kind === 'param' && i.constant) return !0
      }
      return !1
    }
    run() {
      if ((this.path.traverse(uq, this), this.mutableBinding)) return
      this.getCompatibleScopes()
      const e = this.getAttachmentPath()
      if (!e || e.getFunctionParent() === this.path.getFunctionParent()) return
      let r = e.scope.generateUidIdentifier('ref')
      const i = lq(r, this.path.node),
        n = this.attachAfter ? 'insertAfter' : 'insertBefore',
        [s] = e[n]([e.isVariableDeclarator() ? i : oq('var', [i])]),
        a = this.path.parentPath
      return (
        a.isJSXElement() && this.path.container === a.node.children && (r = aq(r)),
        this.path.replaceWith(sq(r)),
        e.isVariableDeclarator() ? s.get('init') : s.get('declarations.0.init')
      )
    }
  }
  ;(cl.default = cq),
    Object.defineProperty(gr, '__esModule', { value: !0 }),
    (gr._containerInsert = Cq),
    (gr._containerInsertAfter = Iq),
    (gr._containerInsertBefore = xq),
    (gr._verifyNodeList = Dq),
    (gr.hoist = Mq),
    (gr.insertAfter = Nq),
    (gr.insertBefore = Aq),
    (gr.pushContainer = Lq),
    (gr.unshiftContainer = Bq),
    (gr.updateSiblingKeys = Oq)
  var pq = Vt,
    fq = cl,
    lf = Ut,
    hq = st
  const {
    arrowFunctionExpression: dq,
    assertExpression: mq,
    assignmentExpression: yq,
    blockStatement: Qg,
    callExpression: gq,
    cloneNode: uf,
    expressionStatement: cf,
    isAssignmentExpression: Tq,
    isCallExpression: bq,
    isExpression: Sq,
    isIdentifier: vq,
    isSequenceExpression: Eq,
    isSuper: Pq,
    thisExpression: wq,
  } = hq
  function Aq(t) {
    this._assertUnremoved()
    const e = this._verifyNodeList(t),
      { parentPath: r } = this
    if (
      r.isExpressionStatement() ||
      r.isLabeledStatement() ||
      r.isExportNamedDeclaration() ||
      (r.isExportDefaultDeclaration() && this.isDeclaration())
    )
      return r.insertBefore(e)
    if ((this.isNodeType('Expression') && !this.isJSXElement()) || (r.isForStatement() && this.key === 'init'))
      return this.node && e.push(this.node), this.replaceExpressionWithStatements(e)
    if (Array.isArray(this.container)) return this._containerInsertBefore(e)
    if (this.isStatementOrBlock()) {
      const i = this.node,
        n = i && (!this.isExpressionStatement() || i.expression != null)
      return this.replaceWith(Qg(n ? [i] : [])), this.unshiftContainer('body', e)
    } else throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?")
  }
  function Cq(t, e) {
    this.updateSiblingKeys(t, e.length)
    const r = []
    this.container.splice(t, 0, ...e)
    for (let n = 0; n < e.length; n++) {
      const s = t + n,
        a = this.getSibling(s)
      r.push(a), this.context && this.context.queue && a.pushContext(this.context)
    }
    const i = this._getQueueContexts()
    for (const n of r) {
      n.setScope(), n.debug('Inserted.')
      for (const s of i) s.maybeQueue(n, !0)
    }
    return r
  }
  function xq(t) {
    return this._containerInsert(this.key, t)
  }
  function Iq(t) {
    return this._containerInsert(this.key + 1, t)
  }
  const eT = (t) => t[t.length - 1]
  function tT(t) {
    return Eq(t.parent) && (eT(t.parent.expressions) !== t.node || tT(t.parentPath))
  }
  function kq(t, e) {
    if (!Tq(t) || !vq(t.left)) return !1
    const r = e.getBlockParent()
    return r.hasOwnBinding(t.left.name) && r.getOwnBinding(t.left.name).constantViolations.length <= 1
  }
  function Nq(t) {
    if ((this._assertUnremoved(), this.isSequenceExpression())) return eT(this.get('expressions')).insertAfter(t)
    const e = this._verifyNodeList(t),
      { parentPath: r } = this
    if (
      r.isExpressionStatement() ||
      r.isLabeledStatement() ||
      r.isExportNamedDeclaration() ||
      (r.isExportDefaultDeclaration() && this.isDeclaration())
    )
      return r.insertAfter(e.map((i) => (Sq(i) ? cf(i) : i)))
    if (
      (this.isNodeType('Expression') && !this.isJSXElement() && !r.isJSXElement()) ||
      (r.isForStatement() && this.key === 'init')
    ) {
      if (this.node) {
        const i = this.node
        let { scope: n } = this
        if (n.path.isPattern())
          return mq(i), this.replaceWith(gq(dq([], i), [])), this.get('callee.body').insertAfter(e), [this]
        if (tT(this)) e.unshift(i)
        else if (bq(i) && Pq(i.callee)) e.unshift(i), e.push(wq())
        else if (kq(i, n)) e.unshift(i), e.push(uf(i.left))
        else if (n.isPure(i, !0)) e.push(i)
        else {
          r.isMethod({ computed: !0, key: i }) && (n = n.parent)
          const s = n.generateDeclaredUidIdentifier()
          e.unshift(cf(yq('=', uf(s), i))), e.push(cf(uf(s)))
        }
      }
      return this.replaceExpressionWithStatements(e)
    } else {
      if (Array.isArray(this.container)) return this._containerInsertAfter(e)
      if (this.isStatementOrBlock()) {
        const i = this.node,
          n = i && (!this.isExpressionStatement() || i.expression != null)
        return this.replaceWith(Qg(n ? [i] : [])), this.pushContainer('body', e)
      } else
        throw new Error(
          "We don't know what to do with this node type. We were previously a Statement but we can't fit in here?"
        )
    }
  }
  function Oq(t, e) {
    if (!this.parent) return
    const r = pq.path.get(this.parent)
    for (const [, i] of r) i.key >= t && (i.key += e)
  }
  function Dq(t) {
    if (!t) return []
    Array.isArray(t) || (t = [t])
    for (let e = 0; e < t.length; e++) {
      const r = t[e]
      let i
      if (
        (r
          ? typeof r != 'object'
            ? (i = 'contains a non-object node')
            : r.type
            ? r instanceof lf.default && (i = 'has a NodePath when it expected a raw object')
            : (i = 'without a type')
          : (i = 'has falsy node'),
        i)
      ) {
        const n = Array.isArray(r) ? 'array' : typeof r
        throw new Error(`Node list ${i} with the index of ${e} and type of ${n}`)
      }
    }
    return t
  }
  function Bq(t, e) {
    return (
      this._assertUnremoved(),
      (e = this._verifyNodeList(e)),
      lf.default
        .get({ parentPath: this, parent: this.node, container: this.node[t], listKey: t, key: 0 })
        .setContext(this.context)
        ._containerInsertBefore(e)
    )
  }
  function Lq(t, e) {
    this._assertUnremoved()
    const r = this._verifyNodeList(e),
      i = this.node[t]
    return lf.default
      .get({ parentPath: this, parent: this.node, container: i, listKey: t, key: i.length })
      .setContext(this.context)
      .replaceWithMultiple(r)
  }
  function Mq(t = this.scope) {
    return new fq.default(this, t).run()
  }
  var Ht = {}
  Object.defineProperty(Ht, '__esModule', { value: !0 }),
    (Ht._getKey = Qq),
    (Ht._getPattern = eX),
    (Ht.get = Zq),
    (Ht.getAllNextSiblings = Gq),
    (Ht.getAllPrevSiblings = Jq),
    (Ht.getBindingIdentifierPaths = iX),
    (Ht.getBindingIdentifiers = tX),
    (Ht.getCompletionRecords = Yq),
    (Ht.getNextSibling = Xq),
    (Ht.getOpposite = zq),
    (Ht.getOuterBindingIdentifierPaths = nX),
    (Ht.getOuterBindingIdentifiers = rX),
    (Ht.getPrevSibling = qq),
    (Ht.getSibling = Hq)
  var pf = Ut,
    Fq = st
  const {
      getBindingIdentifiers: rT,
      getOuterBindingIdentifiers: $q,
      isDeclaration: Rq,
      numericLiteral: jq,
      unaryExpression: _q,
    } = Fq,
    ff = 0,
    Gs = 1
  function Vq(t) {
    return { type: ff, path: t }
  }
  function Uq(t) {
    return { type: Gs, path: t }
  }
  function zq() {
    return this.key === 'left' ? this.getSibling('right') : this.key === 'right' ? this.getSibling('left') : null
  }
  function zn(t, e, r) {
    return t && e.push(...Kn(t, r)), e
  }
  function Kq(t, e, r) {
    let i = []
    for (let n = 0; n < t.length; n++) {
      const s = t[n],
        a = Kn(s, r),
        o = [],
        u = []
      for (const c of a) c.type === ff && o.push(c), c.type === Gs && u.push(c)
      o.length && (i = o), e.push(...u)
    }
    return e.push(...i), e
  }
  function Wq(t) {
    t.forEach((e) => {
      e.type = Gs
    })
  }
  function hf(t, e) {
    t.forEach((r) => {
      r.path.isBreakStatement({ label: null }) && (e ? r.path.replaceWith(_q('void', jq(0))) : r.path.remove())
    })
  }
  function iT(t, e) {
    const r = []
    if (e.canHaveBreak) {
      let i = []
      for (let n = 0; n < t.length; n++) {
        const s = t[n],
          a = Object.assign({}, e, { inCaseClause: !1 })
        s.isBlockStatement() && (e.inCaseClause || e.shouldPopulateBreak)
          ? (a.shouldPopulateBreak = !0)
          : (a.shouldPopulateBreak = !1)
        const o = Kn(s, a)
        if (o.length > 0 && o.every((u) => u.type === Gs)) {
          i.length > 0 && o.every((u) => u.path.isBreakStatement({ label: null }))
            ? (Wq(i), r.push(...i), i.some((u) => u.path.isDeclaration()) && (r.push(...o), hf(o, !0)), hf(o, !1))
            : (r.push(...o), e.shouldPopulateBreak || hf(o, !0))
          break
        }
        if (n === t.length - 1) r.push(...o)
        else {
          i = []
          for (let u = 0; u < o.length; u++) {
            const c = o[u]
            c.type === Gs && r.push(c), c.type === ff && i.push(c)
          }
        }
      }
    } else if (t.length)
      for (let i = t.length - 1; i >= 0; i--) {
        const n = Kn(t[i], e)
        if (n.length > 1 || (n.length === 1 && !n[0].path.isVariableDeclaration())) {
          r.push(...n)
          break
        }
      }
    return r
  }
  function Kn(t, e) {
    let r = []
    if (t.isIfStatement()) (r = zn(t.get('consequent'), r, e)), (r = zn(t.get('alternate'), r, e))
    else {
      if (t.isDoExpression() || t.isFor() || t.isWhile() || t.isLabeledStatement()) return zn(t.get('body'), r, e)
      if (t.isProgram() || t.isBlockStatement()) return iT(t.get('body'), e)
      if (t.isFunction()) return Kn(t.get('body'), e)
      if (t.isTryStatement()) (r = zn(t.get('block'), r, e)), (r = zn(t.get('handler'), r, e))
      else {
        if (t.isCatchClause()) return zn(t.get('body'), r, e)
        if (t.isSwitchStatement()) return Kq(t.get('cases'), r, e)
        if (t.isSwitchCase())
          return iT(t.get('consequent'), { canHaveBreak: !0, shouldPopulateBreak: !1, inCaseClause: !0 })
        t.isBreakStatement() ? r.push(Uq(t)) : r.push(Vq(t))
      }
    }
    return r
  }
  function Yq() {
    return Kn(this, { canHaveBreak: !1, shouldPopulateBreak: !1, inCaseClause: !1 }).map((e) => e.path)
  }
  function Hq(t) {
    return pf.default
      .get({
        parentPath: this.parentPath,
        parent: this.parent,
        container: this.container,
        listKey: this.listKey,
        key: t,
      })
      .setContext(this.context)
  }
  function qq() {
    return this.getSibling(this.key - 1)
  }
  function Xq() {
    return this.getSibling(this.key + 1)
  }
  function Gq() {
    let t = this.key,
      e = this.getSibling(++t)
    const r = []
    for (; e.node; ) r.push(e), (e = this.getSibling(++t))
    return r
  }
  function Jq() {
    let t = this.key,
      e = this.getSibling(--t)
    const r = []
    for (; e.node; ) r.push(e), (e = this.getSibling(--t))
    return r
  }
  function Zq(t, e = !0) {
    e === !0 && (e = this.context)
    const r = t.split('.')
    return r.length === 1 ? this._getKey(t, e) : this._getPattern(r, e)
  }
  function Qq(t, e) {
    const r = this.node,
      i = r[t]
    return Array.isArray(i)
      ? i.map((n, s) => pf.default.get({ listKey: t, parentPath: this, parent: r, container: i, key: s }).setContext(e))
      : pf.default.get({ parentPath: this, parent: r, container: r, key: t }).setContext(e)
  }
  function eX(t, e) {
    let r = this
    for (const i of t) i === '.' ? (r = r.parentPath) : Array.isArray(r) ? (r = r[i]) : (r = r.get(i, e))
    return r
  }
  function tX(t) {
    return rT(this.node, t)
  }
  function rX(t) {
    return $q(this.node, t)
  }
  function iX(t = !1, e = !1) {
    const i = [this],
      n = Object.create(null)
    for (; i.length; ) {
      const s = i.shift()
      if (!s || !s.node) continue
      const a = rT.keys[s.node.type]
      if (s.isIdentifier()) {
        t ? (n[s.node.name] = n[s.node.name] || []).push(s) : (n[s.node.name] = s)
        continue
      }
      if (s.isExportDeclaration()) {
        const o = s.get('declaration')
        Rq(o) && i.push(o)
        continue
      }
      if (e) {
        if (s.isFunctionDeclaration()) {
          i.push(s.get('id'))
          continue
        }
        if (s.isFunctionExpression()) continue
      }
      if (a)
        for (let o = 0; o < a.length; o++) {
          const u = a[o],
            c = s.get(u)
          Array.isArray(c) ? i.push(...c) : c.node && i.push(c)
        }
    }
    return n
  }
  function nX(t) {
    return this.getBindingIdentifierPaths(t, !0)
  }
  var Js = {}
  Object.defineProperty(Js, '__esModule', { value: !0 }),
    (Js.addComment = uX),
    (Js.addComments = cX),
    (Js.shareCommentsWithSiblings = lX)
  var sX = st
  const { addComment: aX, addComments: oX } = sX
  function lX() {
    if (typeof this.key == 'string') return
    const t = this.node
    if (!t) return
    const e = t.trailingComments,
      r = t.leadingComments
    if (!e && !r) return
    const i = this.getSibling(this.key - 1),
      n = this.getSibling(this.key + 1),
      s = Boolean(i.node),
      a = Boolean(n.node)
    s && !a ? i.addComments('trailing', e) : a && !s && n.addComments('leading', r)
  }
  function uX(t, e, r) {
    aX(this.node, t, e, r)
  }
  function cX(t, e) {
    oX(this.node, t, e)
  }
  Object.defineProperty(Ut, '__esModule', { value: !0 }),
    (Ut.default = Ut.SHOULD_STOP = Ut.SHOULD_SKIP = Ut.REMOVED = void 0)
  var nT = rt,
    pX = Qu.exports,
    fX = ss,
    hX = gs,
    sT = st,
    pl = sT,
    aT = Vt,
    dX = Ts,
    mX = dr,
    yX = di,
    gX = mi,
    TX = Ro,
    bX = an,
    oT = Ot,
    SX = Nt,
    vX = Ci,
    EX = gr,
    PX = Ht,
    wX = Js
  const { validate: AX } = sT,
    lT = pX('babel'),
    fl = 1 << 0
  Ut.REMOVED = fl
  const hl = 1 << 1
  Ut.SHOULD_STOP = hl
  const dl = 1 << 2
  Ut.SHOULD_SKIP = dl
  class xi {
    constructor(e, r) {
      ;(this.contexts = []),
        (this.state = null),
        (this.opts = null),
        (this._traverseFlags = 0),
        (this.skipKeys = null),
        (this.parentPath = null),
        (this.container = null),
        (this.listKey = null),
        (this.key = null),
        (this.node = null),
        (this.type = null),
        (this.parent = r),
        (this.hub = e),
        (this.data = null),
        (this.context = null),
        (this.scope = null)
    }
    static get({ hub: e, parentPath: r, parent: i, container: n, listKey: s, key: a }) {
      if ((!e && r && (e = r.hub), !i)) throw new Error('To get a node path the parent needs to exist')
      const o = n[a]
      let u = aT.path.get(i)
      u || ((u = new Map()), aT.path.set(i, u))
      let c = u.get(o)
      return c || ((c = new xi(e, i)), o && u.set(o, c)), c.setup(r, n, s, a), c
    }
    getScope(e) {
      return this.isScope() ? new hX.default(this) : e
    }
    setData(e, r) {
      return this.data == null && (this.data = Object.create(null)), (this.data[e] = r)
    }
    getData(e, r) {
      this.data == null && (this.data = Object.create(null))
      let i = this.data[e]
      return i === void 0 && r !== void 0 && (i = this.data[e] = r), i
    }
    hasNode() {
      return this.node != null
    }
    buildCodeFrameError(e, r = SyntaxError) {
      return this.hub.buildError(this.node, e, r)
    }
    traverse(e, r) {
      ;(0, fX.default)(this.node, e, this.scope, r, this)
    }
    set(e, r) {
      AX(this.node, e, r), (this.node[e] = r)
    }
    getPathLocation() {
      const e = []
      let r = this
      do {
        let i = r.key
        r.inList && (i = `${r.listKey}[${i}]`), e.unshift(i)
      } while ((r = r.parentPath))
      return e.join('.')
    }
    debug(e) {
      !lT.enabled || lT(`${this.getPathLocation()} ${this.type}: ${e}`)
    }
    toString() {
      return (0, dX.default)(this.node).code
    }
    get inList() {
      return !!this.listKey
    }
    set inList(e) {
      e || (this.listKey = null)
    }
    get parentKey() {
      return this.listKey || this.key
    }
    get shouldSkip() {
      return !!(this._traverseFlags & dl)
    }
    set shouldSkip(e) {
      e ? (this._traverseFlags |= dl) : (this._traverseFlags &= ~dl)
    }
    get shouldStop() {
      return !!(this._traverseFlags & hl)
    }
    set shouldStop(e) {
      e ? (this._traverseFlags |= hl) : (this._traverseFlags &= ~hl)
    }
    get removed() {
      return !!(this._traverseFlags & fl)
    }
    set removed(e) {
      e ? (this._traverseFlags |= fl) : (this._traverseFlags &= ~fl)
    }
  }
  Object.assign(xi.prototype, mX, yX, gX, TX, bX, oT, SX, vX, EX, PX, wX),
    (xi.prototype._guessExecutionStatusRelativeToDifferentFunctions = oT._guessExecutionStatusRelativeTo)
  for (const t of pl.TYPES) {
    const e = `is${t}`,
      r = pl[e]
    ;(xi.prototype[e] = function (i) {
      return r(this.node, i)
    }),
      (xi.prototype[`assert${t}`] = function (i) {
        if (!r(this.node, i)) throw new TypeError(`Expected node path of type ${t}`)
      })
  }
  for (const t of Object.keys(nT)) {
    if (t[0] === '_') continue
    pl.TYPES.indexOf(t) < 0 && pl.TYPES.push(t)
    const e = nT[t]
    xi.prototype[`is${t}`] = function (r) {
      return e.checkPath(this, r)
    }
  }
  var CX = xi
  ;(Ut.default = CX), Object.defineProperty(Za, '__esModule', { value: !0 }), (Za.default = void 0)
  var xX = Ut,
    IX = st
  const { VISITOR_KEYS: kX } = IX
  class NX {
    constructor(e, r, i, n) {
      ;(this.queue = null),
        (this.priorityQueue = null),
        (this.parentPath = n),
        (this.scope = e),
        (this.state = i),
        (this.opts = r)
    }
    shouldVisit(e) {
      const r = this.opts
      if (r.enter || r.exit || r[e.type]) return !0
      const i = kX[e.type]
      if (!(i != null && i.length)) return !1
      for (const n of i) if (e[n]) return !0
      return !1
    }
    create(e, r, i, n) {
      return xX.default.get({ parentPath: this.parentPath, parent: e, container: r, key: i, listKey: n })
    }
    maybeQueue(e, r) {
      this.queue && (r ? this.queue.push(e) : this.priorityQueue.push(e))
    }
    visitMultiple(e, r, i) {
      if (e.length === 0) return !1
      const n = []
      for (let s = 0; s < e.length; s++) {
        const a = e[s]
        a && this.shouldVisit(a) && n.push(this.create(r, e, s, i))
      }
      return this.visitQueue(n)
    }
    visitSingle(e, r) {
      return this.shouldVisit(e[r]) ? this.visitQueue([this.create(e, e, r)]) : !1
    }
    visitQueue(e) {
      ;(this.queue = e), (this.priorityQueue = [])
      const r = new WeakSet()
      let i = !1
      for (const n of e) {
        if (
          (n.resync(),
          (n.contexts.length === 0 || n.contexts[n.contexts.length - 1] !== this) && n.pushContext(this),
          n.key === null)
        )
          continue
        const { node: s } = n
        if (!r.has(s)) {
          if ((s && r.add(s), n.visit())) {
            i = !0
            break
          }
          if (
            this.priorityQueue.length &&
            ((i = this.visitQueue(this.priorityQueue)), (this.priorityQueue = []), (this.queue = e), i)
          )
            break
        }
      }
      for (const n of e) n.popContext()
      return (this.queue = null), i
    }
    visit(e, r) {
      const i = e[r]
      return i ? (Array.isArray(i) ? this.visitMultiple(i, e, r) : this.visitSingle(e, r)) : !1
    }
  }
  ;(Za.default = NX), Object.defineProperty(Ja, '__esModule', { value: !0 }), (Ja.traverseNode = LX)
  var OX = Za,
    DX = st
  const { VISITOR_KEYS: BX } = DX
  function LX(t, e, r, i, n, s) {
    const a = BX[t.type]
    if (!a) return !1
    const o = new OX.default(r, e, i, n)
    for (const u of a) if (!(s && s[u]) && o.visit(t, u)) return !0
    return !1
  }
  var ml = {}
  Object.defineProperty(ml, '__esModule', { value: !0 }), (ml.default = void 0)
  class MX {
    getCode() {}
    getScope() {}
    addHelper() {
      throw new Error('Helpers are not supported by the default hub.')
    }
    buildError(e, r, i = TypeError) {
      return new i(r)
    }
  }
  ;(ml.default = MX),
    (function (t) {
      Object.defineProperty(t, '__esModule', { value: !0 }),
        Object.defineProperty(t, 'Hub', {
          enumerable: !0,
          get: function () {
            return o.default
          },
        }),
        Object.defineProperty(t, 'NodePath', {
          enumerable: !0,
          get: function () {
            return s.default
          },
        }),
        Object.defineProperty(t, 'Scope', {
          enumerable: !0,
          get: function () {
            return a.default
          },
        }),
        (t.visitors = t.default = void 0)
      var e = Tn
      t.visitors = e
      var r = st,
        i = Vt,
        n = Ja,
        s = Ut,
        a = gs,
        o = ml
      const { VISITOR_KEYS: u, removeProperties: c, traverseFast: p } = r
      function h(T, y = {}, b, m, S) {
        if (!!T) {
          if (!y.noScope && !b && T.type !== 'Program' && T.type !== 'File')
            throw new Error(
              `You must pass a scope and parentPath unless traversing a Program/File. Instead of that you tried to traverse a ${T.type} node without passing scope and parentPath.`
            )
          !u[T.type] || (e.explode(y), (0, n.traverseNode)(T, y, b, m, S))
        }
      }
      var f = h
      ;(t.default = f),
        (h.visitors = e),
        (h.verify = e.verify),
        (h.explode = e.explode),
        (h.cheap = function (T, y) {
          return p(T, y)
        }),
        (h.node = function (T, y, b, m, S, E) {
          ;(0, n.traverseNode)(T, y, b, m, S, E)
        }),
        (h.clearNode = function (T, y) {
          c(T, y), i.path.delete(T)
        }),
        (h.removeProperties = function (T, y) {
          return p(T, h.clearNode, y), T
        })
      function d(T, y) {
        T.node.type === y.type && ((y.has = !0), T.stop())
      }
      ;(h.hasType = function (T, y, b) {
        if (b != null && b.includes(T.type)) return !1
        if (T.type === y) return !0
        const m = { has: !1, type: y }
        return h(T, { noScope: !0, denylist: b, enter: d }, null, m), m.has
      }),
        (h.cache = i)
    })(ss)
  var FX = ES(ss),
    uT = { exports: {} }
  /*!

	JSZip v3.10.0 - A JavaScript class for generating and reading zip files
	<http://stuartk.com/jszip>

	(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
	Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.

	JSZip uses the library pako released under the MIT license :
	https://github.com/nodeca/pako/blob/main/LICENSE
	*/ ;(function (t, e) {
    ;(function (r) {
      t.exports = r()
    })(function () {
      return (function r(i, n, s) {
        function a(c, p) {
          if (!n[c]) {
            if (!i[c]) {
              var h = typeof da == 'function' && da
              if (!p && h) return h(c, !0)
              if (o) return o(c, !0)
              var f = new Error("Cannot find module '" + c + "'")
              throw ((f.code = 'MODULE_NOT_FOUND'), f)
            }
            var d = (n[c] = { exports: {} })
            i[c][0].call(
              d.exports,
              function (T) {
                var y = i[c][1][T]
                return a(y || T)
              },
              d,
              d.exports,
              r,
              i,
              n,
              s
            )
          }
          return n[c].exports
        }
        for (var o = typeof da == 'function' && da, u = 0; u < s.length; u++) a(s[u])
        return a
      })(
        {
          1: [
            function (r, i, n) {
              var s = r('./utils'),
                a = r('./support'),
                o = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='
              ;(n.encode = function (u) {
                for (
                  var c, p, h, f, d, T, y, b = [], m = 0, S = u.length, E = S, P = s.getTypeOf(u) !== 'string';
                  m < u.length;

                )
                  (E = S - m),
                    (h = P
                      ? ((c = u[m++]), (p = m < S ? u[m++] : 0), m < S ? u[m++] : 0)
                      : ((c = u.charCodeAt(m++)), (p = m < S ? u.charCodeAt(m++) : 0), m < S ? u.charCodeAt(m++) : 0)),
                    (f = c >> 2),
                    (d = ((3 & c) << 4) | (p >> 4)),
                    (T = 1 < E ? ((15 & p) << 2) | (h >> 6) : 64),
                    (y = 2 < E ? 63 & h : 64),
                    b.push(o.charAt(f) + o.charAt(d) + o.charAt(T) + o.charAt(y))
                return b.join('')
              }),
                (n.decode = function (u) {
                  var c,
                    p,
                    h,
                    f,
                    d,
                    T,
                    y = 0,
                    b = 0,
                    m = 'data:'
                  if (u.substr(0, m.length) === m) throw new Error('Invalid base64 input, it looks like a data url.')
                  var S,
                    E = (3 * (u = u.replace(/[^A-Za-z0-9\+\/\=]/g, '')).length) / 4
                  if (
                    (u.charAt(u.length - 1) === o.charAt(64) && E--,
                    u.charAt(u.length - 2) === o.charAt(64) && E--,
                    E % 1 != 0)
                  )
                    throw new Error('Invalid base64 input, bad content length.')
                  for (S = a.uint8array ? new Uint8Array(0 | E) : new Array(0 | E); y < u.length; )
                    (c = (o.indexOf(u.charAt(y++)) << 2) | ((f = o.indexOf(u.charAt(y++))) >> 4)),
                      (p = ((15 & f) << 4) | ((d = o.indexOf(u.charAt(y++))) >> 2)),
                      (h = ((3 & d) << 6) | (T = o.indexOf(u.charAt(y++)))),
                      (S[b++] = c),
                      d !== 64 && (S[b++] = p),
                      T !== 64 && (S[b++] = h)
                  return S
                })
            },
            { './support': 30, './utils': 32 },
          ],
          2: [
            function (r, i, n) {
              var s = r('./external'),
                a = r('./stream/DataWorker'),
                o = r('./stream/Crc32Probe'),
                u = r('./stream/DataLengthProbe')
              function c(p, h, f, d, T) {
                ;(this.compressedSize = p),
                  (this.uncompressedSize = h),
                  (this.crc32 = f),
                  (this.compression = d),
                  (this.compressedContent = T)
              }
              ;(c.prototype = {
                getContentWorker: function () {
                  var p = new a(s.Promise.resolve(this.compressedContent))
                      .pipe(this.compression.uncompressWorker())
                      .pipe(new u('data_length')),
                    h = this
                  return (
                    p.on('end', function () {
                      if (this.streamInfo.data_length !== h.uncompressedSize)
                        throw new Error('Bug : uncompressed data size mismatch')
                    }),
                    p
                  )
                },
                getCompressedWorker: function () {
                  return new a(s.Promise.resolve(this.compressedContent))
                    .withStreamInfo('compressedSize', this.compressedSize)
                    .withStreamInfo('uncompressedSize', this.uncompressedSize)
                    .withStreamInfo('crc32', this.crc32)
                    .withStreamInfo('compression', this.compression)
                },
              }),
                (c.createWorkerFrom = function (p, h, f) {
                  return p
                    .pipe(new o())
                    .pipe(new u('uncompressedSize'))
                    .pipe(h.compressWorker(f))
                    .pipe(new u('compressedSize'))
                    .withStreamInfo('compression', h)
                }),
                (i.exports = c)
            },
            { './external': 6, './stream/Crc32Probe': 25, './stream/DataLengthProbe': 26, './stream/DataWorker': 27 },
          ],
          3: [
            function (r, i, n) {
              var s = r('./stream/GenericWorker')
              ;(n.STORE = {
                magic: '\0\0',
                compressWorker: function (a) {
                  return new s('STORE compression')
                },
                uncompressWorker: function () {
                  return new s('STORE decompression')
                },
              }),
                (n.DEFLATE = r('./flate'))
            },
            { './flate': 7, './stream/GenericWorker': 28 },
          ],
          4: [
            function (r, i, n) {
              var s = r('./utils'),
                a = (function () {
                  for (var o, u = [], c = 0; c < 256; c++) {
                    o = c
                    for (var p = 0; p < 8; p++) o = 1 & o ? 3988292384 ^ (o >>> 1) : o >>> 1
                    u[c] = o
                  }
                  return u
                })()
              i.exports = function (o, u) {
                return o !== void 0 && o.length
                  ? s.getTypeOf(o) !== 'string'
                    ? (function (c, p, h, f) {
                        var d = a,
                          T = f + h
                        c ^= -1
                        for (var y = f; y < T; y++) c = (c >>> 8) ^ d[255 & (c ^ p[y])]
                        return -1 ^ c
                      })(0 | u, o, o.length, 0)
                    : (function (c, p, h, f) {
                        var d = a,
                          T = f + h
                        c ^= -1
                        for (var y = f; y < T; y++) c = (c >>> 8) ^ d[255 & (c ^ p.charCodeAt(y))]
                        return -1 ^ c
                      })(0 | u, o, o.length, 0)
                  : 0
              }
            },
            { './utils': 32 },
          ],
          5: [
            function (r, i, n) {
              ;(n.base64 = !1),
                (n.binary = !1),
                (n.dir = !1),
                (n.createFolders = !0),
                (n.date = null),
                (n.compression = null),
                (n.compressionOptions = null),
                (n.comment = null),
                (n.unixPermissions = null),
                (n.dosPermissions = null)
            },
            {},
          ],
          6: [
            function (r, i, n) {
              var s = null
              ;(s = typeof Promise != 'undefined' ? Promise : r('lie')), (i.exports = { Promise: s })
            },
            { lie: 37 },
          ],
          7: [
            function (r, i, n) {
              var s =
                  typeof Uint8Array != 'undefined' &&
                  typeof Uint16Array != 'undefined' &&
                  typeof Uint32Array != 'undefined',
                a = r('pako'),
                o = r('./utils'),
                u = r('./stream/GenericWorker'),
                c = s ? 'uint8array' : 'array'
              function p(h, f) {
                u.call(this, 'FlateWorker/' + h),
                  (this._pako = null),
                  (this._pakoAction = h),
                  (this._pakoOptions = f),
                  (this.meta = {})
              }
              ;(n.magic = '\b\0'),
                o.inherits(p, u),
                (p.prototype.processChunk = function (h) {
                  ;(this.meta = h.meta),
                    this._pako === null && this._createPako(),
                    this._pako.push(o.transformTo(c, h.data), !1)
                }),
                (p.prototype.flush = function () {
                  u.prototype.flush.call(this), this._pako === null && this._createPako(), this._pako.push([], !0)
                }),
                (p.prototype.cleanUp = function () {
                  u.prototype.cleanUp.call(this), (this._pako = null)
                }),
                (p.prototype._createPako = function () {
                  this._pako = new a[this._pakoAction]({ raw: !0, level: this._pakoOptions.level || -1 })
                  var h = this
                  this._pako.onData = function (f) {
                    h.push({ data: f, meta: h.meta })
                  }
                }),
                (n.compressWorker = function (h) {
                  return new p('Deflate', h)
                }),
                (n.uncompressWorker = function () {
                  return new p('Inflate', {})
                })
            },
            { './stream/GenericWorker': 28, './utils': 32, pako: 38 },
          ],
          8: [
            function (r, i, n) {
              function s(d, T) {
                var y,
                  b = ''
                for (y = 0; y < T; y++) (b += String.fromCharCode(255 & d)), (d >>>= 8)
                return b
              }
              function a(d, T, y, b, m, S) {
                var E,
                  P,
                  x = d.file,
                  D = d.compression,
                  N = S !== c.utf8encode,
                  I = o.transformTo('string', S(x.name)),
                  B = o.transformTo('string', c.utf8encode(x.name)),
                  K = x.comment,
                  Y = o.transformTo('string', S(K)),
                  C = o.transformTo('string', c.utf8encode(K)),
                  H = B.length !== x.name.length,
                  w = C.length !== K.length,
                  J = '',
                  X = '',
                  G = '',
                  Te = x.dir,
                  ce = x.date,
                  se = { crc32: 0, compressedSize: 0, uncompressedSize: 0 }
                ;(T && !y) ||
                  ((se.crc32 = d.crc32),
                  (se.compressedSize = d.compressedSize),
                  (se.uncompressedSize = d.uncompressedSize))
                var U = 0
                T && (U |= 8), N || (!H && !w) || (U |= 2048)
                var W = 0,
                  ge = 0
                Te && (W |= 16),
                  m === 'UNIX'
                    ? ((ge = 798),
                      (W |= (function (me, ke) {
                        var ae = me
                        return me || (ae = ke ? 16893 : 33204), (65535 & ae) << 16
                      })(x.unixPermissions, Te)))
                    : ((ge = 20),
                      (W |= (function (me) {
                        return 63 & (me || 0)
                      })(x.dosPermissions))),
                  (E = ce.getUTCHours()),
                  (E <<= 6),
                  (E |= ce.getUTCMinutes()),
                  (E <<= 5),
                  (E |= ce.getUTCSeconds() / 2),
                  (P = ce.getUTCFullYear() - 1980),
                  (P <<= 4),
                  (P |= ce.getUTCMonth() + 1),
                  (P <<= 5),
                  (P |= ce.getUTCDate()),
                  H && ((X = s(1, 1) + s(p(I), 4) + B), (J += 'up' + s(X.length, 2) + X)),
                  w && ((G = s(1, 1) + s(p(Y), 4) + C), (J += 'uc' + s(G.length, 2) + G))
                var ye = ''
                return (
                  (ye += `
\0`),
                  (ye += s(U, 2)),
                  (ye += D.magic),
                  (ye += s(E, 2)),
                  (ye += s(P, 2)),
                  (ye += s(se.crc32, 4)),
                  (ye += s(se.compressedSize, 4)),
                  (ye += s(se.uncompressedSize, 4)),
                  (ye += s(I.length, 2)),
                  (ye += s(J.length, 2)),
                  {
                    fileRecord: h.LOCAL_FILE_HEADER + ye + I + J,
                    dirRecord:
                      h.CENTRAL_FILE_HEADER +
                      s(ge, 2) +
                      ye +
                      s(Y.length, 2) +
                      '\0\0\0\0' +
                      s(W, 4) +
                      s(b, 4) +
                      I +
                      J +
                      Y,
                  }
                )
              }
              var o = r('../utils'),
                u = r('../stream/GenericWorker'),
                c = r('../utf8'),
                p = r('../crc32'),
                h = r('../signature')
              function f(d, T, y, b) {
                u.call(this, 'ZipFileWorker'),
                  (this.bytesWritten = 0),
                  (this.zipComment = T),
                  (this.zipPlatform = y),
                  (this.encodeFileName = b),
                  (this.streamFiles = d),
                  (this.accumulate = !1),
                  (this.contentBuffer = []),
                  (this.dirRecords = []),
                  (this.currentSourceOffset = 0),
                  (this.entriesCount = 0),
                  (this.currentFile = null),
                  (this._sources = [])
              }
              o.inherits(f, u),
                (f.prototype.push = function (d) {
                  var T = d.meta.percent || 0,
                    y = this.entriesCount,
                    b = this._sources.length
                  this.accumulate
                    ? this.contentBuffer.push(d)
                    : ((this.bytesWritten += d.data.length),
                      u.prototype.push.call(this, {
                        data: d.data,
                        meta: { currentFile: this.currentFile, percent: y ? (T + 100 * (y - b - 1)) / y : 100 },
                      }))
                }),
                (f.prototype.openedSource = function (d) {
                  ;(this.currentSourceOffset = this.bytesWritten), (this.currentFile = d.file.name)
                  var T = this.streamFiles && !d.file.dir
                  if (T) {
                    var y = a(d, T, !1, this.currentSourceOffset, this.zipPlatform, this.encodeFileName)
                    this.push({ data: y.fileRecord, meta: { percent: 0 } })
                  } else this.accumulate = !0
                }),
                (f.prototype.closedSource = function (d) {
                  this.accumulate = !1
                  var T = this.streamFiles && !d.file.dir,
                    y = a(d, T, !0, this.currentSourceOffset, this.zipPlatform, this.encodeFileName)
                  if ((this.dirRecords.push(y.dirRecord), T))
                    this.push({
                      data: (function (b) {
                        return h.DATA_DESCRIPTOR + s(b.crc32, 4) + s(b.compressedSize, 4) + s(b.uncompressedSize, 4)
                      })(d),
                      meta: { percent: 100 },
                    })
                  else
                    for (this.push({ data: y.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; )
                      this.push(this.contentBuffer.shift())
                  this.currentFile = null
                }),
                (f.prototype.flush = function () {
                  for (var d = this.bytesWritten, T = 0; T < this.dirRecords.length; T++)
                    this.push({ data: this.dirRecords[T], meta: { percent: 100 } })
                  var y = this.bytesWritten - d,
                    b = (function (m, S, E, P, x) {
                      var D = o.transformTo('string', x(P))
                      return (
                        h.CENTRAL_DIRECTORY_END +
                        '\0\0\0\0' +
                        s(m, 2) +
                        s(m, 2) +
                        s(S, 4) +
                        s(E, 4) +
                        s(D.length, 2) +
                        D
                      )
                    })(this.dirRecords.length, y, d, this.zipComment, this.encodeFileName)
                  this.push({ data: b, meta: { percent: 100 } })
                }),
                (f.prototype.prepareNextSource = function () {
                  ;(this.previous = this._sources.shift()),
                    this.openedSource(this.previous.streamInfo),
                    this.isPaused ? this.previous.pause() : this.previous.resume()
                }),
                (f.prototype.registerPrevious = function (d) {
                  this._sources.push(d)
                  var T = this
                  return (
                    d.on('data', function (y) {
                      T.processChunk(y)
                    }),
                    d.on('end', function () {
                      T.closedSource(T.previous.streamInfo), T._sources.length ? T.prepareNextSource() : T.end()
                    }),
                    d.on('error', function (y) {
                      T.error(y)
                    }),
                    this
                  )
                }),
                (f.prototype.resume = function () {
                  return (
                    !!u.prototype.resume.call(this) &&
                    (!this.previous && this._sources.length
                      ? (this.prepareNextSource(), !0)
                      : this.previous || this._sources.length || this.generatedError
                      ? void 0
                      : (this.end(), !0))
                  )
                }),
                (f.prototype.error = function (d) {
                  var T = this._sources
                  if (!u.prototype.error.call(this, d)) return !1
                  for (var y = 0; y < T.length; y++)
                    try {
                      T[y].error(d)
                    } catch {}
                  return !0
                }),
                (f.prototype.lock = function () {
                  u.prototype.lock.call(this)
                  for (var d = this._sources, T = 0; T < d.length; T++) d[T].lock()
                }),
                (i.exports = f)
            },
            { '../crc32': 4, '../signature': 23, '../stream/GenericWorker': 28, '../utf8': 31, '../utils': 32 },
          ],
          9: [
            function (r, i, n) {
              var s = r('../compressions'),
                a = r('./ZipFileWorker')
              n.generateWorker = function (o, u, c) {
                var p = new a(u.streamFiles, c, u.platform, u.encodeFileName),
                  h = 0
                try {
                  o.forEach(function (f, d) {
                    h++
                    var T = (function (S, E) {
                        var P = S || E,
                          x = s[P]
                        if (!x) throw new Error(P + ' is not a valid compression method !')
                        return x
                      })(d.options.compression, u.compression),
                      y = d.options.compressionOptions || u.compressionOptions || {},
                      b = d.dir,
                      m = d.date
                    d._compressWorker(T, y)
                      .withStreamInfo('file', {
                        name: f,
                        dir: b,
                        date: m,
                        comment: d.comment || '',
                        unixPermissions: d.unixPermissions,
                        dosPermissions: d.dosPermissions,
                      })
                      .pipe(p)
                  }),
                    (p.entriesCount = h)
                } catch (f) {
                  p.error(f)
                }
                return p
              }
            },
            { '../compressions': 3, './ZipFileWorker': 8 },
          ],
          10: [
            function (r, i, n) {
              function s() {
                if (!(this instanceof s)) return new s()
                if (arguments.length)
                  throw new Error(
                    'The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.'
                  )
                ;(this.files = Object.create(null)),
                  (this.comment = null),
                  (this.root = ''),
                  (this.clone = function () {
                    var a = new s()
                    for (var o in this) typeof this[o] != 'function' && (a[o] = this[o])
                    return a
                  })
              }
              ;((s.prototype = r('./object')).loadAsync = r('./load')),
                (s.support = r('./support')),
                (s.defaults = r('./defaults')),
                (s.version = '3.10.0'),
                (s.loadAsync = function (a, o) {
                  return new s().loadAsync(a, o)
                }),
                (s.external = r('./external')),
                (i.exports = s)
            },
            { './defaults': 5, './external': 6, './load': 11, './object': 15, './support': 30 },
          ],
          11: [
            function (r, i, n) {
              var s = r('./utils'),
                a = r('./external'),
                o = r('./utf8'),
                u = r('./zipEntries'),
                c = r('./stream/Crc32Probe'),
                p = r('./nodejsUtils')
              function h(f) {
                return new a.Promise(function (d, T) {
                  var y = f.decompressed.getContentWorker().pipe(new c())
                  y.on('error', function (b) {
                    T(b)
                  })
                    .on('end', function () {
                      y.streamInfo.crc32 !== f.decompressed.crc32 ? T(new Error('Corrupted zip : CRC32 mismatch')) : d()
                    })
                    .resume()
                })
              }
              i.exports = function (f, d) {
                var T = this
                return (
                  (d = s.extend(d || {}, {
                    base64: !1,
                    checkCRC32: !1,
                    optimizedBinaryString: !1,
                    createFolders: !1,
                    decodeFileName: o.utf8decode,
                  })),
                  p.isNode && p.isStream(f)
                    ? a.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file."))
                    : s
                        .prepareContent('the loaded zip file', f, !0, d.optimizedBinaryString, d.base64)
                        .then(function (y) {
                          var b = new u(d)
                          return b.load(y), b
                        })
                        .then(function (y) {
                          var b = [a.Promise.resolve(y)],
                            m = y.files
                          if (d.checkCRC32) for (var S = 0; S < m.length; S++) b.push(h(m[S]))
                          return a.Promise.all(b)
                        })
                        .then(function (y) {
                          for (var b = y.shift(), m = b.files, S = 0; S < m.length; S++) {
                            var E = m[S],
                              P = E.fileNameStr,
                              x = s.resolve(E.fileNameStr)
                            T.file(x, E.decompressed, {
                              binary: !0,
                              optimizedBinaryString: !0,
                              date: E.date,
                              dir: E.dir,
                              comment: E.fileCommentStr.length ? E.fileCommentStr : null,
                              unixPermissions: E.unixPermissions,
                              dosPermissions: E.dosPermissions,
                              createFolders: d.createFolders,
                            }),
                              E.dir || (T.file(x).unsafeOriginalName = P)
                          }
                          return b.zipComment.length && (T.comment = b.zipComment), T
                        })
                )
              }
            },
            {
              './external': 6,
              './nodejsUtils': 14,
              './stream/Crc32Probe': 25,
              './utf8': 31,
              './utils': 32,
              './zipEntries': 33,
            },
          ],
          12: [
            function (r, i, n) {
              var s = r('../utils'),
                a = r('../stream/GenericWorker')
              function o(u, c) {
                a.call(this, 'Nodejs stream input adapter for ' + u), (this._upstreamEnded = !1), this._bindStream(c)
              }
              s.inherits(o, a),
                (o.prototype._bindStream = function (u) {
                  var c = this
                  ;(this._stream = u).pause(),
                    u
                      .on('data', function (p) {
                        c.push({ data: p, meta: { percent: 0 } })
                      })
                      .on('error', function (p) {
                        c.isPaused ? (this.generatedError = p) : c.error(p)
                      })
                      .on('end', function () {
                        c.isPaused ? (c._upstreamEnded = !0) : c.end()
                      })
                }),
                (o.prototype.pause = function () {
                  return !!a.prototype.pause.call(this) && (this._stream.pause(), !0)
                }),
                (o.prototype.resume = function () {
                  return (
                    !!a.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), !0)
                  )
                }),
                (i.exports = o)
            },
            { '../stream/GenericWorker': 28, '../utils': 32 },
          ],
          13: [
            function (r, i, n) {
              var s = r('readable-stream').Readable
              function a(o, u, c) {
                s.call(this, u), (this._helper = o)
                var p = this
                o.on('data', function (h, f) {
                  p.push(h) || p._helper.pause(), c && c(f)
                })
                  .on('error', function (h) {
                    p.emit('error', h)
                  })
                  .on('end', function () {
                    p.push(null)
                  })
              }
              r('../utils').inherits(a, s),
                (a.prototype._read = function () {
                  this._helper.resume()
                }),
                (i.exports = a)
            },
            { '../utils': 32, 'readable-stream': 16 },
          ],
          14: [
            function (r, i, n) {
              i.exports = {
                isNode: typeof Buffer != 'undefined',
                newBufferFrom: function (s, a) {
                  if (Buffer.from && Buffer.from !== Uint8Array.from) return Buffer.from(s, a)
                  if (typeof s == 'number') throw new Error('The "data" argument must not be a number')
                  return new Buffer(s, a)
                },
                allocBuffer: function (s) {
                  if (Buffer.alloc) return Buffer.alloc(s)
                  var a = new Buffer(s)
                  return a.fill(0), a
                },
                isBuffer: function (s) {
                  return Buffer.isBuffer(s)
                },
                isStream: function (s) {
                  return s && typeof s.on == 'function' && typeof s.pause == 'function' && typeof s.resume == 'function'
                },
              }
            },
            {},
          ],
          15: [
            function (r, i, n) {
              function s(x, D, N) {
                var I,
                  B = o.getTypeOf(D),
                  K = o.extend(N || {}, p)
                ;(K.date = K.date || new Date()),
                  K.compression !== null && (K.compression = K.compression.toUpperCase()),
                  typeof K.unixPermissions == 'string' && (K.unixPermissions = parseInt(K.unixPermissions, 8)),
                  K.unixPermissions && 16384 & K.unixPermissions && (K.dir = !0),
                  K.dosPermissions && 16 & K.dosPermissions && (K.dir = !0),
                  K.dir && (x = m(x)),
                  K.createFolders && (I = b(x)) && S.call(this, I, !0)
                var Y = B === 'string' && K.binary === !1 && K.base64 === !1
                ;(N && N.binary !== void 0) || (K.binary = !Y),
                  ((D instanceof h && D.uncompressedSize === 0) || K.dir || !D || D.length === 0) &&
                    ((K.base64 = !1), (K.binary = !0), (D = ''), (K.compression = 'STORE'), (B = 'string'))
                var C = null
                C =
                  D instanceof h || D instanceof u
                    ? D
                    : T.isNode && T.isStream(D)
                    ? new y(x, D)
                    : o.prepareContent(x, D, K.binary, K.optimizedBinaryString, K.base64)
                var H = new f(x, C, K)
                this.files[x] = H
              }
              var a = r('./utf8'),
                o = r('./utils'),
                u = r('./stream/GenericWorker'),
                c = r('./stream/StreamHelper'),
                p = r('./defaults'),
                h = r('./compressedObject'),
                f = r('./zipObject'),
                d = r('./generate'),
                T = r('./nodejsUtils'),
                y = r('./nodejs/NodejsStreamInputAdapter'),
                b = function (x) {
                  x.slice(-1) === '/' && (x = x.substring(0, x.length - 1))
                  var D = x.lastIndexOf('/')
                  return 0 < D ? x.substring(0, D) : ''
                },
                m = function (x) {
                  return x.slice(-1) !== '/' && (x += '/'), x
                },
                S = function (x, D) {
                  return (
                    (D = D !== void 0 ? D : p.createFolders),
                    (x = m(x)),
                    this.files[x] || s.call(this, x, null, { dir: !0, createFolders: D }),
                    this.files[x]
                  )
                }
              function E(x) {
                return Object.prototype.toString.call(x) === '[object RegExp]'
              }
              var P = {
                load: function () {
                  throw new Error('This method has been removed in JSZip 3.0, please check the upgrade guide.')
                },
                forEach: function (x) {
                  var D, N, I
                  for (D in this.files)
                    (I = this.files[D]),
                      (N = D.slice(this.root.length, D.length)) && D.slice(0, this.root.length) === this.root && x(N, I)
                },
                filter: function (x) {
                  var D = []
                  return (
                    this.forEach(function (N, I) {
                      x(N, I) && D.push(I)
                    }),
                    D
                  )
                },
                file: function (x, D, N) {
                  if (arguments.length !== 1) return (x = this.root + x), s.call(this, x, D, N), this
                  if (E(x)) {
                    var I = x
                    return this.filter(function (K, Y) {
                      return !Y.dir && I.test(K)
                    })
                  }
                  var B = this.files[this.root + x]
                  return B && !B.dir ? B : null
                },
                folder: function (x) {
                  if (!x) return this
                  if (E(x))
                    return this.filter(function (B, K) {
                      return K.dir && x.test(B)
                    })
                  var D = this.root + x,
                    N = S.call(this, D),
                    I = this.clone()
                  return (I.root = N.name), I
                },
                remove: function (x) {
                  x = this.root + x
                  var D = this.files[x]
                  if ((D || (x.slice(-1) !== '/' && (x += '/'), (D = this.files[x])), D && !D.dir)) delete this.files[x]
                  else
                    for (
                      var N = this.filter(function (B, K) {
                          return K.name.slice(0, x.length) === x
                        }),
                        I = 0;
                      I < N.length;
                      I++
                    )
                      delete this.files[N[I].name]
                  return this
                },
                generate: function (x) {
                  throw new Error('This method has been removed in JSZip 3.0, please check the upgrade guide.')
                },
                generateInternalStream: function (x) {
                  var D,
                    N = {}
                  try {
                    if (
                      (((N = o.extend(x || {}, {
                        streamFiles: !1,
                        compression: 'STORE',
                        compressionOptions: null,
                        type: '',
                        platform: 'DOS',
                        comment: null,
                        mimeType: 'application/zip',
                        encodeFileName: a.utf8encode,
                      })).type = N.type.toLowerCase()),
                      (N.compression = N.compression.toUpperCase()),
                      N.type === 'binarystring' && (N.type = 'string'),
                      !N.type)
                    )
                      throw new Error('No output type specified.')
                    o.checkSupport(N.type),
                      (N.platform !== 'darwin' &&
                        N.platform !== 'freebsd' &&
                        N.platform !== 'linux' &&
                        N.platform !== 'sunos') ||
                        (N.platform = 'UNIX'),
                      N.platform === 'win32' && (N.platform = 'DOS')
                    var I = N.comment || this.comment || ''
                    D = d.generateWorker(this, N, I)
                  } catch (B) {
                    ;(D = new u('error')).error(B)
                  }
                  return new c(D, N.type || 'string', N.mimeType)
                },
                generateAsync: function (x, D) {
                  return this.generateInternalStream(x).accumulate(D)
                },
                generateNodeStream: function (x, D) {
                  return (x = x || {}).type || (x.type = 'nodebuffer'), this.generateInternalStream(x).toNodejsStream(D)
                },
              }
              i.exports = P
            },
            {
              './compressedObject': 2,
              './defaults': 5,
              './generate': 9,
              './nodejs/NodejsStreamInputAdapter': 12,
              './nodejsUtils': 14,
              './stream/GenericWorker': 28,
              './stream/StreamHelper': 29,
              './utf8': 31,
              './utils': 32,
              './zipObject': 35,
            },
          ],
          16: [
            function (r, i, n) {
              i.exports = r('stream')
            },
            { stream: void 0 },
          ],
          17: [
            function (r, i, n) {
              var s = r('./DataReader')
              function a(o) {
                s.call(this, o)
                for (var u = 0; u < this.data.length; u++) o[u] = 255 & o[u]
              }
              r('../utils').inherits(a, s),
                (a.prototype.byteAt = function (o) {
                  return this.data[this.zero + o]
                }),
                (a.prototype.lastIndexOfSignature = function (o) {
                  for (
                    var u = o.charCodeAt(0),
                      c = o.charCodeAt(1),
                      p = o.charCodeAt(2),
                      h = o.charCodeAt(3),
                      f = this.length - 4;
                    0 <= f;
                    --f
                  )
                    if (
                      this.data[f] === u &&
                      this.data[f + 1] === c &&
                      this.data[f + 2] === p &&
                      this.data[f + 3] === h
                    )
                      return f - this.zero
                  return -1
                }),
                (a.prototype.readAndCheckSignature = function (o) {
                  var u = o.charCodeAt(0),
                    c = o.charCodeAt(1),
                    p = o.charCodeAt(2),
                    h = o.charCodeAt(3),
                    f = this.readData(4)
                  return u === f[0] && c === f[1] && p === f[2] && h === f[3]
                }),
                (a.prototype.readData = function (o) {
                  if ((this.checkOffset(o), o === 0)) return []
                  var u = this.data.slice(this.zero + this.index, this.zero + this.index + o)
                  return (this.index += o), u
                }),
                (i.exports = a)
            },
            { '../utils': 32, './DataReader': 18 },
          ],
          18: [
            function (r, i, n) {
              var s = r('../utils')
              function a(o) {
                ;(this.data = o), (this.length = o.length), (this.index = 0), (this.zero = 0)
              }
              ;(a.prototype = {
                checkOffset: function (o) {
                  this.checkIndex(this.index + o)
                },
                checkIndex: function (o) {
                  if (this.length < this.zero + o || o < 0)
                    throw new Error(
                      'End of data reached (data length = ' +
                        this.length +
                        ', asked index = ' +
                        o +
                        '). Corrupted zip ?'
                    )
                },
                setIndex: function (o) {
                  this.checkIndex(o), (this.index = o)
                },
                skip: function (o) {
                  this.setIndex(this.index + o)
                },
                byteAt: function (o) {},
                readInt: function (o) {
                  var u,
                    c = 0
                  for (this.checkOffset(o), u = this.index + o - 1; u >= this.index; u--) c = (c << 8) + this.byteAt(u)
                  return (this.index += o), c
                },
                readString: function (o) {
                  return s.transformTo('string', this.readData(o))
                },
                readData: function (o) {},
                lastIndexOfSignature: function (o) {},
                readAndCheckSignature: function (o) {},
                readDate: function () {
                  var o = this.readInt(4)
                  return new Date(
                    Date.UTC(
                      1980 + ((o >> 25) & 127),
                      ((o >> 21) & 15) - 1,
                      (o >> 16) & 31,
                      (o >> 11) & 31,
                      (o >> 5) & 63,
                      (31 & o) << 1
                    )
                  )
                },
              }),
                (i.exports = a)
            },
            { '../utils': 32 },
          ],
          19: [
            function (r, i, n) {
              var s = r('./Uint8ArrayReader')
              function a(o) {
                s.call(this, o)
              }
              r('../utils').inherits(a, s),
                (a.prototype.readData = function (o) {
                  this.checkOffset(o)
                  var u = this.data.slice(this.zero + this.index, this.zero + this.index + o)
                  return (this.index += o), u
                }),
                (i.exports = a)
            },
            { '../utils': 32, './Uint8ArrayReader': 21 },
          ],
          20: [
            function (r, i, n) {
              var s = r('./DataReader')
              function a(o) {
                s.call(this, o)
              }
              r('../utils').inherits(a, s),
                (a.prototype.byteAt = function (o) {
                  return this.data.charCodeAt(this.zero + o)
                }),
                (a.prototype.lastIndexOfSignature = function (o) {
                  return this.data.lastIndexOf(o) - this.zero
                }),
                (a.prototype.readAndCheckSignature = function (o) {
                  return o === this.readData(4)
                }),
                (a.prototype.readData = function (o) {
                  this.checkOffset(o)
                  var u = this.data.slice(this.zero + this.index, this.zero + this.index + o)
                  return (this.index += o), u
                }),
                (i.exports = a)
            },
            { '../utils': 32, './DataReader': 18 },
          ],
          21: [
            function (r, i, n) {
              var s = r('./ArrayReader')
              function a(o) {
                s.call(this, o)
              }
              r('../utils').inherits(a, s),
                (a.prototype.readData = function (o) {
                  if ((this.checkOffset(o), o === 0)) return new Uint8Array(0)
                  var u = this.data.subarray(this.zero + this.index, this.zero + this.index + o)
                  return (this.index += o), u
                }),
                (i.exports = a)
            },
            { '../utils': 32, './ArrayReader': 17 },
          ],
          22: [
            function (r, i, n) {
              var s = r('../utils'),
                a = r('../support'),
                o = r('./ArrayReader'),
                u = r('./StringReader'),
                c = r('./NodeBufferReader'),
                p = r('./Uint8ArrayReader')
              i.exports = function (h) {
                var f = s.getTypeOf(h)
                return (
                  s.checkSupport(f),
                  f !== 'string' || a.uint8array
                    ? f === 'nodebuffer'
                      ? new c(h)
                      : a.uint8array
                      ? new p(s.transformTo('uint8array', h))
                      : new o(s.transformTo('array', h))
                    : new u(h)
                )
              }
            },
            {
              '../support': 30,
              '../utils': 32,
              './ArrayReader': 17,
              './NodeBufferReader': 19,
              './StringReader': 20,
              './Uint8ArrayReader': 21,
            },
          ],
          23: [
            function (r, i, n) {
              ;(n.LOCAL_FILE_HEADER = 'PK'),
                (n.CENTRAL_FILE_HEADER = 'PK'),
                (n.CENTRAL_DIRECTORY_END = 'PK'),
                (n.ZIP64_CENTRAL_DIRECTORY_LOCATOR = 'PK\x07'),
                (n.ZIP64_CENTRAL_DIRECTORY_END = 'PK'),
                (n.DATA_DESCRIPTOR = 'PK\x07\b')
            },
            {},
          ],
          24: [
            function (r, i, n) {
              var s = r('./GenericWorker'),
                a = r('../utils')
              function o(u) {
                s.call(this, 'ConvertWorker to ' + u), (this.destType = u)
              }
              a.inherits(o, s),
                (o.prototype.processChunk = function (u) {
                  this.push({ data: a.transformTo(this.destType, u.data), meta: u.meta })
                }),
                (i.exports = o)
            },
            { '../utils': 32, './GenericWorker': 28 },
          ],
          25: [
            function (r, i, n) {
              var s = r('./GenericWorker'),
                a = r('../crc32')
              function o() {
                s.call(this, 'Crc32Probe'), this.withStreamInfo('crc32', 0)
              }
              r('../utils').inherits(o, s),
                (o.prototype.processChunk = function (u) {
                  ;(this.streamInfo.crc32 = a(u.data, this.streamInfo.crc32 || 0)), this.push(u)
                }),
                (i.exports = o)
            },
            { '../crc32': 4, '../utils': 32, './GenericWorker': 28 },
          ],
          26: [
            function (r, i, n) {
              var s = r('../utils'),
                a = r('./GenericWorker')
              function o(u) {
                a.call(this, 'DataLengthProbe for ' + u), (this.propName = u), this.withStreamInfo(u, 0)
              }
              s.inherits(o, a),
                (o.prototype.processChunk = function (u) {
                  if (u) {
                    var c = this.streamInfo[this.propName] || 0
                    this.streamInfo[this.propName] = c + u.data.length
                  }
                  a.prototype.processChunk.call(this, u)
                }),
                (i.exports = o)
            },
            { '../utils': 32, './GenericWorker': 28 },
          ],
          27: [
            function (r, i, n) {
              var s = r('../utils'),
                a = r('./GenericWorker')
              function o(u) {
                a.call(this, 'DataWorker')
                var c = this
                ;(this.dataIsReady = !1),
                  (this.index = 0),
                  (this.max = 0),
                  (this.data = null),
                  (this.type = ''),
                  (this._tickScheduled = !1),
                  u.then(
                    function (p) {
                      ;(c.dataIsReady = !0),
                        (c.data = p),
                        (c.max = (p && p.length) || 0),
                        (c.type = s.getTypeOf(p)),
                        c.isPaused || c._tickAndRepeat()
                    },
                    function (p) {
                      c.error(p)
                    }
                  )
              }
              s.inherits(o, a),
                (o.prototype.cleanUp = function () {
                  a.prototype.cleanUp.call(this), (this.data = null)
                }),
                (o.prototype.resume = function () {
                  return (
                    !!a.prototype.resume.call(this) &&
                    (!this._tickScheduled &&
                      this.dataIsReady &&
                      ((this._tickScheduled = !0), s.delay(this._tickAndRepeat, [], this)),
                    !0)
                  )
                }),
                (o.prototype._tickAndRepeat = function () {
                  ;(this._tickScheduled = !1),
                    this.isPaused ||
                      this.isFinished ||
                      (this._tick(),
                      this.isFinished || (s.delay(this._tickAndRepeat, [], this), (this._tickScheduled = !0)))
                }),
                (o.prototype._tick = function () {
                  if (this.isPaused || this.isFinished) return !1
                  var u = null,
                    c = Math.min(this.max, this.index + 16384)
                  if (this.index >= this.max) return this.end()
                  switch (this.type) {
                    case 'string':
                      u = this.data.substring(this.index, c)
                      break
                    case 'uint8array':
                      u = this.data.subarray(this.index, c)
                      break
                    case 'array':
                    case 'nodebuffer':
                      u = this.data.slice(this.index, c)
                  }
                  return (
                    (this.index = c),
                    this.push({ data: u, meta: { percent: this.max ? (this.index / this.max) * 100 : 0 } })
                  )
                }),
                (i.exports = o)
            },
            { '../utils': 32, './GenericWorker': 28 },
          ],
          28: [
            function (r, i, n) {
              function s(a) {
                ;(this.name = a || 'default'),
                  (this.streamInfo = {}),
                  (this.generatedError = null),
                  (this.extraStreamInfo = {}),
                  (this.isPaused = !0),
                  (this.isFinished = !1),
                  (this.isLocked = !1),
                  (this._listeners = { data: [], end: [], error: [] }),
                  (this.previous = null)
              }
              ;(s.prototype = {
                push: function (a) {
                  this.emit('data', a)
                },
                end: function () {
                  if (this.isFinished) return !1
                  this.flush()
                  try {
                    this.emit('end'), this.cleanUp(), (this.isFinished = !0)
                  } catch (a) {
                    this.emit('error', a)
                  }
                  return !0
                },
                error: function (a) {
                  return (
                    !this.isFinished &&
                    (this.isPaused
                      ? (this.generatedError = a)
                      : ((this.isFinished = !0),
                        this.emit('error', a),
                        this.previous && this.previous.error(a),
                        this.cleanUp()),
                    !0)
                  )
                },
                on: function (a, o) {
                  return this._listeners[a].push(o), this
                },
                cleanUp: function () {
                  ;(this.streamInfo = this.generatedError = this.extraStreamInfo = null), (this._listeners = [])
                },
                emit: function (a, o) {
                  if (this._listeners[a])
                    for (var u = 0; u < this._listeners[a].length; u++) this._listeners[a][u].call(this, o)
                },
                pipe: function (a) {
                  return a.registerPrevious(this)
                },
                registerPrevious: function (a) {
                  if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.")
                  ;(this.streamInfo = a.streamInfo), this.mergeStreamInfo(), (this.previous = a)
                  var o = this
                  return (
                    a.on('data', function (u) {
                      o.processChunk(u)
                    }),
                    a.on('end', function () {
                      o.end()
                    }),
                    a.on('error', function (u) {
                      o.error(u)
                    }),
                    this
                  )
                },
                pause: function () {
                  return (
                    !this.isPaused &&
                    !this.isFinished &&
                    ((this.isPaused = !0), this.previous && this.previous.pause(), !0)
                  )
                },
                resume: function () {
                  if (!this.isPaused || this.isFinished) return !1
                  var a = (this.isPaused = !1)
                  return (
                    this.generatedError && (this.error(this.generatedError), (a = !0)),
                    this.previous && this.previous.resume(),
                    !a
                  )
                },
                flush: function () {},
                processChunk: function (a) {
                  this.push(a)
                },
                withStreamInfo: function (a, o) {
                  return (this.extraStreamInfo[a] = o), this.mergeStreamInfo(), this
                },
                mergeStreamInfo: function () {
                  for (var a in this.extraStreamInfo)
                    this.extraStreamInfo.hasOwnProperty(a) && (this.streamInfo[a] = this.extraStreamInfo[a])
                },
                lock: function () {
                  if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.")
                  ;(this.isLocked = !0), this.previous && this.previous.lock()
                },
                toString: function () {
                  var a = 'Worker ' + this.name
                  return this.previous ? this.previous + ' -> ' + a : a
                },
              }),
                (i.exports = s)
            },
            {},
          ],
          29: [
            function (r, i, n) {
              var s = r('../utils'),
                a = r('./ConvertWorker'),
                o = r('./GenericWorker'),
                u = r('../base64'),
                c = r('../support'),
                p = r('../external'),
                h = null
              if (c.nodestream)
                try {
                  h = r('../nodejs/NodejsStreamOutputAdapter')
                } catch {}
              function f(T, y) {
                return new p.Promise(function (b, m) {
                  var S = [],
                    E = T._internalType,
                    P = T._outputType,
                    x = T._mimeType
                  T.on('data', function (D, N) {
                    S.push(D), y && y(N)
                  })
                    .on('error', function (D) {
                      ;(S = []), m(D)
                    })
                    .on('end', function () {
                      try {
                        var D = (function (N, I, B) {
                          switch (N) {
                            case 'blob':
                              return s.newBlob(s.transformTo('arraybuffer', I), B)
                            case 'base64':
                              return u.encode(I)
                            default:
                              return s.transformTo(N, I)
                          }
                        })(
                          P,
                          (function (N, I) {
                            var B,
                              K = 0,
                              Y = null,
                              C = 0
                            for (B = 0; B < I.length; B++) C += I[B].length
                            switch (N) {
                              case 'string':
                                return I.join('')
                              case 'array':
                                return Array.prototype.concat.apply([], I)
                              case 'uint8array':
                                for (Y = new Uint8Array(C), B = 0; B < I.length; B++) Y.set(I[B], K), (K += I[B].length)
                                return Y
                              case 'nodebuffer':
                                return Buffer.concat(I)
                              default:
                                throw new Error("concat : unsupported type '" + N + "'")
                            }
                          })(E, S),
                          x
                        )
                        b(D)
                      } catch (N) {
                        m(N)
                      }
                      S = []
                    })
                    .resume()
                })
              }
              function d(T, y, b) {
                var m = y
                switch (y) {
                  case 'blob':
                  case 'arraybuffer':
                    m = 'uint8array'
                    break
                  case 'base64':
                    m = 'string'
                }
                try {
                  ;(this._internalType = m),
                    (this._outputType = y),
                    (this._mimeType = b),
                    s.checkSupport(m),
                    (this._worker = T.pipe(new a(m))),
                    T.lock()
                } catch (S) {
                  ;(this._worker = new o('error')), this._worker.error(S)
                }
              }
              ;(d.prototype = {
                accumulate: function (T) {
                  return f(this, T)
                },
                on: function (T, y) {
                  var b = this
                  return (
                    T === 'data'
                      ? this._worker.on(T, function (m) {
                          y.call(b, m.data, m.meta)
                        })
                      : this._worker.on(T, function () {
                          s.delay(y, arguments, b)
                        }),
                    this
                  )
                },
                resume: function () {
                  return s.delay(this._worker.resume, [], this._worker), this
                },
                pause: function () {
                  return this._worker.pause(), this
                },
                toNodejsStream: function (T) {
                  if ((s.checkSupport('nodestream'), this._outputType !== 'nodebuffer'))
                    throw new Error(this._outputType + ' is not supported by this method')
                  return new h(this, { objectMode: this._outputType !== 'nodebuffer' }, T)
                },
              }),
                (i.exports = d)
            },
            {
              '../base64': 1,
              '../external': 6,
              '../nodejs/NodejsStreamOutputAdapter': 13,
              '../support': 30,
              '../utils': 32,
              './ConvertWorker': 24,
              './GenericWorker': 28,
            },
          ],
          30: [
            function (r, i, n) {
              if (
                ((n.base64 = !0),
                (n.array = !0),
                (n.string = !0),
                (n.arraybuffer = typeof ArrayBuffer != 'undefined' && typeof Uint8Array != 'undefined'),
                (n.nodebuffer = typeof Buffer != 'undefined'),
                (n.uint8array = typeof Uint8Array != 'undefined'),
                typeof ArrayBuffer == 'undefined')
              )
                n.blob = !1
              else {
                var s = new ArrayBuffer(0)
                try {
                  n.blob = new Blob([s], { type: 'application/zip' }).size === 0
                } catch {
                  try {
                    var a = new (self.BlobBuilder ||
                      self.WebKitBlobBuilder ||
                      self.MozBlobBuilder ||
                      self.MSBlobBuilder)()
                    a.append(s), (n.blob = a.getBlob('application/zip').size === 0)
                  } catch {
                    n.blob = !1
                  }
                }
              }
              try {
                n.nodestream = !!r('readable-stream').Readable
              } catch {
                n.nodestream = !1
              }
            },
            { 'readable-stream': 16 },
          ],
          31: [
            function (r, i, n) {
              for (
                var s = r('./utils'),
                  a = r('./support'),
                  o = r('./nodejsUtils'),
                  u = r('./stream/GenericWorker'),
                  c = new Array(256),
                  p = 0;
                p < 256;
                p++
              )
                c[p] = 252 <= p ? 6 : 248 <= p ? 5 : 240 <= p ? 4 : 224 <= p ? 3 : 192 <= p ? 2 : 1
              c[254] = c[254] = 1
              function h() {
                u.call(this, 'utf-8 decode'), (this.leftOver = null)
              }
              function f() {
                u.call(this, 'utf-8 encode')
              }
              ;(n.utf8encode = function (d) {
                return a.nodebuffer
                  ? o.newBufferFrom(d, 'utf-8')
                  : (function (T) {
                      var y,
                        b,
                        m,
                        S,
                        E,
                        P = T.length,
                        x = 0
                      for (S = 0; S < P; S++)
                        (64512 & (b = T.charCodeAt(S))) == 55296 &&
                          S + 1 < P &&
                          (64512 & (m = T.charCodeAt(S + 1))) == 56320 &&
                          ((b = 65536 + ((b - 55296) << 10) + (m - 56320)), S++),
                          (x += b < 128 ? 1 : b < 2048 ? 2 : b < 65536 ? 3 : 4)
                      for (y = a.uint8array ? new Uint8Array(x) : new Array(x), S = E = 0; E < x; S++)
                        (64512 & (b = T.charCodeAt(S))) == 55296 &&
                          S + 1 < P &&
                          (64512 & (m = T.charCodeAt(S + 1))) == 56320 &&
                          ((b = 65536 + ((b - 55296) << 10) + (m - 56320)), S++),
                          b < 128
                            ? (y[E++] = b)
                            : (b < 2048
                                ? (y[E++] = 192 | (b >>> 6))
                                : (b < 65536
                                    ? (y[E++] = 224 | (b >>> 12))
                                    : ((y[E++] = 240 | (b >>> 18)), (y[E++] = 128 | ((b >>> 12) & 63))),
                                  (y[E++] = 128 | ((b >>> 6) & 63))),
                              (y[E++] = 128 | (63 & b)))
                      return y
                    })(d)
              }),
                (n.utf8decode = function (d) {
                  return a.nodebuffer
                    ? s.transformTo('nodebuffer', d).toString('utf-8')
                    : (function (T) {
                        var y,
                          b,
                          m,
                          S,
                          E = T.length,
                          P = new Array(2 * E)
                        for (y = b = 0; y < E; )
                          if ((m = T[y++]) < 128) P[b++] = m
                          else if (4 < (S = c[m])) (P[b++] = 65533), (y += S - 1)
                          else {
                            for (m &= S === 2 ? 31 : S === 3 ? 15 : 7; 1 < S && y < E; )
                              (m = (m << 6) | (63 & T[y++])), S--
                            1 < S
                              ? (P[b++] = 65533)
                              : m < 65536
                              ? (P[b++] = m)
                              : ((m -= 65536), (P[b++] = 55296 | ((m >> 10) & 1023)), (P[b++] = 56320 | (1023 & m)))
                          }
                        return (
                          P.length !== b && (P.subarray ? (P = P.subarray(0, b)) : (P.length = b)),
                          s.applyFromCharCode(P)
                        )
                      })((d = s.transformTo(a.uint8array ? 'uint8array' : 'array', d)))
                }),
                s.inherits(h, u),
                (h.prototype.processChunk = function (d) {
                  var T = s.transformTo(a.uint8array ? 'uint8array' : 'array', d.data)
                  if (this.leftOver && this.leftOver.length) {
                    if (a.uint8array) {
                      var y = T
                      ;(T = new Uint8Array(y.length + this.leftOver.length)).set(this.leftOver, 0),
                        T.set(y, this.leftOver.length)
                    } else T = this.leftOver.concat(T)
                    this.leftOver = null
                  }
                  var b = (function (S, E) {
                      var P
                      for ((E = E || S.length) > S.length && (E = S.length), P = E - 1; 0 <= P && (192 & S[P]) == 128; )
                        P--
                      return P < 0 || P === 0 ? E : P + c[S[P]] > E ? P : E
                    })(T),
                    m = T
                  b !== T.length &&
                    (a.uint8array
                      ? ((m = T.subarray(0, b)), (this.leftOver = T.subarray(b, T.length)))
                      : ((m = T.slice(0, b)), (this.leftOver = T.slice(b, T.length)))),
                    this.push({ data: n.utf8decode(m), meta: d.meta })
                }),
                (h.prototype.flush = function () {
                  this.leftOver &&
                    this.leftOver.length &&
                    (this.push({ data: n.utf8decode(this.leftOver), meta: {} }), (this.leftOver = null))
                }),
                (n.Utf8DecodeWorker = h),
                s.inherits(f, u),
                (f.prototype.processChunk = function (d) {
                  this.push({ data: n.utf8encode(d.data), meta: d.meta })
                }),
                (n.Utf8EncodeWorker = f)
            },
            { './nodejsUtils': 14, './stream/GenericWorker': 28, './support': 30, './utils': 32 },
          ],
          32: [
            function (r, i, n) {
              var s = r('./support'),
                a = r('./base64'),
                o = r('./nodejsUtils'),
                u = r('./external')
              function c(y) {
                return y
              }
              function p(y, b) {
                for (var m = 0; m < y.length; ++m) b[m] = 255 & y.charCodeAt(m)
                return b
              }
              r('setimmediate'),
                (n.newBlob = function (y, b) {
                  n.checkSupport('blob')
                  try {
                    return new Blob([y], { type: b })
                  } catch {
                    try {
                      var m = new (self.BlobBuilder ||
                        self.WebKitBlobBuilder ||
                        self.MozBlobBuilder ||
                        self.MSBlobBuilder)()
                      return m.append(y), m.getBlob(b)
                    } catch {
                      throw new Error("Bug : can't construct the Blob.")
                    }
                  }
                })
              var h = {
                stringifyByChunk: function (y, b, m) {
                  var S = [],
                    E = 0,
                    P = y.length
                  if (P <= m) return String.fromCharCode.apply(null, y)
                  for (; E < P; )
                    b === 'array' || b === 'nodebuffer'
                      ? S.push(String.fromCharCode.apply(null, y.slice(E, Math.min(E + m, P))))
                      : S.push(String.fromCharCode.apply(null, y.subarray(E, Math.min(E + m, P)))),
                      (E += m)
                  return S.join('')
                },
                stringifyByChar: function (y) {
                  for (var b = '', m = 0; m < y.length; m++) b += String.fromCharCode(y[m])
                  return b
                },
                applyCanBeUsed: {
                  uint8array: (function () {
                    try {
                      return s.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1
                    } catch {
                      return !1
                    }
                  })(),
                  nodebuffer: (function () {
                    try {
                      return s.nodebuffer && String.fromCharCode.apply(null, o.allocBuffer(1)).length === 1
                    } catch {
                      return !1
                    }
                  })(),
                },
              }
              function f(y) {
                var b = 65536,
                  m = n.getTypeOf(y),
                  S = !0
                if (
                  (m === 'uint8array'
                    ? (S = h.applyCanBeUsed.uint8array)
                    : m === 'nodebuffer' && (S = h.applyCanBeUsed.nodebuffer),
                  S)
                )
                  for (; 1 < b; )
                    try {
                      return h.stringifyByChunk(y, m, b)
                    } catch {
                      b = Math.floor(b / 2)
                    }
                return h.stringifyByChar(y)
              }
              function d(y, b) {
                for (var m = 0; m < y.length; m++) b[m] = y[m]
                return b
              }
              n.applyFromCharCode = f
              var T = {}
              ;(T.string = {
                string: c,
                array: function (y) {
                  return p(y, new Array(y.length))
                },
                arraybuffer: function (y) {
                  return T.string.uint8array(y).buffer
                },
                uint8array: function (y) {
                  return p(y, new Uint8Array(y.length))
                },
                nodebuffer: function (y) {
                  return p(y, o.allocBuffer(y.length))
                },
              }),
                (T.array = {
                  string: f,
                  array: c,
                  arraybuffer: function (y) {
                    return new Uint8Array(y).buffer
                  },
                  uint8array: function (y) {
                    return new Uint8Array(y)
                  },
                  nodebuffer: function (y) {
                    return o.newBufferFrom(y)
                  },
                }),
                (T.arraybuffer = {
                  string: function (y) {
                    return f(new Uint8Array(y))
                  },
                  array: function (y) {
                    return d(new Uint8Array(y), new Array(y.byteLength))
                  },
                  arraybuffer: c,
                  uint8array: function (y) {
                    return new Uint8Array(y)
                  },
                  nodebuffer: function (y) {
                    return o.newBufferFrom(new Uint8Array(y))
                  },
                }),
                (T.uint8array = {
                  string: f,
                  array: function (y) {
                    return d(y, new Array(y.length))
                  },
                  arraybuffer: function (y) {
                    return y.buffer
                  },
                  uint8array: c,
                  nodebuffer: function (y) {
                    return o.newBufferFrom(y)
                  },
                }),
                (T.nodebuffer = {
                  string: f,
                  array: function (y) {
                    return d(y, new Array(y.length))
                  },
                  arraybuffer: function (y) {
                    return T.nodebuffer.uint8array(y).buffer
                  },
                  uint8array: function (y) {
                    return d(y, new Uint8Array(y.length))
                  },
                  nodebuffer: c,
                }),
                (n.transformTo = function (y, b) {
                  if (((b = b || ''), !y)) return b
                  n.checkSupport(y)
                  var m = n.getTypeOf(b)
                  return T[m][y](b)
                }),
                (n.resolve = function (y) {
                  for (var b = y.split('/'), m = [], S = 0; S < b.length; S++) {
                    var E = b[S]
                    E === '.' || (E === '' && S !== 0 && S !== b.length - 1) || (E === '..' ? m.pop() : m.push(E))
                  }
                  return m.join('/')
                }),
                (n.getTypeOf = function (y) {
                  return typeof y == 'string'
                    ? 'string'
                    : Object.prototype.toString.call(y) === '[object Array]'
                    ? 'array'
                    : s.nodebuffer && o.isBuffer(y)
                    ? 'nodebuffer'
                    : s.uint8array && y instanceof Uint8Array
                    ? 'uint8array'
                    : s.arraybuffer && y instanceof ArrayBuffer
                    ? 'arraybuffer'
                    : void 0
                }),
                (n.checkSupport = function (y) {
                  if (!s[y.toLowerCase()]) throw new Error(y + ' is not supported by this platform')
                }),
                (n.MAX_VALUE_16BITS = 65535),
                (n.MAX_VALUE_32BITS = -1),
                (n.pretty = function (y) {
                  var b,
                    m,
                    S = ''
                  for (m = 0; m < (y || '').length; m++)
                    S += '\\x' + ((b = y.charCodeAt(m)) < 16 ? '0' : '') + b.toString(16).toUpperCase()
                  return S
                }),
                (n.delay = function (y, b, m) {
                  setImmediate(function () {
                    y.apply(m || null, b || [])
                  })
                }),
                (n.inherits = function (y, b) {
                  function m() {}
                  ;(m.prototype = b.prototype), (y.prototype = new m())
                }),
                (n.extend = function () {
                  var y,
                    b,
                    m = {}
                  for (y = 0; y < arguments.length; y++)
                    for (b in arguments[y])
                      arguments[y].hasOwnProperty(b) && m[b] === void 0 && (m[b] = arguments[y][b])
                  return m
                }),
                (n.prepareContent = function (y, b, m, S, E) {
                  return u.Promise.resolve(b)
                    .then(function (P) {
                      return s.blob &&
                        (P instanceof Blob ||
                          ['[object File]', '[object Blob]'].indexOf(Object.prototype.toString.call(P)) !== -1) &&
                        typeof FileReader != 'undefined'
                        ? new u.Promise(function (x, D) {
                            var N = new FileReader()
                            ;(N.onload = function (I) {
                              x(I.target.result)
                            }),
                              (N.onerror = function (I) {
                                D(I.target.error)
                              }),
                              N.readAsArrayBuffer(P)
                          })
                        : P
                    })
                    .then(function (P) {
                      var x = n.getTypeOf(P)
                      return x
                        ? (x === 'arraybuffer'
                            ? (P = n.transformTo('uint8array', P))
                            : x === 'string' &&
                              (E
                                ? (P = a.decode(P))
                                : m &&
                                  S !== !0 &&
                                  (P = (function (D) {
                                    return p(D, s.uint8array ? new Uint8Array(D.length) : new Array(D.length))
                                  })(P))),
                          P)
                        : u.Promise.reject(
                            new Error(
                              "Can't read the data of '" +
                                y +
                                "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"
                            )
                          )
                    })
                })
            },
            { './base64': 1, './external': 6, './nodejsUtils': 14, './support': 30, setimmediate: 54 },
          ],
          33: [
            function (r, i, n) {
              var s = r('./reader/readerFor'),
                a = r('./utils'),
                o = r('./signature'),
                u = r('./zipEntry'),
                c = (r('./utf8'), r('./support'))
              function p(h) {
                ;(this.files = []), (this.loadOptions = h)
              }
              ;(p.prototype = {
                checkSignature: function (h) {
                  if (!this.reader.readAndCheckSignature(h)) {
                    this.reader.index -= 4
                    var f = this.reader.readString(4)
                    throw new Error(
                      'Corrupted zip or bug: unexpected signature (' + a.pretty(f) + ', expected ' + a.pretty(h) + ')'
                    )
                  }
                },
                isSignature: function (h, f) {
                  var d = this.reader.index
                  this.reader.setIndex(h)
                  var T = this.reader.readString(4) === f
                  return this.reader.setIndex(d), T
                },
                readBlockEndOfCentral: function () {
                  ;(this.diskNumber = this.reader.readInt(2)),
                    (this.diskWithCentralDirStart = this.reader.readInt(2)),
                    (this.centralDirRecordsOnThisDisk = this.reader.readInt(2)),
                    (this.centralDirRecords = this.reader.readInt(2)),
                    (this.centralDirSize = this.reader.readInt(4)),
                    (this.centralDirOffset = this.reader.readInt(4)),
                    (this.zipCommentLength = this.reader.readInt(2))
                  var h = this.reader.readData(this.zipCommentLength),
                    f = c.uint8array ? 'uint8array' : 'array',
                    d = a.transformTo(f, h)
                  this.zipComment = this.loadOptions.decodeFileName(d)
                },
                readBlockZip64EndOfCentral: function () {
                  ;(this.zip64EndOfCentralSize = this.reader.readInt(8)),
                    this.reader.skip(4),
                    (this.diskNumber = this.reader.readInt(4)),
                    (this.diskWithCentralDirStart = this.reader.readInt(4)),
                    (this.centralDirRecordsOnThisDisk = this.reader.readInt(8)),
                    (this.centralDirRecords = this.reader.readInt(8)),
                    (this.centralDirSize = this.reader.readInt(8)),
                    (this.centralDirOffset = this.reader.readInt(8)),
                    (this.zip64ExtensibleData = {})
                  for (var h, f, d, T = this.zip64EndOfCentralSize - 44; 0 < T; )
                    (h = this.reader.readInt(2)),
                      (f = this.reader.readInt(4)),
                      (d = this.reader.readData(f)),
                      (this.zip64ExtensibleData[h] = { id: h, length: f, value: d })
                },
                readBlockZip64EndOfCentralLocator: function () {
                  if (
                    ((this.diskWithZip64CentralDirStart = this.reader.readInt(4)),
                    (this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8)),
                    (this.disksCount = this.reader.readInt(4)),
                    1 < this.disksCount)
                  )
                    throw new Error('Multi-volumes zip are not supported')
                },
                readLocalFiles: function () {
                  var h, f
                  for (h = 0; h < this.files.length; h++)
                    (f = this.files[h]),
                      this.reader.setIndex(f.localHeaderOffset),
                      this.checkSignature(o.LOCAL_FILE_HEADER),
                      f.readLocalPart(this.reader),
                      f.handleUTF8(),
                      f.processAttributes()
                },
                readCentralDir: function () {
                  var h
                  for (
                    this.reader.setIndex(this.centralDirOffset);
                    this.reader.readAndCheckSignature(o.CENTRAL_FILE_HEADER);

                  )
                    (h = new u({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader),
                      this.files.push(h)
                  if (
                    this.centralDirRecords !== this.files.length &&
                    this.centralDirRecords !== 0 &&
                    this.files.length === 0
                  )
                    throw new Error(
                      'Corrupted zip or bug: expected ' +
                        this.centralDirRecords +
                        ' records in central dir, got ' +
                        this.files.length
                    )
                },
                readEndOfCentral: function () {
                  var h = this.reader.lastIndexOfSignature(o.CENTRAL_DIRECTORY_END)
                  if (h < 0)
                    throw this.isSignature(0, o.LOCAL_FILE_HEADER)
                      ? new Error("Corrupted zip: can't find end of central directory")
                      : new Error(
                          "Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html"
                        )
                  this.reader.setIndex(h)
                  var f = h
                  if (
                    (this.checkSignature(o.CENTRAL_DIRECTORY_END),
                    this.readBlockEndOfCentral(),
                    this.diskNumber === a.MAX_VALUE_16BITS ||
                      this.diskWithCentralDirStart === a.MAX_VALUE_16BITS ||
                      this.centralDirRecordsOnThisDisk === a.MAX_VALUE_16BITS ||
                      this.centralDirRecords === a.MAX_VALUE_16BITS ||
                      this.centralDirSize === a.MAX_VALUE_32BITS ||
                      this.centralDirOffset === a.MAX_VALUE_32BITS)
                  ) {
                    if (
                      ((this.zip64 = !0), (h = this.reader.lastIndexOfSignature(o.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0)
                    )
                      throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator")
                    if (
                      (this.reader.setIndex(h),
                      this.checkSignature(o.ZIP64_CENTRAL_DIRECTORY_LOCATOR),
                      this.readBlockZip64EndOfCentralLocator(),
                      !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, o.ZIP64_CENTRAL_DIRECTORY_END) &&
                        ((this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(
                          o.ZIP64_CENTRAL_DIRECTORY_END
                        )),
                        this.relativeOffsetEndOfZip64CentralDir < 0))
                    )
                      throw new Error("Corrupted zip: can't find the ZIP64 end of central directory")
                    this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir),
                      this.checkSignature(o.ZIP64_CENTRAL_DIRECTORY_END),
                      this.readBlockZip64EndOfCentral()
                  }
                  var d = this.centralDirOffset + this.centralDirSize
                  this.zip64 && ((d += 20), (d += 12 + this.zip64EndOfCentralSize))
                  var T = f - d
                  if (0 < T) this.isSignature(f, o.CENTRAL_FILE_HEADER) || (this.reader.zero = T)
                  else if (T < 0) throw new Error('Corrupted zip: missing ' + Math.abs(T) + ' bytes.')
                },
                prepareReader: function (h) {
                  this.reader = s(h)
                },
                load: function (h) {
                  this.prepareReader(h), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles()
                },
              }),
                (i.exports = p)
            },
            {
              './reader/readerFor': 22,
              './signature': 23,
              './support': 30,
              './utf8': 31,
              './utils': 32,
              './zipEntry': 34,
            },
          ],
          34: [
            function (r, i, n) {
              var s = r('./reader/readerFor'),
                a = r('./utils'),
                o = r('./compressedObject'),
                u = r('./crc32'),
                c = r('./utf8'),
                p = r('./compressions'),
                h = r('./support')
              function f(d, T) {
                ;(this.options = d), (this.loadOptions = T)
              }
              ;(f.prototype = {
                isEncrypted: function () {
                  return (1 & this.bitFlag) == 1
                },
                useUTF8: function () {
                  return (2048 & this.bitFlag) == 2048
                },
                readLocalPart: function (d) {
                  var T, y
                  if (
                    (d.skip(22),
                    (this.fileNameLength = d.readInt(2)),
                    (y = d.readInt(2)),
                    (this.fileName = d.readData(this.fileNameLength)),
                    d.skip(y),
                    this.compressedSize === -1 || this.uncompressedSize === -1)
                  )
                    throw new Error(
                      "Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)"
                    )
                  if (
                    (T = (function (b) {
                      for (var m in p) if (p.hasOwnProperty(m) && p[m].magic === b) return p[m]
                      return null
                    })(this.compressionMethod)) === null
                  )
                    throw new Error(
                      'Corrupted zip : compression ' +
                        a.pretty(this.compressionMethod) +
                        ' unknown (inner file : ' +
                        a.transformTo('string', this.fileName) +
                        ')'
                    )
                  this.decompressed = new o(
                    this.compressedSize,
                    this.uncompressedSize,
                    this.crc32,
                    T,
                    d.readData(this.compressedSize)
                  )
                },
                readCentralPart: function (d) {
                  ;(this.versionMadeBy = d.readInt(2)),
                    d.skip(2),
                    (this.bitFlag = d.readInt(2)),
                    (this.compressionMethod = d.readString(2)),
                    (this.date = d.readDate()),
                    (this.crc32 = d.readInt(4)),
                    (this.compressedSize = d.readInt(4)),
                    (this.uncompressedSize = d.readInt(4))
                  var T = d.readInt(2)
                  if (
                    ((this.extraFieldsLength = d.readInt(2)),
                    (this.fileCommentLength = d.readInt(2)),
                    (this.diskNumberStart = d.readInt(2)),
                    (this.internalFileAttributes = d.readInt(2)),
                    (this.externalFileAttributes = d.readInt(4)),
                    (this.localHeaderOffset = d.readInt(4)),
                    this.isEncrypted())
                  )
                    throw new Error('Encrypted zip are not supported')
                  d.skip(T),
                    this.readExtraFields(d),
                    this.parseZIP64ExtraField(d),
                    (this.fileComment = d.readData(this.fileCommentLength))
                },
                processAttributes: function () {
                  ;(this.unixPermissions = null), (this.dosPermissions = null)
                  var d = this.versionMadeBy >> 8
                  ;(this.dir = !!(16 & this.externalFileAttributes)),
                    d == 0 && (this.dosPermissions = 63 & this.externalFileAttributes),
                    d == 3 && (this.unixPermissions = (this.externalFileAttributes >> 16) & 65535),
                    this.dir || this.fileNameStr.slice(-1) !== '/' || (this.dir = !0)
                },
                parseZIP64ExtraField: function (d) {
                  if (this.extraFields[1]) {
                    var T = s(this.extraFields[1].value)
                    this.uncompressedSize === a.MAX_VALUE_32BITS && (this.uncompressedSize = T.readInt(8)),
                      this.compressedSize === a.MAX_VALUE_32BITS && (this.compressedSize = T.readInt(8)),
                      this.localHeaderOffset === a.MAX_VALUE_32BITS && (this.localHeaderOffset = T.readInt(8)),
                      this.diskNumberStart === a.MAX_VALUE_32BITS && (this.diskNumberStart = T.readInt(4))
                  }
                },
                readExtraFields: function (d) {
                  var T,
                    y,
                    b,
                    m = d.index + this.extraFieldsLength
                  for (this.extraFields || (this.extraFields = {}); d.index + 4 < m; )
                    (T = d.readInt(2)),
                      (y = d.readInt(2)),
                      (b = d.readData(y)),
                      (this.extraFields[T] = { id: T, length: y, value: b })
                  d.setIndex(m)
                },
                handleUTF8: function () {
                  var d = h.uint8array ? 'uint8array' : 'array'
                  if (this.useUTF8())
                    (this.fileNameStr = c.utf8decode(this.fileName)),
                      (this.fileCommentStr = c.utf8decode(this.fileComment))
                  else {
                    var T = this.findExtraFieldUnicodePath()
                    if (T !== null) this.fileNameStr = T
                    else {
                      var y = a.transformTo(d, this.fileName)
                      this.fileNameStr = this.loadOptions.decodeFileName(y)
                    }
                    var b = this.findExtraFieldUnicodeComment()
                    if (b !== null) this.fileCommentStr = b
                    else {
                      var m = a.transformTo(d, this.fileComment)
                      this.fileCommentStr = this.loadOptions.decodeFileName(m)
                    }
                  }
                },
                findExtraFieldUnicodePath: function () {
                  var d = this.extraFields[28789]
                  if (d) {
                    var T = s(d.value)
                    return T.readInt(1) !== 1 || u(this.fileName) !== T.readInt(4)
                      ? null
                      : c.utf8decode(T.readData(d.length - 5))
                  }
                  return null
                },
                findExtraFieldUnicodeComment: function () {
                  var d = this.extraFields[25461]
                  if (d) {
                    var T = s(d.value)
                    return T.readInt(1) !== 1 || u(this.fileComment) !== T.readInt(4)
                      ? null
                      : c.utf8decode(T.readData(d.length - 5))
                  }
                  return null
                },
              }),
                (i.exports = f)
            },
            {
              './compressedObject': 2,
              './compressions': 3,
              './crc32': 4,
              './reader/readerFor': 22,
              './support': 30,
              './utf8': 31,
              './utils': 32,
            },
          ],
          35: [
            function (r, i, n) {
              function s(T, y, b) {
                ;(this.name = T),
                  (this.dir = b.dir),
                  (this.date = b.date),
                  (this.comment = b.comment),
                  (this.unixPermissions = b.unixPermissions),
                  (this.dosPermissions = b.dosPermissions),
                  (this._data = y),
                  (this._dataBinary = b.binary),
                  (this.options = { compression: b.compression, compressionOptions: b.compressionOptions })
              }
              var a = r('./stream/StreamHelper'),
                o = r('./stream/DataWorker'),
                u = r('./utf8'),
                c = r('./compressedObject'),
                p = r('./stream/GenericWorker')
              s.prototype = {
                internalStream: function (T) {
                  var y = null,
                    b = 'string'
                  try {
                    if (!T) throw new Error('No output type specified.')
                    var m = (b = T.toLowerCase()) === 'string' || b === 'text'
                    ;(b !== 'binarystring' && b !== 'text') || (b = 'string'), (y = this._decompressWorker())
                    var S = !this._dataBinary
                    S && !m && (y = y.pipe(new u.Utf8EncodeWorker())), !S && m && (y = y.pipe(new u.Utf8DecodeWorker()))
                  } catch (E) {
                    ;(y = new p('error')).error(E)
                  }
                  return new a(y, b, '')
                },
                async: function (T, y) {
                  return this.internalStream(T).accumulate(y)
                },
                nodeStream: function (T, y) {
                  return this.internalStream(T || 'nodebuffer').toNodejsStream(y)
                },
                _compressWorker: function (T, y) {
                  if (this._data instanceof c && this._data.compression.magic === T.magic)
                    return this._data.getCompressedWorker()
                  var b = this._decompressWorker()
                  return this._dataBinary || (b = b.pipe(new u.Utf8EncodeWorker())), c.createWorkerFrom(b, T, y)
                },
                _decompressWorker: function () {
                  return this._data instanceof c
                    ? this._data.getContentWorker()
                    : this._data instanceof p
                    ? this._data
                    : new o(this._data)
                },
              }
              for (
                var h = ['asText', 'asBinary', 'asNodeBuffer', 'asUint8Array', 'asArrayBuffer'],
                  f = function () {
                    throw new Error('This method has been removed in JSZip 3.0, please check the upgrade guide.')
                  },
                  d = 0;
                d < h.length;
                d++
              )
                s.prototype[h[d]] = f
              i.exports = s
            },
            {
              './compressedObject': 2,
              './stream/DataWorker': 27,
              './stream/GenericWorker': 28,
              './stream/StreamHelper': 29,
              './utf8': 31,
            },
          ],
          36: [
            function (r, i, n) {
              ;(function (s) {
                var a,
                  o,
                  u = s.MutationObserver || s.WebKitMutationObserver
                if (u) {
                  var c = 0,
                    p = new u(T),
                    h = s.document.createTextNode('')
                  p.observe(h, { characterData: !0 }),
                    (a = function () {
                      h.data = c = ++c % 2
                    })
                } else if (s.setImmediate || s.MessageChannel === void 0)
                  a =
                    'document' in s && 'onreadystatechange' in s.document.createElement('script')
                      ? function () {
                          var y = s.document.createElement('script')
                          ;(y.onreadystatechange = function () {
                            T(), (y.onreadystatechange = null), y.parentNode.removeChild(y), (y = null)
                          }),
                            s.document.documentElement.appendChild(y)
                        }
                      : function () {
                          setTimeout(T, 0)
                        }
                else {
                  var f = new s.MessageChannel()
                  ;(f.port1.onmessage = T),
                    (a = function () {
                      f.port2.postMessage(0)
                    })
                }
                var d = []
                function T() {
                  var y, b
                  o = !0
                  for (var m = d.length; m; ) {
                    for (b = d, d = [], y = -1; ++y < m; ) b[y]()
                    m = d.length
                  }
                  o = !1
                }
                i.exports = function (y) {
                  d.push(y) !== 1 || o || a()
                }
              }.call(
                this,
                typeof jt != 'undefined'
                  ? jt
                  : typeof self != 'undefined'
                  ? self
                  : typeof window != 'undefined'
                  ? window
                  : {}
              ))
            },
            {},
          ],
          37: [
            function (r, i, n) {
              var s = r('immediate')
              function a() {}
              var o = {},
                u = ['REJECTED'],
                c = ['FULFILLED'],
                p = ['PENDING']
              function h(m) {
                if (typeof m != 'function') throw new TypeError('resolver must be a function')
                ;(this.state = p), (this.queue = []), (this.outcome = void 0), m !== a && y(this, m)
              }
              function f(m, S, E) {
                ;(this.promise = m),
                  typeof S == 'function' && ((this.onFulfilled = S), (this.callFulfilled = this.otherCallFulfilled)),
                  typeof E == 'function' && ((this.onRejected = E), (this.callRejected = this.otherCallRejected))
              }
              function d(m, S, E) {
                s(function () {
                  var P
                  try {
                    P = S(E)
                  } catch (x) {
                    return o.reject(m, x)
                  }
                  P === m ? o.reject(m, new TypeError('Cannot resolve promise with itself')) : o.resolve(m, P)
                })
              }
              function T(m) {
                var S = m && m.then
                if (m && (typeof m == 'object' || typeof m == 'function') && typeof S == 'function')
                  return function () {
                    S.apply(m, arguments)
                  }
              }
              function y(m, S) {
                var E = !1
                function P(N) {
                  E || ((E = !0), o.reject(m, N))
                }
                function x(N) {
                  E || ((E = !0), o.resolve(m, N))
                }
                var D = b(function () {
                  S(x, P)
                })
                D.status === 'error' && P(D.value)
              }
              function b(m, S) {
                var E = {}
                try {
                  ;(E.value = m(S)), (E.status = 'success')
                } catch (P) {
                  ;(E.status = 'error'), (E.value = P)
                }
                return E
              }
              ;((i.exports = h).prototype.finally = function (m) {
                if (typeof m != 'function') return this
                var S = this.constructor
                return this.then(
                  function (E) {
                    return S.resolve(m()).then(function () {
                      return E
                    })
                  },
                  function (E) {
                    return S.resolve(m()).then(function () {
                      throw E
                    })
                  }
                )
              }),
                (h.prototype.catch = function (m) {
                  return this.then(null, m)
                }),
                (h.prototype.then = function (m, S) {
                  if ((typeof m != 'function' && this.state === c) || (typeof S != 'function' && this.state === u))
                    return this
                  var E = new this.constructor(a)
                  return (
                    this.state !== p ? d(E, this.state === c ? m : S, this.outcome) : this.queue.push(new f(E, m, S)), E
                  )
                }),
                (f.prototype.callFulfilled = function (m) {
                  o.resolve(this.promise, m)
                }),
                (f.prototype.otherCallFulfilled = function (m) {
                  d(this.promise, this.onFulfilled, m)
                }),
                (f.prototype.callRejected = function (m) {
                  o.reject(this.promise, m)
                }),
                (f.prototype.otherCallRejected = function (m) {
                  d(this.promise, this.onRejected, m)
                }),
                (o.resolve = function (m, S) {
                  var E = b(T, S)
                  if (E.status === 'error') return o.reject(m, E.value)
                  var P = E.value
                  if (P) y(m, P)
                  else {
                    ;(m.state = c), (m.outcome = S)
                    for (var x = -1, D = m.queue.length; ++x < D; ) m.queue[x].callFulfilled(S)
                  }
                  return m
                }),
                (o.reject = function (m, S) {
                  ;(m.state = u), (m.outcome = S)
                  for (var E = -1, P = m.queue.length; ++E < P; ) m.queue[E].callRejected(S)
                  return m
                }),
                (h.resolve = function (m) {
                  return m instanceof this ? m : o.resolve(new this(a), m)
                }),
                (h.reject = function (m) {
                  var S = new this(a)
                  return o.reject(S, m)
                }),
                (h.all = function (m) {
                  var S = this
                  if (Object.prototype.toString.call(m) !== '[object Array]')
                    return this.reject(new TypeError('must be an array'))
                  var E = m.length,
                    P = !1
                  if (!E) return this.resolve([])
                  for (var x = new Array(E), D = 0, N = -1, I = new this(a); ++N < E; ) B(m[N], N)
                  return I
                  function B(K, Y) {
                    S.resolve(K).then(
                      function (C) {
                        ;(x[Y] = C), ++D !== E || P || ((P = !0), o.resolve(I, x))
                      },
                      function (C) {
                        P || ((P = !0), o.reject(I, C))
                      }
                    )
                  }
                }),
                (h.race = function (m) {
                  var S = this
                  if (Object.prototype.toString.call(m) !== '[object Array]')
                    return this.reject(new TypeError('must be an array'))
                  var E = m.length,
                    P = !1
                  if (!E) return this.resolve([])
                  for (var x = -1, D = new this(a); ++x < E; )
                    (N = m[x]),
                      S.resolve(N).then(
                        function (I) {
                          P || ((P = !0), o.resolve(D, I))
                        },
                        function (I) {
                          P || ((P = !0), o.reject(D, I))
                        }
                      )
                  var N
                  return D
                })
            },
            { immediate: 36 },
          ],
          38: [
            function (r, i, n) {
              var s = {}
              ;(0, r('./lib/utils/common').assign)(
                s,
                r('./lib/deflate'),
                r('./lib/inflate'),
                r('./lib/zlib/constants')
              ),
                (i.exports = s)
            },
            { './lib/deflate': 39, './lib/inflate': 40, './lib/utils/common': 41, './lib/zlib/constants': 44 },
          ],
          39: [
            function (r, i, n) {
              var s = r('./zlib/deflate'),
                a = r('./utils/common'),
                o = r('./utils/strings'),
                u = r('./zlib/messages'),
                c = r('./zlib/zstream'),
                p = Object.prototype.toString,
                h = 0,
                f = -1,
                d = 0,
                T = 8
              function y(m) {
                if (!(this instanceof y)) return new y(m)
                this.options = a.assign(
                  { level: f, method: T, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: d, to: '' },
                  m || {}
                )
                var S = this.options
                S.raw && 0 < S.windowBits
                  ? (S.windowBits = -S.windowBits)
                  : S.gzip && 0 < S.windowBits && S.windowBits < 16 && (S.windowBits += 16),
                  (this.err = 0),
                  (this.msg = ''),
                  (this.ended = !1),
                  (this.chunks = []),
                  (this.strm = new c()),
                  (this.strm.avail_out = 0)
                var E = s.deflateInit2(this.strm, S.level, S.method, S.windowBits, S.memLevel, S.strategy)
                if (E !== h) throw new Error(u[E])
                if ((S.header && s.deflateSetHeader(this.strm, S.header), S.dictionary)) {
                  var P
                  if (
                    ((P =
                      typeof S.dictionary == 'string'
                        ? o.string2buf(S.dictionary)
                        : p.call(S.dictionary) === '[object ArrayBuffer]'
                        ? new Uint8Array(S.dictionary)
                        : S.dictionary),
                    (E = s.deflateSetDictionary(this.strm, P)) !== h)
                  )
                    throw new Error(u[E])
                  this._dict_set = !0
                }
              }
              function b(m, S) {
                var E = new y(S)
                if ((E.push(m, !0), E.err)) throw E.msg || u[E.err]
                return E.result
              }
              ;(y.prototype.push = function (m, S) {
                var E,
                  P,
                  x = this.strm,
                  D = this.options.chunkSize
                if (this.ended) return !1
                ;(P = S === ~~S ? S : S === !0 ? 4 : 0),
                  typeof m == 'string'
                    ? (x.input = o.string2buf(m))
                    : p.call(m) === '[object ArrayBuffer]'
                    ? (x.input = new Uint8Array(m))
                    : (x.input = m),
                  (x.next_in = 0),
                  (x.avail_in = x.input.length)
                do {
                  if (
                    (x.avail_out === 0 && ((x.output = new a.Buf8(D)), (x.next_out = 0), (x.avail_out = D)),
                    (E = s.deflate(x, P)) !== 1 && E !== h)
                  )
                    return this.onEnd(E), !(this.ended = !0)
                  ;(x.avail_out !== 0 && (x.avail_in !== 0 || (P !== 4 && P !== 2))) ||
                    (this.options.to === 'string'
                      ? this.onData(o.buf2binstring(a.shrinkBuf(x.output, x.next_out)))
                      : this.onData(a.shrinkBuf(x.output, x.next_out)))
                } while ((0 < x.avail_in || x.avail_out === 0) && E !== 1)
                return P === 4
                  ? ((E = s.deflateEnd(this.strm)), this.onEnd(E), (this.ended = !0), E === h)
                  : P !== 2 || (this.onEnd(h), !(x.avail_out = 0))
              }),
                (y.prototype.onData = function (m) {
                  this.chunks.push(m)
                }),
                (y.prototype.onEnd = function (m) {
                  m === h &&
                    (this.options.to === 'string'
                      ? (this.result = this.chunks.join(''))
                      : (this.result = a.flattenChunks(this.chunks))),
                    (this.chunks = []),
                    (this.err = m),
                    (this.msg = this.strm.msg)
                }),
                (n.Deflate = y),
                (n.deflate = b),
                (n.deflateRaw = function (m, S) {
                  return ((S = S || {}).raw = !0), b(m, S)
                }),
                (n.gzip = function (m, S) {
                  return ((S = S || {}).gzip = !0), b(m, S)
                })
            },
            {
              './utils/common': 41,
              './utils/strings': 42,
              './zlib/deflate': 46,
              './zlib/messages': 51,
              './zlib/zstream': 53,
            },
          ],
          40: [
            function (r, i, n) {
              var s = r('./zlib/inflate'),
                a = r('./utils/common'),
                o = r('./utils/strings'),
                u = r('./zlib/constants'),
                c = r('./zlib/messages'),
                p = r('./zlib/zstream'),
                h = r('./zlib/gzheader'),
                f = Object.prototype.toString
              function d(y) {
                if (!(this instanceof d)) return new d(y)
                this.options = a.assign({ chunkSize: 16384, windowBits: 0, to: '' }, y || {})
                var b = this.options
                b.raw &&
                  0 <= b.windowBits &&
                  b.windowBits < 16 &&
                  ((b.windowBits = -b.windowBits), b.windowBits === 0 && (b.windowBits = -15)),
                  !(0 <= b.windowBits && b.windowBits < 16) || (y && y.windowBits) || (b.windowBits += 32),
                  15 < b.windowBits && b.windowBits < 48 && (15 & b.windowBits) == 0 && (b.windowBits |= 15),
                  (this.err = 0),
                  (this.msg = ''),
                  (this.ended = !1),
                  (this.chunks = []),
                  (this.strm = new p()),
                  (this.strm.avail_out = 0)
                var m = s.inflateInit2(this.strm, b.windowBits)
                if (m !== u.Z_OK) throw new Error(c[m])
                ;(this.header = new h()), s.inflateGetHeader(this.strm, this.header)
              }
              function T(y, b) {
                var m = new d(b)
                if ((m.push(y, !0), m.err)) throw m.msg || c[m.err]
                return m.result
              }
              ;(d.prototype.push = function (y, b) {
                var m,
                  S,
                  E,
                  P,
                  x,
                  D,
                  N = this.strm,
                  I = this.options.chunkSize,
                  B = this.options.dictionary,
                  K = !1
                if (this.ended) return !1
                ;(S = b === ~~b ? b : b === !0 ? u.Z_FINISH : u.Z_NO_FLUSH),
                  typeof y == 'string'
                    ? (N.input = o.binstring2buf(y))
                    : f.call(y) === '[object ArrayBuffer]'
                    ? (N.input = new Uint8Array(y))
                    : (N.input = y),
                  (N.next_in = 0),
                  (N.avail_in = N.input.length)
                do {
                  if (
                    (N.avail_out === 0 && ((N.output = new a.Buf8(I)), (N.next_out = 0), (N.avail_out = I)),
                    (m = s.inflate(N, u.Z_NO_FLUSH)) === u.Z_NEED_DICT &&
                      B &&
                      ((D =
                        typeof B == 'string'
                          ? o.string2buf(B)
                          : f.call(B) === '[object ArrayBuffer]'
                          ? new Uint8Array(B)
                          : B),
                      (m = s.inflateSetDictionary(this.strm, D))),
                    m === u.Z_BUF_ERROR && K === !0 && ((m = u.Z_OK), (K = !1)),
                    m !== u.Z_STREAM_END && m !== u.Z_OK)
                  )
                    return this.onEnd(m), !(this.ended = !0)
                  N.next_out &&
                    ((N.avail_out !== 0 &&
                      m !== u.Z_STREAM_END &&
                      (N.avail_in !== 0 || (S !== u.Z_FINISH && S !== u.Z_SYNC_FLUSH))) ||
                      (this.options.to === 'string'
                        ? ((E = o.utf8border(N.output, N.next_out)),
                          (P = N.next_out - E),
                          (x = o.buf2string(N.output, E)),
                          (N.next_out = P),
                          (N.avail_out = I - P),
                          P && a.arraySet(N.output, N.output, E, P, 0),
                          this.onData(x))
                        : this.onData(a.shrinkBuf(N.output, N.next_out)))),
                    N.avail_in === 0 && N.avail_out === 0 && (K = !0)
                } while ((0 < N.avail_in || N.avail_out === 0) && m !== u.Z_STREAM_END)
                return (
                  m === u.Z_STREAM_END && (S = u.Z_FINISH),
                  S === u.Z_FINISH
                    ? ((m = s.inflateEnd(this.strm)), this.onEnd(m), (this.ended = !0), m === u.Z_OK)
                    : S !== u.Z_SYNC_FLUSH || (this.onEnd(u.Z_OK), !(N.avail_out = 0))
                )
              }),
                (d.prototype.onData = function (y) {
                  this.chunks.push(y)
                }),
                (d.prototype.onEnd = function (y) {
                  y === u.Z_OK &&
                    (this.options.to === 'string'
                      ? (this.result = this.chunks.join(''))
                      : (this.result = a.flattenChunks(this.chunks))),
                    (this.chunks = []),
                    (this.err = y),
                    (this.msg = this.strm.msg)
                }),
                (n.Inflate = d),
                (n.inflate = T),
                (n.inflateRaw = function (y, b) {
                  return ((b = b || {}).raw = !0), T(y, b)
                }),
                (n.ungzip = T)
            },
            {
              './utils/common': 41,
              './utils/strings': 42,
              './zlib/constants': 44,
              './zlib/gzheader': 47,
              './zlib/inflate': 49,
              './zlib/messages': 51,
              './zlib/zstream': 53,
            },
          ],
          41: [
            function (r, i, n) {
              var s =
                typeof Uint8Array != 'undefined' &&
                typeof Uint16Array != 'undefined' &&
                typeof Int32Array != 'undefined'
              ;(n.assign = function (u) {
                for (var c = Array.prototype.slice.call(arguments, 1); c.length; ) {
                  var p = c.shift()
                  if (p) {
                    if (typeof p != 'object') throw new TypeError(p + 'must be non-object')
                    for (var h in p) p.hasOwnProperty(h) && (u[h] = p[h])
                  }
                }
                return u
              }),
                (n.shrinkBuf = function (u, c) {
                  return u.length === c ? u : u.subarray ? u.subarray(0, c) : ((u.length = c), u)
                })
              var a = {
                  arraySet: function (u, c, p, h, f) {
                    if (c.subarray && u.subarray) u.set(c.subarray(p, p + h), f)
                    else for (var d = 0; d < h; d++) u[f + d] = c[p + d]
                  },
                  flattenChunks: function (u) {
                    var c, p, h, f, d, T
                    for (c = h = 0, p = u.length; c < p; c++) h += u[c].length
                    for (T = new Uint8Array(h), c = f = 0, p = u.length; c < p; c++)
                      (d = u[c]), T.set(d, f), (f += d.length)
                    return T
                  },
                },
                o = {
                  arraySet: function (u, c, p, h, f) {
                    for (var d = 0; d < h; d++) u[f + d] = c[p + d]
                  },
                  flattenChunks: function (u) {
                    return [].concat.apply([], u)
                  },
                }
              ;(n.setTyped = function (u) {
                u
                  ? ((n.Buf8 = Uint8Array), (n.Buf16 = Uint16Array), (n.Buf32 = Int32Array), n.assign(n, a))
                  : ((n.Buf8 = Array), (n.Buf16 = Array), (n.Buf32 = Array), n.assign(n, o))
              }),
                n.setTyped(s)
            },
            {},
          ],
          42: [
            function (r, i, n) {
              var s = r('./common'),
                a = !0,
                o = !0
              try {
                String.fromCharCode.apply(null, [0])
              } catch {
                a = !1
              }
              try {
                String.fromCharCode.apply(null, new Uint8Array(1))
              } catch {
                o = !1
              }
              for (var u = new s.Buf8(256), c = 0; c < 256; c++)
                u[c] = 252 <= c ? 6 : 248 <= c ? 5 : 240 <= c ? 4 : 224 <= c ? 3 : 192 <= c ? 2 : 1
              function p(h, f) {
                if (f < 65537 && ((h.subarray && o) || (!h.subarray && a)))
                  return String.fromCharCode.apply(null, s.shrinkBuf(h, f))
                for (var d = '', T = 0; T < f; T++) d += String.fromCharCode(h[T])
                return d
              }
              ;(u[254] = u[254] = 1),
                (n.string2buf = function (h) {
                  var f,
                    d,
                    T,
                    y,
                    b,
                    m = h.length,
                    S = 0
                  for (y = 0; y < m; y++)
                    (64512 & (d = h.charCodeAt(y))) == 55296 &&
                      y + 1 < m &&
                      (64512 & (T = h.charCodeAt(y + 1))) == 56320 &&
                      ((d = 65536 + ((d - 55296) << 10) + (T - 56320)), y++),
                      (S += d < 128 ? 1 : d < 2048 ? 2 : d < 65536 ? 3 : 4)
                  for (f = new s.Buf8(S), y = b = 0; b < S; y++)
                    (64512 & (d = h.charCodeAt(y))) == 55296 &&
                      y + 1 < m &&
                      (64512 & (T = h.charCodeAt(y + 1))) == 56320 &&
                      ((d = 65536 + ((d - 55296) << 10) + (T - 56320)), y++),
                      d < 128
                        ? (f[b++] = d)
                        : (d < 2048
                            ? (f[b++] = 192 | (d >>> 6))
                            : (d < 65536
                                ? (f[b++] = 224 | (d >>> 12))
                                : ((f[b++] = 240 | (d >>> 18)), (f[b++] = 128 | ((d >>> 12) & 63))),
                              (f[b++] = 128 | ((d >>> 6) & 63))),
                          (f[b++] = 128 | (63 & d)))
                  return f
                }),
                (n.buf2binstring = function (h) {
                  return p(h, h.length)
                }),
                (n.binstring2buf = function (h) {
                  for (var f = new s.Buf8(h.length), d = 0, T = f.length; d < T; d++) f[d] = h.charCodeAt(d)
                  return f
                }),
                (n.buf2string = function (h, f) {
                  var d,
                    T,
                    y,
                    b,
                    m = f || h.length,
                    S = new Array(2 * m)
                  for (d = T = 0; d < m; )
                    if ((y = h[d++]) < 128) S[T++] = y
                    else if (4 < (b = u[y])) (S[T++] = 65533), (d += b - 1)
                    else {
                      for (y &= b === 2 ? 31 : b === 3 ? 15 : 7; 1 < b && d < m; ) (y = (y << 6) | (63 & h[d++])), b--
                      1 < b
                        ? (S[T++] = 65533)
                        : y < 65536
                        ? (S[T++] = y)
                        : ((y -= 65536), (S[T++] = 55296 | ((y >> 10) & 1023)), (S[T++] = 56320 | (1023 & y)))
                    }
                  return p(S, T)
                }),
                (n.utf8border = function (h, f) {
                  var d
                  for ((f = f || h.length) > h.length && (f = h.length), d = f - 1; 0 <= d && (192 & h[d]) == 128; ) d--
                  return d < 0 || d === 0 ? f : d + u[h[d]] > f ? d : f
                })
            },
            { './common': 41 },
          ],
          43: [
            function (r, i, n) {
              i.exports = function (s, a, o, u) {
                for (var c = (65535 & s) | 0, p = ((s >>> 16) & 65535) | 0, h = 0; o !== 0; ) {
                  for (o -= h = 2e3 < o ? 2e3 : o; (p = (p + (c = (c + a[u++]) | 0)) | 0), --h; );
                  ;(c %= 65521), (p %= 65521)
                }
                return c | (p << 16) | 0
              }
            },
            {},
          ],
          44: [
            function (r, i, n) {
              i.exports = {
                Z_NO_FLUSH: 0,
                Z_PARTIAL_FLUSH: 1,
                Z_SYNC_FLUSH: 2,
                Z_FULL_FLUSH: 3,
                Z_FINISH: 4,
                Z_BLOCK: 5,
                Z_TREES: 6,
                Z_OK: 0,
                Z_STREAM_END: 1,
                Z_NEED_DICT: 2,
                Z_ERRNO: -1,
                Z_STREAM_ERROR: -2,
                Z_DATA_ERROR: -3,
                Z_BUF_ERROR: -5,
                Z_NO_COMPRESSION: 0,
                Z_BEST_SPEED: 1,
                Z_BEST_COMPRESSION: 9,
                Z_DEFAULT_COMPRESSION: -1,
                Z_FILTERED: 1,
                Z_HUFFMAN_ONLY: 2,
                Z_RLE: 3,
                Z_FIXED: 4,
                Z_DEFAULT_STRATEGY: 0,
                Z_BINARY: 0,
                Z_TEXT: 1,
                Z_UNKNOWN: 2,
                Z_DEFLATED: 8,
              }
            },
            {},
          ],
          45: [
            function (r, i, n) {
              var s = (function () {
                for (var a, o = [], u = 0; u < 256; u++) {
                  a = u
                  for (var c = 0; c < 8; c++) a = 1 & a ? 3988292384 ^ (a >>> 1) : a >>> 1
                  o[u] = a
                }
                return o
              })()
              i.exports = function (a, o, u, c) {
                var p = s,
                  h = c + u
                a ^= -1
                for (var f = c; f < h; f++) a = (a >>> 8) ^ p[255 & (a ^ o[f])]
                return -1 ^ a
              }
            },
            {},
          ],
          46: [
            function (r, i, n) {
              var s,
                a = r('../utils/common'),
                o = r('./trees'),
                u = r('./adler32'),
                c = r('./crc32'),
                p = r('./messages'),
                h = 0,
                f = 4,
                d = 0,
                T = -2,
                y = -1,
                b = 4,
                m = 2,
                S = 8,
                E = 9,
                P = 286,
                x = 30,
                D = 19,
                N = 2 * P + 1,
                I = 15,
                B = 3,
                K = 258,
                Y = K + B + 1,
                C = 42,
                H = 113,
                w = 1,
                J = 2,
                X = 3,
                G = 4
              function Te(A, pe) {
                return (A.msg = p[pe]), pe
              }
              function ce(A) {
                return (A << 1) - (4 < A ? 9 : 0)
              }
              function se(A) {
                for (var pe = A.length; 0 <= --pe; ) A[pe] = 0
              }
              function U(A) {
                var pe = A.state,
                  ie = pe.pending
                ie > A.avail_out && (ie = A.avail_out),
                  ie !== 0 &&
                    (a.arraySet(A.output, pe.pending_buf, pe.pending_out, ie, A.next_out),
                    (A.next_out += ie),
                    (pe.pending_out += ie),
                    (A.total_out += ie),
                    (A.avail_out -= ie),
                    (pe.pending -= ie),
                    pe.pending === 0 && (pe.pending_out = 0))
              }
              function W(A, pe) {
                o._tr_flush_block(A, 0 <= A.block_start ? A.block_start : -1, A.strstart - A.block_start, pe),
                  (A.block_start = A.strstart),
                  U(A.strm)
              }
              function ge(A, pe) {
                A.pending_buf[A.pending++] = pe
              }
              function ye(A, pe) {
                ;(A.pending_buf[A.pending++] = (pe >>> 8) & 255), (A.pending_buf[A.pending++] = 255 & pe)
              }
              function me(A, pe) {
                var ie,
                  L,
                  F = A.max_chain_length,
                  q = A.strstart,
                  le = A.prev_length,
                  fe = A.nice_match,
                  ne = A.strstart > A.w_size - Y ? A.strstart - (A.w_size - Y) : 0,
                  Se = A.window,
                  xe = A.w_mask,
                  Ae = A.prev,
                  Re = A.strstart + K,
                  O = Se[q + le - 1],
                  g = Se[q + le]
                A.prev_length >= A.good_match && (F >>= 2), fe > A.lookahead && (fe = A.lookahead)
                do
                  if (Se[(ie = pe) + le] === g && Se[ie + le - 1] === O && Se[ie] === Se[q] && Se[++ie] === Se[q + 1]) {
                    ;(q += 2), ie++
                    do;
                    while (
                      Se[++q] === Se[++ie] &&
                      Se[++q] === Se[++ie] &&
                      Se[++q] === Se[++ie] &&
                      Se[++q] === Se[++ie] &&
                      Se[++q] === Se[++ie] &&
                      Se[++q] === Se[++ie] &&
                      Se[++q] === Se[++ie] &&
                      Se[++q] === Se[++ie] &&
                      q < Re
                    )
                    if (((L = K - (Re - q)), (q = Re - K), le < L)) {
                      if (((A.match_start = pe), fe <= (le = L))) break
                      ;(O = Se[q + le - 1]), (g = Se[q + le])
                    }
                  }
                while ((pe = Ae[pe & xe]) > ne && --F != 0)
                return le <= A.lookahead ? le : A.lookahead
              }
              function ke(A) {
                var pe,
                  ie,
                  L,
                  F,
                  q,
                  le,
                  fe,
                  ne,
                  Se,
                  xe,
                  Ae = A.w_size
                do {
                  if (((F = A.window_size - A.lookahead - A.strstart), A.strstart >= Ae + (Ae - Y))) {
                    for (
                      a.arraySet(A.window, A.window, Ae, Ae, 0),
                        A.match_start -= Ae,
                        A.strstart -= Ae,
                        A.block_start -= Ae,
                        pe = ie = A.hash_size;
                      (L = A.head[--pe]), (A.head[pe] = Ae <= L ? L - Ae : 0), --ie;

                    );
                    for (pe = ie = Ae; (L = A.prev[--pe]), (A.prev[pe] = Ae <= L ? L - Ae : 0), --ie; );
                    F += Ae
                  }
                  if (A.strm.avail_in === 0) break
                  if (
                    ((le = A.strm),
                    (fe = A.window),
                    (ne = A.strstart + A.lookahead),
                    (Se = F),
                    (xe = void 0),
                    (xe = le.avail_in),
                    Se < xe && (xe = Se),
                    (ie =
                      xe === 0
                        ? 0
                        : ((le.avail_in -= xe),
                          a.arraySet(fe, le.input, le.next_in, xe, ne),
                          le.state.wrap === 1
                            ? (le.adler = u(le.adler, fe, xe, ne))
                            : le.state.wrap === 2 && (le.adler = c(le.adler, fe, xe, ne)),
                          (le.next_in += xe),
                          (le.total_in += xe),
                          xe)),
                    (A.lookahead += ie),
                    A.lookahead + A.insert >= B)
                  )
                    for (
                      q = A.strstart - A.insert,
                        A.ins_h = A.window[q],
                        A.ins_h = ((A.ins_h << A.hash_shift) ^ A.window[q + 1]) & A.hash_mask;
                      A.insert &&
                      ((A.ins_h = ((A.ins_h << A.hash_shift) ^ A.window[q + B - 1]) & A.hash_mask),
                      (A.prev[q & A.w_mask] = A.head[A.ins_h]),
                      (A.head[A.ins_h] = q),
                      q++,
                      A.insert--,
                      !(A.lookahead + A.insert < B));

                    );
                } while (A.lookahead < Y && A.strm.avail_in !== 0)
              }
              function ae(A, pe) {
                for (var ie, L; ; ) {
                  if (A.lookahead < Y) {
                    if ((ke(A), A.lookahead < Y && pe === h)) return w
                    if (A.lookahead === 0) break
                  }
                  if (
                    ((ie = 0),
                    A.lookahead >= B &&
                      ((A.ins_h = ((A.ins_h << A.hash_shift) ^ A.window[A.strstart + B - 1]) & A.hash_mask),
                      (ie = A.prev[A.strstart & A.w_mask] = A.head[A.ins_h]),
                      (A.head[A.ins_h] = A.strstart)),
                    ie !== 0 && A.strstart - ie <= A.w_size - Y && (A.match_length = me(A, ie)),
                    A.match_length >= B)
                  )
                    if (
                      ((L = o._tr_tally(A, A.strstart - A.match_start, A.match_length - B)),
                      (A.lookahead -= A.match_length),
                      A.match_length <= A.max_lazy_match && A.lookahead >= B)
                    ) {
                      for (
                        A.match_length--;
                        A.strstart++,
                          (A.ins_h = ((A.ins_h << A.hash_shift) ^ A.window[A.strstart + B - 1]) & A.hash_mask),
                          (ie = A.prev[A.strstart & A.w_mask] = A.head[A.ins_h]),
                          (A.head[A.ins_h] = A.strstart),
                          --A.match_length != 0;

                      );
                      A.strstart++
                    } else
                      (A.strstart += A.match_length),
                        (A.match_length = 0),
                        (A.ins_h = A.window[A.strstart]),
                        (A.ins_h = ((A.ins_h << A.hash_shift) ^ A.window[A.strstart + 1]) & A.hash_mask)
                  else (L = o._tr_tally(A, 0, A.window[A.strstart])), A.lookahead--, A.strstart++
                  if (L && (W(A, !1), A.strm.avail_out === 0)) return w
                }
                return (
                  (A.insert = A.strstart < B - 1 ? A.strstart : B - 1),
                  pe === f
                    ? (W(A, !0), A.strm.avail_out === 0 ? X : G)
                    : A.last_lit && (W(A, !1), A.strm.avail_out === 0)
                    ? w
                    : J
                )
              }
              function de(A, pe) {
                for (var ie, L, F; ; ) {
                  if (A.lookahead < Y) {
                    if ((ke(A), A.lookahead < Y && pe === h)) return w
                    if (A.lookahead === 0) break
                  }
                  if (
                    ((ie = 0),
                    A.lookahead >= B &&
                      ((A.ins_h = ((A.ins_h << A.hash_shift) ^ A.window[A.strstart + B - 1]) & A.hash_mask),
                      (ie = A.prev[A.strstart & A.w_mask] = A.head[A.ins_h]),
                      (A.head[A.ins_h] = A.strstart)),
                    (A.prev_length = A.match_length),
                    (A.prev_match = A.match_start),
                    (A.match_length = B - 1),
                    ie !== 0 &&
                      A.prev_length < A.max_lazy_match &&
                      A.strstart - ie <= A.w_size - Y &&
                      ((A.match_length = me(A, ie)),
                      A.match_length <= 5 &&
                        (A.strategy === 1 || (A.match_length === B && 4096 < A.strstart - A.match_start)) &&
                        (A.match_length = B - 1)),
                    A.prev_length >= B && A.match_length <= A.prev_length)
                  ) {
                    for (
                      F = A.strstart + A.lookahead - B,
                        L = o._tr_tally(A, A.strstart - 1 - A.prev_match, A.prev_length - B),
                        A.lookahead -= A.prev_length - 1,
                        A.prev_length -= 2;
                      ++A.strstart <= F &&
                        ((A.ins_h = ((A.ins_h << A.hash_shift) ^ A.window[A.strstart + B - 1]) & A.hash_mask),
                        (ie = A.prev[A.strstart & A.w_mask] = A.head[A.ins_h]),
                        (A.head[A.ins_h] = A.strstart)),
                        --A.prev_length != 0;

                    );
                    if (
                      ((A.match_available = 0),
                      (A.match_length = B - 1),
                      A.strstart++,
                      L && (W(A, !1), A.strm.avail_out === 0))
                    )
                      return w
                  } else if (A.match_available) {
                    if (
                      ((L = o._tr_tally(A, 0, A.window[A.strstart - 1])) && W(A, !1),
                      A.strstart++,
                      A.lookahead--,
                      A.strm.avail_out === 0)
                    )
                      return w
                  } else (A.match_available = 1), A.strstart++, A.lookahead--
                }
                return (
                  A.match_available && ((L = o._tr_tally(A, 0, A.window[A.strstart - 1])), (A.match_available = 0)),
                  (A.insert = A.strstart < B - 1 ? A.strstart : B - 1),
                  pe === f
                    ? (W(A, !0), A.strm.avail_out === 0 ? X : G)
                    : A.last_lit && (W(A, !1), A.strm.avail_out === 0)
                    ? w
                    : J
                )
              }
              function be(A, pe, ie, L, F) {
                ;(this.good_length = A),
                  (this.max_lazy = pe),
                  (this.nice_length = ie),
                  (this.max_chain = L),
                  (this.func = F)
              }
              function Pe() {
                ;(this.strm = null),
                  (this.status = 0),
                  (this.pending_buf = null),
                  (this.pending_buf_size = 0),
                  (this.pending_out = 0),
                  (this.pending = 0),
                  (this.wrap = 0),
                  (this.gzhead = null),
                  (this.gzindex = 0),
                  (this.method = S),
                  (this.last_flush = -1),
                  (this.w_size = 0),
                  (this.w_bits = 0),
                  (this.w_mask = 0),
                  (this.window = null),
                  (this.window_size = 0),
                  (this.prev = null),
                  (this.head = null),
                  (this.ins_h = 0),
                  (this.hash_size = 0),
                  (this.hash_bits = 0),
                  (this.hash_mask = 0),
                  (this.hash_shift = 0),
                  (this.block_start = 0),
                  (this.match_length = 0),
                  (this.prev_match = 0),
                  (this.match_available = 0),
                  (this.strstart = 0),
                  (this.match_start = 0),
                  (this.lookahead = 0),
                  (this.prev_length = 0),
                  (this.max_chain_length = 0),
                  (this.max_lazy_match = 0),
                  (this.level = 0),
                  (this.strategy = 0),
                  (this.good_match = 0),
                  (this.nice_match = 0),
                  (this.dyn_ltree = new a.Buf16(2 * N)),
                  (this.dyn_dtree = new a.Buf16(2 * (2 * x + 1))),
                  (this.bl_tree = new a.Buf16(2 * (2 * D + 1))),
                  se(this.dyn_ltree),
                  se(this.dyn_dtree),
                  se(this.bl_tree),
                  (this.l_desc = null),
                  (this.d_desc = null),
                  (this.bl_desc = null),
                  (this.bl_count = new a.Buf16(I + 1)),
                  (this.heap = new a.Buf16(2 * P + 1)),
                  se(this.heap),
                  (this.heap_len = 0),
                  (this.heap_max = 0),
                  (this.depth = new a.Buf16(2 * P + 1)),
                  se(this.depth),
                  (this.l_buf = 0),
                  (this.lit_bufsize = 0),
                  (this.last_lit = 0),
                  (this.d_buf = 0),
                  (this.opt_len = 0),
                  (this.static_len = 0),
                  (this.matches = 0),
                  (this.insert = 0),
                  (this.bi_buf = 0),
                  (this.bi_valid = 0)
              }
              function De(A) {
                var pe
                return A && A.state
                  ? ((A.total_in = A.total_out = 0),
                    (A.data_type = m),
                    ((pe = A.state).pending = 0),
                    (pe.pending_out = 0),
                    pe.wrap < 0 && (pe.wrap = -pe.wrap),
                    (pe.status = pe.wrap ? C : H),
                    (A.adler = pe.wrap === 2 ? 0 : 1),
                    (pe.last_flush = h),
                    o._tr_init(pe),
                    d)
                  : Te(A, T)
              }
              function Le(A) {
                var pe = De(A)
                return (
                  pe === d &&
                    (function (ie) {
                      ;(ie.window_size = 2 * ie.w_size),
                        se(ie.head),
                        (ie.max_lazy_match = s[ie.level].max_lazy),
                        (ie.good_match = s[ie.level].good_length),
                        (ie.nice_match = s[ie.level].nice_length),
                        (ie.max_chain_length = s[ie.level].max_chain),
                        (ie.strstart = 0),
                        (ie.block_start = 0),
                        (ie.lookahead = 0),
                        (ie.insert = 0),
                        (ie.match_length = ie.prev_length = B - 1),
                        (ie.match_available = 0),
                        (ie.ins_h = 0)
                    })(A.state),
                  pe
                )
              }
              function We(A, pe, ie, L, F, q) {
                if (!A) return T
                var le = 1
                if (
                  (pe === y && (pe = 6),
                  L < 0 ? ((le = 0), (L = -L)) : 15 < L && ((le = 2), (L -= 16)),
                  F < 1 || E < F || ie !== S || L < 8 || 15 < L || pe < 0 || 9 < pe || q < 0 || b < q)
                )
                  return Te(A, T)
                L === 8 && (L = 9)
                var fe = new Pe()
                return (
                  ((A.state = fe).strm = A),
                  (fe.wrap = le),
                  (fe.gzhead = null),
                  (fe.w_bits = L),
                  (fe.w_size = 1 << fe.w_bits),
                  (fe.w_mask = fe.w_size - 1),
                  (fe.hash_bits = F + 7),
                  (fe.hash_size = 1 << fe.hash_bits),
                  (fe.hash_mask = fe.hash_size - 1),
                  (fe.hash_shift = ~~((fe.hash_bits + B - 1) / B)),
                  (fe.window = new a.Buf8(2 * fe.w_size)),
                  (fe.head = new a.Buf16(fe.hash_size)),
                  (fe.prev = new a.Buf16(fe.w_size)),
                  (fe.lit_bufsize = 1 << (F + 6)),
                  (fe.pending_buf_size = 4 * fe.lit_bufsize),
                  (fe.pending_buf = new a.Buf8(fe.pending_buf_size)),
                  (fe.d_buf = 1 * fe.lit_bufsize),
                  (fe.l_buf = 3 * fe.lit_bufsize),
                  (fe.level = pe),
                  (fe.strategy = q),
                  (fe.method = ie),
                  Le(A)
                )
              }
              ;(s = [
                new be(0, 0, 0, 0, function (A, pe) {
                  var ie = 65535
                  for (ie > A.pending_buf_size - 5 && (ie = A.pending_buf_size - 5); ; ) {
                    if (A.lookahead <= 1) {
                      if ((ke(A), A.lookahead === 0 && pe === h)) return w
                      if (A.lookahead === 0) break
                    }
                    ;(A.strstart += A.lookahead), (A.lookahead = 0)
                    var L = A.block_start + ie
                    if (
                      ((A.strstart === 0 || A.strstart >= L) &&
                        ((A.lookahead = A.strstart - L), (A.strstart = L), W(A, !1), A.strm.avail_out === 0)) ||
                      (A.strstart - A.block_start >= A.w_size - Y && (W(A, !1), A.strm.avail_out === 0))
                    )
                      return w
                  }
                  return (
                    (A.insert = 0),
                    pe === f
                      ? (W(A, !0), A.strm.avail_out === 0 ? X : G)
                      : (A.strstart > A.block_start && (W(A, !1), A.strm.avail_out), w)
                  )
                }),
                new be(4, 4, 8, 4, ae),
                new be(4, 5, 16, 8, ae),
                new be(4, 6, 32, 32, ae),
                new be(4, 4, 16, 16, de),
                new be(8, 16, 32, 32, de),
                new be(8, 16, 128, 128, de),
                new be(8, 32, 128, 256, de),
                new be(32, 128, 258, 1024, de),
                new be(32, 258, 258, 4096, de),
              ]),
                (n.deflateInit = function (A, pe) {
                  return We(A, pe, S, 15, 8, 0)
                }),
                (n.deflateInit2 = We),
                (n.deflateReset = Le),
                (n.deflateResetKeep = De),
                (n.deflateSetHeader = function (A, pe) {
                  return A && A.state ? (A.state.wrap !== 2 ? T : ((A.state.gzhead = pe), d)) : T
                }),
                (n.deflate = function (A, pe) {
                  var ie, L, F, q
                  if (!A || !A.state || 5 < pe || pe < 0) return A ? Te(A, T) : T
                  if (((L = A.state), !A.output || (!A.input && A.avail_in !== 0) || (L.status === 666 && pe !== f)))
                    return Te(A, A.avail_out === 0 ? -5 : T)
                  if (((L.strm = A), (ie = L.last_flush), (L.last_flush = pe), L.status === C))
                    if (L.wrap === 2)
                      (A.adler = 0),
                        ge(L, 31),
                        ge(L, 139),
                        ge(L, 8),
                        L.gzhead
                          ? (ge(
                              L,
                              (L.gzhead.text ? 1 : 0) +
                                (L.gzhead.hcrc ? 2 : 0) +
                                (L.gzhead.extra ? 4 : 0) +
                                (L.gzhead.name ? 8 : 0) +
                                (L.gzhead.comment ? 16 : 0)
                            ),
                            ge(L, 255 & L.gzhead.time),
                            ge(L, (L.gzhead.time >> 8) & 255),
                            ge(L, (L.gzhead.time >> 16) & 255),
                            ge(L, (L.gzhead.time >> 24) & 255),
                            ge(L, L.level === 9 ? 2 : 2 <= L.strategy || L.level < 2 ? 4 : 0),
                            ge(L, 255 & L.gzhead.os),
                            L.gzhead.extra &&
                              L.gzhead.extra.length &&
                              (ge(L, 255 & L.gzhead.extra.length), ge(L, (L.gzhead.extra.length >> 8) & 255)),
                            L.gzhead.hcrc && (A.adler = c(A.adler, L.pending_buf, L.pending, 0)),
                            (L.gzindex = 0),
                            (L.status = 69))
                          : (ge(L, 0),
                            ge(L, 0),
                            ge(L, 0),
                            ge(L, 0),
                            ge(L, 0),
                            ge(L, L.level === 9 ? 2 : 2 <= L.strategy || L.level < 2 ? 4 : 0),
                            ge(L, 3),
                            (L.status = H))
                    else {
                      var le = (S + ((L.w_bits - 8) << 4)) << 8
                      ;(le |= (2 <= L.strategy || L.level < 2 ? 0 : L.level < 6 ? 1 : L.level === 6 ? 2 : 3) << 6),
                        L.strstart !== 0 && (le |= 32),
                        (le += 31 - (le % 31)),
                        (L.status = H),
                        ye(L, le),
                        L.strstart !== 0 && (ye(L, A.adler >>> 16), ye(L, 65535 & A.adler)),
                        (A.adler = 1)
                    }
                  if (L.status === 69)
                    if (L.gzhead.extra) {
                      for (
                        F = L.pending;
                        L.gzindex < (65535 & L.gzhead.extra.length) &&
                        (L.pending !== L.pending_buf_size ||
                          (L.gzhead.hcrc && L.pending > F && (A.adler = c(A.adler, L.pending_buf, L.pending - F, F)),
                          U(A),
                          (F = L.pending),
                          L.pending !== L.pending_buf_size));

                      )
                        ge(L, 255 & L.gzhead.extra[L.gzindex]), L.gzindex++
                      L.gzhead.hcrc && L.pending > F && (A.adler = c(A.adler, L.pending_buf, L.pending - F, F)),
                        L.gzindex === L.gzhead.extra.length && ((L.gzindex = 0), (L.status = 73))
                    } else L.status = 73
                  if (L.status === 73)
                    if (L.gzhead.name) {
                      F = L.pending
                      do {
                        if (
                          L.pending === L.pending_buf_size &&
                          (L.gzhead.hcrc && L.pending > F && (A.adler = c(A.adler, L.pending_buf, L.pending - F, F)),
                          U(A),
                          (F = L.pending),
                          L.pending === L.pending_buf_size)
                        ) {
                          q = 1
                          break
                        }
                        ;(q = L.gzindex < L.gzhead.name.length ? 255 & L.gzhead.name.charCodeAt(L.gzindex++) : 0),
                          ge(L, q)
                      } while (q !== 0)
                      L.gzhead.hcrc && L.pending > F && (A.adler = c(A.adler, L.pending_buf, L.pending - F, F)),
                        q === 0 && ((L.gzindex = 0), (L.status = 91))
                    } else L.status = 91
                  if (L.status === 91)
                    if (L.gzhead.comment) {
                      F = L.pending
                      do {
                        if (
                          L.pending === L.pending_buf_size &&
                          (L.gzhead.hcrc && L.pending > F && (A.adler = c(A.adler, L.pending_buf, L.pending - F, F)),
                          U(A),
                          (F = L.pending),
                          L.pending === L.pending_buf_size)
                        ) {
                          q = 1
                          break
                        }
                        ;(q = L.gzindex < L.gzhead.comment.length ? 255 & L.gzhead.comment.charCodeAt(L.gzindex++) : 0),
                          ge(L, q)
                      } while (q !== 0)
                      L.gzhead.hcrc && L.pending > F && (A.adler = c(A.adler, L.pending_buf, L.pending - F, F)),
                        q === 0 && (L.status = 103)
                    } else L.status = 103
                  if (
                    (L.status === 103 &&
                      (L.gzhead.hcrc
                        ? (L.pending + 2 > L.pending_buf_size && U(A),
                          L.pending + 2 <= L.pending_buf_size &&
                            (ge(L, 255 & A.adler), ge(L, (A.adler >> 8) & 255), (A.adler = 0), (L.status = H)))
                        : (L.status = H)),
                    L.pending !== 0)
                  ) {
                    if ((U(A), A.avail_out === 0)) return (L.last_flush = -1), d
                  } else if (A.avail_in === 0 && ce(pe) <= ce(ie) && pe !== f) return Te(A, -5)
                  if (L.status === 666 && A.avail_in !== 0) return Te(A, -5)
                  if (A.avail_in !== 0 || L.lookahead !== 0 || (pe !== h && L.status !== 666)) {
                    var fe =
                      L.strategy === 2
                        ? (function (ne, Se) {
                            for (var xe; ; ) {
                              if (ne.lookahead === 0 && (ke(ne), ne.lookahead === 0)) {
                                if (Se === h) return w
                                break
                              }
                              if (
                                ((ne.match_length = 0),
                                (xe = o._tr_tally(ne, 0, ne.window[ne.strstart])),
                                ne.lookahead--,
                                ne.strstart++,
                                xe && (W(ne, !1), ne.strm.avail_out === 0))
                              )
                                return w
                            }
                            return (
                              (ne.insert = 0),
                              Se === f
                                ? (W(ne, !0), ne.strm.avail_out === 0 ? X : G)
                                : ne.last_lit && (W(ne, !1), ne.strm.avail_out === 0)
                                ? w
                                : J
                            )
                          })(L, pe)
                        : L.strategy === 3
                        ? (function (ne, Se) {
                            for (var xe, Ae, Re, O, g = ne.window; ; ) {
                              if (ne.lookahead <= K) {
                                if ((ke(ne), ne.lookahead <= K && Se === h)) return w
                                if (ne.lookahead === 0) break
                              }
                              if (
                                ((ne.match_length = 0),
                                ne.lookahead >= B &&
                                  0 < ne.strstart &&
                                  (Ae = g[(Re = ne.strstart - 1)]) === g[++Re] &&
                                  Ae === g[++Re] &&
                                  Ae === g[++Re])
                              ) {
                                O = ne.strstart + K
                                do;
                                while (
                                  Ae === g[++Re] &&
                                  Ae === g[++Re] &&
                                  Ae === g[++Re] &&
                                  Ae === g[++Re] &&
                                  Ae === g[++Re] &&
                                  Ae === g[++Re] &&
                                  Ae === g[++Re] &&
                                  Ae === g[++Re] &&
                                  Re < O
                                )
                                ;(ne.match_length = K - (O - Re)),
                                  ne.match_length > ne.lookahead && (ne.match_length = ne.lookahead)
                              }
                              if (
                                (ne.match_length >= B
                                  ? ((xe = o._tr_tally(ne, 1, ne.match_length - B)),
                                    (ne.lookahead -= ne.match_length),
                                    (ne.strstart += ne.match_length),
                                    (ne.match_length = 0))
                                  : ((xe = o._tr_tally(ne, 0, ne.window[ne.strstart])), ne.lookahead--, ne.strstart++),
                                xe && (W(ne, !1), ne.strm.avail_out === 0))
                              )
                                return w
                            }
                            return (
                              (ne.insert = 0),
                              Se === f
                                ? (W(ne, !0), ne.strm.avail_out === 0 ? X : G)
                                : ne.last_lit && (W(ne, !1), ne.strm.avail_out === 0)
                                ? w
                                : J
                            )
                          })(L, pe)
                        : s[L.level].func(L, pe)
                    if (((fe !== X && fe !== G) || (L.status = 666), fe === w || fe === X))
                      return A.avail_out === 0 && (L.last_flush = -1), d
                    if (
                      fe === J &&
                      (pe === 1
                        ? o._tr_align(L)
                        : pe !== 5 &&
                          (o._tr_stored_block(L, 0, 0, !1),
                          pe === 3 &&
                            (se(L.head), L.lookahead === 0 && ((L.strstart = 0), (L.block_start = 0), (L.insert = 0)))),
                      U(A),
                      A.avail_out === 0)
                    )
                      return (L.last_flush = -1), d
                  }
                  return pe !== f
                    ? d
                    : L.wrap <= 0
                    ? 1
                    : (L.wrap === 2
                        ? (ge(L, 255 & A.adler),
                          ge(L, (A.adler >> 8) & 255),
                          ge(L, (A.adler >> 16) & 255),
                          ge(L, (A.adler >> 24) & 255),
                          ge(L, 255 & A.total_in),
                          ge(L, (A.total_in >> 8) & 255),
                          ge(L, (A.total_in >> 16) & 255),
                          ge(L, (A.total_in >> 24) & 255))
                        : (ye(L, A.adler >>> 16), ye(L, 65535 & A.adler)),
                      U(A),
                      0 < L.wrap && (L.wrap = -L.wrap),
                      L.pending !== 0 ? d : 1)
                }),
                (n.deflateEnd = function (A) {
                  var pe
                  return A && A.state
                    ? (pe = A.state.status) !== C &&
                      pe !== 69 &&
                      pe !== 73 &&
                      pe !== 91 &&
                      pe !== 103 &&
                      pe !== H &&
                      pe !== 666
                      ? Te(A, T)
                      : ((A.state = null), pe === H ? Te(A, -3) : d)
                    : T
                }),
                (n.deflateSetDictionary = function (A, pe) {
                  var ie,
                    L,
                    F,
                    q,
                    le,
                    fe,
                    ne,
                    Se,
                    xe = pe.length
                  if (!A || !A.state || (q = (ie = A.state).wrap) === 2 || (q === 1 && ie.status !== C) || ie.lookahead)
                    return T
                  for (
                    q === 1 && (A.adler = u(A.adler, pe, xe, 0)),
                      ie.wrap = 0,
                      xe >= ie.w_size &&
                        (q === 0 && (se(ie.head), (ie.strstart = 0), (ie.block_start = 0), (ie.insert = 0)),
                        (Se = new a.Buf8(ie.w_size)),
                        a.arraySet(Se, pe, xe - ie.w_size, ie.w_size, 0),
                        (pe = Se),
                        (xe = ie.w_size)),
                      le = A.avail_in,
                      fe = A.next_in,
                      ne = A.input,
                      A.avail_in = xe,
                      A.next_in = 0,
                      A.input = pe,
                      ke(ie);
                    ie.lookahead >= B;

                  ) {
                    for (
                      L = ie.strstart, F = ie.lookahead - (B - 1);
                      (ie.ins_h = ((ie.ins_h << ie.hash_shift) ^ ie.window[L + B - 1]) & ie.hash_mask),
                        (ie.prev[L & ie.w_mask] = ie.head[ie.ins_h]),
                        (ie.head[ie.ins_h] = L),
                        L++,
                        --F;

                    );
                    ;(ie.strstart = L), (ie.lookahead = B - 1), ke(ie)
                  }
                  return (
                    (ie.strstart += ie.lookahead),
                    (ie.block_start = ie.strstart),
                    (ie.insert = ie.lookahead),
                    (ie.lookahead = 0),
                    (ie.match_length = ie.prev_length = B - 1),
                    (ie.match_available = 0),
                    (A.next_in = fe),
                    (A.input = ne),
                    (A.avail_in = le),
                    (ie.wrap = q),
                    d
                  )
                }),
                (n.deflateInfo = 'pako deflate (from Nodeca project)')
            },
            { '../utils/common': 41, './adler32': 43, './crc32': 45, './messages': 51, './trees': 52 },
          ],
          47: [
            function (r, i, n) {
              i.exports = function () {
                ;(this.text = 0),
                  (this.time = 0),
                  (this.xflags = 0),
                  (this.os = 0),
                  (this.extra = null),
                  (this.extra_len = 0),
                  (this.name = ''),
                  (this.comment = ''),
                  (this.hcrc = 0),
                  (this.done = !1)
              }
            },
            {},
          ],
          48: [
            function (r, i, n) {
              i.exports = function (s, a) {
                var o, u, c, p, h, f, d, T, y, b, m, S, E, P, x, D, N, I, B, K, Y, C, H, w, J
                ;(o = s.state),
                  (u = s.next_in),
                  (w = s.input),
                  (c = u + (s.avail_in - 5)),
                  (p = s.next_out),
                  (J = s.output),
                  (h = p - (a - s.avail_out)),
                  (f = p + (s.avail_out - 257)),
                  (d = o.dmax),
                  (T = o.wsize),
                  (y = o.whave),
                  (b = o.wnext),
                  (m = o.window),
                  (S = o.hold),
                  (E = o.bits),
                  (P = o.lencode),
                  (x = o.distcode),
                  (D = (1 << o.lenbits) - 1),
                  (N = (1 << o.distbits) - 1)
                e: do {
                  E < 15 && ((S += w[u++] << E), (E += 8), (S += w[u++] << E), (E += 8)), (I = P[S & D])
                  t: for (;;) {
                    if (((S >>>= B = I >>> 24), (E -= B), (B = (I >>> 16) & 255) === 0)) J[p++] = 65535 & I
                    else {
                      if (!(16 & B)) {
                        if ((64 & B) == 0) {
                          I = P[(65535 & I) + (S & ((1 << B) - 1))]
                          continue t
                        }
                        if (32 & B) {
                          o.mode = 12
                          break e
                        }
                        ;(s.msg = 'invalid literal/length code'), (o.mode = 30)
                        break e
                      }
                      ;(K = 65535 & I),
                        (B &= 15) &&
                          (E < B && ((S += w[u++] << E), (E += 8)), (K += S & ((1 << B) - 1)), (S >>>= B), (E -= B)),
                        E < 15 && ((S += w[u++] << E), (E += 8), (S += w[u++] << E), (E += 8)),
                        (I = x[S & N])
                      r: for (;;) {
                        if (((S >>>= B = I >>> 24), (E -= B), !(16 & (B = (I >>> 16) & 255)))) {
                          if ((64 & B) == 0) {
                            I = x[(65535 & I) + (S & ((1 << B) - 1))]
                            continue r
                          }
                          ;(s.msg = 'invalid distance code'), (o.mode = 30)
                          break e
                        }
                        if (
                          ((Y = 65535 & I),
                          E < (B &= 15) && ((S += w[u++] << E), (E += 8) < B && ((S += w[u++] << E), (E += 8))),
                          d < (Y += S & ((1 << B) - 1)))
                        ) {
                          ;(s.msg = 'invalid distance too far back'), (o.mode = 30)
                          break e
                        }
                        if (((S >>>= B), (E -= B), (B = p - h) < Y)) {
                          if (y < (B = Y - B) && o.sane) {
                            ;(s.msg = 'invalid distance too far back'), (o.mode = 30)
                            break e
                          }
                          if (((H = m), (C = 0) === b)) {
                            if (((C += T - B), B < K)) {
                              for (K -= B; (J[p++] = m[C++]), --B; );
                              ;(C = p - Y), (H = J)
                            }
                          } else if (b < B) {
                            if (((C += T + b - B), (B -= b) < K)) {
                              for (K -= B; (J[p++] = m[C++]), --B; );
                              if (((C = 0), b < K)) {
                                for (K -= B = b; (J[p++] = m[C++]), --B; );
                                ;(C = p - Y), (H = J)
                              }
                            }
                          } else if (((C += b - B), B < K)) {
                            for (K -= B; (J[p++] = m[C++]), --B; );
                            ;(C = p - Y), (H = J)
                          }
                          for (; 2 < K; ) (J[p++] = H[C++]), (J[p++] = H[C++]), (J[p++] = H[C++]), (K -= 3)
                          K && ((J[p++] = H[C++]), 1 < K && (J[p++] = H[C++]))
                        } else {
                          for (C = p - Y; (J[p++] = J[C++]), (J[p++] = J[C++]), (J[p++] = J[C++]), 2 < (K -= 3); );
                          K && ((J[p++] = J[C++]), 1 < K && (J[p++] = J[C++]))
                        }
                        break
                      }
                    }
                    break
                  }
                } while (u < c && p < f)
                ;(u -= K = E >> 3),
                  (S &= (1 << (E -= K << 3)) - 1),
                  (s.next_in = u),
                  (s.next_out = p),
                  (s.avail_in = u < c ? c - u + 5 : 5 - (u - c)),
                  (s.avail_out = p < f ? f - p + 257 : 257 - (p - f)),
                  (o.hold = S),
                  (o.bits = E)
              }
            },
            {},
          ],
          49: [
            function (r, i, n) {
              var s = r('../utils/common'),
                a = r('./adler32'),
                o = r('./crc32'),
                u = r('./inffast'),
                c = r('./inftrees'),
                p = 1,
                h = 2,
                f = 0,
                d = -2,
                T = 1,
                y = 852,
                b = 592
              function m(C) {
                return ((C >>> 24) & 255) + ((C >>> 8) & 65280) + ((65280 & C) << 8) + ((255 & C) << 24)
              }
              function S() {
                ;(this.mode = 0),
                  (this.last = !1),
                  (this.wrap = 0),
                  (this.havedict = !1),
                  (this.flags = 0),
                  (this.dmax = 0),
                  (this.check = 0),
                  (this.total = 0),
                  (this.head = null),
                  (this.wbits = 0),
                  (this.wsize = 0),
                  (this.whave = 0),
                  (this.wnext = 0),
                  (this.window = null),
                  (this.hold = 0),
                  (this.bits = 0),
                  (this.length = 0),
                  (this.offset = 0),
                  (this.extra = 0),
                  (this.lencode = null),
                  (this.distcode = null),
                  (this.lenbits = 0),
                  (this.distbits = 0),
                  (this.ncode = 0),
                  (this.nlen = 0),
                  (this.ndist = 0),
                  (this.have = 0),
                  (this.next = null),
                  (this.lens = new s.Buf16(320)),
                  (this.work = new s.Buf16(288)),
                  (this.lendyn = null),
                  (this.distdyn = null),
                  (this.sane = 0),
                  (this.back = 0),
                  (this.was = 0)
              }
              function E(C) {
                var H
                return C && C.state
                  ? ((H = C.state),
                    (C.total_in = C.total_out = H.total = 0),
                    (C.msg = ''),
                    H.wrap && (C.adler = 1 & H.wrap),
                    (H.mode = T),
                    (H.last = 0),
                    (H.havedict = 0),
                    (H.dmax = 32768),
                    (H.head = null),
                    (H.hold = 0),
                    (H.bits = 0),
                    (H.lencode = H.lendyn = new s.Buf32(y)),
                    (H.distcode = H.distdyn = new s.Buf32(b)),
                    (H.sane = 1),
                    (H.back = -1),
                    f)
                  : d
              }
              function P(C) {
                var H
                return C && C.state ? (((H = C.state).wsize = 0), (H.whave = 0), (H.wnext = 0), E(C)) : d
              }
              function x(C, H) {
                var w, J
                return C && C.state
                  ? ((J = C.state),
                    H < 0 ? ((w = 0), (H = -H)) : ((w = 1 + (H >> 4)), H < 48 && (H &= 15)),
                    H && (H < 8 || 15 < H)
                      ? d
                      : (J.window !== null && J.wbits !== H && (J.window = null), (J.wrap = w), (J.wbits = H), P(C)))
                  : d
              }
              function D(C, H) {
                var w, J
                return C
                  ? ((J = new S()), ((C.state = J).window = null), (w = x(C, H)) !== f && (C.state = null), w)
                  : d
              }
              var N,
                I,
                B = !0
              function K(C) {
                if (B) {
                  var H
                  for (N = new s.Buf32(512), I = new s.Buf32(32), H = 0; H < 144; ) C.lens[H++] = 8
                  for (; H < 256; ) C.lens[H++] = 9
                  for (; H < 280; ) C.lens[H++] = 7
                  for (; H < 288; ) C.lens[H++] = 8
                  for (c(p, C.lens, 0, 288, N, 0, C.work, { bits: 9 }), H = 0; H < 32; ) C.lens[H++] = 5
                  c(h, C.lens, 0, 32, I, 0, C.work, { bits: 5 }), (B = !1)
                }
                ;(C.lencode = N), (C.lenbits = 9), (C.distcode = I), (C.distbits = 5)
              }
              function Y(C, H, w, J) {
                var X,
                  G = C.state
                return (
                  G.window === null &&
                    ((G.wsize = 1 << G.wbits), (G.wnext = 0), (G.whave = 0), (G.window = new s.Buf8(G.wsize))),
                  J >= G.wsize
                    ? (s.arraySet(G.window, H, w - G.wsize, G.wsize, 0), (G.wnext = 0), (G.whave = G.wsize))
                    : (J < (X = G.wsize - G.wnext) && (X = J),
                      s.arraySet(G.window, H, w - J, X, G.wnext),
                      (J -= X)
                        ? (s.arraySet(G.window, H, w - J, J, 0), (G.wnext = J), (G.whave = G.wsize))
                        : ((G.wnext += X), G.wnext === G.wsize && (G.wnext = 0), G.whave < G.wsize && (G.whave += X))),
                  0
                )
              }
              ;(n.inflateReset = P),
                (n.inflateReset2 = x),
                (n.inflateResetKeep = E),
                (n.inflateInit = function (C) {
                  return D(C, 15)
                }),
                (n.inflateInit2 = D),
                (n.inflate = function (C, H) {
                  var w,
                    J,
                    X,
                    G,
                    Te,
                    ce,
                    se,
                    U,
                    W,
                    ge,
                    ye,
                    me,
                    ke,
                    ae,
                    de,
                    be,
                    Pe,
                    De,
                    Le,
                    We,
                    A,
                    pe,
                    ie,
                    L,
                    F = 0,
                    q = new s.Buf8(4),
                    le = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
                  if (!C || !C.state || !C.output || (!C.input && C.avail_in !== 0)) return d
                  ;(w = C.state).mode === 12 && (w.mode = 13),
                    (Te = C.next_out),
                    (X = C.output),
                    (se = C.avail_out),
                    (G = C.next_in),
                    (J = C.input),
                    (ce = C.avail_in),
                    (U = w.hold),
                    (W = w.bits),
                    (ge = ce),
                    (ye = se),
                    (pe = f)
                  e: for (;;)
                    switch (w.mode) {
                      case T:
                        if (w.wrap === 0) {
                          w.mode = 13
                          break
                        }
                        for (; W < 16; ) {
                          if (ce === 0) break e
                          ce--, (U += J[G++] << W), (W += 8)
                        }
                        if (2 & w.wrap && U === 35615) {
                          ;(q[(w.check = 0)] = 255 & U),
                            (q[1] = (U >>> 8) & 255),
                            (w.check = o(w.check, q, 2, 0)),
                            (W = U = 0),
                            (w.mode = 2)
                          break
                        }
                        if (
                          ((w.flags = 0),
                          w.head && (w.head.done = !1),
                          !(1 & w.wrap) || (((255 & U) << 8) + (U >> 8)) % 31)
                        ) {
                          ;(C.msg = 'incorrect header check'), (w.mode = 30)
                          break
                        }
                        if ((15 & U) != 8) {
                          ;(C.msg = 'unknown compression method'), (w.mode = 30)
                          break
                        }
                        if (((W -= 4), (A = 8 + (15 & (U >>>= 4))), w.wbits === 0)) w.wbits = A
                        else if (A > w.wbits) {
                          ;(C.msg = 'invalid window size'), (w.mode = 30)
                          break
                        }
                        ;(w.dmax = 1 << A), (C.adler = w.check = 1), (w.mode = 512 & U ? 10 : 12), (W = U = 0)
                        break
                      case 2:
                        for (; W < 16; ) {
                          if (ce === 0) break e
                          ce--, (U += J[G++] << W), (W += 8)
                        }
                        if (((w.flags = U), (255 & w.flags) != 8)) {
                          ;(C.msg = 'unknown compression method'), (w.mode = 30)
                          break
                        }
                        if (57344 & w.flags) {
                          ;(C.msg = 'unknown header flags set'), (w.mode = 30)
                          break
                        }
                        w.head && (w.head.text = (U >> 8) & 1),
                          512 & w.flags &&
                            ((q[0] = 255 & U), (q[1] = (U >>> 8) & 255), (w.check = o(w.check, q, 2, 0))),
                          (W = U = 0),
                          (w.mode = 3)
                      case 3:
                        for (; W < 32; ) {
                          if (ce === 0) break e
                          ce--, (U += J[G++] << W), (W += 8)
                        }
                        w.head && (w.head.time = U),
                          512 & w.flags &&
                            ((q[0] = 255 & U),
                            (q[1] = (U >>> 8) & 255),
                            (q[2] = (U >>> 16) & 255),
                            (q[3] = (U >>> 24) & 255),
                            (w.check = o(w.check, q, 4, 0))),
                          (W = U = 0),
                          (w.mode = 4)
                      case 4:
                        for (; W < 16; ) {
                          if (ce === 0) break e
                          ce--, (U += J[G++] << W), (W += 8)
                        }
                        w.head && ((w.head.xflags = 255 & U), (w.head.os = U >> 8)),
                          512 & w.flags &&
                            ((q[0] = 255 & U), (q[1] = (U >>> 8) & 255), (w.check = o(w.check, q, 2, 0))),
                          (W = U = 0),
                          (w.mode = 5)
                      case 5:
                        if (1024 & w.flags) {
                          for (; W < 16; ) {
                            if (ce === 0) break e
                            ce--, (U += J[G++] << W), (W += 8)
                          }
                          ;(w.length = U),
                            w.head && (w.head.extra_len = U),
                            512 & w.flags &&
                              ((q[0] = 255 & U), (q[1] = (U >>> 8) & 255), (w.check = o(w.check, q, 2, 0))),
                            (W = U = 0)
                        } else w.head && (w.head.extra = null)
                        w.mode = 6
                      case 6:
                        if (
                          1024 & w.flags &&
                          (ce < (me = w.length) && (me = ce),
                          me &&
                            (w.head &&
                              ((A = w.head.extra_len - w.length),
                              w.head.extra || (w.head.extra = new Array(w.head.extra_len)),
                              s.arraySet(w.head.extra, J, G, me, A)),
                            512 & w.flags && (w.check = o(w.check, J, me, G)),
                            (ce -= me),
                            (G += me),
                            (w.length -= me)),
                          w.length)
                        )
                          break e
                        ;(w.length = 0), (w.mode = 7)
                      case 7:
                        if (2048 & w.flags) {
                          if (ce === 0) break e
                          for (
                            me = 0;
                            (A = J[G + me++]),
                              w.head && A && w.length < 65536 && (w.head.name += String.fromCharCode(A)),
                              A && me < ce;

                          );
                          if ((512 & w.flags && (w.check = o(w.check, J, me, G)), (ce -= me), (G += me), A)) break e
                        } else w.head && (w.head.name = null)
                        ;(w.length = 0), (w.mode = 8)
                      case 8:
                        if (4096 & w.flags) {
                          if (ce === 0) break e
                          for (
                            me = 0;
                            (A = J[G + me++]),
                              w.head && A && w.length < 65536 && (w.head.comment += String.fromCharCode(A)),
                              A && me < ce;

                          );
                          if ((512 & w.flags && (w.check = o(w.check, J, me, G)), (ce -= me), (G += me), A)) break e
                        } else w.head && (w.head.comment = null)
                        w.mode = 9
                      case 9:
                        if (512 & w.flags) {
                          for (; W < 16; ) {
                            if (ce === 0) break e
                            ce--, (U += J[G++] << W), (W += 8)
                          }
                          if (U !== (65535 & w.check)) {
                            ;(C.msg = 'header crc mismatch'), (w.mode = 30)
                            break
                          }
                          W = U = 0
                        }
                        w.head && ((w.head.hcrc = (w.flags >> 9) & 1), (w.head.done = !0)),
                          (C.adler = w.check = 0),
                          (w.mode = 12)
                        break
                      case 10:
                        for (; W < 32; ) {
                          if (ce === 0) break e
                          ce--, (U += J[G++] << W), (W += 8)
                        }
                        ;(C.adler = w.check = m(U)), (W = U = 0), (w.mode = 11)
                      case 11:
                        if (w.havedict === 0)
                          return (
                            (C.next_out = Te),
                            (C.avail_out = se),
                            (C.next_in = G),
                            (C.avail_in = ce),
                            (w.hold = U),
                            (w.bits = W),
                            2
                          )
                        ;(C.adler = w.check = 1), (w.mode = 12)
                      case 12:
                        if (H === 5 || H === 6) break e
                      case 13:
                        if (w.last) {
                          ;(U >>>= 7 & W), (W -= 7 & W), (w.mode = 27)
                          break
                        }
                        for (; W < 3; ) {
                          if (ce === 0) break e
                          ce--, (U += J[G++] << W), (W += 8)
                        }
                        switch (((w.last = 1 & U), (W -= 1), 3 & (U >>>= 1))) {
                          case 0:
                            w.mode = 14
                            break
                          case 1:
                            if ((K(w), (w.mode = 20), H !== 6)) break
                            ;(U >>>= 2), (W -= 2)
                            break e
                          case 2:
                            w.mode = 17
                            break
                          case 3:
                            ;(C.msg = 'invalid block type'), (w.mode = 30)
                        }
                        ;(U >>>= 2), (W -= 2)
                        break
                      case 14:
                        for (U >>>= 7 & W, W -= 7 & W; W < 32; ) {
                          if (ce === 0) break e
                          ce--, (U += J[G++] << W), (W += 8)
                        }
                        if ((65535 & U) != ((U >>> 16) ^ 65535)) {
                          ;(C.msg = 'invalid stored block lengths'), (w.mode = 30)
                          break
                        }
                        if (((w.length = 65535 & U), (W = U = 0), (w.mode = 15), H === 6)) break e
                      case 15:
                        w.mode = 16
                      case 16:
                        if ((me = w.length)) {
                          if ((ce < me && (me = ce), se < me && (me = se), me === 0)) break e
                          s.arraySet(X, J, G, me, Te), (ce -= me), (G += me), (se -= me), (Te += me), (w.length -= me)
                          break
                        }
                        w.mode = 12
                        break
                      case 17:
                        for (; W < 14; ) {
                          if (ce === 0) break e
                          ce--, (U += J[G++] << W), (W += 8)
                        }
                        if (
                          ((w.nlen = 257 + (31 & U)),
                          (U >>>= 5),
                          (W -= 5),
                          (w.ndist = 1 + (31 & U)),
                          (U >>>= 5),
                          (W -= 5),
                          (w.ncode = 4 + (15 & U)),
                          (U >>>= 4),
                          (W -= 4),
                          286 < w.nlen || 30 < w.ndist)
                        ) {
                          ;(C.msg = 'too many length or distance symbols'), (w.mode = 30)
                          break
                        }
                        ;(w.have = 0), (w.mode = 18)
                      case 18:
                        for (; w.have < w.ncode; ) {
                          for (; W < 3; ) {
                            if (ce === 0) break e
                            ce--, (U += J[G++] << W), (W += 8)
                          }
                          ;(w.lens[le[w.have++]] = 7 & U), (U >>>= 3), (W -= 3)
                        }
                        for (; w.have < 19; ) w.lens[le[w.have++]] = 0
                        if (
                          ((w.lencode = w.lendyn),
                          (w.lenbits = 7),
                          (ie = { bits: w.lenbits }),
                          (pe = c(0, w.lens, 0, 19, w.lencode, 0, w.work, ie)),
                          (w.lenbits = ie.bits),
                          pe)
                        ) {
                          ;(C.msg = 'invalid code lengths set'), (w.mode = 30)
                          break
                        }
                        ;(w.have = 0), (w.mode = 19)
                      case 19:
                        for (; w.have < w.nlen + w.ndist; ) {
                          for (
                            ;
                            (be = ((F = w.lencode[U & ((1 << w.lenbits) - 1)]) >>> 16) & 255),
                              (Pe = 65535 & F),
                              !((de = F >>> 24) <= W);

                          ) {
                            if (ce === 0) break e
                            ce--, (U += J[G++] << W), (W += 8)
                          }
                          if (Pe < 16) (U >>>= de), (W -= de), (w.lens[w.have++] = Pe)
                          else {
                            if (Pe === 16) {
                              for (L = de + 2; W < L; ) {
                                if (ce === 0) break e
                                ce--, (U += J[G++] << W), (W += 8)
                              }
                              if (((U >>>= de), (W -= de), w.have === 0)) {
                                ;(C.msg = 'invalid bit length repeat'), (w.mode = 30)
                                break
                              }
                              ;(A = w.lens[w.have - 1]), (me = 3 + (3 & U)), (U >>>= 2), (W -= 2)
                            } else if (Pe === 17) {
                              for (L = de + 3; W < L; ) {
                                if (ce === 0) break e
                                ce--, (U += J[G++] << W), (W += 8)
                              }
                              ;(W -= de), (A = 0), (me = 3 + (7 & (U >>>= de))), (U >>>= 3), (W -= 3)
                            } else {
                              for (L = de + 7; W < L; ) {
                                if (ce === 0) break e
                                ce--, (U += J[G++] << W), (W += 8)
                              }
                              ;(W -= de), (A = 0), (me = 11 + (127 & (U >>>= de))), (U >>>= 7), (W -= 7)
                            }
                            if (w.have + me > w.nlen + w.ndist) {
                              ;(C.msg = 'invalid bit length repeat'), (w.mode = 30)
                              break
                            }
                            for (; me--; ) w.lens[w.have++] = A
                          }
                        }
                        if (w.mode === 30) break
                        if (w.lens[256] === 0) {
                          ;(C.msg = 'invalid code -- missing end-of-block'), (w.mode = 30)
                          break
                        }
                        if (
                          ((w.lenbits = 9),
                          (ie = { bits: w.lenbits }),
                          (pe = c(p, w.lens, 0, w.nlen, w.lencode, 0, w.work, ie)),
                          (w.lenbits = ie.bits),
                          pe)
                        ) {
                          ;(C.msg = 'invalid literal/lengths set'), (w.mode = 30)
                          break
                        }
                        if (
                          ((w.distbits = 6),
                          (w.distcode = w.distdyn),
                          (ie = { bits: w.distbits }),
                          (pe = c(h, w.lens, w.nlen, w.ndist, w.distcode, 0, w.work, ie)),
                          (w.distbits = ie.bits),
                          pe)
                        ) {
                          ;(C.msg = 'invalid distances set'), (w.mode = 30)
                          break
                        }
                        if (((w.mode = 20), H === 6)) break e
                      case 20:
                        w.mode = 21
                      case 21:
                        if (6 <= ce && 258 <= se) {
                          ;(C.next_out = Te),
                            (C.avail_out = se),
                            (C.next_in = G),
                            (C.avail_in = ce),
                            (w.hold = U),
                            (w.bits = W),
                            u(C, ye),
                            (Te = C.next_out),
                            (X = C.output),
                            (se = C.avail_out),
                            (G = C.next_in),
                            (J = C.input),
                            (ce = C.avail_in),
                            (U = w.hold),
                            (W = w.bits),
                            w.mode === 12 && (w.back = -1)
                          break
                        }
                        for (
                          w.back = 0;
                          (be = ((F = w.lencode[U & ((1 << w.lenbits) - 1)]) >>> 16) & 255),
                            (Pe = 65535 & F),
                            !((de = F >>> 24) <= W);

                        ) {
                          if (ce === 0) break e
                          ce--, (U += J[G++] << W), (W += 8)
                        }
                        if (be && (240 & be) == 0) {
                          for (
                            De = de, Le = be, We = Pe;
                            (be = ((F = w.lencode[We + ((U & ((1 << (De + Le)) - 1)) >> De)]) >>> 16) & 255),
                              (Pe = 65535 & F),
                              !(De + (de = F >>> 24) <= W);

                          ) {
                            if (ce === 0) break e
                            ce--, (U += J[G++] << W), (W += 8)
                          }
                          ;(U >>>= De), (W -= De), (w.back += De)
                        }
                        if (((U >>>= de), (W -= de), (w.back += de), (w.length = Pe), be === 0)) {
                          w.mode = 26
                          break
                        }
                        if (32 & be) {
                          ;(w.back = -1), (w.mode = 12)
                          break
                        }
                        if (64 & be) {
                          ;(C.msg = 'invalid literal/length code'), (w.mode = 30)
                          break
                        }
                        ;(w.extra = 15 & be), (w.mode = 22)
                      case 22:
                        if (w.extra) {
                          for (L = w.extra; W < L; ) {
                            if (ce === 0) break e
                            ce--, (U += J[G++] << W), (W += 8)
                          }
                          ;(w.length += U & ((1 << w.extra) - 1)), (U >>>= w.extra), (W -= w.extra), (w.back += w.extra)
                        }
                        ;(w.was = w.length), (w.mode = 23)
                      case 23:
                        for (
                          ;
                          (be = ((F = w.distcode[U & ((1 << w.distbits) - 1)]) >>> 16) & 255),
                            (Pe = 65535 & F),
                            !((de = F >>> 24) <= W);

                        ) {
                          if (ce === 0) break e
                          ce--, (U += J[G++] << W), (W += 8)
                        }
                        if ((240 & be) == 0) {
                          for (
                            De = de, Le = be, We = Pe;
                            (be = ((F = w.distcode[We + ((U & ((1 << (De + Le)) - 1)) >> De)]) >>> 16) & 255),
                              (Pe = 65535 & F),
                              !(De + (de = F >>> 24) <= W);

                          ) {
                            if (ce === 0) break e
                            ce--, (U += J[G++] << W), (W += 8)
                          }
                          ;(U >>>= De), (W -= De), (w.back += De)
                        }
                        if (((U >>>= de), (W -= de), (w.back += de), 64 & be)) {
                          ;(C.msg = 'invalid distance code'), (w.mode = 30)
                          break
                        }
                        ;(w.offset = Pe), (w.extra = 15 & be), (w.mode = 24)
                      case 24:
                        if (w.extra) {
                          for (L = w.extra; W < L; ) {
                            if (ce === 0) break e
                            ce--, (U += J[G++] << W), (W += 8)
                          }
                          ;(w.offset += U & ((1 << w.extra) - 1)), (U >>>= w.extra), (W -= w.extra), (w.back += w.extra)
                        }
                        if (w.offset > w.dmax) {
                          ;(C.msg = 'invalid distance too far back'), (w.mode = 30)
                          break
                        }
                        w.mode = 25
                      case 25:
                        if (se === 0) break e
                        if (((me = ye - se), w.offset > me)) {
                          if ((me = w.offset - me) > w.whave && w.sane) {
                            ;(C.msg = 'invalid distance too far back'), (w.mode = 30)
                            break
                          }
                          ;(ke = me > w.wnext ? ((me -= w.wnext), w.wsize - me) : w.wnext - me),
                            me > w.length && (me = w.length),
                            (ae = w.window)
                        } else (ae = X), (ke = Te - w.offset), (me = w.length)
                        for (se < me && (me = se), se -= me, w.length -= me; (X[Te++] = ae[ke++]), --me; );
                        w.length === 0 && (w.mode = 21)
                        break
                      case 26:
                        if (se === 0) break e
                        ;(X[Te++] = w.length), se--, (w.mode = 21)
                        break
                      case 27:
                        if (w.wrap) {
                          for (; W < 32; ) {
                            if (ce === 0) break e
                            ce--, (U |= J[G++] << W), (W += 8)
                          }
                          if (
                            ((ye -= se),
                            (C.total_out += ye),
                            (w.total += ye),
                            ye &&
                              (C.adler = w.check = w.flags ? o(w.check, X, ye, Te - ye) : a(w.check, X, ye, Te - ye)),
                            (ye = se),
                            (w.flags ? U : m(U)) !== w.check)
                          ) {
                            ;(C.msg = 'incorrect data check'), (w.mode = 30)
                            break
                          }
                          W = U = 0
                        }
                        w.mode = 28
                      case 28:
                        if (w.wrap && w.flags) {
                          for (; W < 32; ) {
                            if (ce === 0) break e
                            ce--, (U += J[G++] << W), (W += 8)
                          }
                          if (U !== (4294967295 & w.total)) {
                            ;(C.msg = 'incorrect length check'), (w.mode = 30)
                            break
                          }
                          W = U = 0
                        }
                        w.mode = 29
                      case 29:
                        pe = 1
                        break e
                      case 30:
                        pe = -3
                        break e
                      case 31:
                        return -4
                      case 32:
                      default:
                        return d
                    }
                  return (
                    (C.next_out = Te),
                    (C.avail_out = se),
                    (C.next_in = G),
                    (C.avail_in = ce),
                    (w.hold = U),
                    (w.bits = W),
                    (w.wsize || (ye !== C.avail_out && w.mode < 30 && (w.mode < 27 || H !== 4))) &&
                    Y(C, C.output, C.next_out, ye - C.avail_out)
                      ? ((w.mode = 31), -4)
                      : ((ge -= C.avail_in),
                        (ye -= C.avail_out),
                        (C.total_in += ge),
                        (C.total_out += ye),
                        (w.total += ye),
                        w.wrap &&
                          ye &&
                          (C.adler = w.check =
                            w.flags ? o(w.check, X, ye, C.next_out - ye) : a(w.check, X, ye, C.next_out - ye)),
                        (C.data_type =
                          w.bits +
                          (w.last ? 64 : 0) +
                          (w.mode === 12 ? 128 : 0) +
                          (w.mode === 20 || w.mode === 15 ? 256 : 0)),
                        ((ge == 0 && ye === 0) || H === 4) && pe === f && (pe = -5),
                        pe)
                  )
                }),
                (n.inflateEnd = function (C) {
                  if (!C || !C.state) return d
                  var H = C.state
                  return H.window && (H.window = null), (C.state = null), f
                }),
                (n.inflateGetHeader = function (C, H) {
                  var w
                  return C && C.state ? ((2 & (w = C.state).wrap) == 0 ? d : (((w.head = H).done = !1), f)) : d
                }),
                (n.inflateSetDictionary = function (C, H) {
                  var w,
                    J = H.length
                  return C && C.state
                    ? (w = C.state).wrap !== 0 && w.mode !== 11
                      ? d
                      : w.mode === 11 && a(1, H, J, 0) !== w.check
                      ? -3
                      : Y(C, H, J, J)
                      ? ((w.mode = 31), -4)
                      : ((w.havedict = 1), f)
                    : d
                }),
                (n.inflateInfo = 'pako inflate (from Nodeca project)')
            },
            { '../utils/common': 41, './adler32': 43, './crc32': 45, './inffast': 48, './inftrees': 50 },
          ],
          50: [
            function (r, i, n) {
              var s = r('../utils/common'),
                a = [
                  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163,
                  195, 227, 258, 0, 0,
                ],
                o = [
                  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21,
                  21, 21, 21, 16, 72, 78,
                ],
                u = [
                  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073,
                  4097, 6145, 8193, 12289, 16385, 24577, 0, 0,
                ],
                c = [
                  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27,
                  27, 28, 28, 29, 29, 64, 64,
                ]
              i.exports = function (p, h, f, d, T, y, b, m) {
                var S,
                  E,
                  P,
                  x,
                  D,
                  N,
                  I,
                  B,
                  K,
                  Y = m.bits,
                  C = 0,
                  H = 0,
                  w = 0,
                  J = 0,
                  X = 0,
                  G = 0,
                  Te = 0,
                  ce = 0,
                  se = 0,
                  U = 0,
                  W = null,
                  ge = 0,
                  ye = new s.Buf16(16),
                  me = new s.Buf16(16),
                  ke = null,
                  ae = 0
                for (C = 0; C <= 15; C++) ye[C] = 0
                for (H = 0; H < d; H++) ye[h[f + H]]++
                for (X = Y, J = 15; 1 <= J && ye[J] === 0; J--);
                if ((J < X && (X = J), J === 0)) return (T[y++] = 20971520), (T[y++] = 20971520), (m.bits = 1), 0
                for (w = 1; w < J && ye[w] === 0; w++);
                for (X < w && (X = w), C = ce = 1; C <= 15; C++) if (((ce <<= 1), (ce -= ye[C]) < 0)) return -1
                if (0 < ce && (p === 0 || J !== 1)) return -1
                for (me[1] = 0, C = 1; C < 15; C++) me[C + 1] = me[C] + ye[C]
                for (H = 0; H < d; H++) h[f + H] !== 0 && (b[me[h[f + H]]++] = H)
                if (
                  ((N =
                    p === 0
                      ? ((W = ke = b), 19)
                      : p === 1
                      ? ((W = a), (ge -= 257), (ke = o), (ae -= 257), 256)
                      : ((W = u), (ke = c), -1)),
                  (C = w),
                  (D = y),
                  (Te = H = U = 0),
                  (P = -1),
                  (x = (se = 1 << (G = X)) - 1),
                  (p === 1 && 852 < se) || (p === 2 && 592 < se))
                )
                  return 1
                for (;;) {
                  for (
                    I = C - Te,
                      K = b[H] < N ? ((B = 0), b[H]) : b[H] > N ? ((B = ke[ae + b[H]]), W[ge + b[H]]) : ((B = 96), 0),
                      S = 1 << (C - Te),
                      w = E = 1 << G;
                    (T[D + (U >> Te) + (E -= S)] = (I << 24) | (B << 16) | K | 0), E !== 0;

                  );
                  for (S = 1 << (C - 1); U & S; ) S >>= 1
                  if ((S !== 0 ? ((U &= S - 1), (U += S)) : (U = 0), H++, --ye[C] == 0)) {
                    if (C === J) break
                    C = h[f + b[H]]
                  }
                  if (X < C && (U & x) !== P) {
                    for (
                      Te === 0 && (Te = X), D += w, ce = 1 << (G = C - Te);
                      G + Te < J && !((ce -= ye[G + Te]) <= 0);

                    )
                      G++, (ce <<= 1)
                    if (((se += 1 << G), (p === 1 && 852 < se) || (p === 2 && 592 < se))) return 1
                    T[(P = U & x)] = (X << 24) | (G << 16) | (D - y) | 0
                  }
                }
                return U !== 0 && (T[D + U] = ((C - Te) << 24) | (64 << 16) | 0), (m.bits = X), 0
              }
            },
            { '../utils/common': 41 },
          ],
          51: [
            function (r, i, n) {
              i.exports = {
                2: 'need dictionary',
                1: 'stream end',
                0: '',
                '-1': 'file error',
                '-2': 'stream error',
                '-3': 'data error',
                '-4': 'insufficient memory',
                '-5': 'buffer error',
                '-6': 'incompatible version',
              }
            },
            {},
          ],
          52: [
            function (r, i, n) {
              var s = r('../utils/common'),
                a = 0,
                o = 1
              function u(F) {
                for (var q = F.length; 0 <= --q; ) F[q] = 0
              }
              var c = 0,
                p = 29,
                h = 256,
                f = h + 1 + p,
                d = 30,
                T = 19,
                y = 2 * f + 1,
                b = 15,
                m = 16,
                S = 7,
                E = 256,
                P = 16,
                x = 17,
                D = 18,
                N = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0],
                I = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13],
                B = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7],
                K = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],
                Y = new Array(2 * (f + 2))
              u(Y)
              var C = new Array(2 * d)
              u(C)
              var H = new Array(512)
              u(H)
              var w = new Array(256)
              u(w)
              var J = new Array(p)
              u(J)
              var X,
                G,
                Te,
                ce = new Array(d)
              function se(F, q, le, fe, ne) {
                ;(this.static_tree = F),
                  (this.extra_bits = q),
                  (this.extra_base = le),
                  (this.elems = fe),
                  (this.max_length = ne),
                  (this.has_stree = F && F.length)
              }
              function U(F, q) {
                ;(this.dyn_tree = F), (this.max_code = 0), (this.stat_desc = q)
              }
              function W(F) {
                return F < 256 ? H[F] : H[256 + (F >>> 7)]
              }
              function ge(F, q) {
                ;(F.pending_buf[F.pending++] = 255 & q), (F.pending_buf[F.pending++] = (q >>> 8) & 255)
              }
              function ye(F, q, le) {
                F.bi_valid > m - le
                  ? ((F.bi_buf |= (q << F.bi_valid) & 65535),
                    ge(F, F.bi_buf),
                    (F.bi_buf = q >> (m - F.bi_valid)),
                    (F.bi_valid += le - m))
                  : ((F.bi_buf |= (q << F.bi_valid) & 65535), (F.bi_valid += le))
              }
              function me(F, q, le) {
                ye(F, le[2 * q], le[2 * q + 1])
              }
              function ke(F, q) {
                for (var le = 0; (le |= 1 & F), (F >>>= 1), (le <<= 1), 0 < --q; );
                return le >>> 1
              }
              function ae(F, q, le) {
                var fe,
                  ne,
                  Se = new Array(b + 1),
                  xe = 0
                for (fe = 1; fe <= b; fe++) Se[fe] = xe = (xe + le[fe - 1]) << 1
                for (ne = 0; ne <= q; ne++) {
                  var Ae = F[2 * ne + 1]
                  Ae !== 0 && (F[2 * ne] = ke(Se[Ae]++, Ae))
                }
              }
              function de(F) {
                var q
                for (q = 0; q < f; q++) F.dyn_ltree[2 * q] = 0
                for (q = 0; q < d; q++) F.dyn_dtree[2 * q] = 0
                for (q = 0; q < T; q++) F.bl_tree[2 * q] = 0
                ;(F.dyn_ltree[2 * E] = 1), (F.opt_len = F.static_len = 0), (F.last_lit = F.matches = 0)
              }
              function be(F) {
                8 < F.bi_valid ? ge(F, F.bi_buf) : 0 < F.bi_valid && (F.pending_buf[F.pending++] = F.bi_buf),
                  (F.bi_buf = 0),
                  (F.bi_valid = 0)
              }
              function Pe(F, q, le, fe) {
                var ne = 2 * q,
                  Se = 2 * le
                return F[ne] < F[Se] || (F[ne] === F[Se] && fe[q] <= fe[le])
              }
              function De(F, q, le) {
                for (
                  var fe = F.heap[le], ne = le << 1;
                  ne <= F.heap_len &&
                  (ne < F.heap_len && Pe(q, F.heap[ne + 1], F.heap[ne], F.depth) && ne++,
                  !Pe(q, fe, F.heap[ne], F.depth));

                )
                  (F.heap[le] = F.heap[ne]), (le = ne), (ne <<= 1)
                F.heap[le] = fe
              }
              function Le(F, q, le) {
                var fe,
                  ne,
                  Se,
                  xe,
                  Ae = 0
                if (F.last_lit !== 0)
                  for (
                    ;
                    (fe = (F.pending_buf[F.d_buf + 2 * Ae] << 8) | F.pending_buf[F.d_buf + 2 * Ae + 1]),
                      (ne = F.pending_buf[F.l_buf + Ae]),
                      Ae++,
                      fe === 0
                        ? me(F, ne, q)
                        : (me(F, (Se = w[ne]) + h + 1, q),
                          (xe = N[Se]) !== 0 && ye(F, (ne -= J[Se]), xe),
                          me(F, (Se = W(--fe)), le),
                          (xe = I[Se]) !== 0 && ye(F, (fe -= ce[Se]), xe)),
                      Ae < F.last_lit;

                  );
                me(F, E, q)
              }
              function We(F, q) {
                var le,
                  fe,
                  ne,
                  Se = q.dyn_tree,
                  xe = q.stat_desc.static_tree,
                  Ae = q.stat_desc.has_stree,
                  Re = q.stat_desc.elems,
                  O = -1
                for (F.heap_len = 0, F.heap_max = y, le = 0; le < Re; le++)
                  Se[2 * le] !== 0 ? ((F.heap[++F.heap_len] = O = le), (F.depth[le] = 0)) : (Se[2 * le + 1] = 0)
                for (; F.heap_len < 2; )
                  (Se[2 * (ne = F.heap[++F.heap_len] = O < 2 ? ++O : 0)] = 1),
                    (F.depth[ne] = 0),
                    F.opt_len--,
                    Ae && (F.static_len -= xe[2 * ne + 1])
                for (q.max_code = O, le = F.heap_len >> 1; 1 <= le; le--) De(F, Se, le)
                for (
                  ne = Re;
                  (le = F.heap[1]),
                    (F.heap[1] = F.heap[F.heap_len--]),
                    De(F, Se, 1),
                    (fe = F.heap[1]),
                    (F.heap[--F.heap_max] = le),
                    (F.heap[--F.heap_max] = fe),
                    (Se[2 * ne] = Se[2 * le] + Se[2 * fe]),
                    (F.depth[ne] = (F.depth[le] >= F.depth[fe] ? F.depth[le] : F.depth[fe]) + 1),
                    (Se[2 * le + 1] = Se[2 * fe + 1] = ne),
                    (F.heap[1] = ne++),
                    De(F, Se, 1),
                    2 <= F.heap_len;

                );
                ;(F.heap[--F.heap_max] = F.heap[1]),
                  (function (g, v) {
                    var z,
                      ee,
                      ue,
                      Z,
                      et,
                      bt,
                      at = v.dyn_tree,
                      Pt = v.max_code,
                      R = v.stat_desc.static_tree,
                      Ze = v.stat_desc.has_stree,
                      Mr = v.stat_desc.extra_bits,
                      ns = v.stat_desc.extra_base,
                      ha = v.stat_desc.max_length,
                      Jl = 0
                    for (Z = 0; Z <= b; Z++) g.bl_count[Z] = 0
                    for (at[2 * g.heap[g.heap_max] + 1] = 0, z = g.heap_max + 1; z < y; z++)
                      ha < (Z = at[2 * at[2 * (ee = g.heap[z]) + 1] + 1] + 1) && ((Z = ha), Jl++),
                        (at[2 * ee + 1] = Z),
                        Pt < ee ||
                          (g.bl_count[Z]++,
                          (et = 0),
                          ns <= ee && (et = Mr[ee - ns]),
                          (bt = at[2 * ee]),
                          (g.opt_len += bt * (Z + et)),
                          Ze && (g.static_len += bt * (R[2 * ee + 1] + et)))
                    if (Jl !== 0) {
                      do {
                        for (Z = ha - 1; g.bl_count[Z] === 0; ) Z--
                        g.bl_count[Z]--, (g.bl_count[Z + 1] += 2), g.bl_count[ha]--, (Jl -= 2)
                      } while (0 < Jl)
                      for (Z = ha; Z !== 0; Z--)
                        for (ee = g.bl_count[Z]; ee !== 0; )
                          Pt < (ue = g.heap[--z]) ||
                            (at[2 * ue + 1] !== Z &&
                              ((g.opt_len += (Z - at[2 * ue + 1]) * at[2 * ue]), (at[2 * ue + 1] = Z)),
                            ee--)
                    }
                  })(F, q),
                  ae(Se, O, F.bl_count)
              }
              function A(F, q, le) {
                var fe,
                  ne,
                  Se = -1,
                  xe = q[1],
                  Ae = 0,
                  Re = 7,
                  O = 4
                for (xe === 0 && ((Re = 138), (O = 3)), q[2 * (le + 1) + 1] = 65535, fe = 0; fe <= le; fe++)
                  (ne = xe),
                    (xe = q[2 * (fe + 1) + 1]),
                    (++Ae < Re && ne === xe) ||
                      (Ae < O
                        ? (F.bl_tree[2 * ne] += Ae)
                        : ne !== 0
                        ? (ne !== Se && F.bl_tree[2 * ne]++, F.bl_tree[2 * P]++)
                        : Ae <= 10
                        ? F.bl_tree[2 * x]++
                        : F.bl_tree[2 * D]++,
                      (Se = ne),
                      (O = (Ae = 0) === xe ? ((Re = 138), 3) : ne === xe ? ((Re = 6), 3) : ((Re = 7), 4)))
              }
              function pe(F, q, le) {
                var fe,
                  ne,
                  Se = -1,
                  xe = q[1],
                  Ae = 0,
                  Re = 7,
                  O = 4
                for (xe === 0 && ((Re = 138), (O = 3)), fe = 0; fe <= le; fe++)
                  if (((ne = xe), (xe = q[2 * (fe + 1) + 1]), !(++Ae < Re && ne === xe))) {
                    if (Ae < O) for (; me(F, ne, F.bl_tree), --Ae != 0; );
                    else
                      ne !== 0
                        ? (ne !== Se && (me(F, ne, F.bl_tree), Ae--), me(F, P, F.bl_tree), ye(F, Ae - 3, 2))
                        : Ae <= 10
                        ? (me(F, x, F.bl_tree), ye(F, Ae - 3, 3))
                        : (me(F, D, F.bl_tree), ye(F, Ae - 11, 7))
                    ;(Se = ne), (O = (Ae = 0) === xe ? ((Re = 138), 3) : ne === xe ? ((Re = 6), 3) : ((Re = 7), 4))
                  }
              }
              u(ce)
              var ie = !1
              function L(F, q, le, fe) {
                ye(F, (c << 1) + (fe ? 1 : 0), 3),
                  (function (ne, Se, xe, Ae) {
                    be(ne),
                      Ae && (ge(ne, xe), ge(ne, ~xe)),
                      s.arraySet(ne.pending_buf, ne.window, Se, xe, ne.pending),
                      (ne.pending += xe)
                  })(F, q, le, !0)
              }
              ;(n._tr_init = function (F) {
                ie ||
                  ((function () {
                    var q,
                      le,
                      fe,
                      ne,
                      Se,
                      xe = new Array(b + 1)
                    for (ne = fe = 0; ne < p - 1; ne++) for (J[ne] = fe, q = 0; q < 1 << N[ne]; q++) w[fe++] = ne
                    for (w[fe - 1] = ne, ne = Se = 0; ne < 16; ne++)
                      for (ce[ne] = Se, q = 0; q < 1 << I[ne]; q++) H[Se++] = ne
                    for (Se >>= 7; ne < d; ne++)
                      for (ce[ne] = Se << 7, q = 0; q < 1 << (I[ne] - 7); q++) H[256 + Se++] = ne
                    for (le = 0; le <= b; le++) xe[le] = 0
                    for (q = 0; q <= 143; ) (Y[2 * q + 1] = 8), q++, xe[8]++
                    for (; q <= 255; ) (Y[2 * q + 1] = 9), q++, xe[9]++
                    for (; q <= 279; ) (Y[2 * q + 1] = 7), q++, xe[7]++
                    for (; q <= 287; ) (Y[2 * q + 1] = 8), q++, xe[8]++
                    for (ae(Y, f + 1, xe), q = 0; q < d; q++) (C[2 * q + 1] = 5), (C[2 * q] = ke(q, 5))
                    ;(X = new se(Y, N, h + 1, f, b)),
                      (G = new se(C, I, 0, d, b)),
                      (Te = new se(new Array(0), B, 0, T, S))
                  })(),
                  (ie = !0)),
                  (F.l_desc = new U(F.dyn_ltree, X)),
                  (F.d_desc = new U(F.dyn_dtree, G)),
                  (F.bl_desc = new U(F.bl_tree, Te)),
                  (F.bi_buf = 0),
                  (F.bi_valid = 0),
                  de(F)
              }),
                (n._tr_stored_block = L),
                (n._tr_flush_block = function (F, q, le, fe) {
                  var ne,
                    Se,
                    xe = 0
                  0 < F.level
                    ? (F.strm.data_type === 2 &&
                        (F.strm.data_type = (function (Ae) {
                          var Re,
                            O = 4093624447
                          for (Re = 0; Re <= 31; Re++, O >>>= 1) if (1 & O && Ae.dyn_ltree[2 * Re] !== 0) return a
                          if (Ae.dyn_ltree[18] !== 0 || Ae.dyn_ltree[20] !== 0 || Ae.dyn_ltree[26] !== 0) return o
                          for (Re = 32; Re < h; Re++) if (Ae.dyn_ltree[2 * Re] !== 0) return o
                          return a
                        })(F)),
                      We(F, F.l_desc),
                      We(F, F.d_desc),
                      (xe = (function (Ae) {
                        var Re
                        for (
                          A(Ae, Ae.dyn_ltree, Ae.l_desc.max_code),
                            A(Ae, Ae.dyn_dtree, Ae.d_desc.max_code),
                            We(Ae, Ae.bl_desc),
                            Re = T - 1;
                          3 <= Re && Ae.bl_tree[2 * K[Re] + 1] === 0;
                          Re--
                        );
                        return (Ae.opt_len += 3 * (Re + 1) + 5 + 5 + 4), Re
                      })(F)),
                      (ne = (F.opt_len + 3 + 7) >>> 3),
                      (Se = (F.static_len + 3 + 7) >>> 3) <= ne && (ne = Se))
                    : (ne = Se = le + 5),
                    le + 4 <= ne && q !== -1
                      ? L(F, q, le, fe)
                      : F.strategy === 4 || Se === ne
                      ? (ye(F, 2 + (fe ? 1 : 0), 3), Le(F, Y, C))
                      : (ye(F, 4 + (fe ? 1 : 0), 3),
                        (function (Ae, Re, O, g) {
                          var v
                          for (ye(Ae, Re - 257, 5), ye(Ae, O - 1, 5), ye(Ae, g - 4, 4), v = 0; v < g; v++)
                            ye(Ae, Ae.bl_tree[2 * K[v] + 1], 3)
                          pe(Ae, Ae.dyn_ltree, Re - 1), pe(Ae, Ae.dyn_dtree, O - 1)
                        })(F, F.l_desc.max_code + 1, F.d_desc.max_code + 1, xe + 1),
                        Le(F, F.dyn_ltree, F.dyn_dtree)),
                    de(F),
                    fe && be(F)
                }),
                (n._tr_tally = function (F, q, le) {
                  return (
                    (F.pending_buf[F.d_buf + 2 * F.last_lit] = (q >>> 8) & 255),
                    (F.pending_buf[F.d_buf + 2 * F.last_lit + 1] = 255 & q),
                    (F.pending_buf[F.l_buf + F.last_lit] = 255 & le),
                    F.last_lit++,
                    q === 0
                      ? F.dyn_ltree[2 * le]++
                      : (F.matches++, q--, F.dyn_ltree[2 * (w[le] + h + 1)]++, F.dyn_dtree[2 * W(q)]++),
                    F.last_lit === F.lit_bufsize - 1
                  )
                }),
                (n._tr_align = function (F) {
                  ye(F, 2, 3),
                    me(F, E, Y),
                    (function (q) {
                      q.bi_valid === 16
                        ? (ge(q, q.bi_buf), (q.bi_buf = 0), (q.bi_valid = 0))
                        : 8 <= q.bi_valid &&
                          ((q.pending_buf[q.pending++] = 255 & q.bi_buf), (q.bi_buf >>= 8), (q.bi_valid -= 8))
                    })(F)
                })
            },
            { '../utils/common': 41 },
          ],
          53: [
            function (r, i, n) {
              i.exports = function () {
                ;(this.input = null),
                  (this.next_in = 0),
                  (this.avail_in = 0),
                  (this.total_in = 0),
                  (this.output = null),
                  (this.next_out = 0),
                  (this.avail_out = 0),
                  (this.total_out = 0),
                  (this.msg = ''),
                  (this.state = null),
                  (this.data_type = 2),
                  (this.adler = 0)
              }
            },
            {},
          ],
          54: [
            function (r, i, n) {
              ;(function (s) {
                ;(function (a, o) {
                  if (!a.setImmediate) {
                    var u,
                      c,
                      p,
                      h,
                      f = 1,
                      d = {},
                      T = !1,
                      y = a.document,
                      b = Object.getPrototypeOf && Object.getPrototypeOf(a)
                    ;(b = b && b.setTimeout ? b : a),
                      (u =
                        {}.toString.call(a.process) === '[object process]'
                          ? function (P) {
                              process.nextTick(function () {
                                S(P)
                              })
                            }
                          : (function () {
                              if (a.postMessage && !a.importScripts) {
                                var P = !0,
                                  x = a.onmessage
                                return (
                                  (a.onmessage = function () {
                                    P = !1
                                  }),
                                  a.postMessage('', '*'),
                                  (a.onmessage = x),
                                  P
                                )
                              }
                            })()
                          ? ((h = 'setImmediate$' + Math.random() + '$'),
                            a.addEventListener ? a.addEventListener('message', E, !1) : a.attachEvent('onmessage', E),
                            function (P) {
                              a.postMessage(h + P, '*')
                            })
                          : a.MessageChannel
                          ? (((p = new MessageChannel()).port1.onmessage = function (P) {
                              S(P.data)
                            }),
                            function (P) {
                              p.port2.postMessage(P)
                            })
                          : y && 'onreadystatechange' in y.createElement('script')
                          ? ((c = y.documentElement),
                            function (P) {
                              var x = y.createElement('script')
                              ;(x.onreadystatechange = function () {
                                S(P), (x.onreadystatechange = null), c.removeChild(x), (x = null)
                              }),
                                c.appendChild(x)
                            })
                          : function (P) {
                              setTimeout(S, 0, P)
                            }),
                      (b.setImmediate = function (P) {
                        typeof P != 'function' && (P = new Function('' + P))
                        for (var x = new Array(arguments.length - 1), D = 0; D < x.length; D++) x[D] = arguments[D + 1]
                        var N = { callback: P, args: x }
                        return (d[f] = N), u(f), f++
                      }),
                      (b.clearImmediate = m)
                  }
                  function m(P) {
                    delete d[P]
                  }
                  function S(P) {
                    if (T) setTimeout(S, 0, P)
                    else {
                      var x = d[P]
                      if (x) {
                        T = !0
                        try {
                          ;(function (D) {
                            var N = D.callback,
                              I = D.args
                            switch (I.length) {
                              case 0:
                                N()
                                break
                              case 1:
                                N(I[0])
                                break
                              case 2:
                                N(I[0], I[1])
                                break
                              case 3:
                                N(I[0], I[1], I[2])
                                break
                              default:
                                N.apply(o, I)
                            }
                          })(x)
                        } finally {
                          m(P), (T = !1)
                        }
                      }
                    }
                  }
                  function E(P) {
                    P.source === a && typeof P.data == 'string' && P.data.indexOf(h) === 0 && S(+P.data.slice(h.length))
                  }
                })(typeof self == 'undefined' ? (s === void 0 ? this : s) : self)
              }.call(
                this,
                typeof jt != 'undefined'
                  ? jt
                  : typeof self != 'undefined'
                  ? self
                  : typeof window != 'undefined'
                  ? window
                  : {}
              ))
            },
            {},
          ],
        },
        {},
        [10]
      )(10)
    })
  })(uT)
  var $X = uT.exports,
    jne = '',
    _ne = '',
    Vne = '',
    Une = '',
    zne = '',
    Kne = '',
    cT = { locks: {}, zIndex: 2e3, touchmoveForbid: !0 }
  l.reactive(cT)
  var Ii = l.reactive(cT),
    Ee = (t) =>
      t == null ? 0 : Tr(t) ? ((t = parseFloat(t)), (t = Number.isNaN(t) ? 0 : t), t) : df(t) ? Number(t) : t,
    pT = (t) => (t == null ? !1 : t.startsWith('data:image') || /\.(png|jpg|gif|jpeg|svg)$/.test(t)),
    fT = (t) => (t == null ? !1 : t.startsWith('data:video') || /\.(mp4|webm|ogg)$/.test(t)),
    Tr = (t) => typeof t == 'string',
    df = (t) => typeof t == 'boolean',
    br = (t) => typeof t == 'number',
    hT = (t) => Object.prototype.toString.call(t) === '[object Object]',
    RX = (t) => typeof t == 'object' && t !== null,
    At = (t) => Array.isArray(t),
    jX = (t) => (t ? /^(http)|(\.*\/)/.test(t) : !1),
    ki = (t) => t == null || t === '' || (Array.isArray(t) && !t.length),
    yl = (t, e) => {
      if (t.length) {
        var r = t.indexOf(e)
        if (r > -1) return t.splice(r, 1)
      }
    },
    mf = function (t, e) {
      e === void 0 && (e = 200)
      var r,
        i = 0
      return function n() {
        for (var s = arguments.length, a = new Array(s), o = 0; o < s; o++) a[o] = arguments[o]
        var u = Date.now(),
          c = u - i
        i || (i = u),
          r && window.clearTimeout(r),
          c >= e
            ? (t.apply(this, a), (i = u))
            : (r = window.setTimeout(() => {
                n.apply(this, a)
              }, e - c))
      }
    },
    _X = (t) => {
      var e = []
      return {
        cache: e,
        has(r) {
          return this.cache.includes(r)
        },
        add(r) {
          this.has(r) || (this.cache.length === t && e.shift(), this.cache.push(r))
        },
        remove(r) {
          this.has(r) && yl(this.cache, r)
        },
        clear() {
          this.cache.length = 0
        },
      }
    },
    dT = (t) => t,
    mT = (t) => Math.pow(t, 3),
    yT = (t) => (t < 0.5 ? mT(t * 2) / 2 : 1 - mT((1 - t) * 2) / 2)
  function VX(t, e) {
    var r = Object.values(e),
      i = ['DD', 'HH', 'mm', 'ss'],
      n = [24, 60, 60, 1e3]
    if (
      (i.forEach((a, o) => {
        t.includes(a) ? (t = t.replace(a, String(r[o]).padStart(2, '0'))) : (r[o + 1] += r[o] * n[o])
      }),
      t.includes('S'))
    ) {
      var s = String(r[r.length - 1]).padStart(3, '0')
      t.includes('SSS')
        ? (t = t.replace('SSS', s))
        : t.includes('SS')
        ? (t = t.replace('SS', s.slice(0, 2)))
        : (t = t.replace('S', s.slice(0, 1)))
    }
    return t
  }
  var gl = (t, e) => (t == null ? e : t),
    UX = () => typeof window != 'undefined',
    gT = (t) => [...new Set(t)]
  function zX(t) {
    var e = t.replace(/([A-Z])/g, ' $1').trim()
    return e.split(' ').join('-').toLowerCase()
  }
  function TT(t, e, r, i, n, s, a) {
    try {
      var o = t[s](a),
        u = o.value
    } catch (c) {
      r(c)
      return
    }
    o.done ? e(u) : Promise.resolve(u).then(i, n)
  }
  function KX(t) {
    return function () {
      var e = this,
        r = arguments
      return new Promise(function (i, n) {
        var s = t.apply(e, r)
        function a(u) {
          TT(s, i, n, a, o, 'next', u)
        }
        function o(u) {
          TT(s, i, n, a, o, 'throw', u)
        }
        a(void 0)
      })
    }
  }
  function bT(t) {
    var { left: e } = t.getBoundingClientRect()
    return e + (document.body.scrollLeft || document.documentElement.scrollLeft)
  }
  function ST(t) {
    var { top: e } = t.getBoundingClientRect()
    return e + (document.body.scrollTop || document.documentElement.scrollTop)
  }
  function Tl(t) {
    var e = 'scrollTop' in t ? t.scrollTop : t.pageYOffset
    return Math.max(e, 0)
  }
  function yf(t) {
    var e = 'scrollLeft' in t ? t.scrollLeft : t.pageXOffset
    return Math.max(e, 0)
  }
  function WX(t) {
    return gf.apply(this, arguments)
  }
  function gf() {
    return (
      (gf = KX(function* (t) {
        yield dn()
        var { top: e, bottom: r, left: i, right: n } = t.getBoundingClientRect(),
          { innerWidth: s, innerHeight: a } = window,
          o = i <= s && n >= 0,
          u = e <= a && r >= 0
        return o && u
      })),
      gf.apply(this, arguments)
    )
  }
  function Tf(t) {
    var { transform: e } = window.getComputedStyle(t)
    return +e.slice(e.lastIndexOf(',') + 2, e.length - 1)
  }
  function Wn(t) {
    for (
      var e = t;
      e && !(!e.parentNode || ((e = e.parentNode), e === document.body || e === document.documentElement));

    ) {
      var r = /(scroll|auto)/,
        { overflowY: i, overflow: n } = window.getComputedStyle(e)
      if (r.test(i) || r.test(n)) return e
    }
    return window
  }
  function YX(t) {
    for (var e = [], r = t; r !== window; ) (r = Wn(r)), e.push(r)
    return e
  }
  var vT = (t) => Tr(t) && t.endsWith('rem'),
    HX = (t) => (Tr(t) && t.endsWith('px')) || br(t),
    qX = (t) => Tr(t) && t.endsWith('%'),
    ET = (t) => Tr(t) && t.endsWith('vw'),
    PT = (t) => Tr(t) && t.endsWith('vh'),
    Mt = (t) => {
      if (br(t)) return t
      if (HX(t)) return +t.replace('px', '')
      if (ET(t)) return (+t.replace('vw', '') * window.innerWidth) / 100
      if (PT(t)) return (+t.replace('vh', '') * window.innerHeight) / 100
      if (vT(t)) {
        var e = +t.replace('rem', ''),
          r = window.getComputedStyle(document.documentElement).fontSize
        return e * parseFloat(r)
      }
      return Tr(t) ? Ee(t) : 0
    },
    xt = (t) => {
      if (t != null) return qX(t) || ET(t) || PT(t) || vT(t) ? t : Mt(t) + 'px'
    },
    qt = function (t, e) {
      if ((e === void 0 && (e = 1), t != null)) {
        var r = xt(t),
          i = r.match(/(vh|%|rem|px|vw)$/)[0]
        return '' + parseFloat(r) * e + i
      }
    }
  function ui(t) {
    return globalThis.requestAnimationFrame ? globalThis.requestAnimationFrame(t) : globalThis.setTimeout(t, 16)
  }
  function XX(t) {
    globalThis.cancelAnimationFrame ? globalThis.cancelAnimationFrame(t) : globalThis.clearTimeout(t)
  }
  function bf(t) {
    ui(() => {
      ui(t)
    })
  }
  function dn() {
    return new Promise((t) => {
      ui(() => {
        ui(t)
      })
    })
  }
  function bl(t, e) {
    var { top: r = 0, left: i = 0, duration: n = 300, animation: s } = e,
      a = Date.now(),
      o = Tl(t),
      u = yf(t)
    return new Promise((c) => {
      var p = () => {
        var h = (Date.now() - a) / n
        if (h < 1) {
          var f = o + (r - o) * s(h),
            d = u + (i - u) * s(h)
          t.scrollTo(d, f), ui(p)
        } else t.scrollTo(i, r), c()
      }
      ui(p)
    })
  }
  function GX(t) {
    return Object.entries(t != null ? t : {}).reduce((e, r) => {
      var [i, n] = r,
        s = i.startsWith('--') ? i : '--' + zX(i)
      return (e[s] = n), e
    }, {})
  }
  function JX() {
    var t = typeof window != 'undefined'
    return t && 'ontouchstart' in window
  }
  var ZX = ['collect', 'clear']
  function wT(t, e, r, i, n, s, a) {
    try {
      var o = t[s](a),
        u = o.value
    } catch (c) {
      r(c)
      return
    }
    o.done ? e(u) : Promise.resolve(u).then(i, n)
  }
  function AT(t) {
    return function () {
      var e = this,
        r = arguments
      return new Promise(function (i, n) {
        var s = t.apply(e, r)
        function a(u) {
          wT(s, i, n, a, o, 'next', u)
        }
        function o(u) {
          wT(s, i, n, a, o, 'throw', u)
        }
        a(void 0)
      })
    }
  }
  function QX(t, e) {
    if (t == null) return {}
    var r = {},
      i = Object.keys(t),
      n,
      s
    for (s = 0; s < i.length; s++) (n = i[s]), !(e.indexOf(n) >= 0) && (r[n] = t[n])
    return r
  }
  function Sl() {
    return (
      (Sl =
        Object.assign ||
        function (t) {
          for (var e = 1; e < arguments.length; e++) {
            var r = arguments[e]
            for (var i in r) Object.prototype.hasOwnProperty.call(r, i) && (t[i] = r[i])
          }
          return t
        }),
      Sl.apply(this, arguments)
    )
  }
  function xr(t, e) {
    return Array.isArray(e) ? e.reduce((r, i) => ((r[i] = t[i]), r), {}) : t[e]
  }
  function eG(t) {
    var e = l.createApp(t),
      r = document.createElement('div')
    return (
      document.body.appendChild(r),
      {
        instance: e.mount(r),
        unmount() {
          e.unmount(), document.body.removeChild(r)
        },
      }
    )
  }
  function tG(t, e, r) {
    e === void 0 && (e = {}), r === void 0 && (r = {})
    var i = {
        setup() {
          return () => l.h(t, Sl({}, e, r))
        },
      },
      { unmount: n } = eG(i)
    return { unmountInstance: n }
  }
  function rG(t) {
    var e = [],
      r = (i) => {
        if (i != null && i.component) {
          r(i == null ? void 0 : i.component.subTree)
          return
        }
        Array.isArray(i == null ? void 0 : i.children) &&
          i.children.forEach((n) => {
            l.isVNode(n) && (e.push(n), r(n))
          })
      }
    return r(t), e
  }
  function Ir(t) {
    var e = l.reactive([]),
      r = l.getCurrentInstance(),
      i = () => {
        var o = rG(r.subTree)
        e.sort((u, c) => o.indexOf(u.vnode) - o.indexOf(c.vnode))
      },
      n = (o) => {
        e.push(o), i()
      },
      s = (o) => {
        yl(e, o)
      }
    l.provide(t, { collect: n, clear: s, instances: e })
    var a = l.computed(() => e.length)
    return { length: a }
  }
  function kr(t) {
    if (!CT(t)) return { index: null }
    var e = l.inject(t),
      { collect: r, clear: i, instances: n } = e,
      s = l.getCurrentInstance()
    l.onMounted(() => {
      l.nextTick().then(() => r(s))
    }),
      l.onUnmounted(() => {
        l.nextTick().then(() => i(s))
      })
    var a = l.computed(() => n.indexOf(s))
    return { index: a }
  }
  function Sr(t) {
    var e = [],
      r = (s) => {
        e.push(s)
      },
      i = (s) => {
        yl(e, s)
      },
      n = (s) => {
        l.provide(t, Sl({ collect: r, clear: i }, s))
      }
    return { childProviders: e, bindChildren: n }
  }
  function vr(t) {
    if (!CT(t)) return { parentProvider: null, bindParent: null }
    var e = l.inject(t),
      { collect: r, clear: i } = e,
      n = QX(e, ZX),
      s = (a) => {
        l.onMounted(() => r(a)), l.onBeforeUnmount(() => i(a))
      }
    return { parentProvider: n, bindParent: s }
  }
  function CT(t) {
    var e = l.getCurrentInstance()
    return t in e.provides
  }
  function Nr() {
    var t = l.ref(''),
      e = (function () {
        var n = AT(function* (s, a, o) {
          if (!At(s) || !s.length) return !0
          var u = yield Promise.all(s.map((c) => c(a, o)))
          return !u.some((c) => (c !== !0 ? ((t.value = String(c)), !0) : !1))
        })
        return function (a, o, u) {
          return n.apply(this, arguments)
        }
      })(),
      r = () => {
        t.value = ''
      },
      i = (function () {
        var n = AT(function* (s, a, o, u, c) {
          s.includes(a) && (yield e(o, u, c)) && (t.value = '')
        })
        return function (a, o, u, c, p) {
          return n.apply(this, arguments)
        }
      })()
    return { errorMessage: t, validate: e, resetValidation: r, validateWithTrigger: i }
  }
  function iG(t) {
    l.onMounted(() => {
      window.addEventListener('hashchange', t), window.addEventListener('popstate', t)
    }),
      l.onUnmounted(() => {
        window.removeEventListener('hashchange', t), window.removeEventListener('popstate', t)
      })
  }
  function Sf() {
    var t = l.ref(!1)
    return (
      l.onActivated(() => {
        t.value = !1
      }),
      l.onDeactivated(() => {
        t.value = !0
      }),
      { disabled: t }
    )
  }
  function nG(t) {
    var e = l.getCurrentInstance()
    e && Object.assign(e.proxy, t)
  }
  function Me(t) {
    var e = 'var-' + t,
      r = (n) => (n ? (n.startsWith('--') ? '' + e + n : e + '__' + n) : e),
      i = function () {
        for (var n = arguments.length, s = new Array(n), a = 0; a < n; a++) s[a] = arguments[a]
        return s.map((o) => {
          if (At(o)) {
            var [u, c, p = null] = o
            return u ? c : p
          }
          return o
        })
      }
    return { n: r, classes: i }
  }
  function he(t) {
    for (var e = arguments.length, r = new Array(e > 1 ? e - 1 : 0), i = 1; i < e; i++) r[i - 1] = arguments[i]
    if (t) return t(...r)
  }
  function vl() {
    return (
      (vl =
        Object.assign ||
        function (t) {
          for (var e = 1; e < arguments.length; e++) {
            var r = arguments[e]
            for (var i in r) Object.prototype.hasOwnProperty.call(r, i) && (t[i] = r[i])
          }
          return t
        }),
      vl.apply(this, arguments)
    )
  }
  var { n: xT } = Me('ripple'),
    IT = 250
  function sG(t) {
    var { zIndex: e, position: r } = window.getComputedStyle(t)
    ;(t.style.overflow = 'hidden'),
      (t.style.overflowX = 'hidden'),
      (t.style.overflowY = 'hidden'),
      r === 'static' && (t.style.position = 'relative'),
      e === 'auto' && (t.style.zIndex = '1')
  }
  function aG(t, e) {
    var { top: r, left: i } = t.getBoundingClientRect(),
      { clientWidth: n, clientHeight: s } = t,
      a = Math.sqrt(Math.pow(n, 2) + Math.pow(s, 2)) / 2,
      o = a * 2,
      u = e.touches[0].clientX - i,
      c = e.touches[0].clientY - r,
      p = (n - a * 2) / 2,
      h = (s - a * 2) / 2,
      f = u - a,
      d = c - a
    return { x: f, y: d, centerX: p, centerY: h, size: o }
  }
  function kT(t) {
    var e = this._ripple
    if ((e.removeRipple(), !(e.disabled || e.tasker))) {
      var r = () => {
        e.tasker = null
        var { x: i, y: n, centerX: s, centerY: a, size: o } = aG(this, t),
          u = document.createElement('div')
        u.classList.add(xT()),
          (u.style.opacity = '0'),
          (u.style.transform = 'translate(' + i + 'px, ' + n + 'px) scale3d(.3, .3, .3)'),
          (u.style.width = o + 'px'),
          (u.style.height = o + 'px'),
          e.color && (u.style.backgroundColor = e.color),
          (u.dataset.createdAt = String(performance.now())),
          sG(this),
          this.appendChild(u),
          window.setTimeout(() => {
            ;(u.style.transform = 'translate(' + s + 'px, ' + a + 'px) scale3d(1, 1, 1)'), (u.style.opacity = '.25')
          }, 20)
      }
      e.tasker = window.setTimeout(r, 60)
    }
  }
  function vf() {
    var t = this._ripple,
      e = () => {
        var r = this.querySelectorAll('.' + xT())
        if (!!r.length) {
          var i = r[r.length - 1],
            n = IT - performance.now() + Number(i.dataset.createdAt)
          setTimeout(() => {
            ;(i.style.opacity = '0'),
              setTimeout(() => {
                var s
                return (s = i.parentNode) == null ? void 0 : s.removeChild(i)
              }, IT)
          }, n)
        }
      }
    t.tasker ? setTimeout(e, 60) : e()
  }
  function NT() {
    var t = this._ripple
    !JX() || !t.touchmoveForbid || (t.tasker && window.clearTimeout(t.tasker), (t.tasker = null))
  }
  function oG(t, e) {
    var r, i, n
    ;(t._ripple = vl({ tasker: null }, (r = e.value) != null ? r : {}, {
      touchmoveForbid: (i = (n = e.value) == null ? void 0 : n.touchmoveForbid) != null ? i : Ii.touchmoveForbid,
      removeRipple: vf.bind(t),
    })),
      t.addEventListener('touchstart', kT, { passive: !0 }),
      t.addEventListener('touchmove', NT, { passive: !0 }),
      t.addEventListener('dragstart', vf, { passive: !0 }),
      document.addEventListener('touchend', t._ripple.removeRipple, { passive: !0 }),
      document.addEventListener('touchcancel', t._ripple.removeRipple, { passive: !0 })
  }
  function lG(t) {
    t.removeEventListener('touchstart', kT),
      t.removeEventListener('touchmove', NT),
      t.removeEventListener('dragstart', vf),
      document.removeEventListener('touchend', t._ripple.removeRipple),
      document.removeEventListener('touchcancel', t._ripple.removeRipple)
  }
  function uG(t, e) {
    var r, i, n
    t._ripple.tasker && t._ripple.removeRipple(),
      (t._ripple = vl({}, t._ripple, (r = e.value) != null ? r : {}, {
        touchmoveForbid: (i = (n = e.value) == null ? void 0 : n.touchmoveForbid) != null ? i : Ii.touchmoveForbid,
        tasker: null,
      }))
  }
  var tr = {
    mounted: oG,
    unmounted: lG,
    updated: uG,
    install(t) {
      t.directive('ripple', this)
    },
  }
  function cG(t) {
    return ['top', 'bottom', 'right', 'left', 'center'].includes(t)
  }
  var Zs = {
    show: { type: Boolean, default: !1 },
    position: { type: String, default: 'center', validator: cG },
    transition: { type: String },
    overlay: { type: Boolean, default: !0 },
    overlayClass: { type: String },
    overlayStyle: { type: Object },
    lockScroll: { type: Boolean, default: !0 },
    closeOnClickOverlay: { type: Boolean, default: !0 },
    teleport: { type: String },
    onOpen: { type: Function },
    onOpened: { type: Function },
    onClose: { type: Function },
    onClosed: { type: Function },
    onClickOverlay: { type: Function },
    onRouteChange: { type: Function },
    'onUpdate:show': { type: Function },
  }
  function OT() {
    var t = Object.keys(Ii.locks).length
    t <= 0 ? document.body.classList.remove('var--lock') : document.body.classList.add('var--lock')
  }
  function El(t) {
    ;(Ii.locks[t] = 1), OT()
  }
  function Pl(t) {
    delete Ii.locks[t], OT()
  }
  function Ef(t, e) {
    var { uid: r } = l.getCurrentInstance()
    e &&
      l.watch(e, (i) => {
        i === !1 ? Pl(r) : i === !0 && t() === !0 && El(r)
      }),
      l.watch(t, (i) => {
        ;(e && e() === !1) || (i === !0 ? El(r) : Pl(r))
      }),
      l.onBeforeMount(() => {
        ;(e && e() === !1) || (t() === !0 && El(r))
      }),
      l.onUnmounted(() => {
        ;(e && e() === !1) || (t() === !0 && Pl(r))
      }),
      l.onActivated(() => {
        ;(e && e() === !1) || (t() === !0 && El(r))
      }),
      l.onDeactivated(() => {
        ;(e && e() === !1) || (t() === !0 && Pl(r))
      })
  }
  function wl(t, e) {
    var r = l.ref(Ii.zIndex)
    return (
      l.watch(
        t,
        (i) => {
          i && ((Ii.zIndex += e), (r.value = Ii.zIndex))
        },
        { immediate: !0 }
      ),
      { zIndex: r }
    )
  }
  function Pf() {
    return (
      (Pf =
        Object.assign ||
        function (t) {
          for (var e = 1; e < arguments.length; e++) {
            var r = arguments[e]
            for (var i in r) Object.prototype.hasOwnProperty.call(r, i) && (t[i] = r[i])
          }
          return t
        }),
      Pf.apply(this, arguments)
    )
  }
  function pG(t) {
    return typeof t == 'function' || (Object.prototype.toString.call(t) === '[object Object]' && !l.isVNode(t))
  }
  var { n: Al, classes: wf } = Me('popup'),
    Ni = l.defineComponent({
      name: 'VarPopup',
      inheritAttrs: !1,
      props: Zs,
      setup(t, e) {
        var { slots: r, attrs: i } = e,
          { zIndex: n } = wl(() => t.show, 3),
          { disabled: s } = Sf(),
          a = () => {
            var p,
              { closeOnClickOverlay: h, onClickOverlay: f } = t
            f == null || f(), h && ((p = t['onUpdate:show']) == null || p.call(t, !1))
          }
        Ef(
          () => t.show,
          () => t.lockScroll
        ),
          l.watch(
            () => t.show,
            (p) => {
              var { onOpen: h, onClose: f } = t
              p ? h == null || h() : f == null || f()
            }
          ),
          iG(() => (t.onRouteChange == null ? void 0 : t.onRouteChange()))
        var o = () => {
            var { overlayClass: p = '', overlayStyle: h } = t
            return l.createVNode(
              'div',
              { class: wf(Al('overlay'), p), style: Pf({ zIndex: n.value - 1 }, h), onClick: a },
              null
            )
          },
          u = () =>
            l.createVNode(
              'div',
              l.mergeProps(
                { class: wf(Al('content'), 'var-elevation--3', Al('--' + t.position)), style: { zIndex: n.value } },
                i
              ),
              [r.default == null ? void 0 : r.default()]
            ),
          c = () => {
            var { onOpened: p, onClosed: h, show: f, overlay: d, transition: T, position: y } = t
            return l.createVNode(
              l.Transition,
              { name: 'var-fade', onAfterEnter: p, onAfterLeave: h },
              {
                default: () => [
                  l.withDirectives(
                    l.createVNode('div', { class: wf('var--box', Al()), style: { zIndex: n.value - 2 } }, [
                      d && o(),
                      l.createVNode(l.Transition, { name: T || 'var-pop-' + y }, { default: () => [f && u()] }),
                    ]),
                    [[l.vShow, f]]
                  ),
                ],
              }
            )
          }
        return () => {
          var { teleport: p } = t
          if (p) {
            var h
            return l.createVNode(l.Teleport, { to: p, disabled: s.value }, pG((h = c())) ? h : { default: () => [h] })
          }
          return c()
        }
      },
    })
  Ni.install = function (t) {
    t.component(Ni.name, Ni)
  }
  var DT = {
    name: { type: String },
    size: { type: [Number, String] },
    color: { type: String },
    namespace: { type: String, default: 'var-icon' },
    transition: { type: [Number, String], default: 0 },
    onClick: { type: Function },
  }
  function BT(t, e, r, i, n, s, a) {
    try {
      var o = t[s](a),
        u = o.value
    } catch (c) {
      r(c)
      return
    }
    o.done ? e(u) : Promise.resolve(u).then(i, n)
  }
  function fG(t) {
    return function () {
      var e = this,
        r = arguments
      return new Promise(function (i, n) {
        var s = t.apply(e, r)
        function a(u) {
          BT(s, i, n, a, o, 'next', u)
        }
        function o(u) {
          BT(s, i, n, a, o, 'throw', u)
        }
        a(void 0)
      })
    }
  }
  var { n: hG, classes: dG } = Me('icon')
  function mG(t, e) {
    return (
      l.openBlock(),
      l.createBlock(
        l.resolveDynamicComponent(t.isURL(t.name) ? 'img' : 'i'),
        {
          class: l.normalizeClass(
            t.classes(
              t.n(),
              t.namespace + '--set',
              [t.isURL(t.name), t.n('image'), t.namespace + '-' + t.nextName],
              [t.shrinking, t.n('--shrinking')]
            )
          ),
          style: l.normalizeStyle({
            color: t.color,
            transition: 'transform ' + t.toNumber(t.transition) + 'ms',
            width: t.isURL(t.name) ? t.toSizeUnit(t.size) : null,
            height: t.isURL(t.name) ? t.toSizeUnit(t.size) : null,
            fontSize: t.toSizeUnit(t.size),
          }),
          src: t.isURL(t.name) ? t.nextName : null,
          onClick: t.onClick,
        },
        null,
        8,
        ['class', 'style', 'src', 'onClick']
      )
    )
  }
  var kt = l.defineComponent({
    render: mG,
    name: 'VarIcon',
    props: DT,
    setup(t) {
      var e = l.ref(''),
        r = l.ref(!1),
        i = (function () {
          var n = fG(function* (s, a) {
            var { transition: o } = t
            if (a == null || Ee(o) === 0) {
              e.value = s
              return
            }
            ;(r.value = !0),
              yield l.nextTick(),
              setTimeout(() => {
                a != null && (e.value = s), (r.value = !1)
              }, Ee(o))
          })
          return function (a, o) {
            return n.apply(this, arguments)
          }
        })()
      return (
        l.watch(() => t.name, i, { immediate: !0 }),
        { n: hG, classes: dG, nextName: e, shrinking: r, isURL: jX, toNumber: Ee, toSizeUnit: xt }
      )
    },
  })
  kt.install = function (t) {
    t.component(kt.name, kt)
  }
  function Af() {
    return (
      (Af =
        Object.assign ||
        function (t) {
          for (var e = 1; e < arguments.length; e++) {
            var r = arguments[e]
            for (var i in r) Object.prototype.hasOwnProperty.call(r, i) && (t[i] = r[i])
          }
          return t
        }),
      Af.apply(this, arguments)
    )
  }
  var yG = Af(
      {
        show: { type: Boolean, default: !1 },
        actions: { type: Array, default: () => [] },
        title: { type: String },
        closeOnClickAction: { type: Boolean, default: !0 },
        onSelect: { type: Function },
        'onUpdate:show': { type: Function },
      },
      xr(Zs, [
        'overlay',
        'overlayClass',
        'overlayStyle',
        'lockScroll',
        'closeOnClickOverlay',
        'teleport',
        'onOpen',
        'onClose',
        'onOpened',
        'onClosed',
        'onClickOverlay',
        'onRouteChange',
      ])
    ),
    gG = {
      dialogTitle: '\u63D0\u793A',
      dialogConfirmButtonText: '\u786E\u8BA4',
      dialogCancelButtonText: '\u53D6\u6D88',
      actionSheetTitle: '\u8BF7\u9009\u62E9',
      listLoadingText: '\u52A0\u8F7D\u4E2D',
      listFinishedText: '\u6CA1\u6709\u66F4\u591A\u4E86',
      listErrorText: '\u52A0\u8F7D\u5931\u8D25',
      pickerTitle: '\u8BF7\u9009\u62E9',
      pickerConfirmButtonText: '\u786E\u8BA4',
      pickerCancelButtonText: '\u53D6\u6D88',
      datePickerMonthDict: {
        '01': { name: '\u4E00\u6708', abbr: '\u4E00\u6708' },
        '02': { name: '\u4E8C\u6708', abbr: '\u4E8C\u6708' },
        '03': { name: '\u4E09\u6708', abbr: '\u4E09\u6708' },
        '04': { name: '\u56DB\u6708', abbr: '\u56DB\u6708' },
        '05': { name: '\u4E94\u6708', abbr: '\u4E94\u6708' },
        '06': { name: '\u516D\u6708', abbr: '\u516D\u6708' },
        '07': { name: '\u4E03\u6708', abbr: '\u4E03\u6708' },
        '08': { name: '\u516B\u6708', abbr: '\u516B\u6708' },
        '09': { name: '\u4E5D\u6708', abbr: '\u4E5D\u6708' },
        10: { name: '\u5341\u6708', abbr: '\u5341\u6708' },
        11: { name: '\u5341\u4E00\u6708', abbr: '\u5341\u4E00\u6708' },
        12: { name: '\u5341\u4E8C\u6708', abbr: '\u5341\u4E8C\u6708' },
      },
      datePickerWeekDict: {
        0: { name: '\u661F\u671F\u65E5', abbr: '\u65E5' },
        1: { name: '\u661F\u671F\u4E00', abbr: '\u4E00' },
        2: { name: '\u661F\u671F\u4E8C', abbr: '\u4E8C' },
        3: { name: '\u661F\u671F\u4E09', abbr: '\u4E09' },
        4: { name: '\u661F\u671F\u56DB', abbr: '\u56DB' },
        5: { name: '\u661F\u671F\u4E94', abbr: '\u4E94' },
        6: { name: '\u661F\u671F\u516D', abbr: '\u516D' },
      },
      datePickerSelected: '\u4E2A\u88AB\u9009\u62E9',
      paginationItem: '\u6761',
      paginationPage: '\u9875',
      paginationJump: '\u524D\u5F80',
    }
  function Cf() {
    return (
      (Cf =
        Object.assign ||
        function (t) {
          for (var e = 1; e < arguments.length; e++) {
            var r = arguments[e]
            for (var i in r) Object.prototype.hasOwnProperty.call(r, i) && (t[i] = r[i])
          }
          return t
        }),
      Cf.apply(this, arguments)
    )
  }
  function TG() {
    var t = {},
      e = l.ref({}),
      r = (s, a) => {
        ;(a.lang = s), (t[s] = a)
      },
      i = (s) => {
        if (!t[s])
          return console.warn('The ' + s + ' does not exist. You can mount a language package using the add method'), {}
        e.value = t[s]
      },
      n = (s, a) => {
        if (!t[s]) {
          console.warn('The ' + s + ' does not exist. You can mount a language package using the add method')
          return
        }
        ;(t[s] = Cf({}, t[s], a)), i(s)
      }
    return { packs: t, pack: e, add: r, use: i, merge: n }
  }
  var { packs: Wne, pack: Xt, add: bG, use: SG, merge: Yne } = TG()
  bG('zh-CN', gG), SG('zh-CN')
  var { n: vG, classes: EG } = Me('action-sheet'),
    PG = ['onClick']
  function wG(t, e) {
    var r = l.resolveComponent('var-icon'),
      i = l.resolveComponent('var-popup'),
      n = l.resolveDirective('ripple')
    return (
      l.openBlock(),
      l.createBlock(
        i,
        l.mergeProps(
          {
            class: t.n('popup-radius'),
            position: 'bottom',
            overlay: t.overlay,
            'overlay-class': t.overlayClass,
            'overlay-style': t.overlayStyle,
            'lock-scroll': t.lockScroll,
            'close-on-click-overlay': t.closeOnClickOverlay,
            teleport: t.teleport,
            show: t.popupShow,
          },
          { 'onUpdate:show': t.handlePopupUpdateShow },
          {
            onOpen: t.onOpen,
            onClose: t.onClose,
            onClosed: t.onClosed,
            onOpened: t.onOpened,
            onRouteChange: t.onRouteChange,
          }
        ),
        {
          default: l.withCtx(() => [
            l.createElementVNode(
              'div',
              l.mergeProps({ class: t.classes(t.n(), 'var--box') }, t.$attrs),
              [
                l.renderSlot(t.$slots, 'title', {}, () => [
                  l.createElementVNode(
                    'div',
                    { class: l.normalizeClass(t.n('title')) },
                    l.toDisplayString(t.dt(t.title, t.pack.actionSheetTitle)),
                    3
                  ),
                ]),
                l.renderSlot(t.$slots, 'actions', {}, () => [
                  (l.openBlock(!0),
                  l.createElementBlock(
                    l.Fragment,
                    null,
                    l.renderList(t.actions, (s) =>
                      l.withDirectives(
                        (l.openBlock(),
                        l.createElementBlock(
                          'div',
                          {
                            class: l.normalizeClass(
                              t.classes(t.n('action-item'), s.className, [s.disabled, t.n('--disabled')])
                            ),
                            key: s.name,
                            style: l.normalizeStyle({ color: s.color }),
                            onClick: (a) => t.handleSelect(s),
                          },
                          [
                            s.icon
                              ? (l.openBlock(),
                                l.createBlock(
                                  r,
                                  {
                                    key: 0,
                                    class: l.normalizeClass(t.n('action-icon')),
                                    'var-action-sheet-cover': '',
                                    name: s.icon,
                                    size: s.iconSize,
                                  },
                                  null,
                                  8,
                                  ['class', 'name', 'size']
                                ))
                              : l.createCommentVNode('v-if', !0),
                            l.createElementVNode(
                              'div',
                              { class: l.normalizeClass(t.n('action-name')) },
                              l.toDisplayString(s.name),
                              3
                            ),
                          ],
                          14,
                          PG
                        )),
                        [[n, { disabled: s.disabled }]]
                      )
                    ),
                    128
                  )),
                ]),
              ],
              16
            ),
          ]),
          _: 3,
        },
        16,
        [
          'class',
          'overlay',
          'overlay-class',
          'overlay-style',
          'lock-scroll',
          'close-on-click-overlay',
          'teleport',
          'show',
          'onOpen',
          'onClose',
          'onClosed',
          'onOpened',
          'onRouteChange',
        ]
      )
    )
  }
  var xf = l.defineComponent({
    render: wG,
    name: 'VarActionSheet',
    directives: { Ripple: tr },
    components: { VarPopup: Ni, VarIcon: kt },
    inheritAttrs: !1,
    props: yG,
    setup(t) {
      var e = l.ref(!1),
        r = (n) => {
          if (!n.disabled) {
            var { closeOnClickAction: s, onSelect: a } = t
            he(a, n), s && he(t['onUpdate:show'], !1)
          }
        },
        i = (n) => he(t['onUpdate:show'], n)
      return (
        l.watch(
          () => t.show,
          (n) => {
            e.value = n
          },
          { immediate: !0 }
        ),
        { n: vG, classes: EG, handlePopupUpdateShow: i, popupShow: e, pack: Xt, dt: gl, handleSelect: r }
      )
    },
  })
  xf.install = function (t) {
    t.component(xf.name, xf)
  }
  function AG(t) {
    var e = ['left', 'center', 'right']
    return e.includes(t)
  }
  var CG = {
      color: { type: String },
      textColor: { type: String },
      title: { type: String },
      titlePosition: { type: String, default: 'left', validator: AG },
      elevation: { type: Boolean, default: !0 },
    },
    { n: xG, classes: IG } = Me('app-bar')
  function kG(t, e) {
    return (
      l.openBlock(),
      l.createElementBlock(
        'div',
        {
          class: l.normalizeClass(t.classes(t.n(), [t.elevation, 'var-elevation--3'])),
          style: l.normalizeStyle({ background: t.color, color: t.textColor }),
        },
        [
          l.createElementVNode(
            'div',
            { class: l.normalizeClass(t.n('left')) },
            [
              l.renderSlot(t.$slots, 'left'),
              t.titlePosition === 'left'
                ? (l.openBlock(),
                  l.createElementBlock(
                    'div',
                    {
                      key: 0,
                      class: l.normalizeClass(t.n('title')),
                      style: l.normalizeStyle({ paddingLeft: t.paddingLeft }),
                    },
                    [l.renderSlot(t.$slots, 'default', {}, () => [l.createTextVNode(l.toDisplayString(t.title), 1)])],
                    6
                  ))
                : l.createCommentVNode('v-if', !0),
            ],
            2
          ),
          t.titlePosition === 'center'
            ? (l.openBlock(),
              l.createElementBlock(
                'div',
                { key: 0, class: l.normalizeClass(t.n('title')) },
                [l.renderSlot(t.$slots, 'default', {}, () => [l.createTextVNode(l.toDisplayString(t.title), 1)])],
                2
              ))
            : l.createCommentVNode('v-if', !0),
          l.createElementVNode(
            'div',
            { class: l.normalizeClass(t.n('right')) },
            [
              t.titlePosition === 'right'
                ? (l.openBlock(),
                  l.createElementBlock(
                    'div',
                    {
                      key: 0,
                      class: l.normalizeClass(t.n('title')),
                      style: l.normalizeStyle({ paddingRight: t.paddingRight }),
                    },
                    [l.renderSlot(t.$slots, 'default', {}, () => [l.createTextVNode(l.toDisplayString(t.title), 1)])],
                    6
                  ))
                : l.createCommentVNode('v-if', !0),
              l.renderSlot(t.$slots, 'right'),
            ],
            2
          ),
        ],
        6
      )
    )
  }
  var If = l.defineComponent({
    render: kG,
    name: 'VarAppBar',
    props: CG,
    setup(t, e) {
      var { slots: r } = e,
        i = l.ref(),
        n = l.ref(),
        s = () => {
          ;(i.value = r.left ? 0 : void 0), (n.value = r.right ? 0 : void 0)
        }
      return l.onMounted(s), l.onUpdated(s), { n: xG, classes: IG, paddingLeft: i, paddingRight: n }
    },
  })
  If.install = function (t) {
    t.component(If.name, If)
  }
  function NG(t) {
    return ['circle', 'wave', 'cube', 'rect', 'disappear'].includes(t)
  }
  function OG(t) {
    return ['normal', 'mini', 'small', 'large'].includes(t)
  }
  var Qs = {
      type: { type: String, default: 'circle', validator: NG },
      radius: { type: [String, Number] },
      size: { type: String, default: 'normal', validator: OG },
      color: { type: String, default: 'currentColor' },
      description: { type: String },
      loading: { type: Boolean, default: !1 },
    },
    { n: DG, classes: BG } = Me('loading'),
    LG = (t) => (l.pushScopeId(''), (t = t()), l.popScopeId(), t),
    MG = LG(() =>
      l.createElementVNode(
        'svg',
        { viewBox: '25 25 50 50' },
        [l.createElementVNode('circle', { cx: '50', cy: '50', r: '20', fill: 'none' })],
        -1
      )
    ),
    FG = [MG]
  function $G(t, e) {
    return (
      l.openBlock(),
      l.createElementBlock(
        'div',
        { class: l.normalizeClass(t.n()) },
        [
          t.$slots.default
            ? (l.openBlock(),
              l.createElementBlock(
                'div',
                { key: 0, class: l.normalizeClass(t.classes(t.n('content'), [t.loading, t.n('content--active')])) },
                [
                  l.renderSlot(t.$slots, 'default'),
                  t.loading
                    ? (l.openBlock(),
                      l.createElementBlock('div', { key: 0, class: l.normalizeClass(t.n('content-mask')) }, null, 2))
                    : l.createCommentVNode('v-if', !0),
                ],
                2
              ))
            : l.createCommentVNode('v-if', !0),
          t.isShow
            ? (l.openBlock(),
              l.createElementBlock(
                'div',
                {
                  key: 1,
                  class: l.normalizeClass(t.classes('var--box', t.n('body'), [t.$slots.default, t.n('inside')])),
                },
                [
                  t.type === 'circle'
                    ? (l.openBlock(),
                      l.createElementBlock(
                        'div',
                        { key: 0, class: l.normalizeClass(t.n('circle')) },
                        [
                          l.createElementVNode(
                            'span',
                            {
                              class: l.normalizeClass(t.classes(t.n('circle-block'), t.n('circle-block--' + t.size))),
                              style: l.normalizeStyle({
                                width: t.multiplySizeUnit(t.radius, 2),
                                height: t.multiplySizeUnit(t.radius, 2),
                                color: t.color,
                              }),
                            },
                            FG,
                            6
                          ),
                        ],
                        2
                      ))
                    : l.createCommentVNode('v-if', !0),
                  (l.openBlock(!0),
                  l.createElementBlock(
                    l.Fragment,
                    null,
                    l.renderList(
                      t.loadingTypeDict,
                      (r, i) => (
                        l.openBlock(),
                        l.createElementBlock(
                          l.Fragment,
                          { key: i },
                          [
                            t.type === i
                              ? (l.openBlock(),
                                l.createElementBlock(
                                  'div',
                                  { key: 0, class: l.normalizeClass(t.classes(t.n(i), t.n(i + '--' + t.size))) },
                                  [
                                    (l.openBlock(!0),
                                    l.createElementBlock(
                                      l.Fragment,
                                      null,
                                      l.renderList(
                                        r,
                                        (n) => (
                                          l.openBlock(),
                                          l.createElementBlock(
                                            'div',
                                            {
                                              key: n + i,
                                              style: l.normalizeStyle({ backgroundColor: t.color }),
                                              class: l.normalizeClass(
                                                t.classes(t.n(i + '-item'), t.n(i + '-item--' + t.size))
                                              ),
                                            },
                                            null,
                                            6
                                          )
                                        )
                                      ),
                                      128
                                    )),
                                  ],
                                  2
                                ))
                              : l.createCommentVNode('v-if', !0),
                          ],
                          64
                        )
                      )
                    ),
                    128
                  )),
                  t.$slots.description || t.description
                    ? (l.openBlock(),
                      l.createElementBlock(
                        'div',
                        {
                          key: 1,
                          class: l.normalizeClass(t.classes(t.n('description'), t.n('description--' + t.size))),
                          style: l.normalizeStyle({ color: t.color }),
                        },
                        [
                          l.renderSlot(t.$slots, 'description', {}, () => [
                            l.createTextVNode(l.toDisplayString(t.description), 1),
                          ]),
                        ],
                        6
                      ))
                    : l.createCommentVNode('v-if', !0),
                ],
                2
              ))
            : l.createCommentVNode('v-if', !0),
        ],
        2
      )
    )
  }
  var mn = l.defineComponent({
    render: $G,
    name: 'VarLoading',
    props: Qs,
    setup(t, e) {
      var { slots: r } = e,
        i = { wave: 5, cube: 4, rect: 8, disappear: 3 },
        n = l.computed(() => (he(r.default) ? t.loading : !0))
      return { n: DG, classes: BG, multiplySizeUnit: qt, loadingTypeDict: i, isShow: n }
    },
  })
  mn.install = function (t) {
    t.component(mn.name, mn)
  }
  function RG(t) {
    return ['default', 'primary', 'info', 'success', 'warning', 'danger'].includes(t)
  }
  function jG(t) {
    return ['normal', 'mini', 'small', 'large'].includes(t)
  }
  var _G = {
      type: { type: String, default: 'default', validator: RG },
      size: { type: String, default: 'normal', validator: jG },
      loading: { type: Boolean, default: !1 },
      round: { type: Boolean, default: !1 },
      block: { type: Boolean, default: !1 },
      text: { type: Boolean, default: !1 },
      outline: { type: Boolean, default: !1 },
      disabled: { type: Boolean, default: !1 },
      ripple: { type: Boolean, default: !0 },
      color: { type: String },
      textColor: { type: String },
      autoLoading: { type: Boolean, default: !1 },
      loadingRadius: { type: [Number, String], default: 12 },
      loadingType: xr(Qs, 'type'),
      loadingSize: xr(Qs, 'size'),
      onClick: { type: Function },
      onTouchstart: { type: Function },
    },
    { n: VG, classes: UG } = Me('button'),
    zG = ['disabled']
  function KG(t, e) {
    var r = l.resolveComponent('var-loading'),
      i = l.resolveDirective('ripple')
    return l.withDirectives(
      (l.openBlock(),
      l.createElementBlock(
        'button',
        {
          class: l.normalizeClass(
            t.classes(
              t.n(),
              'var--box',
              t.n('--' + t.size),
              [t.block, 'var--flex ' + t.n('--block'), 'var--inline-flex'],
              [t.disabled, t.n('--disabled')],
              [t.text, t.n('--text-' + t.type) + ' ' + t.n('--text'), t.n('--' + t.type) + ' var-elevation--2'],
              [t.text && t.disabled, t.n('--text-disabled')],
              [t.round, t.n('--round')],
              [t.outline, t.n('--outline')]
            )
          ),
          style: l.normalizeStyle({ color: t.textColor, background: t.color }),
          disabled: t.disabled,
          onClick:
            e[0] ||
            (e[0] = function () {
              return t.handleClick && t.handleClick(...arguments)
            }),
          onTouchstart:
            e[1] ||
            (e[1] = function () {
              return t.handleTouchstart && t.handleTouchstart(...arguments)
            }),
        },
        [
          t.loading || t.pending
            ? (l.openBlock(),
              l.createBlock(
                r,
                {
                  key: 0,
                  class: l.normalizeClass(t.n('loading')),
                  'var-button-cover': '',
                  type: t.loadingType,
                  size: t.loadingSize,
                  radius: t.loadingRadius,
                },
                null,
                8,
                ['class', 'type', 'size', 'radius']
              ))
            : l.createCommentVNode('v-if', !0),
          l.createElementVNode(
            'div',
            { class: l.normalizeClass(t.classes(t.n('content'), [t.loading || t.pending, t.n('--hidden')])) },
            [l.renderSlot(t.$slots, 'default')],
            2
          ),
        ],
        46,
        zG
      )),
      [[i, { disabled: t.disabled || !t.ripple }]]
    )
  }
  var Er = l.defineComponent({
    render: KG,
    name: 'VarButton',
    components: { VarLoading: mn },
    directives: { Ripple: tr },
    props: _G,
    setup(t) {
      var e = l.ref(!1),
        r = (s) => {
          t.autoLoading &&
            ((e.value = !0),
            Promise.resolve(s).finally(() => {
              e.value = !1
            }))
        },
        i = (s) => {
          var { loading: a, disabled: o, onClick: u } = t
          !u || a || o || e.value || r(u(s))
        },
        n = (s) => {
          var { loading: a, disabled: o, onTouchstart: u } = t
          !u || a || o || e.value || r(u(s))
        }
      return { n: VG, classes: UG, pending: e, handleClick: i, handleTouchstart: n }
    },
  })
  Er.install = function (t) {
    t.component(Er.name, Er)
  }
  var WG = {
      visibilityHeight: { type: [Number, String], default: 200 },
      duration: { type: Number, default: 300 },
      right: { type: [Number, String] },
      bottom: { type: [Number, String] },
      target: { type: [String, Object] },
      onClick: { type: Function },
    },
    { n: YG, classes: HG } = Me('back-top')
  function qG(t, e) {
    var r = l.resolveComponent('var-icon'),
      i = l.resolveComponent('var-button')
    return (
      l.openBlock(),
      l.createBlock(
        l.Teleport,
        { to: 'body', disabled: t.disabled },
        [
          l.createElementVNode(
            'div',
            {
              class: l.normalizeClass(t.classes(t.n(), [t.show, t.n('--active')])),
              ref: 'backTopEl',
              style: l.normalizeStyle({ right: t.toSizeUnit(t.right), bottom: t.toSizeUnit(t.bottom) }),
              onClick:
                e[0] ||
                (e[0] = l.withModifiers(
                  function () {
                    return t.click && t.click(...arguments)
                  },
                  ['stop']
                )),
            },
            [
              l.renderSlot(t.$slots, 'default', {}, () => [
                l.createVNode(
                  i,
                  { type: 'primary', round: '', 'var-back-top-cover': '' },
                  { default: l.withCtx(() => [l.createVNode(r, { name: 'chevron-up' })]), _: 1 }
                ),
              ]),
            ],
            6
          ),
        ],
        8,
        ['disabled']
      )
    )
  }
  var kf = l.defineComponent({
    render: qG,
    name: 'VarBackTop',
    components: { VarButton: Er, VarIcon: kt },
    props: WG,
    setup(t) {
      var e = l.ref(!1),
        r = l.ref(null),
        i = l.ref(!0),
        n,
        s = (c) => {
          he(t.onClick, c)
          var p = yf(n)
          bl(n, { left: p, duration: t.duration, animation: yT })
        },
        a = () => {
          e.value = Tl(n) >= Mt(t.visibilityHeight)
        },
        o = mf(a, 200),
        u = () => {
          var { target: c } = t
          if (Tr(c)) {
            var p = document.querySelector(t.target)
            if (!p) throw Error('[Varlet] BackTop: target element cannot found')
            return p
          }
          if (RX(c)) return c
          throw Error('[Varlet] BackTop: type of prop "target" should be a selector or an element object')
        }
      return (
        l.onMounted(() => {
          ;(n = t.target ? u() : Wn(r.value)), n.addEventListener('scroll', o), (i.value = !1)
        }),
        l.onBeforeUnmount(() => {
          n.removeEventListener('scroll', o)
        }),
        { disabled: i, show: e, backTopEl: r, toSizeUnit: xt, n: YG, classes: HG, click: s }
      )
    },
  })
  kf.install = function (t) {
    t.component(kf.name, kf)
  }
  function XG(t) {
    return ['default', 'primary', 'info', 'success', 'warning', 'danger'].includes(t)
  }
  function GG(t) {
    return ['right-top', 'right-bottom', 'left-top', 'left-bottom'].includes(t)
  }
  var JG = {
      type: { type: String, default: 'default', validator: XG },
      hidden: { type: Boolean, default: !1 },
      dot: { type: Boolean, default: !1 },
      value: { type: [String, Number], default: 0 },
      maxValue: { type: [String, Number] },
      color: { type: String },
      position: { type: String, default: 'right-top', validator: GG },
      icon: { type: String },
    },
    { n: Oi, classes: ZG } = Me('badge'),
    QG = { key: 1 }
  function eJ(t, e) {
    var r = l.resolveComponent('var-icon')
    return (
      l.openBlock(),
      l.createElementBlock(
        'div',
        { class: l.normalizeClass(t.classes(t.n(), 'var--box')) },
        [
          l.createVNode(
            l.Transition,
            { name: 'var-badge-fade' },
            {
              default: l.withCtx(() => [
                l.withDirectives(
                  l.createElementVNode(
                    'span',
                    l.mergeProps(t.$attrs, {
                      class: t.classes(t.n('content'), ...t.contentClass),
                      style: { background: t.color },
                    }),
                    [
                      t.icon && !t.dot
                        ? (l.openBlock(), l.createBlock(r, { key: 0, name: t.icon, size: '10px' }, null, 8, ['name']))
                        : (l.openBlock(), l.createElementBlock('span', QG, l.toDisplayString(t.values), 1)),
                    ],
                    16
                  ),
                  [[l.vShow, !t.hidden]]
                ),
              ]),
              _: 1,
            }
          ),
          l.renderSlot(t.$slots, 'default'),
        ],
        2
      )
    )
  }
  var Cl = l.defineComponent({
    render: eJ,
    name: 'VarBadge',
    components: { VarIcon: kt },
    inheritAttrs: !1,
    props: JG,
    setup(t, e) {
      var { slots: r } = e,
        i = l.computed(() => {
          var { type: a, position: o, dot: u, icon: c } = t,
            p = r.default && Oi('position') + ' ' + Oi('--' + o),
            h = u ? Oi('dot') : null,
            f = s(),
            d = c ? Oi('icon') : null
          return [Oi('--' + a), p, h, f, d]
        }),
        n = l.computed(() => {
          var { dot: a, value: o, maxValue: u } = t
          return a ? '' : o !== void 0 && u !== void 0 && Ee(o) > u ? u + '+' : o
        }),
        s = () => {
          var { position: a, dot: o } = t
          if (o && a.includes('right')) return Oi('dot--right')
          if (o && a.includes('left')) return Oi('dot--left')
        }
      return { n: Oi, classes: ZG, values: n, contentClass: i }
    },
  })
  Cl.install = function (t) {
    t.component(Cl.name, Cl)
  }
  var tJ = {
      active: { type: [Number, String], default: 0 },
      fixed: { type: Boolean, default: !1 },
      border: { type: Boolean, default: !1 },
      safeArea: { type: Boolean, default: !1 },
      zIndex: { type: [Number, String], default: 1 },
      activeColor: { type: String },
      inactiveColor: { type: String },
      onChange: { type: Function },
      'onUpdate:active': { type: Function },
      onBeforeChange: { type: Function },
      onFabClick: { type: Function },
      fabProps: { type: Object },
    },
    LT = Symbol('BOTTOM_NAVIGATION_BIND_BOTTOM_NAVIGATION_ITEM_KEY'),
    MT = Symbol('BOTTOM_NAVIGATION_COUNT_BOTTOM_NAVIGATION_ITEM_KEY')
  function rJ() {
    var { childProviders: t, bindChildren: e } = Sr(LT),
      { length: r } = Ir(MT)
    return { length: r, bottomNavigationItems: t, bindBottomNavigationItem: e }
  }
  function Nf() {
    return (
      (Nf =
        Object.assign ||
        function (t) {
          for (var e = 1; e < arguments.length; e++) {
            var r = arguments[e]
            for (var i in r) Object.prototype.hasOwnProperty.call(r, i) && (t[i] = r[i])
          }
          return t
        }),
      Nf.apply(this, arguments)
    )
  }
  var { n: iJ, classes: nJ } = Me('bottom-navigation'),
    { n: xl } = Me('bottom-navigation-item'),
    FT = xl('--right-half-space'),
    $T = xl('--left-half-space'),
    RT = xl('--right-space'),
    sJ = { type: 'primary' }
  function aJ(t, e) {
    var r = l.resolveComponent('var-button')
    return (
      l.openBlock(),
      l.createElementBlock(
        'div',
        {
          class: l.normalizeClass(
            t.classes(t.n(), [t.fixed, t.n('--fixed')], [t.border, t.n('--border')], [t.safeArea, t.n('--safe-area')])
          ),
          ref: 'bottomNavigationDom',
          style: l.normalizeStyle('z-index:' + t.zIndex),
        },
        [
          l.renderSlot(t.$slots, 'default'),
          t.$slots.fab
            ? (l.openBlock(),
              l.createBlock(
                r,
                l.mergeProps(
                  {
                    key: 0,
                    class: t.classes(t.n('fab'), [t.length % 2, t.n('--fab-right'), t.n('--fab-center')]),
                    'var-bottom-navigation__fab': '',
                    onClick: t.handleFabClick,
                  },
                  t.fabProps,
                  { round: '' }
                ),
                { default: l.withCtx(() => [l.renderSlot(t.$slots, 'fab')]), _: 3 },
                16,
                ['class', 'onClick']
              ))
            : l.createCommentVNode('v-if', !0),
        ],
        6
      )
    )
  }
  var Of = l.defineComponent({
    render: aJ,
    name: 'VarBottomNavigation',
    components: { VarButton: Er },
    props: tJ,
    setup(t, e) {
      var { slots: r } = e,
        i = l.ref(null),
        n = l.computed(() => t.active),
        s = l.computed(() => t.activeColor),
        a = l.computed(() => t.inactiveColor),
        o = l.ref({}),
        { length: u, bottomNavigationItems: c, bindBottomNavigationItem: p } = rJ(),
        h = () => {
          u.value === 0 || f() || d() || T()
        },
        f = () =>
          c.find((I) => {
            var { name: B } = I
            return n.value === B.value
          }),
        d = () =>
          c.find((I) => {
            var { index: B } = I
            return n.value === B.value
          }),
        T = () => {
          !br(n.value) ||
            (n.value < 0 ? he(t['onUpdate:active'], 0) : n.value > u.value - 1 && he(t['onUpdate:active'], u.value - 1))
        },
        y = (I) => {
          t.onBeforeChange ? b(I) : m(I)
        },
        b = (I) => {
          Promise.resolve(he(t.onBeforeChange, I)).then((B) => B && m(I))
        },
        m = (I) => {
          he(t['onUpdate:active'], I), he(t.onChange, I)
        },
        S = () => {
          var I = x()
          I.forEach((B) => {
            B.classList.remove(FT, $T, RT)
          })
        },
        E = (I) => {
          var B = x(),
            K = B.length,
            Y = I % 2 === 0
          B.forEach((C, H) => {
            P(Y, C, H, K)
          })
        },
        P = (I, B, K, Y) => {
          var C = K === Y - 1
          if (!I && C) {
            B.classList.add(RT)
            return
          }
          var H = K === Y / 2 - 1,
            w = K === Y / 2
          H ? B.classList.add(FT) : w && B.classList.add($T)
        },
        x = () => Array.from(i.value.querySelectorAll('.' + xl())),
        D = () => {
          he(t.onFabClick)
        },
        N = { active: n, activeColor: s, inactiveColor: a, onToggle: y }
      return (
        p(N),
        l.watch(() => u.value, h),
        l.watch(
          () => t.fabProps,
          (I) => {
            o.value = Nf({}, sJ, I)
          },
          { immediate: !0, deep: !0 }
        ),
        l.onMounted(() => {
          !r.fab || E(u.value)
        }),
        l.onUpdated(() => {
          S(), r.fab && E(u.value)
        }),
        { n: iJ, classes: nJ, length: u, bottomNavigationDom: i, handleFabClick: D, fabProps: o }
      )
    },
  })
  Of.install = function (t) {
    t.component(Of.name, Of)
  }
  var oJ = {
    name: { type: String },
    icon: { type: String },
    label: { type: String },
    namespace: { type: String, default: 'var-icon' },
    badge: { type: [Boolean, Object], default: !1 },
    onClick: { type: Function },
  }
  function lJ() {
    var { parentProvider: t, bindParent: e } = vr(LT),
      { index: r } = kr(MT)
    if (!t || !e || !r) throw Error('<var-bottom-navigation-item/> must in <var-bottom-navigation/>')
    return { index: r, bottomNavigation: t, bindBottomNavigation: e }
  }
  var { n: uJ, classes: cJ } = Me('bottom-navigation-item'),
    pJ = { type: 'danger', dot: !0 }
  function fJ(t, e) {
    var r = l.resolveComponent('var-icon'),
      i = l.resolveComponent('var-badge'),
      n = l.resolveDirective('ripple')
    return l.withDirectives(
      (l.openBlock(),
      l.createElementBlock(
        'button',
        {
          class: l.normalizeClass(t.classes(t.n(), [t.active === t.index || t.active === t.name, t.n('--active')])),
          style: l.normalizeStyle({ color: t.computeColorStyle() }),
          onClick:
            e[0] ||
            (e[0] = function () {
              return t.handleClick && t.handleClick(...arguments)
            }),
        },
        [
          t.icon && !t.$slots.icon
            ? (l.openBlock(),
              l.createBlock(
                r,
                {
                  key: 0,
                  name: t.icon,
                  namespace: t.namespace,
                  class: l.normalizeClass(t.n('icon')),
                  'var-bottom-navigation-item-cover': '',
                },
                null,
                8,
                ['name', 'namespace', 'class']
              ))
            : l.createCommentVNode('v-if', !0),
          l.renderSlot(t.$slots, 'icon', { active: t.active === t.index || t.active === t.name }),
          t.badge
            ? (l.openBlock(),
              l.createBlock(
                i,
                l.mergeProps({ key: 1 }, t.badgeProps, { class: t.n('badge'), 'var-bottom-navigation-item-cover': '' }),
                null,
                16,
                ['class']
              ))
            : l.createCommentVNode('v-if', !0),
          l.createElementVNode(
            'span',
            { class: l.normalizeClass(t.n('label')) },
            [
              t.$slots.default
                ? l.createCommentVNode('v-if', !0)
                : (l.openBlock(),
                  l.createElementBlock(
                    l.Fragment,
                    { key: 0 },
                    [l.createTextVNode(l.toDisplayString(t.label), 1)],
                    2112
                  )),
              l.renderSlot(t.$slots, 'default'),
            ],
            2
          ),
        ],
        6
      )),
      [[n]]
    )
  }
  var Df = l.defineComponent({
    render: fJ,
    name: 'VarBottomNavigationItem',
    components: { VarBadge: Cl, VarIcon: kt },
    directives: { Ripple: tr },
    props: oJ,
    setup(t) {
      var e = l.computed(() => t.name),
        r = l.computed(() => t.badge),
        i = l.ref({}),
        { index: n, bottomNavigation: s, bindBottomNavigation: a } = lJ(),
        { active: o, activeColor: u, inactiveColor: c } = s,
        p = { name: e, index: n },
        h = () => (o.value === e.value || o.value === n.value ? u.value : c.value),
        f = () => {
          var d,
            T = (d = e.value) != null ? d : n.value
          he(t.onClick, T), he(s.onToggle, T)
        }
      return (
        a(p),
        l.watch(
          () => r.value,
          (d) => {
            i.value = d === !0 ? pJ : r.value
          },
          { immediate: !0 }
        ),
        { n: uJ, classes: cJ, index: n, active: o, badge: r, badgeProps: i, computeColorStyle: h, handleClick: f }
      )
    },
  })
  Df.install = function (t) {
    t.component(Df.name, Df)
  }
  function hJ(t) {
    return ['fill', 'contain', 'cover', 'none', 'scale-down'].includes(t)
  }
  var dJ = {
    src: { type: String },
    fit: { type: String, validator: hJ, default: 'cover' },
    height: { type: [String, Number] },
    imageHeight: { type: [String, Number] },
    imageWidth: { type: [String, Number] },
    layout: { type: String, default: 'column' },
    floating: { type: Boolean, default: !1 },
    'onUpdate:floating': { type: Function },
    floatingDuration: { type: Number, default: 250 },
    alt: { type: String },
    title: { type: String },
    subtitle: { type: String },
    description: { type: String },
    elevation: { type: [Number, String] },
    ripple: { type: Boolean, default: !1 },
    onClick: { type: Function },
  }
  function jT(t, e, r, i, n, s, a) {
    try {
      var o = t[s](a),
        u = o.value
    } catch (c) {
      r(c)
      return
    }
    o.done ? e(u) : Promise.resolve(u).then(i, n)
  }
  function _T(t) {
    return function () {
      var e = this,
        r = arguments
      return new Promise(function (i, n) {
        var s = t.apply(e, r)
        function a(u) {
          jT(s, i, n, a, o, 'next', u)
        }
        function o(u) {
          jT(s, i, n, a, o, 'throw', u)
        }
        a(void 0)
      })
    }
  }
  var { n: mJ, classes: yJ } = Me('card'),
    gJ = 500,
    TJ = ['src', 'alt']
  function bJ(t, e) {
    var r = l.resolveComponent('var-icon'),
      i = l.resolveComponent('var-button'),
      n = l.resolveDirective('ripple')
    return l.withDirectives(
      (l.openBlock(),
      l.createElementBlock(
        'div',
        {
          ref: 'card',
          class: l.normalizeClass(
            t.classes(
              t.n(),
              [t.isRow, t.n('--layout-row')],
              [t.elevation, 'var-elevation--' + t.elevation, 'var-elevation--1']
            )
          ),
          style: l.normalizeStyle({ zIndex: t.floated ? t.zIndex : void 0 }),
          onClick:
            e[0] ||
            (e[0] = function () {
              return t.onClick && t.onClick(...arguments)
            }),
        },
        [
          l.createElementVNode(
            'div',
            {
              ref: 'cardFloater',
              class: l.normalizeClass(t.classes(t.n('floater'))),
              style: l.normalizeStyle({
                width: t.floaterWidth,
                height: t.floaterHeight,
                top: t.floaterTop,
                left: t.floaterLeft,
                overflow: t.floaterOverflow,
                position: t.floaterPosition,
                transition: t.floated
                  ? 'background-color ' +
                    t.floatingDuration +
                    'ms, width ' +
                    t.floatingDuration +
                    'ms, height ' +
                    t.floatingDuration +
                    'ms, top ' +
                    t.floatingDuration +
                    'ms, left ' +
                    t.floatingDuration +
                    'ms'
                  : void 0,
              }),
            },
            [
              l.renderSlot(t.$slots, 'image', {}, () => {
                var s
                return [
                  t.src
                    ? (l.openBlock(),
                      l.createElementBlock(
                        'img',
                        {
                          key: 0,
                          class: l.normalizeClass(t.n('image')),
                          style: l.normalizeStyle({
                            objectFit: t.fit,
                            height: t.toSizeUnit((s = t.imageHeight) != null ? s : t.height),
                            width: t.toSizeUnit(t.imageWidth),
                          }),
                          src: t.src,
                          alt: t.alt,
                        },
                        null,
                        14,
                        TJ
                      ))
                    : l.createCommentVNode('v-if', !0),
                ]
              }),
              l.createElementVNode(
                'div',
                { class: l.normalizeClass(t.n('container')) },
                [
                  l.renderSlot(t.$slots, 'title', {}, () => [
                    t.title
                      ? (l.openBlock(),
                        l.createElementBlock(
                          'div',
                          { key: 0, class: l.normalizeClass(t.n('title')) },
                          l.toDisplayString(t.title),
                          3
                        ))
                      : l.createCommentVNode('v-if', !0),
                  ]),
                  l.renderSlot(t.$slots, 'subtitle', {}, () => [
                    t.subtitle
                      ? (l.openBlock(),
                        l.createElementBlock(
                          'div',
                          { key: 0, class: l.normalizeClass(t.n('subtitle')) },
                          l.toDisplayString(t.subtitle),
                          3
                        ))
                      : l.createCommentVNode('v-if', !0),
                  ]),
                  l.renderSlot(t.$slots, 'description', {}, () => [
                    t.description
                      ? (l.openBlock(),
                        l.createElementBlock(
                          'div',
                          { key: 0, class: l.normalizeClass(t.n('description')) },
                          l.toDisplayString(t.description),
                          3
                        ))
                      : l.createCommentVNode('v-if', !0),
                  ]),
                  t.$slots.extra
                    ? (l.openBlock(),
                      l.createElementBlock(
                        'div',
                        { key: 0, class: l.normalizeClass(t.n('footer')) },
                        [l.renderSlot(t.$slots, 'extra')],
                        2
                      ))
                    : l.createCommentVNode('v-if', !0),
                  t.$slots.content && !t.isRow
                    ? (l.openBlock(),
                      l.createElementBlock(
                        'div',
                        {
                          key: 1,
                          class: l.normalizeClass(t.n('content')),
                          style: l.normalizeStyle({
                            height: t.contentHeight,
                            opacity: t.opacity,
                            transition: 'opacity ' + t.floatingDuration * 2 + 'ms',
                          }),
                        },
                        [l.renderSlot(t.$slots, 'content')],
                        6
                      ))
                    : l.createCommentVNode('v-if', !0),
                ],
                2
              ),
              t.showFloatingButtons
                ? (l.openBlock(),
                  l.createElementBlock(
                    'div',
                    {
                      key: 0,
                      class: l.normalizeClass(t.classes(t.n('floating-buttons'), 'var--box')),
                      style: l.normalizeStyle({
                        zIndex: t.zIndex,
                        opacity: t.opacity,
                        transition: 'opacity ' + t.floatingDuration * 2 + 'ms',
                      }),
                    },
                    [
                      l.renderSlot(t.$slots, 'close-button', {}, () => [
                        l.createVNode(
                          i,
                          {
                            'var-card-cover': '',
                            round: '',
                            class: l.normalizeClass(t.classes(t.n('close-button'), 'var-elevation--6')),
                            onClick: l.withModifiers(t.close, ['stop']),
                          },
                          {
                            default: l.withCtx(() => [
                              l.createVNode(
                                r,
                                {
                                  'var-card-cover': '',
                                  name: 'window-close',
                                  class: l.normalizeClass(t.n('close-button-icon')),
                                },
                                null,
                                8,
                                ['class']
                              ),
                            ]),
                            _: 1,
                          },
                          8,
                          ['class', 'onClick']
                        ),
                      ]),
                    ],
                    6
                  ))
                : l.createCommentVNode('v-if', !0),
            ],
            6
          ),
          l.createElementVNode(
            'div',
            {
              class: l.normalizeClass(t.n('holder')),
              style: l.normalizeStyle({ width: t.holderWidth, height: t.holderHeight }),
            },
            null,
            6
          ),
        ],
        6
      )),
      [[n, { disabled: !t.ripple || t.floater }]]
    )
  }
  var Bf = l.defineComponent({
    render: bJ,
    name: 'VarCard',
    directives: { Ripple: tr },
    components: { VarIcon: kt, VarButton: Er },
    props: dJ,
    setup(t) {
      var e = l.ref(null),
        r = l.ref(null),
        i = l.ref('auto'),
        n = l.ref('auto'),
        s = l.ref('100%'),
        a = l.ref('100%'),
        o = l.ref('auto'),
        u = l.ref('auto'),
        c = l.ref(void 0),
        p = l.ref('hidden'),
        h = l.ref('0px'),
        f = l.ref('0'),
        { zIndex: d } = wl(() => t.floating, 1),
        T = l.computed(() => t.layout === 'row'),
        y = l.ref(!1),
        b = l.ref(!1)
      Ef(
        () => t.floating,
        () => T
      )
      var m = 'auto',
        S = 'auto',
        E = null,
        P = l.ref(null),
        x = (function () {
          var I = _T(function* () {
            clearTimeout(P.value),
              clearTimeout(E),
              (P.value = null),
              (P.value = setTimeout(
                _T(function* () {
                  var { width: B, height: K, left: Y, top: C } = e.value.getBoundingClientRect()
                  ;(i.value = xt(B)),
                    (n.value = xt(K)),
                    (s.value = i.value),
                    (a.value = n.value),
                    (o.value = xt(C)),
                    (u.value = xt(Y)),
                    (c.value = 'fixed'),
                    (m = o.value),
                    (S = u.value),
                    (y.value = !0),
                    yield dn(),
                    (o.value = '0'),
                    (u.value = '0'),
                    (s.value = '100vw'),
                    (a.value = '100vh'),
                    (h.value = 'auto'),
                    (f.value = '1'),
                    (p.value = 'auto'),
                    (b.value = !0)
                }),
                t.ripple ? gJ : 0
              ))
          })
          return function () {
            return I.apply(this, arguments)
          }
        })(),
        D = () => {
          clearTimeout(E),
            clearTimeout(P.value),
            (P.value = null),
            (s.value = i.value),
            (a.value = n.value),
            (o.value = m),
            (u.value = S),
            (h.value = '0px'),
            (f.value = '0'),
            (y.value = !1),
            (E = setTimeout(() => {
              ;(i.value = 'auto'),
                (n.value = 'auto'),
                (s.value = '100%'),
                (a.value = '100%'),
                (o.value = 'auto'),
                (u.value = 'auto'),
                (m = 'auto'),
                (S = 'auto'),
                (p.value = 'hidden'),
                (c.value = void 0),
                (b.value = !1)
            }, t.floatingDuration))
        },
        N = () => {
          he(t['onUpdate:floating'], !1)
        }
      return (
        l.watch(
          () => t.floating,
          (I) => {
            T.value ||
              l.nextTick(() => {
                I ? x() : D()
              })
          },
          { immediate: !0 }
        ),
        {
          n: mJ,
          classes: yJ,
          toSizeUnit: xt,
          card: e,
          cardFloater: r,
          holderWidth: i,
          holderHeight: n,
          floater: P,
          floaterWidth: s,
          floaterHeight: a,
          floaterTop: o,
          floaterLeft: u,
          floaterPosition: c,
          floaterOverflow: p,
          contentHeight: h,
          opacity: f,
          zIndex: d,
          isRow: T,
          close: N,
          showFloatingButtons: y,
          floated: b,
        }
      )
    },
  })
  Bf.install = function (t) {
    t.component(Bf.name, Bf)
  }
  var SJ = {
      title: { type: [Number, String] },
      icon: { type: String },
      desc: { type: String },
      border: { type: Boolean, default: !1 },
      iconClass: { type: String },
      titleClass: { type: String },
      descClass: { type: String },
      extraClass: { type: String },
    },
    { n: vJ, classes: EJ } = Me('cell')
  function PJ(t, e) {
    var r = l.resolveComponent('var-icon')
    return (
      l.openBlock(),
      l.createElementBlock(
        'div',
        { class: l.normalizeClass(t.classes(t.n(), [t.border, t.n('--border')])) },
        [
          t.$slots.icon || t.icon
            ? (l.openBlock(),
              l.createElementBlock(
                'div',
                { key: 0, class: l.normalizeClass(t.classes(t.n('icon'), [t.iconClass, t.iconClass])) },
                [
                  l.renderSlot(t.$slots, 'icon', {}, () => [
                    l.createVNode(r, { class: 'var--flex', name: t.icon }, null, 8, ['name']),
                  ]),
                ],
                2
              ))
            : l.createCommentVNode('v-if', !0),
          l.createElementVNode(
            'div',
            { class: l.normalizeClass(t.n('content')) },
            [
              l.createElementVNode(
                'div',
                { class: l.normalizeClass(t.classes(t.n('title'), [t.titleClass, t.titleClass])) },
                [l.renderSlot(t.$slots, 'default', {}, () => [l.createTextVNode(l.toDisplayString(t.title), 1)])],
                2
              ),
              t.$slots.desc || t.desc
                ? (l.openBlock(),
                  l.createElementBlock(
                    'div',
                    { key: 0, class: l.normalizeClass(t.classes(t.n('desc'), [t.descClass, t.descClass])) },
                    [l.renderSlot(t.$slots, 'desc', {}, () => [l.createTextVNode(l.toDisplayString(t.desc), 1)])],
                    2
                  ))
                : l.createCommentVNode('v-if', !0),
            ],
            2
          ),
          t.$slots.extra
            ? (l.openBlock(),
              l.createElementBlock(
                'div',
                { key: 1, class: l.normalizeClass(t.classes(t.n('extra'), [t.extraClass, t.extraClass])) },
                [l.renderSlot(t.$slots, 'extra')],
                2
              ))
            : l.createCommentVNode('v-if', !0),
        ],
        2
      )
    )
  }
  var Il = l.defineComponent({
    render: PJ,
    name: 'VarCell',
    components: { VarIcon: kt },
    props: SJ,
    setup() {
      return { n: vJ, classes: EJ }
    },
  })
  Il.install = function (t) {
    t.component(Il.name, Il)
  }
  var wJ = { errorMessage: { type: String, default: '' }, maxlengthText: { type: String, default: '' } },
    { n: AJ } = Me('form-details')
  function CJ(t, e) {
    return (
      l.openBlock(),
      l.createBlock(
        l.Transition,
        { name: t.n() },
        {
          default: l.withCtx(() => [
            t.errorMessage || t.maxlengthText
              ? (l.openBlock(),
                l.createElementBlock(
                  'div',
                  { key: 0, class: l.normalizeClass(t.n()) },
                  [
                    l.createElementVNode(
                      'div',
                      { class: l.normalizeClass(t.n('message')) },
                      l.toDisplayString(t.errorMessage),
                      3
                    ),
                    l.createElementVNode(
                      'div',
                      { class: l.normalizeClass(t.n('length')) },
                      l.toDisplayString(t.maxlengthText),
                      3
                    ),
                  ],
                  2
                ))
              : l.createCommentVNode('v-if', !0),
          ]),
          _: 1,
        },
        8,
        ['name']
      )
    )
  }
  var lr = l.defineComponent({ render: CJ, name: 'VarFormDetails', props: wJ, setup: () => ({ n: AJ }) })
  lr.install = function (t) {
    t.component(lr.name, lr)
  }
  var xJ = {
      modelValue: { type: [String, Number, Boolean, Object, Array], default: !1 },
      checkedValue: { type: [String, Number, Boolean, Object, Array], default: !0 },
      uncheckedValue: { type: [String, Number, Boolean, Object, Array], default: !1 },
      checkedColor: { type: String },
      uncheckedColor: { type: String },
      disabled: { type: Boolean, default: !1 },
      readonly: { type: Boolean, default: !1 },
      iconSize: { type: [String, Number] },
      ripple: { type: Boolean, default: !0 },
      validateTrigger: { type: Array, default: ['onChange'] },
      rules: { type: Array },
      onClick: { type: Function },
      onChange: { type: Function },
      'onUpdate:modelValue': { type: Function },
    },
    VT = Symbol('CHECKBOX_GROUP_BIND_CHECKBOX_KEY'),
    UT = Symbol('CHECKBOX_GROUP_COUNT_CHECKBOX_KEY')
  function IJ() {
    var { bindChildren: t, childProviders: e } = Sr(VT),
      { length: r } = Ir(UT)
    return { length: r, checkboxes: e, bindCheckboxes: t }
  }
  function kJ() {
    var { bindParent: t, parentProvider: e } = vr(VT),
      { index: r } = kr(UT)
    return { index: r, checkboxGroup: e, bindCheckboxGroup: t }
  }
  var zT = Symbol('FORM_BIND_FORM_ITEM_KEY')
  function Or() {
    var { bindParent: t, parentProvider: e } = vr(zT)
    return { bindForm: t, form: e }
  }
  function NJ() {
    var { bindChildren: t, childProviders: e } = Sr(zT)
    return { formItems: e, bindFormItems: t }
  }
  var { n: OJ, classes: DJ } = Me('checkbox')
  function BJ(t, e) {
    var r = l.resolveComponent('var-icon'),
      i = l.resolveComponent('var-form-details'),
      n = l.resolveDirective('ripple')
    return (
      l.openBlock(),
      l.createElementBlock(
        'div',
        {
          class: l.normalizeClass(t.n('wrap')),
          onClick:
            e[0] ||
            (e[0] = function () {
              return t.handleClick && t.handleClick(...arguments)
            }),
        },
        [
          l.createElementVNode(
            'div',
            { class: l.normalizeClass(t.n()) },
            [
              l.withDirectives(
                (l.openBlock(),
                l.createElementBlock(
                  'div',
                  {
                    class: l.normalizeClass(
                      t.classes(
                        t.n('action'),
                        [t.checked, t.n('--checked'), t.n('--unchecked')],
                        [t.errorMessage || t.checkboxGroupErrorMessage, t.n('--error')],
                        [t.formDisabled || t.disabled, t.n('--disabled')]
                      )
                    ),
                    style: l.normalizeStyle({ color: t.checked ? t.checkedColor : t.uncheckedColor }),
                  },
                  [
                    t.checked
                      ? l.renderSlot(t.$slots, 'checked-icon', { key: 0 }, () => [
                          l.createVNode(
                            r,
                            {
                              class: l.normalizeClass(
                                t.classes(t.n('icon'), [t.withAnimation, t.n('--with-animation')])
                              ),
                              name: 'checkbox-marked',
                              size: t.iconSize,
                              'var-checkbox-cover': '',
                            },
                            null,
                            8,
                            ['class', 'size']
                          ),
                        ])
                      : l.renderSlot(t.$slots, 'unchecked-icon', { key: 1 }, () => [
                          l.createVNode(
                            r,
                            {
                              class: l.normalizeClass(
                                t.classes(t.n('icon'), [t.withAnimation, t.n('--with-animation')])
                              ),
                              name: 'checkbox-blank-outline',
                              size: t.iconSize,
                              'var-checkbox-cover': '',
                            },
                            null,
                            8,
                            ['class', 'size']
                          ),
                        ]),
                  ],
                  6
                )),
                [[n, { disabled: t.formReadonly || t.readonly || t.formDisabled || t.disabled || !t.ripple }]]
              ),
              l.createElementVNode(
                'div',
                {
                  class: l.normalizeClass(
                    t.classes(
                      t.n('text'),
                      [t.errorMessage || t.checkboxGroupErrorMessage, t.n('--error')],
                      [t.formDisabled || t.disabled, t.n('--disabled')]
                    )
                  ),
                },
                [l.renderSlot(t.$slots, 'default')],
                2
              ),
            ],
            2
          ),
          l.createVNode(i, { 'error-message': t.errorMessage }, null, 8, ['error-message']),
        ],
        2
      )
    )
  }
  var kl = l.defineComponent({
    render: BJ,
    name: 'VarCheckbox',
    directives: { Ripple: tr },
    components: { VarIcon: kt, VarFormDetails: lr },
    props: xJ,
    setup(t) {
      var e = l.ref(!1),
        r = l.computed(() => e.value === t.checkedValue),
        i = l.computed(() => t.checkedValue),
        n = l.ref(!1),
        { checkboxGroup: s, bindCheckboxGroup: a } = kJ(),
        { form: o, bindForm: u } = Or(),
        { errorMessage: c, validateWithTrigger: p, validate: h, resetValidation: f } = Nr(),
        d = (D) => {
          l.nextTick(() => {
            var { validateTrigger: N, rules: I, modelValue: B } = t
            p(N, D, I, B)
          })
        },
        T = (D) => {
          e.value = D
          var { checkedValue: N, onChange: I } = t
          he(t['onUpdate:modelValue'], e.value),
            he(I, e.value),
            d('onChange'),
            D === N ? s == null || s.onChecked(N) : s == null || s.onUnchecked(N)
        },
        y = (D) => {
          var { disabled: N, readonly: I, checkedValue: B, uncheckedValue: K, onClick: Y } = t
          if (!((o != null && o.disabled.value) || N) && (he(Y, D), !((o != null && o.readonly.value) || I))) {
            n.value = !0
            var C = s ? s.checkedCount.value >= Number(s.max.value) : !1
            ;(!r.value && C) || T(r.value ? K : B)
          }
        },
        b = (D) => {
          var { checkedValue: N, uncheckedValue: I } = t
          e.value = D.includes(N) ? N : I
        },
        m = () => {
          n.value = !1
        },
        S = () => {
          he(t['onUpdate:modelValue'], t.uncheckedValue), f()
        },
        E = (D) => {
          var { checkedValue: N, uncheckedValue: I } = t,
            B = ![N, I].includes(D)
          B && (D = r.value ? I : N), T(D)
        },
        P = () => h(t.rules, t.modelValue)
      l.watch(
        () => t.modelValue,
        (D) => {
          e.value = D
        },
        { immediate: !0 }
      )
      var x = { checkedValue: i, checked: r, sync: b, validate: P, resetValidation: f, reset: S, resetWithAnimation: m }
      return (
        he(a, x),
        he(u, x),
        {
          withAnimation: n,
          checked: r,
          errorMessage: c,
          checkboxGroupErrorMessage: s == null ? void 0 : s.errorMessage,
          formDisabled: o == null ? void 0 : o.disabled,
          formReadonly: o == null ? void 0 : o.readonly,
          n: OJ,
          classes: DJ,
          handleClick: y,
          toggle: E,
          reset: S,
          validate: P,
          resetValidation: f,
        }
      )
    },
  })
  kl.install = function (t) {
    t.component(kl.name, kl)
  }
  function LJ(t) {
    return ['horizontal', 'vertical'].includes(t)
  }
  var MJ = {
      modelValue: { type: Array, default: () => [] },
      max: { type: [String, Number] },
      direction: { type: String, default: 'horizontal', validator: LJ },
      validateTrigger: { type: Array, default: ['onChange'] },
      rules: { type: Array },
      onChange: { type: Function },
      'onUpdate:modelValue': { type: Function },
    },
    { n: FJ, classes: $J } = Me('checkbox-group')
  function RJ(t, e) {
    var r = l.resolveComponent('var-form-details')
    return (
      l.openBlock(),
      l.createElementBlock(
        'div',
        { class: l.normalizeClass(t.n('wrap')) },
        [
          l.createElementVNode(
            'div',
            { class: l.normalizeClass(t.classes(t.n(), t.n('--' + t.direction))) },
            [l.renderSlot(t.$slots, 'default')],
            2
          ),
          l.createVNode(r, { 'error-message': t.errorMessage }, null, 8, ['error-message']),
        ],
        2
      )
    )
  }
  var Lf = l.defineComponent({
    render: RJ,
    name: 'VarCheckboxGroup',
    components: { VarFormDetails: lr },
    props: MJ,
    setup(t) {
      var e = l.computed(() => t.max),
        r = l.computed(() => t.modelValue.length),
        { length: i, checkboxes: n, bindCheckboxes: s } = IJ(),
        { bindForm: a } = Or(),
        { errorMessage: o, validateWithTrigger: u, validate: c, resetValidation: p } = Nr(),
        h = l.computed(() => o.value),
        f = (N) => {
          l.nextTick(() => {
            var { validateTrigger: I, rules: B, modelValue: K } = t
            u(I, N, B, K)
          })
        },
        d = (N) => {
          he(t['onUpdate:modelValue'], N), he(t.onChange, N), f('onChange')
        },
        T = (N) => {
          var { modelValue: I } = t
          I.includes(N) || d([...I, N])
        },
        y = (N) => {
          var { modelValue: I } = t
          !I.includes(N) || d(I.filter((B) => B !== N))
        },
        b = () =>
          n.forEach((N) => {
            var { sync: I } = N
            return I(t.modelValue)
          }),
        m = () => {
          n.forEach((N) => N.resetWithAnimation())
        },
        S = () => {
          var N = n.map((B) => {
              var { checkedValue: K } = B
              return K.value
            }),
            I = gT(N)
          return m(), he(t['onUpdate:modelValue'], I), I
        },
        E = () => {
          var N = n
              .filter((B) => {
                var { checked: K } = B
                return !K.value
              })
              .map((B) => {
                var { checkedValue: K } = B
                return K.value
              }),
            I = gT(N)
          return m(), he(t['onUpdate:modelValue'], I), I
        },
        P = () => {
          he(t['onUpdate:modelValue'], []), p()
        },
        x = () => c(t.rules, t.modelValue)
      l.watch(() => t.modelValue, b, { deep: !0 }), l.watch(() => i.value, b)
      var D = {
        max: e,
        checkedCount: r,
        onChecked: T,
        onUnchecked: y,
        validate: x,
        resetValidation: p,
        reset: P,
        errorMessage: h,
      }
      return (
        s(D),
        he(a, D),
        { errorMessage: o, n: FJ, classes: $J, checkAll: S, inverseAll: E, reset: P, validate: x, resetValidation: p }
      )
    },
  })
  Lf.install = function (t) {
    t.component(Lf.name, Lf)
  }
  function jJ(t) {
    return ['default', 'primary', 'info', 'success', 'warning', 'danger'].includes(t)
  }
  function _J(t) {
    return ['normal', 'mini', 'small', 'large'].includes(t)
  }
  var VJ = {
      type: { type: String, default: 'default', validator: jJ },
      size: { type: String, default: 'normal', validator: _J },
      color: { type: String },
      textColor: { type: String },
      iconName: xr(DT, 'name'),
      plain: { type: Boolean, default: !1 },
      round: { type: Boolean, default: !0 },
      block: { type: Boolean, default: !1 },
      closable: { type: Boolean, default: !1 },
      onClose: { type: Function },
    },
    { n: Yn, classes: UJ } = Me('chip')
  function zJ(t, e) {
    var r = l.resolveComponent('var-icon')
    return (
      l.openBlock(),
      l.createBlock(
        l.Transition,
        { name: 'var-fade' },
        {
          default: l.withCtx(() => [
            l.createElementVNode(
              'span',
              l.mergeProps({ class: t.classes(t.n(), 'var--box', ...t.contentClass), style: t.chipStyles }, t.$attrs),
              [
                l.renderSlot(t.$slots, 'left'),
                l.createElementVNode(
                  'span',
                  { class: l.normalizeClass(t.n('text-' + t.size)) },
                  [l.renderSlot(t.$slots, 'default')],
                  2
                ),
                l.renderSlot(t.$slots, 'right'),
                t.closable
                  ? (l.openBlock(),
                    l.createElementBlock(
                      'span',
                      {
                        key: 0,
                        class: l.normalizeClass(t.n('--close')),
                        onClick:
                          e[0] ||
                          (e[0] = function () {
                            return t.onClose && t.onClose(...arguments)
                          }),
                      },
                      [l.createVNode(r, { name: '' + (t.iconName ? t.iconName : 'close-circle') }, null, 8, ['name'])],
                      2
                    ))
                  : l.createCommentVNode('v-if', !0),
              ],
              16
            ),
          ]),
          _: 3,
        }
      )
    )
  }
  var Nl = l.defineComponent({
    render: zJ,
    name: 'VarChip',
    components: { VarIcon: kt },
    inheritAttrs: !1,
    props: VJ,
    setup(t) {
      var e = l.computed(() => {
          var { plain: i, textColor: n, color: s } = t
          return i ? { color: n || s, borderColor: s } : { color: n, background: s }
        }),
        r = l.computed(() => {
          var { size: i, block: n, type: s, plain: a, round: o } = t,
            u = n ? 'var--flex' : 'var--inline-flex',
            c = a ? Yn('plain') + ' ' + Yn('plain-' + s) : Yn('--' + s),
            p = o ? Yn('--round') : null
          return [Yn('--' + i), u, c, p]
        })
      return { n: Yn, classes: UJ, chipStyles: e, contentClass: r }
    },
  })
  Nl.install = function (t) {
    t.component(Nl.name, Nl)
  }
  var KJ = {
      span: { type: [String, Number], default: 24 },
      offset: { type: [String, Number], default: 0 },
      onClick: { type: Function },
      xs: { type: [Object, Number, String] },
      sm: { type: [Object, Number, String] },
      md: { type: [Object, Number, String] },
      lg: { type: [Object, Number, String] },
      xl: { type: [Object, Number, String] },
    },
    KT = Symbol('ROW_BIND_COL_KEY'),
    WT = Symbol('ROW_COUNT_COL_KEY')
  function WJ() {
    var { bindChildren: t, childProviders: e } = Sr(KT),
      { length: r } = Ir(WT)
    return { length: r, cols: e, bindCols: t }
  }
  function YJ() {
    var { parentProvider: t, bindParent: e } = vr(KT),
      { index: r } = kr(WT)
    return (!t || !e || !r) && console.warn('col must in row'), { index: r, row: t, bindRow: e }
  }
  var { n: Ol, classes: HJ } = Me('col')
  function qJ(t, e) {
    return (
      l.openBlock(),
      l.createElementBlock(
        'div',
        {
          class: l.normalizeClass(
            t.classes(
              t.n(),
              'var--box',
              [t.span >= 0, t.n('--span-' + t.span)],
              [t.offset, t.n('--offset-' + t.offset)],
              ...t.getSize('xs', t.xs),
              ...t.getSize('sm', t.sm),
              ...t.getSize('md', t.md),
              ...t.getSize('lg', t.lg),
              ...t.getSize('xl', t.xl)
            )
          ),
          style: l.normalizeStyle({
            paddingLeft: t.toSizeUnit(t.padding.left),
            paddingRight: t.toSizeUnit(t.padding.right),
          }),
          onClick:
            e[0] ||
            (e[0] = function () {
              return t.onClick && t.onClick(...arguments)
            }),
        },
        [l.renderSlot(t.$slots, 'default')],
        6
      )
    )
  }
  var Mf = l.defineComponent({
    render: qJ,
    name: 'VarCol',
    props: KJ,
    setup(t) {
      var e = l.ref({ left: 0, right: 0 }),
        r = l.computed(() => Ee(t.span)),
        i = l.computed(() => Ee(t.offset)),
        { row: n, bindRow: s } = YJ(),
        a = {
          setPadding(u) {
            e.value = u
          },
        },
        o = (u, c) => {
          var p = []
          if (c == null) return p
          if (hT(c)) {
            var { offset: h, span: f } = c
            Number(f) >= 0 && p.push(Ol('--span-' + u + '-' + f)), h && p.push(Ol('--offset-' + u + '-' + h))
          } else Number(c) >= 0 && p.push(Ol('--span-' + u + '-' + c))
          return p
        }
      return (
        l.watch([() => t.span, () => t.offset], () => {
          n == null || n.computePadding()
        }),
        he(s, a),
        { n: Ol, classes: HJ, padding: e, toNumber: Ee, toSizeUnit: xt, getSize: o, span: r, offset: i }
      )
    },
  })
  Mf.install = function (t) {
    t.component(Mf.name, Mf)
  }
  var YT = Symbol('COLLAPSE_BIND_COLLAPSE_ITEM_KEY'),
    HT = Symbol('COLLAPSE_COUNT_COLLAPSE_ITEM_KEY')
  function XJ() {
    var { bindChildren: t, childProviders: e } = Sr(YT),
      { length: r } = Ir(HT)
    return { length: r, collapseItem: e, bindCollapseItem: t }
  }
  var GJ = {
      modelValue: { type: [Array, String, Number] },
      accordion: { type: Boolean, default: !1 },
      offset: { type: Boolean, default: !0 },
      onChange: { type: Function },
      'onUpdate:modelValue': { type: Function },
    },
    { n: JJ } = Me('collapse')
  function ZJ(t, e) {
    return (
      l.openBlock(),
      l.createElementBlock('div', { class: l.normalizeClass(t.n()) }, [l.renderSlot(t.$slots, 'default')], 2)
    )
  }
  var Ff = l.defineComponent({
    render: ZJ,
    name: 'VarCollapse',
    props: GJ,
    setup(t) {
      var { length: e, collapseItem: r, bindCollapseItem: i } = XJ(),
        n = l.computed(() => t.modelValue),
        s = l.computed(() => t.offset),
        a = () =>
          !t.accordion && !At(t.modelValue)
            ? (console.error('[Varlet] Collapse: type of prop "modelValue" should be an Array'), !1)
            : t.accordion && At(t.modelValue)
            ? (console.error('[Varlet] Collapse: type of prop "modelValue" should be a String or Number'), !1)
            : !0,
        o = (d, T) =>
          a()
            ? T
              ? t.accordion
                ? d
                : [...t.modelValue, d]
              : t.accordion
              ? null
              : t.modelValue.filter((y) => y !== d)
            : null,
        u = (d, T) => {
          var y = o(d, T)
          he(t['onUpdate:modelValue'], y), he(t.onChange, y)
        },
        c = () => {
          if (t.accordion)
            return r.find((T) => {
              var { name: y } = T
              return t.modelValue === y.value
            })
          var d = r.filter((T) => {
            var { name: y } = T
            return y.value === void 0 ? !1 : t.modelValue.includes(y.value)
          })
          return d.length ? d : void 0
        },
        p = () =>
          t.accordion
            ? r.find((d) => {
                var { index: T, name: y } = d
                return y.value === void 0 ? t.modelValue === T.value : !1
              })
            : r.filter((d) => {
                var { index: T, name: y } = d
                return y.value === void 0 ? t.modelValue.includes(T.value) : !1
              }),
        h = () => {
          if (!!a()) {
            var d = c() || p()
            if ((t.accordion && !d) || (!t.accordion && !d.length)) {
              r.forEach((T) => {
                T.init(t.accordion, !1)
              })
              return
            }
            r.forEach((T) => {
              var y = t.accordion ? d === T : d.includes(T)
              T.init(t.accordion, y)
            })
          }
        },
        f = { active: n, offset: s, updateItem: u }
      return (
        i(f),
        l.watch(
          () => e.value,
          () => l.nextTick().then(h)
        ),
        l.watch(
          () => t.modelValue,
          () => l.nextTick().then(h)
        ),
        { n: JJ }
      )
    },
  })
  Ff.install = function (t) {
    t.component(Ff.name, Ff)
  }
  function QJ() {
    var { parentProvider: t, bindParent: e } = vr(YT),
      { index: r } = kr(HT)
    if (!t || !e || !r) throw Error('[Varlet] Collapse: <var-collapse-item/> must in <var-collapse>')
    return { index: r, collapse: t, bindCollapse: e }
  }
  var eZ = {
      name: { type: [String, Number] },
      title: { type: String },
      icon: { type: String, default: 'chevron-down' },
      disabled: { type: Boolean, default: !1 },
    },
    { n: tZ, classes: rZ } = Me('collapse-item')
  function iZ(t, e) {
    var r = l.resolveComponent('var-icon')
    return (
      l.openBlock(),
      l.createElementBlock(
        'div',
        {
          class: l.normalizeClass(
            t.classes(t.n(), [t.offset && t.isShow, t.n('--active')], [t.disabled, t.n('--disable')])
          ),
        },
        [
          l.createElementVNode(
            'div',
            { class: l.normalizeClass(t.n('header')), onClick: e[0] || (e[0] = (i) => t.toggle()) },
            [
              l.createElementVNode(
                'div',
                { class: l.normalizeClass(t.n('header-title')) },
                [l.renderSlot(t.$slots, 'title', {}, () => [l.createTextVNode(l.toDisplayString(t.title), 1)])],
                2
              ),
              l.createElementVNode(
                'div',
                { class: l.normalizeClass(t.n('header-icon')) },
                [
                  l.renderSlot(t.$slots, 'icon', {}, () => [
                    l.createVNode(
                      r,
                      {
                        name: t.icon,
                        transition: 250,
                        class: l.normalizeClass(
                          t.classes(
                            t.n('header-icon'),
                            [t.isShow && t.icon === 'chevron-down', t.n('header-open')],
                            [t.disabled, t.n('header--disable')]
                          )
                        ),
                      },
                      null,
                      8,
                      ['name', 'class']
                    ),
                  ]),
                ],
                2
              ),
            ],
            2
          ),
          l.withDirectives(
            l.createElementVNode(
              'div',
              {
                class: l.normalizeClass(t.n('content')),
                ref: 'contentEl',
                onTransitionend:
                  e[1] ||
                  (e[1] = function () {
                    return t.transitionend && t.transitionend(...arguments)
                  }),
              },
              [
                l.createElementVNode(
                  'div',
                  { class: l.normalizeClass(t.n('content-wrap')) },
                  [l.renderSlot(t.$slots, 'default')],
                  2
                ),
              ],
              34
            ),
            [[l.vShow, t.show]]
          ),
        ],
        2
      )
    )
  }
  var $f = l.defineComponent({
    render: iZ,
    name: 'VarCollapseItem',
    components: { VarIcon: kt },
    props: eZ,
    setup(t) {
      var { index: e, collapse: r, bindCollapse: i } = QJ(),
        n = l.ref(null),
        s = l.ref(!1),
        a = l.ref(!1),
        { active: o, offset: u, updateItem: c } = r,
        p = l.computed(() => t.name),
        h = (m, S) => {
          o.value === void 0 || (m && At(o.value)) || S === a.value || ((a.value = S), f(!0))
        },
        f = (m) => {
          t.disabled || m || c(t.name || e.value, !a.value)
        },
        d = () => {
          !n.value ||
            ((n.value.style.height = ''),
            (s.value = !0),
            l.nextTick(() => {
              var { offsetHeight: m } = n.value
              ;(n.value.style.height = 0 + 'px'),
                ui(() => {
                  n.value.style.height = m + 'px'
                })
            }))
        },
        T = () => {
          !n.value || (n.value.style.height = 0 + 'px')
        },
        y = () => {
          a.value || ((s.value = !1), (n.value.style.height = ''))
        },
        b = { index: e, name: p, init: h }
      return (
        i(b),
        l.watch(a, (m) => {
          m ? d() : T()
        }),
        { n: tZ, classes: rZ, show: s, isShow: a, offset: u, toggle: f, contentEl: n, transitionend: y }
      )
    },
  })
  $f.install = function (t) {
    t.component($f.name, $f)
  }
  var nZ = {
      time: { type: [String, Number], default: 0 },
      format: { type: String, default: 'HH : mm : ss' },
      autoStart: { type: Boolean, default: !0 },
      onEnd: { type: Function },
      onChange: { type: Function },
    },
    { n: sZ } = Me('countdown'),
    Rf = 1e3,
    jf = 60 * Rf,
    _f = 60 * jf,
    qT = 24 * _f
  function aZ(t, e) {
    return (
      l.openBlock(),
      l.createElementBlock(
        'div',
        { class: l.normalizeClass(t.n()) },
        [
          l.renderSlot(t.$slots, 'default', l.normalizeProps(l.guardReactiveProps(t.timeData)), () => [
            l.createTextVNode(l.toDisplayString(t.showTime), 1),
          ]),
        ],
        2
      )
    )
  }
  var Vf = l.defineComponent({
    render: aZ,
    name: 'VarCountdown',
    props: nZ,
    setup(t) {
      var e = l.ref(0),
        r = l.ref(!1),
        i = l.ref(''),
        n = l.ref(0),
        s = l.ref(0),
        a = l.ref({ days: 0, hours: 0, minutes: 0, seconds: 0, milliseconds: 0 }),
        o = (f) => {
          var d = Math.floor(f / qT),
            T = Math.floor((f % qT) / _f),
            y = Math.floor((f % _f) / jf),
            b = Math.floor((f % jf) / Rf),
            m = Math.floor(f % Rf),
            S = { days: d, hours: T, minutes: y, seconds: b, milliseconds: m }
          ;(a.value = S), he(t.onChange, a.value), (i.value = VX(t.format, S))
        },
        u = () => {
          var { time: f, onEnd: d, autoStart: T } = t,
            y = Date.now()
          e.value || (e.value = y + Ee(f))
          var b = e.value - y
          if ((b < 0 && (b = 0), (s.value = b), o(b), b === 0)) {
            he(d)
            return
          }
          ;(T || r.value) && (n.value = ui(u))
        },
        c = () => {
          r.value || ((r.value = !0), (e.value = Date.now() + (s.value || Ee(t.time))), u())
        },
        p = () => {
          r.value = !1
        },
        h = () => {
          ;(e.value = 0), (r.value = !1), XX(n.value), u()
        }
      return (
        l.watch(
          () => t.time,
          () => h(),
          { immediate: !0 }
        ),
        { showTime: i, timeData: a, n: sZ, start: c, pause: p, reset: h }
      )
    },
  })
  Vf.install = function (t) {
    t.component(Vf.name, Vf)
  }
  var Hn = 9e15,
    Di = 1e9,
    Uf = '0123456789abcdef',
    Dl =
      '2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058',
    Bl =
      '3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789',
    zf = { precision: 20, rounding: 4, modulo: 1, toExpNeg: -7, toExpPos: 21, minE: -Hn, maxE: Hn, crypto: !1 },
    XT,
    ci,
    Qe = !0,
    Ll = '[DecimalError] ',
    Bi = Ll + 'Invalid argument: ',
    GT = Ll + 'Precision limit exceeded',
    JT = Ll + 'crypto unavailable',
    ZT = '[object Decimal]',
    Gt = Math.floor,
    Bt = Math.pow,
    oZ = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i,
    lZ = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i,
    uZ = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i,
    QT = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,
    Dr = 1e7,
    Xe = 7,
    cZ = 9007199254740991,
    pZ = Dl.length - 1,
    Kf = Bl.length - 1,
    we = { toStringTag: ZT }
  ;(we.absoluteValue = we.abs =
    function () {
      var t = new this.constructor(this)
      return t.s < 0 && (t.s = 1), Ke(t)
    }),
    (we.ceil = function () {
      return Ke(new this.constructor(this), this.e + 1, 2)
    }),
    (we.clampedTo = we.clamp =
      function (t, e) {
        var r,
          i = this,
          n = i.constructor
        if (((t = new n(t)), (e = new n(e)), !t.s || !e.s)) return new n(NaN)
        if (t.gt(e)) throw Error(Bi + e)
        return (r = i.cmp(t)), r < 0 ? t : i.cmp(e) > 0 ? e : new n(i)
      }),
    (we.comparedTo = we.cmp =
      function (t) {
        var e,
          r,
          i,
          n,
          s = this,
          a = s.d,
          o = (t = new s.constructor(t)).d,
          u = s.s,
          c = t.s
        if (!a || !o) return !u || !c ? NaN : u !== c ? u : a === o ? 0 : !a ^ (u < 0) ? 1 : -1
        if (!a[0] || !o[0]) return a[0] ? u : o[0] ? -c : 0
        if (u !== c) return u
        if (s.e !== t.e) return (s.e > t.e) ^ (u < 0) ? 1 : -1
        for (i = a.length, n = o.length, e = 0, r = i < n ? i : n; e < r; ++e)
          if (a[e] !== o[e]) return (a[e] > o[e]) ^ (u < 0) ? 1 : -1
        return i === n ? 0 : (i > n) ^ (u < 0) ? 1 : -1
      }),
    (we.cosine = we.cos =
      function () {
        var t,
          e,
          r = this,
          i = r.constructor
        return r.d
          ? r.d[0]
            ? ((t = i.precision),
              (e = i.rounding),
              (i.precision = t + Math.max(r.e, r.sd()) + Xe),
              (i.rounding = 1),
              (r = fZ(i, sb(i, r))),
              (i.precision = t),
              (i.rounding = e),
              Ke(ci == 2 || ci == 3 ? r.neg() : r, t, e, !0))
            : new i(1)
          : new i(NaN)
      }),
    (we.cubeRoot = we.cbrt =
      function () {
        var t,
          e,
          r,
          i,
          n,
          s,
          a,
          o,
          u,
          c,
          p = this,
          h = p.constructor
        if (!p.isFinite() || p.isZero()) return new h(p)
        for (
          Qe = !1,
            s = p.s * Bt(p.s * p, 1 / 3),
            !s || Math.abs(s) == 1 / 0
              ? ((r = Rt(p.d)),
                (t = p.e),
                (s = (t - r.length + 1) % 3) && (r += s == 1 || s == -2 ? '0' : '00'),
                (s = Bt(r, 1 / 3)),
                (t = Gt((t + 1) / 3) - (t % 3 == (t < 0 ? -1 : 2))),
                s == 1 / 0 ? (r = '5e' + t) : ((r = s.toExponential()), (r = r.slice(0, r.indexOf('e') + 1) + t)),
                (i = new h(r)),
                (i.s = p.s))
              : (i = new h(s.toString())),
            a = (t = h.precision) + 3;
          ;

        )
          if (
            ((o = i),
            (u = o.times(o).times(o)),
            (c = u.plus(p)),
            (i = vt(c.plus(p).times(o), c.plus(u), a + 2, 1)),
            Rt(o.d).slice(0, a) === (r = Rt(i.d)).slice(0, a))
          )
            if (((r = r.slice(a - 3, a + 1)), r == '9999' || (!n && r == '4999'))) {
              if (!n && (Ke(o, t + 1, 0), o.times(o).times(o).eq(p))) {
                i = o
                break
              }
              ;(a += 4), (n = 1)
            } else {
              ;(!+r || (!+r.slice(1) && r.charAt(0) == '5')) && (Ke(i, t + 1, 1), (e = !i.times(i).times(i).eq(p)))
              break
            }
        return (Qe = !0), Ke(i, t, h.rounding, e)
      }),
    (we.decimalPlaces = we.dp =
      function () {
        var t,
          e = this.d,
          r = NaN
        if (e) {
          if (((t = e.length - 1), (r = (t - Gt(this.e / Xe)) * Xe), (t = e[t]), t)) for (; t % 10 == 0; t /= 10) r--
          r < 0 && (r = 0)
        }
        return r
      }),
    (we.dividedBy = we.div =
      function (t) {
        return vt(this, new this.constructor(t))
      }),
    (we.dividedToIntegerBy = we.divToInt =
      function (t) {
        var e = this,
          r = e.constructor
        return Ke(vt(e, new r(t), 0, 1, 1), r.precision, r.rounding)
      }),
    (we.equals = we.eq =
      function (t) {
        return this.cmp(t) === 0
      }),
    (we.floor = function () {
      return Ke(new this.constructor(this), this.e + 1, 3)
    }),
    (we.greaterThan = we.gt =
      function (t) {
        return this.cmp(t) > 0
      }),
    (we.greaterThanOrEqualTo = we.gte =
      function (t) {
        var e = this.cmp(t)
        return e == 1 || e === 0
      }),
    (we.hyperbolicCosine = we.cosh =
      function () {
        var t,
          e,
          r,
          i,
          n,
          s = this,
          a = s.constructor,
          o = new a(1)
        if (!s.isFinite()) return new a(s.s ? 1 / 0 : NaN)
        if (s.isZero()) return o
        ;(r = a.precision),
          (i = a.rounding),
          (a.precision = r + Math.max(s.e, s.sd()) + 4),
          (a.rounding = 1),
          (n = s.d.length),
          n < 32
            ? ((t = Math.ceil(n / 3)), (e = (1 / Rl(4, t)).toString()))
            : ((t = 16), (e = '2.3283064365386962890625e-10')),
          (s = qn(a, 1, s.times(e), new a(1), !0))
        for (var u, c = t, p = new a(8); c--; ) (u = s.times(s)), (s = o.minus(u.times(p.minus(u.times(p)))))
        return Ke(s, (a.precision = r), (a.rounding = i), !0)
      }),
    (we.hyperbolicSine = we.sinh =
      function () {
        var t,
          e,
          r,
          i,
          n = this,
          s = n.constructor
        if (!n.isFinite() || n.isZero()) return new s(n)
        if (
          ((e = s.precision),
          (r = s.rounding),
          (s.precision = e + Math.max(n.e, n.sd()) + 4),
          (s.rounding = 1),
          (i = n.d.length),
          i < 3)
        )
          n = qn(s, 2, n, n, !0)
        else {
          ;(t = 1.4 * Math.sqrt(i)), (t = t > 16 ? 16 : t | 0), (n = n.times(1 / Rl(5, t))), (n = qn(s, 2, n, n, !0))
          for (var a, o = new s(5), u = new s(16), c = new s(20); t--; )
            (a = n.times(n)), (n = n.times(o.plus(a.times(u.times(a).plus(c)))))
        }
        return (s.precision = e), (s.rounding = r), Ke(n, e, r, !0)
      }),
    (we.hyperbolicTangent = we.tanh =
      function () {
        var t,
          e,
          r = this,
          i = r.constructor
        return r.isFinite()
          ? r.isZero()
            ? new i(r)
            : ((t = i.precision),
              (e = i.rounding),
              (i.precision = t + 7),
              (i.rounding = 1),
              vt(r.sinh(), r.cosh(), (i.precision = t), (i.rounding = e)))
          : new i(r.s)
      }),
    (we.inverseCosine = we.acos =
      function () {
        var t,
          e = this,
          r = e.constructor,
          i = e.abs().cmp(1),
          n = r.precision,
          s = r.rounding
        return i !== -1
          ? i === 0
            ? e.isNeg()
              ? Br(r, n, s)
              : new r(0)
            : new r(NaN)
          : e.isZero()
          ? Br(r, n + 4, s).times(0.5)
          : ((r.precision = n + 6),
            (r.rounding = 1),
            (e = e.asin()),
            (t = Br(r, n + 4, s).times(0.5)),
            (r.precision = n),
            (r.rounding = s),
            t.minus(e))
      }),
    (we.inverseHyperbolicCosine = we.acosh =
      function () {
        var t,
          e,
          r = this,
          i = r.constructor
        return r.lte(1)
          ? new i(r.eq(1) ? 0 : NaN)
          : r.isFinite()
          ? ((t = i.precision),
            (e = i.rounding),
            (i.precision = t + Math.max(Math.abs(r.e), r.sd()) + 4),
            (i.rounding = 1),
            (Qe = !1),
            (r = r.times(r).minus(1).sqrt().plus(r)),
            (Qe = !0),
            (i.precision = t),
            (i.rounding = e),
            r.ln())
          : new i(r)
      }),
    (we.inverseHyperbolicSine = we.asinh =
      function () {
        var t,
          e,
          r = this,
          i = r.constructor
        return !r.isFinite() || r.isZero()
          ? new i(r)
          : ((t = i.precision),
            (e = i.rounding),
            (i.precision = t + 2 * Math.max(Math.abs(r.e), r.sd()) + 6),
            (i.rounding = 1),
            (Qe = !1),
            (r = r.times(r).plus(1).sqrt().plus(r)),
            (Qe = !0),
            (i.precision = t),
            (i.rounding = e),
            r.ln())
      }),
    (we.inverseHyperbolicTangent = we.atanh =
      function () {
        var t,
          e,
          r,
          i,
          n = this,
          s = n.constructor
        return n.isFinite()
          ? n.e >= 0
            ? new s(n.abs().eq(1) ? n.s / 0 : n.isZero() ? n : NaN)
            : ((t = s.precision),
              (e = s.rounding),
              (i = n.sd()),
              Math.max(i, t) < 2 * -n.e - 1
                ? Ke(new s(n), t, e, !0)
                : ((s.precision = r = i - n.e),
                  (n = vt(n.plus(1), new s(1).minus(n), r + t, 1)),
                  (s.precision = t + 4),
                  (s.rounding = 1),
                  (n = n.ln()),
                  (s.precision = t),
                  (s.rounding = e),
                  n.times(0.5)))
          : new s(NaN)
      }),
    (we.inverseSine = we.asin =
      function () {
        var t,
          e,
          r,
          i,
          n = this,
          s = n.constructor
        return n.isZero()
          ? new s(n)
          : ((e = n.abs().cmp(1)),
            (r = s.precision),
            (i = s.rounding),
            e !== -1
              ? e === 0
                ? ((t = Br(s, r + 4, i).times(0.5)), (t.s = n.s), t)
                : new s(NaN)
              : ((s.precision = r + 6),
                (s.rounding = 1),
                (n = n.div(new s(1).minus(n.times(n)).sqrt().plus(1)).atan()),
                (s.precision = r),
                (s.rounding = i),
                n.times(2)))
      }),
    (we.inverseTangent = we.atan =
      function () {
        var t,
          e,
          r,
          i,
          n,
          s,
          a,
          o,
          u,
          c = this,
          p = c.constructor,
          h = p.precision,
          f = p.rounding
        if (c.isFinite()) {
          if (c.isZero()) return new p(c)
          if (c.abs().eq(1) && h + 4 <= Kf) return (a = Br(p, h + 4, f).times(0.25)), (a.s = c.s), a
        } else {
          if (!c.s) return new p(NaN)
          if (h + 4 <= Kf) return (a = Br(p, h + 4, f).times(0.5)), (a.s = c.s), a
        }
        for (p.precision = o = h + 10, p.rounding = 1, r = Math.min(28, (o / Xe + 2) | 0), t = r; t; --t)
          c = c.div(c.times(c).plus(1).sqrt().plus(1))
        for (Qe = !1, e = Math.ceil(o / Xe), i = 1, u = c.times(c), a = new p(c), n = c; t !== -1; )
          if (
            ((n = n.times(u)),
            (s = a.minus(n.div((i += 2)))),
            (n = n.times(u)),
            (a = s.plus(n.div((i += 2)))),
            a.d[e] !== void 0)
          )
            for (t = e; a.d[t] === s.d[t] && t--; );
        return r && (a = a.times(2 << (r - 1))), (Qe = !0), Ke(a, (p.precision = h), (p.rounding = f), !0)
      }),
    (we.isFinite = function () {
      return !!this.d
    }),
    (we.isInteger = we.isInt =
      function () {
        return !!this.d && Gt(this.e / Xe) > this.d.length - 2
      }),
    (we.isNaN = function () {
      return !this.s
    }),
    (we.isNegative = we.isNeg =
      function () {
        return this.s < 0
      }),
    (we.isPositive = we.isPos =
      function () {
        return this.s > 0
      }),
    (we.isZero = function () {
      return !!this.d && this.d[0] === 0
    }),
    (we.lessThan = we.lt =
      function (t) {
        return this.cmp(t) < 0
      }),
    (we.lessThanOrEqualTo = we.lte =
      function (t) {
        return this.cmp(t) < 1
      }),
    (we.logarithm = we.log =
      function (t) {
        var e,
          r,
          i,
          n,
          s,
          a,
          o,
          u,
          c = this,
          p = c.constructor,
          h = p.precision,
          f = p.rounding,
          d = 5
        if (t == null) (t = new p(10)), (e = !0)
        else {
          if (((t = new p(t)), (r = t.d), t.s < 0 || !r || !r[0] || t.eq(1))) return new p(NaN)
          e = t.eq(10)
        }
        if (((r = c.d), c.s < 0 || !r || !r[0] || c.eq(1)))
          return new p(r && !r[0] ? -1 / 0 : c.s != 1 ? NaN : r ? 0 : 1 / 0)
        if (e)
          if (r.length > 1) s = !0
          else {
            for (n = r[0]; n % 10 === 0; ) n /= 10
            s = n !== 1
          }
        if (
          ((Qe = !1),
          (o = h + d),
          (a = Mi(c, o)),
          (i = e ? $l(p, o + 10) : Mi(t, o)),
          (u = vt(a, i, o, 1)),
          ea(u.d, (n = h), f))
        )
          do
            if (((o += 10), (a = Mi(c, o)), (i = e ? $l(p, o + 10) : Mi(t, o)), (u = vt(a, i, o, 1)), !s)) {
              ;+Rt(u.d).slice(n + 1, n + 15) + 1 == 1e14 && (u = Ke(u, h + 1, 0))
              break
            }
          while (ea(u.d, (n += 10), f))
        return (Qe = !0), Ke(u, h, f)
      }),
    (we.minus = we.sub =
      function (t) {
        var e,
          r,
          i,
          n,
          s,
          a,
          o,
          u,
          c,
          p,
          h,
          f,
          d = this,
          T = d.constructor
        if (((t = new T(t)), !d.d || !t.d))
          return !d.s || !t.s ? (t = new T(NaN)) : d.d ? (t.s = -t.s) : (t = new T(t.d || d.s !== t.s ? d : NaN)), t
        if (d.s != t.s) return (t.s = -t.s), d.plus(t)
        if (((c = d.d), (f = t.d), (o = T.precision), (u = T.rounding), !c[0] || !f[0])) {
          if (f[0]) t.s = -t.s
          else if (c[0]) t = new T(d)
          else return new T(u === 3 ? -0 : 0)
          return Qe ? Ke(t, o, u) : t
        }
        if (((r = Gt(t.e / Xe)), (p = Gt(d.e / Xe)), (c = c.slice()), (s = p - r), s)) {
          for (
            h = s < 0,
              h ? ((e = c), (s = -s), (a = f.length)) : ((e = f), (r = p), (a = c.length)),
              i = Math.max(Math.ceil(o / Xe), a) + 2,
              s > i && ((s = i), (e.length = 1)),
              e.reverse(),
              i = s;
            i--;

          )
            e.push(0)
          e.reverse()
        } else {
          for (i = c.length, a = f.length, h = i < a, h && (a = i), i = 0; i < a; i++)
            if (c[i] != f[i]) {
              h = c[i] < f[i]
              break
            }
          s = 0
        }
        for (h && ((e = c), (c = f), (f = e), (t.s = -t.s)), a = c.length, i = f.length - a; i > 0; --i) c[a++] = 0
        for (i = f.length; i > s; ) {
          if (c[--i] < f[i]) {
            for (n = i; n && c[--n] === 0; ) c[n] = Dr - 1
            --c[n], (c[i] += Dr)
          }
          c[i] -= f[i]
        }
        for (; c[--a] === 0; ) c.pop()
        for (; c[0] === 0; c.shift()) --r
        return c[0] ? ((t.d = c), (t.e = Fl(c, r)), Qe ? Ke(t, o, u) : t) : new T(u === 3 ? -0 : 0)
      }),
    (we.modulo = we.mod =
      function (t) {
        var e,
          r = this,
          i = r.constructor
        return (
          (t = new i(t)),
          !r.d || !t.s || (t.d && !t.d[0])
            ? new i(NaN)
            : !t.d || (r.d && !r.d[0])
            ? Ke(new i(r), i.precision, i.rounding)
            : ((Qe = !1),
              i.modulo == 9 ? ((e = vt(r, t.abs(), 0, 3, 1)), (e.s *= t.s)) : (e = vt(r, t, 0, i.modulo, 1)),
              (e = e.times(t)),
              (Qe = !0),
              r.minus(e))
        )
      }),
    (we.naturalExponential = we.exp =
      function () {
        return Wf(this)
      }),
    (we.naturalLogarithm = we.ln =
      function () {
        return Mi(this)
      }),
    (we.negated = we.neg =
      function () {
        var t = new this.constructor(this)
        return (t.s = -t.s), Ke(t)
      }),
    (we.plus = we.add =
      function (t) {
        var e,
          r,
          i,
          n,
          s,
          a,
          o,
          u,
          c,
          p,
          h = this,
          f = h.constructor
        if (((t = new f(t)), !h.d || !t.d))
          return !h.s || !t.s ? (t = new f(NaN)) : h.d || (t = new f(t.d || h.s === t.s ? h : NaN)), t
        if (h.s != t.s) return (t.s = -t.s), h.minus(t)
        if (((c = h.d), (p = t.d), (o = f.precision), (u = f.rounding), !c[0] || !p[0]))
          return p[0] || (t = new f(h)), Qe ? Ke(t, o, u) : t
        if (((s = Gt(h.e / Xe)), (i = Gt(t.e / Xe)), (c = c.slice()), (n = s - i), n)) {
          for (
            n < 0 ? ((r = c), (n = -n), (a = p.length)) : ((r = p), (i = s), (a = c.length)),
              s = Math.ceil(o / Xe),
              a = s > a ? s + 1 : a + 1,
              n > a && ((n = a), (r.length = 1)),
              r.reverse();
            n--;

          )
            r.push(0)
          r.reverse()
        }
        for (a = c.length, n = p.length, a - n < 0 && ((n = a), (r = p), (p = c), (c = r)), e = 0; n; )
          (e = ((c[--n] = c[n] + p[n] + e) / Dr) | 0), (c[n] %= Dr)
        for (e && (c.unshift(e), ++i), a = c.length; c[--a] == 0; ) c.pop()
        return (t.d = c), (t.e = Fl(c, i)), Qe ? Ke(t, o, u) : t
      }),
    (we.precision = we.sd =
      function (t) {
        var e,
          r = this
        if (t !== void 0 && t !== !!t && t !== 1 && t !== 0) throw Error(Bi + t)
        return r.d ? ((e = eb(r.d)), t && r.e + 1 > e && (e = r.e + 1)) : (e = NaN), e
      }),
    (we.round = function () {
      var t = this,
        e = t.constructor
      return Ke(new e(t), t.e + 1, e.rounding)
    }),
    (we.sine = we.sin =
      function () {
        var t,
          e,
          r = this,
          i = r.constructor
        return r.isFinite()
          ? r.isZero()
            ? new i(r)
            : ((t = i.precision),
              (e = i.rounding),
              (i.precision = t + Math.max(r.e, r.sd()) + Xe),
              (i.rounding = 1),
              (r = dZ(i, sb(i, r))),
              (i.precision = t),
              (i.rounding = e),
              Ke(ci > 2 ? r.neg() : r, t, e, !0))
          : new i(NaN)
      }),
    (we.squareRoot = we.sqrt =
      function () {
        var t,
          e,
          r,
          i,
          n,
          s,
          a = this,
          o = a.d,
          u = a.e,
          c = a.s,
          p = a.constructor
        if (c !== 1 || !o || !o[0]) return new p(!c || (c < 0 && (!o || o[0])) ? NaN : o ? a : 1 / 0)
        for (
          Qe = !1,
            c = Math.sqrt(+a),
            c == 0 || c == 1 / 0
              ? ((e = Rt(o)),
                (e.length + u) % 2 == 0 && (e += '0'),
                (c = Math.sqrt(e)),
                (u = Gt((u + 1) / 2) - (u < 0 || u % 2)),
                c == 1 / 0 ? (e = '5e' + u) : ((e = c.toExponential()), (e = e.slice(0, e.indexOf('e') + 1) + u)),
                (i = new p(e)))
              : (i = new p(c.toString())),
            r = (u = p.precision) + 3;
          ;

        )
          if (((s = i), (i = s.plus(vt(a, s, r + 2, 1)).times(0.5)), Rt(s.d).slice(0, r) === (e = Rt(i.d)).slice(0, r)))
            if (((e = e.slice(r - 3, r + 1)), e == '9999' || (!n && e == '4999'))) {
              if (!n && (Ke(s, u + 1, 0), s.times(s).eq(a))) {
                i = s
                break
              }
              ;(r += 4), (n = 1)
            } else {
              ;(!+e || (!+e.slice(1) && e.charAt(0) == '5')) && (Ke(i, u + 1, 1), (t = !i.times(i).eq(a)))
              break
            }
        return (Qe = !0), Ke(i, u, p.rounding, t)
      }),
    (we.tangent = we.tan =
      function () {
        var t,
          e,
          r = this,
          i = r.constructor
        return r.isFinite()
          ? r.isZero()
            ? new i(r)
            : ((t = i.precision),
              (e = i.rounding),
              (i.precision = t + 10),
              (i.rounding = 1),
              (r = r.sin()),
              (r.s = 1),
              (r = vt(r, new i(1).minus(r.times(r)).sqrt(), t + 10, 0)),
              (i.precision = t),
              (i.rounding = e),
              Ke(ci == 2 || ci == 4 ? r.neg() : r, t, e, !0))
          : new i(NaN)
      }),
    (we.times = we.mul =
      function (t) {
        var e,
          r,
          i,
          n,
          s,
          a,
          o,
          u,
          c,
          p = this,
          h = p.constructor,
          f = p.d,
          d = (t = new h(t)).d
        if (((t.s *= p.s), !f || !f[0] || !d || !d[0]))
          return new h(!t.s || (f && !f[0] && !d) || (d && !d[0] && !f) ? NaN : !f || !d ? t.s / 0 : t.s * 0)
        for (
          r = Gt(p.e / Xe) + Gt(t.e / Xe),
            u = f.length,
            c = d.length,
            u < c && ((s = f), (f = d), (d = s), (a = u), (u = c), (c = a)),
            s = [],
            a = u + c,
            i = a;
          i--;

        )
          s.push(0)
        for (i = c; --i >= 0; ) {
          for (e = 0, n = u + i; n > i; )
            (o = s[n] + d[i] * f[n - i - 1] + e), (s[n--] = o % Dr | 0), (e = (o / Dr) | 0)
          s[n] = (s[n] + e) % Dr | 0
        }
        for (; !s[--a]; ) s.pop()
        return e ? ++r : s.shift(), (t.d = s), (t.e = Fl(s, r)), Qe ? Ke(t, h.precision, h.rounding) : t
      }),
    (we.toBinary = function (t, e) {
      return Hf(this, 2, t, e)
    }),
    (we.toDecimalPlaces = we.toDP =
      function (t, e) {
        var r = this,
          i = r.constructor
        return (
          (r = new i(r)),
          t === void 0 ? r : (ur(t, 0, Di), e === void 0 ? (e = i.rounding) : ur(e, 0, 8), Ke(r, t + r.e + 1, e))
        )
      }),
    (we.toExponential = function (t, e) {
      var r,
        i = this,
        n = i.constructor
      return (
        t === void 0
          ? (r = Rr(i, !0))
          : (ur(t, 0, Di),
            e === void 0 ? (e = n.rounding) : ur(e, 0, 8),
            (i = Ke(new n(i), t + 1, e)),
            (r = Rr(i, !0, t + 1))),
        i.isNeg() && !i.isZero() ? '-' + r : r
      )
    }),
    (we.toFixed = function (t, e) {
      var r,
        i,
        n = this,
        s = n.constructor
      return (
        t === void 0
          ? (r = Rr(n))
          : (ur(t, 0, Di),
            e === void 0 ? (e = s.rounding) : ur(e, 0, 8),
            (i = Ke(new s(n), t + n.e + 1, e)),
            (r = Rr(i, !1, t + i.e + 1))),
        n.isNeg() && !n.isZero() ? '-' + r : r
      )
    }),
    (we.toFraction = function (t) {
      var e,
        r,
        i,
        n,
        s,
        a,
        o,
        u,
        c,
        p,
        h,
        f,
        d = this,
        T = d.d,
        y = d.constructor
      if (!T) return new y(d)
      if (
        ((c = r = new y(1)),
        (i = u = new y(0)),
        (e = new y(i)),
        (s = e.e = eb(T) - d.e - 1),
        (a = s % Xe),
        (e.d[0] = Bt(10, a < 0 ? Xe + a : a)),
        t == null)
      )
        t = s > 0 ? e : c
      else {
        if (((o = new y(t)), !o.isInt() || o.lt(c))) throw Error(Bi + o)
        t = o.gt(e) ? (s > 0 ? e : c) : o
      }
      for (
        Qe = !1, o = new y(Rt(T)), p = y.precision, y.precision = s = T.length * Xe * 2;
        (h = vt(o, e, 0, 1, 1)), (n = r.plus(h.times(i))), n.cmp(t) != 1;

      )
        (r = i), (i = n), (n = c), (c = u.plus(h.times(n))), (u = n), (n = e), (e = o.minus(h.times(n))), (o = n)
      return (
        (n = vt(t.minus(r), i, 0, 1, 1)),
        (u = u.plus(n.times(c))),
        (r = r.plus(n.times(i))),
        (u.s = c.s = d.s),
        (f = vt(c, i, s, 1).minus(d).abs().cmp(vt(u, r, s, 1).minus(d).abs()) < 1 ? [c, i] : [u, r]),
        (y.precision = p),
        (Qe = !0),
        f
      )
    }),
    (we.toHexadecimal = we.toHex =
      function (t, e) {
        return Hf(this, 16, t, e)
      }),
    (we.toNearest = function (t, e) {
      var r = this,
        i = r.constructor
      if (((r = new i(r)), t == null)) {
        if (!r.d) return r
        ;(t = new i(1)), (e = i.rounding)
      } else {
        if (((t = new i(t)), e === void 0 ? (e = i.rounding) : ur(e, 0, 8), !r.d)) return t.s ? r : t
        if (!t.d) return t.s && (t.s = r.s), t
      }
      return t.d[0] ? ((Qe = !1), (r = vt(r, t, 0, e, 1).times(t)), (Qe = !0), Ke(r)) : ((t.s = r.s), (r = t)), r
    }),
    (we.toNumber = function () {
      return +this
    }),
    (we.toOctal = function (t, e) {
      return Hf(this, 8, t, e)
    }),
    (we.toPower = we.pow =
      function (t) {
        var e,
          r,
          i,
          n,
          s,
          a,
          o = this,
          u = o.constructor,
          c = +(t = new u(t))
        if (!o.d || !t.d || !o.d[0] || !t.d[0]) return new u(Bt(+o, c))
        if (((o = new u(o)), o.eq(1))) return o
        if (((i = u.precision), (s = u.rounding), t.eq(1))) return Ke(o, i, s)
        if (((e = Gt(t.e / Xe)), e >= t.d.length - 1 && (r = c < 0 ? -c : c) <= cZ))
          return (n = tb(u, o, r, i)), t.s < 0 ? new u(1).div(n) : Ke(n, i, s)
        if (((a = o.s), a < 0)) {
          if (e < t.d.length - 1) return new u(NaN)
          if (((t.d[e] & 1) == 0 && (a = 1), o.e == 0 && o.d[0] == 1 && o.d.length == 1)) return (o.s = a), o
        }
        return (
          (r = Bt(+o, c)),
          (e = r == 0 || !isFinite(r) ? Gt(c * (Math.log('0.' + Rt(o.d)) / Math.LN10 + o.e + 1)) : new u(r + '').e),
          e > u.maxE + 1 || e < u.minE - 1
            ? new u(e > 0 ? a / 0 : 0)
            : ((Qe = !1),
              (u.rounding = o.s = 1),
              (r = Math.min(12, (e + '').length)),
              (n = Wf(t.times(Mi(o, i + r)), i)),
              n.d &&
                ((n = Ke(n, i + 5, 1)),
                ea(n.d, i, s) &&
                  ((e = i + 10),
                  (n = Ke(Wf(t.times(Mi(o, e + r)), e), e + 5, 1)),
                  +Rt(n.d).slice(i + 1, i + 15) + 1 == 1e14 && (n = Ke(n, i + 1, 0)))),
              (n.s = a),
              (Qe = !0),
              (u.rounding = s),
              Ke(n, i, s))
        )
      }),
    (we.toPrecision = function (t, e) {
      var r,
        i = this,
        n = i.constructor
      return (
        t === void 0
          ? (r = Rr(i, i.e <= n.toExpNeg || i.e >= n.toExpPos))
          : (ur(t, 1, Di),
            e === void 0 ? (e = n.rounding) : ur(e, 0, 8),
            (i = Ke(new n(i), t, e)),
            (r = Rr(i, t <= i.e || i.e <= n.toExpNeg, t))),
        i.isNeg() && !i.isZero() ? '-' + r : r
      )
    }),
    (we.toSignificantDigits = we.toSD =
      function (t, e) {
        var r = this,
          i = r.constructor
        return (
          t === void 0
            ? ((t = i.precision), (e = i.rounding))
            : (ur(t, 1, Di), e === void 0 ? (e = i.rounding) : ur(e, 0, 8)),
          Ke(new i(r), t, e)
        )
      }),
    (we.toString = function () {
      var t = this,
        e = t.constructor,
        r = Rr(t, t.e <= e.toExpNeg || t.e >= e.toExpPos)
      return t.isNeg() && !t.isZero() ? '-' + r : r
    }),
    (we.truncated = we.trunc =
      function () {
        return Ke(new this.constructor(this), this.e + 1, 1)
      }),
    (we.valueOf = we.toJSON =
      function () {
        var t = this,
          e = t.constructor,
          r = Rr(t, t.e <= e.toExpNeg || t.e >= e.toExpPos)
        return t.isNeg() ? '-' + r : r
      })
  function Rt(t) {
    var e,
      r,
      i,
      n = t.length - 1,
      s = '',
      a = t[0]
    if (n > 0) {
      for (s += a, e = 1; e < n; e++) (i = t[e] + ''), (r = Xe - i.length), r && (s += Li(r)), (s += i)
      ;(a = t[e]), (i = a + ''), (r = Xe - i.length), r && (s += Li(r))
    } else if (a === 0) return '0'
    for (; a % 10 === 0; ) a /= 10
    return s + a
  }
  function ur(t, e, r) {
    if (t !== ~~t || t < e || t > r) throw Error(Bi + t)
  }
  function ea(t, e, r, i) {
    var n, s, a, o
    for (s = t[0]; s >= 10; s /= 10) --e
    return (
      --e < 0 ? ((e += Xe), (n = 0)) : ((n = Math.ceil((e + 1) / Xe)), (e %= Xe)),
      (s = Bt(10, Xe - e)),
      (o = t[n] % s | 0),
      i == null
        ? e < 3
          ? (e == 0 ? (o = (o / 100) | 0) : e == 1 && (o = (o / 10) | 0),
            (a = (r < 4 && o == 99999) || (r > 3 && o == 49999) || o == 5e4 || o == 0))
          : (a =
              (((r < 4 && o + 1 == s) || (r > 3 && o + 1 == s / 2)) &&
                ((t[n + 1] / s / 100) | 0) == Bt(10, e - 2) - 1) ||
              ((o == s / 2 || o == 0) && ((t[n + 1] / s / 100) | 0) == 0))
        : e < 4
        ? (e == 0 ? (o = (o / 1e3) | 0) : e == 1 ? (o = (o / 100) | 0) : e == 2 && (o = (o / 10) | 0),
          (a = ((i || r < 4) && o == 9999) || (!i && r > 3 && o == 4999)))
        : (a =
            (((i || r < 4) && o + 1 == s) || (!i && r > 3 && o + 1 == s / 2)) &&
            ((t[n + 1] / s / 1e3) | 0) == Bt(10, e - 3) - 1),
      a
    )
  }
  function Ml(t, e, r) {
    for (var i, n = [0], s, a = 0, o = t.length; a < o; ) {
      for (s = n.length; s--; ) n[s] *= e
      for (n[0] += Uf.indexOf(t.charAt(a++)), i = 0; i < n.length; i++)
        n[i] > r - 1 && (n[i + 1] === void 0 && (n[i + 1] = 0), (n[i + 1] += (n[i] / r) | 0), (n[i] %= r))
    }
    return n.reverse()
  }
  function fZ(t, e) {
    var r, i, n
    if (e.isZero()) return e
    ;(i = e.d.length),
      i < 32
        ? ((r = Math.ceil(i / 3)), (n = (1 / Rl(4, r)).toString()))
        : ((r = 16), (n = '2.3283064365386962890625e-10')),
      (t.precision += r),
      (e = qn(t, 1, e.times(n), new t(1)))
    for (var s = r; s--; ) {
      var a = e.times(e)
      e = a.times(a).minus(a).times(8).plus(1)
    }
    return (t.precision -= r), e
  }
  var vt = (function () {
    function t(i, n, s) {
      var a,
        o = 0,
        u = i.length
      for (i = i.slice(); u--; ) (a = i[u] * n + o), (i[u] = a % s | 0), (o = (a / s) | 0)
      return o && i.unshift(o), i
    }
    function e(i, n, s, a) {
      var o, u
      if (s != a) u = s > a ? 1 : -1
      else
        for (o = u = 0; o < s; o++)
          if (i[o] != n[o]) {
            u = i[o] > n[o] ? 1 : -1
            break
          }
      return u
    }
    function r(i, n, s, a) {
      for (var o = 0; s--; ) (i[s] -= o), (o = i[s] < n[s] ? 1 : 0), (i[s] = o * a + i[s] - n[s])
      for (; !i[0] && i.length > 1; ) i.shift()
    }
    return function (i, n, s, a, o, u) {
      var c,
        p,
        h,
        f,
        d,
        T,
        y,
        b,
        m,
        S,
        E,
        P,
        x,
        D,
        N,
        I,
        B,
        K,
        Y,
        C,
        H = i.constructor,
        w = i.s == n.s ? 1 : -1,
        J = i.d,
        X = n.d
      if (!J || !J[0] || !X || !X[0])
        return new H(!i.s || !n.s || (J ? X && J[0] == X[0] : !X) ? NaN : (J && J[0] == 0) || !X ? w * 0 : w / 0)
      for (
        u ? ((d = 1), (p = i.e - n.e)) : ((u = Dr), (d = Xe), (p = Gt(i.e / d) - Gt(n.e / d))),
          Y = X.length,
          B = J.length,
          m = new H(w),
          S = m.d = [],
          h = 0;
        X[h] == (J[h] || 0);
        h++
      );
      if (
        (X[h] > (J[h] || 0) && p--,
        s == null ? ((D = s = H.precision), (a = H.rounding)) : o ? (D = s + (i.e - n.e) + 1) : (D = s),
        D < 0)
      )
        S.push(1), (T = !0)
      else {
        if (((D = (D / d + 2) | 0), (h = 0), Y == 1)) {
          for (f = 0, X = X[0], D++; (h < B || f) && D--; h++)
            (N = f * u + (J[h] || 0)), (S[h] = (N / X) | 0), (f = N % X | 0)
          T = f || h < B
        } else {
          for (
            f = (u / (X[0] + 1)) | 0,
              f > 1 && ((X = t(X, f, u)), (J = t(J, f, u)), (Y = X.length), (B = J.length)),
              I = Y,
              E = J.slice(0, Y),
              P = E.length;
            P < Y;

          )
            E[P++] = 0
          ;(C = X.slice()), C.unshift(0), (K = X[0]), X[1] >= u / 2 && ++K
          do
            (f = 0),
              (c = e(X, E, Y, P)),
              c < 0
                ? ((x = E[0]),
                  Y != P && (x = x * u + (E[1] || 0)),
                  (f = (x / K) | 0),
                  f > 1
                    ? (f >= u && (f = u - 1),
                      (y = t(X, f, u)),
                      (b = y.length),
                      (P = E.length),
                      (c = e(y, E, b, P)),
                      c == 1 && (f--, r(y, Y < b ? C : X, b, u)))
                    : (f == 0 && (c = f = 1), (y = X.slice())),
                  (b = y.length),
                  b < P && y.unshift(0),
                  r(E, y, P, u),
                  c == -1 && ((P = E.length), (c = e(X, E, Y, P)), c < 1 && (f++, r(E, Y < P ? C : X, P, u))),
                  (P = E.length))
                : c === 0 && (f++, (E = [0])),
              (S[h++] = f),
              c && E[0] ? (E[P++] = J[I] || 0) : ((E = [J[I]]), (P = 1))
          while ((I++ < B || E[0] !== void 0) && D--)
          T = E[0] !== void 0
        }
        S[0] || S.shift()
      }
      if (d == 1) (m.e = p), (XT = T)
      else {
        for (h = 1, f = S[0]; f >= 10; f /= 10) h++
        ;(m.e = h + p * d - 1), Ke(m, o ? s + m.e + 1 : s, a, T)
      }
      return m
    }
  })()
  function Ke(t, e, r, i) {
    var n,
      s,
      a,
      o,
      u,
      c,
      p,
      h,
      f,
      d = t.constructor
    e: if (e != null) {
      if (((h = t.d), !h)) return t
      for (n = 1, o = h[0]; o >= 10; o /= 10) n++
      if (((s = e - n), s < 0)) (s += Xe), (a = e), (p = h[(f = 0)]), (u = (p / Bt(10, n - a - 1)) % 10 | 0)
      else if (((f = Math.ceil((s + 1) / Xe)), (o = h.length), f >= o))
        if (i) {
          for (; o++ <= f; ) h.push(0)
          ;(p = u = 0), (n = 1), (s %= Xe), (a = s - Xe + 1)
        } else break e
      else {
        for (p = o = h[f], n = 1; o >= 10; o /= 10) n++
        ;(s %= Xe), (a = s - Xe + n), (u = a < 0 ? 0 : (p / Bt(10, n - a - 1)) % 10 | 0)
      }
      if (
        ((i = i || e < 0 || h[f + 1] !== void 0 || (a < 0 ? p : p % Bt(10, n - a - 1))),
        (c =
          r < 4
            ? (u || i) && (r == 0 || r == (t.s < 0 ? 3 : 2))
            : u > 5 ||
              (u == 5 &&
                (r == 4 ||
                  i ||
                  (r == 6 && (s > 0 ? (a > 0 ? p / Bt(10, n - a) : 0) : h[f - 1]) % 10 & 1) ||
                  r == (t.s < 0 ? 8 : 7)))),
        e < 1 || !h[0])
      )
        return (
          (h.length = 0),
          c ? ((e -= t.e + 1), (h[0] = Bt(10, (Xe - (e % Xe)) % Xe)), (t.e = -e || 0)) : (h[0] = t.e = 0),
          t
        )
      if (
        (s == 0
          ? ((h.length = f), (o = 1), f--)
          : ((h.length = f + 1), (o = Bt(10, Xe - s)), (h[f] = a > 0 ? ((p / Bt(10, n - a)) % Bt(10, a) | 0) * o : 0)),
        c)
      )
        for (;;)
          if (f == 0) {
            for (s = 1, a = h[0]; a >= 10; a /= 10) s++
            for (a = h[0] += o, o = 1; a >= 10; a /= 10) o++
            s != o && (t.e++, h[0] == Dr && (h[0] = 1))
            break
          } else {
            if (((h[f] += o), h[f] != Dr)) break
            ;(h[f--] = 0), (o = 1)
          }
      for (s = h.length; h[--s] === 0; ) h.pop()
    }
    return Qe && (t.e > d.maxE ? ((t.d = null), (t.e = NaN)) : t.e < d.minE && ((t.e = 0), (t.d = [0]))), t
  }
  function Rr(t, e, r) {
    if (!t.isFinite()) return nb(t)
    var i,
      n = t.e,
      s = Rt(t.d),
      a = s.length
    return (
      e
        ? (r && (i = r - a) > 0
            ? (s = s.charAt(0) + '.' + s.slice(1) + Li(i))
            : a > 1 && (s = s.charAt(0) + '.' + s.slice(1)),
          (s = s + (t.e < 0 ? 'e' : 'e+') + t.e))
        : n < 0
        ? ((s = '0.' + Li(-n - 1) + s), r && (i = r - a) > 0 && (s += Li(i)))
        : n >= a
        ? ((s += Li(n + 1 - a)), r && (i = r - n - 1) > 0 && (s = s + '.' + Li(i)))
        : ((i = n + 1) < a && (s = s.slice(0, i) + '.' + s.slice(i)),
          r && (i = r - a) > 0 && (n + 1 === a && (s += '.'), (s += Li(i)))),
      s
    )
  }
  function Fl(t, e) {
    var r = t[0]
    for (e *= Xe; r >= 10; r /= 10) e++
    return e
  }
  function $l(t, e, r) {
    if (e > pZ) throw ((Qe = !0), r && (t.precision = r), Error(GT))
    return Ke(new t(Dl), e, 1, !0)
  }
  function Br(t, e, r) {
    if (e > Kf) throw Error(GT)
    return Ke(new t(Bl), e, r, !0)
  }
  function eb(t) {
    var e = t.length - 1,
      r = e * Xe + 1
    if (((e = t[e]), e)) {
      for (; e % 10 == 0; e /= 10) r--
      for (e = t[0]; e >= 10; e /= 10) r++
    }
    return r
  }
  function Li(t) {
    for (var e = ''; t--; ) e += '0'
    return e
  }
  function tb(t, e, r, i) {
    var n,
      s = new t(1),
      a = Math.ceil(i / Xe + 4)
    for (Qe = !1; ; ) {
      if ((r % 2 && ((s = s.times(e)), ab(s.d, a) && (n = !0)), (r = Gt(r / 2)), r === 0)) {
        ;(r = s.d.length - 1), n && s.d[r] === 0 && ++s.d[r]
        break
      }
      ;(e = e.times(e)), ab(e.d, a)
    }
    return (Qe = !0), s
  }
  function rb(t) {
    return t.d[t.d.length - 1] & 1
  }
  function ib(t, e, r) {
    for (var i, n = new t(e[0]), s = 0; ++s < e.length; )
      if (((i = new t(e[s])), i.s)) n[r](i) && (n = i)
      else {
        n = i
        break
      }
    return n
  }
  function Wf(t, e) {
    var r,
      i,
      n,
      s,
      a,
      o,
      u,
      c = 0,
      p = 0,
      h = 0,
      f = t.constructor,
      d = f.rounding,
      T = f.precision
    if (!t.d || !t.d[0] || t.e > 17)
      return new f(t.d ? (t.d[0] ? (t.s < 0 ? 0 : 1 / 0) : 1) : t.s ? (t.s < 0 ? 0 : t) : 0 / 0)
    for (e == null ? ((Qe = !1), (u = T)) : (u = e), o = new f(0.03125); t.e > -2; ) (t = t.times(o)), (h += 5)
    for (i = ((Math.log(Bt(2, h)) / Math.LN10) * 2 + 5) | 0, u += i, r = s = a = new f(1), f.precision = u; ; ) {
      if (
        ((s = Ke(s.times(t), u, 1)),
        (r = r.times(++p)),
        (o = a.plus(vt(s, r, u, 1))),
        Rt(o.d).slice(0, u) === Rt(a.d).slice(0, u))
      ) {
        for (n = h; n--; ) a = Ke(a.times(a), u, 1)
        if (e == null)
          if (c < 3 && ea(a.d, u - i, d, c)) (f.precision = u += 10), (r = s = o = new f(1)), (p = 0), c++
          else return Ke(a, (f.precision = T), d, (Qe = !0))
        else return (f.precision = T), a
      }
      a = o
    }
  }
  function Mi(t, e) {
    var r,
      i,
      n,
      s,
      a,
      o,
      u,
      c,
      p,
      h,
      f,
      d = 1,
      T = 10,
      y = t,
      b = y.d,
      m = y.constructor,
      S = m.rounding,
      E = m.precision
    if (y.s < 0 || !b || !b[0] || (!y.e && b[0] == 1 && b.length == 1))
      return new m(b && !b[0] ? -1 / 0 : y.s != 1 ? NaN : b ? 0 : y)
    if (
      (e == null ? ((Qe = !1), (p = E)) : (p = e),
      (m.precision = p += T),
      (r = Rt(b)),
      (i = r.charAt(0)),
      Math.abs((s = y.e)) < 15e14)
    ) {
      for (; (i < 7 && i != 1) || (i == 1 && r.charAt(1) > 3); ) (y = y.times(t)), (r = Rt(y.d)), (i = r.charAt(0)), d++
      ;(s = y.e), i > 1 ? ((y = new m('0.' + r)), s++) : (y = new m(i + '.' + r.slice(1)))
    } else return (c = $l(m, p + 2, E).times(s + '')), (y = Mi(new m(i + '.' + r.slice(1)), p - T).plus(c)), (m.precision = E), e == null ? Ke(y, E, S, (Qe = !0)) : y
    for (h = y, u = a = y = vt(y.minus(1), y.plus(1), p, 1), f = Ke(y.times(y), p, 1), n = 3; ; ) {
      if (
        ((a = Ke(a.times(f), p, 1)), (c = u.plus(vt(a, new m(n), p, 1))), Rt(c.d).slice(0, p) === Rt(u.d).slice(0, p))
      )
        if (
          ((u = u.times(2)),
          s !== 0 && (u = u.plus($l(m, p + 2, E).times(s + ''))),
          (u = vt(u, new m(d), p, 1)),
          e == null)
        )
          if (ea(u.d, p - T, S, o))
            (m.precision = p += T),
              (c = a = y = vt(h.minus(1), h.plus(1), p, 1)),
              (f = Ke(y.times(y), p, 1)),
              (n = o = 1)
          else return Ke(u, (m.precision = E), S, (Qe = !0))
        else return (m.precision = E), u
      ;(u = c), (n += 2)
    }
  }
  function nb(t) {
    return String((t.s * t.s) / 0)
  }
  function Yf(t, e) {
    var r, i, n
    for (
      (r = e.indexOf('.')) > -1 && (e = e.replace('.', '')),
        (i = e.search(/e/i)) > 0
          ? (r < 0 && (r = i), (r += +e.slice(i + 1)), (e = e.substring(0, i)))
          : r < 0 && (r = e.length),
        i = 0;
      e.charCodeAt(i) === 48;
      i++
    );
    for (n = e.length; e.charCodeAt(n - 1) === 48; --n);
    if (((e = e.slice(i, n)), e)) {
      if (((n -= i), (t.e = r = r - i - 1), (t.d = []), (i = (r + 1) % Xe), r < 0 && (i += Xe), i < n)) {
        for (i && t.d.push(+e.slice(0, i)), n -= Xe; i < n; ) t.d.push(+e.slice(i, (i += Xe)))
        ;(e = e.slice(i)), (i = Xe - e.length)
      } else i -= n
      for (; i--; ) e += '0'
      t.d.push(+e),
        Qe &&
          (t.e > t.constructor.maxE
            ? ((t.d = null), (t.e = NaN))
            : t.e < t.constructor.minE && ((t.e = 0), (t.d = [0])))
    } else (t.e = 0), (t.d = [0])
    return t
  }
  function hZ(t, e) {
    var r, i, n, s, a, o, u, c, p
    if (e.indexOf('_') > -1) {
      if (((e = e.replace(/(\d)_(?=\d)/g, '$1')), QT.test(e))) return Yf(t, e)
    } else if (e === 'Infinity' || e === 'NaN') return +e || (t.s = NaN), (t.e = NaN), (t.d = null), t
    if (lZ.test(e)) (r = 16), (e = e.toLowerCase())
    else if (oZ.test(e)) r = 2
    else if (uZ.test(e)) r = 8
    else throw Error(Bi + e)
    for (
      s = e.search(/p/i),
        s > 0 ? ((u = +e.slice(s + 1)), (e = e.substring(2, s))) : (e = e.slice(2)),
        s = e.indexOf('.'),
        a = s >= 0,
        i = t.constructor,
        a && ((e = e.replace('.', '')), (o = e.length), (s = o - s), (n = tb(i, new i(r), s, s * 2))),
        c = Ml(e, r, Dr),
        p = c.length - 1,
        s = p;
      c[s] === 0;
      --s
    )
      c.pop()
    return s < 0
      ? new i(t.s * 0)
      : ((t.e = Fl(c, p)),
        (t.d = c),
        (Qe = !1),
        a && (t = vt(t, n, o * 4)),
        u && (t = t.times(Math.abs(u) < 54 ? Bt(2, u) : Fi.pow(2, u))),
        (Qe = !0),
        t)
  }
  function dZ(t, e) {
    var r,
      i = e.d.length
    if (i < 3) return e.isZero() ? e : qn(t, 2, e, e)
    ;(r = 1.4 * Math.sqrt(i)), (r = r > 16 ? 16 : r | 0), (e = e.times(1 / Rl(5, r))), (e = qn(t, 2, e, e))
    for (var n, s = new t(5), a = new t(16), o = new t(20); r--; )
      (n = e.times(e)), (e = e.times(s.plus(n.times(a.times(n).minus(o)))))
    return e
  }
  function qn(t, e, r, i, n) {
    var s,
      a,
      o,
      u,
      c = t.precision,
      p = Math.ceil(c / Xe)
    for (Qe = !1, u = r.times(r), o = new t(i); ; ) {
      if (
        ((a = vt(o.times(u), new t(e++ * e++), c, 1)),
        (o = n ? i.plus(a) : i.minus(a)),
        (i = vt(a.times(u), new t(e++ * e++), c, 1)),
        (a = o.plus(i)),
        a.d[p] !== void 0)
      ) {
        for (s = p; a.d[s] === o.d[s] && s--; );
        if (s == -1) break
      }
      ;(s = o), (o = i), (i = a), (a = s)
    }
    return (Qe = !0), (a.d.length = p + 1), a
  }
  function Rl(t, e) {
    for (var r = t; --e; ) r *= t
    return r
  }
  function sb(t, e) {
    var r,
      i = e.s < 0,
      n = Br(t, t.precision, 1),
      s = n.times(0.5)
    if (((e = e.abs()), e.lte(s))) return (ci = i ? 4 : 1), e
    if (((r = e.divToInt(n)), r.isZero())) ci = i ? 3 : 2
    else {
      if (((e = e.minus(r.times(n))), e.lte(s))) return (ci = rb(r) ? (i ? 2 : 3) : i ? 4 : 1), e
      ci = rb(r) ? (i ? 1 : 4) : i ? 3 : 2
    }
    return e.minus(n).abs()
  }
  function Hf(t, e, r, i) {
    var n,
      s,
      a,
      o,
      u,
      c,
      p,
      h,
      f,
      d = t.constructor,
      T = r !== void 0
    if (
      (T ? (ur(r, 1, Di), i === void 0 ? (i = d.rounding) : ur(i, 0, 8)) : ((r = d.precision), (i = d.rounding)),
      !t.isFinite())
    )
      p = nb(t)
    else {
      for (
        p = Rr(t),
          a = p.indexOf('.'),
          T ? ((n = 2), e == 16 ? (r = r * 4 - 3) : e == 8 && (r = r * 3 - 2)) : (n = e),
          a >= 0 &&
            ((p = p.replace('.', '')),
            (f = new d(1)),
            (f.e = p.length - a),
            (f.d = Ml(Rr(f), 10, n)),
            (f.e = f.d.length)),
          h = Ml(p, 10, n),
          s = u = h.length;
        h[--u] == 0;

      )
        h.pop()
      if (!h[0]) p = T ? '0p+0' : '0'
      else {
        if (
          (a < 0
            ? s--
            : ((t = new d(t)), (t.d = h), (t.e = s), (t = vt(t, f, r, i, 0, n)), (h = t.d), (s = t.e), (c = XT)),
          (a = h[r]),
          (o = n / 2),
          (c = c || h[r + 1] !== void 0),
          (c =
            i < 4
              ? (a !== void 0 || c) && (i === 0 || i === (t.s < 0 ? 3 : 2))
              : a > o || (a === o && (i === 4 || c || (i === 6 && h[r - 1] & 1) || i === (t.s < 0 ? 8 : 7)))),
          (h.length = r),
          c)
        )
          for (; ++h[--r] > n - 1; ) (h[r] = 0), r || (++s, h.unshift(1))
        for (u = h.length; !h[u - 1]; --u);
        for (a = 0, p = ''; a < u; a++) p += Uf.charAt(h[a])
        if (T) {
          if (u > 1)
            if (e == 16 || e == 8) {
              for (a = e == 16 ? 4 : 3, --u; u % a; u++) p += '0'
              for (h = Ml(p, n, e), u = h.length; !h[u - 1]; --u);
              for (a = 1, p = '1.'; a < u; a++) p += Uf.charAt(h[a])
            } else p = p.charAt(0) + '.' + p.slice(1)
          p = p + (s < 0 ? 'p' : 'p+') + s
        } else if (s < 0) {
          for (; ++s; ) p = '0' + p
          p = '0.' + p
        } else if (++s > u) for (s -= u; s--; ) p += '0'
        else s < u && (p = p.slice(0, s) + '.' + p.slice(s))
      }
      p = (e == 16 ? '0x' : e == 2 ? '0b' : e == 8 ? '0o' : '') + p
    }
    return t.s < 0 ? '-' + p : p
  }
  function ab(t, e) {
    if (t.length > e) return (t.length = e), !0
  }
  function mZ(t) {
    return new this(t).abs()
  }
  function yZ(t) {
    return new this(t).acos()
  }
  function gZ(t) {
    return new this(t).acosh()
  }
  function TZ(t, e) {
    return new this(t).plus(e)
  }
  function bZ(t) {
    return new this(t).asin()
  }
  function SZ(t) {
    return new this(t).asinh()
  }
  function vZ(t) {
    return new this(t).atan()
  }
  function EZ(t) {
    return new this(t).atanh()
  }
  function PZ(t, e) {
    ;(t = new this(t)), (e = new this(e))
    var r,
      i = this.precision,
      n = this.rounding,
      s = i + 4
    return (
      !t.s || !e.s
        ? (r = new this(NaN))
        : !t.d && !e.d
        ? ((r = Br(this, s, 1).times(e.s > 0 ? 0.25 : 0.75)), (r.s = t.s))
        : !e.d || t.isZero()
        ? ((r = e.s < 0 ? Br(this, i, n) : new this(0)), (r.s = t.s))
        : !t.d || e.isZero()
        ? ((r = Br(this, s, 1).times(0.5)), (r.s = t.s))
        : e.s < 0
        ? ((this.precision = s),
          (this.rounding = 1),
          (r = this.atan(vt(t, e, s, 1))),
          (e = Br(this, s, 1)),
          (this.precision = i),
          (this.rounding = n),
          (r = t.s < 0 ? r.minus(e) : r.plus(e)))
        : (r = this.atan(vt(t, e, s, 1))),
      r
    )
  }
  function wZ(t) {
    return new this(t).cbrt()
  }
  function AZ(t) {
    return Ke((t = new this(t)), t.e + 1, 2)
  }
  function CZ(t, e, r) {
    return new this(t).clamp(e, r)
  }
  function xZ(t) {
    if (!t || typeof t != 'object') throw Error(Ll + 'Object expected')
    var e,
      r,
      i,
      n = t.defaults === !0,
      s = [
        'precision',
        1,
        Di,
        'rounding',
        0,
        8,
        'toExpNeg',
        -Hn,
        0,
        'toExpPos',
        0,
        Hn,
        'maxE',
        0,
        Hn,
        'minE',
        -Hn,
        0,
        'modulo',
        0,
        9,
      ]
    for (e = 0; e < s.length; e += 3)
      if (((r = s[e]), n && (this[r] = zf[r]), (i = t[r]) !== void 0))
        if (Gt(i) === i && i >= s[e + 1] && i <= s[e + 2]) this[r] = i
        else throw Error(Bi + r + ': ' + i)
    if (((r = 'crypto'), n && (this[r] = zf[r]), (i = t[r]) !== void 0))
      if (i === !0 || i === !1 || i === 0 || i === 1)
        if (i)
          if (typeof crypto != 'undefined' && crypto && (crypto.getRandomValues || crypto.randomBytes)) this[r] = !0
          else throw Error(JT)
        else this[r] = !1
      else throw Error(Bi + r + ': ' + i)
    return this
  }
  function IZ(t) {
    return new this(t).cos()
  }
  function kZ(t) {
    return new this(t).cosh()
  }
  function ob(t) {
    var e, r, i
    function n(s) {
      var a,
        o,
        u,
        c = this
      if (!(c instanceof n)) return new n(s)
      if (((c.constructor = n), lb(s))) {
        ;(c.s = s.s),
          Qe
            ? !s.d || s.e > n.maxE
              ? ((c.e = NaN), (c.d = null))
              : s.e < n.minE
              ? ((c.e = 0), (c.d = [0]))
              : ((c.e = s.e), (c.d = s.d.slice()))
            : ((c.e = s.e), (c.d = s.d ? s.d.slice() : s.d))
        return
      }
      if (((u = typeof s), u === 'number')) {
        if (s === 0) {
          ;(c.s = 1 / s < 0 ? -1 : 1), (c.e = 0), (c.d = [0])
          return
        }
        if ((s < 0 ? ((s = -s), (c.s = -1)) : (c.s = 1), s === ~~s && s < 1e7)) {
          for (a = 0, o = s; o >= 10; o /= 10) a++
          Qe
            ? a > n.maxE
              ? ((c.e = NaN), (c.d = null))
              : a < n.minE
              ? ((c.e = 0), (c.d = [0]))
              : ((c.e = a), (c.d = [s]))
            : ((c.e = a), (c.d = [s]))
          return
        } else if (s * 0 !== 0) {
          s || (c.s = NaN), (c.e = NaN), (c.d = null)
          return
        }
        return Yf(c, s.toString())
      } else if (u !== 'string') throw Error(Bi + s)
      return (
        (o = s.charCodeAt(0)) === 45 ? ((s = s.slice(1)), (c.s = -1)) : (o === 43 && (s = s.slice(1)), (c.s = 1)),
        QT.test(s) ? Yf(c, s) : hZ(c, s)
      )
    }
    if (
      ((n.prototype = we),
      (n.ROUND_UP = 0),
      (n.ROUND_DOWN = 1),
      (n.ROUND_CEIL = 2),
      (n.ROUND_FLOOR = 3),
      (n.ROUND_HALF_UP = 4),
      (n.ROUND_HALF_DOWN = 5),
      (n.ROUND_HALF_EVEN = 6),
      (n.ROUND_HALF_CEIL = 7),
      (n.ROUND_HALF_FLOOR = 8),
      (n.EUCLID = 9),
      (n.config = n.set = xZ),
      (n.clone = ob),
      (n.isDecimal = lb),
      (n.abs = mZ),
      (n.acos = yZ),
      (n.acosh = gZ),
      (n.add = TZ),
      (n.asin = bZ),
      (n.asinh = SZ),
      (n.atan = vZ),
      (n.atanh = EZ),
      (n.atan2 = PZ),
      (n.cbrt = wZ),
      (n.ceil = AZ),
      (n.clamp = CZ),
      (n.cos = IZ),
      (n.cosh = kZ),
      (n.div = NZ),
      (n.exp = OZ),
      (n.floor = DZ),
      (n.hypot = BZ),
      (n.ln = LZ),
      (n.log = MZ),
      (n.log10 = $Z),
      (n.log2 = FZ),
      (n.max = RZ),
      (n.min = jZ),
      (n.mod = _Z),
      (n.mul = VZ),
      (n.pow = UZ),
      (n.random = zZ),
      (n.round = KZ),
      (n.sign = WZ),
      (n.sin = YZ),
      (n.sinh = HZ),
      (n.sqrt = qZ),
      (n.sub = XZ),
      (n.sum = GZ),
      (n.tan = JZ),
      (n.tanh = ZZ),
      (n.trunc = QZ),
      t === void 0 && (t = {}),
      t && t.defaults !== !0)
    )
      for (
        i = ['precision', 'rounding', 'toExpNeg', 'toExpPos', 'maxE', 'minE', 'modulo', 'crypto'], e = 0;
        e < i.length;

      )
        t.hasOwnProperty((r = i[e++])) || (t[r] = this[r])
    return n.config(t), n
  }
  function NZ(t, e) {
    return new this(t).div(e)
  }
  function OZ(t) {
    return new this(t).exp()
  }
  function DZ(t) {
    return Ke((t = new this(t)), t.e + 1, 3)
  }
  function BZ() {
    var t,
      e,
      r = new this(0)
    for (Qe = !1, t = 0; t < arguments.length; )
      if (((e = new this(arguments[t++])), e.d)) r.d && (r = r.plus(e.times(e)))
      else {
        if (e.s) return (Qe = !0), new this(1 / 0)
        r = e
      }
    return (Qe = !0), r.sqrt()
  }
  function lb(t) {
    return t instanceof Fi || (t && t.toStringTag === ZT) || !1
  }
  function LZ(t) {
    return new this(t).ln()
  }
  function MZ(t, e) {
    return new this(t).log(e)
  }
  function FZ(t) {
    return new this(t).log(2)
  }
  function $Z(t) {
    return new this(t).log(10)
  }
  function RZ() {
    return ib(this, arguments, 'lt')
  }
  function jZ() {
    return ib(this, arguments, 'gt')
  }
  function _Z(t, e) {
    return new this(t).mod(e)
  }
  function VZ(t, e) {
    return new this(t).mul(e)
  }
  function UZ(t, e) {
    return new this(t).pow(e)
  }
  function zZ(t) {
    var e,
      r,
      i,
      n,
      s = 0,
      a = new this(1),
      o = []
    if ((t === void 0 ? (t = this.precision) : ur(t, 1, Di), (i = Math.ceil(t / Xe)), this.crypto))
      if (crypto.getRandomValues)
        for (e = crypto.getRandomValues(new Uint32Array(i)); s < i; )
          (n = e[s]), n >= 429e7 ? (e[s] = crypto.getRandomValues(new Uint32Array(1))[0]) : (o[s++] = n % 1e7)
      else if (crypto.randomBytes) {
        for (e = crypto.randomBytes((i *= 4)); s < i; )
          (n = e[s] + (e[s + 1] << 8) + (e[s + 2] << 16) + ((e[s + 3] & 127) << 24)),
            n >= 214e7 ? crypto.randomBytes(4).copy(e, s) : (o.push(n % 1e7), (s += 4))
        s = i / 4
      } else throw Error(JT)
    else for (; s < i; ) o[s++] = (Math.random() * 1e7) | 0
    for (i = o[--s], t %= Xe, i && t && ((n = Bt(10, Xe - t)), (o[s] = ((i / n) | 0) * n)); o[s] === 0; s--) o.pop()
    if (s < 0) (r = 0), (o = [0])
    else {
      for (r = -1; o[0] === 0; r -= Xe) o.shift()
      for (i = 1, n = o[0]; n >= 10; n /= 10) i++
      i < Xe && (r -= Xe - i)
    }
    return (a.e = r), (a.d = o), a
  }
  function KZ(t) {
    return Ke((t = new this(t)), t.e + 1, this.rounding)
  }
  function WZ(t) {
    return (t = new this(t)), t.d ? (t.d[0] ? t.s : 0 * t.s) : t.s || NaN
  }
  function YZ(t) {
    return new this(t).sin()
  }
  function HZ(t) {
    return new this(t).sinh()
  }
  function qZ(t) {
    return new this(t).sqrt()
  }
  function XZ(t, e) {
    return new this(t).sub(e)
  }
  function GZ() {
    var t = 0,
      e = arguments,
      r = new this(e[t])
    for (Qe = !1; r.s && ++t < e.length; ) r = r.plus(e[t])
    return (Qe = !0), Ke(r, this.precision, this.rounding)
  }
  function JZ(t) {
    return new this(t).tan()
  }
  function ZZ(t) {
    return new this(t).tanh()
  }
  function QZ(t) {
    return Ke((t = new this(t)), t.e + 1, 1)
  }
  ;(we[Symbol.for('nodejs.util.inspect.custom')] = we.toString), (we[Symbol.toStringTag] = 'Decimal')
  var Fi = (we.constructor = ob(zf))
  ;(Dl = new Fi(Dl)), (Bl = new Fi(Bl))
  var eQ = {
      modelValue: { type: [String, Number], default: 0 },
      min: { type: [String, Number] },
      max: { type: [String, Number] },
      step: { type: [String, Number], default: 1 },
      color: { type: String },
      inputWidth: { type: [String, Number] },
      inputTextSize: { type: [String, Number] },
      buttonSize: { type: [String, Number] },
      decimalLength: { type: [String, Number] },
      disabled: { type: Boolean, default: !1 },
      readonly: { type: Boolean, default: !1 },
      disableIncrement: { type: Boolean, default: !1 },
      disableDecrement: { type: Boolean, default: !1 },
      disableInput: { type: Boolean, default: !1 },
      lazyChange: { type: Boolean, default: !1 },
      incrementButton: { type: Boolean, default: !0 },
      decrementButton: { type: Boolean, default: !0 },
      press: { type: Boolean, default: !0 },
      ripple: { type: Boolean, default: !0 },
      validateTrigger: { type: Array, default: () => ['onInputChange', 'onLazyChange', 'onIncrement', 'onDecrement'] },
      rules: { type: Array },
      onBeforeChange: { type: Function },
      onChange: { type: Function },
      onIncrement: { type: Function },
      onDecrement: { type: Function },
      'onUpdate:modelValue': { type: Function },
    },
    { n: tQ, classes: rQ } = Me('counter'),
    ub = 100,
    cb = 600,
    iQ = ['inputmode', 'readonly', 'disabled']
  function nQ(t, e) {
    var r = l.resolveComponent('var-icon'),
      i = l.resolveComponent('var-form-details'),
      n = l.resolveDirective('ripple')
    return (
      l.openBlock(),
      l.createElementBlock(
        'div',
        { class: l.normalizeClass(t.classes(t.n(), 'var--box')) },
        [
          l.createElementVNode(
            'div',
            l.mergeProps(
              {
                class: t.classes(
                  t.n('controller'),
                  'var-elevation--2',
                  [t.disabled || t.formDisabled, t.n('--disabled')],
                  [t.errorMessage, t.n('--error')]
                ),
                style: { background: t.color ? t.color : void 0 },
              },
              t.$attrs
            ),
            [
              l.withDirectives(
                l.createVNode(
                  r,
                  {
                    'var-counter-cover': '',
                    name: 'minus',
                    class: l.normalizeClass(t.classes(t.n('decrement-button'), [!t.decrementButton, t.n('--hidden')])),
                    style: l.normalizeStyle({ width: t.toSizeUnit(t.buttonSize), height: t.toSizeUnit(t.buttonSize) }),
                    onClick: t.decrement,
                    onTouchstart: t.pressDecrement,
                    onTouchend: t.releaseDecrement,
                    onTouchcancel: t.releaseDecrement,
                  },
                  null,
                  8,
                  ['class', 'style', 'onClick', 'onTouchstart', 'onTouchend', 'onTouchcancel']
                ),
                [
                  [
                    n,
                    {
                      disabled:
                        !t.ripple || t.disabled || t.readonly || t.disableDecrement || !t.decrementButton || t.isMin,
                    },
                  ],
                ]
              ),
              l.withDirectives(
                l.createElementVNode(
                  'input',
                  {
                    class: l.normalizeClass(t.n('input')),
                    style: l.normalizeStyle({
                      width: t.toSizeUnit(t.inputWidth),
                      fontSize: t.toSizeUnit(t.inputTextSize),
                    }),
                    inputmode: t.toNumber(t.decimalLength) === 0 ? 'numeric' : 'decimal',
                    readonly: t.readonly || t.formReadonly,
                    disabled: t.disabled || t.formDisabled || t.disableInput,
                    'onUpdate:modelValue': e[0] || (e[0] = (s) => (t.inputValue = s)),
                    onChange:
                      e[1] ||
                      (e[1] = function () {
                        return t.handleChange && t.handleChange(...arguments)
                      }),
                  },
                  null,
                  46,
                  iQ
                ),
                [[l.vModelText, t.inputValue]]
              ),
              l.withDirectives(
                l.createVNode(
                  r,
                  {
                    'var-counter-cover': '',
                    name: 'plus',
                    class: l.normalizeClass(t.classes(t.n('increment-button'), [!t.incrementButton, t.n('--hidden')])),
                    style: l.normalizeStyle({ width: t.toSizeUnit(t.buttonSize), height: t.toSizeUnit(t.buttonSize) }),
                    onClick: t.increment,
                    onTouchstart: t.pressIncrement,
                    onTouchend: t.releaseIncrement,
                    onTouchcancel: t.releaseIncrement,
                  },
                  null,
                  8,
                  ['class', 'style', 'onClick', 'onTouchstart', 'onTouchend', 'onTouchcancel']
                ),
                [
                  [
                    n,
                    {
                      disabled:
                        !t.ripple || t.disabled || t.readonly || t.disableIncrement || !t.incrementButton || t.isMax,
                    },
                  ],
                ]
              ),
            ],
            16
          ),
          l.createVNode(i, { 'error-message': t.errorMessage }, null, 8, ['error-message']),
        ],
        2
      )
    )
  }
  var qf = l.defineComponent({
    render: nQ,
    name: 'VarCounter',
    components: { VarIcon: kt, VarFormDetails: lr },
    directives: { Ripple: tr },
    inheritAttrs: !1,
    props: eQ,
    setup(t) {
      var e = l.ref(''),
        r,
        i,
        n,
        s,
        { bindForm: a, form: o } = Or(),
        { errorMessage: u, validateWithTrigger: c, validate: p, resetValidation: h } = Nr(),
        { readonly: f, disabled: d } = o != null ? o : {},
        T = () => p(t.rules, t.modelValue),
        y = (X) => {
          l.nextTick(() => {
            var { validateTrigger: G, rules: Te, modelValue: ce } = t
            c(G, X, Te, ce)
          })
        },
        b = () => {
          var { min: X } = t
          he(t['onUpdate:modelValue'], X != null ? Ee(X) : 0), h()
        },
        m = { reset: b, validate: T, resetValidation: h },
        S = l.computed(() => {
          var { max: X, modelValue: G } = t
          return X != null && Ee(G) >= Ee(X)
        }),
        E = l.computed(() => {
          var { min: X, modelValue: G } = t
          return X != null && Ee(G) <= Ee(X)
        }),
        P = (X) => {
          var { decimalLength: G, max: Te, min: ce } = t,
            se = Ee(X)
          return (
            Te != null && se > Ee(Te) && (se = Ee(Te)),
            ce != null && se < Ee(ce) && (se = Ee(ce)),
            (X = String(se)),
            G != null && (X = se.toFixed(Ee(G))),
            X
          )
        },
        x = (X) => {
          var { lazyChange: G, onBeforeChange: Te } = t,
            { value: ce } = X.target,
            se = P(ce)
          G ? he(Te, Ee(se), J) : w(se), y('onInputChange')
        },
        D = () => {
          var {
            disabled: X,
            readonly: G,
            disableDecrement: Te,
            decrementButton: ce,
            lazyChange: se,
            step: U,
            modelValue: W,
            onDecrement: ge,
            onBeforeChange: ye,
          } = t
          if (!((d != null && d.value) || (f != null && f.value) || X || G || Te || !ce) && !E.value) {
            var me = new Fi(Ee(W)).minus(new Fi(Ee(U))).toString(),
              ke = P(me),
              ae = Ee(ke)
            he(ge, ae), se ? he(ye, ae, J) : (w(ke), y('onDecrement'))
          }
        },
        N = () => {
          var {
            disabled: X,
            readonly: G,
            disableIncrement: Te,
            incrementButton: ce,
            lazyChange: se,
            step: U,
            modelValue: W,
            onIncrement: ge,
            onBeforeChange: ye,
          } = t
          if (!((d != null && d.value) || (f != null && f.value) || X || G || Te || !ce) && !S.value) {
            var me = new Fi(Ee(W)).plus(new Fi(Ee(U))).toString(),
              ke = P(me),
              ae = Ee(ke)
            he(ge, ae), se ? he(ye, ae, J) : (w(ke), y('onIncrement'))
          }
        },
        I = () => {
          var { press: X, lazyChange: G } = t
          !X ||
            G ||
            (s = window.setTimeout(() => {
              H()
            }, cb))
        },
        B = () => {
          var { press: X, lazyChange: G } = t
          !X ||
            G ||
            (n = window.setTimeout(() => {
              C()
            }, cb))
        },
        K = () => {
          i && clearTimeout(i), s && clearTimeout(s)
        },
        Y = () => {
          r && clearTimeout(r), n && clearTimeout(n)
        },
        C = () => {
          r = window.setTimeout(() => {
            N(), C()
          }, ub)
        },
        H = () => {
          i = window.setTimeout(() => {
            D(), H()
          }, ub)
        },
        w = (X) => {
          e.value = X
          var G = Ee(X)
          he(t['onUpdate:modelValue'], G)
        },
        J = (X) => {
          w(P(String(X))), y('onLazyChange')
        }
      return (
        he(a, m),
        l.watch(
          () => t.modelValue,
          (X) => {
            w(P(String(X))), he(t.onChange, Ee(X))
          }
        ),
        w(P(String(t.modelValue))),
        {
          n: tQ,
          classes: rQ,
          inputValue: e,
          errorMessage: u,
          formDisabled: d,
          formReadonly: f,
          isMax: S,
          isMin: E,
          validate: T,
          reset: b,
          resetValidation: h,
          handleChange: x,
          decrement: D,
          increment: N,
          pressDecrement: I,
          pressIncrement: B,
          releaseDecrement: K,
          releaseIncrement: Y,
          toSizeUnit: xt,
          toNumber: Ee,
        }
      )
    },
  })
  qf.install = function (t) {
    t.component(qf.name, qf)
  }
  var pb = 60,
    fb = pb * 60,
    hb = fb * 24,
    sQ = hb * 7,
    Xn = 1e3,
    Xf = pb * Xn,
    db = fb * Xn,
    aQ = hb * Xn,
    oQ = sQ * Xn,
    Gf = 'millisecond',
    Gn = 'second',
    Jn = 'minute',
    Zn = 'hour',
    $i = 'day',
    jl = 'week',
    Lr = 'month',
    mb = 'quarter',
    Ri = 'year',
    Qn = 'date',
    lQ = 'YYYY-MM-DDTHH:mm:ssZ',
    yb = 'Invalid Date',
    uQ = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/,
    cQ = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,
    pQ = {
      name: 'en',
      weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
      months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
    },
    Jf = function (e, r, i) {
      var n = String(e)
      return !n || n.length >= r ? e : '' + Array(r + 1 - n.length).join(i) + e
    },
    fQ = function (e) {
      var r = -e.utcOffset(),
        i = Math.abs(r),
        n = Math.floor(i / 60),
        s = i % 60
      return (r <= 0 ? '+' : '-') + Jf(n, 2, '0') + ':' + Jf(s, 2, '0')
    },
    hQ = function t(e, r) {
      if (e.date() < r.date()) return -t(r, e)
      var i = (r.year() - e.year()) * 12 + (r.month() - e.month()),
        n = e.clone().add(i, Lr),
        s = r - n < 0,
        a = e.clone().add(i + (s ? -1 : 1), Lr)
      return +(-(i + (r - n) / (s ? n - a : a - n)) || 0)
    },
    dQ = function (e) {
      return e < 0 ? Math.ceil(e) || 0 : Math.floor(e)
    },
    mQ = function (e) {
      var r = { M: Lr, y: Ri, w: jl, d: $i, D: Qn, h: Zn, m: Jn, s: Gn, ms: Gf, Q: mb }
      return (
        r[e] ||
        String(e || '')
          .toLowerCase()
          .replace(/s$/, '')
      )
    },
    yQ = function (e) {
      return e === void 0
    },
    gQ = { s: Jf, z: fQ, m: hQ, a: dQ, p: mQ, u: yQ },
    ta = 'en',
    yn = {}
  yn[ta] = pQ
  var Zf = function (e) {
      return e instanceof Vl
    },
    _l = function t(e, r, i) {
      var n
      if (!e) return ta
      if (typeof e == 'string') {
        var s = e.toLowerCase()
        yn[s] && (n = s), r && ((yn[s] = r), (n = s))
        var a = e.split('-')
        if (!n && a.length > 1) return t(a[0])
      } else {
        var o = e.name
        ;(yn[o] = e), (n = o)
      }
      return !i && n && (ta = n), n || (!i && ta)
    },
    Fe = function (e, r) {
      if (Zf(e)) return e.clone()
      var i = typeof r == 'object' ? r : {}
      return (i.date = e), (i.args = arguments), new Vl(i)
    },
    TQ = function (e, r) {
      return Fe(e, { locale: r.$L, utc: r.$u, x: r.$x, $offset: r.$offset })
    },
    Et = gQ
  ;(Et.l = _l), (Et.i = Zf), (Et.w = TQ)
  var bQ = function (e) {
      var r = e.date,
        i = e.utc
      if (r === null) return new Date(NaN)
      if (Et.u(r)) return new Date()
      if (r instanceof Date) return new Date(r)
      if (typeof r == 'string' && !/Z$/i.test(r)) {
        var n = r.match(uQ)
        if (n) {
          var s = n[2] - 1 || 0,
            a = (n[7] || '0').substring(0, 3)
          return i
            ? new Date(Date.UTC(n[1], s, n[3] || 1, n[4] || 0, n[5] || 0, n[6] || 0, a))
            : new Date(n[1], s, n[3] || 1, n[4] || 0, n[5] || 0, n[6] || 0, a)
        }
      }
      return new Date(r)
    },
    Vl = (function () {
      function t(r) {
        ;(this.$L = _l(r.locale, null, !0)), this.parse(r)
      }
      var e = t.prototype
      return (
        (e.parse = function (i) {
          ;(this.$d = bQ(i)), (this.$x = i.x || {}), this.init()
        }),
        (e.init = function () {
          var i = this.$d
          ;(this.$y = i.getFullYear()),
            (this.$M = i.getMonth()),
            (this.$D = i.getDate()),
            (this.$W = i.getDay()),
            (this.$H = i.getHours()),
            (this.$m = i.getMinutes()),
            (this.$s = i.getSeconds()),
            (this.$ms = i.getMilliseconds())
        }),
        (e.$utils = function () {
          return Et
        }),
        (e.isValid = function () {
          return this.$d.toString() !== yb
        }),
        (e.isSame = function (i, n) {
          var s = Fe(i)
          return this.startOf(n) <= s && s <= this.endOf(n)
        }),
        (e.isAfter = function (i, n) {
          return Fe(i) < this.startOf(n)
        }),
        (e.isBefore = function (i, n) {
          return this.endOf(n) < Fe(i)
        }),
        (e.$g = function (i, n, s) {
          return Et.u(i) ? this[n] : this.set(s, i)
        }),
        (e.unix = function () {
          return Math.floor(this.valueOf() / 1e3)
        }),
        (e.valueOf = function () {
          return this.$d.getTime()
        }),
        (e.startOf = function (i, n) {
          var s = this,
            a = Et.u(n) ? !0 : n,
            o = Et.p(i),
            u = function (m, S) {
              var E = Et.w(s.$u ? Date.UTC(s.$y, S, m) : new Date(s.$y, S, m), s)
              return a ? E : E.endOf($i)
            },
            c = function (m, S) {
              var E = [0, 0, 0, 0],
                P = [23, 59, 59, 999]
              return Et.w(s.toDate()[m].apply(s.toDate('s'), (a ? E : P).slice(S)), s)
            },
            p = this.$W,
            h = this.$M,
            f = this.$D,
            d = 'set' + (this.$u ? 'UTC' : '')
          switch (o) {
            case Ri:
              return a ? u(1, 0) : u(31, 11)
            case Lr:
              return a ? u(1, h) : u(0, h + 1)
            case jl: {
              var T = this.$locale().weekStart || 0,
                y = (p < T ? p + 7 : p) - T
              return u(a ? f - y : f + (6 - y), h)
            }
            case $i:
            case Qn:
              return c(d + 'Hours', 0)
            case Zn:
              return c(d + 'Minutes', 1)
            case Jn:
              return c(d + 'Seconds', 2)
            case Gn:
              return c(d + 'Milliseconds', 3)
            default:
              return this.clone()
          }
        }),
        (e.endOf = function (i) {
          return this.startOf(i, !1)
        }),
        (e.$set = function (i, n) {
          var s,
            a = Et.p(i),
            o = 'set' + (this.$u ? 'UTC' : ''),
            u = ((s = {}),
            (s[$i] = o + 'Date'),
            (s[Qn] = o + 'Date'),
            (s[Lr] = o + 'Month'),
            (s[Ri] = o + 'FullYear'),
            (s[Zn] = o + 'Hours'),
            (s[Jn] = o + 'Minutes'),
            (s[Gn] = o + 'Seconds'),
            (s[Gf] = o + 'Milliseconds'),
            s)[a],
            c = a === $i ? this.$D + (n - this.$W) : n
          if (a === Lr || a === Ri) {
            var p = this.clone().set(Qn, 1)
            p.$d[u](c), p.init(), (this.$d = p.set(Qn, Math.min(this.$D, p.daysInMonth())).$d)
          } else u && this.$d[u](c)
          return this.init(), this
        }),
        (e.set = function (i, n) {
          return this.clone().$set(i, n)
        }),
        (e.get = function (i) {
          return this[Et.p(i)]()
        }),
        (e.add = function (i, n) {
          var s = this,
            a
          i = Number(i)
          var o = Et.p(n),
            u = function (f) {
              var d = Fe(s)
              return Et.w(d.date(d.date() + Math.round(f * i)), s)
            }
          if (o === Lr) return this.set(Lr, this.$M + i)
          if (o === Ri) return this.set(Ri, this.$y + i)
          if (o === $i) return u(1)
          if (o === jl) return u(7)
          var c = ((a = {}), (a[Jn] = Xf), (a[Zn] = db), (a[Gn] = Xn), a)[o] || 1,
            p = this.$d.getTime() + i * c
          return Et.w(p, this)
        }),
        (e.subtract = function (i, n) {
          return this.add(i * -1, n)
        }),
        (e.format = function (i) {
          var n = this,
            s = this.$locale()
          if (!this.isValid()) return s.invalidDate || yb
          var a = i || lQ,
            o = Et.z(this),
            u = this.$H,
            c = this.$m,
            p = this.$M,
            h = s.weekdays,
            f = s.months,
            d = s.meridiem,
            T = function (E, P, x, D) {
              return (E && (E[P] || E(n, a))) || x[P].slice(0, D)
            },
            y = function (E) {
              return Et.s(u % 12 || 12, E, '0')
            },
            b =
              d ||
              function (S, E, P) {
                var x = S < 12 ? 'AM' : 'PM'
                return P ? x.toLowerCase() : x
              },
            m = {
              YY: String(this.$y).slice(-2),
              YYYY: this.$y,
              M: p + 1,
              MM: Et.s(p + 1, 2, '0'),
              MMM: T(s.monthsShort, p, f, 3),
              MMMM: T(f, p),
              D: this.$D,
              DD: Et.s(this.$D, 2, '0'),
              d: String(this.$W),
              dd: T(s.weekdaysMin, this.$W, h, 2),
              ddd: T(s.weekdaysShort, this.$W, h, 3),
              dddd: h[this.$W],
              H: String(u),
              HH: Et.s(u, 2, '0'),
              h: y(1),
              hh: y(2),
              a: b(u, c, !0),
              A: b(u, c, !1),
              m: String(c),
              mm: Et.s(c, 2, '0'),
              s: String(this.$s),
              ss: Et.s(this.$s, 2, '0'),
              SSS: Et.s(this.$ms, 3, '0'),
              Z: o,
            }
          return a.replace(cQ, function (S, E) {
            return E || m[S] || o.replace(':', '')
          })
        }),
        (e.utcOffset = function () {
          return -Math.round(this.$d.getTimezoneOffset() / 15) * 15
        }),
        (e.diff = function (i, n, s) {
          var a,
            o = Et.p(n),
            u = Fe(i),
            c = (u.utcOffset() - this.utcOffset()) * Xf,
            p = this - u,
            h = Et.m(this, u)
          return (
            (h =
              ((a = {}),
              (a[Ri] = h / 12),
              (a[Lr] = h),
              (a[mb] = h / 3),
              (a[jl] = (p - c) / oQ),
              (a[$i] = (p - c) / aQ),
              (a[Zn] = p / db),
              (a[Jn] = p / Xf),
              (a[Gn] = p / Xn),
              a)[o] || p),
            s ? h : Et.a(h)
          )
        }),
        (e.daysInMonth = function () {
          return this.endOf(Lr).$D
        }),
        (e.$locale = function () {
          return yn[this.$L]
        }),
        (e.locale = function (i, n) {
          if (!i) return this.$L
          var s = this.clone(),
            a = _l(i, n, !0)
          return a && (s.$L = a), s
        }),
        (e.clone = function () {
          return Et.w(this.$d, this)
        }),
        (e.toDate = function () {
          return new Date(this.valueOf())
        }),
        (e.toJSON = function () {
          return this.isValid() ? this.toISOString() : null
        }),
        (e.toISOString = function () {
          return this.$d.toISOString()
        }),
        (e.toString = function () {
          return this.$d.toUTCString()
        }),
        t
      )
    })(),
    gb = Vl.prototype
  ;(Fe.prototype = gb),
    [
      ['$ms', Gf],
      ['$s', Gn],
      ['$m', Jn],
      ['$H', Zn],
      ['$W', $i],
      ['$M', Lr],
      ['$y', Ri],
      ['$D', Qn],
    ].forEach(function (t) {
      gb[t[1]] = function (e) {
        return this.$g(e, t[0], t[1])
      }
    }),
    (Fe.extend = function (t, e) {
      return t.$i || (t(e, Vl, Fe), (t.$i = !0)), Fe
    }),
    (Fe.locale = _l),
    (Fe.isDayjs = Zf),
    (Fe.unix = function (t) {
      return Fe(t * 1e3)
    }),
    (Fe.en = yn[ta]),
    (Fe.Ls = yn),
    (Fe.p = {})
  var Tb = function (t, e) {
      e.prototype.isSameOrBefore = function (r, i) {
        return this.isSame(r, i) || this.isBefore(r, i)
      }
    },
    bb = function (t, e) {
      e.prototype.isSameOrAfter = function (r, i) {
        return this.isSame(r, i) || this.isAfter(r, i)
      }
    }
  function SQ(t) {
    return ['date', 'month'].includes(t)
  }
  var Ul = [
      { index: '01' },
      { index: '02' },
      { index: '03' },
      { index: '04' },
      { index: '05' },
      { index: '06' },
      { index: '07' },
      { index: '08' },
      { index: '09' },
      { index: '10' },
      { index: '11' },
      { index: '12' },
    ],
    ra = [
      { index: '0' },
      { index: '1' },
      { index: '2' },
      { index: '3' },
      { index: '4' },
      { index: '5' },
      { index: '6' },
    ],
    vQ = {
      modelValue: { type: [String, Array] },
      type: { type: String, default: 'date', validator: SQ },
      allowedDates: { type: Function },
      color: { type: String },
      headerColor: { type: String },
      shadow: { type: Boolean, default: !1 },
      firstDayOfWeek: { type: [String, Number], default: 0 },
      min: { type: String },
      max: { type: String },
      showCurrent: { type: Boolean, default: !0 },
      readonly: { type: Boolean, default: !1 },
      multiple: { type: Boolean, default: !1 },
      range: { type: Boolean, default: !1 },
      touchable: { type: Boolean, default: !0 },
      onChange: { type: Function },
      'onUpdate:modelValue': { type: Function },
    },
    { n: EQ } = Me('picker-header')
  function PQ(t, e) {
    var r = l.resolveComponent('var-icon'),
      i = l.resolveComponent('var-button')
    return (
      l.openBlock(),
      l.createElementBlock(
        'div',
        { class: l.normalizeClass(t.n()) },
        [
          l.createVNode(
            i,
            {
              round: '',
              text: '',
              style: { filter: 'opacity(0.54)' },
              disabled: t.disabled.left,
              onClick: e[0] || (e[0] = (n) => t.checkDate('prev')),
            },
            { default: l.withCtx(() => [l.createVNode(r, { name: 'chevron-left' })]), _: 1 },
            8,
            ['disabled']
          ),
          l.createElementVNode(
            'div',
            { class: l.normalizeClass(t.n('value')), onClick: e[1] || (e[1] = (n) => t.$emit('check-panel')) },
            [
              l.createVNode(
                l.Transition,
                { name: 'var-date-picker' + (t.reverse ? '-reverse' : '') + '-translatex' },
                {
                  default: l.withCtx(() => [
                    (l.openBlock(), l.createElementBlock('div', { key: t.showDate }, l.toDisplayString(t.showDate), 1)),
                  ]),
                  _: 1,
                },
                8,
                ['name']
              ),
            ],
            2
          ),
          l.createVNode(
            i,
            {
              round: '',
              text: '',
              style: { filter: 'opacity(0.54)' },
              disabled: t.disabled.right,
              onClick: e[2] || (e[2] = (n) => t.checkDate('next')),
            },
            { default: l.withCtx(() => [l.createVNode(r, { name: 'chevron-right' })]), _: 1 },
            8,
            ['disabled']
          ),
        ],
        2
      )
    )
  }
  var Sb = l.defineComponent({
    render: PQ,
    name: 'PanelHeader',
    components: { VarButton: Er, VarIcon: kt },
    props: {
      date: { type: Object, required: !0 },
      type: { type: String, default: 'date' },
      disabled: { type: Object, required: !0 },
    },
    emits: ['check-panel', 'check-date'],
    setup(t, e) {
      var { emit: r } = e,
        i = l.ref(!1),
        n = l.ref(0),
        s = l.computed(() => {
          var o,
            { date: u, type: c } = t,
            { previewMonth: p, previewYear: h } = u
          if (c === 'month') return Ee(h) + n.value
          var f = (o = Xt.value.datePickerMonthDict) == null ? void 0 : o[p.index].name
          return Xt.value.lang === 'zh-CN' ? h + ' ' + f : f + ' ' + h
        }),
        a = (o) => {
          ;(o === 'prev' && t.disabled.left) ||
            (o === 'next' && t.disabled.right) ||
            (r('check-date', o), (i.value = o === 'prev'), (n.value += o === 'prev' ? -1 : 1))
        }
      return (
        l.watch(
          () => t.date,
          () => {
            n.value = 0
          }
        ),
        { n: EQ, reverse: i, showDate: s, checkDate: a }
      )
    },
  })
  function Qf() {
    return (
      (Qf =
        Object.assign ||
        function (t) {
          for (var e = 1; e < arguments.length; e++) {
            var r = arguments[e]
            for (var i in r) Object.prototype.hasOwnProperty.call(r, i) && (t[i] = r[i])
          }
          return t
        }),
      Qf.apply(this, arguments)
    )
  }
  Fe.extend(Tb), Fe.extend(bb)
  var { n: zl, classes: wQ } = Me('month-picker'),
    { n: Kl } = Me('date-picker')
  function AQ(t, e) {
    var r = l.resolveComponent('panel-header'),
      i = l.resolveComponent('var-button')
    return (
      l.openBlock(),
      l.createElementBlock(
        'div',
        { class: l.normalizeClass(t.n()) },
        [
          l.createElementVNode(
            'div',
            { class: l.normalizeClass(t.n('content')) },
            [
              l.createVNode(
                r,
                {
                  ref: 'headerEl',
                  type: 'month',
                  date: t.preview,
                  disabled: t.panelBtnDisabled,
                  onCheckPanel: t.clickYear,
                  onCheckDate: t.checkDate,
                },
                null,
                8,
                ['date', 'disabled', 'onCheckPanel', 'onCheckDate']
              ),
              l.createVNode(
                l.Transition,
                { name: '' + t.nDate() + (t.reverse ? '-reverse' : '') + '-translatex' },
                {
                  default: l.withCtx(() => [
                    (l.openBlock(),
                    l.createElementBlock('ul', { key: t.panelKey }, [
                      (l.openBlock(!0),
                      l.createElementBlock(
                        l.Fragment,
                        null,
                        l.renderList(
                          t.MONTH_LIST,
                          (n) => (
                            l.openBlock(),
                            l.createElementBlock('li', { key: n.index }, [
                              l.createVNode(
                                i,
                                l.mergeProps(
                                  { type: 'primary', 'var-month-picker-cover': '', ripple: !1 },
                                  Qf({}, t.buttonProps(n.index)),
                                  { onClick: (s) => t.chooseMonth(n, s) }
                                ),
                                {
                                  default: l.withCtx(() => [
                                    l.createTextVNode(l.toDisplayString(t.getMonthAbbr(n.index)), 1),
                                  ]),
                                  _: 2,
                                },
                                1040,
                                ['onClick']
                              ),
                            ])
                          )
                        ),
                        128
                      )),
                    ])),
                  ]),
                  _: 1,
                },
                8,
                ['name']
              ),
            ],
            2
          ),
        ],
        2
      )
    )
  }
  var CQ = l.defineComponent({
      render: AQ,
      name: 'MonthPickerPanel',
      components: { VarButton: Er, PanelHeader: Sb },
      props: {
        choose: { type: Object, required: !0 },
        preview: { type: Object, required: !0 },
        current: { type: String, required: !0 },
        clickYear: { type: Function, required: !0 },
        componentProps: { type: Object, required: !0 },
      },
      emits: ['check-preview', 'choose-month'],
      setup(t, e) {
        var { emit: r } = e,
          [i, n] = t.current.split('-'),
          s = l.ref(!1),
          a = l.ref(0),
          o = l.ref(null),
          u = l.reactive({ left: !1, right: !1 }),
          c = l.computed(() => t.choose.chooseYear === t.preview.previewYear),
          p = l.computed(() => t.preview.previewYear === i),
          h = (S) => {
            var E, P
            return (E = (P = Xt.value.datePickerMonthDict) == null ? void 0 : P[S].abbr) != null ? E : ''
          },
          f = (S) => {
            var {
                preview: { previewYear: E },
                componentProps: { min: P, max: x },
              } = t,
              D = !0,
              N = !0,
              I = E + '-' + S
            return (
              x && (D = Fe(I).isSameOrBefore(Fe(x), 'month')), P && (N = Fe(I).isSameOrAfter(Fe(P), 'month')), D && N
            )
          },
          d = (S) => {
            var {
              choose: { chooseMonths: E, chooseDays: P, chooseRangeMonth: x },
              componentProps: { type: D, range: N },
            } = t
            if (N) {
              if (!x.length) return !1
              var I = Fe(S).isSameOrBefore(Fe(x[1]), 'month'),
                B = Fe(S).isSameOrAfter(Fe(x[0]), 'month')
              return I && B
            }
            return D === 'month' ? E.includes(S) : P.some((K) => K.includes(S))
          },
          T = (S) => {
            var {
                choose: { chooseMonth: E },
                preview: { previewYear: P },
                componentProps: { allowedDates: x, color: D, multiple: N, range: I },
              } = t,
              B = P + '-' + S,
              K = () => (I || N ? d(B) : (E == null ? void 0 : E.index) === S && c.value),
              Y = () => (f(S) ? (x ? !x(B) : !1) : !0),
              C = Y(),
              H = () => (C ? !0 : I || N ? !d(B) : !c.value || (E == null ? void 0 : E.index) !== S),
              w = () =>
                p.value && n === S && t.componentProps.showCurrent
                  ? (I || N || c.value) && C
                    ? !0
                    : I || N
                    ? !d(B)
                    : c.value
                    ? (E == null ? void 0 : E.index) !== n
                    : !0
                  : !1,
              J = () => (C ? '' : w() ? (D != null ? D : '') : K() ? '' : Kl() + '-color-cover'),
              X = J().startsWith(Kl())
            return {
              outline: w(),
              text: H(),
              color: H() ? '' : D,
              textColor: X ? '' : J(),
              [Kl() + '-color-cover']: X,
              class: wQ(zl('button'), [C, zl('button--disabled')]),
            }
          },
          y = (S, E) => {
            var P = E.currentTarget
            P.classList.contains(zl('button--disabled')) || r('choose-month', S)
          },
          b = (S) => {
            ;(s.value = S === 'prev'), (a.value += S === 'prev' ? -1 : 1), r('check-preview', 'year', S)
          },
          m = (S) => {
            o.value.checkDate(S)
          }
        return (
          l.watch(
            () => t.preview.previewYear,
            (S) => {
              var {
                componentProps: { min: E, max: P },
              } = t
              P && (u.right = !Fe('' + (Ee(S) + 1)).isSameOrBefore(Fe(P), 'year')),
                E && (u.left = !Fe('' + (Ee(S) - 1)).isSameOrAfter(Fe(E), 'year'))
            },
            { immediate: !0 }
          ),
          {
            n: zl,
            nDate: Kl,
            pack: Xt,
            MONTH_LIST: Ul,
            headerEl: o,
            reverse: s,
            panelKey: a,
            panelBtnDisabled: u,
            forwardRef: m,
            buttonProps: T,
            getMonthAbbr: h,
            chooseMonth: y,
            checkDate: b,
          }
        )
      },
    }),
    { n: vb, classes: xQ } = Me('year-picker'),
    IQ = ['onClick']
  function kQ(t, e) {
    return (
      l.openBlock(),
      l.createElementBlock(
        'ul',
        { class: l.normalizeClass(t.n()) },
        [
          (l.openBlock(!0),
          l.createElementBlock(
            l.Fragment,
            null,
            l.renderList(
              t.yearList,
              (r) => (
                l.openBlock(),
                l.createElementBlock(
                  'li',
                  {
                    key: r,
                    class: l.normalizeClass(t.classes(t.n('item'), [r === t.toNumber(t.preview), t.n('item--active')])),
                    style: l.normalizeStyle({ color: r === t.toNumber(t.preview) ? t.componentProps.color : '' }),
                    onClick: (i) => t.chooseYear(r),
                  },
                  l.toDisplayString(r),
                  15,
                  IQ
                )
              )
            ),
            128
          )),
        ],
        2
      )
    )
  }
  var NQ = l.defineComponent({
    render: kQ,
    name: 'YearPickerPanel',
    props: { preview: { type: String }, componentProps: { type: Object, required: !0 } },
    emits: ['choose-year'],
    setup(t, e) {
      var { emit: r } = e,
        i = l.computed(() => {
          var s = [],
            {
              preview: a,
              componentProps: { max: o, min: u },
            } = t
          if (!a) return s
          var c = [Ee(a) + 100, Ee(a) - 100]
          if (o) {
            var p = Fe(o).format('YYYY-MM-D'),
              h = Ee(p.split('-')[0])
            if ((h < c[0] && h > c[1] && (c = [h, c[1]]), h <= c[1])) return [h]
          }
          if (u) {
            var f = Fe(u).format('YYYY-MM-D'),
              d = Ee(f.split('-')[0])
            if ((d < c[0] && d > c[1] && (c = [c[0], d]), d >= c[0])) return [d]
          }
          for (var T = c[0]; T >= c[1]; T--) s.push(T)
          return s
        }),
        n = (s) => {
          r('choose-year', s)
        }
      return (
        l.onMounted(() => {
          var s = document.querySelector('.' + vb('item--active'))
          s == null || s.scrollIntoView({ block: 'center' })
        }),
        { n: vb, classes: xQ, yearList: i, chooseYear: n, toNumber: Ee }
      )
    },
  })
  function eh() {
    return (
      (eh =
        Object.assign ||
        function (t) {
          for (var e = 1; e < arguments.length; e++) {
            var r = arguments[e]
            for (var i in r) Object.prototype.hasOwnProperty.call(r, i) && (t[i] = r[i])
          }
          return t
        }),
      eh.apply(this, arguments)
    )
  }
  Fe.extend(Tb), Fe.extend(bb)
  var { n: es, classes: OQ } = Me('day-picker'),
    { n: Wl } = Me('date-picker')
  function DQ(t, e) {
    var r = l.resolveComponent('panel-header'),
      i = l.resolveComponent('var-button')
    return (
      l.openBlock(),
      l.createElementBlock(
        'div',
        { class: l.normalizeClass(t.n()) },
        [
          l.createElementVNode(
            'div',
            { class: l.normalizeClass(t.n('content')) },
            [
              l.createVNode(
                r,
                {
                  ref: 'headerEl',
                  type: 'day',
                  date: t.preview,
                  disabled: t.panelBtnDisabled,
                  onCheckPanel: t.clickMonth,
                  onCheckDate: t.checkDate,
                },
                null,
                8,
                ['date', 'disabled', 'onCheckPanel', 'onCheckDate']
              ),
              l.createVNode(
                l.Transition,
                { name: '' + t.nDate() + (t.reverse ? '-reverse' : '') + '-translatex' },
                {
                  default: l.withCtx(() => [
                    (l.openBlock(),
                    l.createElementBlock('div', { key: t.panelKey }, [
                      l.createElementVNode(
                        'ul',
                        { class: l.normalizeClass(t.n('head')) },
                        [
                          (l.openBlock(!0),
                          l.createElementBlock(
                            l.Fragment,
                            null,
                            l.renderList(
                              t.sortWeekList,
                              (n) => (
                                l.openBlock(),
                                l.createElementBlock(
                                  'li',
                                  { key: n.index },
                                  l.toDisplayString(t.getDayAbbr(n.index)),
                                  1
                                )
                              )
                            ),
                            128
                          )),
                        ],
                        2
                      ),
                      l.createElementVNode(
                        'ul',
                        { class: l.normalizeClass(t.n('body')) },
                        [
                          (l.openBlock(!0),
                          l.createElementBlock(
                            l.Fragment,
                            null,
                            l.renderList(
                              t.days,
                              (n, s) => (
                                l.openBlock(),
                                l.createElementBlock('li', { key: s }, [
                                  l.createVNode(
                                    i,
                                    l.mergeProps(
                                      { type: 'primary', 'var-day-picker-cover': '', round: '', ripple: !1 },
                                      eh({}, t.buttonProps(n)),
                                      { onClick: (a) => t.chooseDay(n, a) }
                                    ),
                                    {
                                      default: l.withCtx(() => [
                                        l.createTextVNode(l.toDisplayString(t.filterDay(n)), 1),
                                      ]),
                                      _: 2,
                                    },
                                    1040,
                                    ['onClick']
                                  ),
                                ])
                              )
                            ),
                            128
                          )),
                        ],
                        2
                      ),
                    ])),
                  ]),
                  _: 1,
                },
                8,
                ['name']
              ),
            ],
            2
          ),
        ],
        2
      )
    )
  }
  var BQ = l.defineComponent({
      render: DQ,
      name: 'DayPickerPanel',
      components: { VarButton: Er, PanelHeader: Sb },
      props: {
        choose: { type: Object, required: !0 },
        preview: { type: Object, required: !0 },
        current: { type: String, required: !0 },
        clickMonth: { type: Function, required: !0 },
        componentProps: { type: Object, required: !0 },
      },
      emits: ['check-preview', 'choose-day'],
      setup(t, e) {
        var { emit: r } = e,
          [i, n, s] = t.current.split('-'),
          a = l.ref([]),
          o = l.ref(!1),
          u = l.ref(0),
          c = l.ref(null),
          p = l.reactive({ left: !1, right: !1 }),
          h = l.computed(() => t.preview.previewYear === i && t.preview.previewMonth.index === n),
          f = l.computed(() => {
            var I
            return (
              t.choose.chooseYear === t.preview.previewYear &&
              ((I = t.choose.chooseMonth) == null ? void 0 : I.index) === t.preview.previewMonth.index
            )
          }),
          d = l.computed(() => {
            var I = ra.findIndex((B) => B.index === t.componentProps.firstDayOfWeek)
            return I === -1 || I === 0 ? ra : ra.slice(I).concat(ra.slice(0, I))
          }),
          T = (I) => {
            var B, K
            return (B = (K = Xt.value.datePickerWeekDict) == null ? void 0 : K[I].abbr) != null ? B : ''
          },
          y = (I) => (I > 0 ? I : ''),
          b = () => {
            var {
                preview: { previewMonth: I, previewYear: B },
              } = t,
              K = Fe(B + '-' + I.index).daysInMonth(),
              Y = Fe(B + '-' + I.index + '-01').day(),
              C = d.value.findIndex((H) => H.index === '' + Y)
            a.value = [...Array(C).fill(-1), ...Array.from(Array(K + 1).keys())].filter((H) => H)
          },
          m = () => {
            var {
              preview: { previewYear: I, previewMonth: B },
              componentProps: { max: K, min: Y },
            } = t
            if (K) {
              var C = I + '-' + (Ee(B.index) + 1)
              p.right = !Fe(C).isSameOrBefore(Fe(K), 'month')
            }
            if (Y) {
              var H = I + '-' + (Ee(B.index) - 1)
              p.left = !Fe(H).isSameOrAfter(Fe(Y), 'month')
            }
          },
          S = (I) => {
            var {
                preview: { previewYear: B, previewMonth: K },
                componentProps: { min: Y, max: C },
              } = t,
              H = !0,
              w = !0,
              J = B + '-' + K.index + '-' + I
            return C && (H = Fe(J).isSameOrBefore(Fe(C), 'day')), Y && (w = Fe(J).isSameOrAfter(Fe(Y), 'day')), H && w
          },
          E = (I) => {
            var {
              choose: { chooseDays: B, chooseRangeDay: K },
              componentProps: { range: Y },
            } = t
            if (Y) {
              if (!K.length) return !1
              var C = Fe(I).isSameOrBefore(Fe(K[1]), 'day'),
                H = Fe(I).isSameOrAfter(Fe(K[0]), 'day')
              return C && H
            }
            return B.includes(I)
          },
          P = (I) => {
            if (I < 0) return { text: !0, outline: !1, textColor: '', class: es('button') }
            var {
                choose: { chooseDay: B },
                preview: { previewYear: K, previewMonth: Y },
                componentProps: { allowedDates: C, color: H, multiple: w, range: J },
              } = t,
              X = K + '-' + Y.index + '-' + I,
              G = () => (J || w ? E(X) : Ee(B) === I && f.value),
              Te = () => (S(I) ? (C ? !C(X) : !1) : !0),
              ce = Te(),
              se = () => (ce ? !0 : J || w ? !E(X) : !f.value || Ee(B) !== I),
              U = () =>
                h.value && Ee(s) === I && t.componentProps.showCurrent
                  ? (J || w || f.value) && ce
                    ? !0
                    : J || w
                    ? !E(X)
                    : f.value
                    ? B !== s
                    : !0
                  : !1,
              W = () => (ce ? '' : U() ? (H != null ? H : '') : G() ? '' : Wl() + '-color-cover'),
              ge = W().startsWith(Wl())
            return {
              text: se(),
              outline: U(),
              textColor: ge ? '' : W(),
              [Wl() + '-color-cover']: ge,
              class: OQ(es('button'), es('button--usable'), [ce, es('button--disabled')]),
            }
          },
          x = (I) => {
            ;(o.value = I === 'prev'), (u.value += I === 'prev' ? -1 : 1), r('check-preview', 'month', I)
          },
          D = (I, B) => {
            var K = B.currentTarget
            K.classList.contains(es('button--disabled')) || r('choose-day', I)
          },
          N = (I) => {
            c.value.checkDate(I)
          }
        return (
          l.onMounted(() => {
            b(), m()
          }),
          l.watch(
            () => t.preview,
            () => {
              b(), m()
            }
          ),
          {
            n: es,
            nDate: Wl,
            days: a,
            reverse: o,
            headerEl: c,
            panelKey: u,
            sortWeekList: d,
            panelBtnDisabled: p,
            forwardRef: N,
            filterDay: y,
            getDayAbbr: T,
            checkDate: x,
            chooseDay: D,
            buttonProps: P,
          }
        )
      },
    }),
    { n: LQ, classes: MQ } = Me('date-picker')
  function FQ(t, e) {
    var r = l.resolveComponent('year-picker-panel'),
      i = l.resolveComponent('month-picker-panel'),
      n = l.resolveComponent('day-picker-panel')
    return (
      l.openBlock(),
      l.createElementBlock(
        'div',
        { class: l.normalizeClass(t.classes(t.n(), [t.shadow, 'var-elevation--2'])) },
        [
          l.createElementVNode(
            'div',
            {
              class: l.normalizeClass(t.n('title')),
              style: l.normalizeStyle({ background: t.headerColor || t.color }),
            },
            [
              l.createElementVNode(
                'div',
                {
                  class: l.normalizeClass(t.classes(t.n('title-year'), [t.isYearPanel, t.n('title-year--active')])),
                  onClick: e[0] || (e[0] = (s) => t.clickEl('year')),
                },
                [
                  l.renderSlot(t.$slots, 'year', { year: t.previewYear }, () => [
                    l.createTextVNode(l.toDisplayString(t.previewYear), 1),
                  ]),
                ],
                2
              ),
              l.createElementVNode(
                'div',
                {
                  class: l.normalizeClass(
                    t.classes(
                      t.n('title-date'),
                      [!t.isYearPanel, t.n('title-date--active')],
                      [t.range, t.n('title-date--range')]
                    )
                  ),
                  onClick: e[1] || (e[1] = (s) => t.clickEl('date')),
                },
                [
                  l.createVNode(
                    l.Transition,
                    { name: t.multiple ? '' : '' + t.n() + (t.reverse ? '-reverse' : '') + '-translatey' },
                    {
                      default: l.withCtx(() => {
                        var s, a, o
                        return [
                          t.type === 'month'
                            ? (l.openBlock(),
                              l.createElementBlock(
                                'div',
                                { key: '' + t.chooseYear + ((s = t.chooseMonth) == null ? void 0 : s.index) },
                                [
                                  t.range
                                    ? l.renderSlot(
                                        t.$slots,
                                        'range',
                                        { key: 0, choose: t.getChoose.chooseRangeMonth },
                                        () => [l.createTextVNode(l.toDisplayString(t.getMonthTitle), 1)]
                                      )
                                    : t.multiple
                                    ? l.renderSlot(
                                        t.$slots,
                                        'multiple',
                                        { key: 1, choose: t.getChoose.chooseMonths },
                                        () => [l.createTextVNode(l.toDisplayString(t.getMonthTitle), 1)]
                                      )
                                    : l.renderSlot(
                                        t.$slots,
                                        'month',
                                        {
                                          key: 2,
                                          month: (a = t.chooseMonth) == null ? void 0 : a.index,
                                          year: t.chooseYear,
                                        },
                                        () => [l.createTextVNode(l.toDisplayString(t.getMonthTitle), 1)]
                                      ),
                                ]
                              ))
                            : (l.openBlock(),
                              l.createElementBlock(
                                'div',
                                {
                                  key:
                                    '' + t.chooseYear + ((o = t.chooseMonth) == null ? void 0 : o.index) + t.chooseDay,
                                },
                                [
                                  t.range
                                    ? l.renderSlot(t.$slots, 'range', { key: 0, choose: t.formatRange }, () => [
                                        l.createTextVNode(l.toDisplayString(t.getDateTitle), 1),
                                      ])
                                    : t.multiple
                                    ? l.renderSlot(
                                        t.$slots,
                                        'multiple',
                                        { key: 1, choose: t.getChoose.chooseDays },
                                        () => [l.createTextVNode(l.toDisplayString(t.getDateTitle), 1)]
                                      )
                                    : l.renderSlot(
                                        t.$slots,
                                        'date',
                                        l.normalizeProps(l.mergeProps({ key: 2 }, t.slotProps)),
                                        () => [l.createTextVNode(l.toDisplayString(t.getDateTitle), 1)]
                                      ),
                                ]
                              )),
                        ]
                      }),
                      _: 3,
                    },
                    8,
                    ['name']
                  ),
                ],
                2
              ),
            ],
            6
          ),
          l.createElementVNode(
            'div',
            {
              class: l.normalizeClass(t.n('body')),
              onTouchstart:
                e[2] ||
                (e[2] = function () {
                  return t.handleTouchstart && t.handleTouchstart(...arguments)
                }),
              onTouchmove:
                e[3] ||
                (e[3] = function () {
                  return t.handleTouchmove && t.handleTouchmove(...arguments)
                }),
              onTouchend:
                e[4] ||
                (e[4] = function () {
                  return t.handleTouchend && t.handleTouchend(...arguments)
                }),
            },
            [
              l.createVNode(
                l.Transition,
                { name: t.n() + '-panel-fade' },
                {
                  default: l.withCtx(() => [
                    t.getPanelType === 'year'
                      ? (l.openBlock(),
                        l.createBlock(
                          r,
                          {
                            key: 0,
                            'component-props': t.componentProps,
                            preview: t.previewYear,
                            onChooseYear: t.getChooseYear,
                          },
                          null,
                          8,
                          ['component-props', 'preview', 'onChooseYear']
                        ))
                      : t.getPanelType === 'month'
                      ? (l.openBlock(),
                        l.createBlock(
                          i,
                          {
                            key: 1,
                            ref: 'monthPanelEl',
                            current: t.currentDate,
                            choose: t.getChoose,
                            preview: t.getPreview,
                            'click-year': () => t.clickEl('year'),
                            'component-props': t.componentProps,
                            onChooseMonth: t.getChooseMonth,
                            onCheckPreview: t.checkPreview,
                          },
                          null,
                          8,
                          [
                            'current',
                            'choose',
                            'preview',
                            'click-year',
                            'component-props',
                            'onChooseMonth',
                            'onCheckPreview',
                          ]
                        ))
                      : t.getPanelType === 'date'
                      ? (l.openBlock(),
                        l.createBlock(
                          n,
                          {
                            key: 2,
                            ref: 'dayPanelEl',
                            current: t.currentDate,
                            choose: t.getChoose,
                            preview: t.getPreview,
                            'component-props': t.componentProps,
                            'click-month': () => t.clickEl('month'),
                            onChooseDay: t.getChooseDay,
                            onCheckPreview: t.checkPreview,
                          },
                          null,
                          8,
                          [
                            'current',
                            'choose',
                            'preview',
                            'component-props',
                            'click-month',
                            'onChooseDay',
                            'onCheckPreview',
                          ]
                        ))
                      : l.createCommentVNode('v-if', !0),
                  ]),
                  _: 1,
                },
                8,
                ['name']
              ),
            ],
            34
          ),
        ],
        2
      )
    )
  }
  var th = l.defineComponent({
    render: FQ,
    name: 'VarDatePicker',
    components: { MonthPickerPanel: CQ, YearPickerPanel: NQ, DayPickerPanel: BQ },
    props: vQ,
    setup(t) {
      var e = 0,
        r = 0,
        i = '',
        n,
        s = Fe().format('YYYY-MM-D'),
        [a, o] = s.split('-'),
        u = Ul.find((L) => L.index === o),
        c = l.ref(!1),
        p = l.ref(!1),
        h = l.ref(!0),
        f = l.ref(),
        d = l.ref(),
        T = l.ref(),
        y = l.ref(u),
        b = l.ref(a),
        m = l.ref(!1),
        S = l.ref([]),
        E = l.ref([]),
        P = l.ref([]),
        x = l.ref([]),
        D = l.ref(null),
        N = l.ref(null),
        I = l.reactive({
          allowedDates: t.allowedDates,
          type: t.type,
          color: t.color,
          firstDayOfWeek: t.firstDayOfWeek,
          min: t.min,
          max: t.max,
          showCurrent: t.showCurrent,
          multiple: t.multiple,
          range: t.range,
        }),
        B = l.computed(() => ({
          chooseMonth: f.value,
          chooseYear: d.value,
          chooseDay: T.value,
          chooseMonths: S.value,
          chooseDays: E.value,
          chooseRangeMonth: P.value,
          chooseRangeDay: x.value,
        })),
        K = l.computed(() => ({ previewMonth: y.value, previewYear: b.value })),
        Y = l.computed(() => {
          var { multiple: L, range: F } = t
          if (F) return P.value.length ? P.value[0] + ' ~ ' + P.value[1] : ''
          var q = ''
          if (f.value) {
            var le, fe
            q = (le = (fe = Xt.value.datePickerMonthDict) == null ? void 0 : fe[f.value.index].name) != null ? le : ''
          }
          return L ? '' + S.value.length + Xt.value.datePickerSelected : q
        }),
        C = l.computed(() => {
          var L,
            F,
            q,
            le,
            { multiple: fe, range: ne } = t
          if (ne) {
            var Se = x.value.map((v) => Fe(v).format('YYYY-MM-DD'))
            return Se.length ? Se[0] + ' ~ ' + Se[1] : ''
          }
          if (fe) return '' + E.value.length + Xt.value.datePickerSelected
          if (!d.value || !f.value || !T.value) return ''
          var xe = Fe(d.value + '-' + f.value.index + '-' + T.value).day(),
            Ae = ra.find((v) => v.index === '' + xe),
            Re = (L = (F = Xt.value.datePickerWeekDict) == null ? void 0 : F[Ae.index].name) != null ? L : '',
            O = (q = (le = Xt.value.datePickerMonthDict) == null ? void 0 : le[f.value.index].name) != null ? q : '',
            g = T.value.padStart(2, '0')
          return Xt.value.lang === 'zh-CN'
            ? f.value.index + '-' + g + ' ' + Re.slice(0, 3)
            : Re.slice(0, 3) + ', ' + O.slice(0, 3) + ' ' + T.value
        }),
        H = l.computed(() =>
          c.value ? 'year' : t.type === 'month' || p.value ? 'month' : t.type === 'date' ? 'date' : ''
        ),
        w = l.computed(() => !t.touchable || ['', 'year'].includes(H.value)),
        J = l.computed(() => {
          var L,
            F,
            q,
            le,
            fe,
            ne = Fe(d.value + '-' + ((L = f.value) == null ? void 0 : L.index) + '-' + T.value).day(),
            Se = T.value ? ((F = T.value) == null ? void 0 : F.padStart(2, '0')) : ''
          return {
            week: '' + ne,
            year: (q = d.value) != null ? q : '',
            month: (le = (fe = f.value) == null ? void 0 : fe.index) != null ? le : '',
            date: Se,
          }
        }),
        X = l.computed(() => B.value.chooseRangeDay.map((L) => Fe(L).format('YYYY-MM-DD'))),
        G = l.computed(() => d.value === b.value),
        Te = l.computed(() => {
          var L
          return ((L = f.value) == null ? void 0 : L.index) === y.value.index
        }),
        ce = (L) => {
          L === 'year' ? (c.value = !0) : L === 'month' ? (p.value = !0) : ((c.value = !1), (p.value = !1))
        },
        se = (L) => {
          if (!w.value) {
            var { clientX: F, clientY: q } = L.touches[0]
            ;(e = F), (r = q)
          }
        },
        U = (L, F) => (L >= F && L > 20 ? 'x' : 'y'),
        W = (L) => {
          if (!w.value) {
            var { clientX: F, clientY: q } = L.touches[0],
              le = F - e,
              fe = q - r
            ;(n = U(Math.abs(le), Math.abs(fe))), (i = le > 0 ? 'prev' : 'next')
          }
        },
        ge = () => {
          if (!(w.value || n !== 'x')) {
            var L = H.value === 'month' ? D : N
            bf(() => {
              L.value.forwardRef(i), ie()
            })
          }
        },
        ye = (L, F) => {
          var q = F === 'month' ? P : x
          if (((q.value = h.value ? [L, L] : [q.value[0], L]), (h.value = !h.value), h.value)) {
            var le = Fe(q.value[0]).isAfter(q.value[1]),
              fe = le ? [q.value[1], q.value[0]] : [...q.value]
            he(t['onUpdate:modelValue'], fe), he(t.onChange, fe)
          }
        },
        me = (L, F) => {
          var q = F === 'month' ? S : E,
            le = F === 'month' ? 'YYYY-MM' : 'YYYY-MM-DD',
            fe = q.value.map((Se) => Fe(Se).format(le)),
            ne = fe.findIndex((Se) => Se === L)
          ne === -1 ? fe.push(L) : fe.splice(ne, 1), he(t['onUpdate:modelValue'], fe), he(t.onChange, fe)
        },
        ke = (L, F) =>
          !d.value || !f.value
            ? !1
            : G.value
            ? L === 'month'
              ? F.index < f.value.index
              : Te.value
              ? F < Ee(T.value)
              : f.value.index > y.value.index
            : d.value > b.value,
        ae = (L) => {
          var { readonly: F, range: q, multiple: le, onChange: fe, 'onUpdate:modelValue': ne } = t
          if (!(L < 0 || F)) {
            m.value = ke('day', L)
            var Se = b.value + '-' + y.value.index + '-' + L,
              xe = Fe(Se).format('YYYY-MM-DD')
            q ? ye(xe, 'day') : le ? me(xe, 'day') : (he(ne, xe), he(fe, xe))
          }
        },
        de = (L) => {
          var { type: F, readonly: q, range: le, multiple: fe, onChange: ne, 'onUpdate:modelValue': Se } = t
          if (((m.value = ke('month', L)), F === 'month' && !q)) {
            var xe = b.value + '-' + L.index
            le ? ye(xe, 'month') : fe ? me(xe, 'month') : (he(Se, xe), he(ne, xe))
          } else y.value = L
          p.value = !1
        },
        be = (L) => {
          ;(b.value = '' + L), (c.value = !1), (p.value = !0)
        },
        Pe = (L, F) => {
          var q = F === 'prev' ? -1 : 1
          if (L === 'year') b.value = '' + (Ee(b.value) + q)
          else {
            var le = Ee(y.value.index) + q
            le < 1 && ((b.value = '' + (Ee(b.value) - 1)), (le = 12)),
              le > 12 && ((b.value = '' + (Ee(b.value) + 1)), (le = 1)),
              (y.value = Ul.find((fe) => Ee(fe.index) === le))
          }
        },
        De = () =>
          (t.multiple || t.range) && !At(t.modelValue)
            ? (console.error('[Varlet] DatePicker: type of prop "modelValue" should be an Array'), !1)
            : !t.multiple && !t.range && At(t.modelValue)
            ? (console.error('[Varlet] DatePicker: type of prop "modelValue" should be a String'), !1)
            : !0,
        Le = (L) =>
          At(L)
            ? !1
            : L === 'Invalid Date'
            ? (console.error('[Varlet] DatePicker: "modelValue" is an Invalid Date'), !0)
            : !1,
        We = (L, F) => {
          var q = F === 'month' ? P : x,
            le = F === 'month' ? 'YYYY-MM' : 'YYYY-MM-D',
            fe = L.map((xe) => Fe(xe).format(le)).slice(0, 2),
            ne = q.value.some((xe) => Le(xe))
          if (!ne) {
            q.value = fe
            var Se = Fe(q.value[0]).isAfter(q.value[1])
            q.value.length === 2 && Se && (q.value = [q.value[1], q.value[0]])
          }
        },
        A = (L, F) => {
          var q = F === 'month' ? S : E,
            le = F === 'month' ? 'YYYY-MM' : 'YYYY-MM-D',
            fe = Array.from(new Set(L.map((ne) => Fe(ne).format(le))))
          q.value = fe.filter((ne) => ne !== 'Invalid Date')
        },
        pe = (L) => {
          var F = Fe(L).format('YYYY-MM-D')
          if (!Le(F)) {
            var [q, le, fe] = F.split('-'),
              ne = Ul.find((Se) => Se.index === le)
            ;(f.value = ne), (d.value = q), (T.value = fe), (y.value = ne), (b.value = q)
          }
        },
        ie = () => {
          ;(r = 0), (e = 0), (i = ''), (n = void 0)
        }
      return (
        l.watch(
          () => t.modelValue,
          (L) => {
            if (!(!De() || Le(L) || !L))
              if (t.range) {
                if (!At(L)) return
                ;(h.value = L.length !== 1), We(L, t.type)
              } else if (t.multiple) {
                if (!At(L)) return
                A(L, t.type)
              } else pe(L)
          },
          { immediate: !0 }
        ),
        l.watch(H, ie),
        {
          n: LQ,
          classes: MQ,
          monthPanelEl: D,
          dayPanelEl: N,
          reverse: m,
          currentDate: s,
          chooseMonth: f,
          chooseYear: d,
          chooseDay: T,
          previewYear: b,
          isYearPanel: c,
          isMonthPanel: p,
          getMonthTitle: Y,
          getDateTitle: C,
          getPanelType: H,
          getChoose: B,
          getPreview: K,
          componentProps: I,
          slotProps: J,
          formatRange: X,
          clickEl: ce,
          handleTouchstart: se,
          handleTouchmove: W,
          handleTouchend: ge,
          getChooseDay: ae,
          getChooseMonth: de,
          getChooseYear: be,
          checkPreview: Pe,
        }
      )
    },
  })
  th.install = function (t) {
    t.component(th.name, th)
  }
  function rh() {
    return (
      (rh =
        Object.assign ||
        function (t) {
          for (var e = 1; e < arguments.length; e++) {
            var r = arguments[e]
            for (var i in r) Object.prototype.hasOwnProperty.call(r, i) && (t[i] = r[i])
          }
          return t
        }),
      rh.apply(this, arguments)
    )
  }
  function $Q(t) {
    return ['left', 'center', 'right'].includes(t)
  }
  var RQ = rh(
      {
        show: { type: Boolean, default: !1 },
        title: { type: String },
        message: { type: String },
        messageAlign: { type: String, default: 'left', validator: $Q },
        confirmButton: { type: Boolean, default: !0 },
        cancelButton: { type: Boolean, default: !0 },
        confirmButtonText: { type: String },
        cancelButtonText: { type: String },
        confirmButtonTextColor: { type: String },
        cancelButtonTextColor: { type: String },
        confirmButtonColor: { type: String },
        cancelButtonColor: { type: String },
        onBeforeClose: { type: Function },
        onConfirm: { type: Function },
        onCancel: { type: Function },
        'onUpdate:show': { type: Function },
        dialogClass: { type: String },
        dialogStyle: { type: Object },
      },
      xr(Zs, [
        'overlay',
        'overlayClass',
        'overlayStyle',
        'lockScroll',
        'closeOnClickOverlay',
        'teleport',
        'onOpen',
        'onClose',
        'onOpened',
        'onClosed',
        'onClickOverlay',
        'onRouteChange',
      ])
    ),
    { n: jQ, classes: _Q } = Me('dialog')
  function VQ(t, e) {
    var r = l.resolveComponent('var-button'),
      i = l.resolveComponent('var-popup')
    return (
      l.openBlock(),
      l.createBlock(
        i,
        {
          class: l.normalizeClass(t.n('popup')),
          'var-dialog-cover': '',
          show: t.popupShow,
          overlay: t.overlay,
          'overlay-class': t.overlayClass,
          'overlay-style': t.overlayStyle,
          'lock-scroll': t.lockScroll,
          'close-on-click-overlay': t.popupCloseOnClickOverlay,
          teleport: t.teleport,
          onOpen: t.onOpen,
          onClose: t.onClose,
          onClosed: t.onClosed,
          onOpened: t.onOpened,
          onRouteChange: t.onRouteChange,
          onClickOverlay: t.handleClickOverlay,
        },
        {
          default: l.withCtx(() => [
            l.createElementVNode(
              'div',
              l.mergeProps({ class: t.classes('var--box', t.n(), t.dialogClass), style: t.dialogStyle }, t.$attrs),
              [
                l.createElementVNode(
                  'div',
                  { class: l.normalizeClass(t.n('title')) },
                  [
                    l.renderSlot(t.$slots, 'title', {}, () => [
                      l.createTextVNode(l.toDisplayString(t.dt(t.title, t.pack.dialogTitle)), 1),
                    ]),
                  ],
                  2
                ),
                l.createElementVNode(
                  'div',
                  { class: l.normalizeClass(t.n('message')), style: l.normalizeStyle({ textAlign: t.messageAlign }) },
                  [l.renderSlot(t.$slots, 'default', {}, () => [l.createTextVNode(l.toDisplayString(t.message), 1)])],
                  6
                ),
                l.createElementVNode(
                  'div',
                  { class: l.normalizeClass(t.n('actions')) },
                  [
                    t.cancelButton
                      ? (l.openBlock(),
                        l.createBlock(
                          r,
                          {
                            key: 0,
                            class: l.normalizeClass(t.classes(t.n('button'), t.n('cancel-button'))),
                            'var-dialog-cover': '',
                            text: '',
                            'text-color': t.cancelButtonTextColor,
                            color: t.cancelButtonColor,
                            onClick: t.cancel,
                          },
                          {
                            default: l.withCtx(() => [
                              l.createTextVNode(
                                l.toDisplayString(t.dt(t.cancelButtonText, t.pack.dialogCancelButtonText)),
                                1
                              ),
                            ]),
                            _: 1,
                          },
                          8,
                          ['class', 'text-color', 'color', 'onClick']
                        ))
                      : l.createCommentVNode('v-if', !0),
                    t.confirmButton
                      ? (l.openBlock(),
                        l.createBlock(
                          r,
                          {
                            key: 1,
                            class: l.normalizeClass(t.classes(t.n('button'), t.n('confirm-button'))),
                            'var-dialog-cover': '',
                            text: '',
                            'text-color': t.confirmButtonTextColor,
                            color: t.confirmButtonColor,
                            onClick: t.confirm,
                          },
                          {
                            default: l.withCtx(() => [
                              l.createTextVNode(
                                l.toDisplayString(t.dt(t.confirmButtonText, t.pack.dialogConfirmButtonText)),
                                1
                              ),
                            ]),
                            _: 1,
                          },
                          8,
                          ['class', 'text-color', 'color', 'onClick']
                        ))
                      : l.createCommentVNode('v-if', !0),
                  ],
                  2
                ),
              ],
              16
            ),
          ]),
          _: 3,
        },
        8,
        [
          'class',
          'show',
          'overlay',
          'overlay-class',
          'overlay-style',
          'lock-scroll',
          'close-on-click-overlay',
          'teleport',
          'onOpen',
          'onClose',
          'onClosed',
          'onOpened',
          'onRouteChange',
          'onClickOverlay',
        ]
      )
    )
  }
  var ih = l.defineComponent({
    render: VQ,
    name: 'VarDialog',
    components: { VarPopup: Ni, VarButton: Er },
    inheritAttrs: !1,
    props: RQ,
    setup(t) {
      var e = l.ref(!1),
        r = l.ref(!1),
        i = () => he(t['onUpdate:show'], !1),
        n = () => {
          var { closeOnClickOverlay: o, onClickOverlay: u, onBeforeClose: c } = t
          if ((he(u), !!o)) {
            if (c != null) {
              c('close', i)
              return
            }
            he(t['onUpdate:show'], !1)
          }
        },
        s = () => {
          var { onBeforeClose: o, onConfirm: u } = t
          if ((he(u), o != null)) {
            o('confirm', i)
            return
          }
          he(t['onUpdate:show'], !1)
        },
        a = () => {
          var { onBeforeClose: o, onCancel: u } = t
          if ((he(u), o != null)) {
            o('cancel', i)
            return
          }
          he(t['onUpdate:show'], !1)
        }
      return (
        l.watch(
          () => t.show,
          (o) => {
            e.value = o
          },
          { immediate: !0 }
        ),
        l.watch(
          () => t.closeOnClickOverlay,
          (o) => {
            if (t.onBeforeClose != null) {
              r.value = !1
              return
            }
            r.value = o
          },
          { immediate: !0 }
        ),
        {
          n: jQ,
          classes: _Q,
          pack: Xt,
          dt: gl,
          popupShow: e,
          popupCloseOnClickOverlay: r,
          handleClickOverlay: n,
          confirm: s,
          cancel: a,
        }
      )
    },
  })
  ih.install = function (t) {
    t.component(ih.name, ih)
  }
  var UQ = {
    inset: { type: [Boolean, Number, String], default: !1 },
    vertical: { type: Boolean, default: !1 },
    description: { type: String },
    margin: { type: String },
    dashed: { type: Boolean, default: !1 },
  }
  function ts() {
    return (
      (ts =
        Object.assign ||
        function (t) {
          for (var e = 1; e < arguments.length; e++) {
            var r = arguments[e]
            for (var i in r) Object.prototype.hasOwnProperty.call(r, i) && (t[i] = r[i])
          }
          return t
        }),
      ts.apply(this, arguments)
    )
  }
  var { n: zQ, classes: KQ } = Me('divider')
  function WQ(t, e) {
    return (
      l.openBlock(),
      l.createElementBlock(
        'div',
        {
          class: l.normalizeClass(
            t.classes(
              t.n(),
              'var--box',
              [t.vertical, t.n('--vertical')],
              [t.withText, t.n('--with-text')],
              [t.isInset, t.n('--inset')],
              [t.dashed, t.n('--dashed')]
            )
          ),
          style: l.normalizeStyle(t.style),
        },
        [
          l.renderSlot(t.$slots, 'default', {}, () => [
            t.description
              ? (l.openBlock(),
                l.createElementBlock(
                  'span',
                  { key: 0, class: l.normalizeClass(t.n('text')) },
                  l.toDisplayString(t.description),
                  3
                ))
              : l.createCommentVNode('v-if', !0),
          ]),
        ],
        6
      )
    )
  }
  var nh = l.defineComponent({
    render: WQ,
    name: 'VarDivider',
    props: UQ,
    setup(t, e) {
      var { slots: r } = e,
        i = l.reactive({ withText: !1 }),
        n = l.computed(() => (df(t.inset) ? t.inset : !0)),
        s = l.computed(() => {
          var { inset: o, vertical: u, margin: c } = t,
            p = { margin: c }
          if (df(o) || o === 0) return ts({}, p)
          var h = Ee(o),
            f = Math.abs(h) + (o + '').replace(h + '', '')
          return u
            ? ts({}, p, { height: 'calc(80% - ' + xt(f) + ')' })
            : ts({}, p, { width: 'calc(100% - ' + xt(f) + ')', left: h > 0 ? xt(f) : xt(0) })
        }),
        a = () => {
          i.withText = Boolean(r.default) || Boolean(t.description)
        }
      return (
        l.onMounted(() => {
          a()
        }),
        l.onUpdated(() => {
          a()
        }),
        ts({ n: zQ, classes: KQ }, l.toRefs(i), { style: s, isInset: n })
      )
    },
  })
  nh.install = function (t) {
    t.component(nh.name, nh)
  }
  var YQ = { disabled: { type: Boolean, default: !1 }, readonly: { type: Boolean, default: !1 } }
  function Eb(t, e, r, i, n, s, a) {
    try {
      var o = t[s](a),
        u = o.value
    } catch (c) {
      r(c)
      return
    }
    o.done ? e(u) : Promise.resolve(u).then(i, n)
  }
  function HQ(t) {
    return function () {
      var e = this,
        r = arguments
      return new Promise(function (i, n) {
        var s = t.apply(e, r)
        function a(u) {
          Eb(s, i, n, a, o, 'next', u)
        }
        function o(u) {
          Eb(s, i, n, a, o, 'throw', u)
        }
        a(void 0)
      })
    }
  }
  var { n: qQ } = Me('form')
  function XQ(t, e) {
    return (
      l.openBlock(),
      l.createElementBlock('div', { class: l.normalizeClass(t.n()) }, [l.renderSlot(t.$slots, 'default')], 2)
    )
  }
  var sh = l.defineComponent({
    render: XQ,
    name: 'VarForm',
    props: YQ,
    setup(t) {
      var e = l.computed(() => t.disabled),
        r = l.computed(() => t.readonly),
        { formItems: i, bindFormItems: n } = NJ(),
        s = (function () {
          var c = HQ(function* () {
            var p = yield Promise.all(
              i.map((h) => {
                var { validate: f } = h
                return f()
              })
            )
            return p.every((h) => h === !0)
          })
          return function () {
            return c.apply(this, arguments)
          }
        })(),
        a = () =>
          i.forEach((c) => {
            var { reset: p } = c
            return p()
          }),
        o = () =>
          i.forEach((c) => {
            var { resetValidation: p } = c
            return p()
          }),
        u = { disabled: e, readonly: r }
      return n(u), { n: qQ, validate: s, reset: a, resetValidation: o }
    },
  })
  sh.install = function (t) {
    t.component(sh.name, sh)
  }
  function Pb(t, e, r, i, n, s, a) {
    try {
      var o = t[s](a),
        u = o.value
    } catch (c) {
      r(c)
      return
    }
    o.done ? e(u) : Promise.resolve(u).then(i, n)
  }
  function Yl(t) {
    return function () {
      var e = this,
        r = arguments
      return new Promise(function (i, n) {
        var s = t.apply(e, r)
        function a(u) {
          Pb(s, i, n, a, o, 'next', u)
        }
        function o(u) {
          Pb(s, i, n, a, o, 'throw', u)
        }
        a(void 0)
      })
    }
  }
  function ah() {
    return (
      (ah =
        Object.assign ||
        function (t) {
          for (var e = 1; e < arguments.length; e++) {
            var r = arguments[e]
            for (var i in r) Object.prototype.hasOwnProperty.call(r, i) && (t[i] = r[i])
          }
          return t
        }),
      ah.apply(this, arguments)
    )
  }
  var GQ = 'background-image',
    JQ = 'lazy-loading',
    ZQ = 'lazy-error',
    wb = 'lazy-attempt',
    QQ = ['scroll', 'wheel', 'mousewheel', 'resize', 'animationend', 'transitionend', 'touchmove'],
    oh = 'data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==',
    rs = [],
    Hl = [],
    Ab = _X(100),
    Lt = { loading: oh, error: oh, attempt: 3, throttleWait: 300, events: QQ },
    lh = mf(ia, Lt.throttleWait)
  function ql(t, e) {
    t._lazy.arg === GQ ? (t.style.backgroundImage = 'url(' + e + ')') : t.setAttribute('src', e)
  }
  function eee(t) {
    t._lazy.loading && ql(t, t._lazy.loading), ia()
  }
  function tee(t) {
    t._lazy.error && ql(t, t._lazy.error), (t._lazy.state = 'error'), fh(t), ia()
  }
  function Cb(t, e) {
    ql(t, e), (t._lazy.state = 'success'), fh(t), ia()
  }
  function ree(t) {
    var e
    Hl.includes(t) ||
      (Hl.push(t),
      (e = Lt.events) == null ||
        e.forEach((r) => {
          t.addEventListener(r, lh, { passive: !0 })
        }))
  }
  function iee() {
    Hl.forEach((t) => {
      var e
      ;(e = Lt.events) == null ||
        e.forEach((r) => {
          t.removeEventListener(r, lh)
        })
    }),
      (Hl.length = 0)
  }
  function nee(t, e) {
    var r,
      i,
      n = {
        loading: (r = t.getAttribute(JQ)) != null ? r : Lt.loading,
        error: (i = t.getAttribute(ZQ)) != null ? i : Lt.error,
        attempt: t.getAttribute(wb) ? Number(t.getAttribute(wb)) : Lt.attempt,
      }
    ;(t._lazy = ah({ src: e.value, arg: e.arg, currentAttempt: 0, state: 'pending', attemptLock: !1 }, n)),
      ql(t, oh),
      he(Lt.filter, t._lazy)
  }
  function see(t, e) {
    var r = new Image()
    ;(r.src = e),
      (t._lazy.preloadImage = r),
      r.addEventListener('load', () => {
        ;(t._lazy.attemptLock = !1), Ab.add(e), Cb(t, e)
      }),
      r.addEventListener('error', () => {
        ;(t._lazy.attemptLock = !1), t._lazy.currentAttempt >= t._lazy.attempt ? tee(t) : xb(t)
      })
  }
  function xb(t) {
    if (!t._lazy.attemptLock) {
      ;(t._lazy.attemptLock = !0), t._lazy.currentAttempt++
      var { src: e } = t._lazy
      if (Ab.has(e)) {
        Cb(t, e), (t._lazy.attemptLock = !1)
        return
      }
      eee(t), see(t, e)
    }
  }
  function uh(t) {
    return ch.apply(this, arguments)
  }
  function ch() {
    return (
      (ch = Yl(function* (t) {
        ;(yield WX(t)) && xb(t)
      })),
      ch.apply(this, arguments)
    )
  }
  function ia() {
    rs.forEach((t) => uh(t))
  }
  function aee(t) {
    return ph.apply(this, arguments)
  }
  function ph() {
    return (
      (ph = Yl(function* (t) {
        !rs.includes(t) && rs.push(t), YX(t).forEach(ree), yield uh(t)
      })),
      ph.apply(this, arguments)
    )
  }
  function fh(t) {
    yl(rs, t), rs.length === 0 && iee()
  }
  function oee(t, e) {
    var { src: r, arg: i } = t._lazy
    return r !== e.value || i !== e.arg
  }
  function Ib(t, e) {
    return hh.apply(this, arguments)
  }
  function hh() {
    return (
      (hh = Yl(function* (t, e) {
        nee(t, e), yield aee(t)
      })),
      hh.apply(this, arguments)
    )
  }
  function lee(t, e) {
    return dh.apply(this, arguments)
  }
  function dh() {
    return (
      (dh = Yl(function* (t, e) {
        if (!oee(t, e)) {
          rs.includes(t) && (yield uh(t))
          return
        }
        yield Ib(t, e)
      })),
      dh.apply(this, arguments)
    )
  }
  function uee(t) {
    t === void 0 && (t = {})
    var { events: e, loading: r, error: i, attempt: n, throttleWait: s, filter: a } = t
    ;(Lt.events = e != null ? e : Lt.events),
      (Lt.loading = r != null ? r : Lt.loading),
      (Lt.error = i != null ? i : Lt.error),
      (Lt.attempt = n != null ? n : Lt.attempt),
      (Lt.throttleWait = s != null ? s : Lt.throttleWait),
      (Lt.filter = a)
  }
  var cee = {
    mounted: Ib,
    unmounted: fh,
    updated: lee,
    install(t, e) {
      uee(e), (lh = mf(ia, Lt.throttleWait)), t.directive('lazy', this)
    },
  }
  function pee(t) {
    return ['fill', 'contain', 'cover', 'none', 'scale-down'].includes(t)
  }
  var fee = {
      src: { type: String },
      fit: { type: String, validator: pee, default: 'fill' },
      alt: { type: String },
      width: { type: [String, Number] },
      height: { type: [String, Number] },
      radius: { type: [String, Number], default: 0 },
      loading: { type: String },
      error: { type: String },
      lazy: { type: Boolean, default: !1 },
      ripple: { type: Boolean, default: !1 },
      block: { type: Boolean, default: !0 },
      onClick: { type: Function },
      onLoad: { type: Function },
      onError: { type: Function },
    },
    { n: hee, classes: dee } = Me('image'),
    mee = ['alt', 'lazy-error', 'lazy-loading'],
    yee = ['alt', 'src']
  function gee(t, e) {
    var r = l.resolveDirective('lazy'),
      i = l.resolveDirective('ripple')
    return l.withDirectives(
      (l.openBlock(),
      l.createElementBlock(
        'div',
        {
          class: l.normalizeClass(t.classes(t.n(), 'var--box', [!t.block, 'var--inline-block'])),
          style: l.normalizeStyle({
            width: t.toSizeUnit(t.width),
            height: t.toSizeUnit(t.height),
            'border-radius': t.toSizeUnit(t.radius),
          }),
        },
        [
          t.lazy
            ? l.withDirectives(
                (l.openBlock(),
                l.createElementBlock(
                  'img',
                  {
                    key: 0,
                    class: l.normalizeClass(t.n('image')),
                    alt: t.alt,
                    'lazy-error': t.error,
                    'lazy-loading': t.loading,
                    style: l.normalizeStyle({ objectFit: t.fit }),
                    onLoad:
                      e[0] ||
                      (e[0] = function () {
                        return t.handleLoad && t.handleLoad(...arguments)
                      }),
                    onError:
                      e[1] ||
                      (e[1] = function () {
                        return t.handleError && t.handleError(...arguments)
                      }),
                    onClick:
                      e[2] ||
                      (e[2] = function () {
                        return t.onClick && t.onClick(...arguments)
                      }),
                  },
                  null,
                  46,
                  mee
                )),
                [[r, t.src]]
              )
            : (l.openBlock(),
              l.createElementBlock(
                'img',
                {
                  key: 1,
                  class: l.normalizeClass(t.n('image')),
                  alt: t.alt,
                  style: l.normalizeStyle({ objectFit: t.fit }),
                  src: t.src,
                  onLoad:
                    e[3] ||
                    (e[3] = function () {
                      return t.handleLoad && t.handleLoad(...arguments)
                    }),
                  onError:
                    e[4] ||
                    (e[4] = function () {
                      return t.handleError && t.handleError(...arguments)
                    }),
                  onClick:
                    e[5] ||
                    (e[5] = function () {
                      return t.onClick && t.onClick(...arguments)
                    }),
                },
                null,
                46,
                yee
              )),
        ],
        6
      )),
      [[i, { disabled: !t.ripple }]]
    )
  }
  var mh = l.defineComponent({
    render: gee,
    name: 'VarImage',
    directives: { Lazy: cee, Ripple: tr },
    props: fee,
    setup(t) {
      var e = (i) => {
          var n = i.currentTarget,
            { lazy: s, onLoad: a, onError: o } = t
          s ? (n._lazy.state === 'success' && he(a, i), n._lazy.state === 'error' && he(o, i)) : he(a, i)
        },
        r = (i) => {
          var { lazy: n, onError: s } = t
          !n && he(s, i)
        }
      return { n: hee, classes: dee, toSizeUnit: xt, handleLoad: e, handleError: r }
    },
  })
  mh.install = function (t) {
    t.component(mh.name, mh)
  }
  var kb = Symbol('SWIPE_BIND_SWIPE_ITEM_KEY'),
    Nb = Symbol('SWIPE_COUNT_SWIPE_ITEM_KEY')
  function Tee() {
    var { childProviders: t, bindChildren: e } = Sr(kb),
      { length: r } = Ir(Nb)
    return { length: r, swipeItems: t, bindSwipeItems: e }
  }
  var Ob = {
    loop: { type: Boolean, default: !0 },
    autoplay: { type: [String, Number] },
    duration: { type: [String, Number], default: 300 },
    initialIndex: { type: [String, Number], default: 0 },
    indicator: { type: Boolean, default: !0 },
    indicatorColor: { type: String },
    vertical: { type: Boolean, default: !1 },
    touchable: { type: Boolean, default: !0 },
    onChange: { type: Function },
  }
  function Db(t, e, r, i, n, s, a) {
    try {
      var o = t[s](a),
        u = o.value
    } catch (c) {
      r(c)
      return
    }
    o.done ? e(u) : Promise.resolve(u).then(i, n)
  }
  function bee(t) {
    return function () {
      var e = this,
        r = arguments
      return new Promise(function (i, n) {
        var s = t.apply(e, r)
        function a(u) {
          Db(s, i, n, a, o, 'next', u)
        }
        function o(u) {
          Db(s, i, n, a, o, 'throw', u)
        }
        a(void 0)
      })
    }
  }
  var See = 250,
    vee = 20,
    { n: Eee, classes: Pee } = Me('swipe'),
    wee = ['onClick']
  function Aee(t, e) {
    return (
      l.openBlock(),
      l.createElementBlock(
        'div',
        { class: l.normalizeClass(t.n()), ref: 'swipeEl' },
        [
          l.createElementVNode(
            'div',
            {
              class: l.normalizeClass(t.classes(t.n('track'), [t.vertical, t.n('--vertical')])),
              style: l.normalizeStyle({
                width: t.vertical ? void 0 : t.trackSize + 'px',
                height: t.vertical ? t.trackSize + 'px' : void 0,
                transform: 'translate' + (t.vertical ? 'Y' : 'X') + '(' + t.translate + 'px)',
                transitionDuration: t.lockDuration ? '0ms' : t.toNumber(t.duration) + 'ms',
              }),
              onTouchstart:
                e[0] ||
                (e[0] = function () {
                  return t.handleTouchstart && t.handleTouchstart(...arguments)
                }),
              onTouchmove:
                e[1] ||
                (e[1] = function () {
                  return t.handleTouchmove && t.handleTouchmove(...arguments)
                }),
              onTouchend:
                e[2] ||
                (e[2] = function () {
                  return t.handleTouchend && t.handleTouchend(...arguments)
                }),
            },
            [l.renderSlot(t.$slots, 'default')],
            38
          ),
          l.renderSlot(t.$slots, 'indicator', { index: t.index, length: t.length }, () => [
            t.indicator && t.length
              ? (l.openBlock(),
                l.createElementBlock(
                  'div',
                  {
                    key: 0,
                    class: l.normalizeClass(t.classes(t.n('indicators'), [t.vertical, t.n('--indicators-vertical')])),
                  },
                  [
                    (l.openBlock(!0),
                    l.createElementBlock(
                      l.Fragment,
                      null,
                      l.renderList(
                        t.length,
                        (r, i) => (
                          l.openBlock(),
                          l.createElementBlock(
                            'div',
                            {
                              class: l.normalizeClass(
                                t.classes(
                                  t.n('indicator'),
                                  [t.index === i, t.n('--indicator-active')],
                                  [t.vertical, t.n('--indicator-vertical')]
                                )
                              ),
                              style: l.normalizeStyle({ background: t.indicatorColor }),
                              key: r,
                              onClick: (n) => t.to(i),
                            },
                            null,
                            14,
                            wee
                          )
                        )
                      ),
                      128
                    )),
                  ],
                  2
                ))
              : l.createCommentVNode('v-if', !0),
          ]),
        ],
        2
      )
    )
  }
  var na = l.defineComponent({
    render: Aee,
    name: 'VarSwipe',
    props: Ob,
    setup(t) {
      var e = l.ref(null),
        r = l.ref(0),
        i = l.computed(() => t.vertical),
        n = l.ref(0),
        s = l.ref(0),
        a = l.ref(!1),
        o = l.ref(0),
        { swipeItems: u, bindSwipeItems: c, length: p } = Tee(),
        h = !1,
        f = -1,
        d,
        T,
        y,
        b,
        m,
        S = (se) =>
          u.find((U) => {
            var { index: W } = U
            return W.value === se
          }),
        E = () => {
          !t.loop ||
            (s.value >= 0 && S(p.value - 1).setTranslate(-n.value),
            s.value <= -(n.value - r.value) && S(0).setTranslate(n.value),
            s.value > -(n.value - r.value) && s.value < 0 && (S(p.value - 1).setTranslate(0), S(0).setTranslate(0)))
        },
        P = (se) => {
          var U = br(se) ? se : Math.floor((s.value - r.value / 2) / -r.value),
            { loop: W } = t
          return U <= -1 ? (W ? -1 : 0) : U >= p.value ? (W ? p.value : p.value - 1) : U
        },
        x = (se) => {
          var { loop: U } = t
          return se === -1 ? (U ? p.value - 1 : 0) : se === p.value ? (U ? 0 : p.value - 1) : se
        },
        D = (se) => {
          var { loop: U } = t
          return se < 0 ? (U ? p.value - 1 : 0) : se > p.value - 1 ? (U ? 0 : p.value - 1) : se
        },
        N = (se) => {
          var U = s.value >= r.value,
            W = s.value <= -n.value,
            ge = 0,
            ye = -(n.value - r.value)
          ;(a.value = !0),
            (U || W) && ((a.value = !0), (s.value = W ? ge : ye), S(0).setTranslate(0), S(p.value - 1).setTranslate(0)),
            bf(() => {
              ;(a.value = !1), he(se)
            })
        },
        I = () => {
          o.value = D(Ee(t.initialIndex))
        },
        B = () => {
          var { autoplay: se } = t
          !se ||
            p.value <= 1 ||
            (K(),
            (f = window.setTimeout(() => {
              X(), B()
            }, Ee(se))))
        },
        K = () => {
          f && clearTimeout(f)
        },
        Y = (se, U) => {
          if (se > U && se > 10) return 'horizontal'
          if (U > se && U > 10) return 'vertical'
        },
        C = (se) => {
          if (!(p.value <= 1 || !t.touchable)) {
            var { clientX: U, clientY: W } = se.touches[0]
            ;(d = U),
              (T = W),
              (y = performance.now()),
              (h = !0),
              K(),
              N(() => {
                a.value = !0
              })
          }
        },
        H = (se) => {
          var { touchable: U, vertical: W } = t
          if (!(!h || !U)) {
            var { clientX: ge, clientY: ye } = se.touches[0],
              me = Math.abs(ge - d),
              ke = Math.abs(ye - T),
              ae = Y(me, ke),
              de = W ? 'vertical' : 'horizontal'
            if (ae === de) {
              se.preventDefault()
              var be = b !== void 0 ? ge - b : 0,
                Pe = m !== void 0 ? ye - m : 0
              ;(b = ge), (m = ye), (s.value += W ? Pe : be), E()
            }
          }
        },
        w = () => {
          if (!!h) {
            var { vertical: se, onChange: U } = t,
              W = se ? m < T : b < d,
              ge = Math.abs(se ? T - m : d - b),
              ye = performance.now() - y <= See && ge >= vee,
              me = ye ? P(W ? o.value + 1 : o.value - 1) : P()
            ;(h = !1), (a.value = !1), (b = void 0), (m = void 0), (s.value = me * -r.value)
            var ke = o.value
            ;(o.value = x(me)), B(), ke !== o.value && he(U, o.value)
          }
        },
        J = () => {
          ;(a.value = !0),
            (r.value = t.vertical ? e.value.offsetHeight : e.value.offsetWidth),
            (n.value = r.value * p.value),
            (s.value = o.value * -r.value),
            u.forEach((se) => {
              se.setTranslate(0)
            }),
            B(),
            setTimeout(() => {
              a.value = !1
            })
        },
        X = () => {
          if (!(p.value <= 1)) {
            var { loop: se, onChange: U } = t,
              W = o.value
            ;(o.value = D(W + 1)),
              he(U, o.value),
              N(() => {
                if (W === p.value - 1 && se) {
                  S(0).setTranslate(n.value), (s.value = p.value * -r.value)
                  return
                }
                W !== p.value - 1 && (s.value = o.value * -r.value)
              })
          }
        },
        G = () => {
          if (!(p.value <= 1)) {
            var { loop: se, onChange: U } = t,
              W = o.value
            ;(o.value = D(W - 1)),
              he(U, o.value),
              N(() => {
                if (W === 0 && se) {
                  S(p.value - 1).setTranslate(-n.value), (s.value = r.value)
                  return
                }
                W !== 0 && (s.value = o.value * -r.value)
              })
          }
        },
        Te = (se) => {
          if (!(p.value <= 1 || se === o.value)) {
            ;(se = se < 0 ? 0 : se), (se = se >= p.value ? p.value : se)
            var U = se > o.value ? X : G
            Array.from({ length: Math.abs(se - o.value) }).forEach(U)
          }
        },
        ce = { size: r, vertical: i }
      return (
        c(ce),
        l.watch(
          () => p.value,
          bee(function* () {
            yield dn(), I(), J()
          })
        ),
        l.onMounted(() => {
          window.addEventListener('resize', J)
        }),
        l.onUnmounted(() => {
          window.removeEventListener('resize', J), K()
        }),
        {
          n: Eee,
          classes: Pee,
          length: p,
          index: o,
          swipeEl: e,
          trackSize: n,
          translate: s,
          lockDuration: a,
          handleTouchstart: C,
          handleTouchmove: H,
          handleTouchend: w,
          next: X,
          prev: G,
          to: Te,
          resize: J,
          toNumber: Ee,
        }
      )
    },
  })
  na.install = function (t) {
    t.component(na.name, na)
  }
  function Cee() {
    var { bindParent: t, parentProvider: e } = vr(kb),
      { index: r } = kr(Nb)
    if (!t || !e || !r) throw Error('<var-swipe-item/> must in <var-swipe/>')
    return { index: r, swipe: e, bindSwipe: t }
  }
  var { n: xee } = Me('swipe-item')
  function Iee(t, e) {
    return (
      l.openBlock(),
      l.createElementBlock(
        'div',
        {
          class: l.normalizeClass(t.n()),
          style: l.normalizeStyle({
            width: t.vertical ? void 0 : t.size + 'px',
            height: t.vertical ? t.size + 'px' : void 0,
            transform: 'translate' + (t.vertical ? 'Y' : 'X') + '(' + t.translate + 'px)',
          }),
        },
        [l.renderSlot(t.$slots, 'default')],
        6
      )
    )
  }
  var sa = l.defineComponent({
    render: Iee,
    name: 'VarSwipeItem',
    setup() {
      var t = l.ref(0),
        { swipe: e, bindSwipe: r, index: i } = Cee(),
        { size: n, vertical: s } = e,
        a = (u) => {
          t.value = u
        },
        o = { index: i, setTranslate: a }
      return r(o), { n: xee, size: n, vertical: s, translate: t }
    },
  })
  sa.install = function (t) {
    t.component(sa.name, sa)
  }
  function yh() {
    return (
      (yh =
        Object.assign ||
        function (t) {
          for (var e = 1; e < arguments.length; e++) {
            var r = arguments[e]
            for (var i in r) Object.prototype.hasOwnProperty.call(r, i) && (t[i] = r[i])
          }
          return t
        }),
      yh.apply(this, arguments)
    )
  }
  var kee = yh(
      {
        show: { type: Boolean, default: !1 },
        images: { type: Array, default: () => [] },
        current: { type: String },
        zoom: { type: [String, Number], default: 2 },
        closeable: { type: Boolean, default: !1 },
        'onUpdate:show': { type: Function },
      },
      xr(Ob, ['loop', 'indicator', 'onChange']),
      xr(Zs, ['lockScroll', 'teleport', 'onOpen', 'onClose', 'onOpened', 'onClosed', 'onRouteChange'])
    ),
    { n: Nee, classes: Oee } = Me('image-preview'),
    Bb = 12,
    Lb = 200,
    Dee = 350,
    Mb = 200,
    Bee = ['src', 'alt']
  function Lee(t, e) {
    var r = l.resolveComponent('var-swipe-item'),
      i = l.resolveComponent('var-swipe'),
      n = l.resolveComponent('var-icon'),
      s = l.resolveComponent('var-popup')
    return (
      l.openBlock(),
      l.createBlock(
        s,
        {
          class: l.normalizeClass(t.n('popup')),
          'var-image-preview-cover': '',
          transition: 'var-fade',
          show: t.popupShow,
          overlay: !1,
          'close-on-click-overlay': !1,
          'lock-scroll': t.lockScroll,
          teleport: t.teleport,
          onOpen: t.onOpen,
          onClose: t.onClose,
          onClosed: t.onClosed,
          onOpened: t.onOpened,
          onRouteChange: t.onRouteChange,
        },
        {
          default: l.withCtx(() => [
            l.createVNode(
              i,
              l.mergeProps(
                {
                  class: t.n('swipe'),
                  'var-image-preview-cover': '',
                  touchable: t.canSwipe,
                  indicator: t.indicator && t.images.length > 1,
                  'initial-index': t.initialIndex,
                  loop: t.loop,
                  onChange: t.onChange,
                },
                t.$attrs
              ),
              {
                default: l.withCtx(() => [
                  (l.openBlock(!0),
                  l.createElementBlock(
                    l.Fragment,
                    null,
                    l.renderList(
                      t.images,
                      (a) => (
                        l.openBlock(),
                        l.createBlock(
                          r,
                          { class: l.normalizeClass(t.n('swipe-item')), 'var-image-preview-cover': '', key: a },
                          {
                            default: l.withCtx(() => [
                              l.createElementVNode(
                                'div',
                                {
                                  class: l.normalizeClass(t.n('zoom-container')),
                                  style: l.normalizeStyle({
                                    transform:
                                      'scale(' +
                                      t.scale +
                                      ') translate(' +
                                      t.translateX +
                                      'px, ' +
                                      t.translateY +
                                      'px)',
                                    transitionTimingFunction: t.transitionTimingFunction,
                                    transitionDuration: t.transitionDuration,
                                  }),
                                  onTouchstart:
                                    e[0] ||
                                    (e[0] = function () {
                                      return t.handleTouchstart && t.handleTouchstart(...arguments)
                                    }),
                                  onTouchmove:
                                    e[1] ||
                                    (e[1] = function () {
                                      return t.handleTouchmove && t.handleTouchmove(...arguments)
                                    }),
                                  onTouchend:
                                    e[2] ||
                                    (e[2] = function () {
                                      return t.handleTouchend && t.handleTouchend(...arguments)
                                    }),
                                },
                                [
                                  l.createElementVNode(
                                    'img',
                                    { class: l.normalizeClass(t.n('image')), src: a, alt: a },
                                    null,
                                    10,
                                    Bee
                                  ),
                                ],
                                38
                              ),
                            ]),
                            _: 2,
                          },
                          1032,
                          ['class']
                        )
                      )
                    ),
                    128
                  )),
                ]),
                indicator: l.withCtx((a) => {
                  var { index: o, length: u } = a
                  return [
                    l.renderSlot(t.$slots, 'indicator', { index: o, length: u }, () => [
                      t.indicator && t.images.length > 1
                        ? (l.openBlock(),
                          l.createElementBlock(
                            'div',
                            { key: 0, class: l.normalizeClass(t.n('indicators')) },
                            l.toDisplayString(o + 1) + ' / ' + l.toDisplayString(u),
                            3
                          ))
                        : l.createCommentVNode('v-if', !0),
                    ]),
                  ]
                }),
                _: 3,
              },
              16,
              ['class', 'touchable', 'indicator', 'initial-index', 'loop', 'onChange']
            ),
            l.renderSlot(t.$slots, 'close-icon', {}, () => [
              t.closeable
                ? (l.openBlock(),
                  l.createBlock(
                    n,
                    {
                      key: 0,
                      class: l.normalizeClass(t.n('close-icon')),
                      name: 'close-circle',
                      'var-image-preview-cover': '',
                      onClick: t.close,
                    },
                    null,
                    8,
                    ['class', 'onClick']
                  ))
                : l.createCommentVNode('v-if', !0),
            ]),
            l.createElementVNode(
              'div',
              { class: l.normalizeClass(t.n('extra')) },
              [l.renderSlot(t.$slots, 'extra')],
              2
            ),
          ]),
          _: 3,
        },
        8,
        ['class', 'show', 'lock-scroll', 'teleport', 'onOpen', 'onClose', 'onClosed', 'onOpened', 'onRouteChange']
      )
    )
  }
  var gn = l.defineComponent({
      render: Lee,
      name: 'VarImagePreview',
      components: { VarSwipe: na, VarSwipeItem: sa, VarPopup: Ni, VarIcon: kt },
      inheritAttrs: !1,
      props: kee,
      setup(t) {
        var e = l.ref(!1),
          r = l.computed(() => {
            var { images: K, current: Y } = t,
              C = K.findIndex((H) => H === Y)
            return C >= 0 ? C : 0
          }),
          i = l.ref(1),
          n = l.ref(0),
          s = l.ref(0),
          a = l.ref(void 0),
          o = l.ref(void 0),
          u = l.ref(!0),
          c = null,
          p = null,
          h = null,
          f = (K, Y) => {
            var { clientX: C, clientY: H } = K,
              { clientX: w, clientY: J } = Y
            return Math.abs(Math.sqrt(Math.pow(w - C, 2) + Math.pow(J - H, 2)))
          },
          d = (K, Y) => ({ clientX: K.clientX, clientY: K.clientY, timestamp: Date.now(), target: Y }),
          T = () => {
            ;(i.value = Ee(t.zoom)),
              (u.value = !1),
              (p = null),
              window.setTimeout(() => {
                ;(a.value = 'linear'), (o.value = '0s')
              }, Mb)
          },
          y = () => {
            ;(i.value = 1),
              (n.value = 0),
              (s.value = 0),
              (u.value = !0),
              (p = null),
              (a.value = void 0),
              (o.value = void 0)
          },
          b = (K) => (p ? f(p, K) <= Bb && K.timestamp - p.timestamp <= Lb && p.target === K.target : !1),
          m = (K) =>
            !K || !c || !p
              ? !1
              : f(c, p) <= Bb && Date.now() - p.timestamp < Dee && (K === c.target || K.parentNode === c.target),
          S = (K) => {
            h = window.setTimeout(() => {
              m(K.target) && B(), (c = null)
            }, Lb)
          },
          E = (K) => {
            h && window.clearTimeout(h)
            var { touches: Y } = K,
              C = d(Y[0], K.currentTarget)
            if (((c = C), b(C))) {
              i.value > 1 ? y() : T()
              return
            }
            p = C
          },
          P = (K) => {
            var { offsetWidth: Y, offsetHeight: C } = K,
              { naturalWidth: H, naturalHeight: w } = K.querySelector('.var-image-preview__image')
            return { width: Y, height: C, imageRadio: w / H, rootRadio: C / Y, zoom: Ee(t.zoom) }
          },
          x = (K) => {
            var { zoom: Y, imageRadio: C, rootRadio: H, width: w, height: J } = P(K)
            if (!C) return 0
            var X = C > H ? J / C : w
            return Math.max(0, (Y * X - w) / 2) / Y
          },
          D = (K) => {
            var { zoom: Y, imageRadio: C, rootRadio: H, width: w, height: J } = P(K)
            if (!C) return 0
            var X = C > H ? J : w * C
            return Math.max(0, (Y * X - J) / 2) / Y
          },
          N = (K, Y, C) => (K + Y >= C ? C : K + Y <= -C ? -C : K + Y),
          I = (K) => {
            if (!!p) {
              var Y = K.currentTarget,
                { touches: C } = K,
                H = d(C[0], Y)
              if (i.value > 1) {
                var w = H.clientX - p.clientX,
                  J = H.clientY - p.clientY,
                  X = x(Y),
                  G = D(Y)
                ;(n.value = N(n.value, w, X)), (s.value = N(s.value, J, G))
              }
              p = H
            }
          },
          B = () => {
            if (i.value > 1) {
              y(), setTimeout(() => he(t['onUpdate:show'], !1), Mb)
              return
            }
            he(t['onUpdate:show'], !1)
          }
        return (
          l.watch(
            () => t.show,
            (K) => {
              e.value = K
            },
            { immediate: !0 }
          ),
          {
            n: Nee,
            classes: Oee,
            initialIndex: r,
            popupShow: e,
            scale: i,
            translateX: n,
            translateY: s,
            canSwipe: u,
            transitionTimingFunction: a,
            transitionDuration: o,
            handleTouchstart: E,
            handleTouchmove: I,
            handleTouchend: S,
            close: B,
          }
        )
      },
    }),
    ji
  function aa(t) {
    if (!!UX()) {
      aa.close()
      var e = Tr(t) ? { images: [t] } : At(t) ? { images: t } : t,
        r = l.reactive(e)
      ;(r.teleport = 'body'), (ji = r)
      var { unmountInstance: i } = tG(gn, r, {
        onClose: () => (r.onClose == null ? void 0 : r.onClose()),
        onClosed: () => {
          r.onClosed == null || r.onClosed(), i(), ji === r && (ji = null)
        },
        onRouteChange: () => {
          i(), ji === r && (ji = null)
        },
        'onUpdate:show': (n) => {
          r.show = n
        },
      })
      r.show = !0
    }
  }
  ;(aa.close = () => {
    if (ji != null) {
      var t = ji
      ;(ji = null),
        l.nextTick().then(() => {
          t.show = !1
        })
    }
  }),
    (gn.install = function (t) {
      t.component(gn.name, gn)
    }),
    (aa.install = function (t) {
      t.component(gn.name, gn)
    }),
    (aa.Component = gn)
  var Fb = {
    offsetTop: { type: [String, Number], default: 0 },
    zIndex: { type: [String, Number], default: 10 },
    cssMode: { type: Boolean, default: !1 },
    disabled: { type: Boolean, default: !1 },
    onScroll: { type: Function },
  }
  function $b(t, e, r, i, n, s, a) {
    try {
      var o = t[s](a),
        u = o.value
    } catch (c) {
      r(c)
      return
    }
    o.done ? e(u) : Promise.resolve(u).then(i, n)
  }
  function Mee(t) {
    return function () {
      var e = this,
        r = arguments
      return new Promise(function (i, n) {
        var s = t.apply(e, r)
        function a(u) {
          $b(s, i, n, a, o, 'next', u)
        }
        function o(u) {
          $b(s, i, n, a, o, 'throw', u)
        }
        a(void 0)
      })
    }
  }
  var { n: Fee, classes: $ee } = Me('sticky')
  function Ree(t, e) {
    return (
      l.openBlock(),
      l.createElementBlock(
        'div',
        {
          class: l.normalizeClass(t.classes(t.n(), [t.enableCSSMode, t.n('--css-mode')])),
          ref: 'stickyEl',
          style: l.normalizeStyle({
            zIndex: t.toNumber(t.zIndex),
            top: t.enableCSSMode ? t.offsetTop + 'px' : void 0,
            width: t.enableFixedMode ? t.fixedWidth : void 0,
            height: t.enableFixedMode ? t.fixedHeight : void 0,
          }),
        },
        [
          l.createElementVNode(
            'div',
            {
              class: l.normalizeClass(t.n('wrapper')),
              ref: 'wrapperEl',
              style: l.normalizeStyle({
                zIndex: t.toNumber(t.zIndex),
                position: t.enableFixedMode ? 'fixed' : void 0,
                width: t.enableFixedMode ? t.fixedWrapperWidth : void 0,
                height: t.enableFixedMode ? t.fixedWrapperHeight : void 0,
                left: t.enableFixedMode ? t.fixedLeft : void 0,
                top: t.enableFixedMode ? t.fixedTop : void 0,
              }),
            },
            [l.renderSlot(t.$slots, 'default')],
            6
          ),
        ],
        6
      )
    )
  }
  var oa = l.defineComponent({
    render: Ree,
    name: 'VarSticky',
    props: Fb,
    setup(t) {
      var e = l.ref(null),
        r = l.ref(null),
        i = l.ref(!1),
        n = l.ref('0px'),
        s = l.ref('0px'),
        a = l.ref('auto'),
        o = l.ref('auto'),
        u = l.ref('auto'),
        c = l.ref('auto'),
        p = l.computed(() => !t.disabled && t.cssMode),
        h = l.computed(() => !t.disabled && i.value),
        f = l.computed(() => Mt(t.offsetTop)),
        d,
        T = () => {
          var { onScroll: m, cssMode: S, disabled: E } = t
          if (!E) {
            var P = 0
            if (d !== window) {
              var { top: x } = d.getBoundingClientRect()
              P = x
            }
            var D = r.value,
              N = e.value,
              { top: I, left: B } = N.getBoundingClientRect(),
              K = I - P
            K <= f.value
              ? (S ||
                  ((a.value = N.offsetWidth + 'px'),
                  (o.value = N.offsetHeight + 'px'),
                  (n.value = P + f.value + 'px'),
                  (s.value = B + 'px'),
                  (u.value = D.offsetWidth + 'px'),
                  (c.value = D.offsetHeight + 'px'),
                  (i.value = !0)),
                he(m, f.value, !0))
              : ((i.value = !1), he(m, K, !1))
          }
        },
        y = (function () {
          var m = Mee(function* () {
            yield dn(),
              (d = Wn(e.value)),
              d !== window && d.addEventListener('scroll', T),
              window.addEventListener('scroll', T),
              T()
          })
          return function () {
            return m.apply(this, arguments)
          }
        })(),
        b = () => {
          d !== window && d.removeEventListener('scroll', T), window.removeEventListener('scroll', T)
        }
      return (
        l.watch(() => t.disabled, T),
        l.onActivated(y),
        l.onDeactivated(b),
        l.onMounted(y),
        l.onUnmounted(b),
        {
          n: Fee,
          classes: $ee,
          stickyEl: e,
          wrapperEl: r,
          isFixed: i,
          offsetTop: f,
          fixedTop: n,
          fixedLeft: s,
          fixedWidth: a,
          fixedHeight: o,
          fixedWrapperWidth: u,
          fixedWrapperHeight: c,
          enableCSSMode: p,
          enableFixedMode: h,
          toNumber: Ee,
        }
      )
    },
  })
  oa.install = function (t) {
    t.component(oa.name, oa)
  }
  var Rb = Symbol('INDEX_BAR_BIND_INDEX_ANCHOR_KEY'),
    jb = Symbol('INDEX_BAR_COUNT_INDEX_ANCHOR_KEY')
  function jee() {
    var { bindChildren: t, childProviders: e } = Sr(Rb),
      { length: r } = Ir(jb)
    return { length: r, indexAnchors: e, bindIndexAnchors: t }
  }
  function _ee() {
    var { parentProvider: t, bindParent: e } = vr(Rb),
      { index: r } = kr(jb)
    if (!t || !e) throw Error('[Varlet] IndexAnchor: You should use this component in "IndexBar"')
    return { index: r, indexBar: t, bindIndexBar: e }
  }
  var Vee = { index: { type: [Number, String] } },
    { n: Uee, classes: zee } = Me('index-anchor')
  function Kee(t, e) {
    return (
      l.openBlock(),
      l.createBlock(
        l.resolveDynamicComponent(t.sticky ? 'var-sticky' : t.Transition),
        {
          'offset-top': t.sticky ? t.stickyOffsetTop : null,
          'z-index': t.sticky ? t.zIndex : null,
          disabled: t.disabled && !t.cssMode,
          'css-mode': t.cssMode,
          ref: 'anchorEl',
        },
        {
          default: l.withCtx(() => [
            l.createElementVNode(
              'div',
              l.mergeProps({ class: t.n() }, t.$attrs),
              [l.renderSlot(t.$slots, 'default', {}, () => [l.createTextVNode(l.toDisplayString(t.name), 1)])],
              16
            ),
          ]),
          _: 3,
        },
        8,
        ['offset-top', 'z-index', 'disabled', 'css-mode']
      )
    )
  }
  var gh = l.defineComponent({
    render: Kee,
    name: 'VarIndexAnchor',
    components: { VarSticky: oa },
    inheritAttrs: !1,
    props: Vee,
    setup(t) {
      var { index: e, indexBar: r, bindIndexBar: i } = _ee(),
        n = l.ref(0),
        s = l.ref(!1),
        a = l.computed(() => t.index),
        o = l.ref(null),
        { active: u, sticky: c, cssMode: p, stickyOffsetTop: h, zIndex: f } = r,
        d = () => {
          !o.value || (n.value = o.value.$el ? o.value.$el.offsetTop : o.value.offsetTop)
        },
        T = (b) => {
          s.value = b
        },
        y = { index: e, name: a, ownTop: n, setOwnTop: d, setDisabled: T }
      return (
        i(y),
        {
          n: Uee,
          classes: zee,
          name: a,
          anchorEl: o,
          active: u,
          sticky: c,
          zIndex: f,
          disabled: s,
          cssMode: p,
          stickyOffsetTop: h,
          Transition: l.Transition,
        }
      )
    },
  })
  gh.install = function (t) {
    t.component(gh.name, gh)
  }
  var Wee = {
    sticky: { type: Boolean, default: !0 },
    stickyOffsetTop: { type: [String, Number], default: 0 },
    cssMode: { type: Boolean, default: !1 },
    hideList: { type: Boolean, default: !1 },
    zIndex: { type: [Number, String], default: 1 },
    highlightColor: { type: String },
    duration: { type: [Number, String], default: 0 },
    onClick: { type: Function },
    onChange: { type: Function },
  }
  function _b(t, e, r, i, n, s, a) {
    try {
      var o = t[s](a),
        u = o.value
    } catch (c) {
      r(c)
      return
    }
    o.done ? e(u) : Promise.resolve(u).then(i, n)
  }
  function Th(t) {
    return function () {
      var e = this,
        r = arguments
      return new Promise(function (i, n) {
        var s = t.apply(e, r)
        function a(u) {
          _b(s, i, n, a, o, 'next', u)
        }
        function o(u) {
          _b(s, i, n, a, o, 'throw', u)
        }
        a(void 0)
      })
    }
  }
  var { n: Yee, classes: Hee } = Me('index-bar'),
    qee = ['onClick']
  function Xee(t, e) {
    return (
      l.openBlock(),
      l.createElementBlock(
        'div',
        { class: l.normalizeClass(t.n()), ref: 'barEl' },
        [
          l.renderSlot(t.$slots, 'default'),
          l.createElementVNode(
            'ul',
            {
              class: l.normalizeClass(t.n('anchor-list')),
              style: l.normalizeStyle({ zIndex: t.toNumber(t.zIndex) + 2, display: t.hideList ? 'none' : 'block' }),
            },
            [
              (l.openBlock(!0),
              l.createElementBlock(
                l.Fragment,
                null,
                l.renderList(
                  t.anchorNameList,
                  (r) => (
                    l.openBlock(),
                    l.createElementBlock(
                      'li',
                      {
                        key: r,
                        class: l.normalizeClass(
                          t.classes(t.n('anchor-item'), [t.active === r, t.n('anchor-item--active')])
                        ),
                        style: l.normalizeStyle({ color: t.active === r && t.highlightColor ? t.highlightColor : '' }),
                        onClick: (i) => t.anchorClick(r, !0),
                      },
                      l.toDisplayString(r),
                      15,
                      qee
                    )
                  )
                ),
                128
              )),
            ],
            6
          ),
        ],
        2
      )
    )
  }
  var bh = l.defineComponent({
    render: Xee,
    name: 'VarIndexBar',
    props: Wee,
    setup(t) {
      var { length: e, indexAnchors: r, bindIndexAnchors: i } = jee(),
        n = l.ref(''),
        s = l.ref(null),
        a = l.ref(null),
        o = l.ref([]),
        u = l.ref(),
        c = l.computed(() => t.sticky),
        p = l.computed(() => t.cssMode),
        h = l.computed(() => Mt(t.stickyOffsetTop)),
        f = l.computed(() => t.zIndex),
        d = { active: u, sticky: c, cssMode: p, stickyOffsetTop: h, zIndex: f }
      i(d)
      var T = (S) => {
          var E = hT(S) ? S.name.value : S
          E === u.value || E === void 0 || ((u.value = E), he(t.onChange, E))
        },
        y = () => {
          var S = Tl(s.value),
            E = s.value === window ? document.body.scrollHeight : s.value.scrollHeight,
            { offsetTop: P } = a.value
          r.forEach((x, D) => {
            var N = x.ownTop.value,
              I = S - N + h.value - P,
              B = D === r.length - 1 ? E : r[D + 1].ownTop.value - x.ownTop.value
            I >= 0 && I < B && !n.value && (D && !t.cssMode && r[D - 1].setDisabled(!0), x.setDisabled(!1), T(x))
          })
        },
        b = (function () {
          var S = Th(function* (E, P) {
            var { offsetTop: x } = a.value
            if ((P && he(t.onClick, E), E !== u.value)) {
              var D = r.find((B) => {
                var { name: K } = B
                return E === K.value
              })
              if (!!D) {
                var N = D.ownTop.value - h.value + x,
                  I = yf(s.value)
                ;(n.value = E),
                  T(E),
                  yield bl(s.value, { left: I, top: N, animation: yT, duration: Ee(t.duration) }),
                  bf(() => {
                    n.value = ''
                  })
              }
            }
          })
          return function (P, x) {
            return S.apply(this, arguments)
          }
        })(),
        m = (S) => {
          ui(() => b(S))
        }
      return (
        l.watch(
          () => e.value,
          Th(function* () {
            yield dn(),
              r.forEach((S) => {
                var { name: E, setOwnTop: P } = S
                E.value && o.value.push(E.value), P()
              })
          })
        ),
        l.onMounted(
          Th(function* () {
            yield dn(), (s.value = Wn(a.value)), s.value.addEventListener('scroll', y)
          })
        ),
        l.onBeforeUnmount(() => {
          he(s.value.removeEventListener, 'scroll', y)
        }),
        {
          n: Yee,
          classes: Hee,
          barEl: a,
          active: u,
          zIndex: f,
          anchorNameList: o,
          toNumber: Ee,
          scrollTo: m,
          anchorClick: b,
        }
      )
    },
  })
  bh.install = function (t) {
    t.component(bh.name, bh)
  }
  function Gee(t) {
    return ['text', 'password', 'number'].includes(t)
  }
  var Jee = {
      modelValue: { type: String },
      modelModifiers: { type: Object, default: () => ({}) },
      type: { type: String, default: 'text', validator: Gee },
      textarea: { type: Boolean, default: !1 },
      rows: { type: [String, Number], default: 8 },
      placeholder: { type: String },
      line: { type: Boolean, default: !0 },
      hint: { type: Boolean, default: !0 },
      textColor: { type: String },
      focusColor: { type: String },
      blurColor: { type: String },
      maxlength: { type: [String, Number] },
      disabled: { type: Boolean, default: !1 },
      readonly: { type: Boolean, default: !1 },
      clearable: { type: Boolean, default: !1 },
      resize: { type: Boolean, default: !1 },
      autofocus: { type: Boolean, default: !1 },
      validateTrigger: { type: Array, default: () => ['onInput', 'onClear'] },
      rules: { type: Array },
      onFocus: { type: Function },
      onBlur: { type: Function },
      onClick: { type: Function },
      onClear: { type: Function },
      onInput: { type: Function },
      onChange: { type: Function },
      'onUpdate:modelValue': { type: Function },
    },
    { n: Sh, classes: Zee } = Me('input'),
    Qee = ['id', 'disabled', 'type', 'value', 'maxlength', 'rows'],
    ete = ['id', 'disabled', 'type', 'value', 'maxlength'],
    tte = ['for']
  function rte(t, e) {
    var r = l.resolveComponent('var-icon'),
      i = l.resolveComponent('var-form-details')
    return (
      l.openBlock(),
      l.createElementBlock(
        'div',
        {
          class: l.normalizeClass(t.classes(t.n(), 'var--box', [t.disabled, t.n('--disabled')])),
          onClick:
            e[8] ||
            (e[8] = function () {
              return t.handleClick && t.handleClick(...arguments)
            }),
        },
        [
          l.createElementVNode(
            'div',
            {
              class: l.normalizeClass(
                t.classes(
                  t.n('controller'),
                  [t.isFocus, t.n('--focus')],
                  [t.errorMessage, t.n('--error')],
                  [t.formDisabled || t.disabled, t.n('--disabled')]
                )
              ),
              style: l.normalizeStyle({ color: t.errorMessage ? void 0 : t.isFocus ? t.focusColor : t.blurColor }),
            },
            [
              l.createElementVNode(
                'div',
                { class: l.normalizeClass(t.classes(t.n('icon'), [!t.hint, t.n('--non-hint')])) },
                [l.renderSlot(t.$slots, 'prepend-icon')],
                2
              ),
              l.createElementVNode(
                'div',
                { class: l.normalizeClass(t.classes(t.n('wrap'), [!t.hint, t.n('--non-hint')])) },
                [
                  t.type === 'password'
                    ? (l.openBlock(),
                      l.createElementBlock('input', { key: 0, class: l.normalizeClass(t.n('autocomplete')) }, null, 2))
                    : l.createCommentVNode('v-if', !0),
                  t.textarea
                    ? (l.openBlock(),
                      l.createElementBlock(
                        'textarea',
                        {
                          key: 1,
                          class: l.normalizeClass(
                            t.classes(
                              t.n('input'),
                              t.n('--textarea'),
                              [t.formDisabled || t.disabled, t.n('--disabled')],
                              [t.errorMessage, t.n('--caret-error')]
                            )
                          ),
                          ref: 'el',
                          autocomplete: 'new-password',
                          id: t.id,
                          disabled: t.formDisabled || t.disabled || t.formReadonly || t.readonly,
                          type: t.type,
                          value: t.modelValue,
                          maxlength: t.maxlength,
                          rows: t.rows,
                          style: l.normalizeStyle({
                            color: t.textColor,
                            caretColor: t.errorMessage ? void 0 : t.focusColor,
                            resize: t.resize ? 'vertical' : 'none',
                          }),
                          onFocus:
                            e[0] ||
                            (e[0] = function () {
                              return t.handleFocus && t.handleFocus(...arguments)
                            }),
                          onBlur:
                            e[1] ||
                            (e[1] = function () {
                              return t.handleBlur && t.handleBlur(...arguments)
                            }),
                          onInput:
                            e[2] ||
                            (e[2] = function () {
                              return t.handleInput && t.handleInput(...arguments)
                            }),
                          onChange:
                            e[3] ||
                            (e[3] = function () {
                              return t.handleChange && t.handleChange(...arguments)
                            }),
                        },
                        `
        `,
                        46,
                        Qee
                      ))
                    : (l.openBlock(),
                      l.createElementBlock(
                        'input',
                        {
                          key: 2,
                          class: l.normalizeClass(
                            t.classes(
                              t.n('input'),
                              [t.formDisabled || t.disabled, t.n('--disabled')],
                              [t.errorMessage, t.n('--caret-error')]
                            )
                          ),
                          ref: 'el',
                          autocomplete: 'new-password',
                          id: t.id,
                          disabled: t.formDisabled || t.disabled || t.formReadonly || t.readonly,
                          type: t.type,
                          value: t.modelValue,
                          maxlength: t.maxlength,
                          style: l.normalizeStyle({
                            color: t.textColor,
                            caretColor: t.errorMessage ? void 0 : t.focusColor,
                          }),
                          onFocus:
                            e[4] ||
                            (e[4] = function () {
                              return t.handleFocus && t.handleFocus(...arguments)
                            }),
                          onBlur:
                            e[5] ||
                            (e[5] = function () {
                              return t.handleBlur && t.handleBlur(...arguments)
                            }),
                          onInput:
                            e[6] ||
                            (e[6] = function () {
                              return t.handleInput && t.handleInput(...arguments)
                            }),
                          onChange:
                            e[7] ||
                            (e[7] = function () {
                              return t.handleChange && t.handleChange(...arguments)
                            }),
                        },
                        null,
                        46,
                        ete
                      )),
                  l.createElementVNode(
                    'label',
                    {
                      class: l.normalizeClass(
                        t.classes(
                          'var--ellipsis',
                          [t.isFocus, t.n('--focus')],
                          [t.errorMessage, t.n('--error')],
                          [t.textarea, t.n('textarea-placeholder'), t.n('placeholder')],
                          t.computePlaceholderState(),
                          [!t.hint, t.n('--placeholder-non-hint')]
                        )
                      ),
                      style: l.normalizeStyle({
                        color: t.errorMessage ? void 0 : t.isFocus ? t.focusColor : t.blurColor,
                      }),
                      for: t.id,
                    },
                    l.toDisplayString(t.placeholder),
                    15,
                    tte
                  ),
                ],
                2
              ),
              l.createElementVNode(
                'div',
                { class: l.normalizeClass(t.classes(t.n('icon'), [!t.hint, t.n('--non-hint')])) },
                [
                  l.renderSlot(t.$slots, 'append-icon', {}, () => [
                    t.clearable && !t.isEmpty(t.modelValue)
                      ? (l.openBlock(),
                        l.createBlock(
                          r,
                          {
                            key: 0,
                            class: l.normalizeClass(t.n('clear-icon')),
                            'var-input-cover': '',
                            name: 'close-circle',
                            size: '14px',
                            onClick: t.handleClear,
                          },
                          null,
                          8,
                          ['class', 'onClick']
                        ))
                      : l.createCommentVNode('v-if', !0),
                  ]),
                ],
                2
              ),
            ],
            6
          ),
          t.line
            ? (l.openBlock(),
              l.createElementBlock(
                'div',
                {
                  key: 0,
                  class: l.normalizeClass(
                    t.classes(
                      t.n('line'),
                      [t.formDisabled || t.disabled, t.n('--line-disabled')],
                      [t.errorMessage, t.n('--line-error')]
                    )
                  ),
                  style: l.normalizeStyle({ background: t.errorMessage ? void 0 : t.blurColor }),
                },
                [
                  l.createElementVNode(
                    'div',
                    {
                      class: l.normalizeClass(
                        t.classes(
                          t.n('dot'),
                          [t.isFocus, t.n('--spread')],
                          [t.formDisabled || t.disabled, t.n('--line-disabled')],
                          [t.errorMessage, t.n('--line-error')]
                        )
                      ),
                      style: l.normalizeStyle({ background: t.errorMessage ? void 0 : t.focusColor }),
                    },
                    null,
                    6
                  ),
                ],
                6
              ))
            : l.createCommentVNode('v-if', !0),
          l.createVNode(i, { 'error-message': t.errorMessage, 'maxlength-text': t.maxlengthText }, null, 8, [
            'error-message',
            'maxlength-text',
          ]),
        ],
        2
      )
    )
  }
  var Xl = l.defineComponent({
    render: rte,
    name: 'VarInput',
    components: { VarIcon: kt, VarFormDetails: lr },
    props: Jee,
    setup(t) {
      var e = l.ref('var-input-' + l.getCurrentInstance().uid),
        r = l.ref(null),
        i = l.ref(!1),
        n = l.computed(() => {
          var { maxlength: B, modelValue: K } = t
          return B ? (ki(K) ? '0 / ' + B : String(K).length + '/' + B) : ''
        }),
        { bindForm: s, form: a } = Or(),
        { errorMessage: o, validateWithTrigger: u, validate: c, resetValidation: p } = Nr(),
        h = (B) => {
          l.nextTick(() => {
            var { validateTrigger: K, rules: Y, modelValue: C } = t
            u(K, B, Y, C)
          })
        },
        f = () => {
          var { hint: B, modelValue: K } = t
          if (!B && !ki(K)) return Sh('--placeholder-hidden')
          if (B && (!ki(K) || i.value)) return Sh('--placeholder-hint')
        },
        d = (B) => {
          ;(i.value = !0), he(t.onFocus, B), h('onFocus')
        },
        T = (B) => {
          ;(i.value = !1), he(t.onBlur, B), h('onBlur')
        },
        y = (B) => {
          var { value: K } = B.target
          ;(K = E(K)), he(t['onUpdate:modelValue'], K), he(t.onInput, K, B), h('onInput')
        },
        b = (B) => {
          var { value: K } = B.target
          he(t.onChange, E(K), B), h('onChange')
        },
        m = () => {
          var { disabled: B, readonly: K, clearable: Y, onClear: C } = t
          ;(a != null && a.disabled.value) ||
            (a != null && a.readonly.value) ||
            B ||
            K ||
            !Y ||
            (he(t['onUpdate:modelValue'], ''), he(C, ''), h('onClear'))
        },
        S = (B) => {
          var { disabled: K, onClick: Y } = t
          ;(a != null && a.disabled.value) || K || (he(Y, B), h('onClick'))
        },
        E = (B) => (t.modelModifiers.trim ? B.trim() : B),
        P = () => {
          he(t['onUpdate:modelValue'], ''), p()
        },
        x = () => c(t.rules, t.modelValue),
        D = () => {
          var B
          ;(B = r.value) == null || B.focus()
        },
        N = () => {
          r.value.blur()
        },
        I = { reset: P, validate: x, resetValidation: p }
      return (
        he(s, I),
        l.onMounted(() => {
          t.autofocus && D()
        }),
        {
          el: r,
          id: e,
          isFocus: i,
          errorMessage: o,
          maxlengthText: n,
          formDisabled: a == null ? void 0 : a.disabled,
          formReadonly: a == null ? void 0 : a.readonly,
          n: Sh,
          classes: Zee,
          isEmpty: ki,
          computePlaceholderState: f,
          handleFocus: d,
          handleBlur: T,
          handleInput: y,
          handleChange: b,
          handleClear: m,
          handleClick: S,
          validate: x,
          resetValidation: p,
          reset: P,
          focus: D,
          blur: N,
        }
      )
    },
  })
  Xl.install = function (t) {
    t.component(Xl.name, Xl)
  }
  var ite = {
    loading: { type: Boolean, default: !1 },
    immediateCheck: { type: Boolean, default: !0 },
    finished: { type: Boolean, default: !1 },
    error: { type: Boolean, default: !1 },
    offset: { type: [String, Number], default: 0 },
    loadingText: { type: String },
    finishedText: { type: String },
    errorText: { type: String },
    onLoad: { type: Function },
    'onUpdate:loading': { type: Function },
    'onUpdate:error': { type: Function },
  }
  function Vb(t, e, r, i, n, s, a) {
    try {
      var o = t[s](a),
        u = o.value
    } catch (c) {
      r(c)
      return
    }
    o.done ? e(u) : Promise.resolve(u).then(i, n)
  }
  function nte(t) {
    return function () {
      var e = this,
        r = arguments
      return new Promise(function (i, n) {
        var s = t.apply(e, r)
        function a(u) {
          Vb(s, i, n, a, o, 'next', u)
        }
        function o(u) {
          Vb(s, i, n, a, o, 'throw', u)
        }
        a(void 0)
      })
    }
  }
  var { n: ste, classes: ate } = Me('list')
  function ote(t, e) {
    var r = l.resolveComponent('var-loading'),
      i = l.resolveDirective('ripple')
    return (
      l.openBlock(),
      l.createElementBlock(
        'div',
        { class: l.normalizeClass(t.classes(t.n(), 'var--box')), ref: 'listEl' },
        [
          l.renderSlot(t.$slots, 'default'),
          t.loading
            ? l.renderSlot(t.$slots, 'loading', { key: 0 }, () => [
                l.createElementVNode(
                  'div',
                  { class: l.normalizeClass(t.n('loading')) },
                  [
                    l.createElementVNode(
                      'div',
                      { class: l.normalizeClass(t.n('loading-text')) },
                      l.toDisplayString(t.dt(t.loadingText, t.pack.listLoadingText)),
                      3
                    ),
                    l.createVNode(r, { size: 'mini', radius: 10 }),
                  ],
                  2
                ),
              ])
            : l.createCommentVNode('v-if', !0),
          t.finished
            ? l.renderSlot(t.$slots, 'finished', { key: 1 }, () => [
                l.createElementVNode(
                  'div',
                  { class: l.normalizeClass(t.n('finished')) },
                  l.toDisplayString(t.dt(t.finishedText, t.pack.listFinishedText)),
                  3
                ),
              ])
            : l.createCommentVNode('v-if', !0),
          t.error
            ? l.renderSlot(t.$slots, 'error', { key: 2 }, () => [
                l.withDirectives(
                  (l.openBlock(),
                  l.createElementBlock(
                    'div',
                    {
                      class: l.normalizeClass(t.n('error')),
                      onClick:
                        e[0] ||
                        (e[0] = function () {
                          return t.load && t.load(...arguments)
                        }),
                    },
                    [l.createTextVNode(l.toDisplayString(t.dt(t.errorText, t.pack.listErrorText)), 1)],
                    2
                  )),
                  [[i]]
                ),
              ])
            : l.createCommentVNode('v-if', !0),
          l.createElementVNode('div', { class: l.normalizeClass(t.n('detector')), ref: 'detectorEl' }, null, 2),
        ],
        2
      )
    )
  }
  var vh = l.defineComponent({
    render: ote,
    name: 'VarList',
    directives: { Ripple: tr },
    components: { VarLoading: mn },
    props: ite,
    setup(t) {
      var e = l.ref(null),
        r = l.ref(null),
        i,
        n = () => {
          he(t['onUpdate:error'], !1), he(t['onUpdate:loading'], !0), he(t.onLoad)
        },
        s = () => {
          var o = i === window ? window.innerHeight : i.getBoundingClientRect().bottom,
            { bottom: u } = r.value.getBoundingClientRect()
          return Math.floor(u) - Mt(t.offset) <= o
        },
        a = (function () {
          var o = nte(function* () {
            yield l.nextTick()
            var { loading: u, finished: c, error: p } = t
            !u && !c && !p && s() && n()
          })
          return function () {
            return o.apply(this, arguments)
          }
        })()
      return (
        l.onMounted(() => {
          ;(i = Wn(e.value)), t.immediateCheck && a(), i.addEventListener('scroll', a)
        }),
        l.onUnmounted(() => {
          i.removeEventListener('scroll', a)
        }),
        { pack: Xt, listEl: e, detectorEl: r, dt: gl, isNumber: br, load: n, check: a, n: ste, classes: ate }
      )
    },
  })
  vh.install = function (t) {
    t.component(vh.name, vh)
  }
  function lte(t) {
    return ['top', 'bottom'].includes(t)
  }
  var ute = {
    show: { type: Boolean, default: !1 },
    alignment: { type: String, default: 'top', validator: lte },
    offsetX: { type: [Number, String], default: 0 },
    offsetY: { type: [Number, String], default: 0 },
    teleport: { type: String, default: 'body' },
    onOpen: { type: Function },
    onOpened: { type: Function },
    onClose: { type: Function },
    onClosed: { type: Function },
    'onUpdate:show': { type: Function },
  }
  function Ub(t, e, r, i, n, s, a) {
    try {
      var o = t[s](a),
        u = o.value
    } catch (c) {
      r(c)
      return
    }
    o.done ? e(u) : Promise.resolve(u).then(i, n)
  }
  function cte(t) {
    return function () {
      var e = this,
        r = arguments
      return new Promise(function (i, n) {
        var s = t.apply(e, r)
        function a(u) {
          Ub(s, i, n, a, o, 'next', u)
        }
        function o(u) {
          Ub(s, i, n, a, o, 'throw', u)
        }
        a(void 0)
      })
    }
  }
  function pte(t) {
    return typeof t == 'function' || (Object.prototype.toString.call(t) === '[object Object]' && !l.isVNode(t))
  }
  var { n: Eh, classes: fte } = Me('menu'),
    la = l.defineComponent({
      name: 'VarMenu',
      props: ute,
      setup(t, e) {
        var { slots: r } = e,
          i = l.ref(null),
          n = l.ref(null),
          s = l.ref(),
          a = l.ref(0),
          o = l.ref(0),
          { zIndex: u } = wl(() => t.show, 1),
          { disabled: c } = Sf(),
          p = !1,
          h = (m) => (m === 'top' ? ST(i.value) : ST(i.value) - n.value.offsetHeight),
          f = () => {
            p = !0
          },
          d = () => {
            if (p) {
              p = !1
              return
            }
            !t.show || he(t['onUpdate:show'], !1)
          },
          T = () => {
            ;(a.value = h(t.alignment)), (o.value = bT(i.value))
          },
          y = l.computed(() => ({
            top: 'calc(' + a.value + 'px + ' + xt(t.offsetY) + ')',
            left: 'calc(' + o.value + 'px + ' + xt(t.offsetX) + ')',
            zIndex: u.value,
          })),
          b = () =>
            l.createVNode(
              l.Transition,
              { name: Eh(), onAfterEnter: t.onOpened, onAfterLeave: t.onClosed },
              {
                default: () => [
                  l.withDirectives(
                    l.createVNode(
                      'div',
                      {
                        class: fte(Eh('menu'), 'var-elevation--3'),
                        ref: n,
                        style: y.value,
                        onClick: (m) => {
                          m.stopPropagation()
                        },
                      },
                      [he(r.menu)]
                    ),
                    [[l.vShow, t.show]]
                  ),
                ],
              }
            )
        return (
          l.watch(() => t.alignment, T),
          l.watch(
            () => t.show,
            (function () {
              var m = cte(function* (S) {
                var { onOpen: E, onClose: P } = t
                S && (yield l.nextTick(), T()), he(S ? E : P)
              })
              return function (S) {
                return m.apply(this, arguments)
              }
            })()
          ),
          l.watch(
            () => t.teleport,
            (m) => {
              s.value = m
            }
          ),
          l.onMounted(() => {
            ;(s.value = t.teleport), T(), document.addEventListener('click', d), window.addEventListener('resize', T)
          }),
          l.onUnmounted(() => {
            document.removeEventListener('click', d), window.removeEventListener('resize', T)
          }),
          nG({ resize: T }),
          () => {
            var m
            return l.createVNode('div', { class: Eh(), ref: i, onClick: f }, [
              he(r.default),
              s.value
                ? l.createVNode(
                    l.Teleport,
                    { to: s.value, disabled: c.value },
                    pte((m = b())) ? m : { default: () => [m] }
                  )
                : b(),
            ])
          }
        )
      },
    })
  la.install = function (t) {
    t.component(la.name, la)
  }
  var zb = Symbol('SELECT_BIND_OPTION_KEY'),
    Kb = Symbol('SELECT_COUNT_OPTION_KEY')
  function hte() {
    var { bindChildren: t, childProviders: e } = Sr(zb),
      { length: r } = Ir(Kb)
    return { length: r, options: e, bindOptions: t }
  }
  function dte() {
    var { bindParent: t, parentProvider: e } = vr(zb),
      { index: r } = kr(Kb)
    if (!t || !e) throw Error('<var-option/> must in <var-select/>')
    return { index: r, select: e, bindSelect: t }
  }
  var mte = { label: {}, value: {} },
    { n: yte, classes: gte } = Me('option')
  function Tte(t, e) {
    var r = l.resolveComponent('var-checkbox'),
      i = l.resolveDirective('ripple')
    return l.withDirectives(
      (l.openBlock(),
      l.createElementBlock(
        'div',
        {
          class: l.normalizeClass(t.classes(t.n(), 'var--box', [t.optionSelected, t.n('--selected-color')])),
          style: l.normalizeStyle({ width: t.wrapWidth, color: t.optionSelected ? t.focusColor : void 0 }),
          onClick:
            e[2] ||
            (e[2] = function () {
              return t.handleClick && t.handleClick(...arguments)
            }),
        },
        [
          l.createElementVNode(
            'div',
            {
              class: l.normalizeClass(t.classes(t.n('cover'), [t.optionSelected, t.n('--selected-background')])),
              style: l.normalizeStyle({ background: t.optionSelected ? t.focusColor : void 0 }),
            },
            null,
            6
          ),
          t.multiple
            ? (l.openBlock(),
              l.createBlock(
                r,
                {
                  key: 0,
                  ref: 'checkbox',
                  'checked-color': t.focusColor,
                  modelValue: t.optionSelected,
                  'onUpdate:modelValue': e[0] || (e[0] = (n) => (t.optionSelected = n)),
                  onClick: e[1] || (e[1] = l.withModifiers(() => {}, ['stop'])),
                  onChange: t.handleSelect,
                },
                null,
                8,
                ['checked-color', 'modelValue', 'onChange']
              ))
            : l.createCommentVNode('v-if', !0),
          l.createElementVNode(
            'div',
            { class: l.normalizeClass(t.classes(t.n('text'), 'var--ellipsis')) },
            [l.renderSlot(t.$slots, 'default', {}, () => [l.createTextVNode(l.toDisplayString(t.label), 1)])],
            2
          ),
        ],
        6
      )),
      [[i]]
    )
  }
  var Ph = l.defineComponent({
    render: Tte,
    name: 'VarOption',
    directives: { Ripple: tr },
    components: { VarCheckbox: kl },
    props: mte,
    setup(t) {
      var e = l.ref(!1),
        r = l.computed(() => e.value),
        i = l.computed(() => t.label),
        n = l.computed(() => t.value),
        { select: s, bindSelect: a } = dte(),
        { wrapWidth: o, multiple: u, focusColor: c, onSelect: p } = s,
        h = () => {
          ;(e.value = !e.value), p(T)
        },
        f = () => p(T),
        d = (y) => {
          e.value = y
        },
        T = { label: i, value: n, selected: r, sync: d }
      return (
        l.watch(
          [() => t.label, () => t.value],
          () => {
            if (t.label == null && t.value == null)
              throw Error(`Props label and value can't both be undefined
`)
          },
          { immediate: !0 }
        ),
        a(T),
        {
          n: yte,
          classes: gte,
          optionSelected: e,
          wrapWidth: o,
          multiple: u,
          focusColor: c,
          handleClick: h,
          handleSelect: f,
        }
      )
    },
  })
  Ph.install = function (t) {
    t.component(Ph.name, Ph)
  }
  var bte = {
      current: { type: [Number, String] },
      size: { type: [Number, String], default: 10 },
      total: { type: [Number, String], default: 0 },
      maxPagerCount: { type: Number, default: 3 },
      disabled: { type: Boolean, default: !1 },
      simple: { type: Boolean, default: !0 },
      showSizeChanger: { type: Boolean, default: !0 },
      showQuickJumper: { type: Boolean, default: !1 },
      sizeOption: { type: Array, default: () => [10, 20, 50, 100] },
      showTotal: { type: Function },
      onChange: { type: Function },
      'onUpdate:current': { type: Function },
      'onUpdate:size': { type: Function },
    },
    { n: Ste, classes: vte } = Me('pagination'),
    Ete = ['item-mode', 'onClick']
  function Pte(t, e) {
    var r = l.resolveComponent('var-icon'),
      i = l.resolveComponent('var-input'),
      n = l.resolveComponent('var-cell'),
      s = l.resolveComponent('var-menu'),
      a = l.resolveDirective('ripple')
    return (
      l.openBlock(),
      l.createElementBlock(
        'ul',
        { class: l.normalizeClass(t.n()) },
        [
          l.withDirectives(
            (l.openBlock(),
            l.createElementBlock(
              'li',
              {
                class: l.normalizeClass(
                  t.classes(
                    t.n('item'),
                    t.n('prev'),
                    [t.current <= 1 || t.disabled, t.n('item--disabled')],
                    [t.simple, t.n('item--hover'), 'var-elevation--2']
                  )
                ),
                onClick: e[0] || (e[0] = (o) => t.clickItem('prev')),
              },
              [l.renderSlot(t.$slots, 'prev', {}, () => [l.createVNode(r, { name: 'chevron-left' })])],
              2
            )),
            [[a, { disabled: t.current <= 1 || t.disabled }]]
          ),
          t.simple
            ? (l.openBlock(),
              l.createElementBlock(
                'li',
                { key: 0, class: l.normalizeClass(t.classes(t.n('simple'), [t.disabled, t.n('item--disabled')])) },
                [
                  l.createVNode(
                    i,
                    {
                      modelValue: t.simpleValue,
                      'onUpdate:modelValue': e[1] || (e[1] = (o) => (t.simpleValue = o)),
                      disabled: t.disabled,
                      'var-pagination-cover': '',
                      onBlur: e[2] || (e[2] = (o) => t.setPage('simple', t.simpleValue, o)),
                      onKeydown: e[3] || (e[3] = l.withKeys((o) => t.setPage('simple', t.simpleValue, o), ['enter'])),
                    },
                    null,
                    8,
                    ['modelValue', 'disabled']
                  ),
                  l.createElementVNode('span', null, '/ ' + l.toDisplayString(t.pageCount), 1),
                ],
                2
              ))
            : (l.openBlock(!0),
              l.createElementBlock(
                l.Fragment,
                { key: 1 },
                l.renderList(t.pageList, (o, u) =>
                  l.withDirectives(
                    (l.openBlock(),
                    l.createElementBlock(
                      'li',
                      {
                        key: t.toNumber(o) + u,
                        'item-mode': t.getMode(o, u),
                        class: l.normalizeClass(
                          t.classes(
                            t.n('item'),
                            'var-elevation--2',
                            [o === t.current && !t.disabled, t.n('item--active')],
                            [t.isHideEllipsis(o, u), t.n('item--hide')],
                            [t.disabled, t.n('item--disabled')],
                            [o === t.current && t.disabled, t.n('item--disabled--active')]
                          )
                        ),
                        onClick: (c) => t.clickItem(o, u),
                      },
                      [l.createTextVNode(l.toDisplayString(o), 1)],
                      10,
                      Ete
                    )),
                    [[a, { disabled: t.disabled }]]
                  )
                ),
                128
              )),
          l.withDirectives(
            (l.openBlock(),
            l.createElementBlock(
              'li',
              {
                class: l.normalizeClass(
                  t.classes(
                    t.n('item'),
                    t.n('next'),
                    [t.current >= t.pageCount || t.disabled, t.n('item--disabled')],
                    [t.simple, t.n('item--hover'), 'var-elevation--2']
                  )
                ),
                onClick: e[4] || (e[4] = (o) => t.clickItem('next')),
              },
              [l.renderSlot(t.$slots, 'next', {}, () => [l.createVNode(r, { name: 'chevron-right' })])],
              2
            )),
            [[a, { disabled: t.current >= t.pageCount || t.disabled }]]
          ),
          t.showSizeChanger
            ? (l.openBlock(),
              l.createElementBlock(
                'li',
                { key: 2, class: l.normalizeClass(t.classes(t.n('size'), [t.disabled, t.n('item--disabled')])) },
                [
                  l.createVNode(
                    s,
                    {
                      show: t.menuVisible,
                      'onUpdate:show': e[6] || (e[6] = (o) => (t.menuVisible = o)),
                      'offset-x': -4,
                    },
                    {
                      menu: l.withCtx(() => [
                        (l.openBlock(!0),
                        l.createElementBlock(
                          l.Fragment,
                          null,
                          l.renderList(t.sizeOption, (o, u) =>
                            l.withDirectives(
                              (l.openBlock(),
                              l.createBlock(
                                n,
                                {
                                  class: l.normalizeClass(t.classes(t.n('list'), [t.size === o, t.n('list--active')])),
                                  key: u,
                                  onClick: (c) => t.clickSize(o),
                                },
                                {
                                  default: l.withCtx(() => [
                                    l.createTextVNode(
                                      l.toDisplayString(o) +
                                        l.toDisplayString(t.pack.paginationItem) +
                                        ' / ' +
                                        l.toDisplayString(t.pack.paginationPage),
                                      1
                                    ),
                                  ]),
                                  _: 2,
                                },
                                1032,
                                ['class', 'onClick']
                              )),
                              [[a]]
                            )
                          ),
                          128
                        )),
                      ]),
                      default: l.withCtx(() => [
                        l.createElementVNode(
                          'div',
                          {
                            class: l.normalizeClass(
                              t.classes(t.n('size--open'), [t.current <= 1 || t.disabled, t.n('size--open--disabled')])
                            ),
                            onClick:
                              e[5] ||
                              (e[5] = function () {
                                return t.showMenu && t.showMenu(...arguments)
                              }),
                          },
                          [
                            l.createElementVNode(
                              'span',
                              null,
                              l.toDisplayString(t.size) +
                                l.toDisplayString(t.pack.paginationItem) +
                                ' / ' +
                                l.toDisplayString(t.pack.paginationPage),
                              1
                            ),
                            l.createVNode(
                              r,
                              {
                                class: l.normalizeClass(t.n('size--open-icon')),
                                'var-pagination-cover': '',
                                name: 'menu-down',
                              },
                              null,
                              8,
                              ['class']
                            ),
                          ],
                          2
                        ),
                      ]),
                      _: 1,
                    },
                    8,
                    ['show']
                  ),
                ],
                2
              ))
            : l.createCommentVNode('v-if', !0),
          t.showQuickJumper && !t.simple
            ? (l.openBlock(),
              l.createElementBlock(
                'li',
                { key: 3, class: l.normalizeClass(t.classes(t.n('quickly'), [t.disabled, 'item--disabled'])) },
                [
                  l.createTextVNode(l.toDisplayString(t.pack.paginationJump) + ' ', 1),
                  l.createVNode(
                    i,
                    {
                      modelValue: t.inputValue,
                      'onUpdate:modelValue': e[7] || (e[7] = (o) => (t.inputValue = o)),
                      disabled: t.disabled,
                      'var-pagination-cover': '',
                      onBlur: e[8] || (e[8] = (o) => t.setPage('quick', t.inputValue, o)),
                      onKeydown: e[9] || (e[9] = l.withKeys((o) => t.setPage('quick', t.inputValue, o), ['enter'])),
                    },
                    null,
                    8,
                    ['modelValue', 'disabled']
                  ),
                ],
                2
              ))
            : l.createCommentVNode('v-if', !0),
          t.totalText
            ? (l.openBlock(),
              l.createElementBlock(
                'li',
                { key: 4, class: l.normalizeClass(t.n('total')) },
                l.toDisplayString(t.totalText),
                3
              ))
            : l.createCommentVNode('v-if', !0),
        ],
        2
      )
    )
  }
  var wh = l.defineComponent({
    render: Pte,
    name: 'VarPagination',
    components: { VarMenu: la, VarIcon: kt, VarCell: Il, VarInput: Xl },
    directives: { Ripple: tr },
    props: bte,
    setup(t) {
      var e = l.ref(!1),
        r = l.ref(''),
        i = l.ref('1'),
        n = l.ref(!1),
        s = l.ref(!1),
        a = l.ref(Ee(t.current) || 1),
        o = l.ref(Ee(t.size) || 10),
        u = l.ref([]),
        c = l.computed(() => Math.ceil(t.maxPagerCount / 2)),
        p = l.computed(() => Math.ceil(Ee(t.total) / Ee(o.value))),
        h = l.computed(() => {
          var P = o.value * (a.value - 1) + 1,
            x = Math.min(o.value * a.value, Ee(t.total))
          return [P, x]
        }),
        f = l.computed(() => (t.showTotal ? t.showTotal(Ee(t.total), h.value) : '')),
        d = (P, x) => (br(P) ? !1 : x === 1 ? n.value : s.value),
        T = (P, x) => (br(P) ? 'basic' : x === 1 ? 'head' : 'tail'),
        y = (P, x) => {
          P === a.value ||
            t.disabled ||
            (br(P)
              ? (a.value = P)
              : P === 'prev'
              ? a.value > 1 && (a.value -= 1)
              : P === 'next'
              ? a.value < p.value && (a.value += 1)
              : P === '...' &&
                (x === 1
                  ? (a.value = Math.max(a.value - t.maxPagerCount, 1))
                  : (a.value = Math.min(a.value + t.maxPagerCount, p.value))))
        },
        b = () => {
          t.disabled || (e.value = !0)
        },
        m = (P) => {
          ;(o.value = P), (e.value = !1)
        },
        S = (P) => {
          var x = /^[1-9][0-9]*$/
          return x.test(P)
        },
        E = (P, x, D) => {
          if ((D.target.blur(), S(x))) {
            var N = Ee(x)
            N > p.value && ((N = p.value), (i.value = '' + N)), N !== a.value && (a.value = N)
          }
          P === 'quick' && (r.value = ''), P === 'simple' && !S(x) && (i.value = '' + a.value)
        }
      return (
        l.watch([() => t.current, () => t.size], (P) => {
          var [x, D] = P
          ;(a.value = Ee(x) || 1), (o.value = Ee(D || 10))
        }),
        l.watch(
          [a, o],
          (P, x) => {
            var D,
              N,
              [I, B] = P,
              [K, Y] = x
            if (I > p.value) {
              a.value = p.value
              return
            }
            var C = [],
              { maxPagerCount: H, total: w, onChange: J } = t,
              X = Math.ceil(Ee(w) / Ee(Y)),
              G = p.value - (H - c.value) - 1
            if (((i.value = '' + I), p.value - 2 > H)) {
              if (K === void 0 || p.value !== X) for (var Te = 2; Te < H + 2; Te++) C.push(Te)
              if (I <= H && I < G) {
                C = []
                for (var ce = 1; ce < H + 1; ce++) C.push(ce + 1)
                ;(n.value = !0), (s.value = !1)
              }
              if (I > H && I < G) {
                C = []
                for (var se = 1; se < H + 1; se++) C.push(I + se - c.value)
                ;(n.value = I === 2 && H === 1), (s.value = !1)
              }
              if (I >= G) {
                C = []
                for (var U = 1; U < H + 1; U++) C.push(p.value - (H - U) - 1)
                ;(n.value = !1), (s.value = !0)
              }
              C = [1, '...', ...C, '...', p.value]
            } else for (var W = 1; W <= p.value; W++) C.push(W)
            ;(u.value = C),
              K !== void 0 && (J == null || J(I, B)),
              (D = t['onUpdate:current']) == null || D.call(t, I),
              (N = t['onUpdate:size']) == null || N.call(t, B)
          },
          { immediate: !0 }
        ),
        {
          n: Ste,
          classes: vte,
          pack: Xt,
          current: a,
          menuVisible: e,
          size: o,
          pageCount: p,
          pageList: u,
          inputValue: r,
          simpleValue: i,
          totalText: f,
          getMode: T,
          isHideEllipsis: d,
          clickItem: y,
          showMenu: b,
          clickSize: m,
          setPage: E,
          toNumber: Ee,
        }
      )
    },
  })
  wh.install = function (t) {
    t.component(wh.name, wh)
  }
  function Ah() {
    return (
      (Ah =
        Object.assign ||
        function (t) {
          for (var e = 1; e < arguments.length; e++) {
            var r = arguments[e]
            for (var i in r) Object.prototype.hasOwnProperty.call(r, i) && (t[i] = r[i])
          }
          return t
        }),
      Ah.apply(this, arguments)
    )
  }
  var wte = Ah(
      {
        columns: { type: Array, default: () => [] },
        title: { type: String },
        textKey: { type: String, default: 'text' },
        toolbar: { type: Boolean, default: !0 },
        cascade: { type: Boolean, default: !1 },
        cascadeInitialIndexes: { type: Array, default: () => [] },
        optionHeight: { type: [Number, String], default: 44 },
        optionCount: { type: [Number, String], default: 6 },
        confirmButtonText: { type: String },
        cancelButtonText: { type: String },
        confirmButtonTextColor: { type: String },
        cancelButtonTextColor: { type: String },
        dynamic: { type: Boolean, default: !1 },
        onChange: { type: Function },
        onConfirm: { type: Function },
        onCancel: { type: Function },
        textFormatter: { type: Function, default: (t) => t },
      },
      xr(Zs, [
        'show',
        'onUpdate:show',
        'closeOnClickOverlay',
        'teleport',
        'onOpen',
        'onClose',
        'onOpened',
        'onClosed',
        'onClickOverlay',
        'onRouteChange',
      ])
    ),
    { n: Ate, classes: Cte } = Me('picker'),
    Wb = 300,
    xte = 15,
    Yb = 0,
    Ite = ['onTouchstart', 'onTouchmove', 'onTouchend'],
    kte = ['onTransitionend']
  function Nte(t, e) {
    var r = l.resolveComponent('var-button')
    return (
      l.openBlock(),
      l.createBlock(
        l.resolveDynamicComponent(t.dynamic ? 'var-popup' : t.Transition),
        l.mergeProps(
          t.dynamic
            ? {
                onOpen: t.onOpen,
                onOpened: t.onOpened,
                onClose: t.onClose,
                onClosed: t.onClosed,
                onClickOverlay: t.onClickOverlay,
                onRouteChange: t.onRouteChange,
                closeOnClickOverlay: t.closeOnClickOverlay,
                teleport: t.teleport,
                show: t.show,
                'onUpdate:show': t.handlePopupUpdateShow,
                position: 'bottom',
                class: t.n('popup'),
              }
            : null,
          { 'var-picker-cover': '' }
        ),
        {
          default: l.withCtx(() => [
            l.createElementVNode(
              'div',
              l.mergeProps({ class: t.n() }, t.$attrs),
              [
                l.createElementVNode(
                  'div',
                  { class: l.normalizeClass(t.n('toolbar')) },
                  [
                    l.renderSlot(t.$slots, 'cancel', {}, () => [
                      l.createVNode(
                        r,
                        {
                          class: l.normalizeClass(t.n('cancel-button')),
                          'var-picker-cover': '',
                          text: '',
                          'text-color': t.cancelButtonTextColor,
                          onClick: t.cancel,
                        },
                        {
                          default: l.withCtx(() => [
                            l.createTextVNode(
                              l.toDisplayString(t.dt(t.cancelButtonText, t.pack.pickerCancelButtonText)),
                              1
                            ),
                          ]),
                          _: 1,
                        },
                        8,
                        ['class', 'text-color', 'onClick']
                      ),
                    ]),
                    l.renderSlot(t.$slots, 'title', {}, () => [
                      l.createElementVNode(
                        'div',
                        { class: l.normalizeClass(t.n('title')) },
                        l.toDisplayString(t.dt(t.title, t.pack.pickerTitle)),
                        3
                      ),
                    ]),
                    l.renderSlot(t.$slots, 'confirm', {}, () => [
                      l.createVNode(
                        r,
                        {
                          class: l.normalizeClass(t.n('confirm-button')),
                          text: '',
                          'var-picker-cover': '',
                          'text-color': t.confirmButtonTextColor,
                          onClick: t.confirm,
                        },
                        {
                          default: l.withCtx(() => [
                            l.createTextVNode(
                              l.toDisplayString(t.dt(t.confirmButtonText, t.pack.pickerConfirmButtonText)),
                              1
                            ),
                          ]),
                          _: 1,
                        },
                        8,
                        ['class', 'text-color', 'onClick']
                      ),
                    ]),
                  ],
                  2
                ),
                l.createElementVNode(
                  'div',
                  {
                    class: l.normalizeClass(t.n('columns')),
                    style: l.normalizeStyle({ height: t.columnHeight + 'px' }),
                  },
                  [
                    (l.openBlock(!0),
                    l.createElementBlock(
                      l.Fragment,
                      null,
                      l.renderList(
                        t.scrollColumns,
                        (i) => (
                          l.openBlock(),
                          l.createElementBlock(
                            'div',
                            {
                              class: l.normalizeClass(t.n('column')),
                              key: i.id,
                              onTouchstart: (n) => t.handleTouchstart(n, i),
                              onTouchmove: l.withModifiers((n) => t.handleTouchmove(n, i), ['prevent']),
                              onTouchend: (n) => t.handleTouchend(n, i),
                            },
                            [
                              l.createElementVNode(
                                'div',
                                {
                                  class: l.normalizeClass(t.n('scroller')),
                                  ref_for: !0,
                                  ref: (n) => t.getScrollEl(n, i),
                                  style: l.normalizeStyle({
                                    transform: 'translateY(' + i.translate + 'px)',
                                    transitionDuration: i.duration + 'ms',
                                    transitionProperty: i.duration ? 'transform' : 'none',
                                  }),
                                  onTransitionend: (n) => t.handleTransitionend(i),
                                },
                                [
                                  (l.openBlock(!0),
                                  l.createElementBlock(
                                    l.Fragment,
                                    null,
                                    l.renderList(
                                      i.column.texts,
                                      (n) => (
                                        l.openBlock(),
                                        l.createElementBlock(
                                          'div',
                                          {
                                            class: l.normalizeClass(t.n('option')),
                                            style: l.normalizeStyle({ height: t.optionHeight + 'px' }),
                                            key: n,
                                          },
                                          [
                                            l.createElementVNode(
                                              'div',
                                              { class: l.normalizeClass(t.n('text')) },
                                              l.toDisplayString(t.textFormatter(n, i.columnIndex)),
                                              3
                                            ),
                                          ],
                                          6
                                        )
                                      )
                                    ),
                                    128
                                  )),
                                ],
                                46,
                                kte
                              ),
                            ],
                            42,
                            Ite
                          )
                        )
                      ),
                      128
                    )),
                    l.createElementVNode(
                      'div',
                      {
                        class: l.normalizeClass(t.n('picked')),
                        style: l.normalizeStyle({ top: t.center + 'px', height: t.optionHeight + 'px' }),
                      },
                      null,
                      6
                    ),
                    l.createElementVNode(
                      'div',
                      {
                        class: l.normalizeClass(t.n('mask')),
                        style: l.normalizeStyle({
                          backgroundSize: '100% ' + (t.columnHeight - t.optionHeight) / 2 + 'px',
                        }),
                      },
                      null,
                      6
                    ),
                  ],
                  6
                ),
              ],
              16
            ),
          ]),
          _: 3,
        },
        16
      )
    )
  }
  var Ch = l.defineComponent({
    render: Nte,
    name: 'VarPicker',
    components: { VarButton: Er, VarPopup: Ni },
    inheritAttrs: !1,
    props: wte,
    setup(t) {
      var e = l.ref([]),
        r = l.computed(() => Mt(t.optionHeight)),
        i = l.computed(() => Mt(t.optionCount)),
        n = l.computed(() => (i.value * r.value) / 2 - r.value / 2),
        s = l.computed(() => i.value * r.value),
        a = [],
        o = (Y, C) => {
          C.scrollEl = Y
        },
        u = (Y) => {
          he(t['onUpdate:show'], Y)
        },
        c = (Y) => {
          var C = r.value + n.value,
            H = n.value - Y.column.texts.length * r.value
          Y.translate >= C && (Y.translate = C), Y.translate <= H && (Y.translate = H)
        },
        p = (Y, C) => {
          var { length: H } = Y.column.texts
          return (C = C >= H ? H - 1 : C), (C = C <= 0 ? 0 : C), C
        },
        h = (Y) => {
          var C = Math.round((n.value - Y.translate) / r.value)
          return p(Y, C)
        },
        f = () => {
          var Y = e.value.map((H) => H.column.texts[H.index]),
            C = e.value.map((H) => H.index)
          return { texts: Y, indexes: C }
        },
        d = function (Y, C, H, w) {
          w === void 0 && (w = !1)
          var J = n.value - p(Y, C) * r.value
          J === Y.translate && ((Y.scrolling = !1), !w && N(Y)), (Y.translate = J), (Y.duration = H)
        },
        T = (Y, C, H) => {
          Y.translate += (Math.abs(C / H) / 0.003) * (C < 0 ? -1 : 1)
        },
        y = (Y, C) => {
          ;(C.touching = !0), (C.scrolling = !1), (C.duration = 0), (C.translate = Tf(C.scrollEl))
        },
        b = (Y, C) => {
          if (!!C.touching) {
            var { clientY: H } = Y.touches[0],
              w = C.prevY !== void 0 ? H - C.prevY : 0
            ;(C.prevY = H), (C.translate += w), c(C)
            var J = performance.now()
            J - C.momentumTime > Wb && ((C.momentumTime = J), (C.momentumPrevY = C.translate))
          }
        },
        m = (Y, C) => {
          ;(C.touching = !1), (C.scrolling = !0), (C.prevY = void 0)
          var H = C.translate - C.momentumPrevY,
            w = performance.now() - C.momentumTime,
            J = Math.abs(H) >= xte && w <= Wb
          J && T(C, H, w), (C.index = h(C)), d(C, C.index, J ? 1e3 : 200)
        },
        S = (Y) => {
          ;(Y.scrolling = !1), N(Y)
        },
        E = (Y) =>
          Y.map((C, H) => {
            var w,
              J = At(C) ? { texts: C } : C,
              X = {
                id: Yb++,
                prevY: void 0,
                momentumPrevY: void 0,
                touching: !1,
                translate: n.value,
                index: (w = J.initialIndex) != null ? w : 0,
                columnIndex: H,
                duration: 0,
                momentumTime: 0,
                column: J,
                scrollEl: null,
                scrolling: !1,
              }
            return d(X, X.index, 0, !0), X
          }),
        P = (Y) => {
          var C = []
          return x(C, Y, 0, !0), C
        },
        x = function (Y, C, H, w) {
          if ((w === void 0 && (w = !1), At(C) && C.length)) {
            var J,
              X = w && (J = t.cascadeInitialIndexes[Y.length]) != null ? J : 0,
              G = {
                id: Yb++,
                prevY: void 0,
                momentumPrevY: void 0,
                touching: !1,
                translate: n.value,
                index: X,
                columnIndex: H,
                duration: 0,
                momentumTime: 0,
                column: { texts: C.map((Te) => Te[t.textKey]) },
                columns: C,
                scrollEl: null,
                scrolling: !1,
              }
            Y.push(G), d(G, G.index, 0, !0), x(Y, G.columns[G.index].children, H + 1, w)
          }
        },
        D = (Y) => {
          e.value.splice(e.value.indexOf(Y) + 1), x(e.value, Y.columns[Y.index].children, Y.columnIndex + 1)
        },
        N = (Y) => {
          var { cascade: C, onChange: H } = t
          C && D(Y)
          var w = e.value.some((Te) => Te.scrolling)
          if (!w) {
            var { texts: J, indexes: X } = f(),
              G = X.every((Te, ce) => Te === a[ce])
            G || ((a = [...X]), he(H, J, X))
          }
        },
        I = () => {
          if (t.cascade) {
            var Y = e.value.find((C) => C.scrolling)
            Y && ((Y.translate = Tf(Y.scrollEl)), (Y.index = h(Y)), d(Y, Y.index, 0, !0), (Y.scrolling = !1), D(Y))
          } else
            e.value.forEach((C) => {
              ;(C.translate = Tf(C.scrollEl)), (C.index = h(C)), d(C, C.index, 0)
            })
        },
        B = () => {
          I()
          var { texts: Y, indexes: C } = f()
          ;(a = [...C]), he(t.onConfirm, Y, C)
        },
        K = () => {
          I()
          var { texts: Y, indexes: C } = f()
          ;(a = [...C]), he(t.onCancel, Y, C)
        }
      return (
        l.watch(
          () => t.columns,
          (Y) => {
            e.value = t.cascade ? P(l.toRaw(Y)) : E(l.toRaw(Y))
            var { indexes: C } = f()
            a = [...C]
          },
          { immediate: !0, deep: !0 }
        ),
        {
          n: Ate,
          classes: Cte,
          pack: Xt,
          optionHeight: r,
          optionCount: i,
          scrollColumns: e,
          columnHeight: s,
          center: n,
          Transition: l.Transition,
          getScrollEl: o,
          handlePopupUpdateShow: u,
          handleTouchstart: y,
          handleTouchmove: b,
          handleTouchend: m,
          handleTransitionend: S,
          confirm: B,
          cancel: K,
          dt: gl,
        }
      )
    },
  })
  Ch.install = function (t) {
    t.component(Ch.name, Ch)
  }
  function Ote(t) {
    return ['linear', 'circle'].includes(t)
  }
  var Dte = {
      mode: { type: String, default: 'linear', validator: Ote },
      lineWidth: { type: [Number, String], default: 4 },
      color: { type: String },
      trackColor: { type: String },
      ripple: { type: Boolean, default: !1 },
      value: { type: [Number, String], default: 0 },
      label: { type: Boolean, default: !1 },
      size: { type: [Number, String], default: 40 },
      rotate: { type: Number, default: 0 },
      track: { type: Boolean, default: !0 },
    },
    { n: Bte, classes: Lte } = Me('progress'),
    Mte = ['viewBox'],
    Fte = ['cx', 'cy', 'r', 'stroke-width'],
    $te = ['cx', 'cy', 'r', 'stroke-width']
  function Rte(t, e) {
    return (
      l.openBlock(),
      l.createElementBlock(
        'div',
        { class: l.normalizeClass(t.n()) },
        [
          t.mode === 'linear'
            ? (l.openBlock(),
              l.createElementBlock(
                'div',
                { key: 0, class: l.normalizeClass(t.n('linear')) },
                [
                  l.createElementVNode(
                    'div',
                    l.mergeProps(
                      { class: t.n('linear-block'), style: { height: t.toSizeUnit(t.lineWidth) } },
                      t.$attrs
                    ),
                    [
                      t.track
                        ? (l.openBlock(),
                          l.createElementBlock(
                            'div',
                            {
                              key: 0,
                              class: l.normalizeClass(t.n('linear-background')),
                              style: l.normalizeStyle({ background: t.trackColor }),
                            },
                            null,
                            6
                          ))
                        : l.createCommentVNode('v-if', !0),
                      l.createElementVNode(
                        'div',
                        {
                          class: l.normalizeClass(t.classes(t.n('linear-certain'), [t.ripple, t.n('linear-ripple')])),
                          style: l.normalizeStyle({ background: t.color, width: t.linearProps.width }),
                        },
                        null,
                        6
                      ),
                    ],
                    16
                  ),
                  t.label
                    ? (l.openBlock(),
                      l.createElementBlock(
                        'div',
                        l.mergeProps({ key: 0, class: t.n('linear-label') }, t.$attrs),
                        [
                          l.renderSlot(t.$slots, 'default', {}, () => [
                            l.createTextVNode(l.toDisplayString(t.linearProps.roundValue), 1),
                          ]),
                        ],
                        16
                      ))
                    : l.createCommentVNode('v-if', !0),
                ],
                2
              ))
            : l.createCommentVNode('v-if', !0),
          t.mode === 'circle'
            ? (l.openBlock(),
              l.createElementBlock(
                'div',
                {
                  key: 1,
                  class: l.normalizeClass(t.n('circle')),
                  style: l.normalizeStyle({ width: t.toSizeUnit(t.size), height: t.toSizeUnit(t.size) }),
                },
                [
                  (l.openBlock(),
                  l.createElementBlock(
                    'svg',
                    {
                      class: l.normalizeClass(t.n('circle-svg')),
                      style: l.normalizeStyle({ transform: 'rotate(' + (t.rotate - 90) + 'deg)' }),
                      viewBox: t.circleProps.viewBox,
                    },
                    [
                      t.track
                        ? (l.openBlock(),
                          l.createElementBlock(
                            'circle',
                            {
                              key: 0,
                              class: l.normalizeClass(t.n('circle-background')),
                              cx: t.multiplySizeUnit(t.size, 0.5),
                              cy: t.multiplySizeUnit(t.size, 0.5),
                              r: t.circleProps.radius,
                              fill: 'transparent',
                              'stroke-width': t.toSizeUnit(t.lineWidth),
                              style: l.normalizeStyle({
                                strokeDasharray: t.circleProps.perimeter,
                                stroke: t.trackColor,
                              }),
                            },
                            null,
                            14,
                            Fte
                          ))
                        : l.createCommentVNode('v-if', !0),
                      l.createElementVNode(
                        'circle',
                        {
                          class: l.normalizeClass(t.n('circle-certain')),
                          cx: t.multiplySizeUnit(t.size, 0.5),
                          cy: t.multiplySizeUnit(t.size, 0.5),
                          r: t.circleProps.radius,
                          fill: 'transparent',
                          'stroke-width': t.toSizeUnit(t.lineWidth),
                          style: l.normalizeStyle({ strokeDasharray: t.circleProps.strokeDasharray, stroke: t.color }),
                        },
                        null,
                        14,
                        $te
                      ),
                    ],
                    14,
                    Mte
                  )),
                  t.label
                    ? (l.openBlock(),
                      l.createElementBlock(
                        'div',
                        l.mergeProps({ key: 0, class: t.n('circle-label') }, t.$attrs),
                        [
                          l.renderSlot(t.$slots, 'default', {}, () => [
                            l.createTextVNode(l.toDisplayString(t.circleProps.roundValue), 1),
                          ]),
                        ],
                        16
                      ))
                    : l.createCommentVNode('v-if', !0),
                ],
                6
              ))
            : l.createCommentVNode('v-if', !0),
        ],
        2
      )
    )
  }
  var xh = l.defineComponent({
    render: Rte,
    name: 'VarProgress',
    inheritAttrs: !1,
    props: Dte,
    setup(t) {
      var e = l.computed(() => {
          var i = Ee(t.value),
            n = i > 100 ? 100 : i,
            s = i > 100 ? 100 : Math.round(i)
          return { width: n + '%', roundValue: s + '%' }
        }),
        r = l.computed(() => {
          var { size: i, lineWidth: n, value: s } = t,
            a = '0 0 ' + Mt(i) + ' ' + Mt(i),
            o = Ee(s) > 100 ? 100 : Math.round(Ee(s)),
            u = (Mt(i) - Mt(n)) / 2,
            c = 2 * Math.PI * u,
            p = (o / 100) * c + ', ' + c
          return { viewBox: a, radius: u, strokeDasharray: p, perimeter: c, roundValue: o + '%' }
        })
      return { n: Bte, classes: Lte, toSizeUnit: xt, multiplySizeUnit: qt, linearProps: e, circleProps: r }
    },
  })
  xh.install = function (t) {
    t.component(xh.name, xh)
  }
  var jte = {
    modelValue: { type: Boolean },
    disabled: { type: Boolean, default: !1 },
    animationDuration: { type: [Number, String], default: 300 },
    successDuration: { type: [Number, String], default: 2e3 },
    bgColor: { type: String },
    successBgColor: { type: String },
    color: { type: String },
    successColor: { type: String },
    onRefresh: { type: Function },
    'onUpdate:modelValue': { type: Function },
  }
  function Hb(t, e, r, i, n, s, a) {
    try {
      var o = t[s](a),
        u = o.value
    } catch (c) {
      r(c)
      return
    }
    o.done ? e(u) : Promise.resolve(u).then(i, n)
  }
  function _te(t) {
    return function () {
      var e = this,
        r = arguments
      return new Promise(function (i, n) {
        var s = t.apply(e, r)
        function a(u) {
          Hb(s, i, n, a, o, 'next', u)
        }
        function o(u) {
          Hb(s, i, n, a, o, 'throw', u)
        }
        a(void 0)
      })
    }
  }
  var { n: Vte, classes: Ute } = Me('pull-refresh'),
    ua = 100,
    ca = -50,
    qb = 150
  function zte(t, e) {
    var r = l.resolveComponent('var-icon')
    return (
      l.openBlock(),
      l.createElementBlock(
        'div',
        {
          ref: 'freshNode',
          class: l.normalizeClass(t.n()),
          onTouchstart:
            e[0] ||
            (e[0] = function () {
              return t.touchStart && t.touchStart(...arguments)
            }),
          onTouchmove:
            e[1] ||
            (e[1] = function () {
              return t.touchMove && t.touchMove(...arguments)
            }),
          onTouchend:
            e[2] ||
            (e[2] = function () {
              return t.touchEnd && t.touchEnd(...arguments)
            }),
          onTouchcancel:
            e[3] ||
            (e[3] = function () {
              return t.touchEnd && t.touchEnd(...arguments)
            }),
        },
        [
          l.createElementVNode(
            'div',
            {
              class: l.normalizeClass(
                t.classes(t.n('control'), 'var-elevation--2', [t.isSuccess, t.n('control-success')])
              ),
              style: l.normalizeStyle(t.controlStyle),
            },
            [
              l.createVNode(
                r,
                {
                  name: t.iconName,
                  transition: t.ICON_TRANSITION,
                  class: l.normalizeClass(
                    t.classes(t.n('icon'), [t.refreshStatus === 'loading' && t.iconHasChanged, t.n('animation')])
                  ),
                  'var-pull-refresh-cover': '',
                },
                null,
                8,
                ['name', 'transition', 'class']
              ),
            ],
            6
          ),
          l.renderSlot(t.$slots, 'default'),
        ],
        34
      )
    )
  }
  var Ih = l.defineComponent({
    render: zte,
    name: 'VarPullRefresh',
    components: { VarIcon: kt },
    props: jte,
    setup(t) {
      var e,
        r,
        i = l.ref(null),
        n = l.ref(0),
        s = l.ref(ca),
        a = l.ref('arrow-down'),
        o = l.ref('default'),
        u = l.ref(!1),
        c = l.ref(!0),
        p = l.computed(() => o.value !== 'loading' && o.value !== 'success' && !t.disabled),
        h = l.computed(() => ({
          transform: 'translate3d(0px, ' + s.value + 'px, 0px) translate(-50%, 0)',
          transition: u.value ? 'transform ' + t.animationDuration + 'ms' : void 0,
          background: t.successBgColor || t.bgColor,
          color: t.successColor || t.color,
        })),
        f = l.computed(() => o.value === 'success'),
        d = () =>
          new Promise((S) => {
            window.setTimeout(() => {
              ;(c.value = !0), S()
            }, qb)
          }),
        T = (S) => {
          !p.value || ((o.value = 'pulling'), (n.value = S.touches[0].clientY))
        },
        y = (S) => {
          var E = Tl(e)
          if (!(E > 0 || !p.value)) {
            E === 0 && s.value > ca && S.cancelable && S.preventDefault()
            var P = (S.touches[0].clientY - n.value) / 2 + ca
            ;(s.value = P >= ua ? ua : P),
              s.value >= ua * 0.2 ? ((c.value = !1), (a.value = 'refresh'), (r = d())) : (a.value = 'arrow-down')
          }
        },
        b = (function () {
          var S = _te(function* () {
            if (!!p.value)
              if (((u.value = !0), s.value >= ua * 0.2)) {
                var E
                yield r,
                  (o.value = 'loading'),
                  (s.value = ua * 0.3),
                  (E = t['onUpdate:modelValue']) == null || E.call(t, !0),
                  t.onRefresh == null || t.onRefresh()
              } else
                (o.value = 'loosing'),
                  (a.value = 'arrow-down'),
                  (s.value = ca),
                  setTimeout(() => {
                    u.value = !1
                  }, Ee(t.animationDuration))
          })
          return function () {
            return S.apply(this, arguments)
          }
        })(),
        m = () => {
          setTimeout(() => {
            ;(o.value = 'default'), (a.value = 'arrow-down'), (u.value = !1)
          }, Ee(t.animationDuration))
        }
      return (
        l.watch(
          () => t.modelValue,
          (S) => {
            S === !1 &&
              ((u.value = !0),
              (o.value = 'success'),
              (a.value = 'checkbox-marked-circle'),
              setTimeout(() => {
                ;(s.value = ca), m()
              }, Ee(t.successDuration)))
          }
        ),
        l.onMounted(() => {
          e = Wn(i.value)
        }),
        {
          n: Vte,
          classes: Ute,
          iconHasChanged: c,
          ICON_TRANSITION: qb,
          refreshStatus: o,
          freshNode: i,
          touchStart: T,
          touchMove: y,
          touchEnd: b,
          iconName: a,
          controlStyle: h,
          isSuccess: f,
        }
      )
    },
  })
  Ih.install = function (t) {
    t.component(Ih.name, Ih)
  }
  var Kte = {
      modelValue: { type: [String, Number, Boolean, Object, Array], default: !1 },
      checkedValue: { type: [String, Number, Boolean, Object, Array], default: !0 },
      uncheckedValue: { type: [String, Number, Boolean, Object, Array], default: !1 },
      disabled: { type: Boolean, default: !1 },
      readonly: { type: Boolean, default: !1 },
      checkedColor: { type: String },
      uncheckedColor: { type: String },
      iconSize: { type: [String, Number] },
      ripple: { type: Boolean, default: !0 },
      validateTrigger: { type: Array, default: () => ['onChange'] },
      rules: { type: Array },
      onClick: { type: Function },
      onChange: { type: Function },
      'onUpdate:modelValue': { type: Function },
    },
    Xb = Symbol('RADIO_GROUP_BIND_RADIO_KEY'),
    Gb = Symbol('RADIO_GROUP_COUNT_RADIO_KEY')
  function Wte() {
    var { bindChildren: t, childProviders: e } = Sr(Xb),
      { length: r } = Ir(Gb)
    return { length: r, radios: e, bindRadios: t }
  }
  function Yte() {
    var { bindParent: t, parentProvider: e } = vr(Xb),
      { index: r } = kr(Gb)
    return { index: r, radioGroup: e, bindRadioGroup: t }
  }
  var { n: Hte, classes: qte } = Me('radio')
  function Xte(t, e) {
    var r = l.resolveComponent('var-icon'),
      i = l.resolveComponent('var-form-details'),
      n = l.resolveDirective('ripple')
    return (
      l.openBlock(),
      l.createElementBlock(
        'div',
        { class: l.normalizeClass(t.n('wrap')) },
        [
          l.createElementVNode(
            'div',
            l.mergeProps(
              {
                class: t.n(),
                onClick:
                  e[0] ||
                  (e[0] = function () {
                    return t.handleClick && t.handleClick(...arguments)
                  }),
              },
              t.$attrs
            ),
            [
              l.withDirectives(
                (l.openBlock(),
                l.createElementBlock(
                  'div',
                  {
                    class: l.normalizeClass(
                      t.classes(
                        t.n('action'),
                        [t.checked, t.n('--checked'), t.n('--unchecked')],
                        [t.errorMessage || t.radioGroupErrorMessage, t.n('--error')],
                        [t.formDisabled || t.disabled, t.n('--disabled')]
                      )
                    ),
                    style: l.normalizeStyle({ color: t.checked ? t.checkedColor : t.uncheckedColor }),
                  },
                  [
                    t.checked
                      ? l.renderSlot(t.$slots, 'checked-icon', { key: 0 }, () => [
                          l.createVNode(
                            r,
                            {
                              class: l.normalizeClass(
                                t.classes(t.n('icon'), [t.withAnimation, t.n('--with-animation')])
                              ),
                              'var-radio-cover': '',
                              name: 'radio-marked',
                              size: t.iconSize,
                            },
                            null,
                            8,
                            ['class', 'size']
                          ),
                        ])
                      : l.renderSlot(t.$slots, 'unchecked-icon', { key: 1 }, () => [
                          l.createVNode(
                            r,
                            {
                              class: l.normalizeClass(
                                t.classes(t.n('icon'), [t.withAnimation, t.n('--with-animation')])
                              ),
                              'var-radio-cover': '',
                              name: 'radio-blank',
                              size: t.iconSize,
                            },
                            null,
                            8,
                            ['class', 'size']
                          ),
                        ]),
                  ],
                  6
                )),
                [[n, { disabled: t.formReadonly || t.readonly || t.formDisabled || t.disabled || !t.ripple }]]
              ),
              l.createElementVNode(
                'div',
                {
                  class: l.normalizeClass(
                    t.classes(
                      t.n('text'),
                      [t.errorMessage || t.radioGroupErrorMessage, t.n('--error')],
                      [t.formDisabled || t.disabled, t.n('--disabled')]
                    )
                  ),
                },
                [l.renderSlot(t.$slots, 'default')],
                2
              ),
            ],
            16
          ),
          l.createVNode(i, { 'error-message': t.errorMessage }, null, 8, ['error-message']),
        ],
        2
      )
    )
  }
  var kh = l.defineComponent({
    render: Xte,
    name: 'VarRadio',
    directives: { Ripple: tr },
    components: { VarIcon: kt, VarFormDetails: lr },
    inheritAttrs: !1,
    props: Kte,
    setup(t) {
      var e = l.ref(!1),
        r = l.computed(() => e.value === t.checkedValue),
        i = l.ref(!1),
        { radioGroup: n, bindRadioGroup: s } = Yte(),
        { form: a, bindForm: o } = Or(),
        { errorMessage: u, validateWithTrigger: c, validate: p, resetValidation: h } = Nr(),
        f = (P) => {
          l.nextTick(() => {
            var { validateTrigger: x, rules: D, modelValue: N } = t
            c(x, P, D, N)
          })
        },
        d = (P) => {
          var { checkedValue: x, onChange: D } = t
          ;(n && e.value === x) ||
            ((e.value = P),
            he(t['onUpdate:modelValue'], e.value),
            he(D, e.value),
            n == null || n.onToggle(x),
            f('onChange'))
        },
        T = (P) => {
          var { disabled: x, readonly: D, uncheckedValue: N, checkedValue: I, onClick: B } = t
          ;(a != null && a.disabled.value) ||
            x ||
            (he(B, P), !((a != null && a.readonly.value) || D) && ((i.value = !0), d(r.value ? N : I)))
        },
        y = (P) => {
          var { checkedValue: x, uncheckedValue: D } = t
          e.value = P === x ? x : D
        },
        b = () => {
          he(t['onUpdate:modelValue'], t.uncheckedValue), h()
        },
        m = () => p(t.rules, t.modelValue),
        S = (P) => {
          var { uncheckedValue: x, checkedValue: D } = t,
            N = ![x, D].includes(P)
          N && (P = r.value ? x : D), d(P)
        }
      l.watch(
        () => t.modelValue,
        (P) => {
          e.value = P
        },
        { immediate: !0 }
      )
      var E = { sync: y, validate: m, resetValidation: h, reset: b }
      return (
        he(s, E),
        he(o, E),
        {
          withAnimation: i,
          checked: r,
          errorMessage: u,
          radioGroupErrorMessage: n == null ? void 0 : n.errorMessage,
          formDisabled: a == null ? void 0 : a.disabled,
          formReadonly: a == null ? void 0 : a.readonly,
          n: Hte,
          classes: qte,
          handleClick: T,
          toggle: S,
          reset: b,
          validate: m,
          resetValidation: h,
        }
      )
    },
  })
  kh.install = function (t) {
    t.component(kh.name, kh)
  }
  function Gte(t) {
    return ['horizontal', 'vertical'].includes(t)
  }
  var Jte = {
      modelValue: { type: [String, Number, Boolean, Object, Array], default: void 0 },
      direction: { type: String, default: 'horizontal', validator: Gte },
      validateTrigger: { type: Array, default: () => ['onChange'] },
      rules: { type: Array },
      onChange: { type: Function },
      'onUpdate:modelValue': { type: Function },
    },
    { n: Zte, classes: Qte } = Me('radio-group')
  function ere(t, e) {
    var r = l.resolveComponent('var-form-details')
    return (
      l.openBlock(),
      l.createElementBlock(
        'div',
        { class: l.normalizeClass(t.n('wrap')) },
        [
          l.createElementVNode(
            'div',
            { class: l.normalizeClass(t.classes(t.n(), t.n('--' + t.direction))) },
            [l.renderSlot(t.$slots, 'default')],
            2
          ),
          l.createVNode(r, { 'error-message': t.errorMessage }, null, 8, ['error-message']),
        ],
        2
      )
    )
  }
  var Nh = l.defineComponent({
    render: ere,
    name: 'VarRadioGroup',
    components: { VarFormDetails: lr },
    props: Jte,
    setup(t) {
      var { length: e, radios: r, bindRadios: i } = Wte(),
        { bindForm: n } = Or(),
        { errorMessage: s, validateWithTrigger: a, validate: o, resetValidation: u } = Nr(),
        c = l.computed(() => s.value),
        p = (b) => {
          l.nextTick(() => {
            var { validateTrigger: m, rules: S, modelValue: E } = t
            a(m, b, S, E)
          })
        },
        h = () =>
          r.forEach((b) => {
            var { sync: m } = b
            return m(t.modelValue)
          }),
        f = (b) => {
          he(t['onUpdate:modelValue'], b), he(t.onChange, b), p('onChange')
        },
        d = () => o(t.rules, t.modelValue),
        T = () => {
          he(t['onUpdate:modelValue'], void 0), u()
        }
      l.watch(() => t.modelValue, h), l.watch(() => e.value, h)
      var y = { onToggle: f, validate: d, reset: T, resetValidation: u, errorMessage: c }
      return he(n, y), i(y), { errorMessage: s, n: Zte, classes: Qte, reset: T, validate: d, resetValidation: u }
    },
  })
  Nh.install = function (t) {
    t.component(Nh.name, Nh)
  }
  var tre = {
      modelValue: { type: [String, Number], default: 0 },
      count: { type: [String, Number], default: 5 },
      color: { type: String },
      icon: { type: String, default: 'star' },
      emptyColor: { type: String },
      emptyIcon: { type: String, default: 'star-outline' },
      size: { type: [String, Number] },
      gap: { type: [String, Number] },
      namespace: { type: String },
      half: { type: Boolean, default: !1 },
      halfIcon: { type: String, default: 'star-half-full' },
      disabled: { type: Boolean, default: !1 },
      disabledColor: { type: String },
      readonly: { type: Boolean, default: !1 },
      ripple: { type: Boolean, default: !0 },
      rules: { type: Array },
      onChange: { type: Function },
      'onUpdate:modelValue': { type: Function },
    },
    { n: pa } = Me('rate'),
    rre = ['onClick']
  function ire(t, e) {
    var r = l.resolveComponent('var-icon'),
      i = l.resolveComponent('var-form-details'),
      n = l.resolveDirective('ripple')
    return (
      l.openBlock(),
      l.createElementBlock(
        'div',
        { class: l.normalizeClass(t.n('wrap')) },
        [
          l.createElementVNode(
            'div',
            { class: l.normalizeClass(t.n()) },
            [
              (l.openBlock(!0),
              l.createElementBlock(
                l.Fragment,
                null,
                l.renderList(t.toNumber(t.count), (s) =>
                  l.withDirectives(
                    (l.openBlock(),
                    l.createElementBlock(
                      'div',
                      {
                        key: s,
                        style: l.normalizeStyle(t.getStyle(s)),
                        class: l.normalizeClass(t.getClass(s)),
                        onClick: (a) => t.handleClick(s, a),
                      },
                      [
                        l.createVNode(
                          r,
                          {
                            class: l.normalizeClass(t.n('content-icon')),
                            'var-rate-cover': '',
                            transition: 0,
                            namespace: t.namespace,
                            name: t.getIconName(s),
                            style: l.normalizeStyle({ fontSize: t.toSizeUnit(t.size) }),
                          },
                          null,
                          8,
                          ['class', 'namespace', 'name', 'style']
                        ),
                      ],
                      14,
                      rre
                    )),
                    [[n, { disabled: t.formReadonly || t.readonly || t.formDisabled || t.disabled || !t.ripple }]]
                  )
                ),
                128
              )),
            ],
            2
          ),
          l.createVNode(i, { 'error-message': t.errorMessage }, null, 8, ['error-message']),
        ],
        2
      )
    )
  }
  var Oh = l.defineComponent({
    render: ire,
    name: 'VarRate',
    components: { VarIcon: kt, VarFormDetails: lr },
    directives: { Ripple: tr },
    props: tre,
    setup(t) {
      var { form: e, bindForm: r } = Or(),
        { errorMessage: i, validateWithTrigger: n, validate: s, resetValidation: a } = Nr(),
        o = (m) => {
          var { count: S, size: E, gap: P } = t
          return {
            color: p(m).color,
            marginRight: m !== Ee(S) ? xt(P) : 0,
            width: xt(E),
            height: xt(E),
            borderRadius: '50%',
          }
        },
        u = (m) => {
          var { type: S, color: E } = p(m)
          return {
            [pa('content')]: !0,
            [pa('--disabled')]: (e == null ? void 0 : e.disabled.value) || t.disabled,
            [pa('--error')]: i.value,
            [pa('--primary')]: S !== 'empty' && !E,
          }
        },
        c = (m) => {
          var { type: S } = p(m),
            { icon: E, halfIcon: P, emptyIcon: x } = t
          return S === 'full' ? E : S === 'half' ? P : x
        },
        p = (m) => {
          var { modelValue: S, disabled: E, disabledColor: P, color: x, half: D, emptyColor: N } = t,
            I
          return (
            E || (e != null && e.disabled.value) ? (I = P) : x && (I = x),
            m <= Ee(S)
              ? { type: 'full', score: m, color: I }
              : D && m <= Ee(S) + 0.5
              ? { type: 'half', score: m, color: I }
              : { type: 'empty', score: m, color: E || (e != null && e.disabled.value) ? P : N }
          )
        },
        h = (m, S) => {
          if (t.half) {
            var { offsetWidth: E } = S.target
            S.offsetX <= Math.floor(E / 2) && (m -= 0.5)
          }
          he(t['onUpdate:modelValue'], m)
        },
        f = () => s(t.rules, Ee(t.modelValue)),
        d = () => l.nextTick(() => n(['onChange'], 'onChange', t.rules, t.modelValue)),
        T = (m, S) => {
          var { readonly: E, disabled: P, onChange: x } = t
          E || P || (e != null && e.disabled.value) || (e != null && e.readonly.value) || (h(m, S), he(x, m), d())
        },
        y = () => {
          he(t['onUpdate:modelValue'], 0), a()
        },
        b = { reset: y, validate: f, resetValidation: a }
      return (
        he(r, b),
        {
          errorMessage: i,
          formDisabled: e == null ? void 0 : e.disabled,
          formReadonly: e == null ? void 0 : e.readonly,
          getStyle: o,
          getClass: u,
          getIconName: c,
          handleClick: T,
          reset: y,
          validate: f,
          resetValidation: a,
          toSizeUnit: xt,
          toNumber: Ee,
          n: pa,
        }
      )
    },
  })
  Oh.install = function (t) {
    t.component(Oh.name, Oh)
  }
  function nre(t) {
    return ['flex-start', 'flex-end', 'center', 'space-between', 'space-around'].includes(t)
  }
  function sre(t) {
    return ['flex-start', 'center', 'flex-end'].includes(t)
  }
  var are = {
      gutter: { type: [String, Number], default: 0 },
      justify: { type: String, default: 'flex-start', validator: nre },
      align: { type: String, default: 'flex-start', validator: sre },
      onClick: { type: Function },
    },
    { n: ore, classes: lre } = Me('row')
  function ure(t, e) {
    return (
      l.openBlock(),
      l.createElementBlock(
        'div',
        {
          class: l.normalizeClass(t.classes(t.n(), 'var--box')),
          style: l.normalizeStyle({
            justifyContent: t.justify,
            alignItems: t.align,
            margin: t.average ? '0 -' + t.average + 'px' : void 0,
          }),
          onClick:
            e[0] ||
            (e[0] = function () {
              return t.onClick && t.onClick(...arguments)
            }),
        },
        [l.renderSlot(t.$slots, 'default')],
        6
      )
    )
  }
  var Dh = l.defineComponent({
    render: ure,
    name: 'VarRow',
    props: are,
    setup(t) {
      var { cols: e, bindCols: r, length: i } = WJ(),
        n = l.computed(() => {
          var o = Mt(t.gutter)
          return o / 2
        }),
        s = () => {
          e.forEach((o) => {
            o.setPadding({ left: n.value, right: n.value })
          })
        },
        a = { computePadding: s }
      return l.watch(() => i.value, s), l.watch(() => t.gutter, s), r(a), { n: ore, classes: lre, average: n }
    },
  })
  Dh.install = function (t) {
    t.component(Dh.name, Dh)
  }
  function cre(t) {
    return ['left', 'right', 'center'].includes(t)
  }
  var pre = {
      modelValue: { default: void 0 },
      placeholder: { type: String },
      multiple: { type: Boolean, default: !1 },
      offsetY: { type: [String, Number], default: 0 },
      chip: { type: Boolean, default: !1 },
      line: { type: Boolean, default: !0 },
      hint: { type: Boolean, default: !0 },
      textColor: { type: String },
      focusColor: { type: String },
      blurColor: { type: String },
      disabled: { type: Boolean, default: !1 },
      readonly: { type: Boolean, default: !1 },
      clearable: { type: Boolean, default: !1 },
      separator: { type: String, default: ',' },
      textAlign: { type: String, default: 'left', validator: cre },
      validateTrigger: { type: Array, default: () => ['onChange', 'onClear', 'onClose'] },
      rules: { type: Array },
      onFocus: { type: Function },
      onBlur: { type: Function },
      onClick: { type: Function },
      onClear: { type: Function },
      onClose: { type: Function },
      onChange: { type: Function },
      'onUpdate:modelValue': { type: Function },
    },
    { n: Bh, classes: fre } = Me('select'),
    hre = { key: 0 },
    dre = { key: 1 }
  function mre(t, e) {
    var r = l.resolveComponent('var-chip'),
      i = l.resolveComponent('var-icon'),
      n = l.resolveComponent('var-menu'),
      s = l.resolveComponent('var-form-details')
    return (
      l.openBlock(),
      l.createElementBlock(
        'div',
        {
          class: l.normalizeClass(t.classes(t.n(), 'var--box', [t.formDisabled || t.disabled, t.n('--disabled')])),
          onClick:
            e[3] ||
            (e[3] = function () {
              return t.handleClick && t.handleClick(...arguments)
            }),
        },
        [
          l.createElementVNode(
            'div',
            {
              class: l.normalizeClass(
                t.classes(
                  t.n('controller'),
                  [t.isFocus, t.n('--focus')],
                  [t.errorMessage, t.n('--error')],
                  [t.formDisabled || t.disabled, t.n('--disabled')]
                )
              ),
              style: l.normalizeStyle({ color: t.errorMessage ? void 0 : t.isFocus ? t.focusColor : t.blurColor }),
            },
            [
              l.createElementVNode(
                'div',
                { class: l.normalizeClass(t.classes(t.n('icon'), [!t.hint, t.n('--non-hint')])) },
                [l.renderSlot(t.$slots, 'prepend-icon')],
                2
              ),
              l.createVNode(
                n,
                {
                  class: l.normalizeClass(t.n('menu')),
                  'var-select-cover': '',
                  'offset-y': t.offsetY,
                  show: t.isFocus,
                  'onUpdate:show': e[2] || (e[2] = (a) => (t.isFocus = a)),
                  onClose: t.handleBlur,
                },
                {
                  menu: l.withCtx(() => [
                    l.createElementVNode(
                      'div',
                      { class: l.normalizeClass(t.n('scroller')) },
                      [l.renderSlot(t.$slots, 'default')],
                      2
                    ),
                  ]),
                  default: l.withCtx(() => [
                    l.createElementVNode(
                      'div',
                      {
                        class: l.normalizeClass(t.classes(t.n('wrap'), [!t.hint, t.n('--non-hint')])),
                        ref: 'wrapEl',
                        onClick:
                          e[1] ||
                          (e[1] = function () {
                            return t.handleFocus && t.handleFocus(...arguments)
                          }),
                      },
                      [
                        l.createElementVNode(
                          'div',
                          {
                            class: l.normalizeClass(
                              t.classes(
                                t.n('select'),
                                [t.errorMessage, t.n('--error')],
                                [t.formDisabled || t.disabled, t.n('--disabled')]
                              )
                            ),
                            style: l.normalizeStyle({ textAlign: t.textAlign, color: t.textColor }),
                          },
                          [
                            t.multiple
                              ? (l.openBlock(),
                                l.createElementBlock('div', hre, [
                                  t.chip
                                    ? (l.openBlock(),
                                      l.createElementBlock(
                                        'div',
                                        { key: 0, class: l.normalizeClass(t.n('chips')) },
                                        [
                                          (l.openBlock(!0),
                                          l.createElementBlock(
                                            l.Fragment,
                                            null,
                                            l.renderList(
                                              t.labels,
                                              (a) => (
                                                l.openBlock(),
                                                l.createBlock(
                                                  r,
                                                  {
                                                    class: l.normalizeClass(t.n('chip')),
                                                    'var-select-cover': '',
                                                    closable: '',
                                                    size: 'small',
                                                    type: t.errorMessage ? 'danger' : void 0,
                                                    key: a,
                                                    onClick: e[0] || (e[0] = l.withModifiers(() => {}, ['stop'])),
                                                    onClose: () => t.handleClose(a),
                                                  },
                                                  {
                                                    default: l.withCtx(() => [
                                                      l.createTextVNode(l.toDisplayString(a), 1),
                                                    ]),
                                                    _: 2,
                                                  },
                                                  1032,
                                                  ['class', 'type', 'onClose']
                                                )
                                              )
                                            ),
                                            128
                                          )),
                                        ],
                                        2
                                      ))
                                    : (l.openBlock(),
                                      l.createElementBlock(
                                        'div',
                                        { key: 1, class: l.normalizeClass(t.n('values')) },
                                        l.toDisplayString(t.labels.join(t.separator)),
                                        3
                                      )),
                                ]))
                              : (l.openBlock(), l.createElementBlock('span', dre, l.toDisplayString(t.label), 1)),
                            l.createVNode(
                              i,
                              {
                                class: l.normalizeClass(t.classes(t.n('arrow'), [t.isFocus, t.n('--arrow-rotate')])),
                                'var-select-cover': '',
                                name: 'menu-down',
                                transition: 300,
                              },
                              null,
                              8,
                              ['class']
                            ),
                          ],
                          6
                        ),
                        l.createElementVNode(
                          'label',
                          {
                            class: l.normalizeClass(
                              t.classes(
                                t.n('placeholder'),
                                'var--ellipsis',
                                [t.isFocus, t.n('--focus')],
                                [t.errorMessage, t.n('--error')],
                                [t.formDisabled || t.disabled, t.n('--disabled')],
                                t.computePlaceholderState(),
                                [!t.hint, t.n('--placeholder-non-hint')]
                              )
                            ),
                            style: l.normalizeStyle({
                              color: t.errorMessage ? void 0 : t.isFocus ? t.focusColor : t.blurColor,
                            }),
                          },
                          l.toDisplayString(t.placeholder),
                          7
                        ),
                      ],
                      2
                    ),
                  ]),
                  _: 3,
                },
                8,
                ['class', 'offset-y', 'show', 'onClose']
              ),
              l.createElementVNode(
                'div',
                { class: l.normalizeClass(t.classes(t.n('icon'), [!t.hint, t.n('--non-hint')])) },
                [
                  l.renderSlot(t.$slots, 'append-icon', {}, () => [
                    t.clearable
                      ? (l.openBlock(),
                        l.createBlock(
                          i,
                          {
                            key: 0,
                            class: l.normalizeClass(t.n('clear-icon')),
                            name: 'close-circle',
                            size: '14px',
                            onClick: t.handleClear,
                          },
                          null,
                          8,
                          ['class', 'onClick']
                        ))
                      : l.createCommentVNode('v-if', !0),
                  ]),
                ],
                2
              ),
            ],
            6
          ),
          t.line
            ? (l.openBlock(),
              l.createElementBlock(
                'div',
                {
                  key: 0,
                  class: l.normalizeClass(
                    t.classes(
                      t.n('line'),
                      [t.formDisabled || t.disabled, t.n('--line-disabled')],
                      [t.errorMessage, t.n('--line-error')]
                    )
                  ),
                  style: l.normalizeStyle({ background: t.errorMessage ? void 0 : t.blurColor }),
                },
                [
                  l.createElementVNode(
                    'div',
                    {
                      class: l.normalizeClass(
                        t.classes(
                          t.n('dot'),
                          [t.isFocus, t.n('--spread')],
                          [t.formDisabled || t.disabled, t.n('--line-disabled')],
                          [t.errorMessage, t.n('--line-error')]
                        )
                      ),
                      style: l.normalizeStyle({ background: t.errorMessage ? void 0 : t.focusColor }),
                    },
                    null,
                    6
                  ),
                ],
                6
              ))
            : l.createCommentVNode('v-if', !0),
          l.createVNode(s, { 'error-message': t.errorMessage }, null, 8, ['error-message']),
        ],
        2
      )
    )
  }
  var Lh = l.defineComponent({
    render: mre,
    name: 'VarSelect',
    components: { VarIcon: kt, VarMenu: la, VarChip: Nl, VarFormDetails: lr },
    props: pre,
    setup(t) {
      var e = l.ref(null),
        r = l.ref(!1),
        i = l.computed(() => t.multiple),
        n = l.computed(() => t.focusColor),
        s = l.ref(''),
        a = l.ref([]),
        o = l.ref('0px'),
        u = l.ref(0),
        { bindForm: c, form: p } = Or(),
        { length: h, options: f, bindOptions: d } = hte(),
        { errorMessage: T, validateWithTrigger: y, validate: b, resetValidation: m } = Nr(),
        S = () => {
          var { multiple: U, modelValue: W } = t
          if (U) {
            var ge = W
            a.value = ge.map(x)
          }
          !U && !ki(W) && (s.value = x(W)), !U && ki(W) && (s.value = '')
        },
        E = (U) => {
          l.nextTick(() => {
            var { validateTrigger: W, rules: ge, modelValue: ye } = t
            y(W, U, ge, ye)
          })
        },
        P = (U) => {
          var { value: W, label: ge } = U
          return W.value != null ? W.value : ge.value
        },
        x = (U) => {
          var W,
            ge,
            ye = f.find((me) => {
              var { value: ke } = me
              return ke.value === U
            })
          return (
            ye ||
              (ye = f.find((me) => {
                var { label: ke } = me
                return ke.value === U
              })),
            (W = (ge = ye) == null ? void 0 : ge.label.value) != null ? W : ''
          )
        },
        D = () => {
          var { hint: U, modelValue: W } = t
          if (!U && !ki(W)) return Bh('--placeholder-hidden')
          if (U && (!ki(W) || r.value)) return Bh('--placeholder-hint')
        },
        N = () => (e.value && window.getComputedStyle(e.value).width) || '0px',
        I = () => {
          var U = (e.value && window.getComputedStyle(e.value).paddingTop) || '0px'
          return Mt(U) * 1.5
        },
        B = () => {
          var { disabled: U, readonly: W, onFocus: ge } = t
          ;(p != null && p.disabled.value) ||
            (p != null && p.readonly.value) ||
            U ||
            W ||
            ((o.value = N()), (u.value = I() + Mt(t.offsetY)), (r.value = !0), he(ge), E('onFocus'))
        },
        K = () => {
          var { disabled: U, readonly: W, onBlur: ge } = t
          ;(p != null && p.disabled.value) || (p != null && p.readonly.value) || U || W || (he(ge), E('onBlur'))
        },
        Y = (U) => {
          var { disabled: W, readonly: ge, multiple: ye, onChange: me } = t
          if (!((p != null && p.disabled.value) || (p != null && p.readonly.value) || W || ge)) {
            var ke = ye
              ? f
                  .filter((ae) => {
                    var { selected: de } = ae
                    return de.value
                  })
                  .map(P)
              : P(U)
            he(t['onUpdate:modelValue'], ke), he(me, ke), E('onChange'), !ye && (r.value = !1)
          }
        },
        C = () => {
          var { disabled: U, readonly: W, multiple: ge, clearable: ye, onClear: me } = t
          if (!((p != null && p.disabled.value) || (p != null && p.readonly.value) || U || W || !ye)) {
            var ke = ge ? [] : void 0
            he(t['onUpdate:modelValue'], ke), he(me, ke), E('onClear')
          }
        },
        H = (U) => {
          var { disabled: W, onClick: ge } = t
          ;(p != null && p.disabled.value) || W || (he(ge, U), E('onClick'))
        },
        w = (U) => {
          var { disabled: W, readonly: ge, modelValue: ye, onClose: me } = t
          if (!((p != null && p.disabled.value) || (p != null && p.readonly.value) || W || ge)) {
            var ke = ye,
              ae = f.find((be) => {
                var { label: Pe } = be
                return Pe.value === U
              }),
              de = ke.filter((be) => {
                var Pe
                return be !== ((Pe = ae.value.value) != null ? Pe : ae.label.value)
              })
            he(t['onUpdate:modelValue'], de), he(me, de), E('onClose')
          }
        },
        J = () => {
          var { multiple: U, modelValue: W } = t
          if (U) {
            var ge = W
            f.forEach((ye) => ye.sync(ge.includes(P(ye))))
          } else f.forEach((ye) => ye.sync(W === P(ye)))
          S()
        },
        X = () => {
          ;(o.value = N()), (u.value = I() + Mt(t.offsetY)), (r.value = !0)
        },
        G = () => {
          r.value = !1
        },
        Te = () => b(t.rules, t.modelValue),
        ce = () => {
          he(t['onUpdate:modelValue'], t.multiple ? [] : void 0), m()
        }
      l.watch(
        () => t.multiple,
        () => {
          var { multiple: U, modelValue: W } = t
          if (U && !At(W)) throw Error('The modelValue must be an array when multiple is true')
        }
      ),
        l.watch(() => t.modelValue, J, { deep: !0 }),
        l.watch(() => h.value, J)
      var se = {
        wrapWidth: l.computed(() => o.value),
        multiple: i,
        focusColor: n,
        onSelect: Y,
        reset: ce,
        validate: Te,
        resetValidation: m,
      }
      return (
        d(se),
        he(c, se),
        {
          wrapEl: e,
          offsetY: u,
          isFocus: r,
          errorMessage: T,
          formDisabled: p == null ? void 0 : p.disabled,
          label: s,
          labels: a,
          n: Bh,
          classes: fre,
          computePlaceholderState: D,
          handleFocus: B,
          handleBlur: K,
          handleClear: C,
          handleClick: H,
          handleClose: w,
          reset: ce,
          validate: Te,
          resetValidation: m,
          focus: X,
          blur: G,
        }
      )
    },
  })
  Lh.install = function (t) {
    t.component(Lh.name, Lh)
  }
  var yre = {
      loading: { type: Boolean, default: !0 },
      title: { type: Boolean, default: !1 },
      card: { type: Boolean, default: !1 },
      avatar: { type: Boolean, default: !1 },
      fullscreen: { type: Boolean, default: !1 },
      fullscreenZIndex: { type: [Number, String], default: 100 },
      titleWidth: { type: [Number, String] },
      cardHeight: { type: [Number, String] },
      avatarSize: { type: [Number, String] },
      rows: { type: [Number, String], default: 3 },
      rowsWidth: { type: Array, default: () => [] },
    },
    { n: gre, classes: Tre } = Me('skeleton')
  function bre(t, e) {
    return (
      l.openBlock(),
      l.createElementBlock(
        'div',
        { class: l.normalizeClass(t.classes('var--box', t.n())) },
        [
          t.loading
            ? l.createCommentVNode('v-if', !0)
            : (l.openBlock(),
              l.createElementBlock(
                'div',
                { key: 0, class: l.normalizeClass(t.n('data')) },
                [l.renderSlot(t.$slots, 'default')],
                2
              )),
          t.loading && !t.fullscreen
            ? (l.openBlock(),
              l.createElementBlock(
                'div',
                { key: 1, class: l.normalizeClass(t.n('content')) },
                [
                  t.card
                    ? (l.openBlock(),
                      l.createElementBlock(
                        'div',
                        {
                          key: 0,
                          class: l.normalizeClass(t.n('card')),
                          style: l.normalizeStyle({ height: t.toSizeUnit(t.cardHeight) }),
                        },
                        [l.createElementVNode('div', { class: l.normalizeClass(t.n('--animation')) }, null, 2)],
                        6
                      ))
                    : l.createCommentVNode('v-if', !0),
                  l.createElementVNode(
                    'div',
                    { class: l.normalizeClass(t.n('article')) },
                    [
                      t.avatar
                        ? (l.openBlock(),
                          l.createElementBlock(
                            'div',
                            {
                              key: 0,
                              class: l.normalizeClass(t.n('avatar')),
                              style: l.normalizeStyle({
                                width: t.toSizeUnit(t.avatarSize),
                                height: t.toSizeUnit(t.avatarSize),
                              }),
                            },
                            [l.createElementVNode('div', { class: l.normalizeClass(t.n('--animation')) }, null, 2)],
                            6
                          ))
                        : l.createCommentVNode('v-if', !0),
                      l.createElementVNode(
                        'div',
                        { class: l.normalizeClass(t.n('section')) },
                        [
                          t.title
                            ? (l.openBlock(),
                              l.createElementBlock(
                                'div',
                                {
                                  key: 0,
                                  class: l.normalizeClass(t.n('title')),
                                  style: l.normalizeStyle({ width: t.toSizeUnit(t.titleWidth) }),
                                },
                                [l.createElementVNode('div', { class: l.normalizeClass(t.n('--animation')) }, null, 2)],
                                6
                              ))
                            : l.createCommentVNode('v-if', !0),
                          (l.openBlock(!0),
                          l.createElementBlock(
                            l.Fragment,
                            null,
                            l.renderList(
                              t.toNumber(t.rows),
                              (r, i) => (
                                l.openBlock(),
                                l.createElementBlock(
                                  'div',
                                  {
                                    class: l.normalizeClass(t.n('row')),
                                    key: r,
                                    style: l.normalizeStyle({ width: t.toSizeUnit(t.rowsWidth[i]) }),
                                  },
                                  [
                                    l.createElementVNode(
                                      'div',
                                      { class: l.normalizeClass(t.n('--animation')) },
                                      null,
                                      2
                                    ),
                                  ],
                                  6
                                )
                              )
                            ),
                            128
                          )),
                        ],
                        2
                      ),
                    ],
                    2
                  ),
                ],
                2
              ))
            : l.createCommentVNode('v-if', !0),
          t.loading && t.fullscreen
            ? (l.openBlock(),
              l.createElementBlock(
                'div',
                {
                  key: 2,
                  class: l.normalizeClass(t.n('fullscreen')),
                  style: l.normalizeStyle({ zIndex: t.toNumber(t.fullscreenZIndex) }),
                },
                [l.createElementVNode('div', { class: l.normalizeClass(t.n('--animation')) }, null, 2)],
                6
              ))
            : l.createCommentVNode('v-if', !0),
        ],
        2
      )
    )
  }
  var Mh = l.defineComponent({
    render: bre,
    name: 'VarSkeleton',
    props: yre,
    setup() {
      return { n: gre, classes: Tre, toSizeUnit: xt, toNumber: Ee }
    },
  })
  Mh.install = function (t) {
    t.component(Mh.name, Mh)
  }
  function Sre(t) {
    return ['always', 'normal', 'never'].includes(t)
  }
  var vre = {
    modelValue: { type: [Number, Array], default: 0 },
    step: { type: [Number, String], default: 1 },
    range: { type: Boolean, default: !1 },
    labelVisible: { type: String, default: 'normal', validator: Sre },
    activeColor: { type: String },
    trackColor: { type: String },
    thumbColor: { type: String },
    labelColor: { type: String },
    labelTextColor: { type: String },
    trackHeight: { type: [String, Number] },
    thumbSize: { type: [String, Number] },
    disabled: { type: Boolean, default: !1 },
    readonly: { type: Boolean, default: !1 },
    rules: { type: Array },
    onChange: { type: Function },
    onStart: { type: Function },
    onEnd: { type: Function },
    'onUpdate:modelValue': { type: Function },
  }
  function Fh() {
    return (
      (Fh =
        Object.assign ||
        function (t) {
          for (var e = 1; e < arguments.length; e++) {
            var r = arguments[e]
            for (var i in r) Object.prototype.hasOwnProperty.call(r, i) && (t[i] = r[i])
          }
          return t
        }),
      Fh.apply(this, arguments)
    )
  }
  var { n: Ere, classes: Pre } = Me('slider'),
    Dt
  ;(function (t) {
    ;(t.First = '1'), (t.Second = '2')
  })(Dt || (Dt = {}))
  var wre = ['onTouchstart', 'onTouchmove', 'onTouchend', 'onTouchcancel']
  function Are(t, e) {
    var r = l.resolveComponent('var-form-details')
    return (
      l.openBlock(),
      l.createElementBlock(
        'div',
        { class: l.normalizeClass(t.n()) },
        [
          l.createElementVNode(
            'div',
            {
              class: l.normalizeClass(
                t.classes(t.n('block'), [t.isDisabled, t.n('--disabled')], [t.errorMessage, t.n('--error')])
              ),
              style: l.normalizeStyle({
                height: t.thumbSize === void 0 ? t.thumbSize : t.multiplySizeUnit(t.thumbSize, 3),
                margin: t.thumbSize === void 0 ? t.thumbSize : '0 ' + t.multiplySizeUnit(t.thumbSize, 0.5),
              }),
              ref: 'sliderEl',
              onClick:
                e[0] ||
                (e[0] = function () {
                  return t.click && t.click(...arguments)
                }),
            },
            [
              l.createElementVNode(
                'div',
                { class: l.normalizeClass(t.n('track')) },
                [
                  l.createElementVNode(
                    'div',
                    {
                      class: l.normalizeClass(t.n('track-background')),
                      style: l.normalizeStyle({ background: t.trackColor, height: t.multiplySizeUnit(t.trackHeight) }),
                    },
                    null,
                    6
                  ),
                  l.createElementVNode(
                    'div',
                    { class: l.normalizeClass(t.n('track-fill')), style: l.normalizeStyle(t.getFillStyle) },
                    null,
                    6
                  ),
                ],
                2
              ),
              (l.openBlock(!0),
              l.createElementBlock(
                l.Fragment,
                null,
                l.renderList(
                  t.thumbList,
                  (i) => (
                    l.openBlock(),
                    l.createElementBlock(
                      'div',
                      {
                        class: l.normalizeClass(t.n('thumb')),
                        key: i.enumValue,
                        style: l.normalizeStyle({
                          left: i.value + '%',
                          zIndex: t.thumbsProps[i.enumValue].active ? 1 : void 0,
                        }),
                        onTouchstart: (n) => t.start(n, i.enumValue),
                        onTouchmove: (n) => t.move(n, i.enumValue),
                        onTouchend: (n) => t.end(i.enumValue),
                        onTouchcancel: (n) => t.end(i.enumValue),
                      },
                      [
                        l.renderSlot(t.$slots, 'button', { currentValue: i.value }, () => [
                          l.createElementVNode(
                            'div',
                            {
                              class: l.normalizeClass(t.n('thumb-block')),
                              style: l.normalizeStyle({
                                background: t.thumbColor,
                                height: t.multiplySizeUnit(t.thumbSize),
                                width: t.multiplySizeUnit(t.thumbSize),
                              }),
                            },
                            null,
                            6
                          ),
                          l.createElementVNode(
                            'div',
                            {
                              class: l.normalizeClass(
                                t.classes(t.n('thumb-ripple'), [
                                  t.thumbsProps[i.enumValue].active,
                                  t.n('thumb-ripple--active'),
                                ])
                              ),
                              style: l.normalizeStyle(Fh({ background: t.thumbColor }, t.getRippleSize(i))),
                            },
                            null,
                            6
                          ),
                          l.createElementVNode(
                            'div',
                            {
                              class: l.normalizeClass(
                                t.classes(t.n('thumb-label'), [t.showLabel(i.enumValue), t.n('thumb-label--active')])
                              ),
                              style: l.normalizeStyle({
                                background: t.labelColor,
                                color: t.labelTextColor,
                                height: t.thumbSize === void 0 ? t.thumbSize : t.multiplySizeUnit(t.thumbSize, 2),
                                width: t.thumbSize === void 0 ? t.thumbSize : t.multiplySizeUnit(t.thumbSize, 2),
                              }),
                            },
                            [l.createElementVNode('span', null, l.toDisplayString(i.value), 1)],
                            6
                          ),
                        ]),
                      ],
                      46,
                      wre
                    )
                  )
                ),
                128
              )),
            ],
            6
          ),
          l.createVNode(
            r,
            { 'error-message': t.errorMessage, class: l.normalizeClass(t.n('form')), 'var-slider-cover': '' },
            null,
            8,
            ['error-message', 'class']
          ),
        ],
        2
      )
    )
  }
  var $h = l.defineComponent({
    render: Are,
    name: 'VarSlider',
    components: { VarFormDetails: lr },
    props: vre,
    setup(t) {
      var { bindForm: e, form: r } = Or(),
        { errorMessage: i, validateWithTrigger: n, validate: s, resetValidation: a } = Nr(),
        o = () => s(t.rules, t.modelValue),
        u = () => ({ startPosition: 0, currentLeft: 0, active: !1, percentValue: 0 }),
        c = () => l.nextTick(() => n(['onChange'], 'onChange', t.rules, t.modelValue)),
        p = l.ref(null),
        h = l.ref(0),
        f = l.ref(!1),
        d = l.reactive({ [Dt.First]: u(), [Dt.Second]: u() }),
        T = l.computed(() => (h.value / 100) * Ee(t.step)),
        y = l.computed(() => {
          var X = [{ value: t.modelValue, enumValue: Dt.First }]
          return (
            t.range &&
              At(t.modelValue) &&
              (X = [
                { value: t.modelValue[0], enumValue: Dt.First },
                { value: t.modelValue[1], enumValue: Dt.Second },
              ]),
            X
          )
        }),
        b = (X) => {
          var G
          return (
            t.thumbSize !== void 0 && (G = d[X.enumValue].active ? qt(t.thumbSize, 3) : '0px'), { height: G, width: G }
          )
        },
        m = (X) => (t.labelVisible === 'always' ? !0 : t.labelVisible === 'never' ? !1 : d[X].active),
        S = l.computed(() => {
          var { activeColor: X, range: G, modelValue: Te } = t,
            ce = G && At(Te) ? Math.abs(Te[0] - Te[1]) : Te,
            se = G && At(Te) ? Math.min(Te[0], Te[1]) : 0
          return { width: ce + '%', left: se + '%', background: X }
        }),
        E = l.computed(() => t.disabled || (r == null ? void 0 : r.disabled.value)),
        P = l.computed(() => t.readonly || (r == null ? void 0 : r.readonly.value)),
        x = (X, G) => {
          var Te = [],
            { step: ce, range: se, modelValue: U, onChange: W } = t,
            ge = Ee(ce),
            ye = Math.round(X / T.value),
            me = ye * ge,
            ke = d[G].percentValue
          if (
            ((d[G].percentValue = me / ge), se && At(U) && (Te = G === Dt.First ? [me, U[1]] : [U[0], me]), ke !== me)
          ) {
            var ae = se ? Te : me
            he(W, ae), he(t['onUpdate:modelValue'], ae), c()
          }
        },
        D = (X) => {
          if (!t.range) return Dt.First
          var G = d[Dt.First].percentValue * T.value,
            Te = d[Dt.Second].percentValue * T.value,
            ce = Math.abs(X - G),
            se = Math.abs(X - Te)
          return ce <= se ? Dt.First : Dt.Second
        },
        N = (X, G) => {
          h.value || (h.value = p.value.offsetWidth),
            !(E.value || P.value) && (he(t.onStart), (f.value = !0), (d[G].startPosition = X.touches[0].clientX))
        },
        I = (X, G) => {
          if (!(E.value || P.value || !f.value)) {
            var Te = X.touches[0].clientX - d[G].startPosition + d[G].currentLeft
            ;(d[G].active = !0), Te <= 0 ? (Te = 0) : Te >= h.value && (Te = h.value), x(Te, G)
          }
        },
        B = (X) => {
          var { range: G, modelValue: Te, onEnd: ce } = t
          if (!(E.value || P.value)) {
            var se = []
            ;(d[X].currentLeft = d[X].percentValue * T.value), (d[X].active = !1)
            var U = d[X].percentValue
            G && At(Te) && (se = X === Dt.First ? [U, Te[1]] : [Te[0], U]), he(ce, G ? se : U), (f.value = !1)
          }
        },
        K = (X) => {
          if (!(E.value || P.value) && !X.target.closest('.var-slider__thumb')) {
            var G = X.clientX - bT(X.currentTarget),
              Te = D(G)
            x(G, Te), B(Te)
          }
        },
        Y = () => {
          var X = Ee(t.step)
          return isNaN(X)
            ? (console.warn('[Varlet] Slider: type of prop "step" should be Number'), !1)
            : X < 1 || X > 100
            ? (console.warn('[Varlet] Slider: "step" should be >= 0 and <= 100'), !1)
            : parseInt('' + t.step, 10) !== X
            ? (console.warn('[Varlet] Slider: "step" should be an Integer'), !1)
            : !0
        },
        C = () => {
          var { range: X, modelValue: G } = t
          return X && !At(G)
            ? (console.error('[Varlet] Slider: "modelValue" should be an Array'), !1)
            : !X && At(G)
            ? (console.error('[Varlet] Slider: "modelValue" should be a Number'), !1)
            : X && At(G) && G.length < 2
            ? (console.error('[Varlet] Slider: "modelValue" should have two value'), !1)
            : !0
        },
        H = function (X, G) {
          X === void 0 && (X = t.modelValue),
            G === void 0 && (G = Ee(t.step)),
            t.range && At(X)
              ? ((d[Dt.First].percentValue = X[0] / G),
                (d[Dt.First].currentLeft = d[Dt.First].percentValue * T.value),
                (d[Dt.Second].percentValue = X[1] / G),
                (d[Dt.Second].currentLeft = d[Dt.Second].percentValue * T.value))
              : br(X) && (d[Dt.First].currentLeft = (X / G) * T.value)
        }
      l.watch([() => t.modelValue, () => t.step], (X) => {
        var [G, Te] = X
        !Y() || !C() || f.value || H(G, Ee(Te))
      }),
        l.watch(h, () => H()),
        l.onMounted(() => {
          !Y() || !C() || (h.value = p.value.offsetWidth)
        })
      var w = () => {
          var X = t.range ? [0, 0] : 0
          he(t['onUpdate:modelValue'], X), a()
        },
        J = { reset: w, validate: o, resetValidation: a }
      return (
        he(e, J),
        {
          n: Ere,
          classes: Pre,
          Thumbs: Dt,
          sliderEl: p,
          getFillStyle: S,
          isDisabled: E,
          errorMessage: i,
          thumbsProps: d,
          thumbList: y,
          multiplySizeUnit: qt,
          toNumber: Ee,
          getRippleSize: b,
          showLabel: m,
          start: N,
          move: I,
          end: B,
          click: K,
        }
      )
    },
  })
  $h.install = function (t) {
    t.component($h.name, $h)
  }
  function Cre(t) {
    var e = ['top', 'center', 'bottom']
    return e.includes(t)
  }
  function xre(t) {
    return jh.includes(t)
  }
  var Jb = {
      type: { type: String, validator: xre },
      position: { type: String, default: 'top', validator: Cre },
      content: { type: String },
      contentClass: { type: String },
      duration: { type: Number, default: 3e3 },
      vertical: { type: Boolean, default: !1 },
      loadingType: xr(Qs, 'type'),
      loadingSize: xr(Qs, 'size'),
      lockScroll: { type: Boolean, default: !1 },
      show: { type: Boolean, default: !1 },
      teleport: { type: String, default: 'body' },
      forbidClick: { type: Boolean, default: !1 },
      onOpen: { type: Function, default: () => {} },
      onOpened: { type: Function, default: () => {} },
      onClose: { type: Function, default: () => {} },
      onClosed: { type: Function, default: () => {} },
      'onUpdate:show': { type: Function },
      _update: { type: String },
    },
    { n: Ire, classes: kre } = Me('snackbar'),
    Nre = { success: 'checkbox-marked-circle', warning: 'warning', info: 'information', error: 'error', loading: '' }
  function Ore(t, e) {
    var r = l.resolveComponent('var-icon'),
      i = l.resolveComponent('var-loading')
    return l.withDirectives(
      (l.openBlock(),
      l.createElementBlock(
        'div',
        {
          class: l.normalizeClass(t.n()),
          style: l.normalizeStyle({ pointerEvents: t.isForbidClick ? 'auto' : 'none', zIndex: t.zIndex }),
        },
        [
          l.createElementVNode(
            'div',
            {
              class: l.normalizeClass(
                t.classes(
                  t.n('wrapper'),
                  t.n('wrapper-' + t.position),
                  'var-elevation--4',
                  [t.vertical, t.n('vertical')],
                  [t.type && t.SNACKBAR_TYPE.includes(t.type), t.n('wrapper-' + t.type)]
                )
              ),
              style: l.normalizeStyle({ zIndex: t.zIndex }),
            },
            [
              l.createElementVNode(
                'div',
                { class: l.normalizeClass([t.n('content'), t.contentClass]) },
                [l.renderSlot(t.$slots, 'default', {}, () => [l.createTextVNode(l.toDisplayString(t.content), 1)])],
                2
              ),
              l.createElementVNode(
                'div',
                { class: l.normalizeClass(t.n('action')) },
                [
                  t.iconName
                    ? (l.openBlock(), l.createBlock(r, { key: 0, name: t.iconName }, null, 8, ['name']))
                    : l.createCommentVNode('v-if', !0),
                  t.type === 'loading'
                    ? (l.openBlock(),
                      l.createBlock(i, { key: 1, type: t.loadingType, size: t.loadingSize }, null, 8, ['type', 'size']))
                    : l.createCommentVNode('v-if', !0),
                  l.renderSlot(t.$slots, 'action'),
                ],
                2
              ),
            ],
            6
          ),
        ],
        6
      )),
      [[l.vShow, t.show]]
    )
  }
  var Dre = l.defineComponent({
      render: Ore,
      name: 'VarSnackbarCore',
      components: { VarLoading: mn, VarIcon: kt },
      props: Jb,
      setup(t) {
        var e = l.ref(null),
          { zIndex: r } = wl(() => t.show, 1)
        Ef(
          () => t.show,
          () => t.lockScroll
        )
        var i = l.computed(() => t.type === 'loading' || t.forbidClick),
          n = l.computed(() => (t.type ? Nre[t.type] : '')),
          s = () => {
            e.value = setTimeout(() => {
              var a
              t.type !== 'loading' && ((a = t['onUpdate:show']) == null || a.call(t, !1))
            }, t.duration)
          }
        return (
          l.watch(
            () => t.show,
            (a) => {
              a
                ? (t.onOpen == null || t.onOpen(), s())
                : a === !1 && (clearTimeout(e.value), t.onClose == null || t.onClose())
            }
          ),
          l.watch(
            () => t._update,
            () => {
              clearTimeout(e.value), s()
            }
          ),
          l.onMounted(() => {
            t.show && (t.onOpen == null || t.onOpen(), s())
          }),
          { SNACKBAR_TYPE: jh, n: Ire, classes: kre, zIndex: r, iconName: n, isForbidClick: i }
        )
      },
    }),
    { n: Bre } = Me('snackbar')
  function Lre(t, e) {
    var r = l.resolveComponent('var-snackbar-core')
    return (
      l.openBlock(),
      l.createBlock(
        l.Teleport,
        { to: t.teleport, disabled: t.disabled },
        [
          l.createVNode(
            l.Transition,
            { name: t.n() + '-fade', onAfterEnter: t.onOpened, onAfterLeave: t.onClosed },
            {
              default: l.withCtx(() => [
                l.createVNode(
                  r,
                  l.mergeProps(t.$props, { class: t.n('transition') }),
                  {
                    action: l.withCtx(() => [l.renderSlot(t.$slots, 'action')]),
                    default: l.withCtx(() => [
                      l.renderSlot(t.$slots, 'default', {}, () => [l.createTextVNode(l.toDisplayString(t.content), 1)]),
                    ]),
                    _: 3,
                  },
                  16,
                  ['class']
                ),
              ]),
              _: 3,
            },
            8,
            ['name', 'onAfterEnter', 'onAfterLeave']
          ),
        ],
        8,
        ['to', 'disabled']
      )
    )
  }
  var Rh = l.defineComponent({
      render: Lre,
      name: 'VarSnackbar',
      components: { VarSnackbarCore: Dre },
      props: Jb,
      setup() {
        var { disabled: t } = Sf()
        return { n: Bre, disabled: t }
      },
    }),
    jh = ['loading', 'success', 'warning', 'info', 'error']
  l.reactive([]),
    jh.forEach((t) => {}),
    (Rh.install = function (t) {
      t.component(Rh.name, Rh)
    })
  var Zb = (t) => ['mini', 'small', 'normal', 'large'].includes(t),
    Mre = (t) => Zb(t) || At(t) || br(t) || Tr(t),
    Fre = (t) => ['start', 'end', 'center', 'space-around', 'space-between'].includes(t),
    $re = {
      align: { type: String },
      size: { type: [String, Number, Array], default: 'normal', validator: Mre },
      wrap: { type: Boolean, default: !0 },
      direction: { type: String, default: 'row' },
      justify: { type: String, default: 'start', validator: Fre },
      inline: { type: Boolean, default: !1 },
    },
    { n: Qb, classes: Rre } = Me('space'),
    jre = { mini: [4, 4], small: [6, 6], normal: [8, 12], large: [12, 20] },
    _h = l.defineComponent({
      name: 'VarSpace',
      props: $re,
      setup(t, e) {
        var { slots: r } = e,
          i = (n, s) => (s ? jre[n] : At(n) ? n.map(Mt) : [Mt(n), Mt(n)])
        return () => {
          var n,
            { inline: s, justify: a, align: o, wrap: u, direction: c, size: p } = t,
            h = (n = he(r.default)) != null ? n : [],
            f = Zb(p),
            [d, T] = i(p, f),
            y = (S) => {
              var E = []
              return (
                S.forEach((P) => {
                  if (P.type !== l.Comment) {
                    if (P.type === l.Fragment && At(P.children)) {
                      P.children.forEach((x) => {
                        E.push(x)
                      })
                      return
                    }
                    E.push(P)
                  }
                }),
                E
              )
            }
          h = y(h)
          var b = h.length - 1,
            m = h.map((S, E) => {
              var P = c === 'row' ? void 0 : '100%',
                x = '0'
              return (
                c === 'row' &&
                  (a === 'start' || a === 'center' || a === 'end'
                    ? E !== b
                      ? (x = d / 2 + 'px ' + T + 'px ' + d / 2 + 'px 0')
                      : (x = d / 2 + 'px 0')
                    : a === 'space-around'
                    ? (x = d / 2 + 'px ' + T / 2 + 'px')
                    : a === 'space-between' &&
                      (E === 0
                        ? (x = d / 2 + 'px ' + T / 2 + 'px ' + d / 2 + 'px 0')
                        : E === b
                        ? (x = d / 2 + 'px 0 ' + d / 2 + 'px ' + T / 2 + 'px')
                        : (x = d / 2 + 'px ' + T / 2 + 'px'))),
                c === 'column' && E !== b && (x = '0 0 ' + d + 'px 0'),
                l.createVNode('div', { style: { margin: x, width: P } }, [S])
              )
            })
          return l.createVNode(
            'div',
            {
              class: Rre(Qb(), 'var--box', [s, Qb('--inline')]),
              style: {
                flexDirection: c,
                justifyContent: a,
                alignItems: o,
                flexWrap: u ? 'wrap' : 'nowrap',
                margin: c === 'row' ? '-' + d / 2 + 'px 0' : void 0,
              },
            },
            [m]
          )
        }
      },
    })
  _h.install = function (t) {
    t.component(_h.name, _h)
  }
  var _re = {
      activeIcon: { type: String, default: 'check' },
      currentIcon: { type: String },
      inactiveIcon: { type: String },
    },
    eS = Symbol('STEPS_BIND_STEP_KEY'),
    tS = Symbol('STEPS_COUNT_STEP_KEY')
  function Vre() {
    var { bindChildren: t, childProviders: e } = Sr(eS),
      { length: r } = Ir(tS)
    return { length: r, step: e, bindStep: t }
  }
  function Ure() {
    var { parentProvider: t, bindParent: e } = vr(eS),
      { index: r } = kr(tS)
    if (!t || !e || !r) throw Error('[Varlet] Steps: <step/> must in <steps>')
    return { index: r, steps: t, bindSteps: e }
  }
  var { n: zre, classes: Kre } = Me('step'),
    Wre = { key: 3 }
  function Yre(t, e) {
    var r = l.resolveComponent('var-icon')
    return (
      l.openBlock(),
      l.createElementBlock(
        'div',
        { class: l.normalizeClass(t.n()) },
        [
          l.createElementVNode(
            'div',
            { class: l.normalizeClass(t.n(t.direction)) },
            [
              l.createElementVNode(
                'div',
                { class: l.normalizeClass(t.n(t.direction + '-main')), ref: t.getRef },
                [
                  l.createElementVNode(
                    'div',
                    {
                      class: l.normalizeClass(
                        t.classes(t.n(t.direction + '-tag'), [
                          t.isActive || t.isCurrent,
                          t.n(t.direction + '-tag--active'),
                        ])
                      ),
                      style: l.normalizeStyle({
                        backgroundColor: t.isActive || t.isCurrent ? t.activeColor : t.inactiveColor,
                      }),
                      onClick:
                        e[0] ||
                        (e[0] = function () {
                          return t.click && t.click(...arguments)
                        }),
                    },
                    [
                      t.isActive
                        ? (l.openBlock(),
                          l.createBlock(
                            r,
                            { key: 0, class: l.normalizeClass(t.n('icon')), 'var-step-cover': '', name: t.activeIcon },
                            null,
                            8,
                            ['class', 'name']
                          ))
                        : t.isCurrent && t.currentIcon
                        ? (l.openBlock(),
                          l.createBlock(
                            r,
                            { key: 1, class: l.normalizeClass(t.n('icon')), 'var-step-cover': '', name: t.currentIcon },
                            null,
                            8,
                            ['class', 'name']
                          ))
                        : t.inactiveIcon
                        ? (l.openBlock(),
                          l.createBlock(
                            r,
                            {
                              key: 2,
                              class: l.normalizeClass(t.n('icon')),
                              'var-step-cover': '',
                              name: t.inactiveIcon,
                            },
                            null,
                            8,
                            ['class', 'name']
                          ))
                        : (l.openBlock(), l.createElementBlock('span', Wre, l.toDisplayString(t.index + 1), 1)),
                    ],
                    6
                  ),
                  l.createElementVNode(
                    'div',
                    {
                      class: l.normalizeClass(
                        t.classes(t.n(t.direction + '-content'), [
                          t.isActive || t.isCurrent,
                          t.n(t.direction + '-content--active'),
                        ])
                      ),
                      onClick:
                        e[1] ||
                        (e[1] = function () {
                          return t.click && t.click(...arguments)
                        }),
                    },
                    [l.renderSlot(t.$slots, 'default')],
                    2
                  ),
                ],
                2
              ),
              t.isLastChild
                ? l.createCommentVNode('v-if', !0)
                : (l.openBlock(),
                  l.createElementBlock(
                    'div',
                    {
                      key: 0,
                      class: l.normalizeClass(t.n(t.direction + '-line')),
                      style: l.normalizeStyle({ margin: t.lineMargin }),
                    },
                    null,
                    6
                  )),
            ],
            2
          ),
        ],
        2
      )
    )
  }
  var Vh = l.defineComponent({
    render: Yre,
    name: 'VarStep',
    components: { VarIcon: kt },
    props: _re,
    setup() {
      var t = l.ref(null),
        e = l.ref(''),
        r = l.ref(!1),
        { index: i, steps: n, bindSteps: s } = Ure(),
        { active: a, length: o, activeColor: u, inactiveColor: c, direction: p, clickStep: h } = n,
        f = l.computed(() => a.value === i.value),
        d = l.computed(() => i.value !== -1 && a.value > i.value),
        T = { index: i },
        y = () => h(i.value),
        b = (m) => {
          p.value === 'horizontal' && (t.value = m)
        }
      return (
        s(T),
        l.watch(o, (m) => {
          if (((r.value = m - 1 === i.value), t.value)) {
            var S = t.value.offsetWidth / 2 - 14
            e.value = '0 -' + S + 'px'
          }
        }),
        {
          n: zre,
          classes: Kre,
          main: t,
          index: i,
          isActive: d,
          isCurrent: f,
          direction: p,
          lineMargin: e,
          activeColor: u,
          inactiveColor: c,
          isLastChild: r,
          click: y,
          getRef: b,
        }
      )
    },
  })
  Vh.install = function (t) {
    t.component(Vh.name, Vh)
  }
  function Hre(t) {
    return ['horizontal', 'vertical'].includes(t)
  }
  var qre = {
      active: { type: [String, Number], default: 0 },
      direction: { type: String, default: 'horizontal', validator: Hre },
      activeColor: { type: String },
      inactiveColor: { type: String },
      onClickStep: { type: Function },
    },
    { n: Xre } = Me('steps')
  function Gre(t, e) {
    return (
      l.openBlock(),
      l.createElementBlock(
        'div',
        {
          class: l.normalizeClass(t.n()),
          style: l.normalizeStyle({ flexDirection: t.direction === 'horizontal' ? 'row' : 'column' }),
        },
        [l.renderSlot(t.$slots, 'default')],
        6
      )
    )
  }
  var Uh = l.defineComponent({
    render: Gre,
    name: 'VarSteps',
    props: qre,
    setup(t) {
      var e = l.computed(() => t.active),
        r = l.computed(() => t.activeColor),
        i = l.computed(() => t.inactiveColor),
        n = l.computed(() => t.direction),
        { length: s, bindStep: a } = Vre(),
        o = (c) => {
          he(t.onClickStep, c)
        },
        u = { active: e, length: s, direction: n, activeColor: r, inactiveColor: i, clickStep: o }
      return a(u), { n: Xre }
    },
  })
  Uh.install = function (t) {
    t.component(Uh.name, Uh)
  }
  var { n: Jre } = Me('style-provider'),
    zh = l.defineComponent({
      name: 'VarStyleProvider',
      props: { styleVars: { type: Object, default: () => ({}) } },
      setup(t, e) {
        var { slots: r } = e
        return () => l.h('div', { class: Jre(), style: GX(t.styleVars) }, he(r.default))
      },
    })
  zh.install = function (t) {
    t.component(zh.name, zh)
  }
  var Zre = {
      modelValue: { default: !1 },
      activeValue: { default: !0 },
      inactiveValue: { default: !1 },
      disabled: { type: Boolean, default: !1 },
      readonly: { type: Boolean, default: !1 },
      loading: { type: Boolean, default: !1 },
      color: { type: String },
      loadingColor: { type: String },
      closeColor: { type: String },
      size: { type: [String, Number] },
      rules: { type: Array },
      ripple: { type: Boolean, default: !0 },
      onClick: { type: Function },
      onChange: { type: Function },
      'onUpdate:modelValue': { type: Function },
    },
    { n: Qre, classes: eie } = Me('switch')
  function tie(t, e) {
    var r = l.resolveComponent('var-loading'),
      i = l.resolveComponent('var-form-details'),
      n = l.resolveDirective('ripple')
    return (
      l.openBlock(),
      l.createElementBlock(
        'div',
        { class: l.normalizeClass(t.n()) },
        [
          l.createElementVNode(
            'div',
            {
              class: l.normalizeClass(t.classes(t.n('block'), [t.disabled || t.formDisabled, t.n('--disable')])),
              onClick:
                e[0] ||
                (e[0] = function () {
                  return t.switchActive && t.switchActive(...arguments)
                }),
              style: l.normalizeStyle(t.styleComputed.switch),
            },
            [
              l.createElementVNode(
                'div',
                {
                  style: l.normalizeStyle(t.styleComputed.track),
                  class: l.normalizeClass(
                    t.classes(
                      t.n('track'),
                      [t.modelValue === t.activeValue, t.n('track--active')],
                      [t.errorMessage, t.n('track--error')]
                    )
                  ),
                },
                null,
                6
              ),
              l.withDirectives(
                (l.openBlock(),
                l.createElementBlock(
                  'div',
                  {
                    class: l.normalizeClass(
                      t.classes(t.n('ripple'), [t.modelValue === t.activeValue, t.n('ripple--active')])
                    ),
                    style: l.normalizeStyle(t.styleComputed.ripple),
                  },
                  [
                    l.createElementVNode(
                      'div',
                      {
                        style: l.normalizeStyle(t.styleComputed.handle),
                        class: l.normalizeClass(
                          t.classes(
                            t.n('handle'),
                            'var-elevation--2',
                            [t.modelValue === t.activeValue, t.n('handle--active')],
                            [t.errorMessage, t.n('handle--error')]
                          )
                        ),
                      },
                      [
                        t.loading
                          ? (l.openBlock(), l.createBlock(r, { key: 0, radius: t.radius }, null, 8, ['radius']))
                          : l.createCommentVNode('v-if', !0),
                      ],
                      6
                    ),
                  ],
                  6
                )),
                [[n, { disabled: !t.ripple || t.disabled || t.loading || t.formDisabled }]]
              ),
            ],
            6
          ),
          l.createVNode(i, { 'error-message': t.errorMessage }, null, 8, ['error-message']),
        ],
        2
      )
    )
  }
  var Kh = l.defineComponent({
    render: tie,
    name: 'VarSwitch',
    components: { VarLoading: mn, VarFormDetails: lr },
    directives: { Ripple: tr },
    props: Zre,
    setup(t) {
      var { bindForm: e, form: r } = Or(),
        { errorMessage: i, validateWithTrigger: n, validate: s, resetValidation: a } = Nr(),
        o = () => s(t.rules, t.modelValue),
        u = () => l.nextTick(() => n(['onChange'], 'onChange', t.rules, t.modelValue)),
        c = l.computed(() => {
          var { size: T, modelValue: y, color: b, closeColor: m, loadingColor: S, activeValue: E } = t
          return {
            handle: { width: qt(T), height: qt(T), backgroundColor: y === E ? b || '' : m || '', color: S && S },
            ripple: {
              left: y === E ? qt(T, 0.5) : '-' + qt(T, 0.5),
              color: y === E ? b || '' : m || '#999',
              width: qt(T, 2),
              height: qt(T, 2),
            },
            track: {
              height: qt(T, 0.72),
              width: qt(T, 1.9),
              borderRadius: qt(T, 2 / 3),
              filter: y === E || (i != null && i.value) ? 'opacity(.6)' : 'brightness(.6)',
              backgroundColor: y === E ? b || '' : m || '',
            },
            switch: { height: qt(T, 1.2), width: qt(T, 2) },
          }
        }),
        p = l.computed(() => {
          var { size: T = '5.333vw' } = t
          return qt(T, 0.4)
        }),
        h = (T) => {
          var {
            onClick: y,
            onChange: b,
            disabled: m,
            loading: S,
            readonly: E,
            modelValue: P,
            activeValue: x,
            inactiveValue: D,
            'onUpdate:modelValue': N,
          } = t
          if ((he(y, T), !(m || S || E || (r != null && r.disabled.value) || (r != null && r.readonly.value)))) {
            var I = P === x ? D : x
            he(b, I), he(N, I), u()
          }
        },
        f = () => {
          he(t['onUpdate:modelValue'], t.inactiveValue), a()
        },
        d = { reset: f, validate: o, resetValidation: a }
      return (
        he(e, d),
        {
          n: Qre,
          classes: eie,
          switchActive: h,
          radius: p,
          styleComputed: c,
          errorMessage: i,
          formDisabled: r == null ? void 0 : r.disabled,
          formReadonly: r == null ? void 0 : r.readonly,
        }
      )
    },
  })
  Kh.install = function (t) {
    t.component(Kh.name, Kh)
  }
  var rie = { name: { type: [String, Number] }, disabled: { type: Boolean, default: !1 }, onClick: { type: Function } },
    rS = Symbol('TABS_BIND_TAB_KEY'),
    iS = Symbol('TABS_COUNT_TAB_KEY')
  function iie() {
    var { childProviders: t, bindChildren: e } = Sr(rS),
      { length: r } = Ir(iS)
    return { length: r, tabList: t, bindTabList: e }
  }
  function nie() {
    var { parentProvider: t, bindParent: e } = vr(rS),
      { index: r } = kr(iS)
    if (!t || !e || !r) throw Error('<var-tab/> must in <var-tabs/>')
    return { index: r, tabs: t, bindTabs: e }
  }
  var { n: sie, classes: aie } = Me('tab')
  function oie(t, e) {
    var r = l.resolveDirective('ripple')
    return l.withDirectives(
      (l.openBlock(),
      l.createElementBlock(
        'div',
        {
          class: l.normalizeClass(t.classes(t.n(), 'var--box', t.computeColorClass(), t.n('--' + t.itemDirection))),
          ref: 'tabEl',
          style: l.normalizeStyle({ color: t.computeColorStyle() }),
          onClick:
            e[0] ||
            (e[0] = function () {
              return t.handleClick && t.handleClick(...arguments)
            }),
        },
        [l.renderSlot(t.$slots, 'default')],
        6
      )),
      [[r, { disabled: t.disabled }]]
    )
  }
  var Wh = l.defineComponent({
    render: oie,
    name: 'VarTab',
    directives: { Ripple: tr },
    props: rie,
    setup(t) {
      var e = l.ref(null),
        r = l.computed(() => t.name),
        i = l.computed(() => t.disabled),
        n = l.computed(() => e.value),
        { index: s, tabs: a, bindTabs: o } = nie(),
        {
          onTabClick: u,
          active: c,
          activeColor: p,
          inactiveColor: h,
          disabledColor: f,
          itemDirection: d,
          resize: T,
        } = a,
        y = { name: r, index: s, disabled: i, element: n }
      o(y)
      var b = () => {
          var { disabled: E, name: P } = t
          return E ? f.value : c.value === P || c.value === (s == null ? void 0 : s.value) ? p.value : h.value
        },
        m = () => {
          var { disabled: E, name: P } = t
          return E
            ? 'var-tab--disabled'
            : c.value === P || c.value === (s == null ? void 0 : s.value)
            ? 'var-tab--active'
            : 'var-tab--inactive'
        },
        S = (E) => {
          var { disabled: P, name: x, onClick: D } = t
          P || (D == null || D(x != null ? x : s.value, E), u(y))
        }
      return (
        l.watch(() => t.name, T),
        l.watch(() => t.disabled, T),
        {
          n: sie,
          classes: aie,
          tabEl: e,
          active: c,
          activeColor: p,
          inactiveColor: h,
          itemDirection: d,
          computeColorStyle: b,
          computeColorClass: m,
          handleClick: S,
        }
      )
    },
  })
  Wh.install = function (t) {
    t.component(Wh.name, Wh)
  }
  var nS = Symbol('TABS_ITEMS_BIND_TAB_ITEM_KEY'),
    sS = Symbol('TABS_ITEMS_COUNT_TAB_ITEM_KEY')
  function lie() {
    var { bindChildren: t, childProviders: e } = Sr(nS),
      { length: r } = Ir(sS)
    return { length: r, tabItemList: e, bindTabItem: t }
  }
  function uie() {
    var { parentProvider: t, bindParent: e } = vr(nS),
      { index: r } = kr(sS)
    if (!t || !e || !r) throw Error('<var-tab-item/> must in <var-tabs-items/>')
    return { index: r, tabsItems: t, bindTabsItems: e }
  }
  var cie = { name: { type: [String, Number] } },
    { n: pie, classes: fie } = Me('tab-item')
  function hie(t, e) {
    var r = l.resolveComponent('var-swipe-item')
    return (
      l.openBlock(),
      l.createBlock(
        r,
        { class: l.normalizeClass(t.classes(t.n(), [!t.current, t.n('--inactive')])), 'var-tab-item-cover': '' },
        {
          default: l.withCtx(() => [
            t.initSlot ? l.renderSlot(t.$slots, 'default', { key: 0 }) : l.createCommentVNode('v-if', !0),
          ]),
          _: 3,
        },
        8,
        ['class']
      )
    )
  }
  var Yh = l.defineComponent({
    render: hie,
    name: 'VarTabItem',
    components: { VarSwipeItem: sa },
    props: cie,
    setup(t) {
      var e = l.ref(!1),
        r = l.ref(!1),
        i = l.computed(() => t.name),
        { index: n, bindTabsItems: s } = uie(),
        a = (u) => {
          !r.value && u && (r.value = !0), (e.value = u)
        },
        o = { index: n, name: i, setCurrent: a }
      return s(o), { n: pie, classes: fie, current: e, initSlot: r }
    },
  })
  Yh.install = function (t) {
    t.component(Yh.name, Yh)
  }
  var { n: die, classes: mie } = Me('table')
  function yie(t, e) {
    return (
      l.openBlock(),
      l.createElementBlock(
        'div',
        { class: l.normalizeClass(t.classes(t.n(), 'var-elevation--1 var--box')) },
        [
          l.createElementVNode(
            'div',
            { class: l.normalizeClass(t.n('main')) },
            [
              l.createElementVNode(
                'table',
                {
                  class: l.normalizeClass(t.n('table')),
                  style: l.normalizeStyle({ width: t.toSizeUnit(t.fullWidth) }),
                },
                [l.renderSlot(t.$slots, 'default')],
                6
              ),
            ],
            2
          ),
          t.$slots.footer
            ? (l.openBlock(),
              l.createElementBlock(
                'div',
                { key: 0, class: l.normalizeClass(t.n('footer')) },
                [l.renderSlot(t.$slots, 'footer')],
                2
              ))
            : l.createCommentVNode('v-if', !0),
        ],
        2
      )
    )
  }
  var Hh = l.defineComponent({
    render: yie,
    name: 'VarTable',
    props: { fullWidth: { type: [Number, String], default: '100%' } },
    setup() {
      return { toSizeUnit: xt, n: die, classes: mie }
    },
  })
  Hh.install = function (t) {
    t.component(Hh.name, Hh)
  }
  function aS(t) {
    return ['horizontal', 'vertical'].includes(t)
  }
  var gie = {
    active: { type: [String, Number], default: 0 },
    layoutDirection: { type: String, default: 'horizontal', validator: aS },
    itemDirection: { type: String, default: 'horizontal', validator: aS },
    fixedBottom: { type: Boolean, default: !1 },
    activeColor: { type: String },
    inactiveColor: { type: String },
    disabledColor: { type: String },
    color: { type: String },
    indicatorColor: { type: String },
    indicatorSize: { type: [String, Number] },
    elevation: { type: Boolean, default: !1 },
    sticky: { type: Boolean, default: !1 },
    safeArea: { type: Boolean, default: !1 },
    offsetTop: xr(Fb, 'offsetTop'),
    onClick: { type: Function },
    onChange: { type: Function },
    'onUpdate:active': { type: Function },
  }
  function oS(t, e, r, i, n, s, a) {
    try {
      var o = t[s](a),
        u = o.value
    } catch (c) {
      r(c)
      return
    }
    o.done ? e(u) : Promise.resolve(u).then(i, n)
  }
  function Tie(t) {
    return function () {
      var e = this,
        r = arguments
      return new Promise(function (i, n) {
        var s = t.apply(e, r)
        function a(u) {
          oS(s, i, n, a, o, 'next', u)
        }
        function o(u) {
          oS(s, i, n, a, o, 'throw', u)
        }
        a(void 0)
      })
    }
  }
  var { n: bie, classes: Sie } = Me('tabs')
  function vie(t, e) {
    return (
      l.openBlock(),
      l.createBlock(
        l.resolveDynamicComponent(t.sticky ? 'var-sticky' : t.Transition),
        { 'offset-top': t.sticky ? t.offsetTop : null },
        {
          default: l.withCtx(() => [
            l.createElementVNode(
              'div',
              l.mergeProps(
                {
                  class: t.classes(
                    t.n(),
                    'var--box',
                    t.n('--item-' + t.itemDirection),
                    t.n('--layout-' + t.layoutDirection + '-padding'),
                    [t.elevation, 'var-elevation--4'],
                    [t.fixedBottom, t.n('--fixed-bottom')],
                    [t.safeArea, t.n('--safe-area')]
                  ),
                  style: { background: t.color },
                },
                t.$attrs
              ),
              [
                l.createElementVNode(
                  'div',
                  {
                    ref: 'scrollerEl',
                    class: l.normalizeClass(
                      t.classes(
                        t.n('tab-wrap'),
                        [t.scrollable, t.n('--layout-' + t.layoutDirection + '-scrollable')],
                        t.n('--layout-' + t.layoutDirection)
                      )
                    ),
                  },
                  [
                    l.renderSlot(t.$slots, 'default'),
                    l.createElementVNode(
                      'div',
                      {
                        class: l.normalizeClass(
                          t.classes(t.n('indicator'), t.n('--layout-' + t.layoutDirection + '-indicator'))
                        ),
                        style: l.normalizeStyle({
                          width: t.layoutDirection === 'horizontal' ? t.indicatorWidth : t.toSizeUnit(t.indicatorSize),
                          height:
                            t.layoutDirection === 'horizontal' ? t.toSizeUnit(t.indicatorSize) : t.indicatorHeight,
                          transform:
                            t.layoutDirection === 'horizontal'
                              ? 'translateX(' + t.indicatorX + ')'
                              : 'translateY(' + t.indicatorY + ')',
                          background: t.indicatorColor || t.activeColor,
                        }),
                      },
                      null,
                      6
                    ),
                  ],
                  2
                ),
              ],
              16
            ),
          ]),
          _: 3,
        },
        8,
        ['offset-top']
      )
    )
  }
  var qh = l.defineComponent({
    render: vie,
    name: 'VarTabs',
    components: { VarSticky: oa },
    inheritAttrs: !1,
    props: gie,
    setup(t) {
      var e = l.ref('0px'),
        r = l.ref('0px'),
        i = l.ref('0px'),
        n = l.ref('0px'),
        s = l.ref(!1),
        a = l.ref(null),
        o = l.computed(() => t.active),
        u = l.computed(() => t.activeColor),
        c = l.computed(() => t.inactiveColor),
        p = l.computed(() => t.disabledColor),
        h = l.computed(() => t.itemDirection),
        { tabList: f, bindTabList: d, length: T } = iie(),
        y = (I) => {
          var B,
            K = (B = I.name.value) != null ? B : I.index.value,
            { active: Y, onChange: C, onClick: H } = t
          he(t['onUpdate:active'], K), he(H, K), K !== Y && he(C, K)
        },
        b = () =>
          f.find((I) => {
            var { name: B } = I
            return t.active === B.value
          }),
        m = (I) =>
          f.find((B) => {
            var { index: K } = B
            return (I != null ? I : t.active) === K.value
          }),
        S = () => {
          if (T.value !== 0) {
            var { active: I } = t
            if (br(I)) {
              var B = I > T.value - 1 ? T.value - 1 : 0
              return he(t['onUpdate:active'], B), m(B)
            }
          }
        },
        E = () => {
          s.value = f.length >= 5
        },
        P = (I) => {
          var { element: B } = I,
            K = B.value
          t.layoutDirection === 'horizontal'
            ? ((e.value = (K == null ? void 0 : K.offsetWidth) + 'px'),
              (i.value = (K == null ? void 0 : K.offsetLeft) + 'px'))
            : ((r.value = (K == null ? void 0 : K.offsetHeight) + 'px'),
              (n.value = (K == null ? void 0 : K.offsetTop) + 'px'))
        },
        x = (I) => {
          var { element: B } = I
          if (!!s.value) {
            var K = a.value,
              Y = B.value
            if (t.layoutDirection === 'horizontal') {
              var C = Y.offsetLeft + Y.offsetWidth / 2 - K.offsetWidth / 2
              bl(K, { left: C, animation: dT })
            } else {
              var H = Y.offsetTop + Y.offsetHeight / 2 - K.offsetHeight / 2
              bl(K, { top: H, animation: dT })
            }
          }
        },
        D = () => {
          var I = b() || m() || S()
          !I || I.disabled.value || (E(), P(I), x(I))
        },
        N = {
          active: o,
          activeColor: u,
          inactiveColor: c,
          disabledColor: p,
          itemDirection: h,
          resize: D,
          onTabClick: y,
        }
      return (
        d(N),
        l.watch(
          () => T.value,
          Tie(function* () {
            yield dn(), D()
          })
        ),
        l.watch(() => t.active, D),
        l.onMounted(() => window.addEventListener('resize', D)),
        l.onUnmounted(() => window.removeEventListener('resize', D)),
        {
          indicatorWidth: e,
          indicatorHeight: r,
          indicatorX: i,
          indicatorY: n,
          scrollable: s,
          scrollerEl: a,
          Transition: l.Transition,
          toSizeUnit: xt,
          n: bie,
          classes: Sie,
          resize: D,
        }
      )
    },
  })
  qh.install = function (t) {
    t.component(qh.name, qh)
  }
  var Eie = {
      active: { type: [String, Number], default: 0 },
      canSwipe: { type: Boolean, default: !0 },
      loop: { type: Boolean, default: !1 },
      'onUpdate:active': { type: Function },
    },
    { n: Pie } = Me('tabs-items')
  function wie(t, e) {
    var r = l.resolveComponent('var-swipe')
    return (
      l.openBlock(),
      l.createBlock(
        r,
        {
          class: l.normalizeClass(t.n()),
          ref: 'swipe',
          loop: t.loop,
          touchable: t.canSwipe,
          indicator: !1,
          onChange: t.handleSwipeChange,
        },
        { default: l.withCtx(() => [l.renderSlot(t.$slots, 'default')]), _: 3 },
        8,
        ['class', 'loop', 'touchable', 'onChange']
      )
    )
  }
  var Xh = l.defineComponent({
    render: wie,
    name: 'VarTabsItems',
    components: { VarSwipe: na },
    props: Eie,
    setup(t) {
      var e = l.ref(null),
        { tabItemList: r, bindTabItem: i, length: n } = lie(),
        s = (h) =>
          r.find((f) => {
            var { name: d } = f
            return h === d.value
          }),
        a = (h) =>
          r.find((f) => {
            var { index: d } = f
            return h === d.value
          }),
        o = (h) => s(h) || a(h),
        u = (h) => {
          var f,
            d = o(h)
          !d ||
            (r.forEach((T) => {
              var { setCurrent: y } = T
              return y(!1)
            }),
            d.setCurrent(!0),
            (f = e.value) == null || f.to(d.index.value))
        },
        c = (h) => {
          var f,
            d = r.find((y) => {
              var { index: b } = y
              return b.value === h
            }),
            T = (f = d.name.value) != null ? f : d.index.value
          he(t['onUpdate:active'], T)
        },
        p = {}
      return (
        i(p),
        l.watch(() => t.active, u),
        l.watch(
          () => n.value,
          () => u(t.active)
        ),
        { swipe: e, n: Pie, handleSwipeChange: c }
      )
    },
  })
  Xh.install = function (t) {
    t.component(Xh.name, Xh)
  }
  var Pr = ['12', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11'],
    rr = ['00', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23'],
    lS = ['00', '05', '10', '15', '20', '25', '30', '35', '40', '45', '50', '55']
  function Aie(t) {
    return ['ampm', '24hr'].includes(t)
  }
  var Cie = {
      modelValue: { type: String },
      shadow: { type: Boolean, default: !1 },
      color: { type: String },
      headerColor: { type: String },
      format: { type: String, default: 'ampm', validator: Aie },
      allowedTime: { type: Object },
      min: { type: String },
      max: { type: String },
      useSeconds: { type: Boolean, default: !1 },
      readonly: { type: Boolean, default: !1 },
      'onUpdate:modelValue': { type: Function },
      onChange: { type: Function },
    },
    uS = (t, e) => t === '24hr' || e === 'am',
    Gh = (t, e, r) => {
      var i = Pr.findIndex((s) => Ee(s) === Ee(r)),
        n = uS(t, e) ? r : rr[i]
      return { hourStr: n, hourNum: Ee(n) }
    },
    cr = (t) => {
      var [e, r, i] = t.split(':')
      return { hour: Ee(e), minute: Ee(r), second: Ee(i) }
    },
    cS = (t) => {
      var e,
        r,
        { time: i, format: n, ampm: s, hour: a, max: o, min: u, disableHour: c } = t,
        { hourStr: p, hourNum: h } = Gh(n, s, a),
        f = !1,
        d = !1
      if (c.includes(p)) return !0
      if (o && !u) {
        var { hour: T, minute: y } = cr(o)
        f = T === h && i > y
      }
      if (!o && u) {
        var { hour: b, minute: m } = cr(u)
        f = b === h && i < m
      }
      if (o && u) {
        var { hour: S, minute: E } = cr(o),
          { hour: P, minute: x } = cr(u)
        f = (P === h && i < x) || (S === h && i > E)
      }
      return (
        (e = t.allowedTime) != null && e.minutes && (d = (r = t.allowedTime) == null ? void 0 : r.minutes(i)), f || d
      )
    },
    pS = (t) => {
      var e,
        r,
        { time: i, format: n, ampm: s, hour: a, minute: o, max: u, min: c, disableHour: p } = t,
        { hourStr: h, hourNum: f } = Gh(n, s, a),
        d = !1,
        T = !1
      if (p.includes(h)) return !0
      if (u && !c) {
        var { hour: y, minute: b, second: m } = cr(u)
        d = (y === f && b < o) || (b === o && i > m)
      }
      if (!u && c) {
        var { hour: S, minute: E, second: P } = cr(c)
        d = (S === f && E > o) || (E === o && i > P)
      }
      if (u && c) {
        var { hour: x, minute: D, second: N } = cr(u),
          { hour: I, minute: B, second: K } = cr(c)
        d = (x === f && D < o) || (I === f && B > o) || (x === f && D === o && i > N) || (I === f && B === o && i < K)
      }
      return (
        (e = t.allowedTime) != null && e.seconds && (T = (r = t.allowedTime) == null ? void 0 : r.seconds(i)), d || T
      )
    },
    { n: xie, classes: Iie } = Me('time-picker')
  function kie(t, e) {
    return (
      l.openBlock(),
      l.createElementBlock(
        'div',
        { class: l.normalizeClass(t.n('clock')) },
        [
          l.createElementVNode(
            'div',
            { class: l.normalizeClass(t.n('clock-hand')), style: l.normalizeStyle(t.handStyle) },
            null,
            6
          ),
          (l.openBlock(!0),
          l.createElementBlock(
            l.Fragment,
            null,
            l.renderList(
              t.timeScales,
              (r, i) => (
                l.openBlock(),
                l.createElementBlock(
                  'div',
                  {
                    class: l.normalizeClass(
                      t.classes(
                        t.n('clock-item'),
                        [t.isActive(i, !1), t.n('clock-item--active')],
                        [t.isDisable(r), t.n('clock-item--disable')]
                      )
                    ),
                    key: r,
                    style: l.normalizeStyle(t.getStyle(i, r, !1)),
                  },
                  l.toDisplayString(r),
                  7
                )
              )
            ),
            128
          )),
          t.format === '24hr' && t.type === 'hour'
            ? (l.openBlock(),
              l.createElementBlock(
                'div',
                { key: 0, class: l.normalizeClass(t.n('clock-inner')), ref: 'inner' },
                [
                  (l.openBlock(!0),
                  l.createElementBlock(
                    l.Fragment,
                    null,
                    l.renderList(
                      t.hours24,
                      (r, i) => (
                        l.openBlock(),
                        l.createElementBlock(
                          'div',
                          {
                            class: l.normalizeClass(
                              t.classes(
                                t.n('clock-item'),
                                [t.isActive(i, !0), t.n('clock-item--active')],
                                [t.isDisable(r), t.n('clock-item--disable')]
                              )
                            ),
                            key: r,
                            style: l.normalizeStyle(t.getStyle(i, r, !0)),
                          },
                          l.toDisplayString(r),
                          7
                        )
                      )
                    ),
                    128
                  )),
                ],
                2
              ))
            : l.createCommentVNode('v-if', !0),
        ],
        2
      )
    )
  }
  var Nie = l.defineComponent({
      render: kie,
      name: 'Clock',
      props: {
        isInner: { type: Boolean, required: !0 },
        rad: { type: Number },
        format: { type: String, default: 'ampm' },
        allowedTime: { type: Object },
        time: { type: Object, required: !0 },
        useSeconds: { type: Boolean, default: !1 },
        preventNextUpdate: { type: Boolean, default: !1 },
        type: { type: String, default: 'hour' },
        ampm: { type: String, default: 'am' },
        color: { type: String },
        min: { type: String },
        max: { type: String },
      },
      emits: ['update', 'change-prevent-update'],
      setup(t, e) {
        var { emit: r } = e,
          i = l.ref(null),
          n = l.ref([]),
          s = l.ref([]),
          a = l.computed(() => ({
            transform: 'rotate(' + Ee(t.rad) + 'deg)',
            height: t.isInner && t.type === 'hour' ? 'calc(50% - 40px)' : 'calc(50% - 4px)',
            backgroundColor: p(),
            borderColor: p(),
          })),
          o = l.computed(() => {
            if (t.rad !== void 0) {
              var b = t.rad / 30
              return b >= 0 ? b : b + 12
            }
          }),
          u = l.computed(() => (t.type === 'hour' ? Pr : lS)),
          c = (b, m) => {
            var S
            b = (S = b) != null ? S : t.type === 'minute' ? t.time.minute : t.time.second
            var E = t.type === 'minute' ? cS : pS,
              P = {
                time: Ee(b),
                format: t.format,
                ampm: t.ampm,
                hour: t.time.hour,
                minute: Ee(t.time.minute),
                max: t.max,
                min: t.min,
                allowedTime: t.allowedTime,
                disableHour: n.value,
              }
            return m && t.type === 'minute' && Reflect.deleteProperty(P, 'minute'), E(P)
          },
          p = () => {
            if (o.value === void 0) return t.color
            var b = t.isInner ? rr[o.value] : u.value[o.value]
            return u.value === lS ? (c() ? '#bdbdbd' : t.color) : f(b) ? '#bdbdbd' : t.color
          },
          h = (b, m) => (m ? o.value === b && t.isInner : o.value === b && (!t.isInner || t.type !== 'hour')),
          f = (b) => {
            if (t.type === 'hour') {
              if (uS(t.format, t.ampm)) return n.value.includes(b)
              var m = Pr.findIndex((S) => S === b)
              return s.value.includes(m)
            }
            return c(b, !0)
          },
          d = (b, m, S) => {
            var E = ((2 * Math.PI) / 12) * b - Math.PI / 2,
              P = 50 * (1 + Math.cos(E)),
              x = 50 * (1 + Math.sin(E)),
              D = () =>
                h(b, S)
                  ? f(m)
                    ? { backgroundColor: '#bdbdbd', color: '#fff' }
                    : { backgroundColor: t.color, color: void 0 }
                  : { backgroundColor: void 0, color: void 0 },
              { backgroundColor: N, color: I } = D()
            return { left: P + '%', top: x + '%', backgroundColor: N, color: I }
          },
          T = () => {
            var { width: b, height: m } = i.value.getBoundingClientRect()
            return { width: b, height: m }
          },
          y = () => {
            if (o.value !== void 0) {
              var b = t.ampm === 'am' ? Pr : rr
              return b[o.value].padStart(2, '0')
            }
          }
        return (
          l.watch([o, () => t.isInner], (b, m) => {
            var [S, E] = b,
              [P, x] = m,
              D = S === P && E === x
            if (!(D || t.type !== 'hour' || o.value === void 0)) {
              var N = E ? rr[o.value] : y(),
                I = t.useSeconds ? ':' + t.time.second : '',
                B = N + ':' + t.time.minute + I
              t.preventNextUpdate || r('update', B), r('change-prevent-update')
            }
          }),
          l.watch(
            () => t.rad,
            (b, m) => {
              if (!(t.type === 'hour' || b === void 0 || m === void 0)) {
                var S = b / 6 >= 0 ? b / 6 : b / 6 + 60,
                  E = m / 6 >= 0 ? m / 6 : m / 6 + 60
                if (S !== E) {
                  var P,
                    { hourStr: x } = Gh(t.format, t.ampm, t.time.hour)
                  if (t.type === 'minute') {
                    var D = Fe().minute(S).format('mm'),
                      N = t.useSeconds ? ':' + t.time.second : ''
                    P = x + ':' + D + N
                  }
                  if (t.type === 'second') {
                    var I = Fe().second(S).format('ss'),
                      B = t.useSeconds ? ':' + I : ''
                    P = x + ':' + t.time.minute + B
                  }
                  r('update', P)
                }
              }
            }
          ),
          l.watch(
            [() => t.max, () => t.min, () => t.allowedTime],
            (b) => {
              var [m, S, E] = b
              if (((n.value = []), m && !S)) {
                var { hour: P } = cr(m),
                  x = Pr.filter((G) => Ee(G) > P),
                  D = rr.filter((G) => Ee(G) > P)
                n.value = [...x, ...D]
              }
              if (!m && S) {
                var { hour: N } = cr(S),
                  I = Pr.filter((G) => Ee(G) < N),
                  B = rr.filter((G) => Ee(G) < N)
                n.value = [...I, ...B]
              }
              if (m && S) {
                var { hour: K } = cr(m),
                  { hour: Y } = cr(S),
                  C = Pr.filter((G) => Ee(G) < Y || Ee(G) > K),
                  H = rr.filter((G) => Ee(G) < Y || Ee(G) > K)
                n.value = [...C, ...H]
              }
              if (E != null && E.hours) {
                var { hours: w } = E,
                  J = Pr.filter((G) => !w(Ee(G))),
                  X = rr.filter((G) => !w(Ee(G)))
                n.value = [...new Set([...n.value, ...J, ...X])]
              }
              s.value = n.value.map((G) => rr.findIndex((Te) => G === Te)).filter((G) => G >= 0)
            },
            { immediate: !0 }
          ),
          {
            n: xie,
            classes: Iie,
            hours24: rr,
            timeScales: u,
            inner: i,
            handStyle: a,
            disableHour: n,
            isActive: h,
            isDisable: f,
            getSize: T,
            getStyle: d,
            activeItemIndex: o,
          }
        )
      },
    }),
    { n: Oie, classes: Die } = Me('time-picker'),
    Bie = (t) => (l.pushScopeId(''), (t = t()), l.popScopeId(), t),
    Lie = Bie(() => l.createElementVNode('span', null, ':', -1)),
    Mie = { key: 0 }
  function Fie(t, e) {
    var r = l.resolveComponent('clock')
    return (
      l.openBlock(),
      l.createElementBlock(
        'div',
        { class: l.normalizeClass(t.classes(t.n(), [t.shadow, 'var-elevation--2'])), ref: 'picker' },
        [
          l.createElementVNode(
            'div',
            {
              class: l.normalizeClass(t.n('title')),
              style: l.normalizeStyle({ background: t.headerColor || t.color }),
            },
            [
              l.createElementVNode(
                'div',
                { class: l.normalizeClass(t.n('title-time')) },
                [
                  l.createElementVNode(
                    'div',
                    {
                      class: l.normalizeClass(
                        t.classes(t.n('title-btn'), [t.type === 'hour', t.n('title-btn--active')])
                      ),
                      onClick: e[0] || (e[0] = (i) => t.checkPanel('hour')),
                    },
                    l.toDisplayString(t.time.hour),
                    3
                  ),
                  Lie,
                  l.createElementVNode(
                    'div',
                    {
                      class: l.normalizeClass(
                        t.classes(t.n('title-btn'), [t.type === 'minute', t.n('title-btn--active')])
                      ),
                      onClick: e[1] || (e[1] = (i) => t.checkPanel('minute')),
                    },
                    l.toDisplayString(t.time.minute),
                    3
                  ),
                  t.useSeconds
                    ? (l.openBlock(), l.createElementBlock('span', Mie, ':'))
                    : l.createCommentVNode('v-if', !0),
                  t.useSeconds
                    ? (l.openBlock(),
                      l.createElementBlock(
                        'div',
                        {
                          key: 1,
                          class: l.normalizeClass(
                            t.classes(t.n('title-btn'), [t.type === 'second', t.n('title-btn--active')])
                          ),
                          onClick: e[2] || (e[2] = (i) => t.checkPanel('second')),
                        },
                        l.toDisplayString(t.time.second),
                        3
                      ))
                    : l.createCommentVNode('v-if', !0),
                ],
                2
              ),
              t.format === 'ampm'
                ? (l.openBlock(),
                  l.createElementBlock(
                    'div',
                    { key: 0, class: l.normalizeClass(t.n('title-ampm')) },
                    [
                      l.createElementVNode(
                        'div',
                        {
                          class: l.normalizeClass(
                            t.classes(t.n('title-btn'), [t.ampm === 'am', t.n('title-btn--active')])
                          ),
                          onClick: e[3] || (e[3] = (i) => t.checkAmpm('am')),
                        },
                        'AM',
                        2
                      ),
                      l.createElementVNode(
                        'div',
                        {
                          class: l.normalizeClass(
                            t.classes(t.n('title-btn'), [t.ampm === 'pm', t.n('title-btn--active')])
                          ),
                          onClick: e[4] || (e[4] = (i) => t.checkAmpm('pm')),
                        },
                        'PM',
                        2
                      ),
                    ],
                    2
                  ))
                : l.createCommentVNode('v-if', !0),
            ],
            6
          ),
          l.createElementVNode(
            'div',
            { class: l.normalizeClass(t.n('body')) },
            [
              l.createElementVNode(
                'div',
                {
                  class: l.normalizeClass(t.n('clock-container')),
                  onTouchstart:
                    e[5] ||
                    (e[5] = function () {
                      return t.moveHand && t.moveHand(...arguments)
                    }),
                  onTouchmove:
                    e[6] ||
                    (e[6] = function () {
                      return t.moveHand && t.moveHand(...arguments)
                    }),
                  onTouchend:
                    e[7] ||
                    (e[7] = function () {
                      return t.end && t.end(...arguments)
                    }),
                  ref: 'container',
                },
                [
                  l.createVNode(
                    l.Transition,
                    { name: t.n() + '-panel-fade' },
                    {
                      default: l.withCtx(() => [
                        (l.openBlock(),
                        l.createBlock(
                          r,
                          {
                            key: t.type,
                            ref: 'inner',
                            type: t.type,
                            ampm: t.ampm,
                            color: t.color,
                            'is-inner': t.isInner,
                            format: t.format,
                            'allowed-time': t.allowedTime,
                            rad: t.getRad,
                            time: t.time,
                            'prevent-next-update': t.isPreventNextUpdate,
                            'use-seconds': t.useSeconds,
                            max: t.max,
                            min: t.min,
                            onUpdate: t.update,
                            onChangePreventUpdate: t.changePreventUpdate,
                          },
                          null,
                          8,
                          [
                            'type',
                            'ampm',
                            'color',
                            'is-inner',
                            'format',
                            'allowed-time',
                            'rad',
                            'time',
                            'prevent-next-update',
                            'use-seconds',
                            'max',
                            'min',
                            'onUpdate',
                            'onChangePreventUpdate',
                          ]
                        )),
                      ]),
                      _: 1,
                    },
                    8,
                    ['name']
                  ),
                ],
                34
              ),
            ],
            2
          ),
        ],
        2
      )
    )
  }
  var Jh = l.defineComponent({
    render: Fie,
    name: 'VarTimePicker',
    components: { Clock: Nie },
    props: Cie,
    setup(t) {
      var e = l.ref(null),
        r = l.ref(null),
        i = l.ref(null),
        n = l.ref(!1),
        s = l.ref(!1),
        a = l.ref(!1),
        o = l.ref(!1),
        u = l.ref(!1),
        c = l.ref(void 0),
        p = l.ref(0),
        h = l.ref(0),
        f = l.ref('hour'),
        d = l.ref('am'),
        T = l.ref(!1),
        y = l.ref(!1),
        b = l.ref({ hour: '00', minute: '00', second: '00' }),
        m = l.reactive({ x: 0, y: 0 }),
        S = l.reactive({ x: [], y: [] }),
        E = l.computed(() => (f.value === 'hour' ? c.value : f.value === 'minute' ? p.value : h.value)),
        P = (se) => {
          he(t['onUpdate:modelValue'], se), he(t.onChange, se)
        },
        x = (se) => se * 57.29577951308232,
        D = (se) => {
          ;(o.value = !1), (y.value = !1), (f.value = se)
        },
        N = (se) => {
          var { disableHour: U } = i.value,
            W = Pr.findIndex((me) => Ee(me) === Ee(b.value.hour)),
            ge = se === 'am' ? Pr : rr,
            ye = [...ge.slice(W), ...ge.slice(0, W)]
          return ye.find((me, ke) => ((s.value = ke !== 0), !U.includes(me)))
        },
        I = (se) => {
          if (!t.readonly) {
            d.value = se
            var U = N(se)
            if (!!U) {
              var W = t.useSeconds ? ':' + b.value.second : '',
                ge = U.padStart(2, '0') + ':' + b.value.minute + W
              P(ge)
            }
          }
        },
        B = (se, U) => {
          var W = se >= S.x[0] && se <= S.x[1],
            ge = U >= S.y[0] && U <= S.y[1]
          return W && ge
        },
        K = (se) => {
          var U = t.format === '24hr' ? 'HH' : 'hh',
            { hour: W, minute: ge, second: ye } = cr(se)
          return {
            hour: Fe().hour(W).format(U),
            minute: Fe().minute(ge).format('mm'),
            second: Fe().second(ye).format('ss'),
          }
        },
        Y = (se) => {
          var U = se / 30
          return U >= 0 ? U : U + 12
        },
        C = () => {
          var { width: se, height: U } = i.value.getSize(),
            W = m.x - se / 2 - 8,
            ge = m.x + se / 2 + 8,
            ye = m.y - U / 2 - 8,
            me = m.y + U / 2 + 8
          return { rangeXMin: W, rangeXMax: ge, rangeYMin: ye, rangeYMax: me }
        },
        H = (se, U, W) => {
          var { disableHour: ge } = i.value
          a.value = B(se, U)
          var ye = Math.round(W / 30) * 30 + 90,
            me = Y(ye),
            ke = n.value ? Pr[me] : rr[me]
          if ((ge.includes(ke) || (n.value = t.format === '24hr' ? B(se, U) : !1), n.value === a.value)) {
            var ae = n.value || d.value === 'pm' ? rr[me] : Pr[me]
            ;(T.value = ge.includes(ae)), !T.value && ((c.value = ye), (o.value = !0))
          }
        },
        w = (se) => {
          var { disableHour: U } = i.value,
            W = Math.round(se / 6) * 6 + 90,
            ge = W / 6 >= 0 ? W / 6 : W / 6 + 60,
            ye = {
              time: ge,
              format: t.format,
              ampm: d.value,
              hour: b.value.hour,
              max: t.max,
              min: t.min,
              disableHour: U,
              allowedTime: t.allowedTime,
            }
          ;(y.value = cS(ye)), !y.value && ((p.value = W), (u.value = !0))
        },
        J = (se) => {
          var { disableHour: U } = i.value,
            W = Math.round(se / 6) * 6 + 90,
            ge = W / 6 >= 0 ? W / 6 : W / 6 + 60,
            ye = {
              time: ge,
              format: t.format,
              ampm: d.value,
              hour: b.value.hour,
              minute: Ee(b.value.minute),
              max: t.max,
              min: t.min,
              disableHour: U,
              allowedTime: t.allowedTime,
            }
          pS(ye) || (h.value = W)
        },
        X = () => {
          var { left: se, top: U, width: W, height: ge } = e.value.getBoundingClientRect()
          if (((m.x = se + W / 2), (m.y = U + ge / 2), f.value === 'hour' && t.format === '24hr')) {
            var { rangeXMin: ye, rangeXMax: me, rangeYMin: ke, rangeYMax: ae } = C()
            ;(S.x = [ye, me]), (S.y = [ke, ae])
          }
        },
        G = (se) => {
          if ((se.preventDefault(), !t.readonly)) {
            X()
            var { clientX: U, clientY: W } = se.touches[0],
              ge = U - m.x,
              ye = W - m.y,
              me = Math.round(x(Math.atan2(ye, ge)))
            f.value === 'hour' ? H(U, W, me) : f.value === 'minute' ? w(me) : J(me)
          }
        },
        Te = () => {
          if (!t.readonly) {
            if (f.value === 'hour' && o.value) {
              f.value = 'minute'
              return
            }
            f.value === 'minute' && t.useSeconds && u.value && (f.value = 'second')
          }
        },
        ce = () => {
          s.value = !1
        }
      return (
        l.watch(
          () => t.modelValue,
          (se) => {
            if (se) {
              var { hour: U, minute: W, second: ge } = cr(se),
                ye = Fe().hour(U).format('hh'),
                me = Fe().hour(U).format('HH'),
                ke = Fe().minute(W).format('mm'),
                ae = Fe().second(ge).format('ss')
              ;(c.value = (ye === '12' ? 0 : Ee(ye)) * 30),
                (p.value = Ee(ke) * 6),
                (h.value = Ee(ae) * 6),
                (b.value = K(se)),
                t.format !== '24hr' && (d.value = ('' + U).padStart(2, '0') === me && rr.includes(me) ? 'pm' : 'am'),
                (n.value = t.format === '24hr' && rr.includes(me))
            }
          },
          { immediate: !0 }
        ),
        {
          n: Oie,
          classes: Die,
          getRad: E,
          time: b,
          container: e,
          inner: i,
          picker: r,
          isInner: n,
          type: f,
          ampm: d,
          isPreventNextUpdate: s,
          moveHand: G,
          checkPanel: D,
          checkAmpm: I,
          end: Te,
          update: P,
          changePreventUpdate: ce,
        }
      )
    },
  })
  Jh.install = function (t) {
    t.component(Jh.name, Jh)
  }
  var $ie = {
    modelValue: { type: Array, default: () => [] },
    accept: { type: String, default: 'image/*' },
    capture: { type: [String, Boolean], default: void 0 },
    multiple: { type: Boolean, default: !1 },
    readonly: { type: Boolean, default: !1 },
    disabled: { type: Boolean, default: !1 },
    removable: { type: Boolean, default: !0 },
    maxlength: { type: [Number, String] },
    maxsize: { type: [Number, String] },
    previewed: { type: Boolean, default: !0 },
    ripple: { type: Boolean, default: !0 },
    validateTrigger: { type: Array, default: () => ['onChange', 'onRemove'] },
    rules: { type: Array },
    hideList: { type: Boolean, default: !1 },
    onBeforeRead: { type: Function },
    onAfterRead: { type: Function },
    onBeforeRemove: { type: Function },
    onRemove: { type: Function },
    onOversize: { type: Function },
    'onUpdate:modelValue': { type: Function },
  }
  function fS(t, e, r, i, n, s, a) {
    try {
      var o = t[s](a),
        u = o.value
    } catch (c) {
      r(c)
      return
    }
    o.done ? e(u) : Promise.resolve(u).then(i, n)
  }
  function hS(t) {
    return function () {
      var e = this,
        r = arguments
      return new Promise(function (i, n) {
        var s = t.apply(e, r)
        function a(u) {
          fS(s, i, n, a, o, 'next', u)
        }
        function o(u) {
          fS(s, i, n, a, o, 'throw', u)
        }
        a(void 0)
      })
    }
  }
  var { n: Rie, classes: jie } = Me('uploader'),
    _ie = 0,
    Vie = ['onClick'],
    Uie = ['onClick'],
    zie = ['src', 'alt'],
    Kie = ['multiple', 'accept', 'capture', 'disabled'],
    Wie = ['src']
  function Yie(t, e) {
    var r = l.resolveComponent('var-icon'),
      i = l.resolveComponent('var-form-details'),
      n = l.resolveComponent('var-popup'),
      s = l.resolveDirective('ripple')
    return (
      l.openBlock(),
      l.createElementBlock(
        'div',
        { class: l.normalizeClass(t.classes(t.n(), 'var--box')) },
        [
          l.createElementVNode(
            'div',
            { class: l.normalizeClass(t.n('file-list')) },
            [
              (l.openBlock(!0),
              l.createElementBlock(
                l.Fragment,
                null,
                l.renderList(t.files, (a) =>
                  l.withDirectives(
                    (l.openBlock(),
                    l.createElementBlock(
                      'div',
                      {
                        class: l.normalizeClass(
                          t.classes(t.n('file'), 'var-elevation--2', [a.state === 'loading', t.n('--loading')])
                        ),
                        key: a.id,
                        onClick: (o) => t.preview(a),
                      },
                      [
                        l.createElementVNode(
                          'div',
                          { class: l.normalizeClass(t.n('file-name')) },
                          l.toDisplayString(a.name || a.url),
                          3
                        ),
                        t.removable
                          ? (l.openBlock(),
                            l.createElementBlock(
                              'div',
                              {
                                key: 0,
                                class: l.normalizeClass(t.n('file-close')),
                                onClick: l.withModifiers((o) => t.handleRemove(a), ['stop']),
                              },
                              [
                                l.createVNode(
                                  r,
                                  {
                                    class: l.normalizeClass(t.n('file-close-icon')),
                                    'var-uploader-cover': '',
                                    name: 'delete',
                                  },
                                  null,
                                  8,
                                  ['class']
                                ),
                              ],
                              10,
                              Uie
                            ))
                          : l.createCommentVNode('v-if', !0),
                        a.cover
                          ? (l.openBlock(),
                            l.createElementBlock(
                              'img',
                              {
                                key: 1,
                                class: l.normalizeClass(t.n('file-cover')),
                                style: l.normalizeStyle({ objectFit: a.fit }),
                                src: a.cover,
                                alt: a.name,
                              },
                              null,
                              14,
                              zie
                            ))
                          : l.createCommentVNode('v-if', !0),
                        l.createElementVNode(
                          'div',
                          {
                            class: l.normalizeClass(
                              t.classes(
                                t.n('file-indicator'),
                                [a.state === 'success', t.n('--success')],
                                [a.state === 'error', t.n('--error')]
                              )
                            ),
                          },
                          null,
                          2
                        ),
                      ],
                      10,
                      Vie
                    )),
                    [[s, { disabled: t.disabled || t.formDisabled || t.readonly || t.formReadonly || !t.ripple }]]
                  )
                ),
                128
              )),
              !t.maxlength || t.modelValue.length < t.maxlength
                ? l.withDirectives(
                    (l.openBlock(),
                    l.createElementBlock(
                      'div',
                      {
                        key: 0,
                        class: l.normalizeClass(
                          t.classes(
                            [!t.$slots.default, t.n('action') + ' var-elevation--2'],
                            [t.disabled || t.formDisabled, t.n('--disabled')]
                          )
                        ),
                        onClick:
                          e[1] ||
                          (e[1] = function () {
                            return t.triggerAction && t.triggerAction(...arguments)
                          }),
                      },
                      [
                        l.createElementVNode(
                          'input',
                          {
                            ref: 'input',
                            class: l.normalizeClass(t.n('action-input')),
                            type: 'file',
                            multiple: t.multiple,
                            accept: t.accept,
                            capture: t.capture,
                            disabled: t.disabled || t.formDisabled || t.readonly || t.formReadonly,
                            onChange:
                              e[0] ||
                              (e[0] = function () {
                                return t.handleChange && t.handleChange(...arguments)
                              }),
                          },
                          null,
                          42,
                          Kie
                        ),
                        l.renderSlot(t.$slots, 'default', {}, () => [
                          l.createVNode(
                            r,
                            { class: l.normalizeClass(t.n('action-icon')), 'var-uploader-cover': '', name: 'plus' },
                            null,
                            8,
                            ['class']
                          ),
                        ]),
                      ],
                      2
                    )),
                    [
                      [
                        s,
                        {
                          disabled:
                            t.disabled ||
                            t.formDisabled ||
                            t.readonly ||
                            t.formReadonly ||
                            !t.ripple ||
                            t.$slots.default,
                        },
                      ],
                    ]
                  )
                : l.createCommentVNode('v-if', !0),
            ],
            2
          ),
          l.createVNode(i, { 'error-message': t.errorMessage, 'maxlength-text': t.maxlengthText }, null, 8, [
            'error-message',
            'maxlength-text',
          ]),
          l.createVNode(
            n,
            {
              class: l.normalizeClass(t.n('preview')),
              'var-uploader-cover': '',
              position: 'center',
              show: t.showPreview,
              'onUpdate:show': e[2] || (e[2] = (a) => (t.showPreview = a)),
              onClosed: e[3] || (e[3] = (a) => (t.currentPreview = null)),
            },
            {
              default: l.withCtx(() => {
                var a, o
                return [
                  t.currentPreview && t.isHTMLSupportVideo((a = t.currentPreview) == null ? void 0 : a.url)
                    ? (l.openBlock(),
                      l.createElementBlock(
                        'video',
                        {
                          key: 0,
                          class: l.normalizeClass(t.n('preview-video')),
                          playsinline: 'true',
                          'webkit-playsinline': 'true',
                          'x5-playsinline': 'true',
                          'x5-video-player-type': 'h5',
                          'x5-video-player-fullscreen': 'false',
                          controls: '',
                          src: (o = t.currentPreview) == null ? void 0 : o.url,
                        },
                        null,
                        10,
                        Wie
                      ))
                    : l.createCommentVNode('v-if', !0),
                ]
              }),
              _: 1,
            },
            8,
            ['class', 'show']
          ),
        ],
        2
      )
    )
  }
  var Zh = l.defineComponent({
    render: Yie,
    name: 'VarUploader',
    directives: { Ripple: tr },
    components: { VarIcon: kt, VarPopup: Ni, VarFormDetails: lr },
    props: $ie,
    setup(t) {
      var e = l.ref(null),
        r = l.ref(!1),
        i = l.ref(null),
        n = l.computed(() => {
          var {
            maxlength: w,
            modelValue: { length: J },
          } = t
          return br(w) ? J + ' / ' + w : ''
        }),
        { form: s, bindForm: a } = Or(),
        { errorMessage: o, validateWithTrigger: u, validate: c, resetValidation: p } = Nr(),
        h = l.computed(() => {
          var { modelValue: w, hideList: J } = t
          return J ? [] : w
        }),
        f = () => {
          e.value.click()
        },
        d = (w) => {
          var { disabled: J, readonly: X, previewed: G } = t
          if (!((s != null && s.disabled.value) || (s != null && s.readonly.value) || J || X || !G)) {
            var { url: Te } = w
            if (Tr(Te) && pT(Te)) {
              aa(Te)
              return
            }
            Tr(Te) && fT(Te) && ((i.value = w), (r.value = !0))
          }
        },
        T = (w) => ({ id: _ie++, url: '', cover: '', name: w.name, file: w }),
        y = (w) => {
          var J = w.target,
            { files: X } = J
          return Array.from(X)
        },
        b = (w) =>
          new Promise((J) => {
            var X = new FileReader()
            ;(X.onload = () => {
              var G = X.result
              w.file.type.startsWith('image') && (w.cover = G), (w.url = G), J(w)
            }),
              X.readAsDataURL(w.file)
          }),
        m = (w) => w.map(b),
        S = (w) => {
          var { onBeforeRead: J } = t
          return w.map(
            (X) =>
              new Promise((G) => {
                var Te = J ? J(l.reactive(X)) : !0
                Promise.resolve(Te).then((ce) => G({ valid: ce, varFile: X }))
              })
          )
        },
        E = (function () {
          var w = hS(function* (J) {
            var {
              maxsize: X,
              maxlength: G,
              modelValue: Te,
              onOversize: ce,
              onAfterRead: se,
              readonly: U,
              disabled: W,
            } = t
            if (!((s != null && s.disabled.value) || (s != null && s.readonly.value) || W || U)) {
              var ge = (Pe) => Pe.filter((De) => (De.file.size > Ee(X) ? (he(ce, l.reactive(De)), !1) : !0)),
                ye = (Pe) => {
                  var De = Math.min(Pe.length, Ee(G) - Te.length)
                  return Pe.slice(0, De)
                },
                me = y(J),
                ke = me.map(T)
              ;(ke = X != null ? ge(ke) : ke), (ke = G != null ? ye(ke) : ke)
              var ae = yield Promise.all(m(ke)),
                de = yield Promise.all(S(ae)),
                be = de
                  .filter((Pe) => {
                    var { valid: De } = Pe
                    return De
                  })
                  .map((Pe) => {
                    var { varFile: De } = Pe
                    return De
                  })
              he(t['onUpdate:modelValue'], [...Te, ...be]),
                (J.target.value = ''),
                be.forEach((Pe) => he(se, l.reactive(Pe)))
            }
          })
          return function (X) {
            return w.apply(this, arguments)
          }
        })(),
        P = (function () {
          var w = hS(function* (J) {
            var { disabled: X, readonly: G, modelValue: Te, onBeforeRemove: ce, onRemove: se } = t
            if (
              !((s != null && s.disabled.value) || (s != null && s.readonly.value) || X || G) &&
              !(ce && !(yield ce(J)))
            ) {
              var U = Te.filter((W) => W !== J)
              he(se, J), B('onRemove'), he(t['onUpdate:modelValue'], U)
            }
          })
          return function (X) {
            return w.apply(this, arguments)
          }
        })(),
        x = () => t.modelValue.filter((w) => w.state === 'success'),
        D = () => t.modelValue.filter((w) => w.state === 'error'),
        N = () => t.modelValue.filter((w) => w.state === 'loading'),
        I = { getSuccess: x, getError: D, getLoading: N },
        B = (w) => {
          l.nextTick(() => {
            var { validateTrigger: J, rules: X, modelValue: G } = t
            u(J, w, X, G, I)
          })
        },
        K = !1,
        Y = () => c(t.rules, t.modelValue, I),
        C = () => {
          ;(K = !0), he(t['onUpdate:modelValue'], []), p()
        },
        H = { validate: Y, resetValidation: p, reset: C }
      return (
        he(a, H),
        l.watch(
          () => t.modelValue,
          () => {
            !K && B('onChange'), (K = !1)
          },
          { deep: !0 }
        ),
        {
          n: Rie,
          classes: jie,
          input: e,
          files: h,
          showPreview: r,
          currentPreview: i,
          errorMessage: o,
          maxlengthText: n,
          isHTMLSupportVideo: fT,
          isHTMLSupportImage: pT,
          formDisabled: s == null ? void 0 : s.disabled,
          formReadonly: s == null ? void 0 : s.readonly,
          preview: d,
          triggerAction: f,
          handleChange: E,
          handleRemove: P,
          getSuccess: x,
          getError: D,
          getLoading: N,
          validate: Y,
          resetValidation: p,
          reset: C,
        }
      )
    },
  })
  Zh.install = function (t) {
    t.component(Zh.name, Zh)
  }
  var dS = { exports: {} }
  ;(function (t, e) {
    ;(function (r, i) {
      i()
    })(jt, function () {
      function r(c, p) {
        return (
          typeof p == 'undefined'
            ? (p = { autoBom: !1 })
            : typeof p != 'object' &&
              (console.warn('Deprecated: Expected third argument to be a object'), (p = { autoBom: !p })),
          p.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(c.type)
            ? new Blob(['\uFEFF', c], { type: c.type })
            : c
        )
      }
      function i(c, p, h) {
        var f = new XMLHttpRequest()
        f.open('GET', c),
          (f.responseType = 'blob'),
          (f.onload = function () {
            u(f.response, p, h)
          }),
          (f.onerror = function () {
            console.error('could not download file')
          }),
          f.send()
      }
      function n(c) {
        var p = new XMLHttpRequest()
        p.open('HEAD', c, !1)
        try {
          p.send()
        } catch {}
        return 200 <= p.status && 299 >= p.status
      }
      function s(c) {
        try {
          c.dispatchEvent(new MouseEvent('click'))
        } catch {
          var p = document.createEvent('MouseEvents')
          p.initMouseEvent('click', !0, !0, window, 0, 0, 0, 80, 20, !1, !1, !1, !1, 0, null), c.dispatchEvent(p)
        }
      }
      var a =
          typeof window == 'object' && window.window === window
            ? window
            : typeof self == 'object' && self.self === self
            ? self
            : typeof jt == 'object' && jt.global === jt
            ? jt
            : void 0,
        o =
          a.navigator &&
          /Macintosh/.test(navigator.userAgent) &&
          /AppleWebKit/.test(navigator.userAgent) &&
          !/Safari/.test(navigator.userAgent),
        u =
          a.saveAs ||
          (typeof window != 'object' || window !== a
            ? function () {}
            : 'download' in HTMLAnchorElement.prototype && !o
            ? function (c, p, h) {
                var f = a.URL || a.webkitURL,
                  d = document.createElement('a')
                ;(p = p || c.name || 'download'),
                  (d.download = p),
                  (d.rel = 'noopener'),
                  typeof c == 'string'
                    ? ((d.href = c),
                      d.origin === location.origin ? s(d) : n(d.href) ? i(c, p, h) : s(d, (d.target = '_blank')))
                    : ((d.href = f.createObjectURL(c)),
                      setTimeout(function () {
                        f.revokeObjectURL(d.href)
                      }, 4e4),
                      setTimeout(function () {
                        s(d)
                      }, 0))
              }
            : 'msSaveOrOpenBlob' in navigator
            ? function (c, p, h) {
                if (((p = p || c.name || 'download'), typeof c != 'string')) navigator.msSaveOrOpenBlob(r(c, h), p)
                else if (n(c)) i(c, p, h)
                else {
                  var f = document.createElement('a')
                  ;(f.href = c),
                    (f.target = '_blank'),
                    setTimeout(function () {
                      s(f)
                    })
                }
              }
            : function (c, p, h, f) {
                if (
                  ((f = f || open('', '_blank')),
                  f && (f.document.title = f.document.body.innerText = 'downloading...'),
                  typeof c == 'string')
                )
                  return i(c, p, h)
                var d = c.type === 'application/octet-stream',
                  T = /constructor/i.test(a.HTMLElement) || a.safari,
                  y = /CriOS\/[\d]+/.test(navigator.userAgent)
                if ((y || (d && T) || o) && typeof FileReader != 'undefined') {
                  var b = new FileReader()
                  ;(b.onloadend = function () {
                    var E = b.result
                    ;(E = y ? E : E.replace(/^data:[^;]*;/, 'data:attachment/file;')),
                      f ? (f.location.href = E) : (location = E),
                      (f = null)
                  }),
                    b.readAsDataURL(c)
                } else {
                  var m = a.URL || a.webkitURL,
                    S = m.createObjectURL(c)
                  f ? (f.location = S) : (location.href = S),
                    (f = null),
                    setTimeout(function () {
                      m.revokeObjectURL(S)
                    }, 4e4)
                }
              })
      ;(a.saveAs = u.saveAs = u), (t.exports = u)
    })
  })(dS)
  const Hie = (t) => Object.prototype.toString.call(t) === '[object Object]',
    fa = (t) => Array.isArray(t),
    Qh = (t) => typeof t == 'string'
  function mS(t) {
    return t
      .replace(/([A-Z])/g, ' $1')
      .trim()
      .split(' ')
      .join('-')
      .toLowerCase()
  }
  const qie = { class: 'varlet-low-code-codegen' },
    Xie = l.createTextVNode('Codegen'),
    Gie = l.defineComponent({
      setup(t) {
        const e = () => window[0].VarletLowcodeRenderer.default.schema.value,
          r = () => window[0].VarletLowcodeRenderer.default.assets.value,
          i = () => window[0].VarletLowcodeCore.assetsManager,
          n = (P) => JSON.stringify(P).replace(/"(.+)":/g, '$1:'),
          s = (P) => {
            P = P.replace(/\$index\[['"](.+)['"]\]/g, '$index_$1')
              .replace(/\$index\.(.+)(?![.\[])/g, '$index_$1')
              .replace(/\$item\[['"](.+)['"]\]/g, '$item_$1')
              .replace(/\$item\.(.+)(?![.\[])/g, '$item_$1')
              .replace(/\$slotProps\[['"](.+)['"]\]/g, '$slotProps_$1')
              .replace(/\$slotProps\.(.+)(?![.\[])/g, '$slotProps_$1')
            const x = CU(P, { sourceType: 'module' })
            FX(x, {
              MemberExpression(N) {
                N.node.object.type === 'Identifier' &&
                  N.node.property.type === 'Identifier' &&
                  N.node.property.name === 'value' &&
                  N.replaceWith(st.identifier(N.node.object.name))
              },
            })
            const { code: D } = n_(x)
            return D.endsWith(';') ? D.slice(0, -1) : D
          },
          a = (P) => {
            if (!P.startsWith('on')) return `:${mS(P)}`
            const x = mS(P.slice(2))
            return `@${x.at(0).toLowerCase()}${x.slice(1)}`
          },
          o = () => {
            const P = {}
            return (
              pr.schemaManager.visitSchemaNode(e(), (x) => {
                if (pr.schemaManager.isSchemaPageNode(x) || pr.schemaManager.isSchemaTextNode(x)) return
                const { packageName: D, packageVersion: N } = i().findProfile(r(), x.name, x.library)
                P[x.library] = [D, N]
              }),
              P
            )
          },
          u = (P) => {
            var x
            return Object.entries((x = P.props) != null ? x : {}).reduce(
              (D, [N, I]) =>
                pr.schemaManager.isExpressionBinding(I)
                  ? ((D += ` ${a(N)}="${s(I.value)}"`), D)
                  : pr.schemaManager.isObjectBinding(I)
                  ? ((D += ` :${N}="${n(I.value)}"`), D)
                  : fa(I)
                  ? ((D += ` :${N}="${n(I)}"`), D)
                  : Qh(I)
                  ? ((D += ` ${N}="${I}"`), D)
                  : ((D += ` :${N}="${I}"`), D),
              ''
            )
          },
          c = (P) =>
            Object.hasOwn(P, 'if')
              ? pr.schemaManager.isExpressionBinding(P.if)
                ? ` v-if="${s(P.if.value)}"`
                : pr.schemaManager.isObjectBinding(P.if)
                ? ` v-if="${n(P.if.value)}"`
                : fa(P.if)
                ? ` v-if="${n(P.if)}"`
                : Qh(P.if)
                ? ` v-if="'${P.if}'"`
                : ` v-if="${P.if}"`
              : '',
          p = (P) =>
            Object.hasOwn(P, 'for')
              ? pr.schemaManager.isExpressionBinding(P.for)
                ? ` v-for="$item_${P.id} in ${s(P.for.value)}"`
                : pr.schemaManager.isObjectBinding(P.for)
                ? ` v-for="$item_${P.id} in ${n(P.for.value)}"`
                : fa(P.for)
                ? ` v-for="$item_${P.id} in ${n(P.for)}"`
                : Qh(P.for)
                ? ` v-for="$item_${P.id} in '${P.for}'"`
                : ` v-for="$item_${P.id} in ${P.for}"`
              : '',
          h = (P, x, D, N) =>
            Object.entries(P).map(([I, B]) => {
              var H, w, J
              const K =
                  (J =
                    (w = (H = D.slots) == null ? void 0 : H.find((X) => X.name === I)) == null
                      ? void 0
                      : w.hasSlotProps) != null
                    ? J
                    : !1,
                Y = K ? `="$slotProps_${x.id}"` : ''
              if (I === 'default' && !K)
                return B.children.map((X) => f(X, N + 1)).join(`
`)
              const C = ' '.repeat((N + 1) * 2)
              return `${C}<template #${I}${Y}>
${B.children.map((X) => f(X, N + 2)).join(`
`)}
${C}</template>`
            }).join(`
`),
          f = (P, x = 1) => {
            var B, K
            const D = ' '.repeat(x * 2)
            if (pr.schemaManager.isSchemaPageNode(P) && fa((B = P.slots) == null ? void 0 : B.default.children))
              return P.slots.default.children.map((Y) => f(Y, x + 1)).join(`
`)
            if (pr.schemaManager.isSchemaPageNode(P) && !fa((K = P.slots) == null ? void 0 : K.default.children))
              return ''
            if (pr.schemaManager.isSchemaTextNode(P))
              return pr.schemaManager.isExpressionBinding(P.textContent)
                ? `${D}{{ ${s(P.textContent.value)} }}`
                : `${D}${P.textContent}`
            const N = i().findMaterial(r(), P.name, P.library),
              { name: I } = N.codegen
            return Hie(P.slots)
              ? `${D}<${I}${u(P)}${c(P)}${p(P)}>
${h(P.slots, P, N, x)}
${D}</${I}>`
              : `${D}<${I}${u(P)}${c(P)}${p(P)} />`
          },
          d = (P) => {
            const x = e()
            return `<template>
  <div class="varlet-low-code-page">
${f(x)}
  </div>
</template>

<script>
import {
  defineComponent,
  ref,
  reactive,
  computed,
  watch,
  onBeforeMount,
  onMounted,
  onBeforeUpdate,
  onUpdated,
  onBeforeUnmount,
  onUnmounted,
} from 'vue'
${T(P)}

${x.code}

export default defineComponent({
  setup
})
<\/script>
`
          },
          T = (P) =>
            Object.entries(P).map(
              ([x, [D]]) => `import ${x} from '${D}'
`
            ),
          y = (P) => {
            const x = Object.entries(P).map(([D]) => `.use(${D})`)
            return `import App from './App.vue'
${T(P)}
import { createApp } from 'vue'

const app = createApp(App)

app${x.join('')}
app.mount('#app')
`
          },
          b = (P) => {
            const x = Object.entries(P).map(([D, [N, I]]) => `    "${N}": "${I}"`)
            return bS.replace(
              '"vite": "latest"',
              `"vite": "latest",
${x.join(`,
`)}`
            )
          },
          m = () => {
            const x = i()
              .getResources(r())
              .map((D) => `    <script src="${D}"><\/script>`)
            return TS.replace(
              '    <script type="module" src="/src/main.js"></script>',
              `${x.join(`
`)}
    <script type="module" src="/src/main.js"><\/script>`
            )
          },
          S = (P) => {
            const x = Object.entries(P).map(([D, [N]]) => `      '${N}': '${D}'`)
            return SS.replace(
              '    viteExternalsPlugin()',
              `    viteExternalsPlugin({
      vue: 'Vue',
${x.join(`,
`)}
    })`
            )
          },
          E = async () => {
            const P = o(),
              x = new $X()
            x.file('index.html', m()),
              x.file('package.json', b(P)),
              x.file('vite.config.js', S(P)),
              x.file('README.md', vS)
            const D = x.folder('src')
            D.file('App.vue', d(P)), D.file('main.js', y(P))
            const N = await x.generateAsync({ type: 'blob' })
            dS.exports.saveAs(N, 'vite-varlet-low-code-starter.zip')
          }
        return (P, x) => (
          l.openBlock(),
          l.createElementBlock('div', qie, [
            l.createVNode(l.unref(Er), { type: 'primary', onClick: E }, { default: l.withCtx(() => [Xie]), _: 1 }),
          ])
        )
      },
    })
  var yS = {},
    Gl = {}
  ;(Gl.byteLength = Qie), (Gl.toByteArray = tne), (Gl.fromByteArray = nne)
  for (
    var jr = [],
      wr = [],
      Jie = typeof Uint8Array != 'undefined' ? Uint8Array : Array,
      ed = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
      is = 0,
      Zie = ed.length;
    is < Zie;
    ++is
  )
    (jr[is] = ed[is]), (wr[ed.charCodeAt(is)] = is)
  ;(wr['-'.charCodeAt(0)] = 62), (wr['_'.charCodeAt(0)] = 63)
  function gS(t) {
    var e = t.length
    if (e % 4 > 0) throw new Error('Invalid string. Length must be a multiple of 4')
    var r = t.indexOf('=')
    r === -1 && (r = e)
    var i = r === e ? 0 : 4 - (r % 4)
    return [r, i]
  }
  function Qie(t) {
    var e = gS(t),
      r = e[0],
      i = e[1]
    return ((r + i) * 3) / 4 - i
  }
  function ene(t, e, r) {
    return ((e + r) * 3) / 4 - r
  }
  function tne(t) {
    var e,
      r = gS(t),
      i = r[0],
      n = r[1],
      s = new Jie(ene(t, i, n)),
      a = 0,
      o = n > 0 ? i - 4 : i,
      u
    for (u = 0; u < o; u += 4)
      (e =
        (wr[t.charCodeAt(u)] << 18) |
        (wr[t.charCodeAt(u + 1)] << 12) |
        (wr[t.charCodeAt(u + 2)] << 6) |
        wr[t.charCodeAt(u + 3)]),
        (s[a++] = (e >> 16) & 255),
        (s[a++] = (e >> 8) & 255),
        (s[a++] = e & 255)
    return (
      n === 2 && ((e = (wr[t.charCodeAt(u)] << 2) | (wr[t.charCodeAt(u + 1)] >> 4)), (s[a++] = e & 255)),
      n === 1 &&
        ((e = (wr[t.charCodeAt(u)] << 10) | (wr[t.charCodeAt(u + 1)] << 4) | (wr[t.charCodeAt(u + 2)] >> 2)),
        (s[a++] = (e >> 8) & 255),
        (s[a++] = e & 255)),
      s
    )
  }
  function rne(t) {
    return jr[(t >> 18) & 63] + jr[(t >> 12) & 63] + jr[(t >> 6) & 63] + jr[t & 63]
  }
  function ine(t, e, r) {
    for (var i, n = [], s = e; s < r; s += 3)
      (i = ((t[s] << 16) & 16711680) + ((t[s + 1] << 8) & 65280) + (t[s + 2] & 255)), n.push(rne(i))
    return n.join('')
  }
  function nne(t) {
    for (var e, r = t.length, i = r % 3, n = [], s = 16383, a = 0, o = r - i; a < o; a += s)
      n.push(ine(t, a, a + s > o ? o : a + s))
    return (
      i === 1
        ? ((e = t[r - 1]), n.push(jr[e >> 2] + jr[(e << 4) & 63] + '=='))
        : i === 2 &&
          ((e = (t[r - 2] << 8) + t[r - 1]), n.push(jr[e >> 10] + jr[(e >> 4) & 63] + jr[(e << 2) & 63] + '=')),
      n.join('')
    )
  }
  var td = {}
  /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ ;(td.read = function (
    t,
    e,
    r,
    i,
    n
  ) {
    var s,
      a,
      o = n * 8 - i - 1,
      u = (1 << o) - 1,
      c = u >> 1,
      p = -7,
      h = r ? n - 1 : 0,
      f = r ? -1 : 1,
      d = t[e + h]
    for (h += f, s = d & ((1 << -p) - 1), d >>= -p, p += o; p > 0; s = s * 256 + t[e + h], h += f, p -= 8);
    for (a = s & ((1 << -p) - 1), s >>= -p, p += i; p > 0; a = a * 256 + t[e + h], h += f, p -= 8);
    if (s === 0) s = 1 - c
    else {
      if (s === u) return a ? NaN : (d ? -1 : 1) * (1 / 0)
      ;(a = a + Math.pow(2, i)), (s = s - c)
    }
    return (d ? -1 : 1) * a * Math.pow(2, s - i)
  }),
    (td.write = function (t, e, r, i, n, s) {
      var a,
        o,
        u,
        c = s * 8 - n - 1,
        p = (1 << c) - 1,
        h = p >> 1,
        f = n === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
        d = i ? 0 : s - 1,
        T = i ? 1 : -1,
        y = e < 0 || (e === 0 && 1 / e < 0) ? 1 : 0
      for (
        e = Math.abs(e),
          isNaN(e) || e === 1 / 0
            ? ((o = isNaN(e) ? 1 : 0), (a = p))
            : ((a = Math.floor(Math.log(e) / Math.LN2)),
              e * (u = Math.pow(2, -a)) < 1 && (a--, (u *= 2)),
              a + h >= 1 ? (e += f / u) : (e += f * Math.pow(2, 1 - h)),
              e * u >= 2 && (a++, (u /= 2)),
              a + h >= p
                ? ((o = 0), (a = p))
                : a + h >= 1
                ? ((o = (e * u - 1) * Math.pow(2, n)), (a = a + h))
                : ((o = e * Math.pow(2, h - 1) * Math.pow(2, n)), (a = 0)));
        n >= 8;
        t[r + d] = o & 255, d += T, o /= 256, n -= 8
      );
      for (a = (a << n) | o, c += n; c > 0; t[r + d] = a & 255, d += T, a /= 256, c -= 8);
      t[r + d - T] |= y * 128
    })
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   */ ;(function (t) {
    const e = Gl,
      r = td,
      i =
        typeof Symbol == 'function' && typeof Symbol.for == 'function' ? Symbol.for('nodejs.util.inspect.custom') : null
    ;(t.Buffer = o), (t.SlowBuffer = S), (t.INSPECT_MAX_BYTES = 50)
    const n = 2147483647
    ;(t.kMaxLength = n),
      (o.TYPED_ARRAY_SUPPORT = s()),
      !o.TYPED_ARRAY_SUPPORT &&
        typeof console != 'undefined' &&
        typeof console.error == 'function' &&
        console.error(
          'This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
        )
    function s() {
      try {
        const O = new Uint8Array(1),
          g = {
            foo: function () {
              return 42
            },
          }
        return Object.setPrototypeOf(g, Uint8Array.prototype), Object.setPrototypeOf(O, g), O.foo() === 42
      } catch {
        return !1
      }
    }
    Object.defineProperty(o.prototype, 'parent', {
      enumerable: !0,
      get: function () {
        if (!!o.isBuffer(this)) return this.buffer
      },
    }),
      Object.defineProperty(o.prototype, 'offset', {
        enumerable: !0,
        get: function () {
          if (!!o.isBuffer(this)) return this.byteOffset
        },
      })
    function a(O) {
      if (O > n) throw new RangeError('The value "' + O + '" is invalid for option "size"')
      const g = new Uint8Array(O)
      return Object.setPrototypeOf(g, o.prototype), g
    }
    function o(O, g, v) {
      if (typeof O == 'number') {
        if (typeof g == 'string')
          throw new TypeError('The "string" argument must be of type string. Received type number')
        return h(O)
      }
      return u(O, g, v)
    }
    o.poolSize = 8192
    function u(O, g, v) {
      if (typeof O == 'string') return f(O, g)
      if (ArrayBuffer.isView(O)) return T(O)
      if (O == null)
        throw new TypeError(
          'The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' +
            typeof O
        )
      if (
        ne(O, ArrayBuffer) ||
        (O && ne(O.buffer, ArrayBuffer)) ||
        (typeof SharedArrayBuffer != 'undefined' &&
          (ne(O, SharedArrayBuffer) || (O && ne(O.buffer, SharedArrayBuffer))))
      )
        return y(O, g, v)
      if (typeof O == 'number')
        throw new TypeError('The "value" argument must not be of type number. Received type number')
      const z = O.valueOf && O.valueOf()
      if (z != null && z !== O) return o.from(z, g, v)
      const ee = b(O)
      if (ee) return ee
      if (typeof Symbol != 'undefined' && Symbol.toPrimitive != null && typeof O[Symbol.toPrimitive] == 'function')
        return o.from(O[Symbol.toPrimitive]('string'), g, v)
      throw new TypeError(
        'The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' +
          typeof O
      )
    }
    ;(o.from = function (O, g, v) {
      return u(O, g, v)
    }),
      Object.setPrototypeOf(o.prototype, Uint8Array.prototype),
      Object.setPrototypeOf(o, Uint8Array)
    function c(O) {
      if (typeof O != 'number') throw new TypeError('"size" argument must be of type number')
      if (O < 0) throw new RangeError('The value "' + O + '" is invalid for option "size"')
    }
    function p(O, g, v) {
      return c(O), O <= 0 ? a(O) : g !== void 0 ? (typeof v == 'string' ? a(O).fill(g, v) : a(O).fill(g)) : a(O)
    }
    o.alloc = function (O, g, v) {
      return p(O, g, v)
    }
    function h(O) {
      return c(O), a(O < 0 ? 0 : m(O) | 0)
    }
    ;(o.allocUnsafe = function (O) {
      return h(O)
    }),
      (o.allocUnsafeSlow = function (O) {
        return h(O)
      })
    function f(O, g) {
      if (((typeof g != 'string' || g === '') && (g = 'utf8'), !o.isEncoding(g)))
        throw new TypeError('Unknown encoding: ' + g)
      const v = E(O, g) | 0
      let z = a(v)
      const ee = z.write(O, g)
      return ee !== v && (z = z.slice(0, ee)), z
    }
    function d(O) {
      const g = O.length < 0 ? 0 : m(O.length) | 0,
        v = a(g)
      for (let z = 0; z < g; z += 1) v[z] = O[z] & 255
      return v
    }
    function T(O) {
      if (ne(O, Uint8Array)) {
        const g = new Uint8Array(O)
        return y(g.buffer, g.byteOffset, g.byteLength)
      }
      return d(O)
    }
    function y(O, g, v) {
      if (g < 0 || O.byteLength < g) throw new RangeError('"offset" is outside of buffer bounds')
      if (O.byteLength < g + (v || 0)) throw new RangeError('"length" is outside of buffer bounds')
      let z
      return (
        g === void 0 && v === void 0
          ? (z = new Uint8Array(O))
          : v === void 0
          ? (z = new Uint8Array(O, g))
          : (z = new Uint8Array(O, g, v)),
        Object.setPrototypeOf(z, o.prototype),
        z
      )
    }
    function b(O) {
      if (o.isBuffer(O)) {
        const g = m(O.length) | 0,
          v = a(g)
        return v.length === 0 || O.copy(v, 0, 0, g), v
      }
      if (O.length !== void 0) return typeof O.length != 'number' || Se(O.length) ? a(0) : d(O)
      if (O.type === 'Buffer' && Array.isArray(O.data)) return d(O.data)
    }
    function m(O) {
      if (O >= n)
        throw new RangeError('Attempt to allocate Buffer larger than maximum size: 0x' + n.toString(16) + ' bytes')
      return O | 0
    }
    function S(O) {
      return +O != O && (O = 0), o.alloc(+O)
    }
    ;(o.isBuffer = function (g) {
      return g != null && g._isBuffer === !0 && g !== o.prototype
    }),
      (o.compare = function (g, v) {
        if (
          (ne(g, Uint8Array) && (g = o.from(g, g.offset, g.byteLength)),
          ne(v, Uint8Array) && (v = o.from(v, v.offset, v.byteLength)),
          !o.isBuffer(g) || !o.isBuffer(v))
        )
          throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array')
        if (g === v) return 0
        let z = g.length,
          ee = v.length
        for (let ue = 0, Z = Math.min(z, ee); ue < Z; ++ue)
          if (g[ue] !== v[ue]) {
            ;(z = g[ue]), (ee = v[ue])
            break
          }
        return z < ee ? -1 : ee < z ? 1 : 0
      }),
      (o.isEncoding = function (g) {
        switch (String(g).toLowerCase()) {
          case 'hex':
          case 'utf8':
          case 'utf-8':
          case 'ascii':
          case 'latin1':
          case 'binary':
          case 'base64':
          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return !0
          default:
            return !1
        }
      }),
      (o.concat = function (g, v) {
        if (!Array.isArray(g)) throw new TypeError('"list" argument must be an Array of Buffers')
        if (g.length === 0) return o.alloc(0)
        let z
        if (v === void 0) for (v = 0, z = 0; z < g.length; ++z) v += g[z].length
        const ee = o.allocUnsafe(v)
        let ue = 0
        for (z = 0; z < g.length; ++z) {
          let Z = g[z]
          if (ne(Z, Uint8Array))
            ue + Z.length > ee.length
              ? (o.isBuffer(Z) || (Z = o.from(Z)), Z.copy(ee, ue))
              : Uint8Array.prototype.set.call(ee, Z, ue)
          else if (o.isBuffer(Z)) Z.copy(ee, ue)
          else throw new TypeError('"list" argument must be an Array of Buffers')
          ue += Z.length
        }
        return ee
      })
    function E(O, g) {
      if (o.isBuffer(O)) return O.length
      if (ArrayBuffer.isView(O) || ne(O, ArrayBuffer)) return O.byteLength
      if (typeof O != 'string')
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof O
        )
      const v = O.length,
        z = arguments.length > 2 && arguments[2] === !0
      if (!z && v === 0) return 0
      let ee = !1
      for (;;)
        switch (g) {
          case 'ascii':
          case 'latin1':
          case 'binary':
            return v
          case 'utf8':
          case 'utf-8':
            return L(O).length
          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return v * 2
          case 'hex':
            return v >>> 1
          case 'base64':
            return le(O).length
          default:
            if (ee) return z ? -1 : L(O).length
            ;(g = ('' + g).toLowerCase()), (ee = !0)
        }
    }
    o.byteLength = E
    function P(O, g, v) {
      let z = !1
      if (
        ((g === void 0 || g < 0) && (g = 0),
        g > this.length ||
          ((v === void 0 || v > this.length) && (v = this.length), v <= 0) ||
          ((v >>>= 0), (g >>>= 0), v <= g))
      )
        return ''
      for (O || (O = 'utf8'); ; )
        switch (O) {
          case 'hex':
            return ce(this, g, v)
          case 'utf8':
          case 'utf-8':
            return w(this, g, v)
          case 'ascii':
            return G(this, g, v)
          case 'latin1':
          case 'binary':
            return Te(this, g, v)
          case 'base64':
            return H(this, g, v)
          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return se(this, g, v)
          default:
            if (z) throw new TypeError('Unknown encoding: ' + O)
            ;(O = (O + '').toLowerCase()), (z = !0)
        }
    }
    o.prototype._isBuffer = !0
    function x(O, g, v) {
      const z = O[g]
      ;(O[g] = O[v]), (O[v] = z)
    }
    ;(o.prototype.swap16 = function () {
      const g = this.length
      if (g % 2 !== 0) throw new RangeError('Buffer size must be a multiple of 16-bits')
      for (let v = 0; v < g; v += 2) x(this, v, v + 1)
      return this
    }),
      (o.prototype.swap32 = function () {
        const g = this.length
        if (g % 4 !== 0) throw new RangeError('Buffer size must be a multiple of 32-bits')
        for (let v = 0; v < g; v += 4) x(this, v, v + 3), x(this, v + 1, v + 2)
        return this
      }),
      (o.prototype.swap64 = function () {
        const g = this.length
        if (g % 8 !== 0) throw new RangeError('Buffer size must be a multiple of 64-bits')
        for (let v = 0; v < g; v += 8)
          x(this, v, v + 7), x(this, v + 1, v + 6), x(this, v + 2, v + 5), x(this, v + 3, v + 4)
        return this
      }),
      (o.prototype.toString = function () {
        const g = this.length
        return g === 0 ? '' : arguments.length === 0 ? w(this, 0, g) : P.apply(this, arguments)
      }),
      (o.prototype.toLocaleString = o.prototype.toString),
      (o.prototype.equals = function (g) {
        if (!o.isBuffer(g)) throw new TypeError('Argument must be a Buffer')
        return this === g ? !0 : o.compare(this, g) === 0
      }),
      (o.prototype.inspect = function () {
        let g = ''
        const v = t.INSPECT_MAX_BYTES
        return (
          (g = this.toString('hex', 0, v)
            .replace(/(.{2})/g, '$1 ')
            .trim()),
          this.length > v && (g += ' ... '),
          '<Buffer ' + g + '>'
        )
      }),
      i && (o.prototype[i] = o.prototype.inspect),
      (o.prototype.compare = function (g, v, z, ee, ue) {
        if ((ne(g, Uint8Array) && (g = o.from(g, g.offset, g.byteLength)), !o.isBuffer(g)))
          throw new TypeError(
            'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof g
          )
        if (
          (v === void 0 && (v = 0),
          z === void 0 && (z = g ? g.length : 0),
          ee === void 0 && (ee = 0),
          ue === void 0 && (ue = this.length),
          v < 0 || z > g.length || ee < 0 || ue > this.length)
        )
          throw new RangeError('out of range index')
        if (ee >= ue && v >= z) return 0
        if (ee >= ue) return -1
        if (v >= z) return 1
        if (((v >>>= 0), (z >>>= 0), (ee >>>= 0), (ue >>>= 0), this === g)) return 0
        let Z = ue - ee,
          et = z - v
        const bt = Math.min(Z, et),
          at = this.slice(ee, ue),
          Pt = g.slice(v, z)
        for (let R = 0; R < bt; ++R)
          if (at[R] !== Pt[R]) {
            ;(Z = at[R]), (et = Pt[R])
            break
          }
        return Z < et ? -1 : et < Z ? 1 : 0
      })
    function D(O, g, v, z, ee) {
      if (O.length === 0) return -1
      if (
        (typeof v == 'string'
          ? ((z = v), (v = 0))
          : v > 2147483647
          ? (v = 2147483647)
          : v < -2147483648 && (v = -2147483648),
        (v = +v),
        Se(v) && (v = ee ? 0 : O.length - 1),
        v < 0 && (v = O.length + v),
        v >= O.length)
      ) {
        if (ee) return -1
        v = O.length - 1
      } else if (v < 0)
        if (ee) v = 0
        else return -1
      if ((typeof g == 'string' && (g = o.from(g, z)), o.isBuffer(g))) return g.length === 0 ? -1 : N(O, g, v, z, ee)
      if (typeof g == 'number')
        return (
          (g = g & 255),
          typeof Uint8Array.prototype.indexOf == 'function'
            ? ee
              ? Uint8Array.prototype.indexOf.call(O, g, v)
              : Uint8Array.prototype.lastIndexOf.call(O, g, v)
            : N(O, [g], v, z, ee)
        )
      throw new TypeError('val must be string, number or Buffer')
    }
    function N(O, g, v, z, ee) {
      let ue = 1,
        Z = O.length,
        et = g.length
      if (
        z !== void 0 &&
        ((z = String(z).toLowerCase()), z === 'ucs2' || z === 'ucs-2' || z === 'utf16le' || z === 'utf-16le')
      ) {
        if (O.length < 2 || g.length < 2) return -1
        ;(ue = 2), (Z /= 2), (et /= 2), (v /= 2)
      }
      function bt(Pt, R) {
        return ue === 1 ? Pt[R] : Pt.readUInt16BE(R * ue)
      }
      let at
      if (ee) {
        let Pt = -1
        for (at = v; at < Z; at++)
          if (bt(O, at) === bt(g, Pt === -1 ? 0 : at - Pt)) {
            if ((Pt === -1 && (Pt = at), at - Pt + 1 === et)) return Pt * ue
          } else Pt !== -1 && (at -= at - Pt), (Pt = -1)
      } else
        for (v + et > Z && (v = Z - et), at = v; at >= 0; at--) {
          let Pt = !0
          for (let R = 0; R < et; R++)
            if (bt(O, at + R) !== bt(g, R)) {
              Pt = !1
              break
            }
          if (Pt) return at
        }
      return -1
    }
    ;(o.prototype.includes = function (g, v, z) {
      return this.indexOf(g, v, z) !== -1
    }),
      (o.prototype.indexOf = function (g, v, z) {
        return D(this, g, v, z, !0)
      }),
      (o.prototype.lastIndexOf = function (g, v, z) {
        return D(this, g, v, z, !1)
      })
    function I(O, g, v, z) {
      v = Number(v) || 0
      const ee = O.length - v
      z ? ((z = Number(z)), z > ee && (z = ee)) : (z = ee)
      const ue = g.length
      z > ue / 2 && (z = ue / 2)
      let Z
      for (Z = 0; Z < z; ++Z) {
        const et = parseInt(g.substr(Z * 2, 2), 16)
        if (Se(et)) return Z
        O[v + Z] = et
      }
      return Z
    }
    function B(O, g, v, z) {
      return fe(L(g, O.length - v), O, v, z)
    }
    function K(O, g, v, z) {
      return fe(F(g), O, v, z)
    }
    function Y(O, g, v, z) {
      return fe(le(g), O, v, z)
    }
    function C(O, g, v, z) {
      return fe(q(g, O.length - v), O, v, z)
    }
    ;(o.prototype.write = function (g, v, z, ee) {
      if (v === void 0) (ee = 'utf8'), (z = this.length), (v = 0)
      else if (z === void 0 && typeof v == 'string') (ee = v), (z = this.length), (v = 0)
      else if (isFinite(v))
        (v = v >>> 0), isFinite(z) ? ((z = z >>> 0), ee === void 0 && (ee = 'utf8')) : ((ee = z), (z = void 0))
      else throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported')
      const ue = this.length - v
      if (((z === void 0 || z > ue) && (z = ue), (g.length > 0 && (z < 0 || v < 0)) || v > this.length))
        throw new RangeError('Attempt to write outside buffer bounds')
      ee || (ee = 'utf8')
      let Z = !1
      for (;;)
        switch (ee) {
          case 'hex':
            return I(this, g, v, z)
          case 'utf8':
          case 'utf-8':
            return B(this, g, v, z)
          case 'ascii':
          case 'latin1':
          case 'binary':
            return K(this, g, v, z)
          case 'base64':
            return Y(this, g, v, z)
          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return C(this, g, v, z)
          default:
            if (Z) throw new TypeError('Unknown encoding: ' + ee)
            ;(ee = ('' + ee).toLowerCase()), (Z = !0)
        }
    }),
      (o.prototype.toJSON = function () {
        return { type: 'Buffer', data: Array.prototype.slice.call(this._arr || this, 0) }
      })
    function H(O, g, v) {
      return g === 0 && v === O.length ? e.fromByteArray(O) : e.fromByteArray(O.slice(g, v))
    }
    function w(O, g, v) {
      v = Math.min(O.length, v)
      const z = []
      let ee = g
      for (; ee < v; ) {
        const ue = O[ee]
        let Z = null,
          et = ue > 239 ? 4 : ue > 223 ? 3 : ue > 191 ? 2 : 1
        if (ee + et <= v) {
          let bt, at, Pt, R
          switch (et) {
            case 1:
              ue < 128 && (Z = ue)
              break
            case 2:
              ;(bt = O[ee + 1]), (bt & 192) === 128 && ((R = ((ue & 31) << 6) | (bt & 63)), R > 127 && (Z = R))
              break
            case 3:
              ;(bt = O[ee + 1]),
                (at = O[ee + 2]),
                (bt & 192) === 128 &&
                  (at & 192) === 128 &&
                  ((R = ((ue & 15) << 12) | ((bt & 63) << 6) | (at & 63)),
                  R > 2047 && (R < 55296 || R > 57343) && (Z = R))
              break
            case 4:
              ;(bt = O[ee + 1]),
                (at = O[ee + 2]),
                (Pt = O[ee + 3]),
                (bt & 192) === 128 &&
                  (at & 192) === 128 &&
                  (Pt & 192) === 128 &&
                  ((R = ((ue & 15) << 18) | ((bt & 63) << 12) | ((at & 63) << 6) | (Pt & 63)),
                  R > 65535 && R < 1114112 && (Z = R))
          }
        }
        Z === null
          ? ((Z = 65533), (et = 1))
          : Z > 65535 && ((Z -= 65536), z.push(((Z >>> 10) & 1023) | 55296), (Z = 56320 | (Z & 1023))),
          z.push(Z),
          (ee += et)
      }
      return X(z)
    }
    const J = 4096
    function X(O) {
      const g = O.length
      if (g <= J) return String.fromCharCode.apply(String, O)
      let v = '',
        z = 0
      for (; z < g; ) v += String.fromCharCode.apply(String, O.slice(z, (z += J)))
      return v
    }
    function G(O, g, v) {
      let z = ''
      v = Math.min(O.length, v)
      for (let ee = g; ee < v; ++ee) z += String.fromCharCode(O[ee] & 127)
      return z
    }
    function Te(O, g, v) {
      let z = ''
      v = Math.min(O.length, v)
      for (let ee = g; ee < v; ++ee) z += String.fromCharCode(O[ee])
      return z
    }
    function ce(O, g, v) {
      const z = O.length
      ;(!g || g < 0) && (g = 0), (!v || v < 0 || v > z) && (v = z)
      let ee = ''
      for (let ue = g; ue < v; ++ue) ee += xe[O[ue]]
      return ee
    }
    function se(O, g, v) {
      const z = O.slice(g, v)
      let ee = ''
      for (let ue = 0; ue < z.length - 1; ue += 2) ee += String.fromCharCode(z[ue] + z[ue + 1] * 256)
      return ee
    }
    o.prototype.slice = function (g, v) {
      const z = this.length
      ;(g = ~~g),
        (v = v === void 0 ? z : ~~v),
        g < 0 ? ((g += z), g < 0 && (g = 0)) : g > z && (g = z),
        v < 0 ? ((v += z), v < 0 && (v = 0)) : v > z && (v = z),
        v < g && (v = g)
      const ee = this.subarray(g, v)
      return Object.setPrototypeOf(ee, o.prototype), ee
    }
    function U(O, g, v) {
      if (O % 1 !== 0 || O < 0) throw new RangeError('offset is not uint')
      if (O + g > v) throw new RangeError('Trying to access beyond buffer length')
    }
    ;(o.prototype.readUintLE = o.prototype.readUIntLE =
      function (g, v, z) {
        ;(g = g >>> 0), (v = v >>> 0), z || U(g, v, this.length)
        let ee = this[g],
          ue = 1,
          Z = 0
        for (; ++Z < v && (ue *= 256); ) ee += this[g + Z] * ue
        return ee
      }),
      (o.prototype.readUintBE = o.prototype.readUIntBE =
        function (g, v, z) {
          ;(g = g >>> 0), (v = v >>> 0), z || U(g, v, this.length)
          let ee = this[g + --v],
            ue = 1
          for (; v > 0 && (ue *= 256); ) ee += this[g + --v] * ue
          return ee
        }),
      (o.prototype.readUint8 = o.prototype.readUInt8 =
        function (g, v) {
          return (g = g >>> 0), v || U(g, 1, this.length), this[g]
        }),
      (o.prototype.readUint16LE = o.prototype.readUInt16LE =
        function (g, v) {
          return (g = g >>> 0), v || U(g, 2, this.length), this[g] | (this[g + 1] << 8)
        }),
      (o.prototype.readUint16BE = o.prototype.readUInt16BE =
        function (g, v) {
          return (g = g >>> 0), v || U(g, 2, this.length), (this[g] << 8) | this[g + 1]
        }),
      (o.prototype.readUint32LE = o.prototype.readUInt32LE =
        function (g, v) {
          return (
            (g = g >>> 0),
            v || U(g, 4, this.length),
            (this[g] | (this[g + 1] << 8) | (this[g + 2] << 16)) + this[g + 3] * 16777216
          )
        }),
      (o.prototype.readUint32BE = o.prototype.readUInt32BE =
        function (g, v) {
          return (
            (g = g >>> 0),
            v || U(g, 4, this.length),
            this[g] * 16777216 + ((this[g + 1] << 16) | (this[g + 2] << 8) | this[g + 3])
          )
        }),
      (o.prototype.readBigUInt64LE = Ae(function (g) {
        ;(g = g >>> 0), We(g, 'offset')
        const v = this[g],
          z = this[g + 7]
        ;(v === void 0 || z === void 0) && A(g, this.length - 8)
        const ee = v + this[++g] * 2 ** 8 + this[++g] * 2 ** 16 + this[++g] * 2 ** 24,
          ue = this[++g] + this[++g] * 2 ** 8 + this[++g] * 2 ** 16 + z * 2 ** 24
        return BigInt(ee) + (BigInt(ue) << BigInt(32))
      })),
      (o.prototype.readBigUInt64BE = Ae(function (g) {
        ;(g = g >>> 0), We(g, 'offset')
        const v = this[g],
          z = this[g + 7]
        ;(v === void 0 || z === void 0) && A(g, this.length - 8)
        const ee = v * 2 ** 24 + this[++g] * 2 ** 16 + this[++g] * 2 ** 8 + this[++g],
          ue = this[++g] * 2 ** 24 + this[++g] * 2 ** 16 + this[++g] * 2 ** 8 + z
        return (BigInt(ee) << BigInt(32)) + BigInt(ue)
      })),
      (o.prototype.readIntLE = function (g, v, z) {
        ;(g = g >>> 0), (v = v >>> 0), z || U(g, v, this.length)
        let ee = this[g],
          ue = 1,
          Z = 0
        for (; ++Z < v && (ue *= 256); ) ee += this[g + Z] * ue
        return (ue *= 128), ee >= ue && (ee -= Math.pow(2, 8 * v)), ee
      }),
      (o.prototype.readIntBE = function (g, v, z) {
        ;(g = g >>> 0), (v = v >>> 0), z || U(g, v, this.length)
        let ee = v,
          ue = 1,
          Z = this[g + --ee]
        for (; ee > 0 && (ue *= 256); ) Z += this[g + --ee] * ue
        return (ue *= 128), Z >= ue && (Z -= Math.pow(2, 8 * v)), Z
      }),
      (o.prototype.readInt8 = function (g, v) {
        return (g = g >>> 0), v || U(g, 1, this.length), this[g] & 128 ? (255 - this[g] + 1) * -1 : this[g]
      }),
      (o.prototype.readInt16LE = function (g, v) {
        ;(g = g >>> 0), v || U(g, 2, this.length)
        const z = this[g] | (this[g + 1] << 8)
        return z & 32768 ? z | 4294901760 : z
      }),
      (o.prototype.readInt16BE = function (g, v) {
        ;(g = g >>> 0), v || U(g, 2, this.length)
        const z = this[g + 1] | (this[g] << 8)
        return z & 32768 ? z | 4294901760 : z
      }),
      (o.prototype.readInt32LE = function (g, v) {
        return (
          (g = g >>> 0),
          v || U(g, 4, this.length),
          this[g] | (this[g + 1] << 8) | (this[g + 2] << 16) | (this[g + 3] << 24)
        )
      }),
      (o.prototype.readInt32BE = function (g, v) {
        return (
          (g = g >>> 0),
          v || U(g, 4, this.length),
          (this[g] << 24) | (this[g + 1] << 16) | (this[g + 2] << 8) | this[g + 3]
        )
      }),
      (o.prototype.readBigInt64LE = Ae(function (g) {
        ;(g = g >>> 0), We(g, 'offset')
        const v = this[g],
          z = this[g + 7]
        ;(v === void 0 || z === void 0) && A(g, this.length - 8)
        const ee = this[g + 4] + this[g + 5] * 2 ** 8 + this[g + 6] * 2 ** 16 + (z << 24)
        return (BigInt(ee) << BigInt(32)) + BigInt(v + this[++g] * 2 ** 8 + this[++g] * 2 ** 16 + this[++g] * 2 ** 24)
      })),
      (o.prototype.readBigInt64BE = Ae(function (g) {
        ;(g = g >>> 0), We(g, 'offset')
        const v = this[g],
          z = this[g + 7]
        ;(v === void 0 || z === void 0) && A(g, this.length - 8)
        const ee = (v << 24) + this[++g] * 2 ** 16 + this[++g] * 2 ** 8 + this[++g]
        return (BigInt(ee) << BigInt(32)) + BigInt(this[++g] * 2 ** 24 + this[++g] * 2 ** 16 + this[++g] * 2 ** 8 + z)
      })),
      (o.prototype.readFloatLE = function (g, v) {
        return (g = g >>> 0), v || U(g, 4, this.length), r.read(this, g, !0, 23, 4)
      }),
      (o.prototype.readFloatBE = function (g, v) {
        return (g = g >>> 0), v || U(g, 4, this.length), r.read(this, g, !1, 23, 4)
      }),
      (o.prototype.readDoubleLE = function (g, v) {
        return (g = g >>> 0), v || U(g, 8, this.length), r.read(this, g, !0, 52, 8)
      }),
      (o.prototype.readDoubleBE = function (g, v) {
        return (g = g >>> 0), v || U(g, 8, this.length), r.read(this, g, !1, 52, 8)
      })
    function W(O, g, v, z, ee, ue) {
      if (!o.isBuffer(O)) throw new TypeError('"buffer" argument must be a Buffer instance')
      if (g > ee || g < ue) throw new RangeError('"value" argument is out of bounds')
      if (v + z > O.length) throw new RangeError('Index out of range')
    }
    ;(o.prototype.writeUintLE = o.prototype.writeUIntLE =
      function (g, v, z, ee) {
        if (((g = +g), (v = v >>> 0), (z = z >>> 0), !ee)) {
          const et = Math.pow(2, 8 * z) - 1
          W(this, g, v, z, et, 0)
        }
        let ue = 1,
          Z = 0
        for (this[v] = g & 255; ++Z < z && (ue *= 256); ) this[v + Z] = (g / ue) & 255
        return v + z
      }),
      (o.prototype.writeUintBE = o.prototype.writeUIntBE =
        function (g, v, z, ee) {
          if (((g = +g), (v = v >>> 0), (z = z >>> 0), !ee)) {
            const et = Math.pow(2, 8 * z) - 1
            W(this, g, v, z, et, 0)
          }
          let ue = z - 1,
            Z = 1
          for (this[v + ue] = g & 255; --ue >= 0 && (Z *= 256); ) this[v + ue] = (g / Z) & 255
          return v + z
        }),
      (o.prototype.writeUint8 = o.prototype.writeUInt8 =
        function (g, v, z) {
          return (g = +g), (v = v >>> 0), z || W(this, g, v, 1, 255, 0), (this[v] = g & 255), v + 1
        }),
      (o.prototype.writeUint16LE = o.prototype.writeUInt16LE =
        function (g, v, z) {
          return (
            (g = +g),
            (v = v >>> 0),
            z || W(this, g, v, 2, 65535, 0),
            (this[v] = g & 255),
            (this[v + 1] = g >>> 8),
            v + 2
          )
        }),
      (o.prototype.writeUint16BE = o.prototype.writeUInt16BE =
        function (g, v, z) {
          return (
            (g = +g),
            (v = v >>> 0),
            z || W(this, g, v, 2, 65535, 0),
            (this[v] = g >>> 8),
            (this[v + 1] = g & 255),
            v + 2
          )
        }),
      (o.prototype.writeUint32LE = o.prototype.writeUInt32LE =
        function (g, v, z) {
          return (
            (g = +g),
            (v = v >>> 0),
            z || W(this, g, v, 4, 4294967295, 0),
            (this[v + 3] = g >>> 24),
            (this[v + 2] = g >>> 16),
            (this[v + 1] = g >>> 8),
            (this[v] = g & 255),
            v + 4
          )
        }),
      (o.prototype.writeUint32BE = o.prototype.writeUInt32BE =
        function (g, v, z) {
          return (
            (g = +g),
            (v = v >>> 0),
            z || W(this, g, v, 4, 4294967295, 0),
            (this[v] = g >>> 24),
            (this[v + 1] = g >>> 16),
            (this[v + 2] = g >>> 8),
            (this[v + 3] = g & 255),
            v + 4
          )
        })
    function ge(O, g, v, z, ee) {
      Le(g, z, ee, O, v, 7)
      let ue = Number(g & BigInt(4294967295))
      ;(O[v++] = ue), (ue = ue >> 8), (O[v++] = ue), (ue = ue >> 8), (O[v++] = ue), (ue = ue >> 8), (O[v++] = ue)
      let Z = Number((g >> BigInt(32)) & BigInt(4294967295))
      return (O[v++] = Z), (Z = Z >> 8), (O[v++] = Z), (Z = Z >> 8), (O[v++] = Z), (Z = Z >> 8), (O[v++] = Z), v
    }
    function ye(O, g, v, z, ee) {
      Le(g, z, ee, O, v, 7)
      let ue = Number(g & BigInt(4294967295))
      ;(O[v + 7] = ue),
        (ue = ue >> 8),
        (O[v + 6] = ue),
        (ue = ue >> 8),
        (O[v + 5] = ue),
        (ue = ue >> 8),
        (O[v + 4] = ue)
      let Z = Number((g >> BigInt(32)) & BigInt(4294967295))
      return (O[v + 3] = Z), (Z = Z >> 8), (O[v + 2] = Z), (Z = Z >> 8), (O[v + 1] = Z), (Z = Z >> 8), (O[v] = Z), v + 8
    }
    ;(o.prototype.writeBigUInt64LE = Ae(function (g, v = 0) {
      return ge(this, g, v, BigInt(0), BigInt('0xffffffffffffffff'))
    })),
      (o.prototype.writeBigUInt64BE = Ae(function (g, v = 0) {
        return ye(this, g, v, BigInt(0), BigInt('0xffffffffffffffff'))
      })),
      (o.prototype.writeIntLE = function (g, v, z, ee) {
        if (((g = +g), (v = v >>> 0), !ee)) {
          const bt = Math.pow(2, 8 * z - 1)
          W(this, g, v, z, bt - 1, -bt)
        }
        let ue = 0,
          Z = 1,
          et = 0
        for (this[v] = g & 255; ++ue < z && (Z *= 256); )
          g < 0 && et === 0 && this[v + ue - 1] !== 0 && (et = 1), (this[v + ue] = (((g / Z) >> 0) - et) & 255)
        return v + z
      }),
      (o.prototype.writeIntBE = function (g, v, z, ee) {
        if (((g = +g), (v = v >>> 0), !ee)) {
          const bt = Math.pow(2, 8 * z - 1)
          W(this, g, v, z, bt - 1, -bt)
        }
        let ue = z - 1,
          Z = 1,
          et = 0
        for (this[v + ue] = g & 255; --ue >= 0 && (Z *= 256); )
          g < 0 && et === 0 && this[v + ue + 1] !== 0 && (et = 1), (this[v + ue] = (((g / Z) >> 0) - et) & 255)
        return v + z
      }),
      (o.prototype.writeInt8 = function (g, v, z) {
        return (
          (g = +g),
          (v = v >>> 0),
          z || W(this, g, v, 1, 127, -128),
          g < 0 && (g = 255 + g + 1),
          (this[v] = g & 255),
          v + 1
        )
      }),
      (o.prototype.writeInt16LE = function (g, v, z) {
        return (
          (g = +g),
          (v = v >>> 0),
          z || W(this, g, v, 2, 32767, -32768),
          (this[v] = g & 255),
          (this[v + 1] = g >>> 8),
          v + 2
        )
      }),
      (o.prototype.writeInt16BE = function (g, v, z) {
        return (
          (g = +g),
          (v = v >>> 0),
          z || W(this, g, v, 2, 32767, -32768),
          (this[v] = g >>> 8),
          (this[v + 1] = g & 255),
          v + 2
        )
      }),
      (o.prototype.writeInt32LE = function (g, v, z) {
        return (
          (g = +g),
          (v = v >>> 0),
          z || W(this, g, v, 4, 2147483647, -2147483648),
          (this[v] = g & 255),
          (this[v + 1] = g >>> 8),
          (this[v + 2] = g >>> 16),
          (this[v + 3] = g >>> 24),
          v + 4
        )
      }),
      (o.prototype.writeInt32BE = function (g, v, z) {
        return (
          (g = +g),
          (v = v >>> 0),
          z || W(this, g, v, 4, 2147483647, -2147483648),
          g < 0 && (g = 4294967295 + g + 1),
          (this[v] = g >>> 24),
          (this[v + 1] = g >>> 16),
          (this[v + 2] = g >>> 8),
          (this[v + 3] = g & 255),
          v + 4
        )
      }),
      (o.prototype.writeBigInt64LE = Ae(function (g, v = 0) {
        return ge(this, g, v, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
      })),
      (o.prototype.writeBigInt64BE = Ae(function (g, v = 0) {
        return ye(this, g, v, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
      }))
    function me(O, g, v, z, ee, ue) {
      if (v + z > O.length) throw new RangeError('Index out of range')
      if (v < 0) throw new RangeError('Index out of range')
    }
    function ke(O, g, v, z, ee) {
      return (g = +g), (v = v >>> 0), ee || me(O, g, v, 4), r.write(O, g, v, z, 23, 4), v + 4
    }
    ;(o.prototype.writeFloatLE = function (g, v, z) {
      return ke(this, g, v, !0, z)
    }),
      (o.prototype.writeFloatBE = function (g, v, z) {
        return ke(this, g, v, !1, z)
      })
    function ae(O, g, v, z, ee) {
      return (g = +g), (v = v >>> 0), ee || me(O, g, v, 8), r.write(O, g, v, z, 52, 8), v + 8
    }
    ;(o.prototype.writeDoubleLE = function (g, v, z) {
      return ae(this, g, v, !0, z)
    }),
      (o.prototype.writeDoubleBE = function (g, v, z) {
        return ae(this, g, v, !1, z)
      }),
      (o.prototype.copy = function (g, v, z, ee) {
        if (!o.isBuffer(g)) throw new TypeError('argument should be a Buffer')
        if (
          (z || (z = 0),
          !ee && ee !== 0 && (ee = this.length),
          v >= g.length && (v = g.length),
          v || (v = 0),
          ee > 0 && ee < z && (ee = z),
          ee === z || g.length === 0 || this.length === 0)
        )
          return 0
        if (v < 0) throw new RangeError('targetStart out of bounds')
        if (z < 0 || z >= this.length) throw new RangeError('Index out of range')
        if (ee < 0) throw new RangeError('sourceEnd out of bounds')
        ee > this.length && (ee = this.length), g.length - v < ee - z && (ee = g.length - v + z)
        const ue = ee - z
        return (
          this === g && typeof Uint8Array.prototype.copyWithin == 'function'
            ? this.copyWithin(v, z, ee)
            : Uint8Array.prototype.set.call(g, this.subarray(z, ee), v),
          ue
        )
      }),
      (o.prototype.fill = function (g, v, z, ee) {
        if (typeof g == 'string') {
          if (
            (typeof v == 'string'
              ? ((ee = v), (v = 0), (z = this.length))
              : typeof z == 'string' && ((ee = z), (z = this.length)),
            ee !== void 0 && typeof ee != 'string')
          )
            throw new TypeError('encoding must be a string')
          if (typeof ee == 'string' && !o.isEncoding(ee)) throw new TypeError('Unknown encoding: ' + ee)
          if (g.length === 1) {
            const Z = g.charCodeAt(0)
            ;((ee === 'utf8' && Z < 128) || ee === 'latin1') && (g = Z)
          }
        } else typeof g == 'number' ? (g = g & 255) : typeof g == 'boolean' && (g = Number(g))
        if (v < 0 || this.length < v || this.length < z) throw new RangeError('Out of range index')
        if (z <= v) return this
        ;(v = v >>> 0), (z = z === void 0 ? this.length : z >>> 0), g || (g = 0)
        let ue
        if (typeof g == 'number') for (ue = v; ue < z; ++ue) this[ue] = g
        else {
          const Z = o.isBuffer(g) ? g : o.from(g, ee),
            et = Z.length
          if (et === 0) throw new TypeError('The value "' + g + '" is invalid for argument "value"')
          for (ue = 0; ue < z - v; ++ue) this[ue + v] = Z[ue % et]
        }
        return this
      })
    const de = {}
    function be(O, g, v) {
      de[O] = class extends v {
        constructor() {
          super(),
            Object.defineProperty(this, 'message', { value: g.apply(this, arguments), writable: !0, configurable: !0 }),
            (this.name = `${this.name} [${O}]`),
            this.stack,
            delete this.name
        }
        get code() {
          return O
        }
        set code(ee) {
          Object.defineProperty(this, 'code', { configurable: !0, enumerable: !0, value: ee, writable: !0 })
        }
        toString() {
          return `${this.name} [${O}]: ${this.message}`
        }
      }
    }
    be(
      'ERR_BUFFER_OUT_OF_BOUNDS',
      function (O) {
        return O ? `${O} is outside of buffer bounds` : 'Attempt to access memory outside buffer bounds'
      },
      RangeError
    ),
      be(
        'ERR_INVALID_ARG_TYPE',
        function (O, g) {
          return `The "${O}" argument must be of type number. Received type ${typeof g}`
        },
        TypeError
      ),
      be(
        'ERR_OUT_OF_RANGE',
        function (O, g, v) {
          let z = `The value of "${O}" is out of range.`,
            ee = v
          return (
            Number.isInteger(v) && Math.abs(v) > 2 ** 32
              ? (ee = Pe(String(v)))
              : typeof v == 'bigint' &&
                ((ee = String(v)),
                (v > BigInt(2) ** BigInt(32) || v < -(BigInt(2) ** BigInt(32))) && (ee = Pe(ee)),
                (ee += 'n')),
            (z += ` It must be ${g}. Received ${ee}`),
            z
          )
        },
        RangeError
      )
    function Pe(O) {
      let g = '',
        v = O.length
      const z = O[0] === '-' ? 1 : 0
      for (; v >= z + 4; v -= 3) g = `_${O.slice(v - 3, v)}${g}`
      return `${O.slice(0, v)}${g}`
    }
    function De(O, g, v) {
      We(g, 'offset'), (O[g] === void 0 || O[g + v] === void 0) && A(g, O.length - (v + 1))
    }
    function Le(O, g, v, z, ee, ue) {
      if (O > v || O < g) {
        const Z = typeof g == 'bigint' ? 'n' : ''
        let et
        throw (
          (ue > 3
            ? g === 0 || g === BigInt(0)
              ? (et = `>= 0${Z} and < 2${Z} ** ${(ue + 1) * 8}${Z}`)
              : (et = `>= -(2${Z} ** ${(ue + 1) * 8 - 1}${Z}) and < 2 ** ${(ue + 1) * 8 - 1}${Z}`)
            : (et = `>= ${g}${Z} and <= ${v}${Z}`),
          new de.ERR_OUT_OF_RANGE('value', et, O))
        )
      }
      De(z, ee, ue)
    }
    function We(O, g) {
      if (typeof O != 'number') throw new de.ERR_INVALID_ARG_TYPE(g, 'number', O)
    }
    function A(O, g, v) {
      throw Math.floor(O) !== O
        ? (We(O, v), new de.ERR_OUT_OF_RANGE(v || 'offset', 'an integer', O))
        : g < 0
        ? new de.ERR_BUFFER_OUT_OF_BOUNDS()
        : new de.ERR_OUT_OF_RANGE(v || 'offset', `>= ${v ? 1 : 0} and <= ${g}`, O)
    }
    const pe = /[^+/0-9A-Za-z-_]/g
    function ie(O) {
      if (((O = O.split('=')[0]), (O = O.trim().replace(pe, '')), O.length < 2)) return ''
      for (; O.length % 4 !== 0; ) O = O + '='
      return O
    }
    function L(O, g) {
      g = g || 1 / 0
      let v
      const z = O.length
      let ee = null
      const ue = []
      for (let Z = 0; Z < z; ++Z) {
        if (((v = O.charCodeAt(Z)), v > 55295 && v < 57344)) {
          if (!ee) {
            if (v > 56319) {
              ;(g -= 3) > -1 && ue.push(239, 191, 189)
              continue
            } else if (Z + 1 === z) {
              ;(g -= 3) > -1 && ue.push(239, 191, 189)
              continue
            }
            ee = v
            continue
          }
          if (v < 56320) {
            ;(g -= 3) > -1 && ue.push(239, 191, 189), (ee = v)
            continue
          }
          v = (((ee - 55296) << 10) | (v - 56320)) + 65536
        } else ee && (g -= 3) > -1 && ue.push(239, 191, 189)
        if (((ee = null), v < 128)) {
          if ((g -= 1) < 0) break
          ue.push(v)
        } else if (v < 2048) {
          if ((g -= 2) < 0) break
          ue.push((v >> 6) | 192, (v & 63) | 128)
        } else if (v < 65536) {
          if ((g -= 3) < 0) break
          ue.push((v >> 12) | 224, ((v >> 6) & 63) | 128, (v & 63) | 128)
        } else if (v < 1114112) {
          if ((g -= 4) < 0) break
          ue.push((v >> 18) | 240, ((v >> 12) & 63) | 128, ((v >> 6) & 63) | 128, (v & 63) | 128)
        } else throw new Error('Invalid code point')
      }
      return ue
    }
    function F(O) {
      const g = []
      for (let v = 0; v < O.length; ++v) g.push(O.charCodeAt(v) & 255)
      return g
    }
    function q(O, g) {
      let v, z, ee
      const ue = []
      for (let Z = 0; Z < O.length && !((g -= 2) < 0); ++Z)
        (v = O.charCodeAt(Z)), (z = v >> 8), (ee = v % 256), ue.push(ee), ue.push(z)
      return ue
    }
    function le(O) {
      return e.toByteArray(ie(O))
    }
    function fe(O, g, v, z) {
      let ee
      for (ee = 0; ee < z && !(ee + v >= g.length || ee >= O.length); ++ee) g[ee + v] = O[ee]
      return ee
    }
    function ne(O, g) {
      return (
        O instanceof g ||
        (O != null && O.constructor != null && O.constructor.name != null && O.constructor.name === g.name)
      )
    }
    function Se(O) {
      return O !== O
    }
    const xe = (function () {
      const O = '0123456789abcdef',
        g = new Array(256)
      for (let v = 0; v < 16; ++v) {
        const z = v * 16
        for (let ee = 0; ee < 16; ++ee) g[z + ee] = O[v] + O[ee]
      }
      return g
    })()
    function Ae(O) {
      return typeof BigInt == 'undefined' ? Re : O
    }
    function Re() {
      throw new Error('BigInt not supported')
    }
  })(yS),
    (window.Buffer = yS.Buffer),
    (pi.default = Gie),
    Object.defineProperties(pi, { __esModule: { value: !0 }, [Symbol.toStringTag]: { value: 'Module' } })
})
