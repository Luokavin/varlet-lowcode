;(function () {
  var style = document.createElement('style')
  style.type = 'text/css'
  style.rel = 'stylesheet'
  style.appendChild(
    document.createTextNode(`.var--box,.var--box *{box-sizing:border-box}.var--relative{position:relative}.var--absolute{position:absolute}.var--hidden,.var--lock{overflow:hidden}.var--box,.var--box *{box-sizing:border-box}.var--relative{position:relative}.var--absolute{position:absolute}.var--hidden,.var--lock{overflow:hidden}.var--block{display:block}.var--ellipsis{overflow-x:hidden;text-overflow:ellipsis;white-space:nowrap}.var--inline-block{display:inline-block}.var--flex{display:flex}.var--inline-flex{display:inline-flex}:root{--font-size-xs: 10px;--font-size-sm: 12px;--font-size-md: 14px;--font-size-lg: 16px;--icon-size-xs: 16px;--icon-size-sm: 18px;--icon-size-md: 20px;--icon-size-lg: 22px;--color-body: #fff;--color-text: #333;--color-primary: #3a7afe;--color-info: #00afef;--color-success: #00c48f;--color-warning: #ff9f00;--color-danger: #f44336;--color-disabled: #e0e0e0;--color-text-disabled: #aaa;--cubic-bezier: cubic-bezier(.25, .8, .5, 1);--shadow-key-umbra-opacity: rgba(0, 0, 0, .2);--shadow-key-penumbra-opacity: rgba(0, 0, 0, .14);--shadow-key-ambient-opacity: rgba(0, 0, 0, .12)}.var-elevation--0{box-shadow:0 0 0 0 var(--shadow-key-umbra-opacity),0 0 0 0 var(--shadow-key-penumbra-opacity),0 0 0 0 var(--shadow-key-ambient-opacity)}.var-elevation--1{box-shadow:0 2px 1px -1px var(--shadow-key-umbra-opacity),0 1px 1px 0 var(--shadow-key-penumbra-opacity),0 1px 3px 0 var(--shadow-key-ambient-opacity)}.var-elevation--2{box-shadow:0 3px 1px -2px var(--shadow-key-umbra-opacity),0 2px 2px 0 var(--shadow-key-penumbra-opacity),0 1px 5px 0 var(--shadow-key-ambient-opacity)}.var-elevation--3{box-shadow:0 3px 3px -2px var(--shadow-key-umbra-opacity),0 3px 4px 0 var(--shadow-key-penumbra-opacity),0 1px 8px 0 var(--shadow-key-ambient-opacity)}.var-elevation--4{box-shadow:0 2px 4px -1px var(--shadow-key-umbra-opacity),0 4px 5px 0 var(--shadow-key-penumbra-opacity),0 1px 10px 0 var(--shadow-key-ambient-opacity)}.var-elevation--5{box-shadow:0 3px 5px -1px var(--shadow-key-umbra-opacity),0 5px 8px 0 var(--shadow-key-penumbra-opacity),0 1px 14px 0 var(--shadow-key-ambient-opacity)}.var-elevation--6{box-shadow:0 3px 5px -1px var(--shadow-key-umbra-opacity),0 6px 10px 0 var(--shadow-key-penumbra-opacity),0 1px 18px 0 var(--shadow-key-ambient-opacity)}.var-elevation--7{box-shadow:0 4px 5px -2px var(--shadow-key-umbra-opacity),0 7px 10px 1px var(--shadow-key-penumbra-opacity),0 2px 16px 1px var(--shadow-key-ambient-opacity)}.var-elevation--8{box-shadow:0 5px 5px -3px var(--shadow-key-umbra-opacity),0 8px 10px 1px var(--shadow-key-penumbra-opacity),0 3px 14px 2px var(--shadow-key-ambient-opacity)}.var-elevation--9{box-shadow:0 5px 6px -3px var(--shadow-key-umbra-opacity),0 9px 12px 1px var(--shadow-key-penumbra-opacity),0 3px 16px 2px var(--shadow-key-ambient-opacity)}.var-elevation--10{box-shadow:0 6px 6px -3px var(--shadow-key-umbra-opacity),0 10px 14px 1px var(--shadow-key-penumbra-opacity),0 4px 18px 3px var(--shadow-key-ambient-opacity)}.var-elevation--11{box-shadow:0 6px 7px -4px var(--shadow-key-umbra-opacity),0 11px 15px 1px var(--shadow-key-penumbra-opacity),0 4px 20px 3px var(--shadow-key-ambient-opacity)}.var-elevation--12{box-shadow:0 7px 8px -4px var(--shadow-key-umbra-opacity),0 12px 17px 2px var(--shadow-key-penumbra-opacity),0 5px 22px 4px var(--shadow-key-ambient-opacity)}.var-elevation--13{box-shadow:0 7px 8px -4px var(--shadow-key-umbra-opacity),0 13px 19px 2px var(--shadow-key-penumbra-opacity),0 5px 24px 4px var(--shadow-key-ambient-opacity)}.var-elevation--14{box-shadow:0 7px 9px -4px var(--shadow-key-umbra-opacity),0 14px 21px 2px var(--shadow-key-penumbra-opacity),0 5px 26px 4px var(--shadow-key-ambient-opacity)}.var-elevation--15{box-shadow:0 8px 9px -5px var(--shadow-key-umbra-opacity),0 15px 22px 2px var(--shadow-key-penumbra-opacity),0 6px 28px 5px var(--shadow-key-ambient-opacity)}.var-elevation--16{box-shadow:0 8px 10px -5px var(--shadow-key-umbra-opacity),0 16px 24px 2px var(--shadow-key-penumbra-opacity),0 6px 30px 5px var(--shadow-key-ambient-opacity)}.var-elevation--17{box-shadow:0 8px 11px -5px var(--shadow-key-umbra-opacity),0 17px 26px 2px var(--shadow-key-penumbra-opacity),0 6px 32px 5px var(--shadow-key-ambient-opacity)}.var-elevation--18{box-shadow:0 9px 11px -5px var(--shadow-key-umbra-opacity),0 18px 28px 2px var(--shadow-key-penumbra-opacity),0 7px 34px 6px var(--shadow-key-ambient-opacity)}.var-elevation--19{box-shadow:0 9px 12px -6px var(--shadow-key-umbra-opacity),0 19px 29px 2px var(--shadow-key-penumbra-opacity),0 7px 36px 6px var(--shadow-key-ambient-opacity)}.var-elevation--20{box-shadow:0 10px 13px -6px var(--shadow-key-umbra-opacity),0 20px 31px 3px var(--shadow-key-penumbra-opacity),0 8px 38px 7px var(--shadow-key-ambient-opacity)}.var-elevation--21{box-shadow:0 10px 13px -6px var(--shadow-key-umbra-opacity),0 21px 33px 3px var(--shadow-key-penumbra-opacity),0 8px 40px 7px var(--shadow-key-ambient-opacity)}.var-elevation--22{box-shadow:0 10px 14px -6px var(--shadow-key-umbra-opacity),0 22px 35px 3px var(--shadow-key-penumbra-opacity),0 8px 42px 7px var(--shadow-key-ambient-opacity)}.var-elevation--23{box-shadow:0 11px 14px -7px var(--shadow-key-umbra-opacity),0 23px 36px 3px var(--shadow-key-penumbra-opacity),0 9px 44px 8px var(--shadow-key-ambient-opacity)}.var-elevation--24{box-shadow:0 11px 15px -7px var(--shadow-key-umbra-opacity),0 24px 38px 3px var(--shadow-key-penumbra-opacity),0 9px 46px 8px var(--shadow-key-ambient-opacity)}:root{--ripple-cubic-bezier: cubic-bezier(.68, .01, .62, .6);--ripple-color: currentColor}.var-ripple{position:absolute;transition:transform .2s var(--ripple-cubic-bezier),opacity .14s linear;top:0;left:0;border-radius:50%;opacity:0;will-change:transform,opacity;pointer-events:none;z-index:100;background-color:var(--ripple-color)}:root{--loading-opacity: .38;--loading-desc-margin: 8px 0 0}.var-loading{position:relative}.var-loading__content{position:relative;transition:opacity .3s;opacity:1}.var-loading__content--active{opacity:var(--loading-opacity)}.var-loading__content-mask{position:absolute;left:0;right:0;top:0;bottom:0}.var-loading__body{display:flex;justify-content:center;align-items:center;height:100%;flex-direction:column}.var-loading__inside{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);z-index:1}.var-loading__description{color:currentColor;margin:var(--loading-desc-margin)}.var-loading__description--large{font-size:16px}.var-loading__description--normal{font-size:14px}.var-loading__description--small{font-size:12px}.var-loading__description--mini{font-size:10px}.var-loading__circle{display:flex}.var-loading__circle-block{display:inline-block;animation:circle 1.8s linear infinite}.var-loading__circle-block--large{width:36px;height:36px}.var-loading__circle-block--normal{width:30px;height:30px}.var-loading__circle-block--small{width:24px;height:24px}.var-loading__circle-block--mini{width:18px;height:18px}.var-loading__circle-block svg{display:block;width:100%;height:100%}.var-loading__circle-block svg circle{animation:circular 1.5s ease-in-out infinite;stroke:currentColor;stroke-width:3;stroke-linecap:round}@keyframes circle{0%{transform:rotate(0)}to{transform:rotate(360deg)}}@keyframes circular{0%{stroke-dasharray:1,200;stroke-dashoffset:0}50%{stroke-dasharray:90,150;stroke-dashoffset:-40}to{stroke-dasharray:90,150;stroke-dashoffset:-120}}.var-loading__wave{display:flex;align-items:center;justify-content:center}.var-loading__wave--large{width:64px;height:18px}.var-loading__wave--normal{width:50px;height:16px}.var-loading__wave--small{width:36px;height:14px}.var-loading__wave--mini{width:22px;height:12px}.var-loading__wave-item{height:100%;display:inline-block;animation:1.2s ease-in-out infinite wave}.var-loading__wave-item:nth-child(1){animation-delay:-1.2s;margin-left:0}.var-loading__wave-item:nth-child(2){animation-delay:-1.1s}.var-loading__wave-item:nth-child(3){animation-delay:-1s}.var-loading__wave-item:nth-child(4){animation-delay:-.9s}.var-loading__wave-item:nth-child(5){animation-delay:-.8s}.var-loading__wave-item--large{width:5px;margin-left:5px}.var-loading__wave-item--normal{width:4px;margin-left:4px}.var-loading__wave-item--small{width:3px;margin-left:3px}.var-loading__wave-item--mini{width:2px;margin-left:2px}@keyframes wave{0%,40%,to{transform:scaleY(.4)}20%{transform:scaleY(1)}}.var-loading__cube{display:flex;align-items:center}.var-loading__cube--large{width:64px;height:18px}.var-loading__cube--normal{width:50px;height:16px}.var-loading__cube--small{width:36px;height:14px}.var-loading__cube--mini{width:22px;height:12px}.var-loading__cube-item{display:inline-block;transform-origin:right bottom;animation:1.5s ease infinite cube}.var-loading__cube-item:nth-child(1){animation-delay:.2s;margin-left:0}.var-loading__cube-item:nth-child(2){animation-delay:.4s}.var-loading__cube-item:nth-child(3){animation-delay:.6s}.var-loading__cube-item:nth-child(4){animation-delay:.8s}.var-loading__cube-item--large{height:10px;width:10px;margin-left:5px}.var-loading__cube-item--normal{height:8px;width:8px;margin-left:4px}.var-loading__cube-item--small{height:6px;width:6px;margin-left:3px}.var-loading__cube-item--mini{height:4px;width:4px;margin-left:2px}@keyframes cube{0%{opacity:1;transform:scale(1)}to{opacity:0;transform:rotate(90deg) scale(.3)}}.var-loading__rect{display:flex;flex-wrap:nowrap;justify-content:center;align-items:center}.var-loading__rect--large{width:64px;height:18px}.var-loading__rect--normal{width:50px;height:16px}.var-loading__rect--small{width:36px;height:14px}.var-loading__rect--mini{width:22px;height:12px}.var-loading__rect-item{animation:2s ease-in-out infinite rect}.var-loading__rect-item:nth-child(1){animation-delay:1.75s}.var-loading__rect-item:nth-child(2){animation-delay:1.5s}.var-loading__rect-item:nth-child(3){animation-delay:1.25s}.var-loading__rect-item:nth-child(4){animation-delay:1s}.var-loading__rect-item:nth-child(5){animation-delay:.75s}.var-loading__rect-item:nth-child(6){animation-delay:.5s}.var-loading__rect-item:nth-child(7){animation-delay:.25s}.var-loading__rect-item:nth-child(8){animation-delay:0s}.var-loading__rect-item--large{height:100%;width:8px}.var-loading__rect-item--normal{height:90%;width:6.4px}.var-loading__rect-item--small{height:80%;width:4.8px}.var-loading__rect-item--mini{height:70%;width:3.2px}@keyframes rect{0%{opacity:.3}25%{opacity:1}50%{opacity:.3}65%{opacity:1}to{opacity:.3}}.var-loading__disappear{display:flex;justify-content:space-around;align-items:center;flex-flow:nowrap}.var-loading__disappear--large{width:64px;height:18px}.var-loading__disappear--normal{width:50px;height:16px}.var-loading__disappear--small{width:36px;height:14px}.var-loading__disappear--mini{width:22px;height:12px}.var-loading__disappear-item{border-radius:50%;animation:.5s ease-in-out infinite alternate disappear}.var-loading__disappear-item:nth-child(1){animation-delay:-.4s}.var-loading__disappear-item:nth-child(2){animation-delay:-.2s}.var-loading__disappear-item:nth-child(3){animation-delay:0s}.var-loading__disappear-item--large{height:15px;width:15px}.var-loading__disappear-item--normal{height:12px;width:12px}.var-loading__disappear-item--small{height:9px;width:9px}.var-loading__disappear-item--mini{height:6px;width:6px}@keyframes disappear{0%{opacity:1}to{opacity:0}}:root{--button-default-color: #f5f5f5;--button-primary-color: var(--color-primary);--button-danger-color: var(--color-danger);--button-success-color: var(--color-success);--button-warning-color: var(--color-warning);--button-info-color: var(--color-info);--button-disabled-color: var(--color-disabled);--button-disabled-text-color: var(--color-text-disabled);--button-border-radius: 4px;--button-mini-padding: 0 9px;--button-small-padding: 0 11px;--button-normal-padding: 0 15px;--button-large-padding: 0 22px;--button-round-padding: 6px;--button-mini-height: 20px;--button-small-height: 28px;--button-normal-height: 36px;--button-large-height: 44px}.var-button{position:relative;justify-content:center;align-items:center;outline:none;border:none;border-radius:var(--button-border-radius);user-select:none;cursor:pointer;font-family:inherit;transition:box-shadow .2s,background-color .25s;will-change:box-shadow;-webkit-tap-highlight-color:rgba(0,0,0,0);white-space:nowrap;line-height:1}.var-button:active{box-shadow:0 3px 5px -1px var(--shadow-key-umbra-opacity),0 5px 8px 0 var(--shadow-key-penumbra-opacity),0 1px 14px 0 var(--shadow-key-ambient-opacity)}.var-button__loading[var-button-cover]{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%)}.var-button--default{color:inherit;background-color:var(--button-default-color)}.var-button--primary{color:#fff;background-color:var(--button-primary-color)}.var-button--info{color:#fff;background-color:var(--button-info-color)}.var-button--success{color:#fff;background-color:var(--button-success-color)}.var-button--warning{color:#fff;background-color:var(--button-warning-color)}.var-button--danger{color:#fff;background-color:var(--button-danger-color)}.var-button--disabled{background-color:var(--button-disabled-color);color:var(--button-disabled-text-color);cursor:not-allowed;box-shadow:none!important}.var-button--block{width:100%}.var-button--text{background-color:transparent}.var-button--text:active{box-shadow:none}.var-button--text-default{color:inherit}.var-button--text-primary{color:var(--button-primary-color)}.var-button--text-info{color:var(--button-info-color)}.var-button--text-success{color:var(--button-success-color)}.var-button--text-warning{color:var(--button-warning-color)}.var-button--text-danger{color:var(--button-danger-color)}.var-button--text-disabled{color:var(--button-disabled-text-color)}.var-button--normal{height:var(--button-normal-height);padding:var(--button-normal-padding);font-size:var(--font-size-md)}.var-button--large{height:var(--button-large-height);padding:var(--button-large-padding);font-size:var(--font-size-lg)}.var-button--small{height:var(--button-small-height);padding:var(--button-small-padding);font-size:var(--font-size-sm)}.var-button--mini{height:var(--button-mini-height);padding:var(--button-mini-padding);font-size:var(--font-size-xs)}.var-button--round{padding:var(--button-round-padding);border-radius:50%;height:auto}.var-button--outline{border:thin solid currentColor}.var-button--hidden{opacity:0}
`)
  )
  var head = document.querySelector('head')
  head.appendChild(style)
})()
import {
  reactive,
  ref,
  onMounted,
  onUnmounted,
  onActivated,
  onDeactivated,
  getCurrentInstance,
  provide,
  computed,
  inject,
  nextTick,
  onBeforeUnmount,
  createApp,
  h as h$1,
  isVNode,
  watch,
  onBeforeMount,
  defineComponent,
  createVNode,
  Teleport,
  Transition,
  withDirectives,
  mergeProps,
  vShow,
  openBlock,
  createBlock,
  resolveDynamicComponent,
  normalizeClass,
  normalizeStyle,
  resolveComponent,
  resolveDirective,
  withCtx,
  createElementVNode,
  renderSlot,
  toDisplayString,
  createElementBlock,
  Fragment,
  renderList,
  createCommentVNode,
  onUpdated,
  createTextVNode,
  pushScopeId,
  popScopeId,
  withModifiers,
  normalizeProps,
  guardReactiveProps,
  vModelText,
  toRefs,
  withKeys,
  toRaw,
  Comment,
  unref,
} from 'vue'
import { schemaManager } from '@varlet/lowcode-core'
var index =
  '<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <link rel="icon" href="/favicon.ico" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Vite Varlet Low Code Starter</title>\n  </head>\n  <body>\n    <div id="app"></div>\n\n    <script src="https://cdn.jsdelivr.net/npm/vue"></script>\n    <script type="module" src="/src/main.js"></script>\n  </body>\n</html>\n'
var pkg =
  '{\n  "name": "vite-varlet-low-code-starter",\n  "version": "0.0.0",\n  "scripts": {\n    "dev": "vite",\n    "build": "vite build",\n    "serve": "vite preview"\n  },\n  "dependencies": {\n    "vue": "latest"\n  },\n  "devDependencies": {\n    "@vitejs/plugin-vue": "latest",\n    "vite-plugin-externals": "latest",\n    "@vue/compiler-sfc": "latest",\n    "vite": "latest"\n  }\n}\n'
var config$1 =
  "import vue from '@vitejs/plugin-vue'\nimport { viteExternalsPlugin } from 'vite-plugin-externals'\nimport { defineConfig } from 'vite'\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [vue(), viteExternalsPlugin()],\n})\n"
var readme =
  '# Vite Varlet Low Code Starter\n\nThis is a project template using [Vite](https://vitejs.dev/). It requires [Node.js](https://nodejs.org) v12+.\n\nTo start:\n\n```sh\nnpm install\nnpm run dev\n\n# if using yarn:\nyarn\nyarn dev\n```\n'
var commonjsGlobal =
  typeof globalThis !== 'undefined'
    ? globalThis
    : typeof window !== 'undefined'
    ? window
    : typeof global !== 'undefined'
    ? global
    : typeof self !== 'undefined'
    ? self
    : {}
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x
}
function getAugmentedNamespace(n2) {
  if (n2.__esModule) return n2
  var a = Object.defineProperty({}, '__esModule', { value: true })
  Object.keys(n2).forEach(function (k) {
    var d2 = Object.getOwnPropertyDescriptor(n2, k)
    Object.defineProperty(
      a,
      k,
      d2.get
        ? d2
        : {
            enumerable: true,
            get: function () {
              return n2[k]
            },
          }
    )
  })
  return a
}
function commonjsRequire(path2) {
  throw new Error(
    'Could not dynamically require "' +
      path2 +
      '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.'
  )
}
var lib$c = {}
var visitors = {}
var virtualTypes$2 = {}
var lib$b = {}
var isReactComponent$1 = {}
var buildMatchMemberExpression$1 = {}
var matchesPattern$3 = {}
var generated$4 = {}
var shallowEqual$1 = {}
Object.defineProperty(shallowEqual$1, '__esModule', {
  value: true,
})
shallowEqual$1.default = shallowEqual
function shallowEqual(actual, expected) {
  const keys = Object.keys(expected)
  for (const key of keys) {
    if (actual[key] !== expected[key]) {
      return false
    }
  }
  return true
}
Object.defineProperty(generated$4, '__esModule', {
  value: true,
})
generated$4.isAccessor = isAccessor
generated$4.isAnyTypeAnnotation = isAnyTypeAnnotation$1
generated$4.isArgumentPlaceholder = isArgumentPlaceholder
generated$4.isArrayExpression = isArrayExpression$2
generated$4.isArrayPattern = isArrayPattern
generated$4.isArrayTypeAnnotation = isArrayTypeAnnotation$1
generated$4.isArrowFunctionExpression = isArrowFunctionExpression$1
generated$4.isAssignmentExpression = isAssignmentExpression$4
generated$4.isAssignmentPattern = isAssignmentPattern$2
generated$4.isAwaitExpression = isAwaitExpression$1
generated$4.isBigIntLiteral = isBigIntLiteral
generated$4.isBinary = isBinary$4
generated$4.isBinaryExpression = isBinaryExpression$1
generated$4.isBindExpression = isBindExpression
generated$4.isBlock = isBlock
generated$4.isBlockParent = isBlockParent
generated$4.isBlockStatement = isBlockStatement$2
generated$4.isBooleanLiteral = isBooleanLiteral
generated$4.isBooleanLiteralTypeAnnotation = isBooleanLiteralTypeAnnotation
generated$4.isBooleanTypeAnnotation = isBooleanTypeAnnotation$1
generated$4.isBreakStatement = isBreakStatement
generated$4.isCallExpression = isCallExpression$6
generated$4.isCatchClause = isCatchClause
generated$4.isClass = isClass$1
generated$4.isClassAccessorProperty = isClassAccessorProperty
generated$4.isClassBody = isClassBody$1
generated$4.isClassDeclaration = isClassDeclaration$3
generated$4.isClassExpression = isClassExpression$1
generated$4.isClassImplements = isClassImplements
generated$4.isClassMethod = isClassMethod
generated$4.isClassPrivateMethod = isClassPrivateMethod
generated$4.isClassPrivateProperty = isClassPrivateProperty
generated$4.isClassProperty = isClassProperty
generated$4.isCompletionStatement = isCompletionStatement
generated$4.isConditional = isConditional$1
generated$4.isConditionalExpression = isConditionalExpression$1
generated$4.isContinueStatement = isContinueStatement
generated$4.isDebuggerStatement = isDebuggerStatement
generated$4.isDecimalLiteral = isDecimalLiteral
generated$4.isDeclaration = isDeclaration$1
generated$4.isDeclareClass = isDeclareClass
generated$4.isDeclareExportAllDeclaration = isDeclareExportAllDeclaration
generated$4.isDeclareExportDeclaration = isDeclareExportDeclaration
generated$4.isDeclareFunction = isDeclareFunction
generated$4.isDeclareInterface = isDeclareInterface
generated$4.isDeclareModule = isDeclareModule
generated$4.isDeclareModuleExports = isDeclareModuleExports
generated$4.isDeclareOpaqueType = isDeclareOpaqueType
generated$4.isDeclareTypeAlias = isDeclareTypeAlias
generated$4.isDeclareVariable = isDeclareVariable
generated$4.isDeclaredPredicate = isDeclaredPredicate
generated$4.isDecorator = isDecorator
generated$4.isDirective = isDirective
generated$4.isDirectiveLiteral = isDirectiveLiteral
generated$4.isDoExpression = isDoExpression
generated$4.isDoWhileStatement = isDoWhileStatement
generated$4.isEmptyStatement = isEmptyStatement$1
generated$4.isEmptyTypeAnnotation = isEmptyTypeAnnotation$1
generated$4.isEnumBody = isEnumBody
generated$4.isEnumBooleanBody = isEnumBooleanBody
generated$4.isEnumBooleanMember = isEnumBooleanMember
generated$4.isEnumDeclaration = isEnumDeclaration
generated$4.isEnumDefaultedMember = isEnumDefaultedMember
generated$4.isEnumMember = isEnumMember
generated$4.isEnumNumberBody = isEnumNumberBody
generated$4.isEnumNumberMember = isEnumNumberMember
generated$4.isEnumStringBody = isEnumStringBody
generated$4.isEnumStringMember = isEnumStringMember
generated$4.isEnumSymbolBody = isEnumSymbolBody
generated$4.isExistsTypeAnnotation = isExistsTypeAnnotation
generated$4.isExportAllDeclaration = isExportAllDeclaration$1
generated$4.isExportDeclaration = isExportDeclaration$2
generated$4.isExportDefaultDeclaration = isExportDefaultDeclaration$3
generated$4.isExportDefaultSpecifier = isExportDefaultSpecifier$1
generated$4.isExportNamedDeclaration = isExportNamedDeclaration$2
generated$4.isExportNamespaceSpecifier = isExportNamespaceSpecifier$1
generated$4.isExportSpecifier = isExportSpecifier
generated$4.isExpression = isExpression$4
generated$4.isExpressionStatement = isExpressionStatement$3
generated$4.isExpressionWrapper = isExpressionWrapper
generated$4.isFile = isFile$1
generated$4.isFlow = isFlow$1
generated$4.isFlowBaseAnnotation = isFlowBaseAnnotation$1
generated$4.isFlowDeclaration = isFlowDeclaration
generated$4.isFlowPredicate = isFlowPredicate
generated$4.isFlowType = isFlowType
generated$4.isFor = isFor$2
generated$4.isForInStatement = isForInStatement$1
generated$4.isForOfStatement = isForOfStatement$1
generated$4.isForStatement = isForStatement$3
generated$4.isForXStatement = isForXStatement$1
generated$4.isFunction = isFunction$4
generated$4.isFunctionDeclaration = isFunctionDeclaration$1
generated$4.isFunctionExpression = isFunctionExpression$1
generated$4.isFunctionParent = isFunctionParent
generated$4.isFunctionTypeAnnotation = isFunctionTypeAnnotation
generated$4.isFunctionTypeParam = isFunctionTypeParam
generated$4.isGenericTypeAnnotation = isGenericTypeAnnotation$1
generated$4.isIdentifier = isIdentifier$b
generated$4.isIfStatement = isIfStatement$2
generated$4.isImmutable = isImmutable$2
generated$4.isImport = isImport
generated$4.isImportAttribute = isImportAttribute
generated$4.isImportDeclaration = isImportDeclaration$2
generated$4.isImportDefaultSpecifier = isImportDefaultSpecifier$1
generated$4.isImportNamespaceSpecifier = isImportNamespaceSpecifier$1
generated$4.isImportSpecifier = isImportSpecifier$1
generated$4.isIndexedAccessType = isIndexedAccessType$1
generated$4.isInferredPredicate = isInferredPredicate
generated$4.isInterfaceDeclaration = isInterfaceDeclaration
generated$4.isInterfaceExtends = isInterfaceExtends
generated$4.isInterfaceTypeAnnotation = isInterfaceTypeAnnotation
generated$4.isInterpreterDirective = isInterpreterDirective
generated$4.isIntersectionTypeAnnotation = isIntersectionTypeAnnotation$1
generated$4.isJSX = isJSX
generated$4.isJSXAttribute = isJSXAttribute
generated$4.isJSXClosingElement = isJSXClosingElement
generated$4.isJSXClosingFragment = isJSXClosingFragment
generated$4.isJSXElement = isJSXElement
generated$4.isJSXEmptyExpression = isJSXEmptyExpression
generated$4.isJSXExpressionContainer = isJSXExpressionContainer
generated$4.isJSXFragment = isJSXFragment
generated$4.isJSXIdentifier = isJSXIdentifier$2
generated$4.isJSXMemberExpression = isJSXMemberExpression$1
generated$4.isJSXNamespacedName = isJSXNamespacedName
generated$4.isJSXOpeningElement = isJSXOpeningElement
generated$4.isJSXOpeningFragment = isJSXOpeningFragment
generated$4.isJSXSpreadAttribute = isJSXSpreadAttribute
generated$4.isJSXSpreadChild = isJSXSpreadChild
generated$4.isJSXText = isJSXText
generated$4.isLVal = isLVal
generated$4.isLabeledStatement = isLabeledStatement
generated$4.isLiteral = isLiteral$5
generated$4.isLogicalExpression = isLogicalExpression$1
generated$4.isLoop = isLoop$2
generated$4.isMemberExpression = isMemberExpression$5
generated$4.isMetaProperty = isMetaProperty$1
generated$4.isMethod = isMethod$1
generated$4.isMiscellaneous = isMiscellaneous
generated$4.isMixedTypeAnnotation = isMixedTypeAnnotation$1
generated$4.isModuleDeclaration = isModuleDeclaration$1
generated$4.isModuleExpression = isModuleExpression
generated$4.isModuleSpecifier = isModuleSpecifier$1
generated$4.isNewExpression = isNewExpression$4
generated$4.isNoop = isNoop
generated$4.isNullLiteral = isNullLiteral$1
generated$4.isNullLiteralTypeAnnotation = isNullLiteralTypeAnnotation
generated$4.isNullableTypeAnnotation = isNullableTypeAnnotation$1
generated$4.isNumberLiteral = isNumberLiteral
generated$4.isNumberLiteralTypeAnnotation = isNumberLiteralTypeAnnotation
generated$4.isNumberTypeAnnotation = isNumberTypeAnnotation$1
generated$4.isNumericLiteral = isNumericLiteral
generated$4.isObjectExpression = isObjectExpression$2
generated$4.isObjectMember = isObjectMember
generated$4.isObjectMethod = isObjectMethod$1
generated$4.isObjectPattern = isObjectPattern$1
generated$4.isObjectProperty = isObjectProperty$2
generated$4.isObjectTypeAnnotation = isObjectTypeAnnotation
generated$4.isObjectTypeCallProperty = isObjectTypeCallProperty
generated$4.isObjectTypeIndexer = isObjectTypeIndexer
generated$4.isObjectTypeInternalSlot = isObjectTypeInternalSlot
generated$4.isObjectTypeProperty = isObjectTypeProperty
generated$4.isObjectTypeSpreadProperty = isObjectTypeSpreadProperty
generated$4.isOpaqueType = isOpaqueType
generated$4.isOptionalCallExpression = isOptionalCallExpression$2
generated$4.isOptionalIndexedAccessType = isOptionalIndexedAccessType
generated$4.isOptionalMemberExpression = isOptionalMemberExpression$2
generated$4.isParenthesizedExpression = isParenthesizedExpression
generated$4.isPattern = isPattern
generated$4.isPatternLike = isPatternLike
generated$4.isPipelineBareFunction = isPipelineBareFunction
generated$4.isPipelinePrimaryTopicReference = isPipelinePrimaryTopicReference
generated$4.isPipelineTopicExpression = isPipelineTopicExpression
generated$4.isPlaceholder = isPlaceholder$1
generated$4.isPrivate = isPrivate
generated$4.isPrivateName = isPrivateName$1
generated$4.isProgram = isProgram$2
generated$4.isProperty = isProperty$1
generated$4.isPureish = isPureish$1
generated$4.isQualifiedTypeIdentifier = isQualifiedTypeIdentifier
generated$4.isRecordExpression = isRecordExpression$1
generated$4.isRegExpLiteral = isRegExpLiteral$1
generated$4.isRegexLiteral = isRegexLiteral
generated$4.isRestElement = isRestElement$1
generated$4.isRestProperty = isRestProperty
generated$4.isReturnStatement = isReturnStatement$1
generated$4.isScopable = isScopable
generated$4.isSequenceExpression = isSequenceExpression$2
generated$4.isSpreadElement = isSpreadElement
generated$4.isSpreadProperty = isSpreadProperty
generated$4.isStandardized = isStandardized
generated$4.isStatement = isStatement$6
generated$4.isStaticBlock = isStaticBlock
generated$4.isStringLiteral = isStringLiteral$4
generated$4.isStringLiteralTypeAnnotation = isStringLiteralTypeAnnotation
generated$4.isStringTypeAnnotation = isStringTypeAnnotation$1
generated$4.isSuper = isSuper$2
generated$4.isSwitchCase = isSwitchCase
generated$4.isSwitchStatement = isSwitchStatement$1
generated$4.isSymbolTypeAnnotation = isSymbolTypeAnnotation
generated$4.isTSAnyKeyword = isTSAnyKeyword
generated$4.isTSArrayType = isTSArrayType$1
generated$4.isTSAsExpression = isTSAsExpression$1
generated$4.isTSBaseType = isTSBaseType
generated$4.isTSBigIntKeyword = isTSBigIntKeyword
generated$4.isTSBooleanKeyword = isTSBooleanKeyword
generated$4.isTSCallSignatureDeclaration = isTSCallSignatureDeclaration
generated$4.isTSConditionalType = isTSConditionalType
generated$4.isTSConstructSignatureDeclaration = isTSConstructSignatureDeclaration
generated$4.isTSConstructorType = isTSConstructorType
generated$4.isTSDeclareFunction = isTSDeclareFunction
generated$4.isTSDeclareMethod = isTSDeclareMethod
generated$4.isTSEntityName = isTSEntityName
generated$4.isTSEnumDeclaration = isTSEnumDeclaration
generated$4.isTSEnumMember = isTSEnumMember
generated$4.isTSExportAssignment = isTSExportAssignment
generated$4.isTSExpressionWithTypeArguments = isTSExpressionWithTypeArguments
generated$4.isTSExternalModuleReference = isTSExternalModuleReference
generated$4.isTSFunctionType = isTSFunctionType
generated$4.isTSImportEqualsDeclaration = isTSImportEqualsDeclaration
generated$4.isTSImportType = isTSImportType
generated$4.isTSIndexSignature = isTSIndexSignature
generated$4.isTSIndexedAccessType = isTSIndexedAccessType
generated$4.isTSInferType = isTSInferType
generated$4.isTSInstantiationExpression = isTSInstantiationExpression$1
generated$4.isTSInterfaceBody = isTSInterfaceBody
generated$4.isTSInterfaceDeclaration = isTSInterfaceDeclaration
generated$4.isTSIntersectionType = isTSIntersectionType$1
generated$4.isTSIntrinsicKeyword = isTSIntrinsicKeyword
generated$4.isTSLiteralType = isTSLiteralType
generated$4.isTSMappedType = isTSMappedType
generated$4.isTSMethodSignature = isTSMethodSignature
generated$4.isTSModuleBlock = isTSModuleBlock
generated$4.isTSModuleDeclaration = isTSModuleDeclaration
generated$4.isTSNamedTupleMember = isTSNamedTupleMember
generated$4.isTSNamespaceExportDeclaration = isTSNamespaceExportDeclaration
generated$4.isTSNeverKeyword = isTSNeverKeyword
generated$4.isTSNonNullExpression = isTSNonNullExpression$1
generated$4.isTSNullKeyword = isTSNullKeyword
generated$4.isTSNumberKeyword = isTSNumberKeyword
generated$4.isTSObjectKeyword = isTSObjectKeyword
generated$4.isTSOptionalType = isTSOptionalType$1
generated$4.isTSParameterProperty = isTSParameterProperty
generated$4.isTSParenthesizedType = isTSParenthesizedType
generated$4.isTSPropertySignature = isTSPropertySignature
generated$4.isTSQualifiedName = isTSQualifiedName
generated$4.isTSRestType = isTSRestType$1
generated$4.isTSStringKeyword = isTSStringKeyword
generated$4.isTSSymbolKeyword = isTSSymbolKeyword
generated$4.isTSThisType = isTSThisType
generated$4.isTSTupleType = isTSTupleType
generated$4.isTSType = isTSType
generated$4.isTSTypeAliasDeclaration = isTSTypeAliasDeclaration
generated$4.isTSTypeAnnotation = isTSTypeAnnotation$1
generated$4.isTSTypeAssertion = isTSTypeAssertion$1
generated$4.isTSTypeElement = isTSTypeElement
generated$4.isTSTypeLiteral = isTSTypeLiteral
generated$4.isTSTypeOperator = isTSTypeOperator
generated$4.isTSTypeParameter = isTSTypeParameter
generated$4.isTSTypeParameterDeclaration = isTSTypeParameterDeclaration
generated$4.isTSTypeParameterInstantiation = isTSTypeParameterInstantiation
generated$4.isTSTypePredicate = isTSTypePredicate
generated$4.isTSTypeQuery = isTSTypeQuery
generated$4.isTSTypeReference = isTSTypeReference
generated$4.isTSUndefinedKeyword = isTSUndefinedKeyword
generated$4.isTSUnionType = isTSUnionType$1
generated$4.isTSUnknownKeyword = isTSUnknownKeyword
generated$4.isTSVoidKeyword = isTSVoidKeyword
generated$4.isTaggedTemplateExpression = isTaggedTemplateExpression$2
generated$4.isTemplateElement = isTemplateElement
generated$4.isTemplateLiteral = isTemplateLiteral$2
generated$4.isTerminatorless = isTerminatorless
generated$4.isThisExpression = isThisExpression$1
generated$4.isThisTypeAnnotation = isThisTypeAnnotation
generated$4.isThrowStatement = isThrowStatement$1
generated$4.isTopicReference = isTopicReference$1
generated$4.isTryStatement = isTryStatement
generated$4.isTupleExpression = isTupleExpression$1
generated$4.isTupleTypeAnnotation = isTupleTypeAnnotation
generated$4.isTypeAlias = isTypeAlias
generated$4.isTypeAnnotation = isTypeAnnotation$2
generated$4.isTypeCastExpression = isTypeCastExpression
generated$4.isTypeParameter = isTypeParameter
generated$4.isTypeParameterDeclaration = isTypeParameterDeclaration
generated$4.isTypeParameterInstantiation = isTypeParameterInstantiation
generated$4.isTypeScript = isTypeScript
generated$4.isTypeofTypeAnnotation = isTypeofTypeAnnotation
generated$4.isUnaryExpression = isUnaryExpression$1
generated$4.isUnaryLike = isUnaryLike$1
generated$4.isUnionTypeAnnotation = isUnionTypeAnnotation$2
generated$4.isUpdateExpression = isUpdateExpression$1
generated$4.isUserWhitespacable = isUserWhitespacable
generated$4.isV8IntrinsicIdentifier = isV8IntrinsicIdentifier
generated$4.isVariableDeclaration = isVariableDeclaration$2
generated$4.isVariableDeclarator = isVariableDeclarator$2
generated$4.isVariance = isVariance
generated$4.isVoidTypeAnnotation = isVoidTypeAnnotation$1
generated$4.isWhile = isWhile
generated$4.isWhileStatement = isWhileStatement$1
generated$4.isWithStatement = isWithStatement
generated$4.isYieldExpression = isYieldExpression$1
var _shallowEqual$1 = shallowEqual$1
function isArrayExpression$2(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'ArrayExpression') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isAssignmentExpression$4(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'AssignmentExpression') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isBinaryExpression$1(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'BinaryExpression') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isInterpreterDirective(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'InterpreterDirective') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isDirective(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'Directive') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isDirectiveLiteral(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'DirectiveLiteral') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isBlockStatement$2(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'BlockStatement') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isBreakStatement(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'BreakStatement') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isCallExpression$6(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'CallExpression') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isCatchClause(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'CatchClause') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isConditionalExpression$1(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'ConditionalExpression') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isContinueStatement(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'ContinueStatement') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isDebuggerStatement(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'DebuggerStatement') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isDoWhileStatement(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'DoWhileStatement') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isEmptyStatement$1(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'EmptyStatement') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isExpressionStatement$3(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'ExpressionStatement') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isFile$1(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'File') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isForInStatement$1(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'ForInStatement') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isForStatement$3(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'ForStatement') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isFunctionDeclaration$1(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'FunctionDeclaration') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isFunctionExpression$1(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'FunctionExpression') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isIdentifier$b(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'Identifier') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isIfStatement$2(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'IfStatement') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isLabeledStatement(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'LabeledStatement') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isStringLiteral$4(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'StringLiteral') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isNumericLiteral(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'NumericLiteral') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isNullLiteral$1(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'NullLiteral') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isBooleanLiteral(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'BooleanLiteral') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isRegExpLiteral$1(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'RegExpLiteral') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isLogicalExpression$1(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'LogicalExpression') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isMemberExpression$5(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'MemberExpression') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isNewExpression$4(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'NewExpression') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isProgram$2(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'Program') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isObjectExpression$2(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'ObjectExpression') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isObjectMethod$1(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'ObjectMethod') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isObjectProperty$2(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'ObjectProperty') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isRestElement$1(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'RestElement') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isReturnStatement$1(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'ReturnStatement') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isSequenceExpression$2(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'SequenceExpression') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isParenthesizedExpression(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'ParenthesizedExpression') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isSwitchCase(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'SwitchCase') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isSwitchStatement$1(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'SwitchStatement') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isThisExpression$1(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'ThisExpression') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isThrowStatement$1(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'ThrowStatement') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTryStatement(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'TryStatement') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isUnaryExpression$1(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'UnaryExpression') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isUpdateExpression$1(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'UpdateExpression') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isVariableDeclaration$2(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'VariableDeclaration') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isVariableDeclarator$2(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'VariableDeclarator') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isWhileStatement$1(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'WhileStatement') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isWithStatement(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'WithStatement') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isAssignmentPattern$2(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'AssignmentPattern') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isArrayPattern(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'ArrayPattern') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isArrowFunctionExpression$1(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'ArrowFunctionExpression') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isClassBody$1(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'ClassBody') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isClassExpression$1(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'ClassExpression') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isClassDeclaration$3(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'ClassDeclaration') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isExportAllDeclaration$1(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'ExportAllDeclaration') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isExportDefaultDeclaration$3(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'ExportDefaultDeclaration') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isExportNamedDeclaration$2(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'ExportNamedDeclaration') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isExportSpecifier(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'ExportSpecifier') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isForOfStatement$1(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'ForOfStatement') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isImportDeclaration$2(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'ImportDeclaration') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isImportDefaultSpecifier$1(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'ImportDefaultSpecifier') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isImportNamespaceSpecifier$1(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'ImportNamespaceSpecifier') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isImportSpecifier$1(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'ImportSpecifier') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isMetaProperty$1(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'MetaProperty') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isClassMethod(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'ClassMethod') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isObjectPattern$1(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'ObjectPattern') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isSpreadElement(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'SpreadElement') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isSuper$2(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'Super') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTaggedTemplateExpression$2(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'TaggedTemplateExpression') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTemplateElement(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'TemplateElement') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTemplateLiteral$2(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'TemplateLiteral') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isYieldExpression$1(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'YieldExpression') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isAwaitExpression$1(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'AwaitExpression') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isImport(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'Import') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isBigIntLiteral(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'BigIntLiteral') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isExportNamespaceSpecifier$1(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'ExportNamespaceSpecifier') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isOptionalMemberExpression$2(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'OptionalMemberExpression') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isOptionalCallExpression$2(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'OptionalCallExpression') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isClassProperty(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'ClassProperty') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isClassAccessorProperty(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'ClassAccessorProperty') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isClassPrivateProperty(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'ClassPrivateProperty') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isClassPrivateMethod(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'ClassPrivateMethod') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isPrivateName$1(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'PrivateName') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isStaticBlock(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'StaticBlock') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isAnyTypeAnnotation$1(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'AnyTypeAnnotation') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isArrayTypeAnnotation$1(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'ArrayTypeAnnotation') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isBooleanTypeAnnotation$1(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'BooleanTypeAnnotation') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isBooleanLiteralTypeAnnotation(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'BooleanLiteralTypeAnnotation') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isNullLiteralTypeAnnotation(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'NullLiteralTypeAnnotation') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isClassImplements(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'ClassImplements') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isDeclareClass(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'DeclareClass') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isDeclareFunction(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'DeclareFunction') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isDeclareInterface(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'DeclareInterface') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isDeclareModule(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'DeclareModule') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isDeclareModuleExports(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'DeclareModuleExports') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isDeclareTypeAlias(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'DeclareTypeAlias') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isDeclareOpaqueType(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'DeclareOpaqueType') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isDeclareVariable(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'DeclareVariable') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isDeclareExportDeclaration(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'DeclareExportDeclaration') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isDeclareExportAllDeclaration(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'DeclareExportAllDeclaration') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isDeclaredPredicate(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'DeclaredPredicate') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isExistsTypeAnnotation(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'ExistsTypeAnnotation') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isFunctionTypeAnnotation(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'FunctionTypeAnnotation') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isFunctionTypeParam(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'FunctionTypeParam') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isGenericTypeAnnotation$1(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'GenericTypeAnnotation') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isInferredPredicate(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'InferredPredicate') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isInterfaceExtends(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'InterfaceExtends') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isInterfaceDeclaration(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'InterfaceDeclaration') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isInterfaceTypeAnnotation(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'InterfaceTypeAnnotation') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isIntersectionTypeAnnotation$1(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'IntersectionTypeAnnotation') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isMixedTypeAnnotation$1(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'MixedTypeAnnotation') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isEmptyTypeAnnotation$1(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'EmptyTypeAnnotation') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isNullableTypeAnnotation$1(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'NullableTypeAnnotation') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isNumberLiteralTypeAnnotation(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'NumberLiteralTypeAnnotation') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isNumberTypeAnnotation$1(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'NumberTypeAnnotation') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isObjectTypeAnnotation(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'ObjectTypeAnnotation') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isObjectTypeInternalSlot(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'ObjectTypeInternalSlot') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isObjectTypeCallProperty(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'ObjectTypeCallProperty') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isObjectTypeIndexer(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'ObjectTypeIndexer') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isObjectTypeProperty(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'ObjectTypeProperty') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isObjectTypeSpreadProperty(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'ObjectTypeSpreadProperty') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isOpaqueType(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'OpaqueType') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isQualifiedTypeIdentifier(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'QualifiedTypeIdentifier') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isStringLiteralTypeAnnotation(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'StringLiteralTypeAnnotation') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isStringTypeAnnotation$1(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'StringTypeAnnotation') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isSymbolTypeAnnotation(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'SymbolTypeAnnotation') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isThisTypeAnnotation(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'ThisTypeAnnotation') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTupleTypeAnnotation(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'TupleTypeAnnotation') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTypeofTypeAnnotation(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'TypeofTypeAnnotation') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTypeAlias(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'TypeAlias') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTypeAnnotation$2(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'TypeAnnotation') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTypeCastExpression(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'TypeCastExpression') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTypeParameter(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'TypeParameter') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTypeParameterDeclaration(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'TypeParameterDeclaration') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTypeParameterInstantiation(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'TypeParameterInstantiation') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isUnionTypeAnnotation$2(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'UnionTypeAnnotation') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isVariance(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'Variance') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isVoidTypeAnnotation$1(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'VoidTypeAnnotation') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isEnumDeclaration(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'EnumDeclaration') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isEnumBooleanBody(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'EnumBooleanBody') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isEnumNumberBody(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'EnumNumberBody') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isEnumStringBody(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'EnumStringBody') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isEnumSymbolBody(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'EnumSymbolBody') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isEnumBooleanMember(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'EnumBooleanMember') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isEnumNumberMember(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'EnumNumberMember') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isEnumStringMember(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'EnumStringMember') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isEnumDefaultedMember(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'EnumDefaultedMember') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isIndexedAccessType$1(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'IndexedAccessType') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isOptionalIndexedAccessType(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'OptionalIndexedAccessType') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isJSXAttribute(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'JSXAttribute') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isJSXClosingElement(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'JSXClosingElement') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isJSXElement(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'JSXElement') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isJSXEmptyExpression(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'JSXEmptyExpression') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isJSXExpressionContainer(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'JSXExpressionContainer') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isJSXSpreadChild(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'JSXSpreadChild') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isJSXIdentifier$2(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'JSXIdentifier') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isJSXMemberExpression$1(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'JSXMemberExpression') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isJSXNamespacedName(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'JSXNamespacedName') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isJSXOpeningElement(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'JSXOpeningElement') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isJSXSpreadAttribute(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'JSXSpreadAttribute') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isJSXText(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'JSXText') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isJSXFragment(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'JSXFragment') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isJSXOpeningFragment(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'JSXOpeningFragment') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isJSXClosingFragment(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'JSXClosingFragment') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isNoop(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'Noop') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isPlaceholder$1(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'Placeholder') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isV8IntrinsicIdentifier(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'V8IntrinsicIdentifier') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isArgumentPlaceholder(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'ArgumentPlaceholder') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isBindExpression(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'BindExpression') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isImportAttribute(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'ImportAttribute') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isDecorator(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'Decorator') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isDoExpression(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'DoExpression') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isExportDefaultSpecifier$1(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'ExportDefaultSpecifier') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isRecordExpression$1(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'RecordExpression') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTupleExpression$1(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'TupleExpression') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isDecimalLiteral(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'DecimalLiteral') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isModuleExpression(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'ModuleExpression') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTopicReference$1(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'TopicReference') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isPipelineTopicExpression(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'PipelineTopicExpression') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isPipelineBareFunction(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'PipelineBareFunction') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isPipelinePrimaryTopicReference(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'PipelinePrimaryTopicReference') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTSParameterProperty(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'TSParameterProperty') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTSDeclareFunction(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'TSDeclareFunction') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTSDeclareMethod(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'TSDeclareMethod') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTSQualifiedName(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'TSQualifiedName') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTSCallSignatureDeclaration(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'TSCallSignatureDeclaration') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTSConstructSignatureDeclaration(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'TSConstructSignatureDeclaration') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTSPropertySignature(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'TSPropertySignature') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTSMethodSignature(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'TSMethodSignature') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTSIndexSignature(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'TSIndexSignature') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTSAnyKeyword(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'TSAnyKeyword') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTSBooleanKeyword(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'TSBooleanKeyword') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTSBigIntKeyword(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'TSBigIntKeyword') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTSIntrinsicKeyword(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'TSIntrinsicKeyword') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTSNeverKeyword(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'TSNeverKeyword') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTSNullKeyword(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'TSNullKeyword') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTSNumberKeyword(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'TSNumberKeyword') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTSObjectKeyword(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'TSObjectKeyword') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTSStringKeyword(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'TSStringKeyword') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTSSymbolKeyword(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'TSSymbolKeyword') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTSUndefinedKeyword(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'TSUndefinedKeyword') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTSUnknownKeyword(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'TSUnknownKeyword') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTSVoidKeyword(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'TSVoidKeyword') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTSThisType(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'TSThisType') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTSFunctionType(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'TSFunctionType') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTSConstructorType(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'TSConstructorType') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTSTypeReference(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'TSTypeReference') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTSTypePredicate(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'TSTypePredicate') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTSTypeQuery(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'TSTypeQuery') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTSTypeLiteral(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'TSTypeLiteral') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTSArrayType$1(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'TSArrayType') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTSTupleType(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'TSTupleType') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTSOptionalType$1(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'TSOptionalType') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTSRestType$1(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'TSRestType') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTSNamedTupleMember(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'TSNamedTupleMember') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTSUnionType$1(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'TSUnionType') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTSIntersectionType$1(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'TSIntersectionType') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTSConditionalType(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'TSConditionalType') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTSInferType(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'TSInferType') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTSParenthesizedType(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'TSParenthesizedType') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTSTypeOperator(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'TSTypeOperator') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTSIndexedAccessType(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'TSIndexedAccessType') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTSMappedType(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'TSMappedType') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTSLiteralType(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'TSLiteralType') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTSExpressionWithTypeArguments(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'TSExpressionWithTypeArguments') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTSInterfaceDeclaration(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'TSInterfaceDeclaration') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTSInterfaceBody(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'TSInterfaceBody') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTSTypeAliasDeclaration(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'TSTypeAliasDeclaration') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTSInstantiationExpression$1(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'TSInstantiationExpression') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTSAsExpression$1(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'TSAsExpression') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTSTypeAssertion$1(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'TSTypeAssertion') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTSEnumDeclaration(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'TSEnumDeclaration') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTSEnumMember(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'TSEnumMember') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTSModuleDeclaration(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'TSModuleDeclaration') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTSModuleBlock(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'TSModuleBlock') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTSImportType(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'TSImportType') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTSImportEqualsDeclaration(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'TSImportEqualsDeclaration') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTSExternalModuleReference(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'TSExternalModuleReference') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTSNonNullExpression$1(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'TSNonNullExpression') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTSExportAssignment(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'TSExportAssignment') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTSNamespaceExportDeclaration(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'TSNamespaceExportDeclaration') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTSTypeAnnotation$1(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'TSTypeAnnotation') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTSTypeParameterInstantiation(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'TSTypeParameterInstantiation') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTSTypeParameterDeclaration(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'TSTypeParameterDeclaration') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTSTypeParameter(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'TSTypeParameter') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isStandardized(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (
    nodeType === 'ArrayExpression' ||
    nodeType === 'AssignmentExpression' ||
    nodeType === 'BinaryExpression' ||
    nodeType === 'InterpreterDirective' ||
    nodeType === 'Directive' ||
    nodeType === 'DirectiveLiteral' ||
    nodeType === 'BlockStatement' ||
    nodeType === 'BreakStatement' ||
    nodeType === 'CallExpression' ||
    nodeType === 'CatchClause' ||
    nodeType === 'ConditionalExpression' ||
    nodeType === 'ContinueStatement' ||
    nodeType === 'DebuggerStatement' ||
    nodeType === 'DoWhileStatement' ||
    nodeType === 'EmptyStatement' ||
    nodeType === 'ExpressionStatement' ||
    nodeType === 'File' ||
    nodeType === 'ForInStatement' ||
    nodeType === 'ForStatement' ||
    nodeType === 'FunctionDeclaration' ||
    nodeType === 'FunctionExpression' ||
    nodeType === 'Identifier' ||
    nodeType === 'IfStatement' ||
    nodeType === 'LabeledStatement' ||
    nodeType === 'StringLiteral' ||
    nodeType === 'NumericLiteral' ||
    nodeType === 'NullLiteral' ||
    nodeType === 'BooleanLiteral' ||
    nodeType === 'RegExpLiteral' ||
    nodeType === 'LogicalExpression' ||
    nodeType === 'MemberExpression' ||
    nodeType === 'NewExpression' ||
    nodeType === 'Program' ||
    nodeType === 'ObjectExpression' ||
    nodeType === 'ObjectMethod' ||
    nodeType === 'ObjectProperty' ||
    nodeType === 'RestElement' ||
    nodeType === 'ReturnStatement' ||
    nodeType === 'SequenceExpression' ||
    nodeType === 'ParenthesizedExpression' ||
    nodeType === 'SwitchCase' ||
    nodeType === 'SwitchStatement' ||
    nodeType === 'ThisExpression' ||
    nodeType === 'ThrowStatement' ||
    nodeType === 'TryStatement' ||
    nodeType === 'UnaryExpression' ||
    nodeType === 'UpdateExpression' ||
    nodeType === 'VariableDeclaration' ||
    nodeType === 'VariableDeclarator' ||
    nodeType === 'WhileStatement' ||
    nodeType === 'WithStatement' ||
    nodeType === 'AssignmentPattern' ||
    nodeType === 'ArrayPattern' ||
    nodeType === 'ArrowFunctionExpression' ||
    nodeType === 'ClassBody' ||
    nodeType === 'ClassExpression' ||
    nodeType === 'ClassDeclaration' ||
    nodeType === 'ExportAllDeclaration' ||
    nodeType === 'ExportDefaultDeclaration' ||
    nodeType === 'ExportNamedDeclaration' ||
    nodeType === 'ExportSpecifier' ||
    nodeType === 'ForOfStatement' ||
    nodeType === 'ImportDeclaration' ||
    nodeType === 'ImportDefaultSpecifier' ||
    nodeType === 'ImportNamespaceSpecifier' ||
    nodeType === 'ImportSpecifier' ||
    nodeType === 'MetaProperty' ||
    nodeType === 'ClassMethod' ||
    nodeType === 'ObjectPattern' ||
    nodeType === 'SpreadElement' ||
    nodeType === 'Super' ||
    nodeType === 'TaggedTemplateExpression' ||
    nodeType === 'TemplateElement' ||
    nodeType === 'TemplateLiteral' ||
    nodeType === 'YieldExpression' ||
    nodeType === 'AwaitExpression' ||
    nodeType === 'Import' ||
    nodeType === 'BigIntLiteral' ||
    nodeType === 'ExportNamespaceSpecifier' ||
    nodeType === 'OptionalMemberExpression' ||
    nodeType === 'OptionalCallExpression' ||
    nodeType === 'ClassProperty' ||
    nodeType === 'ClassAccessorProperty' ||
    nodeType === 'ClassPrivateProperty' ||
    nodeType === 'ClassPrivateMethod' ||
    nodeType === 'PrivateName' ||
    nodeType === 'StaticBlock' ||
    (nodeType === 'Placeholder' &&
      (node2.expectedNode === 'Identifier' ||
        node2.expectedNode === 'StringLiteral' ||
        node2.expectedNode === 'BlockStatement' ||
        node2.expectedNode === 'ClassBody'))
  ) {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isExpression$4(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (
    nodeType === 'ArrayExpression' ||
    nodeType === 'AssignmentExpression' ||
    nodeType === 'BinaryExpression' ||
    nodeType === 'CallExpression' ||
    nodeType === 'ConditionalExpression' ||
    nodeType === 'FunctionExpression' ||
    nodeType === 'Identifier' ||
    nodeType === 'StringLiteral' ||
    nodeType === 'NumericLiteral' ||
    nodeType === 'NullLiteral' ||
    nodeType === 'BooleanLiteral' ||
    nodeType === 'RegExpLiteral' ||
    nodeType === 'LogicalExpression' ||
    nodeType === 'MemberExpression' ||
    nodeType === 'NewExpression' ||
    nodeType === 'ObjectExpression' ||
    nodeType === 'SequenceExpression' ||
    nodeType === 'ParenthesizedExpression' ||
    nodeType === 'ThisExpression' ||
    nodeType === 'UnaryExpression' ||
    nodeType === 'UpdateExpression' ||
    nodeType === 'ArrowFunctionExpression' ||
    nodeType === 'ClassExpression' ||
    nodeType === 'MetaProperty' ||
    nodeType === 'Super' ||
    nodeType === 'TaggedTemplateExpression' ||
    nodeType === 'TemplateLiteral' ||
    nodeType === 'YieldExpression' ||
    nodeType === 'AwaitExpression' ||
    nodeType === 'Import' ||
    nodeType === 'BigIntLiteral' ||
    nodeType === 'OptionalMemberExpression' ||
    nodeType === 'OptionalCallExpression' ||
    nodeType === 'TypeCastExpression' ||
    nodeType === 'JSXElement' ||
    nodeType === 'JSXFragment' ||
    nodeType === 'BindExpression' ||
    nodeType === 'DoExpression' ||
    nodeType === 'RecordExpression' ||
    nodeType === 'TupleExpression' ||
    nodeType === 'DecimalLiteral' ||
    nodeType === 'ModuleExpression' ||
    nodeType === 'TopicReference' ||
    nodeType === 'PipelineTopicExpression' ||
    nodeType === 'PipelineBareFunction' ||
    nodeType === 'PipelinePrimaryTopicReference' ||
    nodeType === 'TSInstantiationExpression' ||
    nodeType === 'TSAsExpression' ||
    nodeType === 'TSTypeAssertion' ||
    nodeType === 'TSNonNullExpression' ||
    (nodeType === 'Placeholder' &&
      (node2.expectedNode === 'Expression' ||
        node2.expectedNode === 'Identifier' ||
        node2.expectedNode === 'StringLiteral'))
  ) {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isBinary$4(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'BinaryExpression' || nodeType === 'LogicalExpression') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isScopable(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (
    nodeType === 'BlockStatement' ||
    nodeType === 'CatchClause' ||
    nodeType === 'DoWhileStatement' ||
    nodeType === 'ForInStatement' ||
    nodeType === 'ForStatement' ||
    nodeType === 'FunctionDeclaration' ||
    nodeType === 'FunctionExpression' ||
    nodeType === 'Program' ||
    nodeType === 'ObjectMethod' ||
    nodeType === 'SwitchStatement' ||
    nodeType === 'WhileStatement' ||
    nodeType === 'ArrowFunctionExpression' ||
    nodeType === 'ClassExpression' ||
    nodeType === 'ClassDeclaration' ||
    nodeType === 'ForOfStatement' ||
    nodeType === 'ClassMethod' ||
    nodeType === 'ClassPrivateMethod' ||
    nodeType === 'StaticBlock' ||
    nodeType === 'TSModuleBlock' ||
    (nodeType === 'Placeholder' && node2.expectedNode === 'BlockStatement')
  ) {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isBlockParent(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (
    nodeType === 'BlockStatement' ||
    nodeType === 'CatchClause' ||
    nodeType === 'DoWhileStatement' ||
    nodeType === 'ForInStatement' ||
    nodeType === 'ForStatement' ||
    nodeType === 'FunctionDeclaration' ||
    nodeType === 'FunctionExpression' ||
    nodeType === 'Program' ||
    nodeType === 'ObjectMethod' ||
    nodeType === 'SwitchStatement' ||
    nodeType === 'WhileStatement' ||
    nodeType === 'ArrowFunctionExpression' ||
    nodeType === 'ForOfStatement' ||
    nodeType === 'ClassMethod' ||
    nodeType === 'ClassPrivateMethod' ||
    nodeType === 'StaticBlock' ||
    nodeType === 'TSModuleBlock' ||
    (nodeType === 'Placeholder' && node2.expectedNode === 'BlockStatement')
  ) {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isBlock(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (
    nodeType === 'BlockStatement' ||
    nodeType === 'Program' ||
    nodeType === 'TSModuleBlock' ||
    (nodeType === 'Placeholder' && node2.expectedNode === 'BlockStatement')
  ) {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isStatement$6(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (
    nodeType === 'BlockStatement' ||
    nodeType === 'BreakStatement' ||
    nodeType === 'ContinueStatement' ||
    nodeType === 'DebuggerStatement' ||
    nodeType === 'DoWhileStatement' ||
    nodeType === 'EmptyStatement' ||
    nodeType === 'ExpressionStatement' ||
    nodeType === 'ForInStatement' ||
    nodeType === 'ForStatement' ||
    nodeType === 'FunctionDeclaration' ||
    nodeType === 'IfStatement' ||
    nodeType === 'LabeledStatement' ||
    nodeType === 'ReturnStatement' ||
    nodeType === 'SwitchStatement' ||
    nodeType === 'ThrowStatement' ||
    nodeType === 'TryStatement' ||
    nodeType === 'VariableDeclaration' ||
    nodeType === 'WhileStatement' ||
    nodeType === 'WithStatement' ||
    nodeType === 'ClassDeclaration' ||
    nodeType === 'ExportAllDeclaration' ||
    nodeType === 'ExportDefaultDeclaration' ||
    nodeType === 'ExportNamedDeclaration' ||
    nodeType === 'ForOfStatement' ||
    nodeType === 'ImportDeclaration' ||
    nodeType === 'DeclareClass' ||
    nodeType === 'DeclareFunction' ||
    nodeType === 'DeclareInterface' ||
    nodeType === 'DeclareModule' ||
    nodeType === 'DeclareModuleExports' ||
    nodeType === 'DeclareTypeAlias' ||
    nodeType === 'DeclareOpaqueType' ||
    nodeType === 'DeclareVariable' ||
    nodeType === 'DeclareExportDeclaration' ||
    nodeType === 'DeclareExportAllDeclaration' ||
    nodeType === 'InterfaceDeclaration' ||
    nodeType === 'OpaqueType' ||
    nodeType === 'TypeAlias' ||
    nodeType === 'EnumDeclaration' ||
    nodeType === 'TSDeclareFunction' ||
    nodeType === 'TSInterfaceDeclaration' ||
    nodeType === 'TSTypeAliasDeclaration' ||
    nodeType === 'TSEnumDeclaration' ||
    nodeType === 'TSModuleDeclaration' ||
    nodeType === 'TSImportEqualsDeclaration' ||
    nodeType === 'TSExportAssignment' ||
    nodeType === 'TSNamespaceExportDeclaration' ||
    (nodeType === 'Placeholder' &&
      (node2.expectedNode === 'Statement' ||
        node2.expectedNode === 'Declaration' ||
        node2.expectedNode === 'BlockStatement'))
  ) {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTerminatorless(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (
    nodeType === 'BreakStatement' ||
    nodeType === 'ContinueStatement' ||
    nodeType === 'ReturnStatement' ||
    nodeType === 'ThrowStatement' ||
    nodeType === 'YieldExpression' ||
    nodeType === 'AwaitExpression'
  ) {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isCompletionStatement(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (
    nodeType === 'BreakStatement' ||
    nodeType === 'ContinueStatement' ||
    nodeType === 'ReturnStatement' ||
    nodeType === 'ThrowStatement'
  ) {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isConditional$1(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'ConditionalExpression' || nodeType === 'IfStatement') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isLoop$2(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (
    nodeType === 'DoWhileStatement' ||
    nodeType === 'ForInStatement' ||
    nodeType === 'ForStatement' ||
    nodeType === 'WhileStatement' ||
    nodeType === 'ForOfStatement'
  ) {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isWhile(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'DoWhileStatement' || nodeType === 'WhileStatement') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isExpressionWrapper(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (
    nodeType === 'ExpressionStatement' ||
    nodeType === 'ParenthesizedExpression' ||
    nodeType === 'TypeCastExpression'
  ) {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isFor$2(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'ForInStatement' || nodeType === 'ForStatement' || nodeType === 'ForOfStatement') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isForXStatement$1(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'ForInStatement' || nodeType === 'ForOfStatement') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isFunction$4(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (
    nodeType === 'FunctionDeclaration' ||
    nodeType === 'FunctionExpression' ||
    nodeType === 'ObjectMethod' ||
    nodeType === 'ArrowFunctionExpression' ||
    nodeType === 'ClassMethod' ||
    nodeType === 'ClassPrivateMethod'
  ) {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isFunctionParent(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (
    nodeType === 'FunctionDeclaration' ||
    nodeType === 'FunctionExpression' ||
    nodeType === 'ObjectMethod' ||
    nodeType === 'ArrowFunctionExpression' ||
    nodeType === 'ClassMethod' ||
    nodeType === 'ClassPrivateMethod' ||
    nodeType === 'StaticBlock'
  ) {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isPureish$1(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (
    nodeType === 'FunctionDeclaration' ||
    nodeType === 'FunctionExpression' ||
    nodeType === 'StringLiteral' ||
    nodeType === 'NumericLiteral' ||
    nodeType === 'NullLiteral' ||
    nodeType === 'BooleanLiteral' ||
    nodeType === 'RegExpLiteral' ||
    nodeType === 'ArrowFunctionExpression' ||
    nodeType === 'BigIntLiteral' ||
    nodeType === 'DecimalLiteral' ||
    (nodeType === 'Placeholder' && node2.expectedNode === 'StringLiteral')
  ) {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isDeclaration$1(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (
    nodeType === 'FunctionDeclaration' ||
    nodeType === 'VariableDeclaration' ||
    nodeType === 'ClassDeclaration' ||
    nodeType === 'ExportAllDeclaration' ||
    nodeType === 'ExportDefaultDeclaration' ||
    nodeType === 'ExportNamedDeclaration' ||
    nodeType === 'ImportDeclaration' ||
    nodeType === 'DeclareClass' ||
    nodeType === 'DeclareFunction' ||
    nodeType === 'DeclareInterface' ||
    nodeType === 'DeclareModule' ||
    nodeType === 'DeclareModuleExports' ||
    nodeType === 'DeclareTypeAlias' ||
    nodeType === 'DeclareOpaqueType' ||
    nodeType === 'DeclareVariable' ||
    nodeType === 'DeclareExportDeclaration' ||
    nodeType === 'DeclareExportAllDeclaration' ||
    nodeType === 'InterfaceDeclaration' ||
    nodeType === 'OpaqueType' ||
    nodeType === 'TypeAlias' ||
    nodeType === 'EnumDeclaration' ||
    nodeType === 'TSDeclareFunction' ||
    nodeType === 'TSInterfaceDeclaration' ||
    nodeType === 'TSTypeAliasDeclaration' ||
    nodeType === 'TSEnumDeclaration' ||
    nodeType === 'TSModuleDeclaration' ||
    (nodeType === 'Placeholder' && node2.expectedNode === 'Declaration')
  ) {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isPatternLike(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (
    nodeType === 'Identifier' ||
    nodeType === 'RestElement' ||
    nodeType === 'AssignmentPattern' ||
    nodeType === 'ArrayPattern' ||
    nodeType === 'ObjectPattern' ||
    nodeType === 'TSAsExpression' ||
    nodeType === 'TSTypeAssertion' ||
    nodeType === 'TSNonNullExpression' ||
    (nodeType === 'Placeholder' && (node2.expectedNode === 'Pattern' || node2.expectedNode === 'Identifier'))
  ) {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isLVal(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (
    nodeType === 'Identifier' ||
    nodeType === 'MemberExpression' ||
    nodeType === 'RestElement' ||
    nodeType === 'AssignmentPattern' ||
    nodeType === 'ArrayPattern' ||
    nodeType === 'ObjectPattern' ||
    nodeType === 'TSParameterProperty' ||
    nodeType === 'TSAsExpression' ||
    nodeType === 'TSTypeAssertion' ||
    nodeType === 'TSNonNullExpression' ||
    (nodeType === 'Placeholder' && (node2.expectedNode === 'Pattern' || node2.expectedNode === 'Identifier'))
  ) {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTSEntityName(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (
    nodeType === 'Identifier' ||
    nodeType === 'TSQualifiedName' ||
    (nodeType === 'Placeholder' && node2.expectedNode === 'Identifier')
  ) {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isLiteral$5(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (
    nodeType === 'StringLiteral' ||
    nodeType === 'NumericLiteral' ||
    nodeType === 'NullLiteral' ||
    nodeType === 'BooleanLiteral' ||
    nodeType === 'RegExpLiteral' ||
    nodeType === 'TemplateLiteral' ||
    nodeType === 'BigIntLiteral' ||
    nodeType === 'DecimalLiteral' ||
    (nodeType === 'Placeholder' && node2.expectedNode === 'StringLiteral')
  ) {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isImmutable$2(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (
    nodeType === 'StringLiteral' ||
    nodeType === 'NumericLiteral' ||
    nodeType === 'NullLiteral' ||
    nodeType === 'BooleanLiteral' ||
    nodeType === 'BigIntLiteral' ||
    nodeType === 'JSXAttribute' ||
    nodeType === 'JSXClosingElement' ||
    nodeType === 'JSXElement' ||
    nodeType === 'JSXExpressionContainer' ||
    nodeType === 'JSXSpreadChild' ||
    nodeType === 'JSXOpeningElement' ||
    nodeType === 'JSXText' ||
    nodeType === 'JSXFragment' ||
    nodeType === 'JSXOpeningFragment' ||
    nodeType === 'JSXClosingFragment' ||
    nodeType === 'DecimalLiteral' ||
    (nodeType === 'Placeholder' && node2.expectedNode === 'StringLiteral')
  ) {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isUserWhitespacable(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (
    nodeType === 'ObjectMethod' ||
    nodeType === 'ObjectProperty' ||
    nodeType === 'ObjectTypeInternalSlot' ||
    nodeType === 'ObjectTypeCallProperty' ||
    nodeType === 'ObjectTypeIndexer' ||
    nodeType === 'ObjectTypeProperty' ||
    nodeType === 'ObjectTypeSpreadProperty'
  ) {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isMethod$1(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'ObjectMethod' || nodeType === 'ClassMethod' || nodeType === 'ClassPrivateMethod') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isObjectMember(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'ObjectMethod' || nodeType === 'ObjectProperty') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isProperty$1(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (
    nodeType === 'ObjectProperty' ||
    nodeType === 'ClassProperty' ||
    nodeType === 'ClassAccessorProperty' ||
    nodeType === 'ClassPrivateProperty'
  ) {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isUnaryLike$1(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'UnaryExpression' || nodeType === 'SpreadElement') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isPattern(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (
    nodeType === 'AssignmentPattern' ||
    nodeType === 'ArrayPattern' ||
    nodeType === 'ObjectPattern' ||
    (nodeType === 'Placeholder' && node2.expectedNode === 'Pattern')
  ) {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isClass$1(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'ClassExpression' || nodeType === 'ClassDeclaration') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isModuleDeclaration$1(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (
    nodeType === 'ExportAllDeclaration' ||
    nodeType === 'ExportDefaultDeclaration' ||
    nodeType === 'ExportNamedDeclaration' ||
    nodeType === 'ImportDeclaration'
  ) {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isExportDeclaration$2(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (
    nodeType === 'ExportAllDeclaration' ||
    nodeType === 'ExportDefaultDeclaration' ||
    nodeType === 'ExportNamedDeclaration'
  ) {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isModuleSpecifier$1(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (
    nodeType === 'ExportSpecifier' ||
    nodeType === 'ImportDefaultSpecifier' ||
    nodeType === 'ImportNamespaceSpecifier' ||
    nodeType === 'ImportSpecifier' ||
    nodeType === 'ExportNamespaceSpecifier' ||
    nodeType === 'ExportDefaultSpecifier'
  ) {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isAccessor(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'ClassAccessorProperty') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isPrivate(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'ClassPrivateProperty' || nodeType === 'ClassPrivateMethod' || nodeType === 'PrivateName') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isFlow$1(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (
    nodeType === 'AnyTypeAnnotation' ||
    nodeType === 'ArrayTypeAnnotation' ||
    nodeType === 'BooleanTypeAnnotation' ||
    nodeType === 'BooleanLiteralTypeAnnotation' ||
    nodeType === 'NullLiteralTypeAnnotation' ||
    nodeType === 'ClassImplements' ||
    nodeType === 'DeclareClass' ||
    nodeType === 'DeclareFunction' ||
    nodeType === 'DeclareInterface' ||
    nodeType === 'DeclareModule' ||
    nodeType === 'DeclareModuleExports' ||
    nodeType === 'DeclareTypeAlias' ||
    nodeType === 'DeclareOpaqueType' ||
    nodeType === 'DeclareVariable' ||
    nodeType === 'DeclareExportDeclaration' ||
    nodeType === 'DeclareExportAllDeclaration' ||
    nodeType === 'DeclaredPredicate' ||
    nodeType === 'ExistsTypeAnnotation' ||
    nodeType === 'FunctionTypeAnnotation' ||
    nodeType === 'FunctionTypeParam' ||
    nodeType === 'GenericTypeAnnotation' ||
    nodeType === 'InferredPredicate' ||
    nodeType === 'InterfaceExtends' ||
    nodeType === 'InterfaceDeclaration' ||
    nodeType === 'InterfaceTypeAnnotation' ||
    nodeType === 'IntersectionTypeAnnotation' ||
    nodeType === 'MixedTypeAnnotation' ||
    nodeType === 'EmptyTypeAnnotation' ||
    nodeType === 'NullableTypeAnnotation' ||
    nodeType === 'NumberLiteralTypeAnnotation' ||
    nodeType === 'NumberTypeAnnotation' ||
    nodeType === 'ObjectTypeAnnotation' ||
    nodeType === 'ObjectTypeInternalSlot' ||
    nodeType === 'ObjectTypeCallProperty' ||
    nodeType === 'ObjectTypeIndexer' ||
    nodeType === 'ObjectTypeProperty' ||
    nodeType === 'ObjectTypeSpreadProperty' ||
    nodeType === 'OpaqueType' ||
    nodeType === 'QualifiedTypeIdentifier' ||
    nodeType === 'StringLiteralTypeAnnotation' ||
    nodeType === 'StringTypeAnnotation' ||
    nodeType === 'SymbolTypeAnnotation' ||
    nodeType === 'ThisTypeAnnotation' ||
    nodeType === 'TupleTypeAnnotation' ||
    nodeType === 'TypeofTypeAnnotation' ||
    nodeType === 'TypeAlias' ||
    nodeType === 'TypeAnnotation' ||
    nodeType === 'TypeCastExpression' ||
    nodeType === 'TypeParameter' ||
    nodeType === 'TypeParameterDeclaration' ||
    nodeType === 'TypeParameterInstantiation' ||
    nodeType === 'UnionTypeAnnotation' ||
    nodeType === 'Variance' ||
    nodeType === 'VoidTypeAnnotation' ||
    nodeType === 'EnumDeclaration' ||
    nodeType === 'EnumBooleanBody' ||
    nodeType === 'EnumNumberBody' ||
    nodeType === 'EnumStringBody' ||
    nodeType === 'EnumSymbolBody' ||
    nodeType === 'EnumBooleanMember' ||
    nodeType === 'EnumNumberMember' ||
    nodeType === 'EnumStringMember' ||
    nodeType === 'EnumDefaultedMember' ||
    nodeType === 'IndexedAccessType' ||
    nodeType === 'OptionalIndexedAccessType'
  ) {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isFlowType(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (
    nodeType === 'AnyTypeAnnotation' ||
    nodeType === 'ArrayTypeAnnotation' ||
    nodeType === 'BooleanTypeAnnotation' ||
    nodeType === 'BooleanLiteralTypeAnnotation' ||
    nodeType === 'NullLiteralTypeAnnotation' ||
    nodeType === 'ExistsTypeAnnotation' ||
    nodeType === 'FunctionTypeAnnotation' ||
    nodeType === 'GenericTypeAnnotation' ||
    nodeType === 'InterfaceTypeAnnotation' ||
    nodeType === 'IntersectionTypeAnnotation' ||
    nodeType === 'MixedTypeAnnotation' ||
    nodeType === 'EmptyTypeAnnotation' ||
    nodeType === 'NullableTypeAnnotation' ||
    nodeType === 'NumberLiteralTypeAnnotation' ||
    nodeType === 'NumberTypeAnnotation' ||
    nodeType === 'ObjectTypeAnnotation' ||
    nodeType === 'StringLiteralTypeAnnotation' ||
    nodeType === 'StringTypeAnnotation' ||
    nodeType === 'SymbolTypeAnnotation' ||
    nodeType === 'ThisTypeAnnotation' ||
    nodeType === 'TupleTypeAnnotation' ||
    nodeType === 'TypeofTypeAnnotation' ||
    nodeType === 'UnionTypeAnnotation' ||
    nodeType === 'VoidTypeAnnotation' ||
    nodeType === 'IndexedAccessType' ||
    nodeType === 'OptionalIndexedAccessType'
  ) {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isFlowBaseAnnotation$1(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (
    nodeType === 'AnyTypeAnnotation' ||
    nodeType === 'BooleanTypeAnnotation' ||
    nodeType === 'NullLiteralTypeAnnotation' ||
    nodeType === 'MixedTypeAnnotation' ||
    nodeType === 'EmptyTypeAnnotation' ||
    nodeType === 'NumberTypeAnnotation' ||
    nodeType === 'StringTypeAnnotation' ||
    nodeType === 'SymbolTypeAnnotation' ||
    nodeType === 'ThisTypeAnnotation' ||
    nodeType === 'VoidTypeAnnotation'
  ) {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isFlowDeclaration(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (
    nodeType === 'DeclareClass' ||
    nodeType === 'DeclareFunction' ||
    nodeType === 'DeclareInterface' ||
    nodeType === 'DeclareModule' ||
    nodeType === 'DeclareModuleExports' ||
    nodeType === 'DeclareTypeAlias' ||
    nodeType === 'DeclareOpaqueType' ||
    nodeType === 'DeclareVariable' ||
    nodeType === 'DeclareExportDeclaration' ||
    nodeType === 'DeclareExportAllDeclaration' ||
    nodeType === 'InterfaceDeclaration' ||
    nodeType === 'OpaqueType' ||
    nodeType === 'TypeAlias'
  ) {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isFlowPredicate(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'DeclaredPredicate' || nodeType === 'InferredPredicate') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isEnumBody(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (
    nodeType === 'EnumBooleanBody' ||
    nodeType === 'EnumNumberBody' ||
    nodeType === 'EnumStringBody' ||
    nodeType === 'EnumSymbolBody'
  ) {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isEnumMember(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (
    nodeType === 'EnumBooleanMember' ||
    nodeType === 'EnumNumberMember' ||
    nodeType === 'EnumStringMember' ||
    nodeType === 'EnumDefaultedMember'
  ) {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isJSX(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (
    nodeType === 'JSXAttribute' ||
    nodeType === 'JSXClosingElement' ||
    nodeType === 'JSXElement' ||
    nodeType === 'JSXEmptyExpression' ||
    nodeType === 'JSXExpressionContainer' ||
    nodeType === 'JSXSpreadChild' ||
    nodeType === 'JSXIdentifier' ||
    nodeType === 'JSXMemberExpression' ||
    nodeType === 'JSXNamespacedName' ||
    nodeType === 'JSXOpeningElement' ||
    nodeType === 'JSXSpreadAttribute' ||
    nodeType === 'JSXText' ||
    nodeType === 'JSXFragment' ||
    nodeType === 'JSXOpeningFragment' ||
    nodeType === 'JSXClosingFragment'
  ) {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isMiscellaneous(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'Noop' || nodeType === 'Placeholder' || nodeType === 'V8IntrinsicIdentifier') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTypeScript(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (
    nodeType === 'TSParameterProperty' ||
    nodeType === 'TSDeclareFunction' ||
    nodeType === 'TSDeclareMethod' ||
    nodeType === 'TSQualifiedName' ||
    nodeType === 'TSCallSignatureDeclaration' ||
    nodeType === 'TSConstructSignatureDeclaration' ||
    nodeType === 'TSPropertySignature' ||
    nodeType === 'TSMethodSignature' ||
    nodeType === 'TSIndexSignature' ||
    nodeType === 'TSAnyKeyword' ||
    nodeType === 'TSBooleanKeyword' ||
    nodeType === 'TSBigIntKeyword' ||
    nodeType === 'TSIntrinsicKeyword' ||
    nodeType === 'TSNeverKeyword' ||
    nodeType === 'TSNullKeyword' ||
    nodeType === 'TSNumberKeyword' ||
    nodeType === 'TSObjectKeyword' ||
    nodeType === 'TSStringKeyword' ||
    nodeType === 'TSSymbolKeyword' ||
    nodeType === 'TSUndefinedKeyword' ||
    nodeType === 'TSUnknownKeyword' ||
    nodeType === 'TSVoidKeyword' ||
    nodeType === 'TSThisType' ||
    nodeType === 'TSFunctionType' ||
    nodeType === 'TSConstructorType' ||
    nodeType === 'TSTypeReference' ||
    nodeType === 'TSTypePredicate' ||
    nodeType === 'TSTypeQuery' ||
    nodeType === 'TSTypeLiteral' ||
    nodeType === 'TSArrayType' ||
    nodeType === 'TSTupleType' ||
    nodeType === 'TSOptionalType' ||
    nodeType === 'TSRestType' ||
    nodeType === 'TSNamedTupleMember' ||
    nodeType === 'TSUnionType' ||
    nodeType === 'TSIntersectionType' ||
    nodeType === 'TSConditionalType' ||
    nodeType === 'TSInferType' ||
    nodeType === 'TSParenthesizedType' ||
    nodeType === 'TSTypeOperator' ||
    nodeType === 'TSIndexedAccessType' ||
    nodeType === 'TSMappedType' ||
    nodeType === 'TSLiteralType' ||
    nodeType === 'TSExpressionWithTypeArguments' ||
    nodeType === 'TSInterfaceDeclaration' ||
    nodeType === 'TSInterfaceBody' ||
    nodeType === 'TSTypeAliasDeclaration' ||
    nodeType === 'TSInstantiationExpression' ||
    nodeType === 'TSAsExpression' ||
    nodeType === 'TSTypeAssertion' ||
    nodeType === 'TSEnumDeclaration' ||
    nodeType === 'TSEnumMember' ||
    nodeType === 'TSModuleDeclaration' ||
    nodeType === 'TSModuleBlock' ||
    nodeType === 'TSImportType' ||
    nodeType === 'TSImportEqualsDeclaration' ||
    nodeType === 'TSExternalModuleReference' ||
    nodeType === 'TSNonNullExpression' ||
    nodeType === 'TSExportAssignment' ||
    nodeType === 'TSNamespaceExportDeclaration' ||
    nodeType === 'TSTypeAnnotation' ||
    nodeType === 'TSTypeParameterInstantiation' ||
    nodeType === 'TSTypeParameterDeclaration' ||
    nodeType === 'TSTypeParameter'
  ) {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTSTypeElement(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (
    nodeType === 'TSCallSignatureDeclaration' ||
    nodeType === 'TSConstructSignatureDeclaration' ||
    nodeType === 'TSPropertySignature' ||
    nodeType === 'TSMethodSignature' ||
    nodeType === 'TSIndexSignature'
  ) {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTSType(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (
    nodeType === 'TSAnyKeyword' ||
    nodeType === 'TSBooleanKeyword' ||
    nodeType === 'TSBigIntKeyword' ||
    nodeType === 'TSIntrinsicKeyword' ||
    nodeType === 'TSNeverKeyword' ||
    nodeType === 'TSNullKeyword' ||
    nodeType === 'TSNumberKeyword' ||
    nodeType === 'TSObjectKeyword' ||
    nodeType === 'TSStringKeyword' ||
    nodeType === 'TSSymbolKeyword' ||
    nodeType === 'TSUndefinedKeyword' ||
    nodeType === 'TSUnknownKeyword' ||
    nodeType === 'TSVoidKeyword' ||
    nodeType === 'TSThisType' ||
    nodeType === 'TSFunctionType' ||
    nodeType === 'TSConstructorType' ||
    nodeType === 'TSTypeReference' ||
    nodeType === 'TSTypePredicate' ||
    nodeType === 'TSTypeQuery' ||
    nodeType === 'TSTypeLiteral' ||
    nodeType === 'TSArrayType' ||
    nodeType === 'TSTupleType' ||
    nodeType === 'TSOptionalType' ||
    nodeType === 'TSRestType' ||
    nodeType === 'TSUnionType' ||
    nodeType === 'TSIntersectionType' ||
    nodeType === 'TSConditionalType' ||
    nodeType === 'TSInferType' ||
    nodeType === 'TSParenthesizedType' ||
    nodeType === 'TSTypeOperator' ||
    nodeType === 'TSIndexedAccessType' ||
    nodeType === 'TSMappedType' ||
    nodeType === 'TSLiteralType' ||
    nodeType === 'TSExpressionWithTypeArguments' ||
    nodeType === 'TSImportType'
  ) {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isTSBaseType(node2, opts) {
  if (!node2) return false
  const nodeType = node2.type
  if (
    nodeType === 'TSAnyKeyword' ||
    nodeType === 'TSBooleanKeyword' ||
    nodeType === 'TSBigIntKeyword' ||
    nodeType === 'TSIntrinsicKeyword' ||
    nodeType === 'TSNeverKeyword' ||
    nodeType === 'TSNullKeyword' ||
    nodeType === 'TSNumberKeyword' ||
    nodeType === 'TSObjectKeyword' ||
    nodeType === 'TSStringKeyword' ||
    nodeType === 'TSSymbolKeyword' ||
    nodeType === 'TSUndefinedKeyword' ||
    nodeType === 'TSUnknownKeyword' ||
    nodeType === 'TSVoidKeyword' ||
    nodeType === 'TSThisType' ||
    nodeType === 'TSLiteralType'
  ) {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isNumberLiteral(node2, opts) {
  console.trace('The node type NumberLiteral has been renamed to NumericLiteral')
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'NumberLiteral') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isRegexLiteral(node2, opts) {
  console.trace('The node type RegexLiteral has been renamed to RegExpLiteral')
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'RegexLiteral') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isRestProperty(node2, opts) {
  console.trace('The node type RestProperty has been renamed to RestElement')
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'RestProperty') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
function isSpreadProperty(node2, opts) {
  console.trace('The node type SpreadProperty has been renamed to SpreadElement')
  if (!node2) return false
  const nodeType = node2.type
  if (nodeType === 'SpreadProperty') {
    if (typeof opts === 'undefined') {
      return true
    } else {
      return (0, _shallowEqual$1.default)(node2, opts)
    }
  }
  return false
}
Object.defineProperty(matchesPattern$3, '__esModule', {
  value: true,
})
matchesPattern$3.default = matchesPattern$2
var _generated$o = generated$4
function matchesPattern$2(member, match, allowPartial) {
  if (!(0, _generated$o.isMemberExpression)(member)) return false
  const parts = Array.isArray(match) ? match : match.split('.')
  const nodes2 = []
  let node2
  for (node2 = member; (0, _generated$o.isMemberExpression)(node2); node2 = node2.object) {
    nodes2.push(node2.property)
  }
  nodes2.push(node2)
  if (nodes2.length < parts.length) return false
  if (!allowPartial && nodes2.length > parts.length) return false
  for (let i = 0, j = nodes2.length - 1; i < parts.length; i++, j--) {
    const node3 = nodes2[j]
    let value
    if ((0, _generated$o.isIdentifier)(node3)) {
      value = node3.name
    } else if ((0, _generated$o.isStringLiteral)(node3)) {
      value = node3.value
    } else if ((0, _generated$o.isThisExpression)(node3)) {
      value = 'this'
    } else {
      return false
    }
    if (parts[i] !== value) return false
  }
  return true
}
Object.defineProperty(buildMatchMemberExpression$1, '__esModule', {
  value: true,
})
buildMatchMemberExpression$1.default = buildMatchMemberExpression
var _matchesPattern$1 = matchesPattern$3
function buildMatchMemberExpression(match, allowPartial) {
  const parts = match.split('.')
  return (member) => (0, _matchesPattern$1.default)(member, parts, allowPartial)
}
Object.defineProperty(isReactComponent$1, '__esModule', {
  value: true,
})
isReactComponent$1.default = void 0
var _buildMatchMemberExpression = buildMatchMemberExpression$1
const isReactComponent = (0, _buildMatchMemberExpression.default)('React.Component')
var _default$d = isReactComponent
isReactComponent$1.default = _default$d
var isCompatTag$2 = {}
Object.defineProperty(isCompatTag$2, '__esModule', {
  value: true,
})
isCompatTag$2.default = isCompatTag$1
function isCompatTag$1(tagName) {
  return !!tagName && /^[a-z]/.test(tagName)
}
var buildChildren$1 = {}
var cleanJSXElementLiteralChild$1 = {}
var generated$3 = {}
var validateNode$1 = {}
var validate$6 = {}
var definitions = {}
let fastProto = null
function FastObject(o) {
  if (fastProto !== null && typeof fastProto.property) {
    const result = fastProto
    fastProto = FastObject.prototype = null
    return result
  }
  fastProto = FastObject.prototype = o == null ? /* @__PURE__ */ Object.create(null) : o
  return new FastObject()
}
FastObject()
var toFastProperties = function toFastproperties(o) {
  return FastObject(o)
}
var core = {}
var is$2 = {}
var isType$3 = {}
Object.defineProperty(isType$3, '__esModule', {
  value: true,
})
isType$3.default = isType$2
var _definitions$9 = definitions
function isType$2(nodeType, targetType) {
  if (nodeType === targetType) return true
  if (_definitions$9.ALIAS_KEYS[targetType]) return false
  const aliases = _definitions$9.FLIPPED_ALIAS_KEYS[targetType]
  if (aliases) {
    if (aliases[0] === nodeType) return true
    for (const alias of aliases) {
      if (nodeType === alias) return true
    }
  }
  return false
}
var isPlaceholderType$1 = {}
Object.defineProperty(isPlaceholderType$1, '__esModule', {
  value: true,
})
isPlaceholderType$1.default = isPlaceholderType
var _definitions$8 = definitions
function isPlaceholderType(placeholderType, targetType) {
  if (placeholderType === targetType) return true
  const aliases = _definitions$8.PLACEHOLDERS_ALIAS[placeholderType]
  if (aliases) {
    for (const alias of aliases) {
      if (targetType === alias) return true
    }
  }
  return false
}
Object.defineProperty(is$2, '__esModule', {
  value: true,
})
is$2.default = is$1
var _shallowEqual = shallowEqual$1
var _isType$1 = isType$3
var _isPlaceholderType = isPlaceholderType$1
var _definitions$7 = definitions
function is$1(type, node2, opts) {
  if (!node2) return false
  const matches = (0, _isType$1.default)(node2.type, type)
  if (!matches) {
    if (!opts && node2.type === 'Placeholder' && type in _definitions$7.FLIPPED_ALIAS_KEYS) {
      return (0, _isPlaceholderType.default)(node2.expectedNode, type)
    }
    return false
  }
  if (typeof opts === 'undefined') {
    return true
  } else {
    return (0, _shallowEqual.default)(node2, opts)
  }
}
var isValidIdentifier$1 = {}
var lib$a = {}
var identifier$8 = {}
Object.defineProperty(identifier$8, '__esModule', {
  value: true,
})
identifier$8.isIdentifierChar = isIdentifierChar$2
identifier$8.isIdentifierName = isIdentifierName
identifier$8.isIdentifierStart = isIdentifierStart$2
let nonASCIIidentifierStartChars$2 =
  '\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC'
let nonASCIIidentifierChars$2 =
  '\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F'
const nonASCIIidentifierStart$2 = new RegExp('[' + nonASCIIidentifierStartChars$2 + ']')
const nonASCIIidentifier$2 = new RegExp('[' + nonASCIIidentifierStartChars$2 + nonASCIIidentifierChars$2 + ']')
nonASCIIidentifierStartChars$2 = nonASCIIidentifierChars$2 = null
const astralIdentifierStartCodes$2 = [
  0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7,
  2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11,
  7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7,
  1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50,
  14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30,
  0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1,
  3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21,
  0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0,
  2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26,
  5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1070, 4050, 582, 8634, 568, 8, 30,
  18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8,
  8936, 3, 2, 6, 2, 1, 2, 290, 46, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3,
  3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2,
  30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 482, 44, 11, 6, 17, 0, 322, 29, 19, 43, 1269, 6, 2, 3, 2, 1, 2,
  14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2,
  1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421,
  42719, 33, 4152, 8, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938,
]
const astralIdentifierCodes$2 = [
  509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 50, 3, 123,
  2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83,
  11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9,
  214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9,
  120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1,
  2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0,
  12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23,
  4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 357, 0, 62, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719,
  239,
]
function isInAstralSet$2(code2, set) {
  let pos = 65536
  for (let i = 0, length = set.length; i < length; i += 2) {
    pos += set[i]
    if (pos > code2) return false
    pos += set[i + 1]
    if (pos >= code2) return true
  }
  return false
}
function isIdentifierStart$2(code2) {
  if (code2 < 65) return code2 === 36
  if (code2 <= 90) return true
  if (code2 < 97) return code2 === 95
  if (code2 <= 122) return true
  if (code2 <= 65535) {
    return code2 >= 170 && nonASCIIidentifierStart$2.test(String.fromCharCode(code2))
  }
  return isInAstralSet$2(code2, astralIdentifierStartCodes$2)
}
function isIdentifierChar$2(code2) {
  if (code2 < 48) return code2 === 36
  if (code2 < 58) return true
  if (code2 < 65) return false
  if (code2 <= 90) return true
  if (code2 < 97) return code2 === 95
  if (code2 <= 122) return true
  if (code2 <= 65535) {
    return code2 >= 170 && nonASCIIidentifier$2.test(String.fromCharCode(code2))
  }
  return isInAstralSet$2(code2, astralIdentifierStartCodes$2) || isInAstralSet$2(code2, astralIdentifierCodes$2)
}
function isIdentifierName(name) {
  let isFirst = true
  for (let i = 0; i < name.length; i++) {
    let cp = name.charCodeAt(i)
    if ((cp & 64512) === 55296 && i + 1 < name.length) {
      const trail = name.charCodeAt(++i)
      if ((trail & 64512) === 56320) {
        cp = 65536 + ((cp & 1023) << 10) + (trail & 1023)
      }
    }
    if (isFirst) {
      isFirst = false
      if (!isIdentifierStart$2(cp)) {
        return false
      }
    } else if (!isIdentifierChar$2(cp)) {
      return false
    }
  }
  return !isFirst
}
var keyword = {}
Object.defineProperty(keyword, '__esModule', {
  value: true,
})
keyword.isKeyword = isKeyword$2
keyword.isReservedWord = isReservedWord$2
keyword.isStrictBindOnlyReservedWord = isStrictBindOnlyReservedWord$2
keyword.isStrictBindReservedWord = isStrictBindReservedWord$2
keyword.isStrictReservedWord = isStrictReservedWord$2
const reservedWords$2 = {
  keyword: [
    'break',
    'case',
    'catch',
    'continue',
    'debugger',
    'default',
    'do',
    'else',
    'finally',
    'for',
    'function',
    'if',
    'return',
    'switch',
    'throw',
    'try',
    'var',
    'const',
    'while',
    'with',
    'new',
    'this',
    'super',
    'class',
    'extends',
    'export',
    'import',
    'null',
    'true',
    'false',
    'in',
    'instanceof',
    'typeof',
    'void',
    'delete',
  ],
  strict: ['implements', 'interface', 'let', 'package', 'private', 'protected', 'public', 'static', 'yield'],
  strictBind: ['eval', 'arguments'],
}
const keywords$3 = new Set(reservedWords$2.keyword)
const reservedWordsStrictSet$2 = new Set(reservedWords$2.strict)
const reservedWordsStrictBindSet$2 = new Set(reservedWords$2.strictBind)
function isReservedWord$2(word, inModule) {
  return (inModule && word === 'await') || word === 'enum'
}
function isStrictReservedWord$2(word, inModule) {
  return isReservedWord$2(word, inModule) || reservedWordsStrictSet$2.has(word)
}
function isStrictBindOnlyReservedWord$2(word) {
  return reservedWordsStrictBindSet$2.has(word)
}
function isStrictBindReservedWord$2(word, inModule) {
  return isStrictReservedWord$2(word, inModule) || isStrictBindOnlyReservedWord$2(word)
}
function isKeyword$2(word) {
  return keywords$3.has(word)
}
;(function (exports) {
  Object.defineProperty(exports, '__esModule', {
    value: true,
  })
  Object.defineProperty(exports, 'isIdentifierChar', {
    enumerable: true,
    get: function () {
      return _identifier.isIdentifierChar
    },
  })
  Object.defineProperty(exports, 'isIdentifierName', {
    enumerable: true,
    get: function () {
      return _identifier.isIdentifierName
    },
  })
  Object.defineProperty(exports, 'isIdentifierStart', {
    enumerable: true,
    get: function () {
      return _identifier.isIdentifierStart
    },
  })
  Object.defineProperty(exports, 'isKeyword', {
    enumerable: true,
    get: function () {
      return _keyword.isKeyword
    },
  })
  Object.defineProperty(exports, 'isReservedWord', {
    enumerable: true,
    get: function () {
      return _keyword.isReservedWord
    },
  })
  Object.defineProperty(exports, 'isStrictBindOnlyReservedWord', {
    enumerable: true,
    get: function () {
      return _keyword.isStrictBindOnlyReservedWord
    },
  })
  Object.defineProperty(exports, 'isStrictBindReservedWord', {
    enumerable: true,
    get: function () {
      return _keyword.isStrictBindReservedWord
    },
  })
  Object.defineProperty(exports, 'isStrictReservedWord', {
    enumerable: true,
    get: function () {
      return _keyword.isStrictReservedWord
    },
  })
  var _identifier = identifier$8
  var _keyword = keyword
})(lib$a)
Object.defineProperty(isValidIdentifier$1, '__esModule', {
  value: true,
})
isValidIdentifier$1.default = isValidIdentifier
var _helperValidatorIdentifier$3 = lib$a
function isValidIdentifier(name, reserved = true) {
  if (typeof name !== 'string') return false
  if (reserved) {
    if (
      (0, _helperValidatorIdentifier$3.isKeyword)(name) ||
      (0, _helperValidatorIdentifier$3.isStrictReservedWord)(name, true)
    ) {
      return false
    }
  }
  return (0, _helperValidatorIdentifier$3.isIdentifierName)(name)
}
var constants = {}
Object.defineProperty(constants, '__esModule', {
  value: true,
})
constants.UPDATE_OPERATORS =
  constants.UNARY_OPERATORS =
  constants.STRING_UNARY_OPERATORS =
  constants.STATEMENT_OR_BLOCK_KEYS =
  constants.NUMBER_UNARY_OPERATORS =
  constants.NUMBER_BINARY_OPERATORS =
  constants.NOT_LOCAL_BINDING =
  constants.LOGICAL_OPERATORS =
  constants.INHERIT_KEYS =
  constants.FOR_INIT_KEYS =
  constants.FLATTENABLE_KEYS =
  constants.EQUALITY_BINARY_OPERATORS =
  constants.COMPARISON_BINARY_OPERATORS =
  constants.COMMENT_KEYS =
  constants.BOOLEAN_UNARY_OPERATORS =
  constants.BOOLEAN_NUMBER_BINARY_OPERATORS =
  constants.BOOLEAN_BINARY_OPERATORS =
  constants.BLOCK_SCOPED_SYMBOL =
  constants.BINARY_OPERATORS =
  constants.ASSIGNMENT_OPERATORS =
    void 0
const STATEMENT_OR_BLOCK_KEYS$1 = ['consequent', 'body', 'alternate']
constants.STATEMENT_OR_BLOCK_KEYS = STATEMENT_OR_BLOCK_KEYS$1
const FLATTENABLE_KEYS = ['body', 'expressions']
constants.FLATTENABLE_KEYS = FLATTENABLE_KEYS
const FOR_INIT_KEYS = ['left', 'init']
constants.FOR_INIT_KEYS = FOR_INIT_KEYS
const COMMENT_KEYS = ['leadingComments', 'trailingComments', 'innerComments']
constants.COMMENT_KEYS = COMMENT_KEYS
const LOGICAL_OPERATORS$1 = ['||', '&&', '??']
constants.LOGICAL_OPERATORS = LOGICAL_OPERATORS$1
const UPDATE_OPERATORS = ['++', '--']
constants.UPDATE_OPERATORS = UPDATE_OPERATORS
const BOOLEAN_NUMBER_BINARY_OPERATORS$1 = ['>', '<', '>=', '<=']
constants.BOOLEAN_NUMBER_BINARY_OPERATORS = BOOLEAN_NUMBER_BINARY_OPERATORS$1
const EQUALITY_BINARY_OPERATORS = ['==', '===', '!=', '!==']
constants.EQUALITY_BINARY_OPERATORS = EQUALITY_BINARY_OPERATORS
const COMPARISON_BINARY_OPERATORS = [...EQUALITY_BINARY_OPERATORS, 'in', 'instanceof']
constants.COMPARISON_BINARY_OPERATORS = COMPARISON_BINARY_OPERATORS
const BOOLEAN_BINARY_OPERATORS = [...COMPARISON_BINARY_OPERATORS, ...BOOLEAN_NUMBER_BINARY_OPERATORS$1]
constants.BOOLEAN_BINARY_OPERATORS = BOOLEAN_BINARY_OPERATORS
const NUMBER_BINARY_OPERATORS = ['-', '/', '%', '*', '**', '&', '|', '>>', '>>>', '<<', '^']
constants.NUMBER_BINARY_OPERATORS = NUMBER_BINARY_OPERATORS
const BINARY_OPERATORS = ['+', ...NUMBER_BINARY_OPERATORS, ...BOOLEAN_BINARY_OPERATORS, '|>']
constants.BINARY_OPERATORS = BINARY_OPERATORS
const ASSIGNMENT_OPERATORS = [
  '=',
  '+=',
  ...NUMBER_BINARY_OPERATORS.map((op) => op + '='),
  ...LOGICAL_OPERATORS$1.map((op) => op + '='),
]
constants.ASSIGNMENT_OPERATORS = ASSIGNMENT_OPERATORS
const BOOLEAN_UNARY_OPERATORS = ['delete', '!']
constants.BOOLEAN_UNARY_OPERATORS = BOOLEAN_UNARY_OPERATORS
const NUMBER_UNARY_OPERATORS = ['+', '-', '~']
constants.NUMBER_UNARY_OPERATORS = NUMBER_UNARY_OPERATORS
const STRING_UNARY_OPERATORS = ['typeof']
constants.STRING_UNARY_OPERATORS = STRING_UNARY_OPERATORS
const UNARY_OPERATORS = [
  'void',
  'throw',
  ...BOOLEAN_UNARY_OPERATORS,
  ...NUMBER_UNARY_OPERATORS,
  ...STRING_UNARY_OPERATORS,
]
constants.UNARY_OPERATORS = UNARY_OPERATORS
const INHERIT_KEYS = {
  optional: ['typeAnnotation', 'typeParameters', 'returnType'],
  force: ['start', 'loc', 'end'],
}
constants.INHERIT_KEYS = INHERIT_KEYS
const BLOCK_SCOPED_SYMBOL = Symbol.for('var used to be block scoped')
constants.BLOCK_SCOPED_SYMBOL = BLOCK_SCOPED_SYMBOL
const NOT_LOCAL_BINDING$2 = Symbol.for('should not be considered a local binding')
constants.NOT_LOCAL_BINDING = NOT_LOCAL_BINDING$2
var utils = {}
Object.defineProperty(utils, '__esModule', {
  value: true,
})
utils.VISITOR_KEYS =
  utils.NODE_PARENT_VALIDATIONS =
  utils.NODE_FIELDS =
  utils.FLIPPED_ALIAS_KEYS =
  utils.DEPRECATED_KEYS =
  utils.BUILDER_KEYS =
  utils.ALIAS_KEYS =
    void 0
utils.arrayOf = arrayOf
utils.arrayOfType = arrayOfType
utils.assertEach = assertEach
utils.assertNodeOrValueType = assertNodeOrValueType
utils.assertNodeType = assertNodeType
utils.assertOneOf = assertOneOf
utils.assertOptionalChainStart = assertOptionalChainStart
utils.assertShape = assertShape
utils.assertValueType = assertValueType
utils.chain = chain
utils.default = defineType$5
utils.defineAliasedType = defineAliasedType
utils.typeIs = typeIs
utils.validate = validate$5
utils.validateArrayOfType = validateArrayOfType
utils.validateOptional = validateOptional
utils.validateOptionalType = validateOptionalType
utils.validateType = validateType
var _is$3 = is$2
var _validate$1 = validate$6
const VISITOR_KEYS$4 = {}
utils.VISITOR_KEYS = VISITOR_KEYS$4
const ALIAS_KEYS = {}
utils.ALIAS_KEYS = ALIAS_KEYS
const FLIPPED_ALIAS_KEYS$3 = {}
utils.FLIPPED_ALIAS_KEYS = FLIPPED_ALIAS_KEYS$3
const NODE_FIELDS = {}
utils.NODE_FIELDS = NODE_FIELDS
const BUILDER_KEYS = {}
utils.BUILDER_KEYS = BUILDER_KEYS
const DEPRECATED_KEYS$1 = {}
utils.DEPRECATED_KEYS = DEPRECATED_KEYS$1
const NODE_PARENT_VALIDATIONS = {}
utils.NODE_PARENT_VALIDATIONS = NODE_PARENT_VALIDATIONS
function getType(val) {
  if (Array.isArray(val)) {
    return 'array'
  } else if (val === null) {
    return 'null'
  } else {
    return typeof val
  }
}
function validate$5(validate2) {
  return {
    validate: validate2,
  }
}
function typeIs(typeName) {
  return typeof typeName === 'string' ? assertNodeType(typeName) : assertNodeType(...typeName)
}
function validateType(typeName) {
  return validate$5(typeIs(typeName))
}
function validateOptional(validate2) {
  return {
    validate: validate2,
    optional: true,
  }
}
function validateOptionalType(typeName) {
  return {
    validate: typeIs(typeName),
    optional: true,
  }
}
function arrayOf(elementType) {
  return chain(assertValueType('array'), assertEach(elementType))
}
function arrayOfType(typeName) {
  return arrayOf(typeIs(typeName))
}
function validateArrayOfType(typeName) {
  return validate$5(arrayOfType(typeName))
}
function assertEach(callback) {
  function validator(node2, key, val) {
    if (!Array.isArray(val)) return
    for (let i = 0; i < val.length; i++) {
      const subkey = `${key}[${i}]`
      const v = val[i]
      callback(node2, subkey, v)
      if ({}.BABEL_TYPES_8_BREAKING) (0, _validate$1.validateChild)(node2, subkey, v)
    }
  }
  validator.each = callback
  return validator
}
function assertOneOf(...values) {
  function validate2(node2, key, val) {
    if (values.indexOf(val) < 0) {
      throw new TypeError(
        `Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`
      )
    }
  }
  validate2.oneOf = values
  return validate2
}
function assertNodeType(...types2) {
  function validate2(node2, key, val) {
    for (const type of types2) {
      if ((0, _is$3.default)(type, val)) {
        ;(0, _validate$1.validateChild)(node2, key, val)
        return
      }
    }
    throw new TypeError(
      `Property ${key} of ${node2.type} expected node to be of a type ${JSON.stringify(
        types2
      )} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`
    )
  }
  validate2.oneOfNodeTypes = types2
  return validate2
}
function assertNodeOrValueType(...types2) {
  function validate2(node2, key, val) {
    for (const type of types2) {
      if (getType(val) === type || (0, _is$3.default)(type, val)) {
        ;(0, _validate$1.validateChild)(node2, key, val)
        return
      }
    }
    throw new TypeError(
      `Property ${key} of ${node2.type} expected node to be of a type ${JSON.stringify(
        types2
      )} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`
    )
  }
  validate2.oneOfNodeOrValueTypes = types2
  return validate2
}
function assertValueType(type) {
  function validate2(node2, key, val) {
    const valid = getType(val) === type
    if (!valid) {
      throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`)
    }
  }
  validate2.type = type
  return validate2
}
function assertShape(shape) {
  function validate2(node2, key, val) {
    const errors = []
    for (const property of Object.keys(shape)) {
      try {
        ;(0, _validate$1.validateField)(node2, property, val[property], shape[property])
      } catch (error) {
        if (error instanceof TypeError) {
          errors.push(error.message)
          continue
        }
        throw error
      }
    }
    if (errors.length) {
      throw new TypeError(`Property ${key} of ${node2.type} expected to have the following:
${errors.join('\n')}`)
    }
  }
  validate2.shapeOf = shape
  return validate2
}
function assertOptionalChainStart() {
  function validate2(node2) {
    var _current
    let current = node2
    while (node2) {
      const { type } = current
      if (type === 'OptionalCallExpression') {
        if (current.optional) return
        current = current.callee
        continue
      }
      if (type === 'OptionalMemberExpression') {
        if (current.optional) return
        current = current.object
        continue
      }
      break
    }
    throw new TypeError(
      `Non-optional ${
        node2.type
      } must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${
        (_current = current) == null ? void 0 : _current.type
      }`
    )
  }
  return validate2
}
function chain(...fns) {
  function validate2(...args) {
    for (const fn of fns) {
      fn(...args)
    }
  }
  validate2.chainOf = fns
  if (fns.length >= 2 && 'type' in fns[0] && fns[0].type === 'array' && !('each' in fns[1])) {
    throw new Error(`An assertValueType("array") validator can only be followed by an assertEach(...) validator.`)
  }
  return validate2
}
const validTypeOpts = ['aliases', 'builder', 'deprecatedAlias', 'fields', 'inherits', 'visitor', 'validate']
const validFieldKeys = ['default', 'optional', 'validate']
function defineAliasedType(...aliases) {
  return (type, opts = {}) => {
    let defined = opts.aliases
    if (!defined) {
      var _store$opts$inherits$, _defined
      if (opts.inherits)
        defined =
          (_store$opts$inherits$ = store[opts.inherits].aliases) == null ? void 0 : _store$opts$inherits$.slice()
      ;(_defined = defined) != null ? _defined : (defined = [])
      opts.aliases = defined
    }
    const additional = aliases.filter((a) => !defined.includes(a))
    defined.unshift(...additional)
    return defineType$5(type, opts)
  }
}
function defineType$5(type, opts = {}) {
  const inherits2 = (opts.inherits && store[opts.inherits]) || {}
  let fields = opts.fields
  if (!fields) {
    fields = {}
    if (inherits2.fields) {
      const keys = Object.getOwnPropertyNames(inherits2.fields)
      for (const key of keys) {
        const field = inherits2.fields[key]
        const def = field.default
        if (Array.isArray(def) ? def.length > 0 : def && typeof def === 'object') {
          throw new Error('field defaults can only be primitives or empty arrays currently')
        }
        fields[key] = {
          default: Array.isArray(def) ? [] : def,
          optional: field.optional,
          validate: field.validate,
        }
      }
    }
  }
  const visitor2 = opts.visitor || inherits2.visitor || []
  const aliases = opts.aliases || inherits2.aliases || []
  const builder2 = opts.builder || inherits2.builder || opts.visitor || []
  for (const k of Object.keys(opts)) {
    if (validTypeOpts.indexOf(k) === -1) {
      throw new Error(`Unknown type option "${k}" on ${type}`)
    }
  }
  if (opts.deprecatedAlias) {
    DEPRECATED_KEYS$1[opts.deprecatedAlias] = type
  }
  for (const key of visitor2.concat(builder2)) {
    fields[key] = fields[key] || {}
  }
  for (const key of Object.keys(fields)) {
    const field = fields[key]
    if (field.default !== void 0 && builder2.indexOf(key) === -1) {
      field.optional = true
    }
    if (field.default === void 0) {
      field.default = null
    } else if (!field.validate && field.default != null) {
      field.validate = assertValueType(getType(field.default))
    }
    for (const k of Object.keys(field)) {
      if (validFieldKeys.indexOf(k) === -1) {
        throw new Error(`Unknown field key "${k}" on ${type}.${key}`)
      }
    }
  }
  VISITOR_KEYS$4[type] = opts.visitor = visitor2
  BUILDER_KEYS[type] = opts.builder = builder2
  NODE_FIELDS[type] = opts.fields = fields
  ALIAS_KEYS[type] = opts.aliases = aliases
  aliases.forEach((alias) => {
    FLIPPED_ALIAS_KEYS$3[alias] = FLIPPED_ALIAS_KEYS$3[alias] || []
    FLIPPED_ALIAS_KEYS$3[alias].push(type)
  })
  if (opts.validate) {
    NODE_PARENT_VALIDATIONS[type] = opts.validate
  }
  store[type] = opts
}
const store = {}
Object.defineProperty(core, '__esModule', {
  value: true,
})
core.patternLikeCommon =
  core.functionTypeAnnotationCommon =
  core.functionDeclarationCommon =
  core.functionCommon =
  core.classMethodOrPropertyCommon =
  core.classMethodOrDeclareMethodCommon =
    void 0
var _is$2 = is$2
var _isValidIdentifier$3 = isValidIdentifier$1
var _helperValidatorIdentifier$2 = lib$a
var _constants$5 = constants
var _utils$6 = utils
const defineType$4 = (0, _utils$6.defineAliasedType)('Standardized')
defineType$4('ArrayExpression', {
  fields: {
    elements: {
      validate: (0, _utils$6.chain)(
        (0, _utils$6.assertValueType)('array'),
        (0, _utils$6.assertEach)((0, _utils$6.assertNodeOrValueType)('null', 'Expression', 'SpreadElement'))
      ),
      default: !{}.BABEL_TYPES_8_BREAKING ? [] : void 0,
    },
  },
  visitor: ['elements'],
  aliases: ['Expression'],
})
defineType$4('AssignmentExpression', {
  fields: {
    operator: {
      validate: (function () {
        if (!{}.BABEL_TYPES_8_BREAKING) {
          return (0, _utils$6.assertValueType)('string')
        }
        const identifier2 = (0, _utils$6.assertOneOf)(..._constants$5.ASSIGNMENT_OPERATORS)
        const pattern = (0, _utils$6.assertOneOf)('=')
        return function (node2, key, val) {
          const validator = (0, _is$2.default)('Pattern', node2.left) ? pattern : identifier2
          validator(node2, key, val)
        }
      })(),
    },
    left: {
      validate: !{}.BABEL_TYPES_8_BREAKING
        ? (0, _utils$6.assertNodeType)('LVal')
        : (0, _utils$6.assertNodeType)(
            'Identifier',
            'MemberExpression',
            'ArrayPattern',
            'ObjectPattern',
            'TSAsExpression',
            'TSTypeAssertion',
            'TSNonNullExpression'
          ),
    },
    right: {
      validate: (0, _utils$6.assertNodeType)('Expression'),
    },
  },
  builder: ['operator', 'left', 'right'],
  visitor: ['left', 'right'],
  aliases: ['Expression'],
})
defineType$4('BinaryExpression', {
  builder: ['operator', 'left', 'right'],
  fields: {
    operator: {
      validate: (0, _utils$6.assertOneOf)(..._constants$5.BINARY_OPERATORS),
    },
    left: {
      validate: (function () {
        const expression2 = (0, _utils$6.assertNodeType)('Expression')
        const inOp = (0, _utils$6.assertNodeType)('Expression', 'PrivateName')
        const validator = function (node2, key, val) {
          const validator2 = node2.operator === 'in' ? inOp : expression2
          validator2(node2, key, val)
        }
        validator.oneOfNodeTypes = ['Expression', 'PrivateName']
        return validator
      })(),
    },
    right: {
      validate: (0, _utils$6.assertNodeType)('Expression'),
    },
  },
  visitor: ['left', 'right'],
  aliases: ['Binary', 'Expression'],
})
defineType$4('InterpreterDirective', {
  builder: ['value'],
  fields: {
    value: {
      validate: (0, _utils$6.assertValueType)('string'),
    },
  },
})
defineType$4('Directive', {
  visitor: ['value'],
  fields: {
    value: {
      validate: (0, _utils$6.assertNodeType)('DirectiveLiteral'),
    },
  },
})
defineType$4('DirectiveLiteral', {
  builder: ['value'],
  fields: {
    value: {
      validate: (0, _utils$6.assertValueType)('string'),
    },
  },
})
defineType$4('BlockStatement', {
  builder: ['body', 'directives'],
  visitor: ['directives', 'body'],
  fields: {
    directives: {
      validate: (0, _utils$6.chain)(
        (0, _utils$6.assertValueType)('array'),
        (0, _utils$6.assertEach)((0, _utils$6.assertNodeType)('Directive'))
      ),
      default: [],
    },
    body: {
      validate: (0, _utils$6.chain)(
        (0, _utils$6.assertValueType)('array'),
        (0, _utils$6.assertEach)((0, _utils$6.assertNodeType)('Statement'))
      ),
    },
  },
  aliases: ['Scopable', 'BlockParent', 'Block', 'Statement'],
})
defineType$4('BreakStatement', {
  visitor: ['label'],
  fields: {
    label: {
      validate: (0, _utils$6.assertNodeType)('Identifier'),
      optional: true,
    },
  },
  aliases: ['Statement', 'Terminatorless', 'CompletionStatement'],
})
defineType$4('CallExpression', {
  visitor: ['callee', 'arguments', 'typeParameters', 'typeArguments'],
  builder: ['callee', 'arguments'],
  aliases: ['Expression'],
  fields: Object.assign(
    {
      callee: {
        validate: (0, _utils$6.assertNodeType)('Expression', 'V8IntrinsicIdentifier'),
      },
      arguments: {
        validate: (0, _utils$6.chain)(
          (0, _utils$6.assertValueType)('array'),
          (0, _utils$6.assertEach)(
            (0, _utils$6.assertNodeType)('Expression', 'SpreadElement', 'JSXNamespacedName', 'ArgumentPlaceholder')
          )
        ),
      },
    },
    !{}.BABEL_TYPES_8_BREAKING
      ? {
          optional: {
            validate: (0, _utils$6.assertOneOf)(true, false),
            optional: true,
          },
        }
      : {},
    {
      typeArguments: {
        validate: (0, _utils$6.assertNodeType)('TypeParameterInstantiation'),
        optional: true,
      },
      typeParameters: {
        validate: (0, _utils$6.assertNodeType)('TSTypeParameterInstantiation'),
        optional: true,
      },
    }
  ),
})
defineType$4('CatchClause', {
  visitor: ['param', 'body'],
  fields: {
    param: {
      validate: (0, _utils$6.assertNodeType)('Identifier', 'ArrayPattern', 'ObjectPattern'),
      optional: true,
    },
    body: {
      validate: (0, _utils$6.assertNodeType)('BlockStatement'),
    },
  },
  aliases: ['Scopable', 'BlockParent'],
})
defineType$4('ConditionalExpression', {
  visitor: ['test', 'consequent', 'alternate'],
  fields: {
    test: {
      validate: (0, _utils$6.assertNodeType)('Expression'),
    },
    consequent: {
      validate: (0, _utils$6.assertNodeType)('Expression'),
    },
    alternate: {
      validate: (0, _utils$6.assertNodeType)('Expression'),
    },
  },
  aliases: ['Expression', 'Conditional'],
})
defineType$4('ContinueStatement', {
  visitor: ['label'],
  fields: {
    label: {
      validate: (0, _utils$6.assertNodeType)('Identifier'),
      optional: true,
    },
  },
  aliases: ['Statement', 'Terminatorless', 'CompletionStatement'],
})
defineType$4('DebuggerStatement', {
  aliases: ['Statement'],
})
defineType$4('DoWhileStatement', {
  visitor: ['test', 'body'],
  fields: {
    test: {
      validate: (0, _utils$6.assertNodeType)('Expression'),
    },
    body: {
      validate: (0, _utils$6.assertNodeType)('Statement'),
    },
  },
  aliases: ['Statement', 'BlockParent', 'Loop', 'While', 'Scopable'],
})
defineType$4('EmptyStatement', {
  aliases: ['Statement'],
})
defineType$4('ExpressionStatement', {
  visitor: ['expression'],
  fields: {
    expression: {
      validate: (0, _utils$6.assertNodeType)('Expression'),
    },
  },
  aliases: ['Statement', 'ExpressionWrapper'],
})
defineType$4('File', {
  builder: ['program', 'comments', 'tokens'],
  visitor: ['program'],
  fields: {
    program: {
      validate: (0, _utils$6.assertNodeType)('Program'),
    },
    comments: {
      validate: !{}.BABEL_TYPES_8_BREAKING
        ? Object.assign(() => {}, {
            each: {
              oneOfNodeTypes: ['CommentBlock', 'CommentLine'],
            },
          })
        : (0, _utils$6.assertEach)((0, _utils$6.assertNodeType)('CommentBlock', 'CommentLine')),
      optional: true,
    },
    tokens: {
      validate: (0, _utils$6.assertEach)(
        Object.assign(() => {}, {
          type: 'any',
        })
      ),
      optional: true,
    },
  },
})
defineType$4('ForInStatement', {
  visitor: ['left', 'right', 'body'],
  aliases: ['Scopable', 'Statement', 'For', 'BlockParent', 'Loop', 'ForXStatement'],
  fields: {
    left: {
      validate: !{}.BABEL_TYPES_8_BREAKING
        ? (0, _utils$6.assertNodeType)('VariableDeclaration', 'LVal')
        : (0, _utils$6.assertNodeType)(
            'VariableDeclaration',
            'Identifier',
            'MemberExpression',
            'ArrayPattern',
            'ObjectPattern',
            'TSAsExpression',
            'TSTypeAssertion',
            'TSNonNullExpression'
          ),
    },
    right: {
      validate: (0, _utils$6.assertNodeType)('Expression'),
    },
    body: {
      validate: (0, _utils$6.assertNodeType)('Statement'),
    },
  },
})
defineType$4('ForStatement', {
  visitor: ['init', 'test', 'update', 'body'],
  aliases: ['Scopable', 'Statement', 'For', 'BlockParent', 'Loop'],
  fields: {
    init: {
      validate: (0, _utils$6.assertNodeType)('VariableDeclaration', 'Expression'),
      optional: true,
    },
    test: {
      validate: (0, _utils$6.assertNodeType)('Expression'),
      optional: true,
    },
    update: {
      validate: (0, _utils$6.assertNodeType)('Expression'),
      optional: true,
    },
    body: {
      validate: (0, _utils$6.assertNodeType)('Statement'),
    },
  },
})
const functionCommon = {
  params: {
    validate: (0, _utils$6.chain)(
      (0, _utils$6.assertValueType)('array'),
      (0, _utils$6.assertEach)((0, _utils$6.assertNodeType)('Identifier', 'Pattern', 'RestElement'))
    ),
  },
  generator: {
    default: false,
  },
  async: {
    default: false,
  },
}
core.functionCommon = functionCommon
const functionTypeAnnotationCommon = {
  returnType: {
    validate: (0, _utils$6.assertNodeType)('TypeAnnotation', 'TSTypeAnnotation', 'Noop'),
    optional: true,
  },
  typeParameters: {
    validate: (0, _utils$6.assertNodeType)('TypeParameterDeclaration', 'TSTypeParameterDeclaration', 'Noop'),
    optional: true,
  },
}
core.functionTypeAnnotationCommon = functionTypeAnnotationCommon
const functionDeclarationCommon = Object.assign({}, functionCommon, {
  declare: {
    validate: (0, _utils$6.assertValueType)('boolean'),
    optional: true,
  },
  id: {
    validate: (0, _utils$6.assertNodeType)('Identifier'),
    optional: true,
  },
})
core.functionDeclarationCommon = functionDeclarationCommon
defineType$4('FunctionDeclaration', {
  builder: ['id', 'params', 'body', 'generator', 'async'],
  visitor: ['id', 'params', 'body', 'returnType', 'typeParameters'],
  fields: Object.assign({}, functionDeclarationCommon, functionTypeAnnotationCommon, {
    body: {
      validate: (0, _utils$6.assertNodeType)('BlockStatement'),
    },
    predicate: {
      validate: (0, _utils$6.assertNodeType)('DeclaredPredicate', 'InferredPredicate'),
      optional: true,
    },
  }),
  aliases: ['Scopable', 'Function', 'BlockParent', 'FunctionParent', 'Statement', 'Pureish', 'Declaration'],
  validate: (function () {
    if (!{}.BABEL_TYPES_8_BREAKING) return () => {}
    const identifier2 = (0, _utils$6.assertNodeType)('Identifier')
    return function (parent, key, node2) {
      if (!(0, _is$2.default)('ExportDefaultDeclaration', parent)) {
        identifier2(node2, 'id', node2.id)
      }
    }
  })(),
})
defineType$4('FunctionExpression', {
  inherits: 'FunctionDeclaration',
  aliases: ['Scopable', 'Function', 'BlockParent', 'FunctionParent', 'Expression', 'Pureish'],
  fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {
    id: {
      validate: (0, _utils$6.assertNodeType)('Identifier'),
      optional: true,
    },
    body: {
      validate: (0, _utils$6.assertNodeType)('BlockStatement'),
    },
    predicate: {
      validate: (0, _utils$6.assertNodeType)('DeclaredPredicate', 'InferredPredicate'),
      optional: true,
    },
  }),
})
const patternLikeCommon = {
  typeAnnotation: {
    validate: (0, _utils$6.assertNodeType)('TypeAnnotation', 'TSTypeAnnotation', 'Noop'),
    optional: true,
  },
  decorators: {
    validate: (0, _utils$6.chain)(
      (0, _utils$6.assertValueType)('array'),
      (0, _utils$6.assertEach)((0, _utils$6.assertNodeType)('Decorator'))
    ),
  },
}
core.patternLikeCommon = patternLikeCommon
defineType$4('Identifier', {
  builder: ['name'],
  visitor: ['typeAnnotation', 'decorators'],
  aliases: ['Expression', 'PatternLike', 'LVal', 'TSEntityName'],
  fields: Object.assign({}, patternLikeCommon, {
    name: {
      validate: (0, _utils$6.chain)(
        (0, _utils$6.assertValueType)('string'),
        Object.assign(
          function (node2, key, val) {
            if (!{}.BABEL_TYPES_8_BREAKING) return
            if (!(0, _isValidIdentifier$3.default)(val, false)) {
              throw new TypeError(`"${val}" is not a valid identifier name`)
            }
          },
          {
            type: 'string',
          }
        )
      ),
    },
    optional: {
      validate: (0, _utils$6.assertValueType)('boolean'),
      optional: true,
    },
  }),
  validate(parent, key, node2) {
    if (!{}.BABEL_TYPES_8_BREAKING) return
    const match = /\.(\w+)$/.exec(key)
    if (!match) return
    const [, parentKey] = match
    const nonComp = {
      computed: false,
    }
    if (parentKey === 'property') {
      if ((0, _is$2.default)('MemberExpression', parent, nonComp)) return
      if ((0, _is$2.default)('OptionalMemberExpression', parent, nonComp)) return
    } else if (parentKey === 'key') {
      if ((0, _is$2.default)('Property', parent, nonComp)) return
      if ((0, _is$2.default)('Method', parent, nonComp)) return
    } else if (parentKey === 'exported') {
      if ((0, _is$2.default)('ExportSpecifier', parent)) return
    } else if (parentKey === 'imported') {
      if (
        (0, _is$2.default)('ImportSpecifier', parent, {
          imported: node2,
        })
      )
        return
    } else if (parentKey === 'meta') {
      if (
        (0, _is$2.default)('MetaProperty', parent, {
          meta: node2,
        })
      )
        return
    }
    if (
      ((0, _helperValidatorIdentifier$2.isKeyword)(node2.name) ||
        (0, _helperValidatorIdentifier$2.isReservedWord)(node2.name, false)) &&
      node2.name !== 'this'
    ) {
      throw new TypeError(`"${node2.name}" is not a valid identifier`)
    }
  },
})
defineType$4('IfStatement', {
  visitor: ['test', 'consequent', 'alternate'],
  aliases: ['Statement', 'Conditional'],
  fields: {
    test: {
      validate: (0, _utils$6.assertNodeType)('Expression'),
    },
    consequent: {
      validate: (0, _utils$6.assertNodeType)('Statement'),
    },
    alternate: {
      optional: true,
      validate: (0, _utils$6.assertNodeType)('Statement'),
    },
  },
})
defineType$4('LabeledStatement', {
  visitor: ['label', 'body'],
  aliases: ['Statement'],
  fields: {
    label: {
      validate: (0, _utils$6.assertNodeType)('Identifier'),
    },
    body: {
      validate: (0, _utils$6.assertNodeType)('Statement'),
    },
  },
})
defineType$4('StringLiteral', {
  builder: ['value'],
  fields: {
    value: {
      validate: (0, _utils$6.assertValueType)('string'),
    },
  },
  aliases: ['Expression', 'Pureish', 'Literal', 'Immutable'],
})
defineType$4('NumericLiteral', {
  builder: ['value'],
  deprecatedAlias: 'NumberLiteral',
  fields: {
    value: {
      validate: (0, _utils$6.assertValueType)('number'),
    },
  },
  aliases: ['Expression', 'Pureish', 'Literal', 'Immutable'],
})
defineType$4('NullLiteral', {
  aliases: ['Expression', 'Pureish', 'Literal', 'Immutable'],
})
defineType$4('BooleanLiteral', {
  builder: ['value'],
  fields: {
    value: {
      validate: (0, _utils$6.assertValueType)('boolean'),
    },
  },
  aliases: ['Expression', 'Pureish', 'Literal', 'Immutable'],
})
defineType$4('RegExpLiteral', {
  builder: ['pattern', 'flags'],
  deprecatedAlias: 'RegexLiteral',
  aliases: ['Expression', 'Pureish', 'Literal'],
  fields: {
    pattern: {
      validate: (0, _utils$6.assertValueType)('string'),
    },
    flags: {
      validate: (0, _utils$6.chain)(
        (0, _utils$6.assertValueType)('string'),
        Object.assign(
          function (node2, key, val) {
            if (!{}.BABEL_TYPES_8_BREAKING) return
            const invalid = /[^gimsuy]/.exec(val)
            if (invalid) {
              throw new TypeError(`"${invalid[0]}" is not a valid RegExp flag`)
            }
          },
          {
            type: 'string',
          }
        )
      ),
      default: '',
    },
  },
})
defineType$4('LogicalExpression', {
  builder: ['operator', 'left', 'right'],
  visitor: ['left', 'right'],
  aliases: ['Binary', 'Expression'],
  fields: {
    operator: {
      validate: (0, _utils$6.assertOneOf)(..._constants$5.LOGICAL_OPERATORS),
    },
    left: {
      validate: (0, _utils$6.assertNodeType)('Expression'),
    },
    right: {
      validate: (0, _utils$6.assertNodeType)('Expression'),
    },
  },
})
defineType$4('MemberExpression', {
  builder: ['object', 'property', 'computed', ...(!{}.BABEL_TYPES_8_BREAKING ? ['optional'] : [])],
  visitor: ['object', 'property'],
  aliases: ['Expression', 'LVal'],
  fields: Object.assign(
    {
      object: {
        validate: (0, _utils$6.assertNodeType)('Expression'),
      },
      property: {
        validate: (function () {
          const normal = (0, _utils$6.assertNodeType)('Identifier', 'PrivateName')
          const computed2 = (0, _utils$6.assertNodeType)('Expression')
          const validator = function (node2, key, val) {
            const validator2 = node2.computed ? computed2 : normal
            validator2(node2, key, val)
          }
          validator.oneOfNodeTypes = ['Expression', 'Identifier', 'PrivateName']
          return validator
        })(),
      },
      computed: {
        default: false,
      },
    },
    !{}.BABEL_TYPES_8_BREAKING
      ? {
          optional: {
            validate: (0, _utils$6.assertOneOf)(true, false),
            optional: true,
          },
        }
      : {}
  ),
})
defineType$4('NewExpression', {
  inherits: 'CallExpression',
})
defineType$4('Program', {
  visitor: ['directives', 'body'],
  builder: ['body', 'directives', 'sourceType', 'interpreter'],
  fields: {
    sourceFile: {
      validate: (0, _utils$6.assertValueType)('string'),
    },
    sourceType: {
      validate: (0, _utils$6.assertOneOf)('script', 'module'),
      default: 'script',
    },
    interpreter: {
      validate: (0, _utils$6.assertNodeType)('InterpreterDirective'),
      default: null,
      optional: true,
    },
    directives: {
      validate: (0, _utils$6.chain)(
        (0, _utils$6.assertValueType)('array'),
        (0, _utils$6.assertEach)((0, _utils$6.assertNodeType)('Directive'))
      ),
      default: [],
    },
    body: {
      validate: (0, _utils$6.chain)(
        (0, _utils$6.assertValueType)('array'),
        (0, _utils$6.assertEach)((0, _utils$6.assertNodeType)('Statement'))
      ),
    },
  },
  aliases: ['Scopable', 'BlockParent', 'Block'],
})
defineType$4('ObjectExpression', {
  visitor: ['properties'],
  aliases: ['Expression'],
  fields: {
    properties: {
      validate: (0, _utils$6.chain)(
        (0, _utils$6.assertValueType)('array'),
        (0, _utils$6.assertEach)((0, _utils$6.assertNodeType)('ObjectMethod', 'ObjectProperty', 'SpreadElement'))
      ),
    },
  },
})
defineType$4('ObjectMethod', {
  builder: ['kind', 'key', 'params', 'body', 'computed', 'generator', 'async'],
  fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {
    kind: Object.assign(
      {
        validate: (0, _utils$6.assertOneOf)('method', 'get', 'set'),
      },
      !{}.BABEL_TYPES_8_BREAKING
        ? {
            default: 'method',
          }
        : {}
    ),
    computed: {
      default: false,
    },
    key: {
      validate: (function () {
        const normal = (0, _utils$6.assertNodeType)('Identifier', 'StringLiteral', 'NumericLiteral')
        const computed2 = (0, _utils$6.assertNodeType)('Expression')
        const validator = function (node2, key, val) {
          const validator2 = node2.computed ? computed2 : normal
          validator2(node2, key, val)
        }
        validator.oneOfNodeTypes = ['Expression', 'Identifier', 'StringLiteral', 'NumericLiteral']
        return validator
      })(),
    },
    decorators: {
      validate: (0, _utils$6.chain)(
        (0, _utils$6.assertValueType)('array'),
        (0, _utils$6.assertEach)((0, _utils$6.assertNodeType)('Decorator'))
      ),
      optional: true,
    },
    body: {
      validate: (0, _utils$6.assertNodeType)('BlockStatement'),
    },
  }),
  visitor: ['key', 'params', 'body', 'decorators', 'returnType', 'typeParameters'],
  aliases: ['UserWhitespacable', 'Function', 'Scopable', 'BlockParent', 'FunctionParent', 'Method', 'ObjectMember'],
})
defineType$4('ObjectProperty', {
  builder: ['key', 'value', 'computed', 'shorthand', ...(!{}.BABEL_TYPES_8_BREAKING ? ['decorators'] : [])],
  fields: {
    computed: {
      default: false,
    },
    key: {
      validate: (function () {
        const normal = (0, _utils$6.assertNodeType)(
          'Identifier',
          'StringLiteral',
          'NumericLiteral',
          'BigIntLiteral',
          'DecimalLiteral',
          'PrivateName'
        )
        const computed2 = (0, _utils$6.assertNodeType)('Expression')
        const validator = function (node2, key, val) {
          const validator2 = node2.computed ? computed2 : normal
          validator2(node2, key, val)
        }
        validator.oneOfNodeTypes = [
          'Expression',
          'Identifier',
          'StringLiteral',
          'NumericLiteral',
          'BigIntLiteral',
          'DecimalLiteral',
          'PrivateName',
        ]
        return validator
      })(),
    },
    value: {
      validate: (0, _utils$6.assertNodeType)('Expression', 'PatternLike'),
    },
    shorthand: {
      validate: (0, _utils$6.chain)(
        (0, _utils$6.assertValueType)('boolean'),
        Object.assign(
          function (node2, key, val) {
            if (!{}.BABEL_TYPES_8_BREAKING) return
            if (val && node2.computed) {
              throw new TypeError('Property shorthand of ObjectProperty cannot be true if computed is true')
            }
          },
          {
            type: 'boolean',
          }
        ),
        function (node2, key, val) {
          if (!{}.BABEL_TYPES_8_BREAKING) return
          if (val && !(0, _is$2.default)('Identifier', node2.key)) {
            throw new TypeError('Property shorthand of ObjectProperty cannot be true if key is not an Identifier')
          }
        }
      ),
      default: false,
    },
    decorators: {
      validate: (0, _utils$6.chain)(
        (0, _utils$6.assertValueType)('array'),
        (0, _utils$6.assertEach)((0, _utils$6.assertNodeType)('Decorator'))
      ),
      optional: true,
    },
  },
  visitor: ['key', 'value', 'decorators'],
  aliases: ['UserWhitespacable', 'Property', 'ObjectMember'],
  validate: (function () {
    const pattern = (0, _utils$6.assertNodeType)(
      'Identifier',
      'Pattern',
      'TSAsExpression',
      'TSNonNullExpression',
      'TSTypeAssertion'
    )
    const expression2 = (0, _utils$6.assertNodeType)('Expression')
    return function (parent, key, node2) {
      if (!{}.BABEL_TYPES_8_BREAKING) return
      const validator = (0, _is$2.default)('ObjectPattern', parent) ? pattern : expression2
      validator(node2, 'value', node2.value)
    }
  })(),
})
defineType$4('RestElement', {
  visitor: ['argument', 'typeAnnotation'],
  builder: ['argument'],
  aliases: ['LVal', 'PatternLike'],
  deprecatedAlias: 'RestProperty',
  fields: Object.assign({}, patternLikeCommon, {
    argument: {
      validate: !{}.BABEL_TYPES_8_BREAKING
        ? (0, _utils$6.assertNodeType)('LVal')
        : (0, _utils$6.assertNodeType)(
            'Identifier',
            'ArrayPattern',
            'ObjectPattern',
            'MemberExpression',
            'TSAsExpression',
            'TSTypeAssertion',
            'TSNonNullExpression'
          ),
    },
    optional: {
      validate: (0, _utils$6.assertValueType)('boolean'),
      optional: true,
    },
  }),
  validate(parent, key) {
    if (!{}.BABEL_TYPES_8_BREAKING) return
    const match = /(\w+)\[(\d+)\]/.exec(key)
    if (!match) throw new Error('Internal Babel error: malformed key.')
    const [, listKey, index2] = match
    if (parent[listKey].length > index2 + 1) {
      throw new TypeError(`RestElement must be last element of ${listKey}`)
    }
  },
})
defineType$4('ReturnStatement', {
  visitor: ['argument'],
  aliases: ['Statement', 'Terminatorless', 'CompletionStatement'],
  fields: {
    argument: {
      validate: (0, _utils$6.assertNodeType)('Expression'),
      optional: true,
    },
  },
})
defineType$4('SequenceExpression', {
  visitor: ['expressions'],
  fields: {
    expressions: {
      validate: (0, _utils$6.chain)(
        (0, _utils$6.assertValueType)('array'),
        (0, _utils$6.assertEach)((0, _utils$6.assertNodeType)('Expression'))
      ),
    },
  },
  aliases: ['Expression'],
})
defineType$4('ParenthesizedExpression', {
  visitor: ['expression'],
  aliases: ['Expression', 'ExpressionWrapper'],
  fields: {
    expression: {
      validate: (0, _utils$6.assertNodeType)('Expression'),
    },
  },
})
defineType$4('SwitchCase', {
  visitor: ['test', 'consequent'],
  fields: {
    test: {
      validate: (0, _utils$6.assertNodeType)('Expression'),
      optional: true,
    },
    consequent: {
      validate: (0, _utils$6.chain)(
        (0, _utils$6.assertValueType)('array'),
        (0, _utils$6.assertEach)((0, _utils$6.assertNodeType)('Statement'))
      ),
    },
  },
})
defineType$4('SwitchStatement', {
  visitor: ['discriminant', 'cases'],
  aliases: ['Statement', 'BlockParent', 'Scopable'],
  fields: {
    discriminant: {
      validate: (0, _utils$6.assertNodeType)('Expression'),
    },
    cases: {
      validate: (0, _utils$6.chain)(
        (0, _utils$6.assertValueType)('array'),
        (0, _utils$6.assertEach)((0, _utils$6.assertNodeType)('SwitchCase'))
      ),
    },
  },
})
defineType$4('ThisExpression', {
  aliases: ['Expression'],
})
defineType$4('ThrowStatement', {
  visitor: ['argument'],
  aliases: ['Statement', 'Terminatorless', 'CompletionStatement'],
  fields: {
    argument: {
      validate: (0, _utils$6.assertNodeType)('Expression'),
    },
  },
})
defineType$4('TryStatement', {
  visitor: ['block', 'handler', 'finalizer'],
  aliases: ['Statement'],
  fields: {
    block: {
      validate: (0, _utils$6.chain)(
        (0, _utils$6.assertNodeType)('BlockStatement'),
        Object.assign(
          function (node2) {
            if (!{}.BABEL_TYPES_8_BREAKING) return
            if (!node2.handler && !node2.finalizer) {
              throw new TypeError('TryStatement expects either a handler or finalizer, or both')
            }
          },
          {
            oneOfNodeTypes: ['BlockStatement'],
          }
        )
      ),
    },
    handler: {
      optional: true,
      validate: (0, _utils$6.assertNodeType)('CatchClause'),
    },
    finalizer: {
      optional: true,
      validate: (0, _utils$6.assertNodeType)('BlockStatement'),
    },
  },
})
defineType$4('UnaryExpression', {
  builder: ['operator', 'argument', 'prefix'],
  fields: {
    prefix: {
      default: true,
    },
    argument: {
      validate: (0, _utils$6.assertNodeType)('Expression'),
    },
    operator: {
      validate: (0, _utils$6.assertOneOf)(..._constants$5.UNARY_OPERATORS),
    },
  },
  visitor: ['argument'],
  aliases: ['UnaryLike', 'Expression'],
})
defineType$4('UpdateExpression', {
  builder: ['operator', 'argument', 'prefix'],
  fields: {
    prefix: {
      default: false,
    },
    argument: {
      validate: !{}.BABEL_TYPES_8_BREAKING
        ? (0, _utils$6.assertNodeType)('Expression')
        : (0, _utils$6.assertNodeType)('Identifier', 'MemberExpression'),
    },
    operator: {
      validate: (0, _utils$6.assertOneOf)(..._constants$5.UPDATE_OPERATORS),
    },
  },
  visitor: ['argument'],
  aliases: ['Expression'],
})
defineType$4('VariableDeclaration', {
  builder: ['kind', 'declarations'],
  visitor: ['declarations'],
  aliases: ['Statement', 'Declaration'],
  fields: {
    declare: {
      validate: (0, _utils$6.assertValueType)('boolean'),
      optional: true,
    },
    kind: {
      validate: (0, _utils$6.assertOneOf)('var', 'let', 'const'),
    },
    declarations: {
      validate: (0, _utils$6.chain)(
        (0, _utils$6.assertValueType)('array'),
        (0, _utils$6.assertEach)((0, _utils$6.assertNodeType)('VariableDeclarator'))
      ),
    },
  },
  validate(parent, key, node2) {
    if (!{}.BABEL_TYPES_8_BREAKING) return
    if (
      !(0, _is$2.default)('ForXStatement', parent, {
        left: node2,
      })
    )
      return
    if (node2.declarations.length !== 1) {
      throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${parent.type}`)
    }
  },
})
defineType$4('VariableDeclarator', {
  visitor: ['id', 'init'],
  fields: {
    id: {
      validate: (function () {
        if (!{}.BABEL_TYPES_8_BREAKING) {
          return (0, _utils$6.assertNodeType)('LVal')
        }
        const normal = (0, _utils$6.assertNodeType)('Identifier', 'ArrayPattern', 'ObjectPattern')
        const without = (0, _utils$6.assertNodeType)('Identifier')
        return function (node2, key, val) {
          const validator = node2.init ? normal : without
          validator(node2, key, val)
        }
      })(),
    },
    definite: {
      optional: true,
      validate: (0, _utils$6.assertValueType)('boolean'),
    },
    init: {
      optional: true,
      validate: (0, _utils$6.assertNodeType)('Expression'),
    },
  },
})
defineType$4('WhileStatement', {
  visitor: ['test', 'body'],
  aliases: ['Statement', 'BlockParent', 'Loop', 'While', 'Scopable'],
  fields: {
    test: {
      validate: (0, _utils$6.assertNodeType)('Expression'),
    },
    body: {
      validate: (0, _utils$6.assertNodeType)('Statement'),
    },
  },
})
defineType$4('WithStatement', {
  visitor: ['object', 'body'],
  aliases: ['Statement'],
  fields: {
    object: {
      validate: (0, _utils$6.assertNodeType)('Expression'),
    },
    body: {
      validate: (0, _utils$6.assertNodeType)('Statement'),
    },
  },
})
defineType$4('AssignmentPattern', {
  visitor: ['left', 'right', 'decorators'],
  builder: ['left', 'right'],
  aliases: ['Pattern', 'PatternLike', 'LVal'],
  fields: Object.assign({}, patternLikeCommon, {
    left: {
      validate: (0, _utils$6.assertNodeType)(
        'Identifier',
        'ObjectPattern',
        'ArrayPattern',
        'MemberExpression',
        'TSAsExpression',
        'TSTypeAssertion',
        'TSNonNullExpression'
      ),
    },
    right: {
      validate: (0, _utils$6.assertNodeType)('Expression'),
    },
    decorators: {
      validate: (0, _utils$6.chain)(
        (0, _utils$6.assertValueType)('array'),
        (0, _utils$6.assertEach)((0, _utils$6.assertNodeType)('Decorator'))
      ),
      optional: true,
    },
  }),
})
defineType$4('ArrayPattern', {
  visitor: ['elements', 'typeAnnotation'],
  builder: ['elements'],
  aliases: ['Pattern', 'PatternLike', 'LVal'],
  fields: Object.assign({}, patternLikeCommon, {
    elements: {
      validate: (0, _utils$6.chain)(
        (0, _utils$6.assertValueType)('array'),
        (0, _utils$6.assertEach)((0, _utils$6.assertNodeOrValueType)('null', 'PatternLike'))
      ),
    },
    decorators: {
      validate: (0, _utils$6.chain)(
        (0, _utils$6.assertValueType)('array'),
        (0, _utils$6.assertEach)((0, _utils$6.assertNodeType)('Decorator'))
      ),
      optional: true,
    },
    optional: {
      validate: (0, _utils$6.assertValueType)('boolean'),
      optional: true,
    },
  }),
})
defineType$4('ArrowFunctionExpression', {
  builder: ['params', 'body', 'async'],
  visitor: ['params', 'body', 'returnType', 'typeParameters'],
  aliases: ['Scopable', 'Function', 'BlockParent', 'FunctionParent', 'Expression', 'Pureish'],
  fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {
    expression: {
      validate: (0, _utils$6.assertValueType)('boolean'),
    },
    body: {
      validate: (0, _utils$6.assertNodeType)('BlockStatement', 'Expression'),
    },
    predicate: {
      validate: (0, _utils$6.assertNodeType)('DeclaredPredicate', 'InferredPredicate'),
      optional: true,
    },
  }),
})
defineType$4('ClassBody', {
  visitor: ['body'],
  fields: {
    body: {
      validate: (0, _utils$6.chain)(
        (0, _utils$6.assertValueType)('array'),
        (0, _utils$6.assertEach)(
          (0, _utils$6.assertNodeType)(
            'ClassMethod',
            'ClassPrivateMethod',
            'ClassProperty',
            'ClassPrivateProperty',
            'ClassAccessorProperty',
            'TSDeclareMethod',
            'TSIndexSignature',
            'StaticBlock'
          )
        )
      ),
    },
  },
})
defineType$4('ClassExpression', {
  builder: ['id', 'superClass', 'body', 'decorators'],
  visitor: ['id', 'body', 'superClass', 'mixins', 'typeParameters', 'superTypeParameters', 'implements', 'decorators'],
  aliases: ['Scopable', 'Class', 'Expression'],
  fields: {
    id: {
      validate: (0, _utils$6.assertNodeType)('Identifier'),
      optional: true,
    },
    typeParameters: {
      validate: (0, _utils$6.assertNodeType)('TypeParameterDeclaration', 'TSTypeParameterDeclaration', 'Noop'),
      optional: true,
    },
    body: {
      validate: (0, _utils$6.assertNodeType)('ClassBody'),
    },
    superClass: {
      optional: true,
      validate: (0, _utils$6.assertNodeType)('Expression'),
    },
    superTypeParameters: {
      validate: (0, _utils$6.assertNodeType)('TypeParameterInstantiation', 'TSTypeParameterInstantiation'),
      optional: true,
    },
    implements: {
      validate: (0, _utils$6.chain)(
        (0, _utils$6.assertValueType)('array'),
        (0, _utils$6.assertEach)((0, _utils$6.assertNodeType)('TSExpressionWithTypeArguments', 'ClassImplements'))
      ),
      optional: true,
    },
    decorators: {
      validate: (0, _utils$6.chain)(
        (0, _utils$6.assertValueType)('array'),
        (0, _utils$6.assertEach)((0, _utils$6.assertNodeType)('Decorator'))
      ),
      optional: true,
    },
    mixins: {
      validate: (0, _utils$6.assertNodeType)('InterfaceExtends'),
      optional: true,
    },
  },
})
defineType$4('ClassDeclaration', {
  inherits: 'ClassExpression',
  aliases: ['Scopable', 'Class', 'Statement', 'Declaration'],
  fields: {
    id: {
      validate: (0, _utils$6.assertNodeType)('Identifier'),
    },
    typeParameters: {
      validate: (0, _utils$6.assertNodeType)('TypeParameterDeclaration', 'TSTypeParameterDeclaration', 'Noop'),
      optional: true,
    },
    body: {
      validate: (0, _utils$6.assertNodeType)('ClassBody'),
    },
    superClass: {
      optional: true,
      validate: (0, _utils$6.assertNodeType)('Expression'),
    },
    superTypeParameters: {
      validate: (0, _utils$6.assertNodeType)('TypeParameterInstantiation', 'TSTypeParameterInstantiation'),
      optional: true,
    },
    implements: {
      validate: (0, _utils$6.chain)(
        (0, _utils$6.assertValueType)('array'),
        (0, _utils$6.assertEach)((0, _utils$6.assertNodeType)('TSExpressionWithTypeArguments', 'ClassImplements'))
      ),
      optional: true,
    },
    decorators: {
      validate: (0, _utils$6.chain)(
        (0, _utils$6.assertValueType)('array'),
        (0, _utils$6.assertEach)((0, _utils$6.assertNodeType)('Decorator'))
      ),
      optional: true,
    },
    mixins: {
      validate: (0, _utils$6.assertNodeType)('InterfaceExtends'),
      optional: true,
    },
    declare: {
      validate: (0, _utils$6.assertValueType)('boolean'),
      optional: true,
    },
    abstract: {
      validate: (0, _utils$6.assertValueType)('boolean'),
      optional: true,
    },
  },
  validate: (function () {
    const identifier2 = (0, _utils$6.assertNodeType)('Identifier')
    return function (parent, key, node2) {
      if (!{}.BABEL_TYPES_8_BREAKING) return
      if (!(0, _is$2.default)('ExportDefaultDeclaration', parent)) {
        identifier2(node2, 'id', node2.id)
      }
    }
  })(),
})
defineType$4('ExportAllDeclaration', {
  visitor: ['source'],
  aliases: ['Statement', 'Declaration', 'ModuleDeclaration', 'ExportDeclaration'],
  fields: {
    source: {
      validate: (0, _utils$6.assertNodeType)('StringLiteral'),
    },
    exportKind: (0, _utils$6.validateOptional)((0, _utils$6.assertOneOf)('type', 'value')),
    assertions: {
      optional: true,
      validate: (0, _utils$6.chain)(
        (0, _utils$6.assertValueType)('array'),
        (0, _utils$6.assertEach)((0, _utils$6.assertNodeType)('ImportAttribute'))
      ),
    },
  },
})
defineType$4('ExportDefaultDeclaration', {
  visitor: ['declaration'],
  aliases: ['Statement', 'Declaration', 'ModuleDeclaration', 'ExportDeclaration'],
  fields: {
    declaration: {
      validate: (0, _utils$6.assertNodeType)('FunctionDeclaration', 'ClassDeclaration', 'Expression'),
    },
    exportKind: (0, _utils$6.validateOptional)((0, _utils$6.assertOneOf)('value')),
  },
})
defineType$4('ExportNamedDeclaration', {
  visitor: ['declaration', 'specifiers', 'source'],
  aliases: ['Statement', 'Declaration', 'ModuleDeclaration', 'ExportDeclaration'],
  fields: {
    declaration: {
      optional: true,
      validate: (0, _utils$6.chain)(
        (0, _utils$6.assertNodeType)('Declaration'),
        Object.assign(
          function (node2, key, val) {
            if (!{}.BABEL_TYPES_8_BREAKING) return
            if (val && node2.specifiers.length) {
              throw new TypeError('Only declaration or specifiers is allowed on ExportNamedDeclaration')
            }
          },
          {
            oneOfNodeTypes: ['Declaration'],
          }
        ),
        function (node2, key, val) {
          if (!{}.BABEL_TYPES_8_BREAKING) return
          if (val && node2.source) {
            throw new TypeError('Cannot export a declaration from a source')
          }
        }
      ),
    },
    assertions: {
      optional: true,
      validate: (0, _utils$6.chain)(
        (0, _utils$6.assertValueType)('array'),
        (0, _utils$6.assertEach)((0, _utils$6.assertNodeType)('ImportAttribute'))
      ),
    },
    specifiers: {
      default: [],
      validate: (0, _utils$6.chain)(
        (0, _utils$6.assertValueType)('array'),
        (0, _utils$6.assertEach)(
          (function () {
            const sourced = (0, _utils$6.assertNodeType)(
              'ExportSpecifier',
              'ExportDefaultSpecifier',
              'ExportNamespaceSpecifier'
            )
            const sourceless = (0, _utils$6.assertNodeType)('ExportSpecifier')
            if (!{}.BABEL_TYPES_8_BREAKING) return sourced
            return function (node2, key, val) {
              const validator = node2.source ? sourced : sourceless
              validator(node2, key, val)
            }
          })()
        )
      ),
    },
    source: {
      validate: (0, _utils$6.assertNodeType)('StringLiteral'),
      optional: true,
    },
    exportKind: (0, _utils$6.validateOptional)((0, _utils$6.assertOneOf)('type', 'value')),
  },
})
defineType$4('ExportSpecifier', {
  visitor: ['local', 'exported'],
  aliases: ['ModuleSpecifier'],
  fields: {
    local: {
      validate: (0, _utils$6.assertNodeType)('Identifier'),
    },
    exported: {
      validate: (0, _utils$6.assertNodeType)('Identifier', 'StringLiteral'),
    },
    exportKind: {
      validate: (0, _utils$6.assertOneOf)('type', 'value'),
      optional: true,
    },
  },
})
defineType$4('ForOfStatement', {
  visitor: ['left', 'right', 'body'],
  builder: ['left', 'right', 'body', 'await'],
  aliases: ['Scopable', 'Statement', 'For', 'BlockParent', 'Loop', 'ForXStatement'],
  fields: {
    left: {
      validate: (function () {
        if (!{}.BABEL_TYPES_8_BREAKING) {
          return (0, _utils$6.assertNodeType)('VariableDeclaration', 'LVal')
        }
        const declaration = (0, _utils$6.assertNodeType)('VariableDeclaration')
        const lval = (0, _utils$6.assertNodeType)(
          'Identifier',
          'MemberExpression',
          'ArrayPattern',
          'ObjectPattern',
          'TSAsExpression',
          'TSTypeAssertion',
          'TSNonNullExpression'
        )
        return function (node2, key, val) {
          if ((0, _is$2.default)('VariableDeclaration', val)) {
            declaration(node2, key, val)
          } else {
            lval(node2, key, val)
          }
        }
      })(),
    },
    right: {
      validate: (0, _utils$6.assertNodeType)('Expression'),
    },
    body: {
      validate: (0, _utils$6.assertNodeType)('Statement'),
    },
    await: {
      default: false,
    },
  },
})
defineType$4('ImportDeclaration', {
  visitor: ['specifiers', 'source'],
  aliases: ['Statement', 'Declaration', 'ModuleDeclaration'],
  fields: {
    assertions: {
      optional: true,
      validate: (0, _utils$6.chain)(
        (0, _utils$6.assertValueType)('array'),
        (0, _utils$6.assertEach)((0, _utils$6.assertNodeType)('ImportAttribute'))
      ),
    },
    specifiers: {
      validate: (0, _utils$6.chain)(
        (0, _utils$6.assertValueType)('array'),
        (0, _utils$6.assertEach)(
          (0, _utils$6.assertNodeType)('ImportSpecifier', 'ImportDefaultSpecifier', 'ImportNamespaceSpecifier')
        )
      ),
    },
    source: {
      validate: (0, _utils$6.assertNodeType)('StringLiteral'),
    },
    importKind: {
      validate: (0, _utils$6.assertOneOf)('type', 'typeof', 'value'),
      optional: true,
    },
  },
})
defineType$4('ImportDefaultSpecifier', {
  visitor: ['local'],
  aliases: ['ModuleSpecifier'],
  fields: {
    local: {
      validate: (0, _utils$6.assertNodeType)('Identifier'),
    },
  },
})
defineType$4('ImportNamespaceSpecifier', {
  visitor: ['local'],
  aliases: ['ModuleSpecifier'],
  fields: {
    local: {
      validate: (0, _utils$6.assertNodeType)('Identifier'),
    },
  },
})
defineType$4('ImportSpecifier', {
  visitor: ['local', 'imported'],
  aliases: ['ModuleSpecifier'],
  fields: {
    local: {
      validate: (0, _utils$6.assertNodeType)('Identifier'),
    },
    imported: {
      validate: (0, _utils$6.assertNodeType)('Identifier', 'StringLiteral'),
    },
    importKind: {
      validate: (0, _utils$6.assertOneOf)('type', 'typeof', 'value'),
      optional: true,
    },
  },
})
defineType$4('MetaProperty', {
  visitor: ['meta', 'property'],
  aliases: ['Expression'],
  fields: {
    meta: {
      validate: (0, _utils$6.chain)(
        (0, _utils$6.assertNodeType)('Identifier'),
        Object.assign(
          function (node2, key, val) {
            if (!{}.BABEL_TYPES_8_BREAKING) return
            let property
            switch (val.name) {
              case 'function':
                property = 'sent'
                break
              case 'new':
                property = 'target'
                break
              case 'import':
                property = 'meta'
                break
            }
            if (
              !(0, _is$2.default)('Identifier', node2.property, {
                name: property,
              })
            ) {
              throw new TypeError('Unrecognised MetaProperty')
            }
          },
          {
            oneOfNodeTypes: ['Identifier'],
          }
        )
      ),
    },
    property: {
      validate: (0, _utils$6.assertNodeType)('Identifier'),
    },
  },
})
const classMethodOrPropertyCommon = {
  abstract: {
    validate: (0, _utils$6.assertValueType)('boolean'),
    optional: true,
  },
  accessibility: {
    validate: (0, _utils$6.assertOneOf)('public', 'private', 'protected'),
    optional: true,
  },
  static: {
    default: false,
  },
  override: {
    default: false,
  },
  computed: {
    default: false,
  },
  optional: {
    validate: (0, _utils$6.assertValueType)('boolean'),
    optional: true,
  },
  key: {
    validate: (0, _utils$6.chain)(
      (function () {
        const normal = (0, _utils$6.assertNodeType)('Identifier', 'StringLiteral', 'NumericLiteral')
        const computed2 = (0, _utils$6.assertNodeType)('Expression')
        return function (node2, key, val) {
          const validator = node2.computed ? computed2 : normal
          validator(node2, key, val)
        }
      })(),
      (0, _utils$6.assertNodeType)('Identifier', 'StringLiteral', 'NumericLiteral', 'Expression')
    ),
  },
}
core.classMethodOrPropertyCommon = classMethodOrPropertyCommon
const classMethodOrDeclareMethodCommon = Object.assign({}, functionCommon, classMethodOrPropertyCommon, {
  params: {
    validate: (0, _utils$6.chain)(
      (0, _utils$6.assertValueType)('array'),
      (0, _utils$6.assertEach)(
        (0, _utils$6.assertNodeType)('Identifier', 'Pattern', 'RestElement', 'TSParameterProperty')
      )
    ),
  },
  kind: {
    validate: (0, _utils$6.assertOneOf)('get', 'set', 'method', 'constructor'),
    default: 'method',
  },
  access: {
    validate: (0, _utils$6.chain)(
      (0, _utils$6.assertValueType)('string'),
      (0, _utils$6.assertOneOf)('public', 'private', 'protected')
    ),
    optional: true,
  },
  decorators: {
    validate: (0, _utils$6.chain)(
      (0, _utils$6.assertValueType)('array'),
      (0, _utils$6.assertEach)((0, _utils$6.assertNodeType)('Decorator'))
    ),
    optional: true,
  },
})
core.classMethodOrDeclareMethodCommon = classMethodOrDeclareMethodCommon
defineType$4('ClassMethod', {
  aliases: ['Function', 'Scopable', 'BlockParent', 'FunctionParent', 'Method'],
  builder: ['kind', 'key', 'params', 'body', 'computed', 'static', 'generator', 'async'],
  visitor: ['key', 'params', 'body', 'decorators', 'returnType', 'typeParameters'],
  fields: Object.assign({}, classMethodOrDeclareMethodCommon, functionTypeAnnotationCommon, {
    body: {
      validate: (0, _utils$6.assertNodeType)('BlockStatement'),
    },
  }),
})
defineType$4('ObjectPattern', {
  visitor: ['properties', 'typeAnnotation', 'decorators'],
  builder: ['properties'],
  aliases: ['Pattern', 'PatternLike', 'LVal'],
  fields: Object.assign({}, patternLikeCommon, {
    properties: {
      validate: (0, _utils$6.chain)(
        (0, _utils$6.assertValueType)('array'),
        (0, _utils$6.assertEach)((0, _utils$6.assertNodeType)('RestElement', 'ObjectProperty'))
      ),
    },
  }),
})
defineType$4('SpreadElement', {
  visitor: ['argument'],
  aliases: ['UnaryLike'],
  deprecatedAlias: 'SpreadProperty',
  fields: {
    argument: {
      validate: (0, _utils$6.assertNodeType)('Expression'),
    },
  },
})
defineType$4('Super', {
  aliases: ['Expression'],
})
defineType$4('TaggedTemplateExpression', {
  visitor: ['tag', 'quasi', 'typeParameters'],
  builder: ['tag', 'quasi'],
  aliases: ['Expression'],
  fields: {
    tag: {
      validate: (0, _utils$6.assertNodeType)('Expression'),
    },
    quasi: {
      validate: (0, _utils$6.assertNodeType)('TemplateLiteral'),
    },
    typeParameters: {
      validate: (0, _utils$6.assertNodeType)('TypeParameterInstantiation', 'TSTypeParameterInstantiation'),
      optional: true,
    },
  },
})
defineType$4('TemplateElement', {
  builder: ['value', 'tail'],
  fields: {
    value: {
      validate: (0, _utils$6.assertShape)({
        raw: {
          validate: (0, _utils$6.assertValueType)('string'),
        },
        cooked: {
          validate: (0, _utils$6.assertValueType)('string'),
          optional: true,
        },
      }),
    },
    tail: {
      default: false,
    },
  },
})
defineType$4('TemplateLiteral', {
  visitor: ['quasis', 'expressions'],
  aliases: ['Expression', 'Literal'],
  fields: {
    quasis: {
      validate: (0, _utils$6.chain)(
        (0, _utils$6.assertValueType)('array'),
        (0, _utils$6.assertEach)((0, _utils$6.assertNodeType)('TemplateElement'))
      ),
    },
    expressions: {
      validate: (0, _utils$6.chain)(
        (0, _utils$6.assertValueType)('array'),
        (0, _utils$6.assertEach)((0, _utils$6.assertNodeType)('Expression', 'TSType')),
        function (node2, key, val) {
          if (node2.quasis.length !== val.length + 1) {
            throw new TypeError(`Number of ${
              node2.type
            } quasis should be exactly one more than the number of expressions.
Expected ${val.length + 1} quasis but got ${node2.quasis.length}`)
          }
        }
      ),
    },
  },
})
defineType$4('YieldExpression', {
  builder: ['argument', 'delegate'],
  visitor: ['argument'],
  aliases: ['Expression', 'Terminatorless'],
  fields: {
    delegate: {
      validate: (0, _utils$6.chain)(
        (0, _utils$6.assertValueType)('boolean'),
        Object.assign(
          function (node2, key, val) {
            if (!{}.BABEL_TYPES_8_BREAKING) return
            if (val && !node2.argument) {
              throw new TypeError('Property delegate of YieldExpression cannot be true if there is no argument')
            }
          },
          {
            type: 'boolean',
          }
        )
      ),
      default: false,
    },
    argument: {
      optional: true,
      validate: (0, _utils$6.assertNodeType)('Expression'),
    },
  },
})
defineType$4('AwaitExpression', {
  builder: ['argument'],
  visitor: ['argument'],
  aliases: ['Expression', 'Terminatorless'],
  fields: {
    argument: {
      validate: (0, _utils$6.assertNodeType)('Expression'),
    },
  },
})
defineType$4('Import', {
  aliases: ['Expression'],
})
defineType$4('BigIntLiteral', {
  builder: ['value'],
  fields: {
    value: {
      validate: (0, _utils$6.assertValueType)('string'),
    },
  },
  aliases: ['Expression', 'Pureish', 'Literal', 'Immutable'],
})
defineType$4('ExportNamespaceSpecifier', {
  visitor: ['exported'],
  aliases: ['ModuleSpecifier'],
  fields: {
    exported: {
      validate: (0, _utils$6.assertNodeType)('Identifier'),
    },
  },
})
defineType$4('OptionalMemberExpression', {
  builder: ['object', 'property', 'computed', 'optional'],
  visitor: ['object', 'property'],
  aliases: ['Expression'],
  fields: {
    object: {
      validate: (0, _utils$6.assertNodeType)('Expression'),
    },
    property: {
      validate: (function () {
        const normal = (0, _utils$6.assertNodeType)('Identifier')
        const computed2 = (0, _utils$6.assertNodeType)('Expression')
        const validator = function (node2, key, val) {
          const validator2 = node2.computed ? computed2 : normal
          validator2(node2, key, val)
        }
        validator.oneOfNodeTypes = ['Expression', 'Identifier']
        return validator
      })(),
    },
    computed: {
      default: false,
    },
    optional: {
      validate: !{}.BABEL_TYPES_8_BREAKING
        ? (0, _utils$6.assertValueType)('boolean')
        : (0, _utils$6.chain)((0, _utils$6.assertValueType)('boolean'), (0, _utils$6.assertOptionalChainStart)()),
    },
  },
})
defineType$4('OptionalCallExpression', {
  visitor: ['callee', 'arguments', 'typeParameters', 'typeArguments'],
  builder: ['callee', 'arguments', 'optional'],
  aliases: ['Expression'],
  fields: {
    callee: {
      validate: (0, _utils$6.assertNodeType)('Expression'),
    },
    arguments: {
      validate: (0, _utils$6.chain)(
        (0, _utils$6.assertValueType)('array'),
        (0, _utils$6.assertEach)(
          (0, _utils$6.assertNodeType)('Expression', 'SpreadElement', 'JSXNamespacedName', 'ArgumentPlaceholder')
        )
      ),
    },
    optional: {
      validate: !{}.BABEL_TYPES_8_BREAKING
        ? (0, _utils$6.assertValueType)('boolean')
        : (0, _utils$6.chain)((0, _utils$6.assertValueType)('boolean'), (0, _utils$6.assertOptionalChainStart)()),
    },
    typeArguments: {
      validate: (0, _utils$6.assertNodeType)('TypeParameterInstantiation'),
      optional: true,
    },
    typeParameters: {
      validate: (0, _utils$6.assertNodeType)('TSTypeParameterInstantiation'),
      optional: true,
    },
  },
})
defineType$4('ClassProperty', {
  visitor: ['key', 'value', 'typeAnnotation', 'decorators'],
  builder: ['key', 'value', 'typeAnnotation', 'decorators', 'computed', 'static'],
  aliases: ['Property'],
  fields: Object.assign({}, classMethodOrPropertyCommon, {
    value: {
      validate: (0, _utils$6.assertNodeType)('Expression'),
      optional: true,
    },
    definite: {
      validate: (0, _utils$6.assertValueType)('boolean'),
      optional: true,
    },
    typeAnnotation: {
      validate: (0, _utils$6.assertNodeType)('TypeAnnotation', 'TSTypeAnnotation', 'Noop'),
      optional: true,
    },
    decorators: {
      validate: (0, _utils$6.chain)(
        (0, _utils$6.assertValueType)('array'),
        (0, _utils$6.assertEach)((0, _utils$6.assertNodeType)('Decorator'))
      ),
      optional: true,
    },
    readonly: {
      validate: (0, _utils$6.assertValueType)('boolean'),
      optional: true,
    },
    declare: {
      validate: (0, _utils$6.assertValueType)('boolean'),
      optional: true,
    },
    variance: {
      validate: (0, _utils$6.assertNodeType)('Variance'),
      optional: true,
    },
  }),
})
defineType$4('ClassAccessorProperty', {
  visitor: ['key', 'value', 'typeAnnotation', 'decorators'],
  builder: ['key', 'value', 'typeAnnotation', 'decorators', 'computed', 'static'],
  aliases: ['Property', 'Accessor'],
  fields: Object.assign({}, classMethodOrPropertyCommon, {
    key: {
      validate: (0, _utils$6.chain)(
        (function () {
          const normal = (0, _utils$6.assertNodeType)('Identifier', 'StringLiteral', 'NumericLiteral', 'PrivateName')
          const computed2 = (0, _utils$6.assertNodeType)('Expression')
          return function (node2, key, val) {
            const validator = node2.computed ? computed2 : normal
            validator(node2, key, val)
          }
        })(),
        (0, _utils$6.assertNodeType)('Identifier', 'StringLiteral', 'NumericLiteral', 'Expression', 'PrivateName')
      ),
    },
    value: {
      validate: (0, _utils$6.assertNodeType)('Expression'),
      optional: true,
    },
    definite: {
      validate: (0, _utils$6.assertValueType)('boolean'),
      optional: true,
    },
    typeAnnotation: {
      validate: (0, _utils$6.assertNodeType)('TypeAnnotation', 'TSTypeAnnotation', 'Noop'),
      optional: true,
    },
    decorators: {
      validate: (0, _utils$6.chain)(
        (0, _utils$6.assertValueType)('array'),
        (0, _utils$6.assertEach)((0, _utils$6.assertNodeType)('Decorator'))
      ),
      optional: true,
    },
    readonly: {
      validate: (0, _utils$6.assertValueType)('boolean'),
      optional: true,
    },
    declare: {
      validate: (0, _utils$6.assertValueType)('boolean'),
      optional: true,
    },
    variance: {
      validate: (0, _utils$6.assertNodeType)('Variance'),
      optional: true,
    },
  }),
})
defineType$4('ClassPrivateProperty', {
  visitor: ['key', 'value', 'decorators', 'typeAnnotation'],
  builder: ['key', 'value', 'decorators', 'static'],
  aliases: ['Property', 'Private'],
  fields: {
    key: {
      validate: (0, _utils$6.assertNodeType)('PrivateName'),
    },
    value: {
      validate: (0, _utils$6.assertNodeType)('Expression'),
      optional: true,
    },
    typeAnnotation: {
      validate: (0, _utils$6.assertNodeType)('TypeAnnotation', 'TSTypeAnnotation', 'Noop'),
      optional: true,
    },
    decorators: {
      validate: (0, _utils$6.chain)(
        (0, _utils$6.assertValueType)('array'),
        (0, _utils$6.assertEach)((0, _utils$6.assertNodeType)('Decorator'))
      ),
      optional: true,
    },
    readonly: {
      validate: (0, _utils$6.assertValueType)('boolean'),
      optional: true,
    },
    definite: {
      validate: (0, _utils$6.assertValueType)('boolean'),
      optional: true,
    },
    variance: {
      validate: (0, _utils$6.assertNodeType)('Variance'),
      optional: true,
    },
  },
})
defineType$4('ClassPrivateMethod', {
  builder: ['kind', 'key', 'params', 'body', 'static'],
  visitor: ['key', 'params', 'body', 'decorators', 'returnType', 'typeParameters'],
  aliases: ['Function', 'Scopable', 'BlockParent', 'FunctionParent', 'Method', 'Private'],
  fields: Object.assign({}, classMethodOrDeclareMethodCommon, functionTypeAnnotationCommon, {
    key: {
      validate: (0, _utils$6.assertNodeType)('PrivateName'),
    },
    body: {
      validate: (0, _utils$6.assertNodeType)('BlockStatement'),
    },
  }),
})
defineType$4('PrivateName', {
  visitor: ['id'],
  aliases: ['Private'],
  fields: {
    id: {
      validate: (0, _utils$6.assertNodeType)('Identifier'),
    },
  },
})
defineType$4('StaticBlock', {
  visitor: ['body'],
  fields: {
    body: {
      validate: (0, _utils$6.chain)(
        (0, _utils$6.assertValueType)('array'),
        (0, _utils$6.assertEach)((0, _utils$6.assertNodeType)('Statement'))
      ),
    },
  },
  aliases: ['Scopable', 'BlockParent', 'FunctionParent'],
})
var _utils$5 = utils
const defineType$3 = (0, _utils$5.defineAliasedType)('Flow')
const defineInterfaceishType = (name, typeParameterType = 'TypeParameterDeclaration') => {
  defineType$3(name, {
    builder: ['id', 'typeParameters', 'extends', 'body'],
    visitor: ['id', 'typeParameters', 'extends', 'mixins', 'implements', 'body'],
    aliases: ['FlowDeclaration', 'Statement', 'Declaration'],
    fields: {
      id: (0, _utils$5.validateType)('Identifier'),
      typeParameters: (0, _utils$5.validateOptionalType)(typeParameterType),
      extends: (0, _utils$5.validateOptional)((0, _utils$5.arrayOfType)('InterfaceExtends')),
      mixins: (0, _utils$5.validateOptional)((0, _utils$5.arrayOfType)('InterfaceExtends')),
      implements: (0, _utils$5.validateOptional)((0, _utils$5.arrayOfType)('ClassImplements')),
      body: (0, _utils$5.validateType)('ObjectTypeAnnotation'),
    },
  })
}
defineType$3('AnyTypeAnnotation', {
  aliases: ['FlowType', 'FlowBaseAnnotation'],
})
defineType$3('ArrayTypeAnnotation', {
  visitor: ['elementType'],
  aliases: ['FlowType'],
  fields: {
    elementType: (0, _utils$5.validateType)('FlowType'),
  },
})
defineType$3('BooleanTypeAnnotation', {
  aliases: ['FlowType', 'FlowBaseAnnotation'],
})
defineType$3('BooleanLiteralTypeAnnotation', {
  builder: ['value'],
  aliases: ['FlowType'],
  fields: {
    value: (0, _utils$5.validate)((0, _utils$5.assertValueType)('boolean')),
  },
})
defineType$3('NullLiteralTypeAnnotation', {
  aliases: ['FlowType', 'FlowBaseAnnotation'],
})
defineType$3('ClassImplements', {
  visitor: ['id', 'typeParameters'],
  fields: {
    id: (0, _utils$5.validateType)('Identifier'),
    typeParameters: (0, _utils$5.validateOptionalType)('TypeParameterInstantiation'),
  },
})
defineInterfaceishType('DeclareClass')
defineType$3('DeclareFunction', {
  visitor: ['id'],
  aliases: ['FlowDeclaration', 'Statement', 'Declaration'],
  fields: {
    id: (0, _utils$5.validateType)('Identifier'),
    predicate: (0, _utils$5.validateOptionalType)('DeclaredPredicate'),
  },
})
defineInterfaceishType('DeclareInterface')
defineType$3('DeclareModule', {
  builder: ['id', 'body', 'kind'],
  visitor: ['id', 'body'],
  aliases: ['FlowDeclaration', 'Statement', 'Declaration'],
  fields: {
    id: (0, _utils$5.validateType)(['Identifier', 'StringLiteral']),
    body: (0, _utils$5.validateType)('BlockStatement'),
    kind: (0, _utils$5.validateOptional)((0, _utils$5.assertOneOf)('CommonJS', 'ES')),
  },
})
defineType$3('DeclareModuleExports', {
  visitor: ['typeAnnotation'],
  aliases: ['FlowDeclaration', 'Statement', 'Declaration'],
  fields: {
    typeAnnotation: (0, _utils$5.validateType)('TypeAnnotation'),
  },
})
defineType$3('DeclareTypeAlias', {
  visitor: ['id', 'typeParameters', 'right'],
  aliases: ['FlowDeclaration', 'Statement', 'Declaration'],
  fields: {
    id: (0, _utils$5.validateType)('Identifier'),
    typeParameters: (0, _utils$5.validateOptionalType)('TypeParameterDeclaration'),
    right: (0, _utils$5.validateType)('FlowType'),
  },
})
defineType$3('DeclareOpaqueType', {
  visitor: ['id', 'typeParameters', 'supertype'],
  aliases: ['FlowDeclaration', 'Statement', 'Declaration'],
  fields: {
    id: (0, _utils$5.validateType)('Identifier'),
    typeParameters: (0, _utils$5.validateOptionalType)('TypeParameterDeclaration'),
    supertype: (0, _utils$5.validateOptionalType)('FlowType'),
    impltype: (0, _utils$5.validateOptionalType)('FlowType'),
  },
})
defineType$3('DeclareVariable', {
  visitor: ['id'],
  aliases: ['FlowDeclaration', 'Statement', 'Declaration'],
  fields: {
    id: (0, _utils$5.validateType)('Identifier'),
  },
})
defineType$3('DeclareExportDeclaration', {
  visitor: ['declaration', 'specifiers', 'source'],
  aliases: ['FlowDeclaration', 'Statement', 'Declaration'],
  fields: {
    declaration: (0, _utils$5.validateOptionalType)('Flow'),
    specifiers: (0, _utils$5.validateOptional)(
      (0, _utils$5.arrayOfType)(['ExportSpecifier', 'ExportNamespaceSpecifier'])
    ),
    source: (0, _utils$5.validateOptionalType)('StringLiteral'),
    default: (0, _utils$5.validateOptional)((0, _utils$5.assertValueType)('boolean')),
  },
})
defineType$3('DeclareExportAllDeclaration', {
  visitor: ['source'],
  aliases: ['FlowDeclaration', 'Statement', 'Declaration'],
  fields: {
    source: (0, _utils$5.validateType)('StringLiteral'),
    exportKind: (0, _utils$5.validateOptional)((0, _utils$5.assertOneOf)('type', 'value')),
  },
})
defineType$3('DeclaredPredicate', {
  visitor: ['value'],
  aliases: ['FlowPredicate'],
  fields: {
    value: (0, _utils$5.validateType)('Flow'),
  },
})
defineType$3('ExistsTypeAnnotation', {
  aliases: ['FlowType'],
})
defineType$3('FunctionTypeAnnotation', {
  visitor: ['typeParameters', 'params', 'rest', 'returnType'],
  aliases: ['FlowType'],
  fields: {
    typeParameters: (0, _utils$5.validateOptionalType)('TypeParameterDeclaration'),
    params: (0, _utils$5.validate)((0, _utils$5.arrayOfType)('FunctionTypeParam')),
    rest: (0, _utils$5.validateOptionalType)('FunctionTypeParam'),
    this: (0, _utils$5.validateOptionalType)('FunctionTypeParam'),
    returnType: (0, _utils$5.validateType)('FlowType'),
  },
})
defineType$3('FunctionTypeParam', {
  visitor: ['name', 'typeAnnotation'],
  fields: {
    name: (0, _utils$5.validateOptionalType)('Identifier'),
    typeAnnotation: (0, _utils$5.validateType)('FlowType'),
    optional: (0, _utils$5.validateOptional)((0, _utils$5.assertValueType)('boolean')),
  },
})
defineType$3('GenericTypeAnnotation', {
  visitor: ['id', 'typeParameters'],
  aliases: ['FlowType'],
  fields: {
    id: (0, _utils$5.validateType)(['Identifier', 'QualifiedTypeIdentifier']),
    typeParameters: (0, _utils$5.validateOptionalType)('TypeParameterInstantiation'),
  },
})
defineType$3('InferredPredicate', {
  aliases: ['FlowPredicate'],
})
defineType$3('InterfaceExtends', {
  visitor: ['id', 'typeParameters'],
  fields: {
    id: (0, _utils$5.validateType)(['Identifier', 'QualifiedTypeIdentifier']),
    typeParameters: (0, _utils$5.validateOptionalType)('TypeParameterInstantiation'),
  },
})
defineInterfaceishType('InterfaceDeclaration')
defineType$3('InterfaceTypeAnnotation', {
  visitor: ['extends', 'body'],
  aliases: ['FlowType'],
  fields: {
    extends: (0, _utils$5.validateOptional)((0, _utils$5.arrayOfType)('InterfaceExtends')),
    body: (0, _utils$5.validateType)('ObjectTypeAnnotation'),
  },
})
defineType$3('IntersectionTypeAnnotation', {
  visitor: ['types'],
  aliases: ['FlowType'],
  fields: {
    types: (0, _utils$5.validate)((0, _utils$5.arrayOfType)('FlowType')),
  },
})
defineType$3('MixedTypeAnnotation', {
  aliases: ['FlowType', 'FlowBaseAnnotation'],
})
defineType$3('EmptyTypeAnnotation', {
  aliases: ['FlowType', 'FlowBaseAnnotation'],
})
defineType$3('NullableTypeAnnotation', {
  visitor: ['typeAnnotation'],
  aliases: ['FlowType'],
  fields: {
    typeAnnotation: (0, _utils$5.validateType)('FlowType'),
  },
})
defineType$3('NumberLiteralTypeAnnotation', {
  builder: ['value'],
  aliases: ['FlowType'],
  fields: {
    value: (0, _utils$5.validate)((0, _utils$5.assertValueType)('number')),
  },
})
defineType$3('NumberTypeAnnotation', {
  aliases: ['FlowType', 'FlowBaseAnnotation'],
})
defineType$3('ObjectTypeAnnotation', {
  visitor: ['properties', 'indexers', 'callProperties', 'internalSlots'],
  aliases: ['FlowType'],
  builder: ['properties', 'indexers', 'callProperties', 'internalSlots', 'exact'],
  fields: {
    properties: (0, _utils$5.validate)((0, _utils$5.arrayOfType)(['ObjectTypeProperty', 'ObjectTypeSpreadProperty'])),
    indexers: {
      validate: (0, _utils$5.arrayOfType)('ObjectTypeIndexer'),
      optional: true,
      default: [],
    },
    callProperties: {
      validate: (0, _utils$5.arrayOfType)('ObjectTypeCallProperty'),
      optional: true,
      default: [],
    },
    internalSlots: {
      validate: (0, _utils$5.arrayOfType)('ObjectTypeInternalSlot'),
      optional: true,
      default: [],
    },
    exact: {
      validate: (0, _utils$5.assertValueType)('boolean'),
      default: false,
    },
    inexact: (0, _utils$5.validateOptional)((0, _utils$5.assertValueType)('boolean')),
  },
})
defineType$3('ObjectTypeInternalSlot', {
  visitor: ['id', 'value', 'optional', 'static', 'method'],
  aliases: ['UserWhitespacable'],
  fields: {
    id: (0, _utils$5.validateType)('Identifier'),
    value: (0, _utils$5.validateType)('FlowType'),
    optional: (0, _utils$5.validate)((0, _utils$5.assertValueType)('boolean')),
    static: (0, _utils$5.validate)((0, _utils$5.assertValueType)('boolean')),
    method: (0, _utils$5.validate)((0, _utils$5.assertValueType)('boolean')),
  },
})
defineType$3('ObjectTypeCallProperty', {
  visitor: ['value'],
  aliases: ['UserWhitespacable'],
  fields: {
    value: (0, _utils$5.validateType)('FlowType'),
    static: (0, _utils$5.validate)((0, _utils$5.assertValueType)('boolean')),
  },
})
defineType$3('ObjectTypeIndexer', {
  visitor: ['id', 'key', 'value', 'variance'],
  aliases: ['UserWhitespacable'],
  fields: {
    id: (0, _utils$5.validateOptionalType)('Identifier'),
    key: (0, _utils$5.validateType)('FlowType'),
    value: (0, _utils$5.validateType)('FlowType'),
    static: (0, _utils$5.validate)((0, _utils$5.assertValueType)('boolean')),
    variance: (0, _utils$5.validateOptionalType)('Variance'),
  },
})
defineType$3('ObjectTypeProperty', {
  visitor: ['key', 'value', 'variance'],
  aliases: ['UserWhitespacable'],
  fields: {
    key: (0, _utils$5.validateType)(['Identifier', 'StringLiteral']),
    value: (0, _utils$5.validateType)('FlowType'),
    kind: (0, _utils$5.validate)((0, _utils$5.assertOneOf)('init', 'get', 'set')),
    static: (0, _utils$5.validate)((0, _utils$5.assertValueType)('boolean')),
    proto: (0, _utils$5.validate)((0, _utils$5.assertValueType)('boolean')),
    optional: (0, _utils$5.validate)((0, _utils$5.assertValueType)('boolean')),
    variance: (0, _utils$5.validateOptionalType)('Variance'),
    method: (0, _utils$5.validate)((0, _utils$5.assertValueType)('boolean')),
  },
})
defineType$3('ObjectTypeSpreadProperty', {
  visitor: ['argument'],
  aliases: ['UserWhitespacable'],
  fields: {
    argument: (0, _utils$5.validateType)('FlowType'),
  },
})
defineType$3('OpaqueType', {
  visitor: ['id', 'typeParameters', 'supertype', 'impltype'],
  aliases: ['FlowDeclaration', 'Statement', 'Declaration'],
  fields: {
    id: (0, _utils$5.validateType)('Identifier'),
    typeParameters: (0, _utils$5.validateOptionalType)('TypeParameterDeclaration'),
    supertype: (0, _utils$5.validateOptionalType)('FlowType'),
    impltype: (0, _utils$5.validateType)('FlowType'),
  },
})
defineType$3('QualifiedTypeIdentifier', {
  visitor: ['id', 'qualification'],
  fields: {
    id: (0, _utils$5.validateType)('Identifier'),
    qualification: (0, _utils$5.validateType)(['Identifier', 'QualifiedTypeIdentifier']),
  },
})
defineType$3('StringLiteralTypeAnnotation', {
  builder: ['value'],
  aliases: ['FlowType'],
  fields: {
    value: (0, _utils$5.validate)((0, _utils$5.assertValueType)('string')),
  },
})
defineType$3('StringTypeAnnotation', {
  aliases: ['FlowType', 'FlowBaseAnnotation'],
})
defineType$3('SymbolTypeAnnotation', {
  aliases: ['FlowType', 'FlowBaseAnnotation'],
})
defineType$3('ThisTypeAnnotation', {
  aliases: ['FlowType', 'FlowBaseAnnotation'],
})
defineType$3('TupleTypeAnnotation', {
  visitor: ['types'],
  aliases: ['FlowType'],
  fields: {
    types: (0, _utils$5.validate)((0, _utils$5.arrayOfType)('FlowType')),
  },
})
defineType$3('TypeofTypeAnnotation', {
  visitor: ['argument'],
  aliases: ['FlowType'],
  fields: {
    argument: (0, _utils$5.validateType)('FlowType'),
  },
})
defineType$3('TypeAlias', {
  visitor: ['id', 'typeParameters', 'right'],
  aliases: ['FlowDeclaration', 'Statement', 'Declaration'],
  fields: {
    id: (0, _utils$5.validateType)('Identifier'),
    typeParameters: (0, _utils$5.validateOptionalType)('TypeParameterDeclaration'),
    right: (0, _utils$5.validateType)('FlowType'),
  },
})
defineType$3('TypeAnnotation', {
  visitor: ['typeAnnotation'],
  fields: {
    typeAnnotation: (0, _utils$5.validateType)('FlowType'),
  },
})
defineType$3('TypeCastExpression', {
  visitor: ['expression', 'typeAnnotation'],
  aliases: ['ExpressionWrapper', 'Expression'],
  fields: {
    expression: (0, _utils$5.validateType)('Expression'),
    typeAnnotation: (0, _utils$5.validateType)('TypeAnnotation'),
  },
})
defineType$3('TypeParameter', {
  visitor: ['bound', 'default', 'variance'],
  fields: {
    name: (0, _utils$5.validate)((0, _utils$5.assertValueType)('string')),
    bound: (0, _utils$5.validateOptionalType)('TypeAnnotation'),
    default: (0, _utils$5.validateOptionalType)('FlowType'),
    variance: (0, _utils$5.validateOptionalType)('Variance'),
  },
})
defineType$3('TypeParameterDeclaration', {
  visitor: ['params'],
  fields: {
    params: (0, _utils$5.validate)((0, _utils$5.arrayOfType)('TypeParameter')),
  },
})
defineType$3('TypeParameterInstantiation', {
  visitor: ['params'],
  fields: {
    params: (0, _utils$5.validate)((0, _utils$5.arrayOfType)('FlowType')),
  },
})
defineType$3('UnionTypeAnnotation', {
  visitor: ['types'],
  aliases: ['FlowType'],
  fields: {
    types: (0, _utils$5.validate)((0, _utils$5.arrayOfType)('FlowType')),
  },
})
defineType$3('Variance', {
  builder: ['kind'],
  fields: {
    kind: (0, _utils$5.validate)((0, _utils$5.assertOneOf)('minus', 'plus')),
  },
})
defineType$3('VoidTypeAnnotation', {
  aliases: ['FlowType', 'FlowBaseAnnotation'],
})
defineType$3('EnumDeclaration', {
  aliases: ['Statement', 'Declaration'],
  visitor: ['id', 'body'],
  fields: {
    id: (0, _utils$5.validateType)('Identifier'),
    body: (0, _utils$5.validateType)(['EnumBooleanBody', 'EnumNumberBody', 'EnumStringBody', 'EnumSymbolBody']),
  },
})
defineType$3('EnumBooleanBody', {
  aliases: ['EnumBody'],
  visitor: ['members'],
  fields: {
    explicitType: (0, _utils$5.validate)((0, _utils$5.assertValueType)('boolean')),
    members: (0, _utils$5.validateArrayOfType)('EnumBooleanMember'),
    hasUnknownMembers: (0, _utils$5.validate)((0, _utils$5.assertValueType)('boolean')),
  },
})
defineType$3('EnumNumberBody', {
  aliases: ['EnumBody'],
  visitor: ['members'],
  fields: {
    explicitType: (0, _utils$5.validate)((0, _utils$5.assertValueType)('boolean')),
    members: (0, _utils$5.validateArrayOfType)('EnumNumberMember'),
    hasUnknownMembers: (0, _utils$5.validate)((0, _utils$5.assertValueType)('boolean')),
  },
})
defineType$3('EnumStringBody', {
  aliases: ['EnumBody'],
  visitor: ['members'],
  fields: {
    explicitType: (0, _utils$5.validate)((0, _utils$5.assertValueType)('boolean')),
    members: (0, _utils$5.validateArrayOfType)(['EnumStringMember', 'EnumDefaultedMember']),
    hasUnknownMembers: (0, _utils$5.validate)((0, _utils$5.assertValueType)('boolean')),
  },
})
defineType$3('EnumSymbolBody', {
  aliases: ['EnumBody'],
  visitor: ['members'],
  fields: {
    members: (0, _utils$5.validateArrayOfType)('EnumDefaultedMember'),
    hasUnknownMembers: (0, _utils$5.validate)((0, _utils$5.assertValueType)('boolean')),
  },
})
defineType$3('EnumBooleanMember', {
  aliases: ['EnumMember'],
  visitor: ['id'],
  fields: {
    id: (0, _utils$5.validateType)('Identifier'),
    init: (0, _utils$5.validateType)('BooleanLiteral'),
  },
})
defineType$3('EnumNumberMember', {
  aliases: ['EnumMember'],
  visitor: ['id', 'init'],
  fields: {
    id: (0, _utils$5.validateType)('Identifier'),
    init: (0, _utils$5.validateType)('NumericLiteral'),
  },
})
defineType$3('EnumStringMember', {
  aliases: ['EnumMember'],
  visitor: ['id', 'init'],
  fields: {
    id: (0, _utils$5.validateType)('Identifier'),
    init: (0, _utils$5.validateType)('StringLiteral'),
  },
})
defineType$3('EnumDefaultedMember', {
  aliases: ['EnumMember'],
  visitor: ['id'],
  fields: {
    id: (0, _utils$5.validateType)('Identifier'),
  },
})
defineType$3('IndexedAccessType', {
  visitor: ['objectType', 'indexType'],
  aliases: ['FlowType'],
  fields: {
    objectType: (0, _utils$5.validateType)('FlowType'),
    indexType: (0, _utils$5.validateType)('FlowType'),
  },
})
defineType$3('OptionalIndexedAccessType', {
  visitor: ['objectType', 'indexType'],
  aliases: ['FlowType'],
  fields: {
    objectType: (0, _utils$5.validateType)('FlowType'),
    indexType: (0, _utils$5.validateType)('FlowType'),
    optional: (0, _utils$5.validate)((0, _utils$5.assertValueType)('boolean')),
  },
})
var _utils$4 = utils
const defineType$2 = (0, _utils$4.defineAliasedType)('JSX')
defineType$2('JSXAttribute', {
  visitor: ['name', 'value'],
  aliases: ['Immutable'],
  fields: {
    name: {
      validate: (0, _utils$4.assertNodeType)('JSXIdentifier', 'JSXNamespacedName'),
    },
    value: {
      optional: true,
      validate: (0, _utils$4.assertNodeType)('JSXElement', 'JSXFragment', 'StringLiteral', 'JSXExpressionContainer'),
    },
  },
})
defineType$2('JSXClosingElement', {
  visitor: ['name'],
  aliases: ['Immutable'],
  fields: {
    name: {
      validate: (0, _utils$4.assertNodeType)('JSXIdentifier', 'JSXMemberExpression', 'JSXNamespacedName'),
    },
  },
})
defineType$2('JSXElement', {
  builder: ['openingElement', 'closingElement', 'children', 'selfClosing'],
  visitor: ['openingElement', 'children', 'closingElement'],
  aliases: ['Immutable', 'Expression'],
  fields: Object.assign(
    {
      openingElement: {
        validate: (0, _utils$4.assertNodeType)('JSXOpeningElement'),
      },
      closingElement: {
        optional: true,
        validate: (0, _utils$4.assertNodeType)('JSXClosingElement'),
      },
      children: {
        validate: (0, _utils$4.chain)(
          (0, _utils$4.assertValueType)('array'),
          (0, _utils$4.assertEach)(
            (0, _utils$4.assertNodeType)(
              'JSXText',
              'JSXExpressionContainer',
              'JSXSpreadChild',
              'JSXElement',
              'JSXFragment'
            )
          )
        ),
      },
    },
    {
      selfClosing: {
        validate: (0, _utils$4.assertValueType)('boolean'),
        optional: true,
      },
    }
  ),
})
defineType$2('JSXEmptyExpression', {})
defineType$2('JSXExpressionContainer', {
  visitor: ['expression'],
  aliases: ['Immutable'],
  fields: {
    expression: {
      validate: (0, _utils$4.assertNodeType)('Expression', 'JSXEmptyExpression'),
    },
  },
})
defineType$2('JSXSpreadChild', {
  visitor: ['expression'],
  aliases: ['Immutable'],
  fields: {
    expression: {
      validate: (0, _utils$4.assertNodeType)('Expression'),
    },
  },
})
defineType$2('JSXIdentifier', {
  builder: ['name'],
  fields: {
    name: {
      validate: (0, _utils$4.assertValueType)('string'),
    },
  },
})
defineType$2('JSXMemberExpression', {
  visitor: ['object', 'property'],
  fields: {
    object: {
      validate: (0, _utils$4.assertNodeType)('JSXMemberExpression', 'JSXIdentifier'),
    },
    property: {
      validate: (0, _utils$4.assertNodeType)('JSXIdentifier'),
    },
  },
})
defineType$2('JSXNamespacedName', {
  visitor: ['namespace', 'name'],
  fields: {
    namespace: {
      validate: (0, _utils$4.assertNodeType)('JSXIdentifier'),
    },
    name: {
      validate: (0, _utils$4.assertNodeType)('JSXIdentifier'),
    },
  },
})
defineType$2('JSXOpeningElement', {
  builder: ['name', 'attributes', 'selfClosing'],
  visitor: ['name', 'attributes'],
  aliases: ['Immutable'],
  fields: {
    name: {
      validate: (0, _utils$4.assertNodeType)('JSXIdentifier', 'JSXMemberExpression', 'JSXNamespacedName'),
    },
    selfClosing: {
      default: false,
    },
    attributes: {
      validate: (0, _utils$4.chain)(
        (0, _utils$4.assertValueType)('array'),
        (0, _utils$4.assertEach)((0, _utils$4.assertNodeType)('JSXAttribute', 'JSXSpreadAttribute'))
      ),
    },
    typeParameters: {
      validate: (0, _utils$4.assertNodeType)('TypeParameterInstantiation', 'TSTypeParameterInstantiation'),
      optional: true,
    },
  },
})
defineType$2('JSXSpreadAttribute', {
  visitor: ['argument'],
  fields: {
    argument: {
      validate: (0, _utils$4.assertNodeType)('Expression'),
    },
  },
})
defineType$2('JSXText', {
  aliases: ['Immutable'],
  builder: ['value'],
  fields: {
    value: {
      validate: (0, _utils$4.assertValueType)('string'),
    },
  },
})
defineType$2('JSXFragment', {
  builder: ['openingFragment', 'closingFragment', 'children'],
  visitor: ['openingFragment', 'children', 'closingFragment'],
  aliases: ['Immutable', 'Expression'],
  fields: {
    openingFragment: {
      validate: (0, _utils$4.assertNodeType)('JSXOpeningFragment'),
    },
    closingFragment: {
      validate: (0, _utils$4.assertNodeType)('JSXClosingFragment'),
    },
    children: {
      validate: (0, _utils$4.chain)(
        (0, _utils$4.assertValueType)('array'),
        (0, _utils$4.assertEach)(
          (0, _utils$4.assertNodeType)(
            'JSXText',
            'JSXExpressionContainer',
            'JSXSpreadChild',
            'JSXElement',
            'JSXFragment'
          )
        )
      ),
    },
  },
})
defineType$2('JSXOpeningFragment', {
  aliases: ['Immutable'],
})
defineType$2('JSXClosingFragment', {
  aliases: ['Immutable'],
})
var placeholders$2 = {}
Object.defineProperty(placeholders$2, '__esModule', {
  value: true,
})
placeholders$2.PLACEHOLDERS_FLIPPED_ALIAS = placeholders$2.PLACEHOLDERS_ALIAS = placeholders$2.PLACEHOLDERS = void 0
var _utils$3 = utils
const PLACEHOLDERS = [
  'Identifier',
  'StringLiteral',
  'Expression',
  'Statement',
  'Declaration',
  'BlockStatement',
  'ClassBody',
  'Pattern',
]
placeholders$2.PLACEHOLDERS = PLACEHOLDERS
const PLACEHOLDERS_ALIAS = {
  Declaration: ['Statement'],
  Pattern: ['PatternLike', 'LVal'],
}
placeholders$2.PLACEHOLDERS_ALIAS = PLACEHOLDERS_ALIAS
for (const type of PLACEHOLDERS) {
  const alias = _utils$3.ALIAS_KEYS[type]
  if (alias != null && alias.length) PLACEHOLDERS_ALIAS[type] = alias
}
const PLACEHOLDERS_FLIPPED_ALIAS = {}
placeholders$2.PLACEHOLDERS_FLIPPED_ALIAS = PLACEHOLDERS_FLIPPED_ALIAS
Object.keys(PLACEHOLDERS_ALIAS).forEach((type) => {
  PLACEHOLDERS_ALIAS[type].forEach((alias) => {
    if (!Object.hasOwnProperty.call(PLACEHOLDERS_FLIPPED_ALIAS, alias)) {
      PLACEHOLDERS_FLIPPED_ALIAS[alias] = []
    }
    PLACEHOLDERS_FLIPPED_ALIAS[alias].push(type)
  })
})
var _utils$2 = utils
var _placeholders = placeholders$2
const defineType$1 = (0, _utils$2.defineAliasedType)('Miscellaneous')
{
  defineType$1('Noop', {
    visitor: [],
  })
}
defineType$1('Placeholder', {
  visitor: [],
  builder: ['expectedNode', 'name'],
  fields: {
    name: {
      validate: (0, _utils$2.assertNodeType)('Identifier'),
    },
    expectedNode: {
      validate: (0, _utils$2.assertOneOf)(..._placeholders.PLACEHOLDERS),
    },
  },
})
defineType$1('V8IntrinsicIdentifier', {
  builder: ['name'],
  fields: {
    name: {
      validate: (0, _utils$2.assertValueType)('string'),
    },
  },
})
var _utils$1 = utils
;(0, _utils$1.default)('ArgumentPlaceholder', {})
;(0, _utils$1.default)('BindExpression', {
  visitor: ['object', 'callee'],
  aliases: ['Expression'],
  fields: !{}.BABEL_TYPES_8_BREAKING
    ? {
        object: {
          validate: Object.assign(() => {}, {
            oneOfNodeTypes: ['Expression'],
          }),
        },
        callee: {
          validate: Object.assign(() => {}, {
            oneOfNodeTypes: ['Expression'],
          }),
        },
      }
    : {
        object: {
          validate: (0, _utils$1.assertNodeType)('Expression'),
        },
        callee: {
          validate: (0, _utils$1.assertNodeType)('Expression'),
        },
      },
})
;(0, _utils$1.default)('ImportAttribute', {
  visitor: ['key', 'value'],
  fields: {
    key: {
      validate: (0, _utils$1.assertNodeType)('Identifier', 'StringLiteral'),
    },
    value: {
      validate: (0, _utils$1.assertNodeType)('StringLiteral'),
    },
  },
})
;(0, _utils$1.default)('Decorator', {
  visitor: ['expression'],
  fields: {
    expression: {
      validate: (0, _utils$1.assertNodeType)('Expression'),
    },
  },
})
;(0, _utils$1.default)('DoExpression', {
  visitor: ['body'],
  builder: ['body', 'async'],
  aliases: ['Expression'],
  fields: {
    body: {
      validate: (0, _utils$1.assertNodeType)('BlockStatement'),
    },
    async: {
      validate: (0, _utils$1.assertValueType)('boolean'),
      default: false,
    },
  },
})
;(0, _utils$1.default)('ExportDefaultSpecifier', {
  visitor: ['exported'],
  aliases: ['ModuleSpecifier'],
  fields: {
    exported: {
      validate: (0, _utils$1.assertNodeType)('Identifier'),
    },
  },
})
;(0, _utils$1.default)('RecordExpression', {
  visitor: ['properties'],
  aliases: ['Expression'],
  fields: {
    properties: {
      validate: (0, _utils$1.chain)(
        (0, _utils$1.assertValueType)('array'),
        (0, _utils$1.assertEach)((0, _utils$1.assertNodeType)('ObjectProperty', 'SpreadElement'))
      ),
    },
  },
})
;(0, _utils$1.default)('TupleExpression', {
  fields: {
    elements: {
      validate: (0, _utils$1.chain)(
        (0, _utils$1.assertValueType)('array'),
        (0, _utils$1.assertEach)((0, _utils$1.assertNodeType)('Expression', 'SpreadElement'))
      ),
      default: [],
    },
  },
  visitor: ['elements'],
  aliases: ['Expression'],
})
;(0, _utils$1.default)('DecimalLiteral', {
  builder: ['value'],
  fields: {
    value: {
      validate: (0, _utils$1.assertValueType)('string'),
    },
  },
  aliases: ['Expression', 'Pureish', 'Literal', 'Immutable'],
})
;(0, _utils$1.default)('ModuleExpression', {
  visitor: ['body'],
  fields: {
    body: {
      validate: (0, _utils$1.assertNodeType)('Program'),
    },
  },
  aliases: ['Expression'],
})
;(0, _utils$1.default)('TopicReference', {
  aliases: ['Expression'],
})
;(0, _utils$1.default)('PipelineTopicExpression', {
  builder: ['expression'],
  visitor: ['expression'],
  fields: {
    expression: {
      validate: (0, _utils$1.assertNodeType)('Expression'),
    },
  },
  aliases: ['Expression'],
})
;(0, _utils$1.default)('PipelineBareFunction', {
  builder: ['callee'],
  visitor: ['callee'],
  fields: {
    callee: {
      validate: (0, _utils$1.assertNodeType)('Expression'),
    },
  },
  aliases: ['Expression'],
})
;(0, _utils$1.default)('PipelinePrimaryTopicReference', {
  aliases: ['Expression'],
})
var _utils = utils
var _core = core
var _is$1 = is$2
const defineType = (0, _utils.defineAliasedType)('TypeScript')
const bool = (0, _utils.assertValueType)('boolean')
const tSFunctionTypeAnnotationCommon = {
  returnType: {
    validate: (0, _utils.assertNodeType)('TSTypeAnnotation', 'Noop'),
    optional: true,
  },
  typeParameters: {
    validate: (0, _utils.assertNodeType)('TSTypeParameterDeclaration', 'Noop'),
    optional: true,
  },
}
defineType('TSParameterProperty', {
  aliases: ['LVal'],
  visitor: ['parameter'],
  fields: {
    accessibility: {
      validate: (0, _utils.assertOneOf)('public', 'private', 'protected'),
      optional: true,
    },
    readonly: {
      validate: (0, _utils.assertValueType)('boolean'),
      optional: true,
    },
    parameter: {
      validate: (0, _utils.assertNodeType)('Identifier', 'AssignmentPattern'),
    },
    override: {
      validate: (0, _utils.assertValueType)('boolean'),
      optional: true,
    },
    decorators: {
      validate: (0, _utils.chain)(
        (0, _utils.assertValueType)('array'),
        (0, _utils.assertEach)((0, _utils.assertNodeType)('Decorator'))
      ),
      optional: true,
    },
  },
})
defineType('TSDeclareFunction', {
  aliases: ['Statement', 'Declaration'],
  visitor: ['id', 'typeParameters', 'params', 'returnType'],
  fields: Object.assign({}, _core.functionDeclarationCommon, tSFunctionTypeAnnotationCommon),
})
defineType('TSDeclareMethod', {
  visitor: ['decorators', 'key', 'typeParameters', 'params', 'returnType'],
  fields: Object.assign({}, _core.classMethodOrDeclareMethodCommon, tSFunctionTypeAnnotationCommon),
})
defineType('TSQualifiedName', {
  aliases: ['TSEntityName'],
  visitor: ['left', 'right'],
  fields: {
    left: (0, _utils.validateType)('TSEntityName'),
    right: (0, _utils.validateType)('Identifier'),
  },
})
const signatureDeclarationCommon = {
  typeParameters: (0, _utils.validateOptionalType)('TSTypeParameterDeclaration'),
  ['parameters']: (0, _utils.validateArrayOfType)(['Identifier', 'RestElement']),
  ['typeAnnotation']: (0, _utils.validateOptionalType)('TSTypeAnnotation'),
}
const callConstructSignatureDeclaration = {
  aliases: ['TSTypeElement'],
  visitor: ['typeParameters', 'parameters', 'typeAnnotation'],
  fields: signatureDeclarationCommon,
}
defineType('TSCallSignatureDeclaration', callConstructSignatureDeclaration)
defineType('TSConstructSignatureDeclaration', callConstructSignatureDeclaration)
const namedTypeElementCommon = {
  key: (0, _utils.validateType)('Expression'),
  computed: (0, _utils.validate)(bool),
  optional: (0, _utils.validateOptional)(bool),
}
defineType('TSPropertySignature', {
  aliases: ['TSTypeElement'],
  visitor: ['key', 'typeAnnotation', 'initializer'],
  fields: Object.assign({}, namedTypeElementCommon, {
    readonly: (0, _utils.validateOptional)(bool),
    typeAnnotation: (0, _utils.validateOptionalType)('TSTypeAnnotation'),
    initializer: (0, _utils.validateOptionalType)('Expression'),
    kind: {
      validate: (0, _utils.assertOneOf)('get', 'set'),
    },
  }),
})
defineType('TSMethodSignature', {
  aliases: ['TSTypeElement'],
  visitor: ['key', 'typeParameters', 'parameters', 'typeAnnotation'],
  fields: Object.assign({}, signatureDeclarationCommon, namedTypeElementCommon, {
    kind: {
      validate: (0, _utils.assertOneOf)('method', 'get', 'set'),
    },
  }),
})
defineType('TSIndexSignature', {
  aliases: ['TSTypeElement'],
  visitor: ['parameters', 'typeAnnotation'],
  fields: {
    readonly: (0, _utils.validateOptional)(bool),
    static: (0, _utils.validateOptional)(bool),
    parameters: (0, _utils.validateArrayOfType)('Identifier'),
    typeAnnotation: (0, _utils.validateOptionalType)('TSTypeAnnotation'),
  },
})
const tsKeywordTypes = [
  'TSAnyKeyword',
  'TSBooleanKeyword',
  'TSBigIntKeyword',
  'TSIntrinsicKeyword',
  'TSNeverKeyword',
  'TSNullKeyword',
  'TSNumberKeyword',
  'TSObjectKeyword',
  'TSStringKeyword',
  'TSSymbolKeyword',
  'TSUndefinedKeyword',
  'TSUnknownKeyword',
  'TSVoidKeyword',
]
for (const type of tsKeywordTypes) {
  defineType(type, {
    aliases: ['TSType', 'TSBaseType'],
    visitor: [],
    fields: {},
  })
}
defineType('TSThisType', {
  aliases: ['TSType', 'TSBaseType'],
  visitor: [],
  fields: {},
})
const fnOrCtrBase = {
  aliases: ['TSType'],
  visitor: ['typeParameters', 'parameters', 'typeAnnotation'],
}
defineType(
  'TSFunctionType',
  Object.assign({}, fnOrCtrBase, {
    fields: signatureDeclarationCommon,
  })
)
defineType(
  'TSConstructorType',
  Object.assign({}, fnOrCtrBase, {
    fields: Object.assign({}, signatureDeclarationCommon, {
      abstract: (0, _utils.validateOptional)(bool),
    }),
  })
)
defineType('TSTypeReference', {
  aliases: ['TSType'],
  visitor: ['typeName', 'typeParameters'],
  fields: {
    typeName: (0, _utils.validateType)('TSEntityName'),
    typeParameters: (0, _utils.validateOptionalType)('TSTypeParameterInstantiation'),
  },
})
defineType('TSTypePredicate', {
  aliases: ['TSType'],
  visitor: ['parameterName', 'typeAnnotation'],
  builder: ['parameterName', 'typeAnnotation', 'asserts'],
  fields: {
    parameterName: (0, _utils.validateType)(['Identifier', 'TSThisType']),
    typeAnnotation: (0, _utils.validateOptionalType)('TSTypeAnnotation'),
    asserts: (0, _utils.validateOptional)(bool),
  },
})
defineType('TSTypeQuery', {
  aliases: ['TSType'],
  visitor: ['exprName', 'typeParameters'],
  fields: {
    exprName: (0, _utils.validateType)(['TSEntityName', 'TSImportType']),
    typeParameters: (0, _utils.validateOptionalType)('TSTypeParameterInstantiation'),
  },
})
defineType('TSTypeLiteral', {
  aliases: ['TSType'],
  visitor: ['members'],
  fields: {
    members: (0, _utils.validateArrayOfType)('TSTypeElement'),
  },
})
defineType('TSArrayType', {
  aliases: ['TSType'],
  visitor: ['elementType'],
  fields: {
    elementType: (0, _utils.validateType)('TSType'),
  },
})
defineType('TSTupleType', {
  aliases: ['TSType'],
  visitor: ['elementTypes'],
  fields: {
    elementTypes: (0, _utils.validateArrayOfType)(['TSType', 'TSNamedTupleMember']),
  },
})
defineType('TSOptionalType', {
  aliases: ['TSType'],
  visitor: ['typeAnnotation'],
  fields: {
    typeAnnotation: (0, _utils.validateType)('TSType'),
  },
})
defineType('TSRestType', {
  aliases: ['TSType'],
  visitor: ['typeAnnotation'],
  fields: {
    typeAnnotation: (0, _utils.validateType)('TSType'),
  },
})
defineType('TSNamedTupleMember', {
  visitor: ['label', 'elementType'],
  builder: ['label', 'elementType', 'optional'],
  fields: {
    label: (0, _utils.validateType)('Identifier'),
    optional: {
      validate: bool,
      default: false,
    },
    elementType: (0, _utils.validateType)('TSType'),
  },
})
const unionOrIntersection = {
  aliases: ['TSType'],
  visitor: ['types'],
  fields: {
    types: (0, _utils.validateArrayOfType)('TSType'),
  },
}
defineType('TSUnionType', unionOrIntersection)
defineType('TSIntersectionType', unionOrIntersection)
defineType('TSConditionalType', {
  aliases: ['TSType'],
  visitor: ['checkType', 'extendsType', 'trueType', 'falseType'],
  fields: {
    checkType: (0, _utils.validateType)('TSType'),
    extendsType: (0, _utils.validateType)('TSType'),
    trueType: (0, _utils.validateType)('TSType'),
    falseType: (0, _utils.validateType)('TSType'),
  },
})
defineType('TSInferType', {
  aliases: ['TSType'],
  visitor: ['typeParameter'],
  fields: {
    typeParameter: (0, _utils.validateType)('TSTypeParameter'),
  },
})
defineType('TSParenthesizedType', {
  aliases: ['TSType'],
  visitor: ['typeAnnotation'],
  fields: {
    typeAnnotation: (0, _utils.validateType)('TSType'),
  },
})
defineType('TSTypeOperator', {
  aliases: ['TSType'],
  visitor: ['typeAnnotation'],
  fields: {
    operator: (0, _utils.validate)((0, _utils.assertValueType)('string')),
    typeAnnotation: (0, _utils.validateType)('TSType'),
  },
})
defineType('TSIndexedAccessType', {
  aliases: ['TSType'],
  visitor: ['objectType', 'indexType'],
  fields: {
    objectType: (0, _utils.validateType)('TSType'),
    indexType: (0, _utils.validateType)('TSType'),
  },
})
defineType('TSMappedType', {
  aliases: ['TSType'],
  visitor: ['typeParameter', 'typeAnnotation', 'nameType'],
  fields: {
    readonly: (0, _utils.validateOptional)(bool),
    typeParameter: (0, _utils.validateType)('TSTypeParameter'),
    optional: (0, _utils.validateOptional)(bool),
    typeAnnotation: (0, _utils.validateOptionalType)('TSType'),
    nameType: (0, _utils.validateOptionalType)('TSType'),
  },
})
defineType('TSLiteralType', {
  aliases: ['TSType', 'TSBaseType'],
  visitor: ['literal'],
  fields: {
    literal: {
      validate: (function () {
        const unaryExpression2 = (0, _utils.assertNodeType)('NumericLiteral', 'BigIntLiteral')
        const unaryOperator = (0, _utils.assertOneOf)('-')
        const literal2 = (0, _utils.assertNodeType)(
          'NumericLiteral',
          'StringLiteral',
          'BooleanLiteral',
          'BigIntLiteral'
        )
        function validator(parent, key, node2) {
          if ((0, _is$1.default)('UnaryExpression', node2)) {
            unaryOperator(node2, 'operator', node2.operator)
            unaryExpression2(node2, 'argument', node2.argument)
          } else {
            literal2(parent, key, node2)
          }
        }
        validator.oneOfNodeTypes = [
          'NumericLiteral',
          'StringLiteral',
          'BooleanLiteral',
          'BigIntLiteral',
          'UnaryExpression',
        ]
        return validator
      })(),
    },
  },
})
defineType('TSExpressionWithTypeArguments', {
  aliases: ['TSType'],
  visitor: ['expression', 'typeParameters'],
  fields: {
    expression: (0, _utils.validateType)('TSEntityName'),
    typeParameters: (0, _utils.validateOptionalType)('TSTypeParameterInstantiation'),
  },
})
defineType('TSInterfaceDeclaration', {
  aliases: ['Statement', 'Declaration'],
  visitor: ['id', 'typeParameters', 'extends', 'body'],
  fields: {
    declare: (0, _utils.validateOptional)(bool),
    id: (0, _utils.validateType)('Identifier'),
    typeParameters: (0, _utils.validateOptionalType)('TSTypeParameterDeclaration'),
    extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)('TSExpressionWithTypeArguments')),
    body: (0, _utils.validateType)('TSInterfaceBody'),
  },
})
defineType('TSInterfaceBody', {
  visitor: ['body'],
  fields: {
    body: (0, _utils.validateArrayOfType)('TSTypeElement'),
  },
})
defineType('TSTypeAliasDeclaration', {
  aliases: ['Statement', 'Declaration'],
  visitor: ['id', 'typeParameters', 'typeAnnotation'],
  fields: {
    declare: (0, _utils.validateOptional)(bool),
    id: (0, _utils.validateType)('Identifier'),
    typeParameters: (0, _utils.validateOptionalType)('TSTypeParameterDeclaration'),
    typeAnnotation: (0, _utils.validateType)('TSType'),
  },
})
defineType('TSInstantiationExpression', {
  aliases: ['Expression'],
  visitor: ['expression', 'typeParameters'],
  fields: {
    expression: (0, _utils.validateType)('Expression'),
    typeParameters: (0, _utils.validateOptionalType)('TSTypeParameterInstantiation'),
  },
})
defineType('TSAsExpression', {
  aliases: ['Expression', 'LVal', 'PatternLike'],
  visitor: ['expression', 'typeAnnotation'],
  fields: {
    expression: (0, _utils.validateType)('Expression'),
    typeAnnotation: (0, _utils.validateType)('TSType'),
  },
})
defineType('TSTypeAssertion', {
  aliases: ['Expression', 'LVal', 'PatternLike'],
  visitor: ['typeAnnotation', 'expression'],
  fields: {
    typeAnnotation: (0, _utils.validateType)('TSType'),
    expression: (0, _utils.validateType)('Expression'),
  },
})
defineType('TSEnumDeclaration', {
  aliases: ['Statement', 'Declaration'],
  visitor: ['id', 'members'],
  fields: {
    declare: (0, _utils.validateOptional)(bool),
    const: (0, _utils.validateOptional)(bool),
    id: (0, _utils.validateType)('Identifier'),
    members: (0, _utils.validateArrayOfType)('TSEnumMember'),
    initializer: (0, _utils.validateOptionalType)('Expression'),
  },
})
defineType('TSEnumMember', {
  visitor: ['id', 'initializer'],
  fields: {
    id: (0, _utils.validateType)(['Identifier', 'StringLiteral']),
    initializer: (0, _utils.validateOptionalType)('Expression'),
  },
})
defineType('TSModuleDeclaration', {
  aliases: ['Statement', 'Declaration'],
  visitor: ['id', 'body'],
  fields: {
    declare: (0, _utils.validateOptional)(bool),
    global: (0, _utils.validateOptional)(bool),
    id: (0, _utils.validateType)(['Identifier', 'StringLiteral']),
    body: (0, _utils.validateType)(['TSModuleBlock', 'TSModuleDeclaration']),
  },
})
defineType('TSModuleBlock', {
  aliases: ['Scopable', 'Block', 'BlockParent'],
  visitor: ['body'],
  fields: {
    body: (0, _utils.validateArrayOfType)('Statement'),
  },
})
defineType('TSImportType', {
  aliases: ['TSType'],
  visitor: ['argument', 'qualifier', 'typeParameters'],
  fields: {
    argument: (0, _utils.validateType)('StringLiteral'),
    qualifier: (0, _utils.validateOptionalType)('TSEntityName'),
    typeParameters: (0, _utils.validateOptionalType)('TSTypeParameterInstantiation'),
  },
})
defineType('TSImportEqualsDeclaration', {
  aliases: ['Statement'],
  visitor: ['id', 'moduleReference'],
  fields: {
    isExport: (0, _utils.validate)(bool),
    id: (0, _utils.validateType)('Identifier'),
    moduleReference: (0, _utils.validateType)(['TSEntityName', 'TSExternalModuleReference']),
    importKind: {
      validate: (0, _utils.assertOneOf)('type', 'value'),
      optional: true,
    },
  },
})
defineType('TSExternalModuleReference', {
  visitor: ['expression'],
  fields: {
    expression: (0, _utils.validateType)('StringLiteral'),
  },
})
defineType('TSNonNullExpression', {
  aliases: ['Expression', 'LVal', 'PatternLike'],
  visitor: ['expression'],
  fields: {
    expression: (0, _utils.validateType)('Expression'),
  },
})
defineType('TSExportAssignment', {
  aliases: ['Statement'],
  visitor: ['expression'],
  fields: {
    expression: (0, _utils.validateType)('Expression'),
  },
})
defineType('TSNamespaceExportDeclaration', {
  aliases: ['Statement'],
  visitor: ['id'],
  fields: {
    id: (0, _utils.validateType)('Identifier'),
  },
})
defineType('TSTypeAnnotation', {
  visitor: ['typeAnnotation'],
  fields: {
    typeAnnotation: {
      validate: (0, _utils.assertNodeType)('TSType'),
    },
  },
})
defineType('TSTypeParameterInstantiation', {
  visitor: ['params'],
  fields: {
    params: {
      validate: (0, _utils.chain)(
        (0, _utils.assertValueType)('array'),
        (0, _utils.assertEach)((0, _utils.assertNodeType)('TSType'))
      ),
    },
  },
})
defineType('TSTypeParameterDeclaration', {
  visitor: ['params'],
  fields: {
    params: {
      validate: (0, _utils.chain)(
        (0, _utils.assertValueType)('array'),
        (0, _utils.assertEach)((0, _utils.assertNodeType)('TSTypeParameter'))
      ),
    },
  },
})
defineType('TSTypeParameter', {
  builder: ['constraint', 'default', 'name'],
  visitor: ['constraint', 'default'],
  fields: {
    name: {
      validate: (0, _utils.assertValueType)('string'),
    },
    in: {
      validate: (0, _utils.assertValueType)('boolean'),
      optional: true,
    },
    out: {
      validate: (0, _utils.assertValueType)('boolean'),
      optional: true,
    },
    constraint: {
      validate: (0, _utils.assertNodeType)('TSType'),
      optional: true,
    },
    default: {
      validate: (0, _utils.assertNodeType)('TSType'),
      optional: true,
    },
  },
})
;(function (exports) {
  Object.defineProperty(exports, '__esModule', {
    value: true,
  })
  Object.defineProperty(exports, 'ALIAS_KEYS', {
    enumerable: true,
    get: function () {
      return _utils2.ALIAS_KEYS
    },
  })
  Object.defineProperty(exports, 'BUILDER_KEYS', {
    enumerable: true,
    get: function () {
      return _utils2.BUILDER_KEYS
    },
  })
  Object.defineProperty(exports, 'DEPRECATED_KEYS', {
    enumerable: true,
    get: function () {
      return _utils2.DEPRECATED_KEYS
    },
  })
  Object.defineProperty(exports, 'FLIPPED_ALIAS_KEYS', {
    enumerable: true,
    get: function () {
      return _utils2.FLIPPED_ALIAS_KEYS
    },
  })
  Object.defineProperty(exports, 'NODE_FIELDS', {
    enumerable: true,
    get: function () {
      return _utils2.NODE_FIELDS
    },
  })
  Object.defineProperty(exports, 'NODE_PARENT_VALIDATIONS', {
    enumerable: true,
    get: function () {
      return _utils2.NODE_PARENT_VALIDATIONS
    },
  })
  Object.defineProperty(exports, 'PLACEHOLDERS', {
    enumerable: true,
    get: function () {
      return _placeholders2.PLACEHOLDERS
    },
  })
  Object.defineProperty(exports, 'PLACEHOLDERS_ALIAS', {
    enumerable: true,
    get: function () {
      return _placeholders2.PLACEHOLDERS_ALIAS
    },
  })
  Object.defineProperty(exports, 'PLACEHOLDERS_FLIPPED_ALIAS', {
    enumerable: true,
    get: function () {
      return _placeholders2.PLACEHOLDERS_FLIPPED_ALIAS
    },
  })
  exports.TYPES = void 0
  Object.defineProperty(exports, 'VISITOR_KEYS', {
    enumerable: true,
    get: function () {
      return _utils2.VISITOR_KEYS
    },
  })
  var _toFastProperties = toFastProperties
  var _utils2 = utils
  var _placeholders2 = placeholders$2
  _toFastProperties(_utils2.VISITOR_KEYS)
  _toFastProperties(_utils2.ALIAS_KEYS)
  _toFastProperties(_utils2.FLIPPED_ALIAS_KEYS)
  _toFastProperties(_utils2.NODE_FIELDS)
  _toFastProperties(_utils2.BUILDER_KEYS)
  _toFastProperties(_utils2.DEPRECATED_KEYS)
  _toFastProperties(_placeholders2.PLACEHOLDERS_ALIAS)
  _toFastProperties(_placeholders2.PLACEHOLDERS_FLIPPED_ALIAS)
  const TYPES2 = [].concat(
    Object.keys(_utils2.VISITOR_KEYS),
    Object.keys(_utils2.FLIPPED_ALIAS_KEYS),
    Object.keys(_utils2.DEPRECATED_KEYS)
  )
  exports.TYPES = TYPES2
})(definitions)
Object.defineProperty(validate$6, '__esModule', {
  value: true,
})
validate$6.default = validate$4
validate$6.validateChild = validateChild
validate$6.validateField = validateField
var _definitions$6 = definitions
function validate$4(node2, key, val) {
  if (!node2) return
  const fields = _definitions$6.NODE_FIELDS[node2.type]
  if (!fields) return
  const field = fields[key]
  validateField(node2, key, val, field)
  validateChild(node2, key, val)
}
function validateField(node2, key, val, field) {
  if (!(field != null && field.validate)) return
  if (field.optional && val == null) return
  field.validate(node2, key, val)
}
function validateChild(node2, key, val) {
  if (val == null) return
  const validate2 = _definitions$6.NODE_PARENT_VALIDATIONS[val.type]
  if (!validate2) return
  validate2(node2, key, val)
}
Object.defineProperty(validateNode$1, '__esModule', {
  value: true,
})
validateNode$1.default = validateNode
var _validate = validate$6
var _ = lib$b
function validateNode(node2) {
  const keys = _.BUILDER_KEYS[node2.type]
  for (const key of keys) {
    ;(0, _validate.default)(node2, key, node2[key])
  }
  return node2
}
Object.defineProperty(generated$3, '__esModule', {
  value: true,
})
generated$3.anyTypeAnnotation = anyTypeAnnotation$1
generated$3.argumentPlaceholder = argumentPlaceholder
generated$3.arrayExpression = arrayExpression
generated$3.arrayPattern = arrayPattern
generated$3.arrayTypeAnnotation = arrayTypeAnnotation
generated$3.arrowFunctionExpression = arrowFunctionExpression$3
generated$3.assignmentExpression = assignmentExpression$4
generated$3.assignmentPattern = assignmentPattern
generated$3.awaitExpression = awaitExpression$1
generated$3.bigIntLiteral = bigIntLiteral
generated$3.binaryExpression = binaryExpression$1
generated$3.bindExpression = bindExpression
generated$3.blockStatement = blockStatement$4
generated$3.booleanLiteral = booleanLiteral
generated$3.booleanLiteralTypeAnnotation = booleanLiteralTypeAnnotation
generated$3.booleanTypeAnnotation = booleanTypeAnnotation
generated$3.breakStatement = breakStatement
generated$3.callExpression = callExpression$4
generated$3.catchClause = catchClause
generated$3.classAccessorProperty = classAccessorProperty
generated$3.classBody = classBody
generated$3.classDeclaration = classDeclaration
generated$3.classExpression = classExpression
generated$3.classImplements = classImplements
generated$3.classMethod = classMethod
generated$3.classPrivateMethod = classPrivateMethod
generated$3.classPrivateProperty = classPrivateProperty
generated$3.classProperty = classProperty
generated$3.conditionalExpression = conditionalExpression$1
generated$3.continueStatement = continueStatement
generated$3.debuggerStatement = debuggerStatement
generated$3.decimalLiteral = decimalLiteral
generated$3.declareClass = declareClass
generated$3.declareExportAllDeclaration = declareExportAllDeclaration
generated$3.declareExportDeclaration = declareExportDeclaration
generated$3.declareFunction = declareFunction
generated$3.declareInterface = declareInterface
generated$3.declareModule = declareModule
generated$3.declareModuleExports = declareModuleExports
generated$3.declareOpaqueType = declareOpaqueType
generated$3.declareTypeAlias = declareTypeAlias
generated$3.declareVariable = declareVariable
generated$3.declaredPredicate = declaredPredicate
generated$3.decorator = decorator
generated$3.directive = directive
generated$3.directiveLiteral = directiveLiteral
generated$3.doExpression = doExpression
generated$3.doWhileStatement = doWhileStatement
generated$3.emptyStatement = emptyStatement$1
generated$3.emptyTypeAnnotation = emptyTypeAnnotation
generated$3.enumBooleanBody = enumBooleanBody
generated$3.enumBooleanMember = enumBooleanMember
generated$3.enumDeclaration = enumDeclaration
generated$3.enumDefaultedMember = enumDefaultedMember
generated$3.enumNumberBody = enumNumberBody
generated$3.enumNumberMember = enumNumberMember
generated$3.enumStringBody = enumStringBody
generated$3.enumStringMember = enumStringMember
generated$3.enumSymbolBody = enumSymbolBody
generated$3.existsTypeAnnotation = existsTypeAnnotation
generated$3.exportAllDeclaration = exportAllDeclaration
generated$3.exportDefaultDeclaration = exportDefaultDeclaration
generated$3.exportDefaultSpecifier = exportDefaultSpecifier
generated$3.exportNamedDeclaration = exportNamedDeclaration$1
generated$3.exportNamespaceSpecifier = exportNamespaceSpecifier
generated$3.exportSpecifier = exportSpecifier$1
generated$3.expressionStatement = expressionStatement$5
generated$3.file = file
generated$3.forInStatement = forInStatement
generated$3.forOfStatement = forOfStatement
generated$3.forStatement = forStatement
generated$3.functionDeclaration = functionDeclaration
generated$3.functionExpression = functionExpression
generated$3.functionTypeAnnotation = functionTypeAnnotation
generated$3.functionTypeParam = functionTypeParam
generated$3.genericTypeAnnotation = genericTypeAnnotation
generated$3.identifier = identifier$7
generated$3.ifStatement = ifStatement
generated$3.import = _import
generated$3.importAttribute = importAttribute
generated$3.importDeclaration = importDeclaration
generated$3.importDefaultSpecifier = importDefaultSpecifier
generated$3.importNamespaceSpecifier = importNamespaceSpecifier
generated$3.importSpecifier = importSpecifier
generated$3.indexedAccessType = indexedAccessType
generated$3.inferredPredicate = inferredPredicate
generated$3.interfaceDeclaration = interfaceDeclaration
generated$3.interfaceExtends = interfaceExtends
generated$3.interfaceTypeAnnotation = interfaceTypeAnnotation
generated$3.interpreterDirective = interpreterDirective
generated$3.intersectionTypeAnnotation = intersectionTypeAnnotation
generated$3.jSXAttribute = generated$3.jsxAttribute = jsxAttribute
generated$3.jSXClosingElement = generated$3.jsxClosingElement = jsxClosingElement
generated$3.jSXClosingFragment = generated$3.jsxClosingFragment = jsxClosingFragment
generated$3.jSXElement = generated$3.jsxElement = jsxElement
generated$3.jSXEmptyExpression = generated$3.jsxEmptyExpression = jsxEmptyExpression
generated$3.jSXExpressionContainer = generated$3.jsxExpressionContainer = jsxExpressionContainer$1
generated$3.jSXFragment = generated$3.jsxFragment = jsxFragment
generated$3.jSXIdentifier = generated$3.jsxIdentifier = jsxIdentifier$1
generated$3.jSXMemberExpression = generated$3.jsxMemberExpression = jsxMemberExpression
generated$3.jSXNamespacedName = generated$3.jsxNamespacedName = jsxNamespacedName
generated$3.jSXOpeningElement = generated$3.jsxOpeningElement = jsxOpeningElement
generated$3.jSXOpeningFragment = generated$3.jsxOpeningFragment = jsxOpeningFragment
generated$3.jSXSpreadAttribute = generated$3.jsxSpreadAttribute = jsxSpreadAttribute
generated$3.jSXSpreadChild = generated$3.jsxSpreadChild = jsxSpreadChild
generated$3.jSXText = generated$3.jsxText = jsxText
generated$3.labeledStatement = labeledStatement
generated$3.logicalExpression = logicalExpression$1
generated$3.memberExpression = memberExpression$2
generated$3.metaProperty = metaProperty$1
generated$3.mixedTypeAnnotation = mixedTypeAnnotation
generated$3.moduleExpression = moduleExpression
generated$3.newExpression = newExpression
generated$3.noop = noop
generated$3.nullLiteral = nullLiteral
generated$3.nullLiteralTypeAnnotation = nullLiteralTypeAnnotation
generated$3.nullableTypeAnnotation = nullableTypeAnnotation
generated$3.numberLiteral = NumberLiteral
generated$3.numberLiteralTypeAnnotation = numberLiteralTypeAnnotation
generated$3.numberTypeAnnotation = numberTypeAnnotation$1
generated$3.numericLiteral = numericLiteral$3
generated$3.objectExpression = objectExpression$1
generated$3.objectMethod = objectMethod
generated$3.objectPattern = objectPattern
generated$3.objectProperty = objectProperty
generated$3.objectTypeAnnotation = objectTypeAnnotation
generated$3.objectTypeCallProperty = objectTypeCallProperty
generated$3.objectTypeIndexer = objectTypeIndexer
generated$3.objectTypeInternalSlot = objectTypeInternalSlot
generated$3.objectTypeProperty = objectTypeProperty
generated$3.objectTypeSpreadProperty = objectTypeSpreadProperty
generated$3.opaqueType = opaqueType
generated$3.optionalCallExpression = optionalCallExpression
generated$3.optionalIndexedAccessType = optionalIndexedAccessType
generated$3.optionalMemberExpression = optionalMemberExpression
generated$3.parenthesizedExpression = parenthesizedExpression
generated$3.pipelineBareFunction = pipelineBareFunction
generated$3.pipelinePrimaryTopicReference = pipelinePrimaryTopicReference
generated$3.pipelineTopicExpression = pipelineTopicExpression
generated$3.placeholder = placeholder
generated$3.privateName = privateName
generated$3.program = program$2
generated$3.qualifiedTypeIdentifier = qualifiedTypeIdentifier
generated$3.recordExpression = recordExpression
generated$3.regExpLiteral = regExpLiteral
generated$3.regexLiteral = RegexLiteral
generated$3.restElement = restElement$1
generated$3.restProperty = RestProperty$1
generated$3.returnStatement = returnStatement$2
generated$3.sequenceExpression = sequenceExpression$1
generated$3.spreadElement = spreadElement$1
generated$3.spreadProperty = SpreadProperty$1
generated$3.staticBlock = staticBlock
generated$3.stringLiteral = stringLiteral$2
generated$3.stringLiteralTypeAnnotation = stringLiteralTypeAnnotation
generated$3.stringTypeAnnotation = stringTypeAnnotation$1
generated$3.super = _super$1
generated$3.switchCase = switchCase
generated$3.switchStatement = switchStatement
generated$3.symbolTypeAnnotation = symbolTypeAnnotation
generated$3.taggedTemplateExpression = taggedTemplateExpression
generated$3.templateElement = templateElement
generated$3.templateLiteral = templateLiteral
generated$3.thisExpression = thisExpression$2
generated$3.thisTypeAnnotation = thisTypeAnnotation
generated$3.throwStatement = throwStatement
generated$3.topicReference = topicReference
generated$3.tryStatement = tryStatement
generated$3.tSAnyKeyword = generated$3.tsAnyKeyword = tsAnyKeyword
generated$3.tSArrayType = generated$3.tsArrayType = tsArrayType
generated$3.tSAsExpression = generated$3.tsAsExpression = tsAsExpression
generated$3.tSBigIntKeyword = generated$3.tsBigIntKeyword = tsBigIntKeyword
generated$3.tSBooleanKeyword = generated$3.tsBooleanKeyword = tsBooleanKeyword
generated$3.tSCallSignatureDeclaration = generated$3.tsCallSignatureDeclaration = tsCallSignatureDeclaration
generated$3.tSConditionalType = generated$3.tsConditionalType = tsConditionalType
generated$3.tSConstructSignatureDeclaration = generated$3.tsConstructSignatureDeclaration =
  tsConstructSignatureDeclaration
generated$3.tSConstructorType = generated$3.tsConstructorType = tsConstructorType
generated$3.tSDeclareFunction = generated$3.tsDeclareFunction = tsDeclareFunction
generated$3.tSDeclareMethod = generated$3.tsDeclareMethod = tsDeclareMethod
generated$3.tSEnumDeclaration = generated$3.tsEnumDeclaration = tsEnumDeclaration
generated$3.tSEnumMember = generated$3.tsEnumMember = tsEnumMember
generated$3.tSExportAssignment = generated$3.tsExportAssignment = tsExportAssignment
generated$3.tSExpressionWithTypeArguments = generated$3.tsExpressionWithTypeArguments = tsExpressionWithTypeArguments
generated$3.tSExternalModuleReference = generated$3.tsExternalModuleReference = tsExternalModuleReference
generated$3.tSFunctionType = generated$3.tsFunctionType = tsFunctionType
generated$3.tSImportEqualsDeclaration = generated$3.tsImportEqualsDeclaration = tsImportEqualsDeclaration
generated$3.tSImportType = generated$3.tsImportType = tsImportType
generated$3.tSIndexSignature = generated$3.tsIndexSignature = tsIndexSignature
generated$3.tSIndexedAccessType = generated$3.tsIndexedAccessType = tsIndexedAccessType
generated$3.tSInferType = generated$3.tsInferType = tsInferType
generated$3.tSInstantiationExpression = generated$3.tsInstantiationExpression = tsInstantiationExpression
generated$3.tSInterfaceBody = generated$3.tsInterfaceBody = tsInterfaceBody
generated$3.tSInterfaceDeclaration = generated$3.tsInterfaceDeclaration = tsInterfaceDeclaration
generated$3.tSIntersectionType = generated$3.tsIntersectionType = tsIntersectionType
generated$3.tSIntrinsicKeyword = generated$3.tsIntrinsicKeyword = tsIntrinsicKeyword
generated$3.tSLiteralType = generated$3.tsLiteralType = tsLiteralType
generated$3.tSMappedType = generated$3.tsMappedType = tsMappedType
generated$3.tSMethodSignature = generated$3.tsMethodSignature = tsMethodSignature
generated$3.tSModuleBlock = generated$3.tsModuleBlock = tsModuleBlock
generated$3.tSModuleDeclaration = generated$3.tsModuleDeclaration = tsModuleDeclaration
generated$3.tSNamedTupleMember = generated$3.tsNamedTupleMember = tsNamedTupleMember
generated$3.tSNamespaceExportDeclaration = generated$3.tsNamespaceExportDeclaration = tsNamespaceExportDeclaration
generated$3.tSNeverKeyword = generated$3.tsNeverKeyword = tsNeverKeyword
generated$3.tSNonNullExpression = generated$3.tsNonNullExpression = tsNonNullExpression
generated$3.tSNullKeyword = generated$3.tsNullKeyword = tsNullKeyword
generated$3.tSNumberKeyword = generated$3.tsNumberKeyword = tsNumberKeyword
generated$3.tSObjectKeyword = generated$3.tsObjectKeyword = tsObjectKeyword
generated$3.tSOptionalType = generated$3.tsOptionalType = tsOptionalType
generated$3.tSParameterProperty = generated$3.tsParameterProperty = tsParameterProperty
generated$3.tSParenthesizedType = generated$3.tsParenthesizedType = tsParenthesizedType
generated$3.tSPropertySignature = generated$3.tsPropertySignature = tsPropertySignature
generated$3.tSQualifiedName = generated$3.tsQualifiedName = tsQualifiedName
generated$3.tSRestType = generated$3.tsRestType = tsRestType
generated$3.tSStringKeyword = generated$3.tsStringKeyword = tsStringKeyword
generated$3.tSSymbolKeyword = generated$3.tsSymbolKeyword = tsSymbolKeyword
generated$3.tSThisType = generated$3.tsThisType = tsThisType
generated$3.tSTupleType = generated$3.tsTupleType = tsTupleType
generated$3.tSTypeAliasDeclaration = generated$3.tsTypeAliasDeclaration = tsTypeAliasDeclaration
generated$3.tSTypeAnnotation = generated$3.tsTypeAnnotation = tsTypeAnnotation
generated$3.tSTypeAssertion = generated$3.tsTypeAssertion = tsTypeAssertion
generated$3.tSTypeLiteral = generated$3.tsTypeLiteral = tsTypeLiteral
generated$3.tSTypeOperator = generated$3.tsTypeOperator = tsTypeOperator
generated$3.tSTypeParameter = generated$3.tsTypeParameter = tsTypeParameter
generated$3.tSTypeParameterDeclaration = generated$3.tsTypeParameterDeclaration = tsTypeParameterDeclaration
generated$3.tSTypeParameterInstantiation = generated$3.tsTypeParameterInstantiation = tsTypeParameterInstantiation
generated$3.tSTypePredicate = generated$3.tsTypePredicate = tsTypePredicate
generated$3.tSTypeQuery = generated$3.tsTypeQuery = tsTypeQuery
generated$3.tSTypeReference = generated$3.tsTypeReference = tsTypeReference
generated$3.tSUndefinedKeyword = generated$3.tsUndefinedKeyword = tsUndefinedKeyword
generated$3.tSUnionType = generated$3.tsUnionType = tsUnionType
generated$3.tSUnknownKeyword = generated$3.tsUnknownKeyword = tsUnknownKeyword
generated$3.tSVoidKeyword = generated$3.tsVoidKeyword = tsVoidKeyword
generated$3.tupleExpression = tupleExpression
generated$3.tupleTypeAnnotation = tupleTypeAnnotation
generated$3.typeAlias = typeAlias
generated$3.typeAnnotation = typeAnnotation
generated$3.typeCastExpression = typeCastExpression
generated$3.typeParameter = typeParameter
generated$3.typeParameterDeclaration = typeParameterDeclaration
generated$3.typeParameterInstantiation = typeParameterInstantiation
generated$3.typeofTypeAnnotation = typeofTypeAnnotation
generated$3.unaryExpression = unaryExpression$3
generated$3.unionTypeAnnotation = unionTypeAnnotation
generated$3.updateExpression = updateExpression
generated$3.v8IntrinsicIdentifier = v8IntrinsicIdentifier
generated$3.variableDeclaration = variableDeclaration$3
generated$3.variableDeclarator = variableDeclarator$3
generated$3.variance = variance
generated$3.voidTypeAnnotation = voidTypeAnnotation$2
generated$3.whileStatement = whileStatement
generated$3.withStatement = withStatement
generated$3.yieldExpression = yieldExpression$1
var _validateNode = validateNode$1
function arrayExpression(elements = []) {
  return (0, _validateNode.default)({
    type: 'ArrayExpression',
    elements,
  })
}
function assignmentExpression$4(operator, left, right) {
  return (0, _validateNode.default)({
    type: 'AssignmentExpression',
    operator,
    left,
    right,
  })
}
function binaryExpression$1(operator, left, right) {
  return (0, _validateNode.default)({
    type: 'BinaryExpression',
    operator,
    left,
    right,
  })
}
function interpreterDirective(value) {
  return (0, _validateNode.default)({
    type: 'InterpreterDirective',
    value,
  })
}
function directive(value) {
  return (0, _validateNode.default)({
    type: 'Directive',
    value,
  })
}
function directiveLiteral(value) {
  return (0, _validateNode.default)({
    type: 'DirectiveLiteral',
    value,
  })
}
function blockStatement$4(body, directives = []) {
  return (0, _validateNode.default)({
    type: 'BlockStatement',
    body,
    directives,
  })
}
function breakStatement(label = null) {
  return (0, _validateNode.default)({
    type: 'BreakStatement',
    label,
  })
}
function callExpression$4(callee, _arguments) {
  return (0, _validateNode.default)({
    type: 'CallExpression',
    callee,
    arguments: _arguments,
  })
}
function catchClause(param = null, body) {
  return (0, _validateNode.default)({
    type: 'CatchClause',
    param,
    body,
  })
}
function conditionalExpression$1(test, consequent, alternate) {
  return (0, _validateNode.default)({
    type: 'ConditionalExpression',
    test,
    consequent,
    alternate,
  })
}
function continueStatement(label = null) {
  return (0, _validateNode.default)({
    type: 'ContinueStatement',
    label,
  })
}
function debuggerStatement() {
  return {
    type: 'DebuggerStatement',
  }
}
function doWhileStatement(test, body) {
  return (0, _validateNode.default)({
    type: 'DoWhileStatement',
    test,
    body,
  })
}
function emptyStatement$1() {
  return {
    type: 'EmptyStatement',
  }
}
function expressionStatement$5(expression2) {
  return (0, _validateNode.default)({
    type: 'ExpressionStatement',
    expression: expression2,
  })
}
function file(program2, comments2 = null, tokens = null) {
  return (0, _validateNode.default)({
    type: 'File',
    program: program2,
    comments: comments2,
    tokens,
  })
}
function forInStatement(left, right, body) {
  return (0, _validateNode.default)({
    type: 'ForInStatement',
    left,
    right,
    body,
  })
}
function forStatement(init = null, test = null, update = null, body) {
  return (0, _validateNode.default)({
    type: 'ForStatement',
    init,
    test,
    update,
    body,
  })
}
function functionDeclaration(id = null, params, body, generator = false, async = false) {
  return (0, _validateNode.default)({
    type: 'FunctionDeclaration',
    id,
    params,
    body,
    generator,
    async,
  })
}
function functionExpression(id = null, params, body, generator = false, async = false) {
  return (0, _validateNode.default)({
    type: 'FunctionExpression',
    id,
    params,
    body,
    generator,
    async,
  })
}
function identifier$7(name) {
  return (0, _validateNode.default)({
    type: 'Identifier',
    name,
  })
}
function ifStatement(test, consequent, alternate = null) {
  return (0, _validateNode.default)({
    type: 'IfStatement',
    test,
    consequent,
    alternate,
  })
}
function labeledStatement(label, body) {
  return (0, _validateNode.default)({
    type: 'LabeledStatement',
    label,
    body,
  })
}
function stringLiteral$2(value) {
  return (0, _validateNode.default)({
    type: 'StringLiteral',
    value,
  })
}
function numericLiteral$3(value) {
  return (0, _validateNode.default)({
    type: 'NumericLiteral',
    value,
  })
}
function nullLiteral() {
  return {
    type: 'NullLiteral',
  }
}
function booleanLiteral(value) {
  return (0, _validateNode.default)({
    type: 'BooleanLiteral',
    value,
  })
}
function regExpLiteral(pattern, flags = '') {
  return (0, _validateNode.default)({
    type: 'RegExpLiteral',
    pattern,
    flags,
  })
}
function logicalExpression$1(operator, left, right) {
  return (0, _validateNode.default)({
    type: 'LogicalExpression',
    operator,
    left,
    right,
  })
}
function memberExpression$2(object2, property, computed2 = false, optional = null) {
  return (0, _validateNode.default)({
    type: 'MemberExpression',
    object: object2,
    property,
    computed: computed2,
    optional,
  })
}
function newExpression(callee, _arguments) {
  return (0, _validateNode.default)({
    type: 'NewExpression',
    callee,
    arguments: _arguments,
  })
}
function program$2(body, directives = [], sourceType = 'script', interpreter = null) {
  return (0, _validateNode.default)({
    type: 'Program',
    body,
    directives,
    sourceType,
    interpreter,
    sourceFile: null,
  })
}
function objectExpression$1(properties) {
  return (0, _validateNode.default)({
    type: 'ObjectExpression',
    properties,
  })
}
function objectMethod(kind = 'method', key, params, body, computed2 = false, generator = false, async = false) {
  return (0, _validateNode.default)({
    type: 'ObjectMethod',
    kind,
    key,
    params,
    body,
    computed: computed2,
    generator,
    async,
  })
}
function objectProperty(key, value, computed2 = false, shorthand = false, decorators = null) {
  return (0, _validateNode.default)({
    type: 'ObjectProperty',
    key,
    value,
    computed: computed2,
    shorthand,
    decorators,
  })
}
function restElement$1(argument) {
  return (0, _validateNode.default)({
    type: 'RestElement',
    argument,
  })
}
function returnStatement$2(argument = null) {
  return (0, _validateNode.default)({
    type: 'ReturnStatement',
    argument,
  })
}
function sequenceExpression$1(expressions2) {
  return (0, _validateNode.default)({
    type: 'SequenceExpression',
    expressions: expressions2,
  })
}
function parenthesizedExpression(expression2) {
  return (0, _validateNode.default)({
    type: 'ParenthesizedExpression',
    expression: expression2,
  })
}
function switchCase(test = null, consequent) {
  return (0, _validateNode.default)({
    type: 'SwitchCase',
    test,
    consequent,
  })
}
function switchStatement(discriminant, cases) {
  return (0, _validateNode.default)({
    type: 'SwitchStatement',
    discriminant,
    cases,
  })
}
function thisExpression$2() {
  return {
    type: 'ThisExpression',
  }
}
function throwStatement(argument) {
  return (0, _validateNode.default)({
    type: 'ThrowStatement',
    argument,
  })
}
function tryStatement(block, handler = null, finalizer = null) {
  return (0, _validateNode.default)({
    type: 'TryStatement',
    block,
    handler,
    finalizer,
  })
}
function unaryExpression$3(operator, argument, prefix2 = true) {
  return (0, _validateNode.default)({
    type: 'UnaryExpression',
    operator,
    argument,
    prefix: prefix2,
  })
}
function updateExpression(operator, argument, prefix2 = false) {
  return (0, _validateNode.default)({
    type: 'UpdateExpression',
    operator,
    argument,
    prefix: prefix2,
  })
}
function variableDeclaration$3(kind, declarations) {
  return (0, _validateNode.default)({
    type: 'VariableDeclaration',
    kind,
    declarations,
  })
}
function variableDeclarator$3(id, init = null) {
  return (0, _validateNode.default)({
    type: 'VariableDeclarator',
    id,
    init,
  })
}
function whileStatement(test, body) {
  return (0, _validateNode.default)({
    type: 'WhileStatement',
    test,
    body,
  })
}
function withStatement(object2, body) {
  return (0, _validateNode.default)({
    type: 'WithStatement',
    object: object2,
    body,
  })
}
function assignmentPattern(left, right) {
  return (0, _validateNode.default)({
    type: 'AssignmentPattern',
    left,
    right,
  })
}
function arrayPattern(elements) {
  return (0, _validateNode.default)({
    type: 'ArrayPattern',
    elements,
  })
}
function arrowFunctionExpression$3(params, body, async = false) {
  return (0, _validateNode.default)({
    type: 'ArrowFunctionExpression',
    params,
    body,
    async,
    expression: null,
  })
}
function classBody(body) {
  return (0, _validateNode.default)({
    type: 'ClassBody',
    body,
  })
}
function classExpression(id = null, superClass = null, body, decorators = null) {
  return (0, _validateNode.default)({
    type: 'ClassExpression',
    id,
    superClass,
    body,
    decorators,
  })
}
function classDeclaration(id, superClass = null, body, decorators = null) {
  return (0, _validateNode.default)({
    type: 'ClassDeclaration',
    id,
    superClass,
    body,
    decorators,
  })
}
function exportAllDeclaration(source) {
  return (0, _validateNode.default)({
    type: 'ExportAllDeclaration',
    source,
  })
}
function exportDefaultDeclaration(declaration) {
  return (0, _validateNode.default)({
    type: 'ExportDefaultDeclaration',
    declaration,
  })
}
function exportNamedDeclaration$1(declaration = null, specifiers = [], source = null) {
  return (0, _validateNode.default)({
    type: 'ExportNamedDeclaration',
    declaration,
    specifiers,
    source,
  })
}
function exportSpecifier$1(local, exported) {
  return (0, _validateNode.default)({
    type: 'ExportSpecifier',
    local,
    exported,
  })
}
function forOfStatement(left, right, body, _await = false) {
  return (0, _validateNode.default)({
    type: 'ForOfStatement',
    left,
    right,
    body,
    await: _await,
  })
}
function importDeclaration(specifiers, source) {
  return (0, _validateNode.default)({
    type: 'ImportDeclaration',
    specifiers,
    source,
  })
}
function importDefaultSpecifier(local) {
  return (0, _validateNode.default)({
    type: 'ImportDefaultSpecifier',
    local,
  })
}
function importNamespaceSpecifier(local) {
  return (0, _validateNode.default)({
    type: 'ImportNamespaceSpecifier',
    local,
  })
}
function importSpecifier(local, imported) {
  return (0, _validateNode.default)({
    type: 'ImportSpecifier',
    local,
    imported,
  })
}
function metaProperty$1(meta, property) {
  return (0, _validateNode.default)({
    type: 'MetaProperty',
    meta,
    property,
  })
}
function classMethod(
  kind = 'method',
  key,
  params,
  body,
  computed2 = false,
  _static = false,
  generator = false,
  async = false
) {
  return (0, _validateNode.default)({
    type: 'ClassMethod',
    kind,
    key,
    params,
    body,
    computed: computed2,
    static: _static,
    generator,
    async,
  })
}
function objectPattern(properties) {
  return (0, _validateNode.default)({
    type: 'ObjectPattern',
    properties,
  })
}
function spreadElement$1(argument) {
  return (0, _validateNode.default)({
    type: 'SpreadElement',
    argument,
  })
}
function _super$1() {
  return {
    type: 'Super',
  }
}
function taggedTemplateExpression(tag2, quasi) {
  return (0, _validateNode.default)({
    type: 'TaggedTemplateExpression',
    tag: tag2,
    quasi,
  })
}
function templateElement(value, tail = false) {
  return (0, _validateNode.default)({
    type: 'TemplateElement',
    value,
    tail,
  })
}
function templateLiteral(quasis, expressions2) {
  return (0, _validateNode.default)({
    type: 'TemplateLiteral',
    quasis,
    expressions: expressions2,
  })
}
function yieldExpression$1(argument = null, delegate = false) {
  return (0, _validateNode.default)({
    type: 'YieldExpression',
    argument,
    delegate,
  })
}
function awaitExpression$1(argument) {
  return (0, _validateNode.default)({
    type: 'AwaitExpression',
    argument,
  })
}
function _import() {
  return {
    type: 'Import',
  }
}
function bigIntLiteral(value) {
  return (0, _validateNode.default)({
    type: 'BigIntLiteral',
    value,
  })
}
function exportNamespaceSpecifier(exported) {
  return (0, _validateNode.default)({
    type: 'ExportNamespaceSpecifier',
    exported,
  })
}
function optionalMemberExpression(object2, property, computed2 = false, optional) {
  return (0, _validateNode.default)({
    type: 'OptionalMemberExpression',
    object: object2,
    property,
    computed: computed2,
    optional,
  })
}
function optionalCallExpression(callee, _arguments, optional) {
  return (0, _validateNode.default)({
    type: 'OptionalCallExpression',
    callee,
    arguments: _arguments,
    optional,
  })
}
function classProperty(
  key,
  value = null,
  typeAnnotation2 = null,
  decorators = null,
  computed2 = false,
  _static = false
) {
  return (0, _validateNode.default)({
    type: 'ClassProperty',
    key,
    value,
    typeAnnotation: typeAnnotation2,
    decorators,
    computed: computed2,
    static: _static,
  })
}
function classAccessorProperty(
  key,
  value = null,
  typeAnnotation2 = null,
  decorators = null,
  computed2 = false,
  _static = false
) {
  return (0, _validateNode.default)({
    type: 'ClassAccessorProperty',
    key,
    value,
    typeAnnotation: typeAnnotation2,
    decorators,
    computed: computed2,
    static: _static,
  })
}
function classPrivateProperty(key, value = null, decorators = null, _static) {
  return (0, _validateNode.default)({
    type: 'ClassPrivateProperty',
    key,
    value,
    decorators,
    static: _static,
  })
}
function classPrivateMethod(kind = 'method', key, params, body, _static = false) {
  return (0, _validateNode.default)({
    type: 'ClassPrivateMethod',
    kind,
    key,
    params,
    body,
    static: _static,
  })
}
function privateName(id) {
  return (0, _validateNode.default)({
    type: 'PrivateName',
    id,
  })
}
function staticBlock(body) {
  return (0, _validateNode.default)({
    type: 'StaticBlock',
    body,
  })
}
function anyTypeAnnotation$1() {
  return {
    type: 'AnyTypeAnnotation',
  }
}
function arrayTypeAnnotation(elementType) {
  return (0, _validateNode.default)({
    type: 'ArrayTypeAnnotation',
    elementType,
  })
}
function booleanTypeAnnotation() {
  return {
    type: 'BooleanTypeAnnotation',
  }
}
function booleanLiteralTypeAnnotation(value) {
  return (0, _validateNode.default)({
    type: 'BooleanLiteralTypeAnnotation',
    value,
  })
}
function nullLiteralTypeAnnotation() {
  return {
    type: 'NullLiteralTypeAnnotation',
  }
}
function classImplements(id, typeParameters = null) {
  return (0, _validateNode.default)({
    type: 'ClassImplements',
    id,
    typeParameters,
  })
}
function declareClass(id, typeParameters = null, _extends2 = null, body) {
  return (0, _validateNode.default)({
    type: 'DeclareClass',
    id,
    typeParameters,
    extends: _extends2,
    body,
  })
}
function declareFunction(id) {
  return (0, _validateNode.default)({
    type: 'DeclareFunction',
    id,
  })
}
function declareInterface(id, typeParameters = null, _extends2 = null, body) {
  return (0, _validateNode.default)({
    type: 'DeclareInterface',
    id,
    typeParameters,
    extends: _extends2,
    body,
  })
}
function declareModule(id, body, kind = null) {
  return (0, _validateNode.default)({
    type: 'DeclareModule',
    id,
    body,
    kind,
  })
}
function declareModuleExports(typeAnnotation2) {
  return (0, _validateNode.default)({
    type: 'DeclareModuleExports',
    typeAnnotation: typeAnnotation2,
  })
}
function declareTypeAlias(id, typeParameters = null, right) {
  return (0, _validateNode.default)({
    type: 'DeclareTypeAlias',
    id,
    typeParameters,
    right,
  })
}
function declareOpaqueType(id, typeParameters = null, supertype = null) {
  return (0, _validateNode.default)({
    type: 'DeclareOpaqueType',
    id,
    typeParameters,
    supertype,
  })
}
function declareVariable(id) {
  return (0, _validateNode.default)({
    type: 'DeclareVariable',
    id,
  })
}
function declareExportDeclaration(declaration = null, specifiers = null, source = null) {
  return (0, _validateNode.default)({
    type: 'DeclareExportDeclaration',
    declaration,
    specifiers,
    source,
  })
}
function declareExportAllDeclaration(source) {
  return (0, _validateNode.default)({
    type: 'DeclareExportAllDeclaration',
    source,
  })
}
function declaredPredicate(value) {
  return (0, _validateNode.default)({
    type: 'DeclaredPredicate',
    value,
  })
}
function existsTypeAnnotation() {
  return {
    type: 'ExistsTypeAnnotation',
  }
}
function functionTypeAnnotation(typeParameters = null, params, rest = null, returnType) {
  return (0, _validateNode.default)({
    type: 'FunctionTypeAnnotation',
    typeParameters,
    params,
    rest,
    returnType,
  })
}
function functionTypeParam(name = null, typeAnnotation2) {
  return (0, _validateNode.default)({
    type: 'FunctionTypeParam',
    name,
    typeAnnotation: typeAnnotation2,
  })
}
function genericTypeAnnotation(id, typeParameters = null) {
  return (0, _validateNode.default)({
    type: 'GenericTypeAnnotation',
    id,
    typeParameters,
  })
}
function inferredPredicate() {
  return {
    type: 'InferredPredicate',
  }
}
function interfaceExtends(id, typeParameters = null) {
  return (0, _validateNode.default)({
    type: 'InterfaceExtends',
    id,
    typeParameters,
  })
}
function interfaceDeclaration(id, typeParameters = null, _extends2 = null, body) {
  return (0, _validateNode.default)({
    type: 'InterfaceDeclaration',
    id,
    typeParameters,
    extends: _extends2,
    body,
  })
}
function interfaceTypeAnnotation(_extends2 = null, body) {
  return (0, _validateNode.default)({
    type: 'InterfaceTypeAnnotation',
    extends: _extends2,
    body,
  })
}
function intersectionTypeAnnotation(types2) {
  return (0, _validateNode.default)({
    type: 'IntersectionTypeAnnotation',
    types: types2,
  })
}
function mixedTypeAnnotation() {
  return {
    type: 'MixedTypeAnnotation',
  }
}
function emptyTypeAnnotation() {
  return {
    type: 'EmptyTypeAnnotation',
  }
}
function nullableTypeAnnotation(typeAnnotation2) {
  return (0, _validateNode.default)({
    type: 'NullableTypeAnnotation',
    typeAnnotation: typeAnnotation2,
  })
}
function numberLiteralTypeAnnotation(value) {
  return (0, _validateNode.default)({
    type: 'NumberLiteralTypeAnnotation',
    value,
  })
}
function numberTypeAnnotation$1() {
  return {
    type: 'NumberTypeAnnotation',
  }
}
function objectTypeAnnotation(properties, indexers = [], callProperties = [], internalSlots = [], exact = false) {
  return (0, _validateNode.default)({
    type: 'ObjectTypeAnnotation',
    properties,
    indexers,
    callProperties,
    internalSlots,
    exact,
  })
}
function objectTypeInternalSlot(id, value, optional, _static, method) {
  return (0, _validateNode.default)({
    type: 'ObjectTypeInternalSlot',
    id,
    value,
    optional,
    static: _static,
    method,
  })
}
function objectTypeCallProperty(value) {
  return (0, _validateNode.default)({
    type: 'ObjectTypeCallProperty',
    value,
    static: null,
  })
}
function objectTypeIndexer(id = null, key, value, variance2 = null) {
  return (0, _validateNode.default)({
    type: 'ObjectTypeIndexer',
    id,
    key,
    value,
    variance: variance2,
    static: null,
  })
}
function objectTypeProperty(key, value, variance2 = null) {
  return (0, _validateNode.default)({
    type: 'ObjectTypeProperty',
    key,
    value,
    variance: variance2,
    kind: null,
    method: null,
    optional: null,
    proto: null,
    static: null,
  })
}
function objectTypeSpreadProperty(argument) {
  return (0, _validateNode.default)({
    type: 'ObjectTypeSpreadProperty',
    argument,
  })
}
function opaqueType(id, typeParameters = null, supertype = null, impltype) {
  return (0, _validateNode.default)({
    type: 'OpaqueType',
    id,
    typeParameters,
    supertype,
    impltype,
  })
}
function qualifiedTypeIdentifier(id, qualification) {
  return (0, _validateNode.default)({
    type: 'QualifiedTypeIdentifier',
    id,
    qualification,
  })
}
function stringLiteralTypeAnnotation(value) {
  return (0, _validateNode.default)({
    type: 'StringLiteralTypeAnnotation',
    value,
  })
}
function stringTypeAnnotation$1() {
  return {
    type: 'StringTypeAnnotation',
  }
}
function symbolTypeAnnotation() {
  return {
    type: 'SymbolTypeAnnotation',
  }
}
function thisTypeAnnotation() {
  return {
    type: 'ThisTypeAnnotation',
  }
}
function tupleTypeAnnotation(types2) {
  return (0, _validateNode.default)({
    type: 'TupleTypeAnnotation',
    types: types2,
  })
}
function typeofTypeAnnotation(argument) {
  return (0, _validateNode.default)({
    type: 'TypeofTypeAnnotation',
    argument,
  })
}
function typeAlias(id, typeParameters = null, right) {
  return (0, _validateNode.default)({
    type: 'TypeAlias',
    id,
    typeParameters,
    right,
  })
}
function typeAnnotation(typeAnnotation2) {
  return (0, _validateNode.default)({
    type: 'TypeAnnotation',
    typeAnnotation: typeAnnotation2,
  })
}
function typeCastExpression(expression2, typeAnnotation2) {
  return (0, _validateNode.default)({
    type: 'TypeCastExpression',
    expression: expression2,
    typeAnnotation: typeAnnotation2,
  })
}
function typeParameter(bound = null, _default2 = null, variance2 = null) {
  return (0, _validateNode.default)({
    type: 'TypeParameter',
    bound,
    default: _default2,
    variance: variance2,
    name: null,
  })
}
function typeParameterDeclaration(params) {
  return (0, _validateNode.default)({
    type: 'TypeParameterDeclaration',
    params,
  })
}
function typeParameterInstantiation(params) {
  return (0, _validateNode.default)({
    type: 'TypeParameterInstantiation',
    params,
  })
}
function unionTypeAnnotation(types2) {
  return (0, _validateNode.default)({
    type: 'UnionTypeAnnotation',
    types: types2,
  })
}
function variance(kind) {
  return (0, _validateNode.default)({
    type: 'Variance',
    kind,
  })
}
function voidTypeAnnotation$2() {
  return {
    type: 'VoidTypeAnnotation',
  }
}
function enumDeclaration(id, body) {
  return (0, _validateNode.default)({
    type: 'EnumDeclaration',
    id,
    body,
  })
}
function enumBooleanBody(members) {
  return (0, _validateNode.default)({
    type: 'EnumBooleanBody',
    members,
    explicitType: null,
    hasUnknownMembers: null,
  })
}
function enumNumberBody(members) {
  return (0, _validateNode.default)({
    type: 'EnumNumberBody',
    members,
    explicitType: null,
    hasUnknownMembers: null,
  })
}
function enumStringBody(members) {
  return (0, _validateNode.default)({
    type: 'EnumStringBody',
    members,
    explicitType: null,
    hasUnknownMembers: null,
  })
}
function enumSymbolBody(members) {
  return (0, _validateNode.default)({
    type: 'EnumSymbolBody',
    members,
    hasUnknownMembers: null,
  })
}
function enumBooleanMember(id) {
  return (0, _validateNode.default)({
    type: 'EnumBooleanMember',
    id,
    init: null,
  })
}
function enumNumberMember(id, init) {
  return (0, _validateNode.default)({
    type: 'EnumNumberMember',
    id,
    init,
  })
}
function enumStringMember(id, init) {
  return (0, _validateNode.default)({
    type: 'EnumStringMember',
    id,
    init,
  })
}
function enumDefaultedMember(id) {
  return (0, _validateNode.default)({
    type: 'EnumDefaultedMember',
    id,
  })
}
function indexedAccessType(objectType, indexType) {
  return (0, _validateNode.default)({
    type: 'IndexedAccessType',
    objectType,
    indexType,
  })
}
function optionalIndexedAccessType(objectType, indexType) {
  return (0, _validateNode.default)({
    type: 'OptionalIndexedAccessType',
    objectType,
    indexType,
    optional: null,
  })
}
function jsxAttribute(name, value = null) {
  return (0, _validateNode.default)({
    type: 'JSXAttribute',
    name,
    value,
  })
}
function jsxClosingElement(name) {
  return (0, _validateNode.default)({
    type: 'JSXClosingElement',
    name,
  })
}
function jsxElement(openingElement, closingElement = null, children, selfClosing = null) {
  return (0, _validateNode.default)({
    type: 'JSXElement',
    openingElement,
    closingElement,
    children,
    selfClosing,
  })
}
function jsxEmptyExpression() {
  return {
    type: 'JSXEmptyExpression',
  }
}
function jsxExpressionContainer$1(expression2) {
  return (0, _validateNode.default)({
    type: 'JSXExpressionContainer',
    expression: expression2,
  })
}
function jsxSpreadChild(expression2) {
  return (0, _validateNode.default)({
    type: 'JSXSpreadChild',
    expression: expression2,
  })
}
function jsxIdentifier$1(name) {
  return (0, _validateNode.default)({
    type: 'JSXIdentifier',
    name,
  })
}
function jsxMemberExpression(object2, property) {
  return (0, _validateNode.default)({
    type: 'JSXMemberExpression',
    object: object2,
    property,
  })
}
function jsxNamespacedName(namespace, name) {
  return (0, _validateNode.default)({
    type: 'JSXNamespacedName',
    namespace,
    name,
  })
}
function jsxOpeningElement(name, attributes, selfClosing = false) {
  return (0, _validateNode.default)({
    type: 'JSXOpeningElement',
    name,
    attributes,
    selfClosing,
  })
}
function jsxSpreadAttribute(argument) {
  return (0, _validateNode.default)({
    type: 'JSXSpreadAttribute',
    argument,
  })
}
function jsxText(value) {
  return (0, _validateNode.default)({
    type: 'JSXText',
    value,
  })
}
function jsxFragment(openingFragment, closingFragment, children) {
  return (0, _validateNode.default)({
    type: 'JSXFragment',
    openingFragment,
    closingFragment,
    children,
  })
}
function jsxOpeningFragment() {
  return {
    type: 'JSXOpeningFragment',
  }
}
function jsxClosingFragment() {
  return {
    type: 'JSXClosingFragment',
  }
}
function noop() {
  return {
    type: 'Noop',
  }
}
function placeholder(expectedNode, name) {
  return (0, _validateNode.default)({
    type: 'Placeholder',
    expectedNode,
    name,
  })
}
function v8IntrinsicIdentifier(name) {
  return (0, _validateNode.default)({
    type: 'V8IntrinsicIdentifier',
    name,
  })
}
function argumentPlaceholder() {
  return {
    type: 'ArgumentPlaceholder',
  }
}
function bindExpression(object2, callee) {
  return (0, _validateNode.default)({
    type: 'BindExpression',
    object: object2,
    callee,
  })
}
function importAttribute(key, value) {
  return (0, _validateNode.default)({
    type: 'ImportAttribute',
    key,
    value,
  })
}
function decorator(expression2) {
  return (0, _validateNode.default)({
    type: 'Decorator',
    expression: expression2,
  })
}
function doExpression(body, async = false) {
  return (0, _validateNode.default)({
    type: 'DoExpression',
    body,
    async,
  })
}
function exportDefaultSpecifier(exported) {
  return (0, _validateNode.default)({
    type: 'ExportDefaultSpecifier',
    exported,
  })
}
function recordExpression(properties) {
  return (0, _validateNode.default)({
    type: 'RecordExpression',
    properties,
  })
}
function tupleExpression(elements = []) {
  return (0, _validateNode.default)({
    type: 'TupleExpression',
    elements,
  })
}
function decimalLiteral(value) {
  return (0, _validateNode.default)({
    type: 'DecimalLiteral',
    value,
  })
}
function moduleExpression(body) {
  return (0, _validateNode.default)({
    type: 'ModuleExpression',
    body,
  })
}
function topicReference() {
  return {
    type: 'TopicReference',
  }
}
function pipelineTopicExpression(expression2) {
  return (0, _validateNode.default)({
    type: 'PipelineTopicExpression',
    expression: expression2,
  })
}
function pipelineBareFunction(callee) {
  return (0, _validateNode.default)({
    type: 'PipelineBareFunction',
    callee,
  })
}
function pipelinePrimaryTopicReference() {
  return {
    type: 'PipelinePrimaryTopicReference',
  }
}
function tsParameterProperty(parameter) {
  return (0, _validateNode.default)({
    type: 'TSParameterProperty',
    parameter,
  })
}
function tsDeclareFunction(id = null, typeParameters = null, params, returnType = null) {
  return (0, _validateNode.default)({
    type: 'TSDeclareFunction',
    id,
    typeParameters,
    params,
    returnType,
  })
}
function tsDeclareMethod(decorators = null, key, typeParameters = null, params, returnType = null) {
  return (0, _validateNode.default)({
    type: 'TSDeclareMethod',
    decorators,
    key,
    typeParameters,
    params,
    returnType,
  })
}
function tsQualifiedName(left, right) {
  return (0, _validateNode.default)({
    type: 'TSQualifiedName',
    left,
    right,
  })
}
function tsCallSignatureDeclaration(typeParameters = null, parameters, typeAnnotation2 = null) {
  return (0, _validateNode.default)({
    type: 'TSCallSignatureDeclaration',
    typeParameters,
    parameters,
    typeAnnotation: typeAnnotation2,
  })
}
function tsConstructSignatureDeclaration(typeParameters = null, parameters, typeAnnotation2 = null) {
  return (0, _validateNode.default)({
    type: 'TSConstructSignatureDeclaration',
    typeParameters,
    parameters,
    typeAnnotation: typeAnnotation2,
  })
}
function tsPropertySignature(key, typeAnnotation2 = null, initializer = null) {
  return (0, _validateNode.default)({
    type: 'TSPropertySignature',
    key,
    typeAnnotation: typeAnnotation2,
    initializer,
    kind: null,
  })
}
function tsMethodSignature(key, typeParameters = null, parameters, typeAnnotation2 = null) {
  return (0, _validateNode.default)({
    type: 'TSMethodSignature',
    key,
    typeParameters,
    parameters,
    typeAnnotation: typeAnnotation2,
    kind: null,
  })
}
function tsIndexSignature(parameters, typeAnnotation2 = null) {
  return (0, _validateNode.default)({
    type: 'TSIndexSignature',
    parameters,
    typeAnnotation: typeAnnotation2,
  })
}
function tsAnyKeyword() {
  return {
    type: 'TSAnyKeyword',
  }
}
function tsBooleanKeyword() {
  return {
    type: 'TSBooleanKeyword',
  }
}
function tsBigIntKeyword() {
  return {
    type: 'TSBigIntKeyword',
  }
}
function tsIntrinsicKeyword() {
  return {
    type: 'TSIntrinsicKeyword',
  }
}
function tsNeverKeyword() {
  return {
    type: 'TSNeverKeyword',
  }
}
function tsNullKeyword() {
  return {
    type: 'TSNullKeyword',
  }
}
function tsNumberKeyword() {
  return {
    type: 'TSNumberKeyword',
  }
}
function tsObjectKeyword() {
  return {
    type: 'TSObjectKeyword',
  }
}
function tsStringKeyword() {
  return {
    type: 'TSStringKeyword',
  }
}
function tsSymbolKeyword() {
  return {
    type: 'TSSymbolKeyword',
  }
}
function tsUndefinedKeyword() {
  return {
    type: 'TSUndefinedKeyword',
  }
}
function tsUnknownKeyword() {
  return {
    type: 'TSUnknownKeyword',
  }
}
function tsVoidKeyword() {
  return {
    type: 'TSVoidKeyword',
  }
}
function tsThisType() {
  return {
    type: 'TSThisType',
  }
}
function tsFunctionType(typeParameters = null, parameters, typeAnnotation2 = null) {
  return (0, _validateNode.default)({
    type: 'TSFunctionType',
    typeParameters,
    parameters,
    typeAnnotation: typeAnnotation2,
  })
}
function tsConstructorType(typeParameters = null, parameters, typeAnnotation2 = null) {
  return (0, _validateNode.default)({
    type: 'TSConstructorType',
    typeParameters,
    parameters,
    typeAnnotation: typeAnnotation2,
  })
}
function tsTypeReference(typeName, typeParameters = null) {
  return (0, _validateNode.default)({
    type: 'TSTypeReference',
    typeName,
    typeParameters,
  })
}
function tsTypePredicate(parameterName, typeAnnotation2 = null, asserts = null) {
  return (0, _validateNode.default)({
    type: 'TSTypePredicate',
    parameterName,
    typeAnnotation: typeAnnotation2,
    asserts,
  })
}
function tsTypeQuery(exprName, typeParameters = null) {
  return (0, _validateNode.default)({
    type: 'TSTypeQuery',
    exprName,
    typeParameters,
  })
}
function tsTypeLiteral(members) {
  return (0, _validateNode.default)({
    type: 'TSTypeLiteral',
    members,
  })
}
function tsArrayType(elementType) {
  return (0, _validateNode.default)({
    type: 'TSArrayType',
    elementType,
  })
}
function tsTupleType(elementTypes) {
  return (0, _validateNode.default)({
    type: 'TSTupleType',
    elementTypes,
  })
}
function tsOptionalType(typeAnnotation2) {
  return (0, _validateNode.default)({
    type: 'TSOptionalType',
    typeAnnotation: typeAnnotation2,
  })
}
function tsRestType(typeAnnotation2) {
  return (0, _validateNode.default)({
    type: 'TSRestType',
    typeAnnotation: typeAnnotation2,
  })
}
function tsNamedTupleMember(label, elementType, optional = false) {
  return (0, _validateNode.default)({
    type: 'TSNamedTupleMember',
    label,
    elementType,
    optional,
  })
}
function tsUnionType(types2) {
  return (0, _validateNode.default)({
    type: 'TSUnionType',
    types: types2,
  })
}
function tsIntersectionType(types2) {
  return (0, _validateNode.default)({
    type: 'TSIntersectionType',
    types: types2,
  })
}
function tsConditionalType(checkType, extendsType, trueType, falseType) {
  return (0, _validateNode.default)({
    type: 'TSConditionalType',
    checkType,
    extendsType,
    trueType,
    falseType,
  })
}
function tsInferType(typeParameter2) {
  return (0, _validateNode.default)({
    type: 'TSInferType',
    typeParameter: typeParameter2,
  })
}
function tsParenthesizedType(typeAnnotation2) {
  return (0, _validateNode.default)({
    type: 'TSParenthesizedType',
    typeAnnotation: typeAnnotation2,
  })
}
function tsTypeOperator(typeAnnotation2) {
  return (0, _validateNode.default)({
    type: 'TSTypeOperator',
    typeAnnotation: typeAnnotation2,
    operator: null,
  })
}
function tsIndexedAccessType(objectType, indexType) {
  return (0, _validateNode.default)({
    type: 'TSIndexedAccessType',
    objectType,
    indexType,
  })
}
function tsMappedType(typeParameter2, typeAnnotation2 = null, nameType = null) {
  return (0, _validateNode.default)({
    type: 'TSMappedType',
    typeParameter: typeParameter2,
    typeAnnotation: typeAnnotation2,
    nameType,
  })
}
function tsLiteralType(literal2) {
  return (0, _validateNode.default)({
    type: 'TSLiteralType',
    literal: literal2,
  })
}
function tsExpressionWithTypeArguments(expression2, typeParameters = null) {
  return (0, _validateNode.default)({
    type: 'TSExpressionWithTypeArguments',
    expression: expression2,
    typeParameters,
  })
}
function tsInterfaceDeclaration(id, typeParameters = null, _extends2 = null, body) {
  return (0, _validateNode.default)({
    type: 'TSInterfaceDeclaration',
    id,
    typeParameters,
    extends: _extends2,
    body,
  })
}
function tsInterfaceBody(body) {
  return (0, _validateNode.default)({
    type: 'TSInterfaceBody',
    body,
  })
}
function tsTypeAliasDeclaration(id, typeParameters = null, typeAnnotation2) {
  return (0, _validateNode.default)({
    type: 'TSTypeAliasDeclaration',
    id,
    typeParameters,
    typeAnnotation: typeAnnotation2,
  })
}
function tsInstantiationExpression(expression2, typeParameters = null) {
  return (0, _validateNode.default)({
    type: 'TSInstantiationExpression',
    expression: expression2,
    typeParameters,
  })
}
function tsAsExpression(expression2, typeAnnotation2) {
  return (0, _validateNode.default)({
    type: 'TSAsExpression',
    expression: expression2,
    typeAnnotation: typeAnnotation2,
  })
}
function tsTypeAssertion(typeAnnotation2, expression2) {
  return (0, _validateNode.default)({
    type: 'TSTypeAssertion',
    typeAnnotation: typeAnnotation2,
    expression: expression2,
  })
}
function tsEnumDeclaration(id, members) {
  return (0, _validateNode.default)({
    type: 'TSEnumDeclaration',
    id,
    members,
  })
}
function tsEnumMember(id, initializer = null) {
  return (0, _validateNode.default)({
    type: 'TSEnumMember',
    id,
    initializer,
  })
}
function tsModuleDeclaration(id, body) {
  return (0, _validateNode.default)({
    type: 'TSModuleDeclaration',
    id,
    body,
  })
}
function tsModuleBlock(body) {
  return (0, _validateNode.default)({
    type: 'TSModuleBlock',
    body,
  })
}
function tsImportType(argument, qualifier = null, typeParameters = null) {
  return (0, _validateNode.default)({
    type: 'TSImportType',
    argument,
    qualifier,
    typeParameters,
  })
}
function tsImportEqualsDeclaration(id, moduleReference) {
  return (0, _validateNode.default)({
    type: 'TSImportEqualsDeclaration',
    id,
    moduleReference,
    isExport: null,
  })
}
function tsExternalModuleReference(expression2) {
  return (0, _validateNode.default)({
    type: 'TSExternalModuleReference',
    expression: expression2,
  })
}
function tsNonNullExpression(expression2) {
  return (0, _validateNode.default)({
    type: 'TSNonNullExpression',
    expression: expression2,
  })
}
function tsExportAssignment(expression2) {
  return (0, _validateNode.default)({
    type: 'TSExportAssignment',
    expression: expression2,
  })
}
function tsNamespaceExportDeclaration(id) {
  return (0, _validateNode.default)({
    type: 'TSNamespaceExportDeclaration',
    id,
  })
}
function tsTypeAnnotation(typeAnnotation2) {
  return (0, _validateNode.default)({
    type: 'TSTypeAnnotation',
    typeAnnotation: typeAnnotation2,
  })
}
function tsTypeParameterInstantiation(params) {
  return (0, _validateNode.default)({
    type: 'TSTypeParameterInstantiation',
    params,
  })
}
function tsTypeParameterDeclaration(params) {
  return (0, _validateNode.default)({
    type: 'TSTypeParameterDeclaration',
    params,
  })
}
function tsTypeParameter(constraint = null, _default2 = null, name) {
  return (0, _validateNode.default)({
    type: 'TSTypeParameter',
    constraint,
    default: _default2,
    name,
  })
}
function NumberLiteral(value) {
  console.trace('The node type NumberLiteral has been renamed to NumericLiteral')
  return numericLiteral$3(value)
}
function RegexLiteral(pattern, flags = '') {
  console.trace('The node type RegexLiteral has been renamed to RegExpLiteral')
  return regExpLiteral(pattern, flags)
}
function RestProperty$1(argument) {
  console.trace('The node type RestProperty has been renamed to RestElement')
  return restElement$1(argument)
}
function SpreadProperty$1(argument) {
  console.trace('The node type SpreadProperty has been renamed to SpreadElement')
  return spreadElement$1(argument)
}
Object.defineProperty(cleanJSXElementLiteralChild$1, '__esModule', {
  value: true,
})
cleanJSXElementLiteralChild$1.default = cleanJSXElementLiteralChild
var _generated$n = generated$3
function cleanJSXElementLiteralChild(child, args) {
  const lines = child.value.split(/\r\n|\n|\r/)
  let lastNonEmptyLine = 0
  for (let i = 0; i < lines.length; i++) {
    if (lines[i].match(/[^ \t]/)) {
      lastNonEmptyLine = i
    }
  }
  let str = ''
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i]
    const isFirstLine = i === 0
    const isLastLine = i === lines.length - 1
    const isLastNonEmptyLine = i === lastNonEmptyLine
    let trimmedLine = line.replace(/\t/g, ' ')
    if (!isFirstLine) {
      trimmedLine = trimmedLine.replace(/^[ ]+/, '')
    }
    if (!isLastLine) {
      trimmedLine = trimmedLine.replace(/[ ]+$/, '')
    }
    if (trimmedLine) {
      if (!isLastNonEmptyLine) {
        trimmedLine += ' '
      }
      str += trimmedLine
    }
  }
  if (str) args.push((0, _generated$n.stringLiteral)(str))
}
Object.defineProperty(buildChildren$1, '__esModule', {
  value: true,
})
buildChildren$1.default = buildChildren
var _generated$m = generated$4
var _cleanJSXElementLiteralChild = cleanJSXElementLiteralChild$1
function buildChildren(node2) {
  const elements = []
  for (let i = 0; i < node2.children.length; i++) {
    let child = node2.children[i]
    if ((0, _generated$m.isJSXText)(child)) {
      ;(0, _cleanJSXElementLiteralChild.default)(child, elements)
      continue
    }
    if ((0, _generated$m.isJSXExpressionContainer)(child)) child = child.expression
    if ((0, _generated$m.isJSXEmptyExpression)(child)) continue
    elements.push(child)
  }
  return elements
}
var assertNode$1 = {}
var isNode$1 = {}
Object.defineProperty(isNode$1, '__esModule', {
  value: true,
})
isNode$1.default = isNode
var _definitions$5 = definitions
function isNode(node2) {
  return !!(node2 && _definitions$5.VISITOR_KEYS[node2.type])
}
Object.defineProperty(assertNode$1, '__esModule', {
  value: true,
})
assertNode$1.default = assertNode
var _isNode = isNode$1
function assertNode(node2) {
  if (!(0, _isNode.default)(node2)) {
    var _node$type
    const type = (_node$type = node2 == null ? void 0 : node2.type) != null ? _node$type : JSON.stringify(node2)
    throw new TypeError(`Not a valid node of type "${type}"`)
  }
}
var generated$2 = {}
Object.defineProperty(generated$2, '__esModule', {
  value: true,
})
generated$2.assertAccessor = assertAccessor
generated$2.assertAnyTypeAnnotation = assertAnyTypeAnnotation
generated$2.assertArgumentPlaceholder = assertArgumentPlaceholder
generated$2.assertArrayExpression = assertArrayExpression
generated$2.assertArrayPattern = assertArrayPattern
generated$2.assertArrayTypeAnnotation = assertArrayTypeAnnotation
generated$2.assertArrowFunctionExpression = assertArrowFunctionExpression
generated$2.assertAssignmentExpression = assertAssignmentExpression
generated$2.assertAssignmentPattern = assertAssignmentPattern
generated$2.assertAwaitExpression = assertAwaitExpression
generated$2.assertBigIntLiteral = assertBigIntLiteral
generated$2.assertBinary = assertBinary
generated$2.assertBinaryExpression = assertBinaryExpression
generated$2.assertBindExpression = assertBindExpression
generated$2.assertBlock = assertBlock
generated$2.assertBlockParent = assertBlockParent
generated$2.assertBlockStatement = assertBlockStatement
generated$2.assertBooleanLiteral = assertBooleanLiteral
generated$2.assertBooleanLiteralTypeAnnotation = assertBooleanLiteralTypeAnnotation
generated$2.assertBooleanTypeAnnotation = assertBooleanTypeAnnotation
generated$2.assertBreakStatement = assertBreakStatement
generated$2.assertCallExpression = assertCallExpression
generated$2.assertCatchClause = assertCatchClause
generated$2.assertClass = assertClass
generated$2.assertClassAccessorProperty = assertClassAccessorProperty
generated$2.assertClassBody = assertClassBody
generated$2.assertClassDeclaration = assertClassDeclaration
generated$2.assertClassExpression = assertClassExpression
generated$2.assertClassImplements = assertClassImplements
generated$2.assertClassMethod = assertClassMethod
generated$2.assertClassPrivateMethod = assertClassPrivateMethod
generated$2.assertClassPrivateProperty = assertClassPrivateProperty
generated$2.assertClassProperty = assertClassProperty
generated$2.assertCompletionStatement = assertCompletionStatement
generated$2.assertConditional = assertConditional
generated$2.assertConditionalExpression = assertConditionalExpression
generated$2.assertContinueStatement = assertContinueStatement
generated$2.assertDebuggerStatement = assertDebuggerStatement
generated$2.assertDecimalLiteral = assertDecimalLiteral
generated$2.assertDeclaration = assertDeclaration
generated$2.assertDeclareClass = assertDeclareClass
generated$2.assertDeclareExportAllDeclaration = assertDeclareExportAllDeclaration
generated$2.assertDeclareExportDeclaration = assertDeclareExportDeclaration
generated$2.assertDeclareFunction = assertDeclareFunction
generated$2.assertDeclareInterface = assertDeclareInterface
generated$2.assertDeclareModule = assertDeclareModule
generated$2.assertDeclareModuleExports = assertDeclareModuleExports
generated$2.assertDeclareOpaqueType = assertDeclareOpaqueType
generated$2.assertDeclareTypeAlias = assertDeclareTypeAlias
generated$2.assertDeclareVariable = assertDeclareVariable
generated$2.assertDeclaredPredicate = assertDeclaredPredicate
generated$2.assertDecorator = assertDecorator
generated$2.assertDirective = assertDirective
generated$2.assertDirectiveLiteral = assertDirectiveLiteral
generated$2.assertDoExpression = assertDoExpression
generated$2.assertDoWhileStatement = assertDoWhileStatement
generated$2.assertEmptyStatement = assertEmptyStatement
generated$2.assertEmptyTypeAnnotation = assertEmptyTypeAnnotation
generated$2.assertEnumBody = assertEnumBody
generated$2.assertEnumBooleanBody = assertEnumBooleanBody
generated$2.assertEnumBooleanMember = assertEnumBooleanMember
generated$2.assertEnumDeclaration = assertEnumDeclaration
generated$2.assertEnumDefaultedMember = assertEnumDefaultedMember
generated$2.assertEnumMember = assertEnumMember
generated$2.assertEnumNumberBody = assertEnumNumberBody
generated$2.assertEnumNumberMember = assertEnumNumberMember
generated$2.assertEnumStringBody = assertEnumStringBody
generated$2.assertEnumStringMember = assertEnumStringMember
generated$2.assertEnumSymbolBody = assertEnumSymbolBody
generated$2.assertExistsTypeAnnotation = assertExistsTypeAnnotation
generated$2.assertExportAllDeclaration = assertExportAllDeclaration
generated$2.assertExportDeclaration = assertExportDeclaration
generated$2.assertExportDefaultDeclaration = assertExportDefaultDeclaration
generated$2.assertExportDefaultSpecifier = assertExportDefaultSpecifier
generated$2.assertExportNamedDeclaration = assertExportNamedDeclaration
generated$2.assertExportNamespaceSpecifier = assertExportNamespaceSpecifier
generated$2.assertExportSpecifier = assertExportSpecifier
generated$2.assertExpression = assertExpression$1
generated$2.assertExpressionStatement = assertExpressionStatement$1
generated$2.assertExpressionWrapper = assertExpressionWrapper
generated$2.assertFile = assertFile
generated$2.assertFlow = assertFlow
generated$2.assertFlowBaseAnnotation = assertFlowBaseAnnotation
generated$2.assertFlowDeclaration = assertFlowDeclaration
generated$2.assertFlowPredicate = assertFlowPredicate
generated$2.assertFlowType = assertFlowType
generated$2.assertFor = assertFor
generated$2.assertForInStatement = assertForInStatement
generated$2.assertForOfStatement = assertForOfStatement
generated$2.assertForStatement = assertForStatement
generated$2.assertForXStatement = assertForXStatement
generated$2.assertFunction = assertFunction
generated$2.assertFunctionDeclaration = assertFunctionDeclaration
generated$2.assertFunctionExpression = assertFunctionExpression
generated$2.assertFunctionParent = assertFunctionParent
generated$2.assertFunctionTypeAnnotation = assertFunctionTypeAnnotation
generated$2.assertFunctionTypeParam = assertFunctionTypeParam
generated$2.assertGenericTypeAnnotation = assertGenericTypeAnnotation
generated$2.assertIdentifier = assertIdentifier
generated$2.assertIfStatement = assertIfStatement
generated$2.assertImmutable = assertImmutable
generated$2.assertImport = assertImport
generated$2.assertImportAttribute = assertImportAttribute
generated$2.assertImportDeclaration = assertImportDeclaration
generated$2.assertImportDefaultSpecifier = assertImportDefaultSpecifier
generated$2.assertImportNamespaceSpecifier = assertImportNamespaceSpecifier
generated$2.assertImportSpecifier = assertImportSpecifier
generated$2.assertIndexedAccessType = assertIndexedAccessType
generated$2.assertInferredPredicate = assertInferredPredicate
generated$2.assertInterfaceDeclaration = assertInterfaceDeclaration
generated$2.assertInterfaceExtends = assertInterfaceExtends
generated$2.assertInterfaceTypeAnnotation = assertInterfaceTypeAnnotation
generated$2.assertInterpreterDirective = assertInterpreterDirective
generated$2.assertIntersectionTypeAnnotation = assertIntersectionTypeAnnotation
generated$2.assertJSX = assertJSX
generated$2.assertJSXAttribute = assertJSXAttribute
generated$2.assertJSXClosingElement = assertJSXClosingElement
generated$2.assertJSXClosingFragment = assertJSXClosingFragment
generated$2.assertJSXElement = assertJSXElement
generated$2.assertJSXEmptyExpression = assertJSXEmptyExpression
generated$2.assertJSXExpressionContainer = assertJSXExpressionContainer
generated$2.assertJSXFragment = assertJSXFragment
generated$2.assertJSXIdentifier = assertJSXIdentifier
generated$2.assertJSXMemberExpression = assertJSXMemberExpression
generated$2.assertJSXNamespacedName = assertJSXNamespacedName
generated$2.assertJSXOpeningElement = assertJSXOpeningElement
generated$2.assertJSXOpeningFragment = assertJSXOpeningFragment
generated$2.assertJSXSpreadAttribute = assertJSXSpreadAttribute
generated$2.assertJSXSpreadChild = assertJSXSpreadChild
generated$2.assertJSXText = assertJSXText
generated$2.assertLVal = assertLVal
generated$2.assertLabeledStatement = assertLabeledStatement
generated$2.assertLiteral = assertLiteral
generated$2.assertLogicalExpression = assertLogicalExpression
generated$2.assertLoop = assertLoop
generated$2.assertMemberExpression = assertMemberExpression
generated$2.assertMetaProperty = assertMetaProperty
generated$2.assertMethod = assertMethod
generated$2.assertMiscellaneous = assertMiscellaneous
generated$2.assertMixedTypeAnnotation = assertMixedTypeAnnotation
generated$2.assertModuleDeclaration = assertModuleDeclaration
generated$2.assertModuleExpression = assertModuleExpression
generated$2.assertModuleSpecifier = assertModuleSpecifier
generated$2.assertNewExpression = assertNewExpression
generated$2.assertNoop = assertNoop
generated$2.assertNullLiteral = assertNullLiteral
generated$2.assertNullLiteralTypeAnnotation = assertNullLiteralTypeAnnotation
generated$2.assertNullableTypeAnnotation = assertNullableTypeAnnotation
generated$2.assertNumberLiteral = assertNumberLiteral
generated$2.assertNumberLiteralTypeAnnotation = assertNumberLiteralTypeAnnotation
generated$2.assertNumberTypeAnnotation = assertNumberTypeAnnotation
generated$2.assertNumericLiteral = assertNumericLiteral
generated$2.assertObjectExpression = assertObjectExpression
generated$2.assertObjectMember = assertObjectMember
generated$2.assertObjectMethod = assertObjectMethod
generated$2.assertObjectPattern = assertObjectPattern
generated$2.assertObjectProperty = assertObjectProperty
generated$2.assertObjectTypeAnnotation = assertObjectTypeAnnotation
generated$2.assertObjectTypeCallProperty = assertObjectTypeCallProperty
generated$2.assertObjectTypeIndexer = assertObjectTypeIndexer
generated$2.assertObjectTypeInternalSlot = assertObjectTypeInternalSlot
generated$2.assertObjectTypeProperty = assertObjectTypeProperty
generated$2.assertObjectTypeSpreadProperty = assertObjectTypeSpreadProperty
generated$2.assertOpaqueType = assertOpaqueType
generated$2.assertOptionalCallExpression = assertOptionalCallExpression
generated$2.assertOptionalIndexedAccessType = assertOptionalIndexedAccessType
generated$2.assertOptionalMemberExpression = assertOptionalMemberExpression
generated$2.assertParenthesizedExpression = assertParenthesizedExpression
generated$2.assertPattern = assertPattern
generated$2.assertPatternLike = assertPatternLike
generated$2.assertPipelineBareFunction = assertPipelineBareFunction
generated$2.assertPipelinePrimaryTopicReference = assertPipelinePrimaryTopicReference
generated$2.assertPipelineTopicExpression = assertPipelineTopicExpression
generated$2.assertPlaceholder = assertPlaceholder
generated$2.assertPrivate = assertPrivate
generated$2.assertPrivateName = assertPrivateName
generated$2.assertProgram = assertProgram
generated$2.assertProperty = assertProperty
generated$2.assertPureish = assertPureish
generated$2.assertQualifiedTypeIdentifier = assertQualifiedTypeIdentifier
generated$2.assertRecordExpression = assertRecordExpression
generated$2.assertRegExpLiteral = assertRegExpLiteral
generated$2.assertRegexLiteral = assertRegexLiteral
generated$2.assertRestElement = assertRestElement
generated$2.assertRestProperty = assertRestProperty
generated$2.assertReturnStatement = assertReturnStatement
generated$2.assertScopable = assertScopable
generated$2.assertSequenceExpression = assertSequenceExpression
generated$2.assertSpreadElement = assertSpreadElement
generated$2.assertSpreadProperty = assertSpreadProperty
generated$2.assertStandardized = assertStandardized
generated$2.assertStatement = assertStatement
generated$2.assertStaticBlock = assertStaticBlock
generated$2.assertStringLiteral = assertStringLiteral
generated$2.assertStringLiteralTypeAnnotation = assertStringLiteralTypeAnnotation
generated$2.assertStringTypeAnnotation = assertStringTypeAnnotation
generated$2.assertSuper = assertSuper
generated$2.assertSwitchCase = assertSwitchCase
generated$2.assertSwitchStatement = assertSwitchStatement
generated$2.assertSymbolTypeAnnotation = assertSymbolTypeAnnotation
generated$2.assertTSAnyKeyword = assertTSAnyKeyword
generated$2.assertTSArrayType = assertTSArrayType
generated$2.assertTSAsExpression = assertTSAsExpression
generated$2.assertTSBaseType = assertTSBaseType
generated$2.assertTSBigIntKeyword = assertTSBigIntKeyword
generated$2.assertTSBooleanKeyword = assertTSBooleanKeyword
generated$2.assertTSCallSignatureDeclaration = assertTSCallSignatureDeclaration
generated$2.assertTSConditionalType = assertTSConditionalType
generated$2.assertTSConstructSignatureDeclaration = assertTSConstructSignatureDeclaration
generated$2.assertTSConstructorType = assertTSConstructorType
generated$2.assertTSDeclareFunction = assertTSDeclareFunction
generated$2.assertTSDeclareMethod = assertTSDeclareMethod
generated$2.assertTSEntityName = assertTSEntityName
generated$2.assertTSEnumDeclaration = assertTSEnumDeclaration
generated$2.assertTSEnumMember = assertTSEnumMember
generated$2.assertTSExportAssignment = assertTSExportAssignment
generated$2.assertTSExpressionWithTypeArguments = assertTSExpressionWithTypeArguments
generated$2.assertTSExternalModuleReference = assertTSExternalModuleReference
generated$2.assertTSFunctionType = assertTSFunctionType
generated$2.assertTSImportEqualsDeclaration = assertTSImportEqualsDeclaration
generated$2.assertTSImportType = assertTSImportType
generated$2.assertTSIndexSignature = assertTSIndexSignature
generated$2.assertTSIndexedAccessType = assertTSIndexedAccessType
generated$2.assertTSInferType = assertTSInferType
generated$2.assertTSInstantiationExpression = assertTSInstantiationExpression
generated$2.assertTSInterfaceBody = assertTSInterfaceBody
generated$2.assertTSInterfaceDeclaration = assertTSInterfaceDeclaration
generated$2.assertTSIntersectionType = assertTSIntersectionType
generated$2.assertTSIntrinsicKeyword = assertTSIntrinsicKeyword
generated$2.assertTSLiteralType = assertTSLiteralType
generated$2.assertTSMappedType = assertTSMappedType
generated$2.assertTSMethodSignature = assertTSMethodSignature
generated$2.assertTSModuleBlock = assertTSModuleBlock
generated$2.assertTSModuleDeclaration = assertTSModuleDeclaration
generated$2.assertTSNamedTupleMember = assertTSNamedTupleMember
generated$2.assertTSNamespaceExportDeclaration = assertTSNamespaceExportDeclaration
generated$2.assertTSNeverKeyword = assertTSNeverKeyword
generated$2.assertTSNonNullExpression = assertTSNonNullExpression
generated$2.assertTSNullKeyword = assertTSNullKeyword
generated$2.assertTSNumberKeyword = assertTSNumberKeyword
generated$2.assertTSObjectKeyword = assertTSObjectKeyword
generated$2.assertTSOptionalType = assertTSOptionalType
generated$2.assertTSParameterProperty = assertTSParameterProperty
generated$2.assertTSParenthesizedType = assertTSParenthesizedType
generated$2.assertTSPropertySignature = assertTSPropertySignature
generated$2.assertTSQualifiedName = assertTSQualifiedName
generated$2.assertTSRestType = assertTSRestType
generated$2.assertTSStringKeyword = assertTSStringKeyword
generated$2.assertTSSymbolKeyword = assertTSSymbolKeyword
generated$2.assertTSThisType = assertTSThisType
generated$2.assertTSTupleType = assertTSTupleType
generated$2.assertTSType = assertTSType
generated$2.assertTSTypeAliasDeclaration = assertTSTypeAliasDeclaration
generated$2.assertTSTypeAnnotation = assertTSTypeAnnotation
generated$2.assertTSTypeAssertion = assertTSTypeAssertion
generated$2.assertTSTypeElement = assertTSTypeElement
generated$2.assertTSTypeLiteral = assertTSTypeLiteral
generated$2.assertTSTypeOperator = assertTSTypeOperator
generated$2.assertTSTypeParameter = assertTSTypeParameter
generated$2.assertTSTypeParameterDeclaration = assertTSTypeParameterDeclaration
generated$2.assertTSTypeParameterInstantiation = assertTSTypeParameterInstantiation
generated$2.assertTSTypePredicate = assertTSTypePredicate
generated$2.assertTSTypeQuery = assertTSTypeQuery
generated$2.assertTSTypeReference = assertTSTypeReference
generated$2.assertTSUndefinedKeyword = assertTSUndefinedKeyword
generated$2.assertTSUnionType = assertTSUnionType
generated$2.assertTSUnknownKeyword = assertTSUnknownKeyword
generated$2.assertTSVoidKeyword = assertTSVoidKeyword
generated$2.assertTaggedTemplateExpression = assertTaggedTemplateExpression
generated$2.assertTemplateElement = assertTemplateElement
generated$2.assertTemplateLiteral = assertTemplateLiteral
generated$2.assertTerminatorless = assertTerminatorless
generated$2.assertThisExpression = assertThisExpression
generated$2.assertThisTypeAnnotation = assertThisTypeAnnotation
generated$2.assertThrowStatement = assertThrowStatement
generated$2.assertTopicReference = assertTopicReference
generated$2.assertTryStatement = assertTryStatement
generated$2.assertTupleExpression = assertTupleExpression
generated$2.assertTupleTypeAnnotation = assertTupleTypeAnnotation
generated$2.assertTypeAlias = assertTypeAlias
generated$2.assertTypeAnnotation = assertTypeAnnotation
generated$2.assertTypeCastExpression = assertTypeCastExpression
generated$2.assertTypeParameter = assertTypeParameter
generated$2.assertTypeParameterDeclaration = assertTypeParameterDeclaration
generated$2.assertTypeParameterInstantiation = assertTypeParameterInstantiation
generated$2.assertTypeScript = assertTypeScript
generated$2.assertTypeofTypeAnnotation = assertTypeofTypeAnnotation
generated$2.assertUnaryExpression = assertUnaryExpression
generated$2.assertUnaryLike = assertUnaryLike
generated$2.assertUnionTypeAnnotation = assertUnionTypeAnnotation
generated$2.assertUpdateExpression = assertUpdateExpression
generated$2.assertUserWhitespacable = assertUserWhitespacable
generated$2.assertV8IntrinsicIdentifier = assertV8IntrinsicIdentifier
generated$2.assertVariableDeclaration = assertVariableDeclaration
generated$2.assertVariableDeclarator = assertVariableDeclarator
generated$2.assertVariance = assertVariance
generated$2.assertVoidTypeAnnotation = assertVoidTypeAnnotation
generated$2.assertWhile = assertWhile
generated$2.assertWhileStatement = assertWhileStatement
generated$2.assertWithStatement = assertWithStatement
generated$2.assertYieldExpression = assertYieldExpression
var _is = is$2
function assert$2(type, node2, opts) {
  if (!(0, _is.default)(type, node2, opts)) {
    throw new Error(`Expected type "${type}" with option ${JSON.stringify(opts)}, but instead got "${node2.type}".`)
  }
}
function assertArrayExpression(node2, opts) {
  assert$2('ArrayExpression', node2, opts)
}
function assertAssignmentExpression(node2, opts) {
  assert$2('AssignmentExpression', node2, opts)
}
function assertBinaryExpression(node2, opts) {
  assert$2('BinaryExpression', node2, opts)
}
function assertInterpreterDirective(node2, opts) {
  assert$2('InterpreterDirective', node2, opts)
}
function assertDirective(node2, opts) {
  assert$2('Directive', node2, opts)
}
function assertDirectiveLiteral(node2, opts) {
  assert$2('DirectiveLiteral', node2, opts)
}
function assertBlockStatement(node2, opts) {
  assert$2('BlockStatement', node2, opts)
}
function assertBreakStatement(node2, opts) {
  assert$2('BreakStatement', node2, opts)
}
function assertCallExpression(node2, opts) {
  assert$2('CallExpression', node2, opts)
}
function assertCatchClause(node2, opts) {
  assert$2('CatchClause', node2, opts)
}
function assertConditionalExpression(node2, opts) {
  assert$2('ConditionalExpression', node2, opts)
}
function assertContinueStatement(node2, opts) {
  assert$2('ContinueStatement', node2, opts)
}
function assertDebuggerStatement(node2, opts) {
  assert$2('DebuggerStatement', node2, opts)
}
function assertDoWhileStatement(node2, opts) {
  assert$2('DoWhileStatement', node2, opts)
}
function assertEmptyStatement(node2, opts) {
  assert$2('EmptyStatement', node2, opts)
}
function assertExpressionStatement$1(node2, opts) {
  assert$2('ExpressionStatement', node2, opts)
}
function assertFile(node2, opts) {
  assert$2('File', node2, opts)
}
function assertForInStatement(node2, opts) {
  assert$2('ForInStatement', node2, opts)
}
function assertForStatement(node2, opts) {
  assert$2('ForStatement', node2, opts)
}
function assertFunctionDeclaration(node2, opts) {
  assert$2('FunctionDeclaration', node2, opts)
}
function assertFunctionExpression(node2, opts) {
  assert$2('FunctionExpression', node2, opts)
}
function assertIdentifier(node2, opts) {
  assert$2('Identifier', node2, opts)
}
function assertIfStatement(node2, opts) {
  assert$2('IfStatement', node2, opts)
}
function assertLabeledStatement(node2, opts) {
  assert$2('LabeledStatement', node2, opts)
}
function assertStringLiteral(node2, opts) {
  assert$2('StringLiteral', node2, opts)
}
function assertNumericLiteral(node2, opts) {
  assert$2('NumericLiteral', node2, opts)
}
function assertNullLiteral(node2, opts) {
  assert$2('NullLiteral', node2, opts)
}
function assertBooleanLiteral(node2, opts) {
  assert$2('BooleanLiteral', node2, opts)
}
function assertRegExpLiteral(node2, opts) {
  assert$2('RegExpLiteral', node2, opts)
}
function assertLogicalExpression(node2, opts) {
  assert$2('LogicalExpression', node2, opts)
}
function assertMemberExpression(node2, opts) {
  assert$2('MemberExpression', node2, opts)
}
function assertNewExpression(node2, opts) {
  assert$2('NewExpression', node2, opts)
}
function assertProgram(node2, opts) {
  assert$2('Program', node2, opts)
}
function assertObjectExpression(node2, opts) {
  assert$2('ObjectExpression', node2, opts)
}
function assertObjectMethod(node2, opts) {
  assert$2('ObjectMethod', node2, opts)
}
function assertObjectProperty(node2, opts) {
  assert$2('ObjectProperty', node2, opts)
}
function assertRestElement(node2, opts) {
  assert$2('RestElement', node2, opts)
}
function assertReturnStatement(node2, opts) {
  assert$2('ReturnStatement', node2, opts)
}
function assertSequenceExpression(node2, opts) {
  assert$2('SequenceExpression', node2, opts)
}
function assertParenthesizedExpression(node2, opts) {
  assert$2('ParenthesizedExpression', node2, opts)
}
function assertSwitchCase(node2, opts) {
  assert$2('SwitchCase', node2, opts)
}
function assertSwitchStatement(node2, opts) {
  assert$2('SwitchStatement', node2, opts)
}
function assertThisExpression(node2, opts) {
  assert$2('ThisExpression', node2, opts)
}
function assertThrowStatement(node2, opts) {
  assert$2('ThrowStatement', node2, opts)
}
function assertTryStatement(node2, opts) {
  assert$2('TryStatement', node2, opts)
}
function assertUnaryExpression(node2, opts) {
  assert$2('UnaryExpression', node2, opts)
}
function assertUpdateExpression(node2, opts) {
  assert$2('UpdateExpression', node2, opts)
}
function assertVariableDeclaration(node2, opts) {
  assert$2('VariableDeclaration', node2, opts)
}
function assertVariableDeclarator(node2, opts) {
  assert$2('VariableDeclarator', node2, opts)
}
function assertWhileStatement(node2, opts) {
  assert$2('WhileStatement', node2, opts)
}
function assertWithStatement(node2, opts) {
  assert$2('WithStatement', node2, opts)
}
function assertAssignmentPattern(node2, opts) {
  assert$2('AssignmentPattern', node2, opts)
}
function assertArrayPattern(node2, opts) {
  assert$2('ArrayPattern', node2, opts)
}
function assertArrowFunctionExpression(node2, opts) {
  assert$2('ArrowFunctionExpression', node2, opts)
}
function assertClassBody(node2, opts) {
  assert$2('ClassBody', node2, opts)
}
function assertClassExpression(node2, opts) {
  assert$2('ClassExpression', node2, opts)
}
function assertClassDeclaration(node2, opts) {
  assert$2('ClassDeclaration', node2, opts)
}
function assertExportAllDeclaration(node2, opts) {
  assert$2('ExportAllDeclaration', node2, opts)
}
function assertExportDefaultDeclaration(node2, opts) {
  assert$2('ExportDefaultDeclaration', node2, opts)
}
function assertExportNamedDeclaration(node2, opts) {
  assert$2('ExportNamedDeclaration', node2, opts)
}
function assertExportSpecifier(node2, opts) {
  assert$2('ExportSpecifier', node2, opts)
}
function assertForOfStatement(node2, opts) {
  assert$2('ForOfStatement', node2, opts)
}
function assertImportDeclaration(node2, opts) {
  assert$2('ImportDeclaration', node2, opts)
}
function assertImportDefaultSpecifier(node2, opts) {
  assert$2('ImportDefaultSpecifier', node2, opts)
}
function assertImportNamespaceSpecifier(node2, opts) {
  assert$2('ImportNamespaceSpecifier', node2, opts)
}
function assertImportSpecifier(node2, opts) {
  assert$2('ImportSpecifier', node2, opts)
}
function assertMetaProperty(node2, opts) {
  assert$2('MetaProperty', node2, opts)
}
function assertClassMethod(node2, opts) {
  assert$2('ClassMethod', node2, opts)
}
function assertObjectPattern(node2, opts) {
  assert$2('ObjectPattern', node2, opts)
}
function assertSpreadElement(node2, opts) {
  assert$2('SpreadElement', node2, opts)
}
function assertSuper(node2, opts) {
  assert$2('Super', node2, opts)
}
function assertTaggedTemplateExpression(node2, opts) {
  assert$2('TaggedTemplateExpression', node2, opts)
}
function assertTemplateElement(node2, opts) {
  assert$2('TemplateElement', node2, opts)
}
function assertTemplateLiteral(node2, opts) {
  assert$2('TemplateLiteral', node2, opts)
}
function assertYieldExpression(node2, opts) {
  assert$2('YieldExpression', node2, opts)
}
function assertAwaitExpression(node2, opts) {
  assert$2('AwaitExpression', node2, opts)
}
function assertImport(node2, opts) {
  assert$2('Import', node2, opts)
}
function assertBigIntLiteral(node2, opts) {
  assert$2('BigIntLiteral', node2, opts)
}
function assertExportNamespaceSpecifier(node2, opts) {
  assert$2('ExportNamespaceSpecifier', node2, opts)
}
function assertOptionalMemberExpression(node2, opts) {
  assert$2('OptionalMemberExpression', node2, opts)
}
function assertOptionalCallExpression(node2, opts) {
  assert$2('OptionalCallExpression', node2, opts)
}
function assertClassProperty(node2, opts) {
  assert$2('ClassProperty', node2, opts)
}
function assertClassAccessorProperty(node2, opts) {
  assert$2('ClassAccessorProperty', node2, opts)
}
function assertClassPrivateProperty(node2, opts) {
  assert$2('ClassPrivateProperty', node2, opts)
}
function assertClassPrivateMethod(node2, opts) {
  assert$2('ClassPrivateMethod', node2, opts)
}
function assertPrivateName(node2, opts) {
  assert$2('PrivateName', node2, opts)
}
function assertStaticBlock(node2, opts) {
  assert$2('StaticBlock', node2, opts)
}
function assertAnyTypeAnnotation(node2, opts) {
  assert$2('AnyTypeAnnotation', node2, opts)
}
function assertArrayTypeAnnotation(node2, opts) {
  assert$2('ArrayTypeAnnotation', node2, opts)
}
function assertBooleanTypeAnnotation(node2, opts) {
  assert$2('BooleanTypeAnnotation', node2, opts)
}
function assertBooleanLiteralTypeAnnotation(node2, opts) {
  assert$2('BooleanLiteralTypeAnnotation', node2, opts)
}
function assertNullLiteralTypeAnnotation(node2, opts) {
  assert$2('NullLiteralTypeAnnotation', node2, opts)
}
function assertClassImplements(node2, opts) {
  assert$2('ClassImplements', node2, opts)
}
function assertDeclareClass(node2, opts) {
  assert$2('DeclareClass', node2, opts)
}
function assertDeclareFunction(node2, opts) {
  assert$2('DeclareFunction', node2, opts)
}
function assertDeclareInterface(node2, opts) {
  assert$2('DeclareInterface', node2, opts)
}
function assertDeclareModule(node2, opts) {
  assert$2('DeclareModule', node2, opts)
}
function assertDeclareModuleExports(node2, opts) {
  assert$2('DeclareModuleExports', node2, opts)
}
function assertDeclareTypeAlias(node2, opts) {
  assert$2('DeclareTypeAlias', node2, opts)
}
function assertDeclareOpaqueType(node2, opts) {
  assert$2('DeclareOpaqueType', node2, opts)
}
function assertDeclareVariable(node2, opts) {
  assert$2('DeclareVariable', node2, opts)
}
function assertDeclareExportDeclaration(node2, opts) {
  assert$2('DeclareExportDeclaration', node2, opts)
}
function assertDeclareExportAllDeclaration(node2, opts) {
  assert$2('DeclareExportAllDeclaration', node2, opts)
}
function assertDeclaredPredicate(node2, opts) {
  assert$2('DeclaredPredicate', node2, opts)
}
function assertExistsTypeAnnotation(node2, opts) {
  assert$2('ExistsTypeAnnotation', node2, opts)
}
function assertFunctionTypeAnnotation(node2, opts) {
  assert$2('FunctionTypeAnnotation', node2, opts)
}
function assertFunctionTypeParam(node2, opts) {
  assert$2('FunctionTypeParam', node2, opts)
}
function assertGenericTypeAnnotation(node2, opts) {
  assert$2('GenericTypeAnnotation', node2, opts)
}
function assertInferredPredicate(node2, opts) {
  assert$2('InferredPredicate', node2, opts)
}
function assertInterfaceExtends(node2, opts) {
  assert$2('InterfaceExtends', node2, opts)
}
function assertInterfaceDeclaration(node2, opts) {
  assert$2('InterfaceDeclaration', node2, opts)
}
function assertInterfaceTypeAnnotation(node2, opts) {
  assert$2('InterfaceTypeAnnotation', node2, opts)
}
function assertIntersectionTypeAnnotation(node2, opts) {
  assert$2('IntersectionTypeAnnotation', node2, opts)
}
function assertMixedTypeAnnotation(node2, opts) {
  assert$2('MixedTypeAnnotation', node2, opts)
}
function assertEmptyTypeAnnotation(node2, opts) {
  assert$2('EmptyTypeAnnotation', node2, opts)
}
function assertNullableTypeAnnotation(node2, opts) {
  assert$2('NullableTypeAnnotation', node2, opts)
}
function assertNumberLiteralTypeAnnotation(node2, opts) {
  assert$2('NumberLiteralTypeAnnotation', node2, opts)
}
function assertNumberTypeAnnotation(node2, opts) {
  assert$2('NumberTypeAnnotation', node2, opts)
}
function assertObjectTypeAnnotation(node2, opts) {
  assert$2('ObjectTypeAnnotation', node2, opts)
}
function assertObjectTypeInternalSlot(node2, opts) {
  assert$2('ObjectTypeInternalSlot', node2, opts)
}
function assertObjectTypeCallProperty(node2, opts) {
  assert$2('ObjectTypeCallProperty', node2, opts)
}
function assertObjectTypeIndexer(node2, opts) {
  assert$2('ObjectTypeIndexer', node2, opts)
}
function assertObjectTypeProperty(node2, opts) {
  assert$2('ObjectTypeProperty', node2, opts)
}
function assertObjectTypeSpreadProperty(node2, opts) {
  assert$2('ObjectTypeSpreadProperty', node2, opts)
}
function assertOpaqueType(node2, opts) {
  assert$2('OpaqueType', node2, opts)
}
function assertQualifiedTypeIdentifier(node2, opts) {
  assert$2('QualifiedTypeIdentifier', node2, opts)
}
function assertStringLiteralTypeAnnotation(node2, opts) {
  assert$2('StringLiteralTypeAnnotation', node2, opts)
}
function assertStringTypeAnnotation(node2, opts) {
  assert$2('StringTypeAnnotation', node2, opts)
}
function assertSymbolTypeAnnotation(node2, opts) {
  assert$2('SymbolTypeAnnotation', node2, opts)
}
function assertThisTypeAnnotation(node2, opts) {
  assert$2('ThisTypeAnnotation', node2, opts)
}
function assertTupleTypeAnnotation(node2, opts) {
  assert$2('TupleTypeAnnotation', node2, opts)
}
function assertTypeofTypeAnnotation(node2, opts) {
  assert$2('TypeofTypeAnnotation', node2, opts)
}
function assertTypeAlias(node2, opts) {
  assert$2('TypeAlias', node2, opts)
}
function assertTypeAnnotation(node2, opts) {
  assert$2('TypeAnnotation', node2, opts)
}
function assertTypeCastExpression(node2, opts) {
  assert$2('TypeCastExpression', node2, opts)
}
function assertTypeParameter(node2, opts) {
  assert$2('TypeParameter', node2, opts)
}
function assertTypeParameterDeclaration(node2, opts) {
  assert$2('TypeParameterDeclaration', node2, opts)
}
function assertTypeParameterInstantiation(node2, opts) {
  assert$2('TypeParameterInstantiation', node2, opts)
}
function assertUnionTypeAnnotation(node2, opts) {
  assert$2('UnionTypeAnnotation', node2, opts)
}
function assertVariance(node2, opts) {
  assert$2('Variance', node2, opts)
}
function assertVoidTypeAnnotation(node2, opts) {
  assert$2('VoidTypeAnnotation', node2, opts)
}
function assertEnumDeclaration(node2, opts) {
  assert$2('EnumDeclaration', node2, opts)
}
function assertEnumBooleanBody(node2, opts) {
  assert$2('EnumBooleanBody', node2, opts)
}
function assertEnumNumberBody(node2, opts) {
  assert$2('EnumNumberBody', node2, opts)
}
function assertEnumStringBody(node2, opts) {
  assert$2('EnumStringBody', node2, opts)
}
function assertEnumSymbolBody(node2, opts) {
  assert$2('EnumSymbolBody', node2, opts)
}
function assertEnumBooleanMember(node2, opts) {
  assert$2('EnumBooleanMember', node2, opts)
}
function assertEnumNumberMember(node2, opts) {
  assert$2('EnumNumberMember', node2, opts)
}
function assertEnumStringMember(node2, opts) {
  assert$2('EnumStringMember', node2, opts)
}
function assertEnumDefaultedMember(node2, opts) {
  assert$2('EnumDefaultedMember', node2, opts)
}
function assertIndexedAccessType(node2, opts) {
  assert$2('IndexedAccessType', node2, opts)
}
function assertOptionalIndexedAccessType(node2, opts) {
  assert$2('OptionalIndexedAccessType', node2, opts)
}
function assertJSXAttribute(node2, opts) {
  assert$2('JSXAttribute', node2, opts)
}
function assertJSXClosingElement(node2, opts) {
  assert$2('JSXClosingElement', node2, opts)
}
function assertJSXElement(node2, opts) {
  assert$2('JSXElement', node2, opts)
}
function assertJSXEmptyExpression(node2, opts) {
  assert$2('JSXEmptyExpression', node2, opts)
}
function assertJSXExpressionContainer(node2, opts) {
  assert$2('JSXExpressionContainer', node2, opts)
}
function assertJSXSpreadChild(node2, opts) {
  assert$2('JSXSpreadChild', node2, opts)
}
function assertJSXIdentifier(node2, opts) {
  assert$2('JSXIdentifier', node2, opts)
}
function assertJSXMemberExpression(node2, opts) {
  assert$2('JSXMemberExpression', node2, opts)
}
function assertJSXNamespacedName(node2, opts) {
  assert$2('JSXNamespacedName', node2, opts)
}
function assertJSXOpeningElement(node2, opts) {
  assert$2('JSXOpeningElement', node2, opts)
}
function assertJSXSpreadAttribute(node2, opts) {
  assert$2('JSXSpreadAttribute', node2, opts)
}
function assertJSXText(node2, opts) {
  assert$2('JSXText', node2, opts)
}
function assertJSXFragment(node2, opts) {
  assert$2('JSXFragment', node2, opts)
}
function assertJSXOpeningFragment(node2, opts) {
  assert$2('JSXOpeningFragment', node2, opts)
}
function assertJSXClosingFragment(node2, opts) {
  assert$2('JSXClosingFragment', node2, opts)
}
function assertNoop(node2, opts) {
  assert$2('Noop', node2, opts)
}
function assertPlaceholder(node2, opts) {
  assert$2('Placeholder', node2, opts)
}
function assertV8IntrinsicIdentifier(node2, opts) {
  assert$2('V8IntrinsicIdentifier', node2, opts)
}
function assertArgumentPlaceholder(node2, opts) {
  assert$2('ArgumentPlaceholder', node2, opts)
}
function assertBindExpression(node2, opts) {
  assert$2('BindExpression', node2, opts)
}
function assertImportAttribute(node2, opts) {
  assert$2('ImportAttribute', node2, opts)
}
function assertDecorator(node2, opts) {
  assert$2('Decorator', node2, opts)
}
function assertDoExpression(node2, opts) {
  assert$2('DoExpression', node2, opts)
}
function assertExportDefaultSpecifier(node2, opts) {
  assert$2('ExportDefaultSpecifier', node2, opts)
}
function assertRecordExpression(node2, opts) {
  assert$2('RecordExpression', node2, opts)
}
function assertTupleExpression(node2, opts) {
  assert$2('TupleExpression', node2, opts)
}
function assertDecimalLiteral(node2, opts) {
  assert$2('DecimalLiteral', node2, opts)
}
function assertModuleExpression(node2, opts) {
  assert$2('ModuleExpression', node2, opts)
}
function assertTopicReference(node2, opts) {
  assert$2('TopicReference', node2, opts)
}
function assertPipelineTopicExpression(node2, opts) {
  assert$2('PipelineTopicExpression', node2, opts)
}
function assertPipelineBareFunction(node2, opts) {
  assert$2('PipelineBareFunction', node2, opts)
}
function assertPipelinePrimaryTopicReference(node2, opts) {
  assert$2('PipelinePrimaryTopicReference', node2, opts)
}
function assertTSParameterProperty(node2, opts) {
  assert$2('TSParameterProperty', node2, opts)
}
function assertTSDeclareFunction(node2, opts) {
  assert$2('TSDeclareFunction', node2, opts)
}
function assertTSDeclareMethod(node2, opts) {
  assert$2('TSDeclareMethod', node2, opts)
}
function assertTSQualifiedName(node2, opts) {
  assert$2('TSQualifiedName', node2, opts)
}
function assertTSCallSignatureDeclaration(node2, opts) {
  assert$2('TSCallSignatureDeclaration', node2, opts)
}
function assertTSConstructSignatureDeclaration(node2, opts) {
  assert$2('TSConstructSignatureDeclaration', node2, opts)
}
function assertTSPropertySignature(node2, opts) {
  assert$2('TSPropertySignature', node2, opts)
}
function assertTSMethodSignature(node2, opts) {
  assert$2('TSMethodSignature', node2, opts)
}
function assertTSIndexSignature(node2, opts) {
  assert$2('TSIndexSignature', node2, opts)
}
function assertTSAnyKeyword(node2, opts) {
  assert$2('TSAnyKeyword', node2, opts)
}
function assertTSBooleanKeyword(node2, opts) {
  assert$2('TSBooleanKeyword', node2, opts)
}
function assertTSBigIntKeyword(node2, opts) {
  assert$2('TSBigIntKeyword', node2, opts)
}
function assertTSIntrinsicKeyword(node2, opts) {
  assert$2('TSIntrinsicKeyword', node2, opts)
}
function assertTSNeverKeyword(node2, opts) {
  assert$2('TSNeverKeyword', node2, opts)
}
function assertTSNullKeyword(node2, opts) {
  assert$2('TSNullKeyword', node2, opts)
}
function assertTSNumberKeyword(node2, opts) {
  assert$2('TSNumberKeyword', node2, opts)
}
function assertTSObjectKeyword(node2, opts) {
  assert$2('TSObjectKeyword', node2, opts)
}
function assertTSStringKeyword(node2, opts) {
  assert$2('TSStringKeyword', node2, opts)
}
function assertTSSymbolKeyword(node2, opts) {
  assert$2('TSSymbolKeyword', node2, opts)
}
function assertTSUndefinedKeyword(node2, opts) {
  assert$2('TSUndefinedKeyword', node2, opts)
}
function assertTSUnknownKeyword(node2, opts) {
  assert$2('TSUnknownKeyword', node2, opts)
}
function assertTSVoidKeyword(node2, opts) {
  assert$2('TSVoidKeyword', node2, opts)
}
function assertTSThisType(node2, opts) {
  assert$2('TSThisType', node2, opts)
}
function assertTSFunctionType(node2, opts) {
  assert$2('TSFunctionType', node2, opts)
}
function assertTSConstructorType(node2, opts) {
  assert$2('TSConstructorType', node2, opts)
}
function assertTSTypeReference(node2, opts) {
  assert$2('TSTypeReference', node2, opts)
}
function assertTSTypePredicate(node2, opts) {
  assert$2('TSTypePredicate', node2, opts)
}
function assertTSTypeQuery(node2, opts) {
  assert$2('TSTypeQuery', node2, opts)
}
function assertTSTypeLiteral(node2, opts) {
  assert$2('TSTypeLiteral', node2, opts)
}
function assertTSArrayType(node2, opts) {
  assert$2('TSArrayType', node2, opts)
}
function assertTSTupleType(node2, opts) {
  assert$2('TSTupleType', node2, opts)
}
function assertTSOptionalType(node2, opts) {
  assert$2('TSOptionalType', node2, opts)
}
function assertTSRestType(node2, opts) {
  assert$2('TSRestType', node2, opts)
}
function assertTSNamedTupleMember(node2, opts) {
  assert$2('TSNamedTupleMember', node2, opts)
}
function assertTSUnionType(node2, opts) {
  assert$2('TSUnionType', node2, opts)
}
function assertTSIntersectionType(node2, opts) {
  assert$2('TSIntersectionType', node2, opts)
}
function assertTSConditionalType(node2, opts) {
  assert$2('TSConditionalType', node2, opts)
}
function assertTSInferType(node2, opts) {
  assert$2('TSInferType', node2, opts)
}
function assertTSParenthesizedType(node2, opts) {
  assert$2('TSParenthesizedType', node2, opts)
}
function assertTSTypeOperator(node2, opts) {
  assert$2('TSTypeOperator', node2, opts)
}
function assertTSIndexedAccessType(node2, opts) {
  assert$2('TSIndexedAccessType', node2, opts)
}
function assertTSMappedType(node2, opts) {
  assert$2('TSMappedType', node2, opts)
}
function assertTSLiteralType(node2, opts) {
  assert$2('TSLiteralType', node2, opts)
}
function assertTSExpressionWithTypeArguments(node2, opts) {
  assert$2('TSExpressionWithTypeArguments', node2, opts)
}
function assertTSInterfaceDeclaration(node2, opts) {
  assert$2('TSInterfaceDeclaration', node2, opts)
}
function assertTSInterfaceBody(node2, opts) {
  assert$2('TSInterfaceBody', node2, opts)
}
function assertTSTypeAliasDeclaration(node2, opts) {
  assert$2('TSTypeAliasDeclaration', node2, opts)
}
function assertTSInstantiationExpression(node2, opts) {
  assert$2('TSInstantiationExpression', node2, opts)
}
function assertTSAsExpression(node2, opts) {
  assert$2('TSAsExpression', node2, opts)
}
function assertTSTypeAssertion(node2, opts) {
  assert$2('TSTypeAssertion', node2, opts)
}
function assertTSEnumDeclaration(node2, opts) {
  assert$2('TSEnumDeclaration', node2, opts)
}
function assertTSEnumMember(node2, opts) {
  assert$2('TSEnumMember', node2, opts)
}
function assertTSModuleDeclaration(node2, opts) {
  assert$2('TSModuleDeclaration', node2, opts)
}
function assertTSModuleBlock(node2, opts) {
  assert$2('TSModuleBlock', node2, opts)
}
function assertTSImportType(node2, opts) {
  assert$2('TSImportType', node2, opts)
}
function assertTSImportEqualsDeclaration(node2, opts) {
  assert$2('TSImportEqualsDeclaration', node2, opts)
}
function assertTSExternalModuleReference(node2, opts) {
  assert$2('TSExternalModuleReference', node2, opts)
}
function assertTSNonNullExpression(node2, opts) {
  assert$2('TSNonNullExpression', node2, opts)
}
function assertTSExportAssignment(node2, opts) {
  assert$2('TSExportAssignment', node2, opts)
}
function assertTSNamespaceExportDeclaration(node2, opts) {
  assert$2('TSNamespaceExportDeclaration', node2, opts)
}
function assertTSTypeAnnotation(node2, opts) {
  assert$2('TSTypeAnnotation', node2, opts)
}
function assertTSTypeParameterInstantiation(node2, opts) {
  assert$2('TSTypeParameterInstantiation', node2, opts)
}
function assertTSTypeParameterDeclaration(node2, opts) {
  assert$2('TSTypeParameterDeclaration', node2, opts)
}
function assertTSTypeParameter(node2, opts) {
  assert$2('TSTypeParameter', node2, opts)
}
function assertStandardized(node2, opts) {
  assert$2('Standardized', node2, opts)
}
function assertExpression$1(node2, opts) {
  assert$2('Expression', node2, opts)
}
function assertBinary(node2, opts) {
  assert$2('Binary', node2, opts)
}
function assertScopable(node2, opts) {
  assert$2('Scopable', node2, opts)
}
function assertBlockParent(node2, opts) {
  assert$2('BlockParent', node2, opts)
}
function assertBlock(node2, opts) {
  assert$2('Block', node2, opts)
}
function assertStatement(node2, opts) {
  assert$2('Statement', node2, opts)
}
function assertTerminatorless(node2, opts) {
  assert$2('Terminatorless', node2, opts)
}
function assertCompletionStatement(node2, opts) {
  assert$2('CompletionStatement', node2, opts)
}
function assertConditional(node2, opts) {
  assert$2('Conditional', node2, opts)
}
function assertLoop(node2, opts) {
  assert$2('Loop', node2, opts)
}
function assertWhile(node2, opts) {
  assert$2('While', node2, opts)
}
function assertExpressionWrapper(node2, opts) {
  assert$2('ExpressionWrapper', node2, opts)
}
function assertFor(node2, opts) {
  assert$2('For', node2, opts)
}
function assertForXStatement(node2, opts) {
  assert$2('ForXStatement', node2, opts)
}
function assertFunction(node2, opts) {
  assert$2('Function', node2, opts)
}
function assertFunctionParent(node2, opts) {
  assert$2('FunctionParent', node2, opts)
}
function assertPureish(node2, opts) {
  assert$2('Pureish', node2, opts)
}
function assertDeclaration(node2, opts) {
  assert$2('Declaration', node2, opts)
}
function assertPatternLike(node2, opts) {
  assert$2('PatternLike', node2, opts)
}
function assertLVal(node2, opts) {
  assert$2('LVal', node2, opts)
}
function assertTSEntityName(node2, opts) {
  assert$2('TSEntityName', node2, opts)
}
function assertLiteral(node2, opts) {
  assert$2('Literal', node2, opts)
}
function assertImmutable(node2, opts) {
  assert$2('Immutable', node2, opts)
}
function assertUserWhitespacable(node2, opts) {
  assert$2('UserWhitespacable', node2, opts)
}
function assertMethod(node2, opts) {
  assert$2('Method', node2, opts)
}
function assertObjectMember(node2, opts) {
  assert$2('ObjectMember', node2, opts)
}
function assertProperty(node2, opts) {
  assert$2('Property', node2, opts)
}
function assertUnaryLike(node2, opts) {
  assert$2('UnaryLike', node2, opts)
}
function assertPattern(node2, opts) {
  assert$2('Pattern', node2, opts)
}
function assertClass(node2, opts) {
  assert$2('Class', node2, opts)
}
function assertModuleDeclaration(node2, opts) {
  assert$2('ModuleDeclaration', node2, opts)
}
function assertExportDeclaration(node2, opts) {
  assert$2('ExportDeclaration', node2, opts)
}
function assertModuleSpecifier(node2, opts) {
  assert$2('ModuleSpecifier', node2, opts)
}
function assertAccessor(node2, opts) {
  assert$2('Accessor', node2, opts)
}
function assertPrivate(node2, opts) {
  assert$2('Private', node2, opts)
}
function assertFlow(node2, opts) {
  assert$2('Flow', node2, opts)
}
function assertFlowType(node2, opts) {
  assert$2('FlowType', node2, opts)
}
function assertFlowBaseAnnotation(node2, opts) {
  assert$2('FlowBaseAnnotation', node2, opts)
}
function assertFlowDeclaration(node2, opts) {
  assert$2('FlowDeclaration', node2, opts)
}
function assertFlowPredicate(node2, opts) {
  assert$2('FlowPredicate', node2, opts)
}
function assertEnumBody(node2, opts) {
  assert$2('EnumBody', node2, opts)
}
function assertEnumMember(node2, opts) {
  assert$2('EnumMember', node2, opts)
}
function assertJSX(node2, opts) {
  assert$2('JSX', node2, opts)
}
function assertMiscellaneous(node2, opts) {
  assert$2('Miscellaneous', node2, opts)
}
function assertTypeScript(node2, opts) {
  assert$2('TypeScript', node2, opts)
}
function assertTSTypeElement(node2, opts) {
  assert$2('TSTypeElement', node2, opts)
}
function assertTSType(node2, opts) {
  assert$2('TSType', node2, opts)
}
function assertTSBaseType(node2, opts) {
  assert$2('TSBaseType', node2, opts)
}
function assertNumberLiteral(node2, opts) {
  console.trace('The node type NumberLiteral has been renamed to NumericLiteral')
  assert$2('NumberLiteral', node2, opts)
}
function assertRegexLiteral(node2, opts) {
  console.trace('The node type RegexLiteral has been renamed to RegExpLiteral')
  assert$2('RegexLiteral', node2, opts)
}
function assertRestProperty(node2, opts) {
  console.trace('The node type RestProperty has been renamed to RestElement')
  assert$2('RestProperty', node2, opts)
}
function assertSpreadProperty(node2, opts) {
  console.trace('The node type SpreadProperty has been renamed to SpreadElement')
  assert$2('SpreadProperty', node2, opts)
}
var createTypeAnnotationBasedOnTypeof$2 = {}
Object.defineProperty(createTypeAnnotationBasedOnTypeof$2, '__esModule', {
  value: true,
})
createTypeAnnotationBasedOnTypeof$2.default = void 0
var _generated$l = generated$3
var _default$c = createTypeAnnotationBasedOnTypeof$1
createTypeAnnotationBasedOnTypeof$2.default = _default$c
function createTypeAnnotationBasedOnTypeof$1(type) {
  switch (type) {
    case 'string':
      return (0, _generated$l.stringTypeAnnotation)()
    case 'number':
      return (0, _generated$l.numberTypeAnnotation)()
    case 'undefined':
      return (0, _generated$l.voidTypeAnnotation)()
    case 'boolean':
      return (0, _generated$l.booleanTypeAnnotation)()
    case 'function':
      return (0, _generated$l.genericTypeAnnotation)((0, _generated$l.identifier)('Function'))
    case 'object':
      return (0, _generated$l.genericTypeAnnotation)((0, _generated$l.identifier)('Object'))
    case 'symbol':
      return (0, _generated$l.genericTypeAnnotation)((0, _generated$l.identifier)('Symbol'))
    case 'bigint':
      return (0, _generated$l.anyTypeAnnotation)()
  }
  throw new Error('Invalid typeof value: ' + type)
}
var createFlowUnionType$2 = {}
var removeTypeDuplicates$3 = {}
Object.defineProperty(removeTypeDuplicates$3, '__esModule', {
  value: true,
})
removeTypeDuplicates$3.default = removeTypeDuplicates$2
var _generated$k = generated$4
function getQualifiedName(node2) {
  return (0, _generated$k.isIdentifier)(node2)
    ? node2.name
    : `${node2.id.name}.${getQualifiedName(node2.qualification)}`
}
function removeTypeDuplicates$2(nodes2) {
  const generics = {}
  const bases = {}
  const typeGroups = /* @__PURE__ */ new Set()
  const types2 = []
  for (let i = 0; i < nodes2.length; i++) {
    const node2 = nodes2[i]
    if (!node2) continue
    if (types2.indexOf(node2) >= 0) {
      continue
    }
    if ((0, _generated$k.isAnyTypeAnnotation)(node2)) {
      return [node2]
    }
    if ((0, _generated$k.isFlowBaseAnnotation)(node2)) {
      bases[node2.type] = node2
      continue
    }
    if ((0, _generated$k.isUnionTypeAnnotation)(node2)) {
      if (!typeGroups.has(node2.types)) {
        nodes2 = nodes2.concat(node2.types)
        typeGroups.add(node2.types)
      }
      continue
    }
    if ((0, _generated$k.isGenericTypeAnnotation)(node2)) {
      const name = getQualifiedName(node2.id)
      if (generics[name]) {
        let existing = generics[name]
        if (existing.typeParameters) {
          if (node2.typeParameters) {
            existing.typeParameters.params = removeTypeDuplicates$2(
              existing.typeParameters.params.concat(node2.typeParameters.params)
            )
          }
        } else {
          existing = node2.typeParameters
        }
      } else {
        generics[name] = node2
      }
      continue
    }
    types2.push(node2)
  }
  for (const type of Object.keys(bases)) {
    types2.push(bases[type])
  }
  for (const name of Object.keys(generics)) {
    types2.push(generics[name])
  }
  return types2
}
Object.defineProperty(createFlowUnionType$2, '__esModule', {
  value: true,
})
createFlowUnionType$2.default = createFlowUnionType$1
var _generated$j = generated$3
var _removeTypeDuplicates$1 = removeTypeDuplicates$3
function createFlowUnionType$1(types2) {
  const flattened = (0, _removeTypeDuplicates$1.default)(types2)
  if (flattened.length === 1) {
    return flattened[0]
  } else {
    return (0, _generated$j.unionTypeAnnotation)(flattened)
  }
}
var createTSUnionType$2 = {}
var removeTypeDuplicates$1 = {}
Object.defineProperty(removeTypeDuplicates$1, '__esModule', {
  value: true,
})
removeTypeDuplicates$1.default = removeTypeDuplicates
var _generated$i = generated$4
function removeTypeDuplicates(nodes2) {
  const generics = {}
  const bases = {}
  const typeGroups = /* @__PURE__ */ new Set()
  const types2 = []
  for (let i = 0; i < nodes2.length; i++) {
    const node2 = nodes2[i]
    if (!node2) continue
    if (types2.indexOf(node2) >= 0) {
      continue
    }
    if ((0, _generated$i.isTSAnyKeyword)(node2)) {
      return [node2]
    }
    if ((0, _generated$i.isTSBaseType)(node2)) {
      bases[node2.type] = node2
      continue
    }
    if ((0, _generated$i.isTSUnionType)(node2)) {
      if (!typeGroups.has(node2.types)) {
        nodes2.push(...node2.types)
        typeGroups.add(node2.types)
      }
      continue
    }
    types2.push(node2)
  }
  for (const type of Object.keys(bases)) {
    types2.push(bases[type])
  }
  for (const name of Object.keys(generics)) {
    types2.push(generics[name])
  }
  return types2
}
Object.defineProperty(createTSUnionType$2, '__esModule', {
  value: true,
})
createTSUnionType$2.default = createTSUnionType$1
var _generated$h = generated$3
var _removeTypeDuplicates = removeTypeDuplicates$1
function createTSUnionType$1(typeAnnotations) {
  const types2 = typeAnnotations.map((type) => type.typeAnnotation)
  const flattened = (0, _removeTypeDuplicates.default)(types2)
  if (flattened.length === 1) {
    return flattened[0]
  } else {
    return (0, _generated$h.tsUnionType)(flattened)
  }
}
var uppercase = {}
;(function (exports) {
  Object.defineProperty(exports, '__esModule', {
    value: true,
  })
  Object.defineProperty(exports, 'AnyTypeAnnotation', {
    enumerable: true,
    get: function () {
      return _index3.anyTypeAnnotation
    },
  })
  Object.defineProperty(exports, 'ArgumentPlaceholder', {
    enumerable: true,
    get: function () {
      return _index3.argumentPlaceholder
    },
  })
  Object.defineProperty(exports, 'ArrayExpression', {
    enumerable: true,
    get: function () {
      return _index3.arrayExpression
    },
  })
  Object.defineProperty(exports, 'ArrayPattern', {
    enumerable: true,
    get: function () {
      return _index3.arrayPattern
    },
  })
  Object.defineProperty(exports, 'ArrayTypeAnnotation', {
    enumerable: true,
    get: function () {
      return _index3.arrayTypeAnnotation
    },
  })
  Object.defineProperty(exports, 'ArrowFunctionExpression', {
    enumerable: true,
    get: function () {
      return _index3.arrowFunctionExpression
    },
  })
  Object.defineProperty(exports, 'AssignmentExpression', {
    enumerable: true,
    get: function () {
      return _index3.assignmentExpression
    },
  })
  Object.defineProperty(exports, 'AssignmentPattern', {
    enumerable: true,
    get: function () {
      return _index3.assignmentPattern
    },
  })
  Object.defineProperty(exports, 'AwaitExpression', {
    enumerable: true,
    get: function () {
      return _index3.awaitExpression
    },
  })
  Object.defineProperty(exports, 'BigIntLiteral', {
    enumerable: true,
    get: function () {
      return _index3.bigIntLiteral
    },
  })
  Object.defineProperty(exports, 'BinaryExpression', {
    enumerable: true,
    get: function () {
      return _index3.binaryExpression
    },
  })
  Object.defineProperty(exports, 'BindExpression', {
    enumerable: true,
    get: function () {
      return _index3.bindExpression
    },
  })
  Object.defineProperty(exports, 'BlockStatement', {
    enumerable: true,
    get: function () {
      return _index3.blockStatement
    },
  })
  Object.defineProperty(exports, 'BooleanLiteral', {
    enumerable: true,
    get: function () {
      return _index3.booleanLiteral
    },
  })
  Object.defineProperty(exports, 'BooleanLiteralTypeAnnotation', {
    enumerable: true,
    get: function () {
      return _index3.booleanLiteralTypeAnnotation
    },
  })
  Object.defineProperty(exports, 'BooleanTypeAnnotation', {
    enumerable: true,
    get: function () {
      return _index3.booleanTypeAnnotation
    },
  })
  Object.defineProperty(exports, 'BreakStatement', {
    enumerable: true,
    get: function () {
      return _index3.breakStatement
    },
  })
  Object.defineProperty(exports, 'CallExpression', {
    enumerable: true,
    get: function () {
      return _index3.callExpression
    },
  })
  Object.defineProperty(exports, 'CatchClause', {
    enumerable: true,
    get: function () {
      return _index3.catchClause
    },
  })
  Object.defineProperty(exports, 'ClassAccessorProperty', {
    enumerable: true,
    get: function () {
      return _index3.classAccessorProperty
    },
  })
  Object.defineProperty(exports, 'ClassBody', {
    enumerable: true,
    get: function () {
      return _index3.classBody
    },
  })
  Object.defineProperty(exports, 'ClassDeclaration', {
    enumerable: true,
    get: function () {
      return _index3.classDeclaration
    },
  })
  Object.defineProperty(exports, 'ClassExpression', {
    enumerable: true,
    get: function () {
      return _index3.classExpression
    },
  })
  Object.defineProperty(exports, 'ClassImplements', {
    enumerable: true,
    get: function () {
      return _index3.classImplements
    },
  })
  Object.defineProperty(exports, 'ClassMethod', {
    enumerable: true,
    get: function () {
      return _index3.classMethod
    },
  })
  Object.defineProperty(exports, 'ClassPrivateMethod', {
    enumerable: true,
    get: function () {
      return _index3.classPrivateMethod
    },
  })
  Object.defineProperty(exports, 'ClassPrivateProperty', {
    enumerable: true,
    get: function () {
      return _index3.classPrivateProperty
    },
  })
  Object.defineProperty(exports, 'ClassProperty', {
    enumerable: true,
    get: function () {
      return _index3.classProperty
    },
  })
  Object.defineProperty(exports, 'ConditionalExpression', {
    enumerable: true,
    get: function () {
      return _index3.conditionalExpression
    },
  })
  Object.defineProperty(exports, 'ContinueStatement', {
    enumerable: true,
    get: function () {
      return _index3.continueStatement
    },
  })
  Object.defineProperty(exports, 'DebuggerStatement', {
    enumerable: true,
    get: function () {
      return _index3.debuggerStatement
    },
  })
  Object.defineProperty(exports, 'DecimalLiteral', {
    enumerable: true,
    get: function () {
      return _index3.decimalLiteral
    },
  })
  Object.defineProperty(exports, 'DeclareClass', {
    enumerable: true,
    get: function () {
      return _index3.declareClass
    },
  })
  Object.defineProperty(exports, 'DeclareExportAllDeclaration', {
    enumerable: true,
    get: function () {
      return _index3.declareExportAllDeclaration
    },
  })
  Object.defineProperty(exports, 'DeclareExportDeclaration', {
    enumerable: true,
    get: function () {
      return _index3.declareExportDeclaration
    },
  })
  Object.defineProperty(exports, 'DeclareFunction', {
    enumerable: true,
    get: function () {
      return _index3.declareFunction
    },
  })
  Object.defineProperty(exports, 'DeclareInterface', {
    enumerable: true,
    get: function () {
      return _index3.declareInterface
    },
  })
  Object.defineProperty(exports, 'DeclareModule', {
    enumerable: true,
    get: function () {
      return _index3.declareModule
    },
  })
  Object.defineProperty(exports, 'DeclareModuleExports', {
    enumerable: true,
    get: function () {
      return _index3.declareModuleExports
    },
  })
  Object.defineProperty(exports, 'DeclareOpaqueType', {
    enumerable: true,
    get: function () {
      return _index3.declareOpaqueType
    },
  })
  Object.defineProperty(exports, 'DeclareTypeAlias', {
    enumerable: true,
    get: function () {
      return _index3.declareTypeAlias
    },
  })
  Object.defineProperty(exports, 'DeclareVariable', {
    enumerable: true,
    get: function () {
      return _index3.declareVariable
    },
  })
  Object.defineProperty(exports, 'DeclaredPredicate', {
    enumerable: true,
    get: function () {
      return _index3.declaredPredicate
    },
  })
  Object.defineProperty(exports, 'Decorator', {
    enumerable: true,
    get: function () {
      return _index3.decorator
    },
  })
  Object.defineProperty(exports, 'Directive', {
    enumerable: true,
    get: function () {
      return _index3.directive
    },
  })
  Object.defineProperty(exports, 'DirectiveLiteral', {
    enumerable: true,
    get: function () {
      return _index3.directiveLiteral
    },
  })
  Object.defineProperty(exports, 'DoExpression', {
    enumerable: true,
    get: function () {
      return _index3.doExpression
    },
  })
  Object.defineProperty(exports, 'DoWhileStatement', {
    enumerable: true,
    get: function () {
      return _index3.doWhileStatement
    },
  })
  Object.defineProperty(exports, 'EmptyStatement', {
    enumerable: true,
    get: function () {
      return _index3.emptyStatement
    },
  })
  Object.defineProperty(exports, 'EmptyTypeAnnotation', {
    enumerable: true,
    get: function () {
      return _index3.emptyTypeAnnotation
    },
  })
  Object.defineProperty(exports, 'EnumBooleanBody', {
    enumerable: true,
    get: function () {
      return _index3.enumBooleanBody
    },
  })
  Object.defineProperty(exports, 'EnumBooleanMember', {
    enumerable: true,
    get: function () {
      return _index3.enumBooleanMember
    },
  })
  Object.defineProperty(exports, 'EnumDeclaration', {
    enumerable: true,
    get: function () {
      return _index3.enumDeclaration
    },
  })
  Object.defineProperty(exports, 'EnumDefaultedMember', {
    enumerable: true,
    get: function () {
      return _index3.enumDefaultedMember
    },
  })
  Object.defineProperty(exports, 'EnumNumberBody', {
    enumerable: true,
    get: function () {
      return _index3.enumNumberBody
    },
  })
  Object.defineProperty(exports, 'EnumNumberMember', {
    enumerable: true,
    get: function () {
      return _index3.enumNumberMember
    },
  })
  Object.defineProperty(exports, 'EnumStringBody', {
    enumerable: true,
    get: function () {
      return _index3.enumStringBody
    },
  })
  Object.defineProperty(exports, 'EnumStringMember', {
    enumerable: true,
    get: function () {
      return _index3.enumStringMember
    },
  })
  Object.defineProperty(exports, 'EnumSymbolBody', {
    enumerable: true,
    get: function () {
      return _index3.enumSymbolBody
    },
  })
  Object.defineProperty(exports, 'ExistsTypeAnnotation', {
    enumerable: true,
    get: function () {
      return _index3.existsTypeAnnotation
    },
  })
  Object.defineProperty(exports, 'ExportAllDeclaration', {
    enumerable: true,
    get: function () {
      return _index3.exportAllDeclaration
    },
  })
  Object.defineProperty(exports, 'ExportDefaultDeclaration', {
    enumerable: true,
    get: function () {
      return _index3.exportDefaultDeclaration
    },
  })
  Object.defineProperty(exports, 'ExportDefaultSpecifier', {
    enumerable: true,
    get: function () {
      return _index3.exportDefaultSpecifier
    },
  })
  Object.defineProperty(exports, 'ExportNamedDeclaration', {
    enumerable: true,
    get: function () {
      return _index3.exportNamedDeclaration
    },
  })
  Object.defineProperty(exports, 'ExportNamespaceSpecifier', {
    enumerable: true,
    get: function () {
      return _index3.exportNamespaceSpecifier
    },
  })
  Object.defineProperty(exports, 'ExportSpecifier', {
    enumerable: true,
    get: function () {
      return _index3.exportSpecifier
    },
  })
  Object.defineProperty(exports, 'ExpressionStatement', {
    enumerable: true,
    get: function () {
      return _index3.expressionStatement
    },
  })
  Object.defineProperty(exports, 'File', {
    enumerable: true,
    get: function () {
      return _index3.file
    },
  })
  Object.defineProperty(exports, 'ForInStatement', {
    enumerable: true,
    get: function () {
      return _index3.forInStatement
    },
  })
  Object.defineProperty(exports, 'ForOfStatement', {
    enumerable: true,
    get: function () {
      return _index3.forOfStatement
    },
  })
  Object.defineProperty(exports, 'ForStatement', {
    enumerable: true,
    get: function () {
      return _index3.forStatement
    },
  })
  Object.defineProperty(exports, 'FunctionDeclaration', {
    enumerable: true,
    get: function () {
      return _index3.functionDeclaration
    },
  })
  Object.defineProperty(exports, 'FunctionExpression', {
    enumerable: true,
    get: function () {
      return _index3.functionExpression
    },
  })
  Object.defineProperty(exports, 'FunctionTypeAnnotation', {
    enumerable: true,
    get: function () {
      return _index3.functionTypeAnnotation
    },
  })
  Object.defineProperty(exports, 'FunctionTypeParam', {
    enumerable: true,
    get: function () {
      return _index3.functionTypeParam
    },
  })
  Object.defineProperty(exports, 'GenericTypeAnnotation', {
    enumerable: true,
    get: function () {
      return _index3.genericTypeAnnotation
    },
  })
  Object.defineProperty(exports, 'Identifier', {
    enumerable: true,
    get: function () {
      return _index3.identifier
    },
  })
  Object.defineProperty(exports, 'IfStatement', {
    enumerable: true,
    get: function () {
      return _index3.ifStatement
    },
  })
  Object.defineProperty(exports, 'Import', {
    enumerable: true,
    get: function () {
      return _index3.import
    },
  })
  Object.defineProperty(exports, 'ImportAttribute', {
    enumerable: true,
    get: function () {
      return _index3.importAttribute
    },
  })
  Object.defineProperty(exports, 'ImportDeclaration', {
    enumerable: true,
    get: function () {
      return _index3.importDeclaration
    },
  })
  Object.defineProperty(exports, 'ImportDefaultSpecifier', {
    enumerable: true,
    get: function () {
      return _index3.importDefaultSpecifier
    },
  })
  Object.defineProperty(exports, 'ImportNamespaceSpecifier', {
    enumerable: true,
    get: function () {
      return _index3.importNamespaceSpecifier
    },
  })
  Object.defineProperty(exports, 'ImportSpecifier', {
    enumerable: true,
    get: function () {
      return _index3.importSpecifier
    },
  })
  Object.defineProperty(exports, 'IndexedAccessType', {
    enumerable: true,
    get: function () {
      return _index3.indexedAccessType
    },
  })
  Object.defineProperty(exports, 'InferredPredicate', {
    enumerable: true,
    get: function () {
      return _index3.inferredPredicate
    },
  })
  Object.defineProperty(exports, 'InterfaceDeclaration', {
    enumerable: true,
    get: function () {
      return _index3.interfaceDeclaration
    },
  })
  Object.defineProperty(exports, 'InterfaceExtends', {
    enumerable: true,
    get: function () {
      return _index3.interfaceExtends
    },
  })
  Object.defineProperty(exports, 'InterfaceTypeAnnotation', {
    enumerable: true,
    get: function () {
      return _index3.interfaceTypeAnnotation
    },
  })
  Object.defineProperty(exports, 'InterpreterDirective', {
    enumerable: true,
    get: function () {
      return _index3.interpreterDirective
    },
  })
  Object.defineProperty(exports, 'IntersectionTypeAnnotation', {
    enumerable: true,
    get: function () {
      return _index3.intersectionTypeAnnotation
    },
  })
  Object.defineProperty(exports, 'JSXAttribute', {
    enumerable: true,
    get: function () {
      return _index3.jsxAttribute
    },
  })
  Object.defineProperty(exports, 'JSXClosingElement', {
    enumerable: true,
    get: function () {
      return _index3.jsxClosingElement
    },
  })
  Object.defineProperty(exports, 'JSXClosingFragment', {
    enumerable: true,
    get: function () {
      return _index3.jsxClosingFragment
    },
  })
  Object.defineProperty(exports, 'JSXElement', {
    enumerable: true,
    get: function () {
      return _index3.jsxElement
    },
  })
  Object.defineProperty(exports, 'JSXEmptyExpression', {
    enumerable: true,
    get: function () {
      return _index3.jsxEmptyExpression
    },
  })
  Object.defineProperty(exports, 'JSXExpressionContainer', {
    enumerable: true,
    get: function () {
      return _index3.jsxExpressionContainer
    },
  })
  Object.defineProperty(exports, 'JSXFragment', {
    enumerable: true,
    get: function () {
      return _index3.jsxFragment
    },
  })
  Object.defineProperty(exports, 'JSXIdentifier', {
    enumerable: true,
    get: function () {
      return _index3.jsxIdentifier
    },
  })
  Object.defineProperty(exports, 'JSXMemberExpression', {
    enumerable: true,
    get: function () {
      return _index3.jsxMemberExpression
    },
  })
  Object.defineProperty(exports, 'JSXNamespacedName', {
    enumerable: true,
    get: function () {
      return _index3.jsxNamespacedName
    },
  })
  Object.defineProperty(exports, 'JSXOpeningElement', {
    enumerable: true,
    get: function () {
      return _index3.jsxOpeningElement
    },
  })
  Object.defineProperty(exports, 'JSXOpeningFragment', {
    enumerable: true,
    get: function () {
      return _index3.jsxOpeningFragment
    },
  })
  Object.defineProperty(exports, 'JSXSpreadAttribute', {
    enumerable: true,
    get: function () {
      return _index3.jsxSpreadAttribute
    },
  })
  Object.defineProperty(exports, 'JSXSpreadChild', {
    enumerable: true,
    get: function () {
      return _index3.jsxSpreadChild
    },
  })
  Object.defineProperty(exports, 'JSXText', {
    enumerable: true,
    get: function () {
      return _index3.jsxText
    },
  })
  Object.defineProperty(exports, 'LabeledStatement', {
    enumerable: true,
    get: function () {
      return _index3.labeledStatement
    },
  })
  Object.defineProperty(exports, 'LogicalExpression', {
    enumerable: true,
    get: function () {
      return _index3.logicalExpression
    },
  })
  Object.defineProperty(exports, 'MemberExpression', {
    enumerable: true,
    get: function () {
      return _index3.memberExpression
    },
  })
  Object.defineProperty(exports, 'MetaProperty', {
    enumerable: true,
    get: function () {
      return _index3.metaProperty
    },
  })
  Object.defineProperty(exports, 'MixedTypeAnnotation', {
    enumerable: true,
    get: function () {
      return _index3.mixedTypeAnnotation
    },
  })
  Object.defineProperty(exports, 'ModuleExpression', {
    enumerable: true,
    get: function () {
      return _index3.moduleExpression
    },
  })
  Object.defineProperty(exports, 'NewExpression', {
    enumerable: true,
    get: function () {
      return _index3.newExpression
    },
  })
  Object.defineProperty(exports, 'Noop', {
    enumerable: true,
    get: function () {
      return _index3.noop
    },
  })
  Object.defineProperty(exports, 'NullLiteral', {
    enumerable: true,
    get: function () {
      return _index3.nullLiteral
    },
  })
  Object.defineProperty(exports, 'NullLiteralTypeAnnotation', {
    enumerable: true,
    get: function () {
      return _index3.nullLiteralTypeAnnotation
    },
  })
  Object.defineProperty(exports, 'NullableTypeAnnotation', {
    enumerable: true,
    get: function () {
      return _index3.nullableTypeAnnotation
    },
  })
  Object.defineProperty(exports, 'NumberLiteral', {
    enumerable: true,
    get: function () {
      return _index3.numberLiteral
    },
  })
  Object.defineProperty(exports, 'NumberLiteralTypeAnnotation', {
    enumerable: true,
    get: function () {
      return _index3.numberLiteralTypeAnnotation
    },
  })
  Object.defineProperty(exports, 'NumberTypeAnnotation', {
    enumerable: true,
    get: function () {
      return _index3.numberTypeAnnotation
    },
  })
  Object.defineProperty(exports, 'NumericLiteral', {
    enumerable: true,
    get: function () {
      return _index3.numericLiteral
    },
  })
  Object.defineProperty(exports, 'ObjectExpression', {
    enumerable: true,
    get: function () {
      return _index3.objectExpression
    },
  })
  Object.defineProperty(exports, 'ObjectMethod', {
    enumerable: true,
    get: function () {
      return _index3.objectMethod
    },
  })
  Object.defineProperty(exports, 'ObjectPattern', {
    enumerable: true,
    get: function () {
      return _index3.objectPattern
    },
  })
  Object.defineProperty(exports, 'ObjectProperty', {
    enumerable: true,
    get: function () {
      return _index3.objectProperty
    },
  })
  Object.defineProperty(exports, 'ObjectTypeAnnotation', {
    enumerable: true,
    get: function () {
      return _index3.objectTypeAnnotation
    },
  })
  Object.defineProperty(exports, 'ObjectTypeCallProperty', {
    enumerable: true,
    get: function () {
      return _index3.objectTypeCallProperty
    },
  })
  Object.defineProperty(exports, 'ObjectTypeIndexer', {
    enumerable: true,
    get: function () {
      return _index3.objectTypeIndexer
    },
  })
  Object.defineProperty(exports, 'ObjectTypeInternalSlot', {
    enumerable: true,
    get: function () {
      return _index3.objectTypeInternalSlot
    },
  })
  Object.defineProperty(exports, 'ObjectTypeProperty', {
    enumerable: true,
    get: function () {
      return _index3.objectTypeProperty
    },
  })
  Object.defineProperty(exports, 'ObjectTypeSpreadProperty', {
    enumerable: true,
    get: function () {
      return _index3.objectTypeSpreadProperty
    },
  })
  Object.defineProperty(exports, 'OpaqueType', {
    enumerable: true,
    get: function () {
      return _index3.opaqueType
    },
  })
  Object.defineProperty(exports, 'OptionalCallExpression', {
    enumerable: true,
    get: function () {
      return _index3.optionalCallExpression
    },
  })
  Object.defineProperty(exports, 'OptionalIndexedAccessType', {
    enumerable: true,
    get: function () {
      return _index3.optionalIndexedAccessType
    },
  })
  Object.defineProperty(exports, 'OptionalMemberExpression', {
    enumerable: true,
    get: function () {
      return _index3.optionalMemberExpression
    },
  })
  Object.defineProperty(exports, 'ParenthesizedExpression', {
    enumerable: true,
    get: function () {
      return _index3.parenthesizedExpression
    },
  })
  Object.defineProperty(exports, 'PipelineBareFunction', {
    enumerable: true,
    get: function () {
      return _index3.pipelineBareFunction
    },
  })
  Object.defineProperty(exports, 'PipelinePrimaryTopicReference', {
    enumerable: true,
    get: function () {
      return _index3.pipelinePrimaryTopicReference
    },
  })
  Object.defineProperty(exports, 'PipelineTopicExpression', {
    enumerable: true,
    get: function () {
      return _index3.pipelineTopicExpression
    },
  })
  Object.defineProperty(exports, 'Placeholder', {
    enumerable: true,
    get: function () {
      return _index3.placeholder
    },
  })
  Object.defineProperty(exports, 'PrivateName', {
    enumerable: true,
    get: function () {
      return _index3.privateName
    },
  })
  Object.defineProperty(exports, 'Program', {
    enumerable: true,
    get: function () {
      return _index3.program
    },
  })
  Object.defineProperty(exports, 'QualifiedTypeIdentifier', {
    enumerable: true,
    get: function () {
      return _index3.qualifiedTypeIdentifier
    },
  })
  Object.defineProperty(exports, 'RecordExpression', {
    enumerable: true,
    get: function () {
      return _index3.recordExpression
    },
  })
  Object.defineProperty(exports, 'RegExpLiteral', {
    enumerable: true,
    get: function () {
      return _index3.regExpLiteral
    },
  })
  Object.defineProperty(exports, 'RegexLiteral', {
    enumerable: true,
    get: function () {
      return _index3.regexLiteral
    },
  })
  Object.defineProperty(exports, 'RestElement', {
    enumerable: true,
    get: function () {
      return _index3.restElement
    },
  })
  Object.defineProperty(exports, 'RestProperty', {
    enumerable: true,
    get: function () {
      return _index3.restProperty
    },
  })
  Object.defineProperty(exports, 'ReturnStatement', {
    enumerable: true,
    get: function () {
      return _index3.returnStatement
    },
  })
  Object.defineProperty(exports, 'SequenceExpression', {
    enumerable: true,
    get: function () {
      return _index3.sequenceExpression
    },
  })
  Object.defineProperty(exports, 'SpreadElement', {
    enumerable: true,
    get: function () {
      return _index3.spreadElement
    },
  })
  Object.defineProperty(exports, 'SpreadProperty', {
    enumerable: true,
    get: function () {
      return _index3.spreadProperty
    },
  })
  Object.defineProperty(exports, 'StaticBlock', {
    enumerable: true,
    get: function () {
      return _index3.staticBlock
    },
  })
  Object.defineProperty(exports, 'StringLiteral', {
    enumerable: true,
    get: function () {
      return _index3.stringLiteral
    },
  })
  Object.defineProperty(exports, 'StringLiteralTypeAnnotation', {
    enumerable: true,
    get: function () {
      return _index3.stringLiteralTypeAnnotation
    },
  })
  Object.defineProperty(exports, 'StringTypeAnnotation', {
    enumerable: true,
    get: function () {
      return _index3.stringTypeAnnotation
    },
  })
  Object.defineProperty(exports, 'Super', {
    enumerable: true,
    get: function () {
      return _index3.super
    },
  })
  Object.defineProperty(exports, 'SwitchCase', {
    enumerable: true,
    get: function () {
      return _index3.switchCase
    },
  })
  Object.defineProperty(exports, 'SwitchStatement', {
    enumerable: true,
    get: function () {
      return _index3.switchStatement
    },
  })
  Object.defineProperty(exports, 'SymbolTypeAnnotation', {
    enumerable: true,
    get: function () {
      return _index3.symbolTypeAnnotation
    },
  })
  Object.defineProperty(exports, 'TSAnyKeyword', {
    enumerable: true,
    get: function () {
      return _index3.tsAnyKeyword
    },
  })
  Object.defineProperty(exports, 'TSArrayType', {
    enumerable: true,
    get: function () {
      return _index3.tsArrayType
    },
  })
  Object.defineProperty(exports, 'TSAsExpression', {
    enumerable: true,
    get: function () {
      return _index3.tsAsExpression
    },
  })
  Object.defineProperty(exports, 'TSBigIntKeyword', {
    enumerable: true,
    get: function () {
      return _index3.tsBigIntKeyword
    },
  })
  Object.defineProperty(exports, 'TSBooleanKeyword', {
    enumerable: true,
    get: function () {
      return _index3.tsBooleanKeyword
    },
  })
  Object.defineProperty(exports, 'TSCallSignatureDeclaration', {
    enumerable: true,
    get: function () {
      return _index3.tsCallSignatureDeclaration
    },
  })
  Object.defineProperty(exports, 'TSConditionalType', {
    enumerable: true,
    get: function () {
      return _index3.tsConditionalType
    },
  })
  Object.defineProperty(exports, 'TSConstructSignatureDeclaration', {
    enumerable: true,
    get: function () {
      return _index3.tsConstructSignatureDeclaration
    },
  })
  Object.defineProperty(exports, 'TSConstructorType', {
    enumerable: true,
    get: function () {
      return _index3.tsConstructorType
    },
  })
  Object.defineProperty(exports, 'TSDeclareFunction', {
    enumerable: true,
    get: function () {
      return _index3.tsDeclareFunction
    },
  })
  Object.defineProperty(exports, 'TSDeclareMethod', {
    enumerable: true,
    get: function () {
      return _index3.tsDeclareMethod
    },
  })
  Object.defineProperty(exports, 'TSEnumDeclaration', {
    enumerable: true,
    get: function () {
      return _index3.tsEnumDeclaration
    },
  })
  Object.defineProperty(exports, 'TSEnumMember', {
    enumerable: true,
    get: function () {
      return _index3.tsEnumMember
    },
  })
  Object.defineProperty(exports, 'TSExportAssignment', {
    enumerable: true,
    get: function () {
      return _index3.tsExportAssignment
    },
  })
  Object.defineProperty(exports, 'TSExpressionWithTypeArguments', {
    enumerable: true,
    get: function () {
      return _index3.tsExpressionWithTypeArguments
    },
  })
  Object.defineProperty(exports, 'TSExternalModuleReference', {
    enumerable: true,
    get: function () {
      return _index3.tsExternalModuleReference
    },
  })
  Object.defineProperty(exports, 'TSFunctionType', {
    enumerable: true,
    get: function () {
      return _index3.tsFunctionType
    },
  })
  Object.defineProperty(exports, 'TSImportEqualsDeclaration', {
    enumerable: true,
    get: function () {
      return _index3.tsImportEqualsDeclaration
    },
  })
  Object.defineProperty(exports, 'TSImportType', {
    enumerable: true,
    get: function () {
      return _index3.tsImportType
    },
  })
  Object.defineProperty(exports, 'TSIndexSignature', {
    enumerable: true,
    get: function () {
      return _index3.tsIndexSignature
    },
  })
  Object.defineProperty(exports, 'TSIndexedAccessType', {
    enumerable: true,
    get: function () {
      return _index3.tsIndexedAccessType
    },
  })
  Object.defineProperty(exports, 'TSInferType', {
    enumerable: true,
    get: function () {
      return _index3.tsInferType
    },
  })
  Object.defineProperty(exports, 'TSInstantiationExpression', {
    enumerable: true,
    get: function () {
      return _index3.tsInstantiationExpression
    },
  })
  Object.defineProperty(exports, 'TSInterfaceBody', {
    enumerable: true,
    get: function () {
      return _index3.tsInterfaceBody
    },
  })
  Object.defineProperty(exports, 'TSInterfaceDeclaration', {
    enumerable: true,
    get: function () {
      return _index3.tsInterfaceDeclaration
    },
  })
  Object.defineProperty(exports, 'TSIntersectionType', {
    enumerable: true,
    get: function () {
      return _index3.tsIntersectionType
    },
  })
  Object.defineProperty(exports, 'TSIntrinsicKeyword', {
    enumerable: true,
    get: function () {
      return _index3.tsIntrinsicKeyword
    },
  })
  Object.defineProperty(exports, 'TSLiteralType', {
    enumerable: true,
    get: function () {
      return _index3.tsLiteralType
    },
  })
  Object.defineProperty(exports, 'TSMappedType', {
    enumerable: true,
    get: function () {
      return _index3.tsMappedType
    },
  })
  Object.defineProperty(exports, 'TSMethodSignature', {
    enumerable: true,
    get: function () {
      return _index3.tsMethodSignature
    },
  })
  Object.defineProperty(exports, 'TSModuleBlock', {
    enumerable: true,
    get: function () {
      return _index3.tsModuleBlock
    },
  })
  Object.defineProperty(exports, 'TSModuleDeclaration', {
    enumerable: true,
    get: function () {
      return _index3.tsModuleDeclaration
    },
  })
  Object.defineProperty(exports, 'TSNamedTupleMember', {
    enumerable: true,
    get: function () {
      return _index3.tsNamedTupleMember
    },
  })
  Object.defineProperty(exports, 'TSNamespaceExportDeclaration', {
    enumerable: true,
    get: function () {
      return _index3.tsNamespaceExportDeclaration
    },
  })
  Object.defineProperty(exports, 'TSNeverKeyword', {
    enumerable: true,
    get: function () {
      return _index3.tsNeverKeyword
    },
  })
  Object.defineProperty(exports, 'TSNonNullExpression', {
    enumerable: true,
    get: function () {
      return _index3.tsNonNullExpression
    },
  })
  Object.defineProperty(exports, 'TSNullKeyword', {
    enumerable: true,
    get: function () {
      return _index3.tsNullKeyword
    },
  })
  Object.defineProperty(exports, 'TSNumberKeyword', {
    enumerable: true,
    get: function () {
      return _index3.tsNumberKeyword
    },
  })
  Object.defineProperty(exports, 'TSObjectKeyword', {
    enumerable: true,
    get: function () {
      return _index3.tsObjectKeyword
    },
  })
  Object.defineProperty(exports, 'TSOptionalType', {
    enumerable: true,
    get: function () {
      return _index3.tsOptionalType
    },
  })
  Object.defineProperty(exports, 'TSParameterProperty', {
    enumerable: true,
    get: function () {
      return _index3.tsParameterProperty
    },
  })
  Object.defineProperty(exports, 'TSParenthesizedType', {
    enumerable: true,
    get: function () {
      return _index3.tsParenthesizedType
    },
  })
  Object.defineProperty(exports, 'TSPropertySignature', {
    enumerable: true,
    get: function () {
      return _index3.tsPropertySignature
    },
  })
  Object.defineProperty(exports, 'TSQualifiedName', {
    enumerable: true,
    get: function () {
      return _index3.tsQualifiedName
    },
  })
  Object.defineProperty(exports, 'TSRestType', {
    enumerable: true,
    get: function () {
      return _index3.tsRestType
    },
  })
  Object.defineProperty(exports, 'TSStringKeyword', {
    enumerable: true,
    get: function () {
      return _index3.tsStringKeyword
    },
  })
  Object.defineProperty(exports, 'TSSymbolKeyword', {
    enumerable: true,
    get: function () {
      return _index3.tsSymbolKeyword
    },
  })
  Object.defineProperty(exports, 'TSThisType', {
    enumerable: true,
    get: function () {
      return _index3.tsThisType
    },
  })
  Object.defineProperty(exports, 'TSTupleType', {
    enumerable: true,
    get: function () {
      return _index3.tsTupleType
    },
  })
  Object.defineProperty(exports, 'TSTypeAliasDeclaration', {
    enumerable: true,
    get: function () {
      return _index3.tsTypeAliasDeclaration
    },
  })
  Object.defineProperty(exports, 'TSTypeAnnotation', {
    enumerable: true,
    get: function () {
      return _index3.tsTypeAnnotation
    },
  })
  Object.defineProperty(exports, 'TSTypeAssertion', {
    enumerable: true,
    get: function () {
      return _index3.tsTypeAssertion
    },
  })
  Object.defineProperty(exports, 'TSTypeLiteral', {
    enumerable: true,
    get: function () {
      return _index3.tsTypeLiteral
    },
  })
  Object.defineProperty(exports, 'TSTypeOperator', {
    enumerable: true,
    get: function () {
      return _index3.tsTypeOperator
    },
  })
  Object.defineProperty(exports, 'TSTypeParameter', {
    enumerable: true,
    get: function () {
      return _index3.tsTypeParameter
    },
  })
  Object.defineProperty(exports, 'TSTypeParameterDeclaration', {
    enumerable: true,
    get: function () {
      return _index3.tsTypeParameterDeclaration
    },
  })
  Object.defineProperty(exports, 'TSTypeParameterInstantiation', {
    enumerable: true,
    get: function () {
      return _index3.tsTypeParameterInstantiation
    },
  })
  Object.defineProperty(exports, 'TSTypePredicate', {
    enumerable: true,
    get: function () {
      return _index3.tsTypePredicate
    },
  })
  Object.defineProperty(exports, 'TSTypeQuery', {
    enumerable: true,
    get: function () {
      return _index3.tsTypeQuery
    },
  })
  Object.defineProperty(exports, 'TSTypeReference', {
    enumerable: true,
    get: function () {
      return _index3.tsTypeReference
    },
  })
  Object.defineProperty(exports, 'TSUndefinedKeyword', {
    enumerable: true,
    get: function () {
      return _index3.tsUndefinedKeyword
    },
  })
  Object.defineProperty(exports, 'TSUnionType', {
    enumerable: true,
    get: function () {
      return _index3.tsUnionType
    },
  })
  Object.defineProperty(exports, 'TSUnknownKeyword', {
    enumerable: true,
    get: function () {
      return _index3.tsUnknownKeyword
    },
  })
  Object.defineProperty(exports, 'TSVoidKeyword', {
    enumerable: true,
    get: function () {
      return _index3.tsVoidKeyword
    },
  })
  Object.defineProperty(exports, 'TaggedTemplateExpression', {
    enumerable: true,
    get: function () {
      return _index3.taggedTemplateExpression
    },
  })
  Object.defineProperty(exports, 'TemplateElement', {
    enumerable: true,
    get: function () {
      return _index3.templateElement
    },
  })
  Object.defineProperty(exports, 'TemplateLiteral', {
    enumerable: true,
    get: function () {
      return _index3.templateLiteral
    },
  })
  Object.defineProperty(exports, 'ThisExpression', {
    enumerable: true,
    get: function () {
      return _index3.thisExpression
    },
  })
  Object.defineProperty(exports, 'ThisTypeAnnotation', {
    enumerable: true,
    get: function () {
      return _index3.thisTypeAnnotation
    },
  })
  Object.defineProperty(exports, 'ThrowStatement', {
    enumerable: true,
    get: function () {
      return _index3.throwStatement
    },
  })
  Object.defineProperty(exports, 'TopicReference', {
    enumerable: true,
    get: function () {
      return _index3.topicReference
    },
  })
  Object.defineProperty(exports, 'TryStatement', {
    enumerable: true,
    get: function () {
      return _index3.tryStatement
    },
  })
  Object.defineProperty(exports, 'TupleExpression', {
    enumerable: true,
    get: function () {
      return _index3.tupleExpression
    },
  })
  Object.defineProperty(exports, 'TupleTypeAnnotation', {
    enumerable: true,
    get: function () {
      return _index3.tupleTypeAnnotation
    },
  })
  Object.defineProperty(exports, 'TypeAlias', {
    enumerable: true,
    get: function () {
      return _index3.typeAlias
    },
  })
  Object.defineProperty(exports, 'TypeAnnotation', {
    enumerable: true,
    get: function () {
      return _index3.typeAnnotation
    },
  })
  Object.defineProperty(exports, 'TypeCastExpression', {
    enumerable: true,
    get: function () {
      return _index3.typeCastExpression
    },
  })
  Object.defineProperty(exports, 'TypeParameter', {
    enumerable: true,
    get: function () {
      return _index3.typeParameter
    },
  })
  Object.defineProperty(exports, 'TypeParameterDeclaration', {
    enumerable: true,
    get: function () {
      return _index3.typeParameterDeclaration
    },
  })
  Object.defineProperty(exports, 'TypeParameterInstantiation', {
    enumerable: true,
    get: function () {
      return _index3.typeParameterInstantiation
    },
  })
  Object.defineProperty(exports, 'TypeofTypeAnnotation', {
    enumerable: true,
    get: function () {
      return _index3.typeofTypeAnnotation
    },
  })
  Object.defineProperty(exports, 'UnaryExpression', {
    enumerable: true,
    get: function () {
      return _index3.unaryExpression
    },
  })
  Object.defineProperty(exports, 'UnionTypeAnnotation', {
    enumerable: true,
    get: function () {
      return _index3.unionTypeAnnotation
    },
  })
  Object.defineProperty(exports, 'UpdateExpression', {
    enumerable: true,
    get: function () {
      return _index3.updateExpression
    },
  })
  Object.defineProperty(exports, 'V8IntrinsicIdentifier', {
    enumerable: true,
    get: function () {
      return _index3.v8IntrinsicIdentifier
    },
  })
  Object.defineProperty(exports, 'VariableDeclaration', {
    enumerable: true,
    get: function () {
      return _index3.variableDeclaration
    },
  })
  Object.defineProperty(exports, 'VariableDeclarator', {
    enumerable: true,
    get: function () {
      return _index3.variableDeclarator
    },
  })
  Object.defineProperty(exports, 'Variance', {
    enumerable: true,
    get: function () {
      return _index3.variance
    },
  })
  Object.defineProperty(exports, 'VoidTypeAnnotation', {
    enumerable: true,
    get: function () {
      return _index3.voidTypeAnnotation
    },
  })
  Object.defineProperty(exports, 'WhileStatement', {
    enumerable: true,
    get: function () {
      return _index3.whileStatement
    },
  })
  Object.defineProperty(exports, 'WithStatement', {
    enumerable: true,
    get: function () {
      return _index3.withStatement
    },
  })
  Object.defineProperty(exports, 'YieldExpression', {
    enumerable: true,
    get: function () {
      return _index3.yieldExpression
    },
  })
  var _index3 = generated$3
})(uppercase)
var cloneNode$8 = {}
Object.defineProperty(cloneNode$8, '__esModule', {
  value: true,
})
cloneNode$8.default = cloneNode$7
var _definitions$4 = definitions
var _generated$g = generated$4
const has$1 = Function.call.bind(Object.prototype.hasOwnProperty)
function cloneIfNode(obj, deep, withoutLoc, commentsCache) {
  if (obj && typeof obj.type === 'string') {
    return cloneNodeInternal(obj, deep, withoutLoc, commentsCache)
  }
  return obj
}
function cloneIfNodeOrArray(obj, deep, withoutLoc, commentsCache) {
  if (Array.isArray(obj)) {
    return obj.map((node2) => cloneIfNode(node2, deep, withoutLoc, commentsCache))
  }
  return cloneIfNode(obj, deep, withoutLoc, commentsCache)
}
function cloneNode$7(node2, deep = true, withoutLoc = false) {
  return cloneNodeInternal(node2, deep, withoutLoc, /* @__PURE__ */ new Map())
}
function cloneNodeInternal(node2, deep = true, withoutLoc = false, commentsCache) {
  if (!node2) return node2
  const { type } = node2
  const newNode = {
    type: node2.type,
  }
  if ((0, _generated$g.isIdentifier)(node2)) {
    newNode.name = node2.name
    if (has$1(node2, 'optional') && typeof node2.optional === 'boolean') {
      newNode.optional = node2.optional
    }
    if (has$1(node2, 'typeAnnotation')) {
      newNode.typeAnnotation = deep
        ? cloneIfNodeOrArray(node2.typeAnnotation, true, withoutLoc, commentsCache)
        : node2.typeAnnotation
    }
  } else if (!has$1(_definitions$4.NODE_FIELDS, type)) {
    throw new Error(`Unknown node type: "${type}"`)
  } else {
    for (const field of Object.keys(_definitions$4.NODE_FIELDS[type])) {
      if (has$1(node2, field)) {
        if (deep) {
          newNode[field] =
            (0, _generated$g.isFile)(node2) && field === 'comments'
              ? maybeCloneComments(node2.comments, deep, withoutLoc, commentsCache)
              : cloneIfNodeOrArray(node2[field], true, withoutLoc, commentsCache)
        } else {
          newNode[field] = node2[field]
        }
      }
    }
  }
  if (has$1(node2, 'loc')) {
    if (withoutLoc) {
      newNode.loc = null
    } else {
      newNode.loc = node2.loc
    }
  }
  if (has$1(node2, 'leadingComments')) {
    newNode.leadingComments = maybeCloneComments(node2.leadingComments, deep, withoutLoc, commentsCache)
  }
  if (has$1(node2, 'innerComments')) {
    newNode.innerComments = maybeCloneComments(node2.innerComments, deep, withoutLoc, commentsCache)
  }
  if (has$1(node2, 'trailingComments')) {
    newNode.trailingComments = maybeCloneComments(node2.trailingComments, deep, withoutLoc, commentsCache)
  }
  if (has$1(node2, 'extra')) {
    newNode.extra = Object.assign({}, node2.extra)
  }
  return newNode
}
function maybeCloneComments(comments2, deep, withoutLoc, commentsCache) {
  if (!comments2 || !deep) {
    return comments2
  }
  return comments2.map((comment) => {
    const cache2 = commentsCache.get(comment)
    if (cache2) return cache2
    const { type, value, loc } = comment
    const ret = {
      type,
      value,
      loc,
    }
    if (withoutLoc) {
      ret.loc = null
    }
    commentsCache.set(comment, ret)
    return ret
  })
}
var clone$2 = {}
Object.defineProperty(clone$2, '__esModule', {
  value: true,
})
clone$2.default = clone$1
var _cloneNode$5 = cloneNode$8
function clone$1(node2) {
  return (0, _cloneNode$5.default)(node2, false)
}
var cloneDeep$1 = {}
Object.defineProperty(cloneDeep$1, '__esModule', {
  value: true,
})
cloneDeep$1.default = cloneDeep
var _cloneNode$4 = cloneNode$8
function cloneDeep(node2) {
  return (0, _cloneNode$4.default)(node2)
}
var cloneDeepWithoutLoc$1 = {}
Object.defineProperty(cloneDeepWithoutLoc$1, '__esModule', {
  value: true,
})
cloneDeepWithoutLoc$1.default = cloneDeepWithoutLoc
var _cloneNode$3 = cloneNode$8
function cloneDeepWithoutLoc(node2) {
  return (0, _cloneNode$3.default)(node2, true, true)
}
var cloneWithoutLoc$1 = {}
Object.defineProperty(cloneWithoutLoc$1, '__esModule', {
  value: true,
})
cloneWithoutLoc$1.default = cloneWithoutLoc
var _cloneNode$2 = cloneNode$8
function cloneWithoutLoc(node2) {
  return (0, _cloneNode$2.default)(node2, false, true)
}
var addComment$2 = {}
var addComments$2 = {}
Object.defineProperty(addComments$2, '__esModule', {
  value: true,
})
addComments$2.default = addComments$1
function addComments$1(node2, type, comments2) {
  if (!comments2 || !node2) return node2
  const key = `${type}Comments`
  if (node2[key]) {
    if (type === 'leading') {
      node2[key] = comments2.concat(node2[key])
    } else {
      node2[key].push(...comments2)
    }
  } else {
    node2[key] = comments2
  }
  return node2
}
Object.defineProperty(addComment$2, '__esModule', {
  value: true,
})
addComment$2.default = addComment$1
var _addComments$1 = addComments$2
function addComment$1(node2, type, content, line) {
  return (0, _addComments$1.default)(node2, type, [
    {
      type: line ? 'CommentLine' : 'CommentBlock',
      value: content,
    },
  ])
}
var inheritInnerComments$1 = {}
var inherit$1 = {}
Object.defineProperty(inherit$1, '__esModule', {
  value: true,
})
inherit$1.default = inherit
function inherit(key, child, parent) {
  if (child && parent) {
    child[key] = Array.from(new Set([].concat(child[key], parent[key]).filter(Boolean)))
  }
}
Object.defineProperty(inheritInnerComments$1, '__esModule', {
  value: true,
})
inheritInnerComments$1.default = inheritInnerComments
var _inherit$2 = inherit$1
function inheritInnerComments(child, parent) {
  ;(0, _inherit$2.default)('innerComments', child, parent)
}
var inheritLeadingComments$2 = {}
Object.defineProperty(inheritLeadingComments$2, '__esModule', {
  value: true,
})
inheritLeadingComments$2.default = inheritLeadingComments$1
var _inherit$1 = inherit$1
function inheritLeadingComments$1(child, parent) {
  ;(0, _inherit$1.default)('leadingComments', child, parent)
}
var inheritsComments$2 = {}
var inheritTrailingComments$2 = {}
Object.defineProperty(inheritTrailingComments$2, '__esModule', {
  value: true,
})
inheritTrailingComments$2.default = inheritTrailingComments$1
var _inherit = inherit$1
function inheritTrailingComments$1(child, parent) {
  ;(0, _inherit.default)('trailingComments', child, parent)
}
Object.defineProperty(inheritsComments$2, '__esModule', {
  value: true,
})
inheritsComments$2.default = inheritsComments$1
var _inheritTrailingComments = inheritTrailingComments$2
var _inheritLeadingComments = inheritLeadingComments$2
var _inheritInnerComments = inheritInnerComments$1
function inheritsComments$1(child, parent) {
  ;(0, _inheritTrailingComments.default)(child, parent)
  ;(0, _inheritLeadingComments.default)(child, parent)
  ;(0, _inheritInnerComments.default)(child, parent)
  return child
}
var removeComments$2 = {}
Object.defineProperty(removeComments$2, '__esModule', {
  value: true,
})
removeComments$2.default = removeComments$1
var _constants$4 = constants
function removeComments$1(node2) {
  _constants$4.COMMENT_KEYS.forEach((key) => {
    node2[key] = null
  })
  return node2
}
var generated$1 = {}
Object.defineProperty(generated$1, '__esModule', {
  value: true,
})
generated$1.WHILE_TYPES =
  generated$1.USERWHITESPACABLE_TYPES =
  generated$1.UNARYLIKE_TYPES =
  generated$1.TYPESCRIPT_TYPES =
  generated$1.TSTYPE_TYPES =
  generated$1.TSTYPEELEMENT_TYPES =
  generated$1.TSENTITYNAME_TYPES =
  generated$1.TSBASETYPE_TYPES =
  generated$1.TERMINATORLESS_TYPES =
  generated$1.STATEMENT_TYPES =
  generated$1.STANDARDIZED_TYPES =
  generated$1.SCOPABLE_TYPES =
  generated$1.PUREISH_TYPES =
  generated$1.PROPERTY_TYPES =
  generated$1.PRIVATE_TYPES =
  generated$1.PATTERN_TYPES =
  generated$1.PATTERNLIKE_TYPES =
  generated$1.OBJECTMEMBER_TYPES =
  generated$1.MODULESPECIFIER_TYPES =
  generated$1.MODULEDECLARATION_TYPES =
  generated$1.MISCELLANEOUS_TYPES =
  generated$1.METHOD_TYPES =
  generated$1.LVAL_TYPES =
  generated$1.LOOP_TYPES =
  generated$1.LITERAL_TYPES =
  generated$1.JSX_TYPES =
  generated$1.IMMUTABLE_TYPES =
  generated$1.FUNCTION_TYPES =
  generated$1.FUNCTIONPARENT_TYPES =
  generated$1.FOR_TYPES =
  generated$1.FORXSTATEMENT_TYPES =
  generated$1.FLOW_TYPES =
  generated$1.FLOWTYPE_TYPES =
  generated$1.FLOWPREDICATE_TYPES =
  generated$1.FLOWDECLARATION_TYPES =
  generated$1.FLOWBASEANNOTATION_TYPES =
  generated$1.EXPRESSION_TYPES =
  generated$1.EXPRESSIONWRAPPER_TYPES =
  generated$1.EXPORTDECLARATION_TYPES =
  generated$1.ENUMMEMBER_TYPES =
  generated$1.ENUMBODY_TYPES =
  generated$1.DECLARATION_TYPES =
  generated$1.CONDITIONAL_TYPES =
  generated$1.COMPLETIONSTATEMENT_TYPES =
  generated$1.CLASS_TYPES =
  generated$1.BLOCK_TYPES =
  generated$1.BLOCKPARENT_TYPES =
  generated$1.BINARY_TYPES =
  generated$1.ACCESSOR_TYPES =
    void 0
var _definitions$3 = definitions
const STANDARDIZED_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS['Standardized']
generated$1.STANDARDIZED_TYPES = STANDARDIZED_TYPES
const EXPRESSION_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS['Expression']
generated$1.EXPRESSION_TYPES = EXPRESSION_TYPES
const BINARY_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS['Binary']
generated$1.BINARY_TYPES = BINARY_TYPES
const SCOPABLE_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS['Scopable']
generated$1.SCOPABLE_TYPES = SCOPABLE_TYPES
const BLOCKPARENT_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS['BlockParent']
generated$1.BLOCKPARENT_TYPES = BLOCKPARENT_TYPES
const BLOCK_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS['Block']
generated$1.BLOCK_TYPES = BLOCK_TYPES
const STATEMENT_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS['Statement']
generated$1.STATEMENT_TYPES = STATEMENT_TYPES
const TERMINATORLESS_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS['Terminatorless']
generated$1.TERMINATORLESS_TYPES = TERMINATORLESS_TYPES
const COMPLETIONSTATEMENT_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS['CompletionStatement']
generated$1.COMPLETIONSTATEMENT_TYPES = COMPLETIONSTATEMENT_TYPES
const CONDITIONAL_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS['Conditional']
generated$1.CONDITIONAL_TYPES = CONDITIONAL_TYPES
const LOOP_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS['Loop']
generated$1.LOOP_TYPES = LOOP_TYPES
const WHILE_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS['While']
generated$1.WHILE_TYPES = WHILE_TYPES
const EXPRESSIONWRAPPER_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS['ExpressionWrapper']
generated$1.EXPRESSIONWRAPPER_TYPES = EXPRESSIONWRAPPER_TYPES
const FOR_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS['For']
generated$1.FOR_TYPES = FOR_TYPES
const FORXSTATEMENT_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS['ForXStatement']
generated$1.FORXSTATEMENT_TYPES = FORXSTATEMENT_TYPES
const FUNCTION_TYPES$1 = _definitions$3.FLIPPED_ALIAS_KEYS['Function']
generated$1.FUNCTION_TYPES = FUNCTION_TYPES$1
const FUNCTIONPARENT_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS['FunctionParent']
generated$1.FUNCTIONPARENT_TYPES = FUNCTIONPARENT_TYPES
const PUREISH_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS['Pureish']
generated$1.PUREISH_TYPES = PUREISH_TYPES
const DECLARATION_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS['Declaration']
generated$1.DECLARATION_TYPES = DECLARATION_TYPES
const PATTERNLIKE_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS['PatternLike']
generated$1.PATTERNLIKE_TYPES = PATTERNLIKE_TYPES
const LVAL_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS['LVal']
generated$1.LVAL_TYPES = LVAL_TYPES
const TSENTITYNAME_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS['TSEntityName']
generated$1.TSENTITYNAME_TYPES = TSENTITYNAME_TYPES
const LITERAL_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS['Literal']
generated$1.LITERAL_TYPES = LITERAL_TYPES
const IMMUTABLE_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS['Immutable']
generated$1.IMMUTABLE_TYPES = IMMUTABLE_TYPES
const USERWHITESPACABLE_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS['UserWhitespacable']
generated$1.USERWHITESPACABLE_TYPES = USERWHITESPACABLE_TYPES
const METHOD_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS['Method']
generated$1.METHOD_TYPES = METHOD_TYPES
const OBJECTMEMBER_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS['ObjectMember']
generated$1.OBJECTMEMBER_TYPES = OBJECTMEMBER_TYPES
const PROPERTY_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS['Property']
generated$1.PROPERTY_TYPES = PROPERTY_TYPES
const UNARYLIKE_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS['UnaryLike']
generated$1.UNARYLIKE_TYPES = UNARYLIKE_TYPES
const PATTERN_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS['Pattern']
generated$1.PATTERN_TYPES = PATTERN_TYPES
const CLASS_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS['Class']
generated$1.CLASS_TYPES = CLASS_TYPES
const MODULEDECLARATION_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS['ModuleDeclaration']
generated$1.MODULEDECLARATION_TYPES = MODULEDECLARATION_TYPES
const EXPORTDECLARATION_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS['ExportDeclaration']
generated$1.EXPORTDECLARATION_TYPES = EXPORTDECLARATION_TYPES
const MODULESPECIFIER_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS['ModuleSpecifier']
generated$1.MODULESPECIFIER_TYPES = MODULESPECIFIER_TYPES
const ACCESSOR_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS['Accessor']
generated$1.ACCESSOR_TYPES = ACCESSOR_TYPES
const PRIVATE_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS['Private']
generated$1.PRIVATE_TYPES = PRIVATE_TYPES
const FLOW_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS['Flow']
generated$1.FLOW_TYPES = FLOW_TYPES
const FLOWTYPE_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS['FlowType']
generated$1.FLOWTYPE_TYPES = FLOWTYPE_TYPES
const FLOWBASEANNOTATION_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS['FlowBaseAnnotation']
generated$1.FLOWBASEANNOTATION_TYPES = FLOWBASEANNOTATION_TYPES
const FLOWDECLARATION_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS['FlowDeclaration']
generated$1.FLOWDECLARATION_TYPES = FLOWDECLARATION_TYPES
const FLOWPREDICATE_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS['FlowPredicate']
generated$1.FLOWPREDICATE_TYPES = FLOWPREDICATE_TYPES
const ENUMBODY_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS['EnumBody']
generated$1.ENUMBODY_TYPES = ENUMBODY_TYPES
const ENUMMEMBER_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS['EnumMember']
generated$1.ENUMMEMBER_TYPES = ENUMMEMBER_TYPES
const JSX_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS['JSX']
generated$1.JSX_TYPES = JSX_TYPES
const MISCELLANEOUS_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS['Miscellaneous']
generated$1.MISCELLANEOUS_TYPES = MISCELLANEOUS_TYPES
const TYPESCRIPT_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS['TypeScript']
generated$1.TYPESCRIPT_TYPES = TYPESCRIPT_TYPES
const TSTYPEELEMENT_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS['TSTypeElement']
generated$1.TSTYPEELEMENT_TYPES = TSTYPEELEMENT_TYPES
const TSTYPE_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS['TSType']
generated$1.TSTYPE_TYPES = TSTYPE_TYPES
const TSBASETYPE_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS['TSBaseType']
generated$1.TSBASETYPE_TYPES = TSBASETYPE_TYPES
var ensureBlock$2 = {}
var toBlock$1 = {}
Object.defineProperty(toBlock$1, '__esModule', {
  value: true,
})
toBlock$1.default = toBlock
var _generated$f = generated$4
var _generated2$3 = generated$3
function toBlock(node2, parent) {
  if ((0, _generated$f.isBlockStatement)(node2)) {
    return node2
  }
  let blockNodes = []
  if ((0, _generated$f.isEmptyStatement)(node2)) {
    blockNodes = []
  } else {
    if (!(0, _generated$f.isStatement)(node2)) {
      if ((0, _generated$f.isFunction)(parent)) {
        node2 = (0, _generated2$3.returnStatement)(node2)
      } else {
        node2 = (0, _generated2$3.expressionStatement)(node2)
      }
    }
    blockNodes = [node2]
  }
  return (0, _generated2$3.blockStatement)(blockNodes)
}
Object.defineProperty(ensureBlock$2, '__esModule', {
  value: true,
})
ensureBlock$2.default = ensureBlock$1
var _toBlock = toBlock$1
function ensureBlock$1(node2, key = 'body') {
  return (node2[key] = (0, _toBlock.default)(node2[key], node2))
}
var toBindingIdentifierName$2 = {}
var toIdentifier$2 = {}
Object.defineProperty(toIdentifier$2, '__esModule', {
  value: true,
})
toIdentifier$2.default = toIdentifier$1
var _isValidIdentifier$2 = isValidIdentifier$1
var _helperValidatorIdentifier$1 = lib$a
function toIdentifier$1(input) {
  input = input + ''
  let name = ''
  for (const c of input) {
    name += (0, _helperValidatorIdentifier$1.isIdentifierChar)(c.codePointAt(0)) ? c : '-'
  }
  name = name.replace(/^[-0-9]+/, '')
  name = name.replace(/[-\s]+(.)?/g, function (match, c) {
    return c ? c.toUpperCase() : ''
  })
  if (!(0, _isValidIdentifier$2.default)(name)) {
    name = `_${name}`
  }
  return name || '_'
}
Object.defineProperty(toBindingIdentifierName$2, '__esModule', {
  value: true,
})
toBindingIdentifierName$2.default = toBindingIdentifierName$1
var _toIdentifier = toIdentifier$2
function toBindingIdentifierName$1(name) {
  name = (0, _toIdentifier.default)(name)
  if (name === 'eval' || name === 'arguments') name = '_' + name
  return name
}
var toComputedKey$2 = {}
Object.defineProperty(toComputedKey$2, '__esModule', {
  value: true,
})
toComputedKey$2.default = toComputedKey$1
var _generated$e = generated$4
var _generated2$2 = generated$3
function toComputedKey$1(node2, key = node2.key || node2.property) {
  if (!node2.computed && (0, _generated$e.isIdentifier)(key)) key = (0, _generated2$2.stringLiteral)(key.name)
  return key
}
var toExpression$2 = {}
Object.defineProperty(toExpression$2, '__esModule', {
  value: true,
})
toExpression$2.default = void 0
var _generated$d = generated$4
var _default$b = toExpression$1
toExpression$2.default = _default$b
function toExpression$1(node2) {
  if ((0, _generated$d.isExpressionStatement)(node2)) {
    node2 = node2.expression
  }
  if ((0, _generated$d.isExpression)(node2)) {
    return node2
  }
  if ((0, _generated$d.isClass)(node2)) {
    node2.type = 'ClassExpression'
  } else if ((0, _generated$d.isFunction)(node2)) {
    node2.type = 'FunctionExpression'
  }
  if (!(0, _generated$d.isExpression)(node2)) {
    throw new Error(`cannot turn ${node2.type} to an expression`)
  }
  return node2
}
var toKeyAlias$1 = {}
var removePropertiesDeep$2 = {}
var traverseFast$1 = {}
Object.defineProperty(traverseFast$1, '__esModule', {
  value: true,
})
traverseFast$1.default = traverseFast
var _definitions$2 = definitions
function traverseFast(node2, enter, opts) {
  if (!node2) return
  const keys = _definitions$2.VISITOR_KEYS[node2.type]
  if (!keys) return
  opts = opts || {}
  enter(node2, opts)
  for (const key of keys) {
    const subNode = node2[key]
    if (Array.isArray(subNode)) {
      for (const node3 of subNode) {
        traverseFast(node3, enter, opts)
      }
    } else {
      traverseFast(subNode, enter, opts)
    }
  }
}
var removeProperties$1 = {}
Object.defineProperty(removeProperties$1, '__esModule', {
  value: true,
})
removeProperties$1.default = removeProperties
var _constants$3 = constants
const CLEAR_KEYS = ['tokens', 'start', 'end', 'loc', 'raw', 'rawValue']
const CLEAR_KEYS_PLUS_COMMENTS = _constants$3.COMMENT_KEYS.concat(['comments']).concat(CLEAR_KEYS)
function removeProperties(node2, opts = {}) {
  const map = opts.preserveComments ? CLEAR_KEYS : CLEAR_KEYS_PLUS_COMMENTS
  for (const key of map) {
    if (node2[key] != null) node2[key] = void 0
  }
  for (const key of Object.keys(node2)) {
    if (key[0] === '_' && node2[key] != null) node2[key] = void 0
  }
  const symbols = Object.getOwnPropertySymbols(node2)
  for (const sym of symbols) {
    node2[sym] = null
  }
}
Object.defineProperty(removePropertiesDeep$2, '__esModule', {
  value: true,
})
removePropertiesDeep$2.default = removePropertiesDeep$1
var _traverseFast = traverseFast$1
var _removeProperties = removeProperties$1
function removePropertiesDeep$1(tree, opts) {
  ;(0, _traverseFast.default)(tree, _removeProperties.default, opts)
  return tree
}
Object.defineProperty(toKeyAlias$1, '__esModule', {
  value: true,
})
toKeyAlias$1.default = toKeyAlias
var _generated$c = generated$4
var _cloneNode$1 = cloneNode$8
var _removePropertiesDeep = removePropertiesDeep$2
function toKeyAlias(node2, key = node2.key) {
  let alias
  if (node2.kind === 'method') {
    return toKeyAlias.increment() + ''
  } else if ((0, _generated$c.isIdentifier)(key)) {
    alias = key.name
  } else if ((0, _generated$c.isStringLiteral)(key)) {
    alias = JSON.stringify(key.value)
  } else {
    alias = JSON.stringify((0, _removePropertiesDeep.default)((0, _cloneNode$1.default)(key)))
  }
  if (node2.computed) {
    alias = `[${alias}]`
  }
  if (node2.static) {
    alias = `static:${alias}`
  }
  return alias
}
toKeyAlias.uid = 0
toKeyAlias.increment = function () {
  if (toKeyAlias.uid >= Number.MAX_SAFE_INTEGER) {
    return (toKeyAlias.uid = 0)
  } else {
    return toKeyAlias.uid++
  }
}
var toSequenceExpression$2 = {}
var gatherSequenceExpressions$1 = {}
var getBindingIdentifiers$3 = {}
Object.defineProperty(getBindingIdentifiers$3, '__esModule', {
  value: true,
})
getBindingIdentifiers$3.default = getBindingIdentifiers$2
var _generated$b = generated$4
function getBindingIdentifiers$2(node2, duplicates, outerOnly) {
  let search = [].concat(node2)
  const ids = /* @__PURE__ */ Object.create(null)
  while (search.length) {
    const id = search.shift()
    if (!id) continue
    const keys = getBindingIdentifiers$2.keys[id.type]
    if ((0, _generated$b.isIdentifier)(id)) {
      if (duplicates) {
        const _ids = (ids[id.name] = ids[id.name] || [])
        _ids.push(id)
      } else {
        ids[id.name] = id
      }
      continue
    }
    if ((0, _generated$b.isExportDeclaration)(id) && !(0, _generated$b.isExportAllDeclaration)(id)) {
      if ((0, _generated$b.isDeclaration)(id.declaration)) {
        search.push(id.declaration)
      }
      continue
    }
    if (outerOnly) {
      if ((0, _generated$b.isFunctionDeclaration)(id)) {
        search.push(id.id)
        continue
      }
      if ((0, _generated$b.isFunctionExpression)(id)) {
        continue
      }
    }
    if (keys) {
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i]
        if (id[key]) {
          search = search.concat(id[key])
        }
      }
    }
  }
  return ids
}
getBindingIdentifiers$2.keys = {
  DeclareClass: ['id'],
  DeclareFunction: ['id'],
  DeclareModule: ['id'],
  DeclareVariable: ['id'],
  DeclareInterface: ['id'],
  DeclareTypeAlias: ['id'],
  DeclareOpaqueType: ['id'],
  InterfaceDeclaration: ['id'],
  TypeAlias: ['id'],
  OpaqueType: ['id'],
  CatchClause: ['param'],
  LabeledStatement: ['label'],
  UnaryExpression: ['argument'],
  AssignmentExpression: ['left'],
  ImportSpecifier: ['local'],
  ImportNamespaceSpecifier: ['local'],
  ImportDefaultSpecifier: ['local'],
  ImportDeclaration: ['specifiers'],
  ExportSpecifier: ['exported'],
  ExportNamespaceSpecifier: ['exported'],
  ExportDefaultSpecifier: ['exported'],
  FunctionDeclaration: ['id', 'params'],
  FunctionExpression: ['id', 'params'],
  ArrowFunctionExpression: ['params'],
  ObjectMethod: ['params'],
  ClassMethod: ['params'],
  ClassPrivateMethod: ['params'],
  ForInStatement: ['left'],
  ForOfStatement: ['left'],
  ClassDeclaration: ['id'],
  ClassExpression: ['id'],
  RestElement: ['argument'],
  UpdateExpression: ['argument'],
  ObjectProperty: ['value'],
  AssignmentPattern: ['left'],
  ArrayPattern: ['elements'],
  ObjectPattern: ['properties'],
  VariableDeclaration: ['declarations'],
  VariableDeclarator: ['id'],
}
Object.defineProperty(gatherSequenceExpressions$1, '__esModule', {
  value: true,
})
gatherSequenceExpressions$1.default = gatherSequenceExpressions
var _getBindingIdentifiers$3 = getBindingIdentifiers$3
var _generated$a = generated$4
var _generated2$1 = generated$3
var _cloneNode = cloneNode$8
function gatherSequenceExpressions(nodes2, scope2, declars) {
  const exprs = []
  let ensureLastUndefined = true
  for (const node2 of nodes2) {
    if (!(0, _generated$a.isEmptyStatement)(node2)) {
      ensureLastUndefined = false
    }
    if ((0, _generated$a.isExpression)(node2)) {
      exprs.push(node2)
    } else if ((0, _generated$a.isExpressionStatement)(node2)) {
      exprs.push(node2.expression)
    } else if ((0, _generated$a.isVariableDeclaration)(node2)) {
      if (node2.kind !== 'var') return
      for (const declar of node2.declarations) {
        const bindings = (0, _getBindingIdentifiers$3.default)(declar)
        for (const key of Object.keys(bindings)) {
          declars.push({
            kind: node2.kind,
            id: (0, _cloneNode.default)(bindings[key]),
          })
        }
        if (declar.init) {
          exprs.push((0, _generated2$1.assignmentExpression)('=', declar.id, declar.init))
        }
      }
      ensureLastUndefined = true
    } else if ((0, _generated$a.isIfStatement)(node2)) {
      const consequent = node2.consequent
        ? gatherSequenceExpressions([node2.consequent], scope2, declars)
        : scope2.buildUndefinedNode()
      const alternate = node2.alternate
        ? gatherSequenceExpressions([node2.alternate], scope2, declars)
        : scope2.buildUndefinedNode()
      if (!consequent || !alternate) return
      exprs.push((0, _generated2$1.conditionalExpression)(node2.test, consequent, alternate))
    } else if ((0, _generated$a.isBlockStatement)(node2)) {
      const body = gatherSequenceExpressions(node2.body, scope2, declars)
      if (!body) return
      exprs.push(body)
    } else if ((0, _generated$a.isEmptyStatement)(node2)) {
      if (nodes2.indexOf(node2) === 0) {
        ensureLastUndefined = true
      }
    } else {
      return
    }
  }
  if (ensureLastUndefined) {
    exprs.push(scope2.buildUndefinedNode())
  }
  if (exprs.length === 1) {
    return exprs[0]
  } else {
    return (0, _generated2$1.sequenceExpression)(exprs)
  }
}
Object.defineProperty(toSequenceExpression$2, '__esModule', {
  value: true,
})
toSequenceExpression$2.default = toSequenceExpression$1
var _gatherSequenceExpressions = gatherSequenceExpressions$1
function toSequenceExpression$1(nodes2, scope2) {
  if (!(nodes2 != null && nodes2.length)) return
  const declars = []
  const result = (0, _gatherSequenceExpressions.default)(nodes2, scope2, declars)
  if (!result) return
  for (const declar of declars) {
    scope2.push(declar)
  }
  return result
}
var toStatement$1 = {}
Object.defineProperty(toStatement$1, '__esModule', {
  value: true,
})
toStatement$1.default = void 0
var _generated$9 = generated$4
var _generated2 = generated$3
var _default$a = toStatement
toStatement$1.default = _default$a
function toStatement(node2, ignore) {
  if ((0, _generated$9.isStatement)(node2)) {
    return node2
  }
  let mustHaveId = false
  let newType
  if ((0, _generated$9.isClass)(node2)) {
    mustHaveId = true
    newType = 'ClassDeclaration'
  } else if ((0, _generated$9.isFunction)(node2)) {
    mustHaveId = true
    newType = 'FunctionDeclaration'
  } else if ((0, _generated$9.isAssignmentExpression)(node2)) {
    return (0, _generated2.expressionStatement)(node2)
  }
  if (mustHaveId && !node2.id) {
    newType = false
  }
  if (!newType) {
    if (ignore) {
      return false
    } else {
      throw new Error(`cannot turn ${node2.type} to a statement`)
    }
  }
  node2.type = newType
  return node2
}
var valueToNode$1 = {}
Object.defineProperty(valueToNode$1, '__esModule', {
  value: true,
})
valueToNode$1.default = void 0
var _isValidIdentifier$1 = isValidIdentifier$1
var _generated$8 = generated$3
var _default$9 = valueToNode
valueToNode$1.default = _default$9
const objectToString = Function.call.bind(Object.prototype.toString)
function isRegExp(value) {
  return objectToString(value) === '[object RegExp]'
}
function isPlainObject$2(value) {
  if (typeof value !== 'object' || value === null || Object.prototype.toString.call(value) !== '[object Object]') {
    return false
  }
  const proto2 = Object.getPrototypeOf(value)
  return proto2 === null || Object.getPrototypeOf(proto2) === null
}
function valueToNode(value) {
  if (value === void 0) {
    return (0, _generated$8.identifier)('undefined')
  }
  if (value === true || value === false) {
    return (0, _generated$8.booleanLiteral)(value)
  }
  if (value === null) {
    return (0, _generated$8.nullLiteral)()
  }
  if (typeof value === 'string') {
    return (0, _generated$8.stringLiteral)(value)
  }
  if (typeof value === 'number') {
    let result
    if (Number.isFinite(value)) {
      result = (0, _generated$8.numericLiteral)(Math.abs(value))
    } else {
      let numerator
      if (Number.isNaN(value)) {
        numerator = (0, _generated$8.numericLiteral)(0)
      } else {
        numerator = (0, _generated$8.numericLiteral)(1)
      }
      result = (0, _generated$8.binaryExpression)('/', numerator, (0, _generated$8.numericLiteral)(0))
    }
    if (value < 0 || Object.is(value, -0)) {
      result = (0, _generated$8.unaryExpression)('-', result)
    }
    return result
  }
  if (isRegExp(value)) {
    const pattern = value.source
    const flags = value.toString().match(/\/([a-z]+|)$/)[1]
    return (0, _generated$8.regExpLiteral)(pattern, flags)
  }
  if (Array.isArray(value)) {
    return (0, _generated$8.arrayExpression)(value.map(valueToNode))
  }
  if (isPlainObject$2(value)) {
    const props2 = []
    for (const key of Object.keys(value)) {
      let nodeKey
      if ((0, _isValidIdentifier$1.default)(key)) {
        nodeKey = (0, _generated$8.identifier)(key)
      } else {
        nodeKey = (0, _generated$8.stringLiteral)(key)
      }
      props2.push((0, _generated$8.objectProperty)(nodeKey, valueToNode(value[key])))
    }
    return (0, _generated$8.objectExpression)(props2)
  }
  throw new Error("don't know how to turn this value into a node")
}
var appendToMemberExpression$1 = {}
Object.defineProperty(appendToMemberExpression$1, '__esModule', {
  value: true,
})
appendToMemberExpression$1.default = appendToMemberExpression
var _generated$7 = generated$3
function appendToMemberExpression(member, append, computed2 = false) {
  member.object = (0, _generated$7.memberExpression)(member.object, member.property, member.computed)
  member.property = append
  member.computed = !!computed2
  return member
}
var inherits$1 = {}
Object.defineProperty(inherits$1, '__esModule', {
  value: true,
})
inherits$1.default = inherits
var _constants$2 = constants
var _inheritsComments = inheritsComments$2
function inherits(child, parent) {
  if (!child || !parent) return child
  for (const key of _constants$2.INHERIT_KEYS.optional) {
    if (child[key] == null) {
      child[key] = parent[key]
    }
  }
  for (const key of Object.keys(parent)) {
    if (key[0] === '_' && key !== '__clone') child[key] = parent[key]
  }
  for (const key of _constants$2.INHERIT_KEYS.force) {
    child[key] = parent[key]
  }
  ;(0, _inheritsComments.default)(child, parent)
  return child
}
var prependToMemberExpression$1 = {}
Object.defineProperty(prependToMemberExpression$1, '__esModule', {
  value: true,
})
prependToMemberExpression$1.default = prependToMemberExpression
var _generated$6 = generated$3
function prependToMemberExpression(member, prepend) {
  member.object = (0, _generated$6.memberExpression)(prepend, member.object)
  return member
}
var getOuterBindingIdentifiers$2 = {}
Object.defineProperty(getOuterBindingIdentifiers$2, '__esModule', {
  value: true,
})
getOuterBindingIdentifiers$2.default = void 0
var _getBindingIdentifiers$2 = getBindingIdentifiers$3
var _default$8 = getOuterBindingIdentifiers$1
getOuterBindingIdentifiers$2.default = _default$8
function getOuterBindingIdentifiers$1(node2, duplicates) {
  return (0, _getBindingIdentifiers$2.default)(node2, duplicates, true)
}
var traverse$3 = {}
Object.defineProperty(traverse$3, '__esModule', {
  value: true,
})
traverse$3.default = traverse$2
var _definitions$1 = definitions
function traverse$2(node2, handlers, state) {
  if (typeof handlers === 'function') {
    handlers = {
      enter: handlers,
    }
  }
  const { enter, exit } = handlers
  traverseSimpleImpl(node2, enter, exit, state, [])
}
function traverseSimpleImpl(node2, enter, exit, state, ancestors) {
  const keys = _definitions$1.VISITOR_KEYS[node2.type]
  if (!keys) return
  if (enter) enter(node2, ancestors, state)
  for (const key of keys) {
    const subNode = node2[key]
    if (Array.isArray(subNode)) {
      for (let i = 0; i < subNode.length; i++) {
        const child = subNode[i]
        if (!child) continue
        ancestors.push({
          node: node2,
          key,
          index: i,
        })
        traverseSimpleImpl(child, enter, exit, state, ancestors)
        ancestors.pop()
      }
    } else if (subNode) {
      ancestors.push({
        node: node2,
        key,
      })
      traverseSimpleImpl(subNode, enter, exit, state, ancestors)
      ancestors.pop()
    }
  }
  if (exit) exit(node2, ancestors, state)
}
var isBinding$2 = {}
Object.defineProperty(isBinding$2, '__esModule', {
  value: true,
})
isBinding$2.default = isBinding$1
var _getBindingIdentifiers$1 = getBindingIdentifiers$3
function isBinding$1(node2, parent, grandparent) {
  if (
    grandparent &&
    node2.type === 'Identifier' &&
    parent.type === 'ObjectProperty' &&
    grandparent.type === 'ObjectExpression'
  ) {
    return false
  }
  const keys = _getBindingIdentifiers$1.default.keys[parent.type]
  if (keys) {
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i]
      const val = parent[key]
      if (Array.isArray(val)) {
        if (val.indexOf(node2) >= 0) return true
      } else {
        if (val === node2) return true
      }
    }
  }
  return false
}
var isBlockScoped$2 = {}
var isLet$1 = {}
Object.defineProperty(isLet$1, '__esModule', {
  value: true,
})
isLet$1.default = isLet
var _generated$5 = generated$4
var _constants$1 = constants
function isLet(node2) {
  return (
    (0, _generated$5.isVariableDeclaration)(node2) && (node2.kind !== 'var' || node2[_constants$1.BLOCK_SCOPED_SYMBOL])
  )
}
Object.defineProperty(isBlockScoped$2, '__esModule', {
  value: true,
})
isBlockScoped$2.default = isBlockScoped$1
var _generated$4 = generated$4
var _isLet = isLet$1
function isBlockScoped$1(node2) {
  return (
    (0, _generated$4.isFunctionDeclaration)(node2) ||
    (0, _generated$4.isClassDeclaration)(node2) ||
    (0, _isLet.default)(node2)
  )
}
var isImmutable$1 = {}
Object.defineProperty(isImmutable$1, '__esModule', {
  value: true,
})
isImmutable$1.default = isImmutable
var _isType = isType$3
var _generated$3 = generated$4
function isImmutable(node2) {
  if ((0, _isType.default)(node2.type, 'Immutable')) return true
  if ((0, _generated$3.isIdentifier)(node2)) {
    if (node2.name === 'undefined') {
      return true
    } else {
      return false
    }
  }
  return false
}
var isNodesEquivalent$1 = {}
Object.defineProperty(isNodesEquivalent$1, '__esModule', {
  value: true,
})
isNodesEquivalent$1.default = isNodesEquivalent
var _definitions = definitions
function isNodesEquivalent(a, b) {
  if (typeof a !== 'object' || typeof b !== 'object' || a == null || b == null) {
    return a === b
  }
  if (a.type !== b.type) {
    return false
  }
  const fields = Object.keys(_definitions.NODE_FIELDS[a.type] || a.type)
  const visitorKeys = _definitions.VISITOR_KEYS[a.type]
  for (const field of fields) {
    if (typeof a[field] !== typeof b[field]) {
      return false
    }
    if (a[field] == null && b[field] == null) {
      continue
    } else if (a[field] == null || b[field] == null) {
      return false
    }
    if (Array.isArray(a[field])) {
      if (!Array.isArray(b[field])) {
        return false
      }
      if (a[field].length !== b[field].length) {
        return false
      }
      for (let i = 0; i < a[field].length; i++) {
        if (!isNodesEquivalent(a[field][i], b[field][i])) {
          return false
        }
      }
      continue
    }
    if (typeof a[field] === 'object' && !(visitorKeys != null && visitorKeys.includes(field))) {
      for (const key of Object.keys(a[field])) {
        if (a[field][key] !== b[field][key]) {
          return false
        }
      }
      continue
    }
    if (!isNodesEquivalent(a[field], b[field])) {
      return false
    }
  }
  return true
}
var isReferenced$2 = {}
Object.defineProperty(isReferenced$2, '__esModule', {
  value: true,
})
isReferenced$2.default = isReferenced$1
function isReferenced$1(node2, parent, grandparent) {
  switch (parent.type) {
    case 'MemberExpression':
    case 'OptionalMemberExpression':
      if (parent.property === node2) {
        return !!parent.computed
      }
      return parent.object === node2
    case 'JSXMemberExpression':
      return parent.object === node2
    case 'VariableDeclarator':
      return parent.init === node2
    case 'ArrowFunctionExpression':
      return parent.body === node2
    case 'PrivateName':
      return false
    case 'ClassMethod':
    case 'ClassPrivateMethod':
    case 'ObjectMethod':
      if (parent.key === node2) {
        return !!parent.computed
      }
      return false
    case 'ObjectProperty':
      if (parent.key === node2) {
        return !!parent.computed
      }
      return !grandparent || grandparent.type !== 'ObjectPattern'
    case 'ClassProperty':
    case 'ClassAccessorProperty':
      if (parent.key === node2) {
        return !!parent.computed
      }
      return true
    case 'ClassPrivateProperty':
      return parent.key !== node2
    case 'ClassDeclaration':
    case 'ClassExpression':
      return parent.superClass === node2
    case 'AssignmentExpression':
      return parent.right === node2
    case 'AssignmentPattern':
      return parent.right === node2
    case 'LabeledStatement':
      return false
    case 'CatchClause':
      return false
    case 'RestElement':
      return false
    case 'BreakStatement':
    case 'ContinueStatement':
      return false
    case 'FunctionDeclaration':
    case 'FunctionExpression':
      return false
    case 'ExportNamespaceSpecifier':
    case 'ExportDefaultSpecifier':
      return false
    case 'ExportSpecifier':
      if (grandparent != null && grandparent.source) {
        return false
      }
      return parent.local === node2
    case 'ImportDefaultSpecifier':
    case 'ImportNamespaceSpecifier':
    case 'ImportSpecifier':
      return false
    case 'ImportAttribute':
      return false
    case 'JSXAttribute':
      return false
    case 'ObjectPattern':
    case 'ArrayPattern':
      return false
    case 'MetaProperty':
      return false
    case 'ObjectTypeProperty':
      return parent.key !== node2
    case 'TSEnumMember':
      return parent.id !== node2
    case 'TSPropertySignature':
      if (parent.key === node2) {
        return !!parent.computed
      }
      return true
  }
  return true
}
var isScope$2 = {}
Object.defineProperty(isScope$2, '__esModule', {
  value: true,
})
isScope$2.default = isScope$1
var _generated$2 = generated$4
function isScope$1(node2, parent) {
  if (
    (0, _generated$2.isBlockStatement)(node2) &&
    ((0, _generated$2.isFunction)(parent) || (0, _generated$2.isCatchClause)(parent))
  ) {
    return false
  }
  if (
    (0, _generated$2.isPattern)(node2) &&
    ((0, _generated$2.isFunction)(parent) || (0, _generated$2.isCatchClause)(parent))
  ) {
    return true
  }
  return (0, _generated$2.isScopable)(node2)
}
var isSpecifierDefault$1 = {}
Object.defineProperty(isSpecifierDefault$1, '__esModule', {
  value: true,
})
isSpecifierDefault$1.default = isSpecifierDefault
var _generated$1 = generated$4
function isSpecifierDefault(specifier) {
  return (
    (0, _generated$1.isImportDefaultSpecifier)(specifier) ||
    (0, _generated$1.isIdentifier)(specifier.imported || specifier.exported, {
      name: 'default',
    })
  )
}
var isValidES3Identifier$1 = {}
Object.defineProperty(isValidES3Identifier$1, '__esModule', {
  value: true,
})
isValidES3Identifier$1.default = isValidES3Identifier
var _isValidIdentifier = isValidIdentifier$1
const RESERVED_WORDS_ES3_ONLY = /* @__PURE__ */ new Set([
  'abstract',
  'boolean',
  'byte',
  'char',
  'double',
  'enum',
  'final',
  'float',
  'goto',
  'implements',
  'int',
  'interface',
  'long',
  'native',
  'package',
  'private',
  'protected',
  'public',
  'short',
  'static',
  'synchronized',
  'throws',
  'transient',
  'volatile',
])
function isValidES3Identifier(name) {
  return (0, _isValidIdentifier.default)(name) && !RESERVED_WORDS_ES3_ONLY.has(name)
}
var isVar$2 = {}
Object.defineProperty(isVar$2, '__esModule', {
  value: true,
})
isVar$2.default = isVar$1
var _generated = generated$4
var _constants = constants
function isVar$1(node2) {
  return (
    (0, _generated.isVariableDeclaration)(node2, {
      kind: 'var',
    }) && !node2[_constants.BLOCK_SCOPED_SYMBOL]
  )
}
var generated = /* @__PURE__ */ Object.freeze(
  /* @__PURE__ */ Object.defineProperty(
    {
      __proto__: null,
    },
    Symbol.toStringTag,
    { value: 'Module' }
  )
)
var require$$65 = /* @__PURE__ */ getAugmentedNamespace(generated)
;(function (exports) {
  Object.defineProperty(exports, '__esModule', {
    value: true,
  })
  var _exportNames = {
    react: true,
    assertNode: true,
    createTypeAnnotationBasedOnTypeof: true,
    createUnionTypeAnnotation: true,
    createFlowUnionType: true,
    createTSUnionType: true,
    cloneNode: true,
    clone: true,
    cloneDeep: true,
    cloneDeepWithoutLoc: true,
    cloneWithoutLoc: true,
    addComment: true,
    addComments: true,
    inheritInnerComments: true,
    inheritLeadingComments: true,
    inheritsComments: true,
    inheritTrailingComments: true,
    removeComments: true,
    ensureBlock: true,
    toBindingIdentifierName: true,
    toBlock: true,
    toComputedKey: true,
    toExpression: true,
    toIdentifier: true,
    toKeyAlias: true,
    toSequenceExpression: true,
    toStatement: true,
    valueToNode: true,
    appendToMemberExpression: true,
    inherits: true,
    prependToMemberExpression: true,
    removeProperties: true,
    removePropertiesDeep: true,
    removeTypeDuplicates: true,
    getBindingIdentifiers: true,
    getOuterBindingIdentifiers: true,
    traverse: true,
    traverseFast: true,
    shallowEqual: true,
    is: true,
    isBinding: true,
    isBlockScoped: true,
    isImmutable: true,
    isLet: true,
    isNode: true,
    isNodesEquivalent: true,
    isPlaceholderType: true,
    isReferenced: true,
    isScope: true,
    isSpecifierDefault: true,
    isType: true,
    isValidES3Identifier: true,
    isValidIdentifier: true,
    isVar: true,
    matchesPattern: true,
    validate: true,
    buildMatchMemberExpression: true,
  }
  Object.defineProperty(exports, 'addComment', {
    enumerable: true,
    get: function () {
      return _addComment2.default
    },
  })
  Object.defineProperty(exports, 'addComments', {
    enumerable: true,
    get: function () {
      return _addComments2.default
    },
  })
  Object.defineProperty(exports, 'appendToMemberExpression', {
    enumerable: true,
    get: function () {
      return _appendToMemberExpression.default
    },
  })
  Object.defineProperty(exports, 'assertNode', {
    enumerable: true,
    get: function () {
      return _assertNode.default
    },
  })
  Object.defineProperty(exports, 'buildMatchMemberExpression', {
    enumerable: true,
    get: function () {
      return _buildMatchMemberExpression2.default
    },
  })
  Object.defineProperty(exports, 'clone', {
    enumerable: true,
    get: function () {
      return _clone.default
    },
  })
  Object.defineProperty(exports, 'cloneDeep', {
    enumerable: true,
    get: function () {
      return _cloneDeep.default
    },
  })
  Object.defineProperty(exports, 'cloneDeepWithoutLoc', {
    enumerable: true,
    get: function () {
      return _cloneDeepWithoutLoc.default
    },
  })
  Object.defineProperty(exports, 'cloneNode', {
    enumerable: true,
    get: function () {
      return _cloneNode2.default
    },
  })
  Object.defineProperty(exports, 'cloneWithoutLoc', {
    enumerable: true,
    get: function () {
      return _cloneWithoutLoc.default
    },
  })
  Object.defineProperty(exports, 'createFlowUnionType', {
    enumerable: true,
    get: function () {
      return _createFlowUnionType.default
    },
  })
  Object.defineProperty(exports, 'createTSUnionType', {
    enumerable: true,
    get: function () {
      return _createTSUnionType.default
    },
  })
  Object.defineProperty(exports, 'createTypeAnnotationBasedOnTypeof', {
    enumerable: true,
    get: function () {
      return _createTypeAnnotationBasedOnTypeof.default
    },
  })
  Object.defineProperty(exports, 'createUnionTypeAnnotation', {
    enumerable: true,
    get: function () {
      return _createFlowUnionType.default
    },
  })
  Object.defineProperty(exports, 'ensureBlock', {
    enumerable: true,
    get: function () {
      return _ensureBlock.default
    },
  })
  Object.defineProperty(exports, 'getBindingIdentifiers', {
    enumerable: true,
    get: function () {
      return _getBindingIdentifiers2.default
    },
  })
  Object.defineProperty(exports, 'getOuterBindingIdentifiers', {
    enumerable: true,
    get: function () {
      return _getOuterBindingIdentifiers2.default
    },
  })
  Object.defineProperty(exports, 'inheritInnerComments', {
    enumerable: true,
    get: function () {
      return _inheritInnerComments2.default
    },
  })
  Object.defineProperty(exports, 'inheritLeadingComments', {
    enumerable: true,
    get: function () {
      return _inheritLeadingComments2.default
    },
  })
  Object.defineProperty(exports, 'inheritTrailingComments', {
    enumerable: true,
    get: function () {
      return _inheritTrailingComments2.default
    },
  })
  Object.defineProperty(exports, 'inherits', {
    enumerable: true,
    get: function () {
      return _inherits.default
    },
  })
  Object.defineProperty(exports, 'inheritsComments', {
    enumerable: true,
    get: function () {
      return _inheritsComments2.default
    },
  })
  Object.defineProperty(exports, 'is', {
    enumerable: true,
    get: function () {
      return _is2.default
    },
  })
  Object.defineProperty(exports, 'isBinding', {
    enumerable: true,
    get: function () {
      return _isBinding.default
    },
  })
  Object.defineProperty(exports, 'isBlockScoped', {
    enumerable: true,
    get: function () {
      return _isBlockScoped.default
    },
  })
  Object.defineProperty(exports, 'isImmutable', {
    enumerable: true,
    get: function () {
      return _isImmutable.default
    },
  })
  Object.defineProperty(exports, 'isLet', {
    enumerable: true,
    get: function () {
      return _isLet2.default
    },
  })
  Object.defineProperty(exports, 'isNode', {
    enumerable: true,
    get: function () {
      return _isNode2.default
    },
  })
  Object.defineProperty(exports, 'isNodesEquivalent', {
    enumerable: true,
    get: function () {
      return _isNodesEquivalent.default
    },
  })
  Object.defineProperty(exports, 'isPlaceholderType', {
    enumerable: true,
    get: function () {
      return _isPlaceholderType2.default
    },
  })
  Object.defineProperty(exports, 'isReferenced', {
    enumerable: true,
    get: function () {
      return _isReferenced.default
    },
  })
  Object.defineProperty(exports, 'isScope', {
    enumerable: true,
    get: function () {
      return _isScope.default
    },
  })
  Object.defineProperty(exports, 'isSpecifierDefault', {
    enumerable: true,
    get: function () {
      return _isSpecifierDefault.default
    },
  })
  Object.defineProperty(exports, 'isType', {
    enumerable: true,
    get: function () {
      return _isType2.default
    },
  })
  Object.defineProperty(exports, 'isValidES3Identifier', {
    enumerable: true,
    get: function () {
      return _isValidES3Identifier.default
    },
  })
  Object.defineProperty(exports, 'isValidIdentifier', {
    enumerable: true,
    get: function () {
      return _isValidIdentifier2.default
    },
  })
  Object.defineProperty(exports, 'isVar', {
    enumerable: true,
    get: function () {
      return _isVar.default
    },
  })
  Object.defineProperty(exports, 'matchesPattern', {
    enumerable: true,
    get: function () {
      return _matchesPattern2.default
    },
  })
  Object.defineProperty(exports, 'prependToMemberExpression', {
    enumerable: true,
    get: function () {
      return _prependToMemberExpression.default
    },
  })
  exports.react = void 0
  Object.defineProperty(exports, 'removeComments', {
    enumerable: true,
    get: function () {
      return _removeComments.default
    },
  })
  Object.defineProperty(exports, 'removeProperties', {
    enumerable: true,
    get: function () {
      return _removeProperties2.default
    },
  })
  Object.defineProperty(exports, 'removePropertiesDeep', {
    enumerable: true,
    get: function () {
      return _removePropertiesDeep2.default
    },
  })
  Object.defineProperty(exports, 'removeTypeDuplicates', {
    enumerable: true,
    get: function () {
      return _removeTypeDuplicates2.default
    },
  })
  Object.defineProperty(exports, 'shallowEqual', {
    enumerable: true,
    get: function () {
      return _shallowEqual2.default
    },
  })
  Object.defineProperty(exports, 'toBindingIdentifierName', {
    enumerable: true,
    get: function () {
      return _toBindingIdentifierName.default
    },
  })
  Object.defineProperty(exports, 'toBlock', {
    enumerable: true,
    get: function () {
      return _toBlock2.default
    },
  })
  Object.defineProperty(exports, 'toComputedKey', {
    enumerable: true,
    get: function () {
      return _toComputedKey.default
    },
  })
  Object.defineProperty(exports, 'toExpression', {
    enumerable: true,
    get: function () {
      return _toExpression.default
    },
  })
  Object.defineProperty(exports, 'toIdentifier', {
    enumerable: true,
    get: function () {
      return _toIdentifier2.default
    },
  })
  Object.defineProperty(exports, 'toKeyAlias', {
    enumerable: true,
    get: function () {
      return _toKeyAlias.default
    },
  })
  Object.defineProperty(exports, 'toSequenceExpression', {
    enumerable: true,
    get: function () {
      return _toSequenceExpression.default
    },
  })
  Object.defineProperty(exports, 'toStatement', {
    enumerable: true,
    get: function () {
      return _toStatement.default
    },
  })
  Object.defineProperty(exports, 'traverse', {
    enumerable: true,
    get: function () {
      return _traverse.default
    },
  })
  Object.defineProperty(exports, 'traverseFast', {
    enumerable: true,
    get: function () {
      return _traverseFast2.default
    },
  })
  Object.defineProperty(exports, 'validate', {
    enumerable: true,
    get: function () {
      return _validate2.default
    },
  })
  Object.defineProperty(exports, 'valueToNode', {
    enumerable: true,
    get: function () {
      return _valueToNode.default
    },
  })
  var _isReactComponent = isReactComponent$1
  var _isCompatTag = isCompatTag$2
  var _buildChildren = buildChildren$1
  var _assertNode = assertNode$1
  var _generated3 = generated$2
  Object.keys(_generated3).forEach(function (key) {
    if (key === 'default' || key === '__esModule') return
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return
    if (key in exports && exports[key] === _generated3[key]) return
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _generated3[key]
      },
    })
  })
  var _createTypeAnnotationBasedOnTypeof = createTypeAnnotationBasedOnTypeof$2
  var _createFlowUnionType = createFlowUnionType$2
  var _createTSUnionType = createTSUnionType$2
  var _generated22 = generated$3
  Object.keys(_generated22).forEach(function (key) {
    if (key === 'default' || key === '__esModule') return
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return
    if (key in exports && exports[key] === _generated22[key]) return
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _generated22[key]
      },
    })
  })
  var _uppercase = uppercase
  Object.keys(_uppercase).forEach(function (key) {
    if (key === 'default' || key === '__esModule') return
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return
    if (key in exports && exports[key] === _uppercase[key]) return
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _uppercase[key]
      },
    })
  })
  var _cloneNode2 = cloneNode$8
  var _clone = clone$2
  var _cloneDeep = cloneDeep$1
  var _cloneDeepWithoutLoc = cloneDeepWithoutLoc$1
  var _cloneWithoutLoc = cloneWithoutLoc$1
  var _addComment2 = addComment$2
  var _addComments2 = addComments$2
  var _inheritInnerComments2 = inheritInnerComments$1
  var _inheritLeadingComments2 = inheritLeadingComments$2
  var _inheritsComments2 = inheritsComments$2
  var _inheritTrailingComments2 = inheritTrailingComments$2
  var _removeComments = removeComments$2
  var _generated32 = generated$1
  Object.keys(_generated32).forEach(function (key) {
    if (key === 'default' || key === '__esModule') return
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return
    if (key in exports && exports[key] === _generated32[key]) return
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _generated32[key]
      },
    })
  })
  var _constants2 = constants
  Object.keys(_constants2).forEach(function (key) {
    if (key === 'default' || key === '__esModule') return
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return
    if (key in exports && exports[key] === _constants2[key]) return
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _constants2[key]
      },
    })
  })
  var _ensureBlock = ensureBlock$2
  var _toBindingIdentifierName = toBindingIdentifierName$2
  var _toBlock2 = toBlock$1
  var _toComputedKey = toComputedKey$2
  var _toExpression = toExpression$2
  var _toIdentifier2 = toIdentifier$2
  var _toKeyAlias = toKeyAlias$1
  var _toSequenceExpression = toSequenceExpression$2
  var _toStatement = toStatement$1
  var _valueToNode = valueToNode$1
  var _definitions2 = definitions
  Object.keys(_definitions2).forEach(function (key) {
    if (key === 'default' || key === '__esModule') return
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return
    if (key in exports && exports[key] === _definitions2[key]) return
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _definitions2[key]
      },
    })
  })
  var _appendToMemberExpression = appendToMemberExpression$1
  var _inherits = inherits$1
  var _prependToMemberExpression = prependToMemberExpression$1
  var _removeProperties2 = removeProperties$1
  var _removePropertiesDeep2 = removePropertiesDeep$2
  var _removeTypeDuplicates2 = removeTypeDuplicates$3
  var _getBindingIdentifiers2 = getBindingIdentifiers$3
  var _getOuterBindingIdentifiers2 = getOuterBindingIdentifiers$2
  var _traverse = traverse$3
  Object.keys(_traverse).forEach(function (key) {
    if (key === 'default' || key === '__esModule') return
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return
    if (key in exports && exports[key] === _traverse[key]) return
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _traverse[key]
      },
    })
  })
  var _traverseFast2 = traverseFast$1
  var _shallowEqual2 = shallowEqual$1
  var _is2 = is$2
  var _isBinding = isBinding$2
  var _isBlockScoped = isBlockScoped$2
  var _isImmutable = isImmutable$1
  var _isLet2 = isLet$1
  var _isNode2 = isNode$1
  var _isNodesEquivalent = isNodesEquivalent$1
  var _isPlaceholderType2 = isPlaceholderType$1
  var _isReferenced = isReferenced$2
  var _isScope = isScope$2
  var _isSpecifierDefault = isSpecifierDefault$1
  var _isType2 = isType$3
  var _isValidES3Identifier = isValidES3Identifier$1
  var _isValidIdentifier2 = isValidIdentifier$1
  var _isVar = isVar$2
  var _matchesPattern2 = matchesPattern$3
  var _validate2 = validate$6
  var _buildMatchMemberExpression2 = buildMatchMemberExpression$1
  var _generated4 = generated$4
  Object.keys(_generated4).forEach(function (key) {
    if (key === 'default' || key === '__esModule') return
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return
    if (key in exports && exports[key] === _generated4[key]) return
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _generated4[key]
      },
    })
  })
  var _generated5 = require$$65
  Object.keys(_generated5).forEach(function (key) {
    if (key === 'default' || key === '__esModule') return
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return
    if (key in exports && exports[key] === _generated5[key]) return
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _generated5[key]
      },
    })
  })
  const react2 = {
    isReactComponent: _isReactComponent.default,
    isCompatTag: _isCompatTag.default,
    buildChildren: _buildChildren.default,
  }
  exports.react = react2
})(lib$b)
Object.defineProperty(virtualTypes$2, '__esModule', {
  value: true,
})
virtualTypes$2.Var =
  virtualTypes$2.User =
  virtualTypes$2.Statement =
  virtualTypes$2.SpreadProperty =
  virtualTypes$2.Scope =
  virtualTypes$2.RestProperty =
  virtualTypes$2.ReferencedMemberExpression =
  virtualTypes$2.ReferencedIdentifier =
  virtualTypes$2.Referenced =
  virtualTypes$2.Pure =
  virtualTypes$2.NumericLiteralTypeAnnotation =
  virtualTypes$2.Generated =
  virtualTypes$2.ForAwaitStatement =
  virtualTypes$2.Flow =
  virtualTypes$2.Expression =
  virtualTypes$2.ExistentialTypeParam =
  virtualTypes$2.BlockScoped =
  virtualTypes$2.BindingIdentifier =
    void 0
var _t$v = lib$b
const {
  isBinding,
  isBlockScoped,
  isExportDeclaration: isExportDeclaration$1,
  isExpression: isExpression$3,
  isFlow,
  isForStatement: isForStatement$2,
  isForXStatement,
  isIdentifier: isIdentifier$a,
  isImportDeclaration: isImportDeclaration$1,
  isImportSpecifier,
  isJSXIdentifier: isJSXIdentifier$1,
  isJSXMemberExpression,
  isMemberExpression: isMemberExpression$4,
  isReferenced,
  isScope,
  isStatement: isStatement$5,
  isVar,
  isVariableDeclaration: isVariableDeclaration$1,
  react: react$1,
} = _t$v
const { isCompatTag } = react$1
const ReferencedIdentifier = {
  types: ['Identifier', 'JSXIdentifier'],
  checkPath(path2, opts) {
    const { node: node2, parent } = path2
    if (!isIdentifier$a(node2, opts) && !isJSXMemberExpression(parent, opts)) {
      if (isJSXIdentifier$1(node2, opts)) {
        if (isCompatTag(node2.name)) return false
      } else {
        return false
      }
    }
    return isReferenced(node2, parent, path2.parentPath.parent)
  },
}
virtualTypes$2.ReferencedIdentifier = ReferencedIdentifier
const ReferencedMemberExpression = {
  types: ['MemberExpression'],
  checkPath({ node: node2, parent }) {
    return isMemberExpression$4(node2) && isReferenced(node2, parent)
  },
}
virtualTypes$2.ReferencedMemberExpression = ReferencedMemberExpression
const BindingIdentifier = {
  types: ['Identifier'],
  checkPath(path2) {
    const { node: node2, parent } = path2
    const grandparent = path2.parentPath.parent
    return isIdentifier$a(node2) && isBinding(node2, parent, grandparent)
  },
}
virtualTypes$2.BindingIdentifier = BindingIdentifier
const Statement = {
  types: ['Statement'],
  checkPath({ node: node2, parent }) {
    if (isStatement$5(node2)) {
      if (isVariableDeclaration$1(node2)) {
        if (
          isForXStatement(parent, {
            left: node2,
          })
        )
          return false
        if (
          isForStatement$2(parent, {
            init: node2,
          })
        )
          return false
      }
      return true
    } else {
      return false
    }
  },
}
virtualTypes$2.Statement = Statement
const Expression = {
  types: ['Expression'],
  checkPath(path2) {
    if (path2.isIdentifier()) {
      return path2.isReferencedIdentifier()
    } else {
      return isExpression$3(path2.node)
    }
  },
}
virtualTypes$2.Expression = Expression
const Scope$3 = {
  types: ['Scopable', 'Pattern'],
  checkPath(path2) {
    return isScope(path2.node, path2.parent)
  },
}
virtualTypes$2.Scope = Scope$3
const Referenced = {
  checkPath(path2) {
    return isReferenced(path2.node, path2.parent)
  },
}
virtualTypes$2.Referenced = Referenced
const BlockScoped = {
  checkPath(path2) {
    return isBlockScoped(path2.node)
  },
}
virtualTypes$2.BlockScoped = BlockScoped
const Var = {
  types: ['VariableDeclaration'],
  checkPath(path2) {
    return isVar(path2.node)
  },
}
virtualTypes$2.Var = Var
const User = {
  checkPath(path2) {
    return path2.node && !!path2.node.loc
  },
}
virtualTypes$2.User = User
const Generated = {
  checkPath(path2) {
    return !path2.isUser()
  },
}
virtualTypes$2.Generated = Generated
const Pure = {
  checkPath(path2, constantsOnly) {
    return path2.scope.isPure(path2.node, constantsOnly)
  },
}
virtualTypes$2.Pure = Pure
const Flow = {
  types: ['Flow', 'ImportDeclaration', 'ExportDeclaration', 'ImportSpecifier'],
  checkPath({ node: node2 }) {
    if (isFlow(node2)) {
      return true
    } else if (isImportDeclaration$1(node2)) {
      return node2.importKind === 'type' || node2.importKind === 'typeof'
    } else if (isExportDeclaration$1(node2)) {
      return node2.exportKind === 'type'
    } else if (isImportSpecifier(node2)) {
      return node2.importKind === 'type' || node2.importKind === 'typeof'
    } else {
      return false
    }
  },
}
virtualTypes$2.Flow = Flow
const RestProperty = {
  types: ['RestElement'],
  checkPath(path2) {
    return path2.parentPath && path2.parentPath.isObjectPattern()
  },
}
virtualTypes$2.RestProperty = RestProperty
const SpreadProperty = {
  types: ['RestElement'],
  checkPath(path2) {
    return path2.parentPath && path2.parentPath.isObjectExpression()
  },
}
virtualTypes$2.SpreadProperty = SpreadProperty
const ExistentialTypeParam = {
  types: ['ExistsTypeAnnotation'],
}
virtualTypes$2.ExistentialTypeParam = ExistentialTypeParam
const NumericLiteralTypeAnnotation = {
  types: ['NumberLiteralTypeAnnotation'],
}
virtualTypes$2.NumericLiteralTypeAnnotation = NumericLiteralTypeAnnotation
const ForAwaitStatement = {
  types: ['ForOfStatement'],
  checkPath({ node: node2 }) {
    return node2.await === true
  },
}
virtualTypes$2.ForAwaitStatement = ForAwaitStatement
Object.defineProperty(visitors, '__esModule', {
  value: true,
})
visitors.explode = explode
visitors.merge = merge$2
visitors.verify = verify
var virtualTypes$1 = virtualTypes$2
var _t$u = lib$b
const { DEPRECATED_KEYS, FLIPPED_ALIAS_KEYS: FLIPPED_ALIAS_KEYS$2, TYPES } = _t$u
function explode(visitor2) {
  if (visitor2._exploded) return visitor2
  visitor2._exploded = true
  for (const nodeType of Object.keys(visitor2)) {
    if (shouldIgnoreKey(nodeType)) continue
    const parts = nodeType.split('|')
    if (parts.length === 1) continue
    const fns = visitor2[nodeType]
    delete visitor2[nodeType]
    for (const part of parts) {
      visitor2[part] = fns
    }
  }
  verify(visitor2)
  delete visitor2.__esModule
  ensureEntranceObjects(visitor2)
  ensureCallbackArrays(visitor2)
  for (const nodeType of Object.keys(visitor2)) {
    if (shouldIgnoreKey(nodeType)) continue
    const wrapper3 = virtualTypes$1[nodeType]
    if (!wrapper3) continue
    const fns = visitor2[nodeType]
    for (const type of Object.keys(fns)) {
      fns[type] = wrapCheck(wrapper3, fns[type])
    }
    delete visitor2[nodeType]
    if (wrapper3.types) {
      for (const type of wrapper3.types) {
        if (visitor2[type]) {
          mergePair(visitor2[type], fns)
        } else {
          visitor2[type] = fns
        }
      }
    } else {
      mergePair(visitor2, fns)
    }
  }
  for (const nodeType of Object.keys(visitor2)) {
    if (shouldIgnoreKey(nodeType)) continue
    const fns = visitor2[nodeType]
    let aliases = FLIPPED_ALIAS_KEYS$2[nodeType]
    const deprecatedKey = DEPRECATED_KEYS[nodeType]
    if (deprecatedKey) {
      console.trace(`Visitor defined for ${nodeType} but it has been renamed to ${deprecatedKey}`)
      aliases = [deprecatedKey]
    }
    if (!aliases) continue
    delete visitor2[nodeType]
    for (const alias of aliases) {
      const existing = visitor2[alias]
      if (existing) {
        mergePair(existing, fns)
      } else {
        visitor2[alias] = Object.assign({}, fns)
      }
    }
  }
  for (const nodeType of Object.keys(visitor2)) {
    if (shouldIgnoreKey(nodeType)) continue
    ensureCallbackArrays(visitor2[nodeType])
  }
  return visitor2
}
function verify(visitor2) {
  if (visitor2._verified) return
  if (typeof visitor2 === 'function') {
    throw new Error(
      "You passed `traverse()` a function when it expected a visitor object, are you sure you didn't mean `{ enter: Function }`?"
    )
  }
  for (const nodeType of Object.keys(visitor2)) {
    if (nodeType === 'enter' || nodeType === 'exit') {
      validateVisitorMethods(nodeType, visitor2[nodeType])
    }
    if (shouldIgnoreKey(nodeType)) continue
    if (TYPES.indexOf(nodeType) < 0) {
      throw new Error(`You gave us a visitor for the node type ${nodeType} but it's not a valid type`)
    }
    const visitors2 = visitor2[nodeType]
    if (typeof visitors2 === 'object') {
      for (const visitorKey of Object.keys(visitors2)) {
        if (visitorKey === 'enter' || visitorKey === 'exit') {
          validateVisitorMethods(`${nodeType}.${visitorKey}`, visitors2[visitorKey])
        } else {
          throw new Error(
            `You passed \`traverse()\` a visitor object with the property ${nodeType} that has the invalid property ${visitorKey}`
          )
        }
      }
    }
  }
  visitor2._verified = true
}
function validateVisitorMethods(path2, val) {
  const fns = [].concat(val)
  for (const fn of fns) {
    if (typeof fn !== 'function') {
      throw new TypeError(`Non-function found defined in ${path2} with type ${typeof fn}`)
    }
  }
}
function merge$2(visitors2, states = [], wrapper3) {
  const rootVisitor = {}
  for (let i = 0; i < visitors2.length; i++) {
    const visitor2 = visitors2[i]
    const state = states[i]
    explode(visitor2)
    for (const type of Object.keys(visitor2)) {
      let visitorType = visitor2[type]
      if (state || wrapper3) {
        visitorType = wrapWithStateOrWrapper(visitorType, state, wrapper3)
      }
      const nodeVisitor = (rootVisitor[type] = rootVisitor[type] || {})
      mergePair(nodeVisitor, visitorType)
    }
  }
  return rootVisitor
}
function wrapWithStateOrWrapper(oldVisitor, state, wrapper3) {
  const newVisitor = {}
  for (const key of Object.keys(oldVisitor)) {
    let fns = oldVisitor[key]
    if (!Array.isArray(fns)) continue
    fns = fns.map(function (fn) {
      let newFn = fn
      if (state) {
        newFn = function (path2) {
          return fn.call(state, path2, state)
        }
      }
      if (wrapper3) {
        newFn = wrapper3(state.key, key, newFn)
      }
      if (newFn !== fn) {
        newFn.toString = () => fn.toString()
      }
      return newFn
    })
    newVisitor[key] = fns
  }
  return newVisitor
}
function ensureEntranceObjects(obj) {
  for (const key of Object.keys(obj)) {
    if (shouldIgnoreKey(key)) continue
    const fns = obj[key]
    if (typeof fns === 'function') {
      obj[key] = {
        enter: fns,
      }
    }
  }
}
function ensureCallbackArrays(obj) {
  if (obj.enter && !Array.isArray(obj.enter)) obj.enter = [obj.enter]
  if (obj.exit && !Array.isArray(obj.exit)) obj.exit = [obj.exit]
}
function wrapCheck(wrapper3, fn) {
  const newFn = function (path2) {
    if (wrapper3.checkPath(path2)) {
      return fn.apply(this, arguments)
    }
  }
  newFn.toString = () => fn.toString()
  return newFn
}
function shouldIgnoreKey(key) {
  if (key[0] === '_') return true
  if (key === 'enter' || key === 'exit' || key === 'shouldSkip') return true
  if (key === 'denylist' || key === 'noScope' || key === 'skipKeys' || key === 'blacklist') {
    return true
  }
  return false
}
function mergePair(dest, src) {
  for (const key of Object.keys(src)) {
    dest[key] = [].concat(dest[key] || [], src[key])
  }
}
var cache = {}
Object.defineProperty(cache, '__esModule', {
  value: true,
})
cache.clear = clear$1
cache.clearPath = clearPath
cache.clearScope = clearScope
cache.scope = cache.path = void 0
let path$1 = /* @__PURE__ */ new WeakMap()
cache.path = path$1
let scope$1 = /* @__PURE__ */ new WeakMap()
cache.scope = scope$1
function clear$1() {
  clearPath()
  clearScope()
}
function clearPath() {
  cache.path = path$1 = /* @__PURE__ */ new WeakMap()
}
function clearScope() {
  cache.scope = scope$1 = /* @__PURE__ */ new WeakMap()
}
var traverseNode$1 = {}
var context$2 = {}
var path = {}
var browser$2 = { exports: {} }
var s = 1e3
var m = s * 60
var h = m * 60
var d = h * 24
var w = d * 7
var y = d * 365.25
var ms = function (val, options2) {
  options2 = options2 || {}
  var type = typeof val
  if (type === 'string' && val.length > 0) {
    return parse$3(val)
  } else if (type === 'number' && isFinite(val)) {
    return options2.long ? fmtLong(val) : fmtShort(val)
  }
  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val))
}
function parse$3(str) {
  str = String(str)
  if (str.length > 100) {
    return
  }
  var match =
    /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
      str
    )
  if (!match) {
    return
  }
  var n2 = parseFloat(match[1])
  var type = (match[2] || 'ms').toLowerCase()
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n2 * y
    case 'weeks':
    case 'week':
    case 'w':
      return n2 * w
    case 'days':
    case 'day':
    case 'd':
      return n2 * d
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n2 * h
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n2 * m
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n2 * s
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n2
    default:
      return void 0
  }
}
function fmtShort(ms2) {
  var msAbs = Math.abs(ms2)
  if (msAbs >= d) {
    return Math.round(ms2 / d) + 'd'
  }
  if (msAbs >= h) {
    return Math.round(ms2 / h) + 'h'
  }
  if (msAbs >= m) {
    return Math.round(ms2 / m) + 'm'
  }
  if (msAbs >= s) {
    return Math.round(ms2 / s) + 's'
  }
  return ms2 + 'ms'
}
function fmtLong(ms2) {
  var msAbs = Math.abs(ms2)
  if (msAbs >= d) {
    return plural(ms2, msAbs, d, 'day')
  }
  if (msAbs >= h) {
    return plural(ms2, msAbs, h, 'hour')
  }
  if (msAbs >= m) {
    return plural(ms2, msAbs, m, 'minute')
  }
  if (msAbs >= s) {
    return plural(ms2, msAbs, s, 'second')
  }
  return ms2 + ' ms'
}
function plural(ms2, msAbs, n2, name) {
  var isPlural = msAbs >= n2 * 1.5
  return Math.round(ms2 / n2) + ' ' + name + (isPlural ? 's' : '')
}
function setup$1(env) {
  createDebug.debug = createDebug
  createDebug.default = createDebug
  createDebug.coerce = coerce
  createDebug.disable = disable
  createDebug.enable = enable
  createDebug.enabled = enabled
  createDebug.humanize = ms
  createDebug.destroy = destroy
  Object.keys(env).forEach((key) => {
    createDebug[key] = env[key]
  })
  createDebug.names = []
  createDebug.skips = []
  createDebug.formatters = {}
  function selectColor(namespace) {
    let hash = 0
    for (let i = 0; i < namespace.length; i++) {
      hash = (hash << 5) - hash + namespace.charCodeAt(i)
      hash |= 0
    }
    return createDebug.colors[Math.abs(hash) % createDebug.colors.length]
  }
  createDebug.selectColor = selectColor
  function createDebug(namespace) {
    let prevTime
    let enableOverride = null
    let namespacesCache
    let enabledCache
    function debug2(...args) {
      if (!debug2.enabled) {
        return
      }
      const self2 = debug2
      const curr = Number(new Date())
      const ms2 = curr - (prevTime || curr)
      self2.diff = ms2
      self2.prev = prevTime
      self2.curr = curr
      prevTime = curr
      args[0] = createDebug.coerce(args[0])
      if (typeof args[0] !== 'string') {
        args.unshift('%O')
      }
      let index2 = 0
      args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
        if (match === '%%') {
          return '%'
        }
        index2++
        const formatter = createDebug.formatters[format]
        if (typeof formatter === 'function') {
          const val = args[index2]
          match = formatter.call(self2, val)
          args.splice(index2, 1)
          index2--
        }
        return match
      })
      createDebug.formatArgs.call(self2, args)
      const logFn = self2.log || createDebug.log
      logFn.apply(self2, args)
    }
    debug2.namespace = namespace
    debug2.useColors = createDebug.useColors()
    debug2.color = createDebug.selectColor(namespace)
    debug2.extend = extend2
    debug2.destroy = createDebug.destroy
    Object.defineProperty(debug2, 'enabled', {
      enumerable: true,
      configurable: false,
      get: () => {
        if (enableOverride !== null) {
          return enableOverride
        }
        if (namespacesCache !== createDebug.namespaces) {
          namespacesCache = createDebug.namespaces
          enabledCache = createDebug.enabled(namespace)
        }
        return enabledCache
      },
      set: (v) => {
        enableOverride = v
      },
    })
    if (typeof createDebug.init === 'function') {
      createDebug.init(debug2)
    }
    return debug2
  }
  function extend2(namespace, delimiter) {
    const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace)
    newDebug.log = this.log
    return newDebug
  }
  function enable(namespaces) {
    createDebug.save(namespaces)
    createDebug.namespaces = namespaces
    createDebug.names = []
    createDebug.skips = []
    let i
    const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/)
    const len = split.length
    for (i = 0; i < len; i++) {
      if (!split[i]) {
        continue
      }
      namespaces = split[i].replace(/\*/g, '.*?')
      if (namespaces[0] === '-') {
        createDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'))
      } else {
        createDebug.names.push(new RegExp('^' + namespaces + '$'))
      }
    }
  }
  function disable() {
    const namespaces = [
      ...createDebug.names.map(toNamespace),
      ...createDebug.skips.map(toNamespace).map((namespace) => '-' + namespace),
    ].join(',')
    createDebug.enable('')
    return namespaces
  }
  function enabled(name) {
    if (name[name.length - 1] === '*') {
      return true
    }
    let i
    let len
    for (i = 0, len = createDebug.skips.length; i < len; i++) {
      if (createDebug.skips[i].test(name)) {
        return false
      }
    }
    for (i = 0, len = createDebug.names.length; i < len; i++) {
      if (createDebug.names[i].test(name)) {
        return true
      }
    }
    return false
  }
  function toNamespace(regexp) {
    return regexp
      .toString()
      .substring(2, regexp.toString().length - 2)
      .replace(/\.\*\?$/, '*')
  }
  function coerce(val) {
    if (val instanceof Error) {
      return val.stack || val.message
    }
    return val
  }
  function destroy() {
    console.warn(
      'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'
    )
  }
  createDebug.enable(createDebug.load())
  return createDebug
}
var common$1 = setup$1
;(function (module, exports) {
  exports.formatArgs = formatArgs
  exports.save = save
  exports.load = load
  exports.useColors = useColors
  exports.storage = localstorage()
  exports.destroy = (() => {
    let warned = false
    return () => {
      if (!warned) {
        warned = true
        console.warn(
          'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'
        )
      }
    }
  })()
  exports.colors = [
    '#0000CC',
    '#0000FF',
    '#0033CC',
    '#0033FF',
    '#0066CC',
    '#0066FF',
    '#0099CC',
    '#0099FF',
    '#00CC00',
    '#00CC33',
    '#00CC66',
    '#00CC99',
    '#00CCCC',
    '#00CCFF',
    '#3300CC',
    '#3300FF',
    '#3333CC',
    '#3333FF',
    '#3366CC',
    '#3366FF',
    '#3399CC',
    '#3399FF',
    '#33CC00',
    '#33CC33',
    '#33CC66',
    '#33CC99',
    '#33CCCC',
    '#33CCFF',
    '#6600CC',
    '#6600FF',
    '#6633CC',
    '#6633FF',
    '#66CC00',
    '#66CC33',
    '#9900CC',
    '#9900FF',
    '#9933CC',
    '#9933FF',
    '#99CC00',
    '#99CC33',
    '#CC0000',
    '#CC0033',
    '#CC0066',
    '#CC0099',
    '#CC00CC',
    '#CC00FF',
    '#CC3300',
    '#CC3333',
    '#CC3366',
    '#CC3399',
    '#CC33CC',
    '#CC33FF',
    '#CC6600',
    '#CC6633',
    '#CC9900',
    '#CC9933',
    '#CCCC00',
    '#CCCC33',
    '#FF0000',
    '#FF0033',
    '#FF0066',
    '#FF0099',
    '#FF00CC',
    '#FF00FF',
    '#FF3300',
    '#FF3333',
    '#FF3366',
    '#FF3399',
    '#FF33CC',
    '#FF33FF',
    '#FF6600',
    '#FF6633',
    '#FF9900',
    '#FF9933',
    '#FFCC00',
    '#FFCC33',
  ]
  function useColors() {
    if (
      typeof window !== 'undefined' &&
      window.process &&
      (window.process.type === 'renderer' || window.process.__nwjs)
    ) {
      return true
    }
    if (
      typeof navigator !== 'undefined' &&
      navigator.userAgent &&
      navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)
    ) {
      return false
    }
    return (
      (typeof document !== 'undefined' &&
        document.documentElement &&
        document.documentElement.style &&
        document.documentElement.style.WebkitAppearance) ||
      (typeof window !== 'undefined' &&
        window.console &&
        (window.console.firebug || (window.console.exception && window.console.table))) ||
      (typeof navigator !== 'undefined' &&
        navigator.userAgent &&
        navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) &&
        parseInt(RegExp.$1, 10) >= 31) ||
      (typeof navigator !== 'undefined' &&
        navigator.userAgent &&
        navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/))
    )
  }
  function formatArgs(args) {
    args[0] =
      (this.useColors ? '%c' : '') +
      this.namespace +
      (this.useColors ? ' %c' : ' ') +
      args[0] +
      (this.useColors ? '%c ' : ' ') +
      '+' +
      module.exports.humanize(this.diff)
    if (!this.useColors) {
      return
    }
    const c = 'color: ' + this.color
    args.splice(1, 0, c, 'color: inherit')
    let index2 = 0
    let lastC = 0
    args[0].replace(/%[a-zA-Z%]/g, (match) => {
      if (match === '%%') {
        return
      }
      index2++
      if (match === '%c') {
        lastC = index2
      }
    })
    args.splice(lastC, 0, c)
  }
  exports.log = console.debug || console.log || (() => {})
  function save(namespaces) {
    try {
      if (namespaces) {
        exports.storage.setItem('debug', namespaces)
      } else {
        exports.storage.removeItem('debug')
      }
    } catch (error) {}
  }
  function load() {
    let r
    try {
      r = exports.storage.getItem('debug')
    } catch (error) {}
    if (!r && typeof process !== 'undefined' && 'env' in process) {
      r = {}.DEBUG
    }
    return r
  }
  function localstorage() {
    try {
      return localStorage
    } catch (error) {}
  }
  module.exports = common$1(exports)
  const { formatters: formatters2 } = module.exports
  formatters2.j = function (v) {
    try {
      return JSON.stringify(v)
    } catch (error) {
      return '[UnexpectedJSONParseError]: ' + error.message
    }
  }
})(browser$2, browser$2.exports)
var scope = {}
var renamer = {}
var binding = {}
Object.defineProperty(binding, '__esModule', {
  value: true,
})
binding.default = void 0
class Binding {
  constructor({ identifier: identifier2, scope: scope2, path: path2, kind }) {
    this.identifier = void 0
    this.scope = void 0
    this.path = void 0
    this.kind = void 0
    this.constantViolations = []
    this.constant = true
    this.referencePaths = []
    this.referenced = false
    this.references = 0
    this.identifier = identifier2
    this.scope = scope2
    this.path = path2
    this.kind = kind
    this.clearValue()
  }
  deoptValue() {
    this.clearValue()
    this.hasDeoptedValue = true
  }
  setValue(value) {
    if (this.hasDeoptedValue) return
    this.hasValue = true
    this.value = value
  }
  clearValue() {
    this.hasDeoptedValue = false
    this.hasValue = false
    this.value = null
  }
  reassign(path2) {
    this.constant = false
    if (this.constantViolations.indexOf(path2) !== -1) {
      return
    }
    this.constantViolations.push(path2)
  }
  reference(path2) {
    if (this.referencePaths.indexOf(path2) !== -1) {
      return
    }
    this.referenced = true
    this.references++
    this.referencePaths.push(path2)
  }
  dereference() {
    this.references--
    this.referenced = !!this.references
  }
}
binding.default = Binding
var lib$9 = {}
Object.defineProperty(lib$9, '__esModule', {
  value: true,
})
lib$9.default = splitExportDeclaration
var _t$t = lib$b
const {
  cloneNode: cloneNode$6,
  exportNamedDeclaration,
  exportSpecifier,
  identifier: identifier$6,
  variableDeclaration: variableDeclaration$2,
  variableDeclarator: variableDeclarator$2,
} = _t$t
function splitExportDeclaration(exportDeclaration) {
  if (!exportDeclaration.isExportDeclaration()) {
    throw new Error('Only export declarations can be split.')
  }
  const isDefault = exportDeclaration.isExportDefaultDeclaration()
  const declaration = exportDeclaration.get('declaration')
  const isClassDeclaration2 = declaration.isClassDeclaration()
  if (isDefault) {
    const standaloneDeclaration = declaration.isFunctionDeclaration() || isClassDeclaration2
    const scope2 = declaration.isScope() ? declaration.scope.parent : declaration.scope
    let id = declaration.node.id
    let needBindingRegistration = false
    if (!id) {
      needBindingRegistration = true
      id = scope2.generateUidIdentifier('default')
      if (standaloneDeclaration || declaration.isFunctionExpression() || declaration.isClassExpression()) {
        declaration.node.id = cloneNode$6(id)
      }
    }
    const updatedDeclaration = standaloneDeclaration
      ? declaration
      : variableDeclaration$2('var', [variableDeclarator$2(cloneNode$6(id), declaration.node)])
    const updatedExportDeclaration = exportNamedDeclaration(null, [
      exportSpecifier(cloneNode$6(id), identifier$6('default')),
    ])
    exportDeclaration.insertAfter(updatedExportDeclaration)
    exportDeclaration.replaceWith(updatedDeclaration)
    if (needBindingRegistration) {
      scope2.registerDeclaration(exportDeclaration)
    }
    return exportDeclaration
  }
  if (exportDeclaration.get('specifiers').length > 0) {
    throw new Error("It doesn't make sense to split exported specifiers.")
  }
  const bindingIdentifiers = declaration.getOuterBindingIdentifiers()
  const specifiers = Object.keys(bindingIdentifiers).map((name) => {
    return exportSpecifier(identifier$6(name), identifier$6(name))
  })
  const aliasDeclar = exportNamedDeclaration(null, specifiers)
  exportDeclaration.insertAfter(aliasDeclar)
  exportDeclaration.replaceWith(declaration.node)
  return exportDeclaration
}
var lib$8 = {}
Object.defineProperty(lib$8, '__esModule', {
  value: true,
})
lib$8.default = void 0
lib$8.requeueComputedKeyAndDecorators = requeueComputedKeyAndDecorators
lib$8.skipAllButComputedKey = skipAllButComputedKey
function skipAllButComputedKey(path2) {
  path2.skip()
  if (path2.node.computed) {
    path2.context.maybeQueue(path2.get('key'))
  }
}
function requeueComputedKeyAndDecorators(path2) {
  const { context: context2, node: node2 } = path2
  if (node2.computed) {
    context2.maybeQueue(path2.get('key'))
  }
  if (node2.decorators) {
    for (const decorator2 of path2.get('decorators')) {
      context2.maybeQueue(decorator2)
    }
  }
}
const visitor$2 = {
  FunctionParent(path2) {
    if (path2.isArrowFunctionExpression()) {
      return
    } else {
      path2.skip()
      if (path2.isMethod()) {
        requeueComputedKeyAndDecorators(path2)
      }
    }
  },
  Property(path2) {
    if (path2.isObjectProperty()) {
      return
    }
    path2.skip()
    requeueComputedKeyAndDecorators(path2)
  },
}
var _default$7 = visitor$2
lib$8.default = _default$7
Object.defineProperty(renamer, '__esModule', {
  value: true,
})
renamer.default = void 0
var _helperSplitExportDeclaration = lib$9
var _helperEnvironmentVisitor$1 = lib$8
const renameVisitor = {
  ReferencedIdentifier({ node: node2 }, state) {
    if (node2.name === state.oldName) {
      node2.name = state.newName
    }
  },
  Scope(path2, state) {
    if (!path2.scope.bindingIdentifierEquals(state.oldName, state.binding.identifier)) {
      path2.skip()
      if (path2.isMethod()) {
        ;(0, _helperEnvironmentVisitor$1.requeueComputedKeyAndDecorators)(path2)
      }
    }
  },
  'AssignmentExpression|Declaration|VariableDeclarator'(path2, state) {
    if (path2.isVariableDeclaration()) return
    const ids = path2.getOuterBindingIdentifiers()
    for (const name in ids) {
      if (name === state.oldName) ids[name].name = state.newName
    }
  },
}
class Renamer {
  constructor(binding2, oldName, newName) {
    this.newName = newName
    this.oldName = oldName
    this.binding = binding2
  }
  maybeConvertFromExportDeclaration(parentDeclar) {
    const maybeExportDeclar = parentDeclar.parentPath
    if (!maybeExportDeclar.isExportDeclaration()) {
      return
    }
    if (maybeExportDeclar.isExportDefaultDeclaration() && !maybeExportDeclar.get('declaration').node.id) {
      return
    }
    ;(0, _helperSplitExportDeclaration.default)(maybeExportDeclar)
  }
  maybeConvertFromClassFunctionDeclaration(path2) {
    return
  }
  maybeConvertFromClassFunctionExpression(path2) {
    return
  }
  rename(block) {
    const { binding: binding2, oldName, newName } = this
    const { scope: scope2, path: path2 } = binding2
    const parentDeclar = path2.find(
      (path3) => path3.isDeclaration() || path3.isFunctionExpression() || path3.isClassExpression()
    )
    if (parentDeclar) {
      const bindingIds = parentDeclar.getOuterBindingIdentifiers()
      if (bindingIds[oldName] === binding2.identifier) {
        this.maybeConvertFromExportDeclaration(parentDeclar)
      }
    }
    const blockToTraverse = block || scope2.block
    if ((blockToTraverse == null ? void 0 : blockToTraverse.type) === 'SwitchStatement') {
      blockToTraverse.cases.forEach((c) => {
        scope2.traverse(c, renameVisitor, this)
      })
    } else {
      scope2.traverse(blockToTraverse, renameVisitor, this)
    }
    if (!block) {
      scope2.removeOwnBinding(oldName)
      scope2.bindings[newName] = binding2
      this.binding.identifier.name = newName
    }
    if (parentDeclar) {
      this.maybeConvertFromClassFunctionDeclaration(parentDeclar)
      this.maybeConvertFromClassFunctionExpression(parentDeclar)
    }
  }
}
renamer.default = Renamer
const builtin = {
  Array: false,
  ArrayBuffer: false,
  Atomics: false,
  BigInt: false,
  BigInt64Array: false,
  BigUint64Array: false,
  Boolean: false,
  constructor: false,
  DataView: false,
  Date: false,
  decodeURI: false,
  decodeURIComponent: false,
  encodeURI: false,
  encodeURIComponent: false,
  Error: false,
  escape: false,
  eval: false,
  EvalError: false,
  Float32Array: false,
  Float64Array: false,
  Function: false,
  globalThis: false,
  hasOwnProperty: false,
  Infinity: false,
  Int16Array: false,
  Int32Array: false,
  Int8Array: false,
  isFinite: false,
  isNaN: false,
  isPrototypeOf: false,
  JSON: false,
  Map: false,
  Math: false,
  NaN: false,
  Number: false,
  Object: false,
  parseFloat: false,
  parseInt: false,
  Promise: false,
  propertyIsEnumerable: false,
  Proxy: false,
  RangeError: false,
  ReferenceError: false,
  Reflect: false,
  RegExp: false,
  Set: false,
  SharedArrayBuffer: false,
  String: false,
  Symbol: false,
  SyntaxError: false,
  toLocaleString: false,
  toString: false,
  TypeError: false,
  Uint16Array: false,
  Uint32Array: false,
  Uint8Array: false,
  Uint8ClampedArray: false,
  undefined: false,
  unescape: false,
  URIError: false,
  valueOf: false,
  WeakMap: false,
  WeakSet: false,
}
const es5 = {
  Array: false,
  Boolean: false,
  constructor: false,
  Date: false,
  decodeURI: false,
  decodeURIComponent: false,
  encodeURI: false,
  encodeURIComponent: false,
  Error: false,
  escape: false,
  eval: false,
  EvalError: false,
  Function: false,
  hasOwnProperty: false,
  Infinity: false,
  isFinite: false,
  isNaN: false,
  isPrototypeOf: false,
  JSON: false,
  Math: false,
  NaN: false,
  Number: false,
  Object: false,
  parseFloat: false,
  parseInt: false,
  propertyIsEnumerable: false,
  RangeError: false,
  ReferenceError: false,
  RegExp: false,
  String: false,
  SyntaxError: false,
  toLocaleString: false,
  toString: false,
  TypeError: false,
  undefined: false,
  unescape: false,
  URIError: false,
  valueOf: false,
}
const es2015 = {
  Array: false,
  ArrayBuffer: false,
  Boolean: false,
  constructor: false,
  DataView: false,
  Date: false,
  decodeURI: false,
  decodeURIComponent: false,
  encodeURI: false,
  encodeURIComponent: false,
  Error: false,
  escape: false,
  eval: false,
  EvalError: false,
  Float32Array: false,
  Float64Array: false,
  Function: false,
  hasOwnProperty: false,
  Infinity: false,
  Int16Array: false,
  Int32Array: false,
  Int8Array: false,
  isFinite: false,
  isNaN: false,
  isPrototypeOf: false,
  JSON: false,
  Map: false,
  Math: false,
  NaN: false,
  Number: false,
  Object: false,
  parseFloat: false,
  parseInt: false,
  Promise: false,
  propertyIsEnumerable: false,
  Proxy: false,
  RangeError: false,
  ReferenceError: false,
  Reflect: false,
  RegExp: false,
  Set: false,
  String: false,
  Symbol: false,
  SyntaxError: false,
  toLocaleString: false,
  toString: false,
  TypeError: false,
  Uint16Array: false,
  Uint32Array: false,
  Uint8Array: false,
  Uint8ClampedArray: false,
  undefined: false,
  unescape: false,
  URIError: false,
  valueOf: false,
  WeakMap: false,
  WeakSet: false,
}
const es2017 = {
  Array: false,
  ArrayBuffer: false,
  Atomics: false,
  Boolean: false,
  constructor: false,
  DataView: false,
  Date: false,
  decodeURI: false,
  decodeURIComponent: false,
  encodeURI: false,
  encodeURIComponent: false,
  Error: false,
  escape: false,
  eval: false,
  EvalError: false,
  Float32Array: false,
  Float64Array: false,
  Function: false,
  hasOwnProperty: false,
  Infinity: false,
  Int16Array: false,
  Int32Array: false,
  Int8Array: false,
  isFinite: false,
  isNaN: false,
  isPrototypeOf: false,
  JSON: false,
  Map: false,
  Math: false,
  NaN: false,
  Number: false,
  Object: false,
  parseFloat: false,
  parseInt: false,
  Promise: false,
  propertyIsEnumerable: false,
  Proxy: false,
  RangeError: false,
  ReferenceError: false,
  Reflect: false,
  RegExp: false,
  Set: false,
  SharedArrayBuffer: false,
  String: false,
  Symbol: false,
  SyntaxError: false,
  toLocaleString: false,
  toString: false,
  TypeError: false,
  Uint16Array: false,
  Uint32Array: false,
  Uint8Array: false,
  Uint8ClampedArray: false,
  undefined: false,
  unescape: false,
  URIError: false,
  valueOf: false,
  WeakMap: false,
  WeakSet: false,
}
const browser$1 = {
  AbortController: false,
  AbortSignal: false,
  addEventListener: false,
  alert: false,
  AnalyserNode: false,
  Animation: false,
  AnimationEffectReadOnly: false,
  AnimationEffectTiming: false,
  AnimationEffectTimingReadOnly: false,
  AnimationEvent: false,
  AnimationPlaybackEvent: false,
  AnimationTimeline: false,
  applicationCache: false,
  ApplicationCache: false,
  ApplicationCacheErrorEvent: false,
  atob: false,
  Attr: false,
  Audio: false,
  AudioBuffer: false,
  AudioBufferSourceNode: false,
  AudioContext: false,
  AudioDestinationNode: false,
  AudioListener: false,
  AudioNode: false,
  AudioParam: false,
  AudioProcessingEvent: false,
  AudioScheduledSourceNode: false,
  'AudioWorkletGlobalScope ': false,
  AudioWorkletNode: false,
  AudioWorkletProcessor: false,
  BarProp: false,
  BaseAudioContext: false,
  BatteryManager: false,
  BeforeUnloadEvent: false,
  BiquadFilterNode: false,
  Blob: false,
  BlobEvent: false,
  blur: false,
  BroadcastChannel: false,
  btoa: false,
  BudgetService: false,
  ByteLengthQueuingStrategy: false,
  Cache: false,
  caches: false,
  CacheStorage: false,
  cancelAnimationFrame: false,
  cancelIdleCallback: false,
  CanvasCaptureMediaStreamTrack: false,
  CanvasGradient: false,
  CanvasPattern: false,
  CanvasRenderingContext2D: false,
  ChannelMergerNode: false,
  ChannelSplitterNode: false,
  CharacterData: false,
  clearInterval: false,
  clearTimeout: false,
  clientInformation: false,
  ClipboardEvent: false,
  close: false,
  closed: false,
  CloseEvent: false,
  Comment: false,
  CompositionEvent: false,
  confirm: false,
  console: false,
  ConstantSourceNode: false,
  ConvolverNode: false,
  CountQueuingStrategy: false,
  createImageBitmap: false,
  Credential: false,
  CredentialsContainer: false,
  crypto: false,
  Crypto: false,
  CryptoKey: false,
  CSS: false,
  CSSConditionRule: false,
  CSSFontFaceRule: false,
  CSSGroupingRule: false,
  CSSImportRule: false,
  CSSKeyframeRule: false,
  CSSKeyframesRule: false,
  CSSMediaRule: false,
  CSSNamespaceRule: false,
  CSSPageRule: false,
  CSSRule: false,
  CSSRuleList: false,
  CSSStyleDeclaration: false,
  CSSStyleRule: false,
  CSSStyleSheet: false,
  CSSSupportsRule: false,
  CustomElementRegistry: false,
  customElements: false,
  CustomEvent: false,
  DataTransfer: false,
  DataTransferItem: false,
  DataTransferItemList: false,
  defaultstatus: false,
  defaultStatus: false,
  DelayNode: false,
  DeviceMotionEvent: false,
  DeviceOrientationEvent: false,
  devicePixelRatio: false,
  dispatchEvent: false,
  document: false,
  Document: false,
  DocumentFragment: false,
  DocumentType: false,
  DOMError: false,
  DOMException: false,
  DOMImplementation: false,
  DOMMatrix: false,
  DOMMatrixReadOnly: false,
  DOMParser: false,
  DOMPoint: false,
  DOMPointReadOnly: false,
  DOMQuad: false,
  DOMRect: false,
  DOMRectReadOnly: false,
  DOMStringList: false,
  DOMStringMap: false,
  DOMTokenList: false,
  DragEvent: false,
  DynamicsCompressorNode: false,
  Element: false,
  ErrorEvent: false,
  event: false,
  Event: false,
  EventSource: false,
  EventTarget: false,
  external: false,
  fetch: false,
  File: false,
  FileList: false,
  FileReader: false,
  find: false,
  focus: false,
  FocusEvent: false,
  FontFace: false,
  FontFaceSetLoadEvent: false,
  FormData: false,
  frameElement: false,
  frames: false,
  GainNode: false,
  Gamepad: false,
  GamepadButton: false,
  GamepadEvent: false,
  getComputedStyle: false,
  getSelection: false,
  HashChangeEvent: false,
  Headers: false,
  history: false,
  History: false,
  HTMLAllCollection: false,
  HTMLAnchorElement: false,
  HTMLAreaElement: false,
  HTMLAudioElement: false,
  HTMLBaseElement: false,
  HTMLBodyElement: false,
  HTMLBRElement: false,
  HTMLButtonElement: false,
  HTMLCanvasElement: false,
  HTMLCollection: false,
  HTMLContentElement: false,
  HTMLDataElement: false,
  HTMLDataListElement: false,
  HTMLDetailsElement: false,
  HTMLDialogElement: false,
  HTMLDirectoryElement: false,
  HTMLDivElement: false,
  HTMLDListElement: false,
  HTMLDocument: false,
  HTMLElement: false,
  HTMLEmbedElement: false,
  HTMLFieldSetElement: false,
  HTMLFontElement: false,
  HTMLFormControlsCollection: false,
  HTMLFormElement: false,
  HTMLFrameElement: false,
  HTMLFrameSetElement: false,
  HTMLHeadElement: false,
  HTMLHeadingElement: false,
  HTMLHRElement: false,
  HTMLHtmlElement: false,
  HTMLIFrameElement: false,
  HTMLImageElement: false,
  HTMLInputElement: false,
  HTMLLabelElement: false,
  HTMLLegendElement: false,
  HTMLLIElement: false,
  HTMLLinkElement: false,
  HTMLMapElement: false,
  HTMLMarqueeElement: false,
  HTMLMediaElement: false,
  HTMLMenuElement: false,
  HTMLMetaElement: false,
  HTMLMeterElement: false,
  HTMLModElement: false,
  HTMLObjectElement: false,
  HTMLOListElement: false,
  HTMLOptGroupElement: false,
  HTMLOptionElement: false,
  HTMLOptionsCollection: false,
  HTMLOutputElement: false,
  HTMLParagraphElement: false,
  HTMLParamElement: false,
  HTMLPictureElement: false,
  HTMLPreElement: false,
  HTMLProgressElement: false,
  HTMLQuoteElement: false,
  HTMLScriptElement: false,
  HTMLSelectElement: false,
  HTMLShadowElement: false,
  HTMLSlotElement: false,
  HTMLSourceElement: false,
  HTMLSpanElement: false,
  HTMLStyleElement: false,
  HTMLTableCaptionElement: false,
  HTMLTableCellElement: false,
  HTMLTableColElement: false,
  HTMLTableElement: false,
  HTMLTableRowElement: false,
  HTMLTableSectionElement: false,
  HTMLTemplateElement: false,
  HTMLTextAreaElement: false,
  HTMLTimeElement: false,
  HTMLTitleElement: false,
  HTMLTrackElement: false,
  HTMLUListElement: false,
  HTMLUnknownElement: false,
  HTMLVideoElement: false,
  IDBCursor: false,
  IDBCursorWithValue: false,
  IDBDatabase: false,
  IDBFactory: false,
  IDBIndex: false,
  IDBKeyRange: false,
  IDBObjectStore: false,
  IDBOpenDBRequest: false,
  IDBRequest: false,
  IDBTransaction: false,
  IDBVersionChangeEvent: false,
  IdleDeadline: false,
  IIRFilterNode: false,
  Image: false,
  ImageBitmap: false,
  ImageBitmapRenderingContext: false,
  ImageCapture: false,
  ImageData: false,
  indexedDB: false,
  innerHeight: false,
  innerWidth: false,
  InputEvent: false,
  IntersectionObserver: false,
  IntersectionObserverEntry: false,
  Intl: false,
  isSecureContext: false,
  KeyboardEvent: false,
  KeyframeEffect: false,
  KeyframeEffectReadOnly: false,
  length: false,
  localStorage: false,
  location: true,
  Location: false,
  locationbar: false,
  matchMedia: false,
  MediaDeviceInfo: false,
  MediaDevices: false,
  MediaElementAudioSourceNode: false,
  MediaEncryptedEvent: false,
  MediaError: false,
  MediaKeyMessageEvent: false,
  MediaKeySession: false,
  MediaKeyStatusMap: false,
  MediaKeySystemAccess: false,
  MediaList: false,
  MediaQueryList: false,
  MediaQueryListEvent: false,
  MediaRecorder: false,
  MediaSettingsRange: false,
  MediaSource: false,
  MediaStream: false,
  MediaStreamAudioDestinationNode: false,
  MediaStreamAudioSourceNode: false,
  MediaStreamEvent: false,
  MediaStreamTrack: false,
  MediaStreamTrackEvent: false,
  menubar: false,
  MessageChannel: false,
  MessageEvent: false,
  MessagePort: false,
  MIDIAccess: false,
  MIDIConnectionEvent: false,
  MIDIInput: false,
  MIDIInputMap: false,
  MIDIMessageEvent: false,
  MIDIOutput: false,
  MIDIOutputMap: false,
  MIDIPort: false,
  MimeType: false,
  MimeTypeArray: false,
  MouseEvent: false,
  moveBy: false,
  moveTo: false,
  MutationEvent: false,
  MutationObserver: false,
  MutationRecord: false,
  name: false,
  NamedNodeMap: false,
  NavigationPreloadManager: false,
  navigator: false,
  Navigator: false,
  NetworkInformation: false,
  Node: false,
  NodeFilter: false,
  NodeIterator: false,
  NodeList: false,
  Notification: false,
  OfflineAudioCompletionEvent: false,
  OfflineAudioContext: false,
  offscreenBuffering: false,
  OffscreenCanvas: true,
  onabort: true,
  onafterprint: true,
  onanimationend: true,
  onanimationiteration: true,
  onanimationstart: true,
  onappinstalled: true,
  onauxclick: true,
  onbeforeinstallprompt: true,
  onbeforeprint: true,
  onbeforeunload: true,
  onblur: true,
  oncancel: true,
  oncanplay: true,
  oncanplaythrough: true,
  onchange: true,
  onclick: true,
  onclose: true,
  oncontextmenu: true,
  oncuechange: true,
  ondblclick: true,
  ondevicemotion: true,
  ondeviceorientation: true,
  ondeviceorientationabsolute: true,
  ondrag: true,
  ondragend: true,
  ondragenter: true,
  ondragleave: true,
  ondragover: true,
  ondragstart: true,
  ondrop: true,
  ondurationchange: true,
  onemptied: true,
  onended: true,
  onerror: true,
  onfocus: true,
  ongotpointercapture: true,
  onhashchange: true,
  oninput: true,
  oninvalid: true,
  onkeydown: true,
  onkeypress: true,
  onkeyup: true,
  onlanguagechange: true,
  onload: true,
  onloadeddata: true,
  onloadedmetadata: true,
  onloadstart: true,
  onlostpointercapture: true,
  onmessage: true,
  onmessageerror: true,
  onmousedown: true,
  onmouseenter: true,
  onmouseleave: true,
  onmousemove: true,
  onmouseout: true,
  onmouseover: true,
  onmouseup: true,
  onmousewheel: true,
  onoffline: true,
  ononline: true,
  onpagehide: true,
  onpageshow: true,
  onpause: true,
  onplay: true,
  onplaying: true,
  onpointercancel: true,
  onpointerdown: true,
  onpointerenter: true,
  onpointerleave: true,
  onpointermove: true,
  onpointerout: true,
  onpointerover: true,
  onpointerup: true,
  onpopstate: true,
  onprogress: true,
  onratechange: true,
  onrejectionhandled: true,
  onreset: true,
  onresize: true,
  onscroll: true,
  onsearch: true,
  onseeked: true,
  onseeking: true,
  onselect: true,
  onstalled: true,
  onstorage: true,
  onsubmit: true,
  onsuspend: true,
  ontimeupdate: true,
  ontoggle: true,
  ontransitionend: true,
  onunhandledrejection: true,
  onunload: true,
  onvolumechange: true,
  onwaiting: true,
  onwheel: true,
  open: false,
  openDatabase: false,
  opener: false,
  Option: false,
  origin: false,
  OscillatorNode: false,
  outerHeight: false,
  outerWidth: false,
  PageTransitionEvent: false,
  pageXOffset: false,
  pageYOffset: false,
  PannerNode: false,
  parent: false,
  Path2D: false,
  PaymentAddress: false,
  PaymentRequest: false,
  PaymentRequestUpdateEvent: false,
  PaymentResponse: false,
  performance: false,
  Performance: false,
  PerformanceEntry: false,
  PerformanceLongTaskTiming: false,
  PerformanceMark: false,
  PerformanceMeasure: false,
  PerformanceNavigation: false,
  PerformanceNavigationTiming: false,
  PerformanceObserver: false,
  PerformanceObserverEntryList: false,
  PerformancePaintTiming: false,
  PerformanceResourceTiming: false,
  PerformanceTiming: false,
  PeriodicWave: false,
  Permissions: false,
  PermissionStatus: false,
  personalbar: false,
  PhotoCapabilities: false,
  Plugin: false,
  PluginArray: false,
  PointerEvent: false,
  PopStateEvent: false,
  postMessage: false,
  Presentation: false,
  PresentationAvailability: false,
  PresentationConnection: false,
  PresentationConnectionAvailableEvent: false,
  PresentationConnectionCloseEvent: false,
  PresentationConnectionList: false,
  PresentationReceiver: false,
  PresentationRequest: false,
  print: false,
  ProcessingInstruction: false,
  ProgressEvent: false,
  PromiseRejectionEvent: false,
  prompt: false,
  PushManager: false,
  PushSubscription: false,
  PushSubscriptionOptions: false,
  queueMicrotask: false,
  RadioNodeList: false,
  Range: false,
  ReadableStream: false,
  registerProcessor: false,
  RemotePlayback: false,
  removeEventListener: false,
  Request: false,
  requestAnimationFrame: false,
  requestIdleCallback: false,
  resizeBy: false,
  ResizeObserver: false,
  ResizeObserverEntry: false,
  resizeTo: false,
  Response: false,
  RTCCertificate: false,
  RTCDataChannel: false,
  RTCDataChannelEvent: false,
  RTCDtlsTransport: false,
  RTCIceCandidate: false,
  RTCIceGatherer: false,
  RTCIceTransport: false,
  RTCPeerConnection: false,
  RTCPeerConnectionIceEvent: false,
  RTCRtpContributingSource: false,
  RTCRtpReceiver: false,
  RTCRtpSender: false,
  RTCSctpTransport: false,
  RTCSessionDescription: false,
  RTCStatsReport: false,
  RTCTrackEvent: false,
  screen: false,
  Screen: false,
  screenLeft: false,
  ScreenOrientation: false,
  screenTop: false,
  screenX: false,
  screenY: false,
  ScriptProcessorNode: false,
  scroll: false,
  scrollbars: false,
  scrollBy: false,
  scrollTo: false,
  scrollX: false,
  scrollY: false,
  SecurityPolicyViolationEvent: false,
  Selection: false,
  self: false,
  ServiceWorker: false,
  ServiceWorkerContainer: false,
  ServiceWorkerRegistration: false,
  sessionStorage: false,
  setInterval: false,
  setTimeout: false,
  ShadowRoot: false,
  SharedWorker: false,
  SourceBuffer: false,
  SourceBufferList: false,
  speechSynthesis: false,
  SpeechSynthesisEvent: false,
  SpeechSynthesisUtterance: false,
  StaticRange: false,
  status: false,
  statusbar: false,
  StereoPannerNode: false,
  stop: false,
  Storage: false,
  StorageEvent: false,
  StorageManager: false,
  styleMedia: false,
  StyleSheet: false,
  StyleSheetList: false,
  SubtleCrypto: false,
  SVGAElement: false,
  SVGAngle: false,
  SVGAnimatedAngle: false,
  SVGAnimatedBoolean: false,
  SVGAnimatedEnumeration: false,
  SVGAnimatedInteger: false,
  SVGAnimatedLength: false,
  SVGAnimatedLengthList: false,
  SVGAnimatedNumber: false,
  SVGAnimatedNumberList: false,
  SVGAnimatedPreserveAspectRatio: false,
  SVGAnimatedRect: false,
  SVGAnimatedString: false,
  SVGAnimatedTransformList: false,
  SVGAnimateElement: false,
  SVGAnimateMotionElement: false,
  SVGAnimateTransformElement: false,
  SVGAnimationElement: false,
  SVGCircleElement: false,
  SVGClipPathElement: false,
  SVGComponentTransferFunctionElement: false,
  SVGDefsElement: false,
  SVGDescElement: false,
  SVGDiscardElement: false,
  SVGElement: false,
  SVGEllipseElement: false,
  SVGFEBlendElement: false,
  SVGFEColorMatrixElement: false,
  SVGFEComponentTransferElement: false,
  SVGFECompositeElement: false,
  SVGFEConvolveMatrixElement: false,
  SVGFEDiffuseLightingElement: false,
  SVGFEDisplacementMapElement: false,
  SVGFEDistantLightElement: false,
  SVGFEDropShadowElement: false,
  SVGFEFloodElement: false,
  SVGFEFuncAElement: false,
  SVGFEFuncBElement: false,
  SVGFEFuncGElement: false,
  SVGFEFuncRElement: false,
  SVGFEGaussianBlurElement: false,
  SVGFEImageElement: false,
  SVGFEMergeElement: false,
  SVGFEMergeNodeElement: false,
  SVGFEMorphologyElement: false,
  SVGFEOffsetElement: false,
  SVGFEPointLightElement: false,
  SVGFESpecularLightingElement: false,
  SVGFESpotLightElement: false,
  SVGFETileElement: false,
  SVGFETurbulenceElement: false,
  SVGFilterElement: false,
  SVGForeignObjectElement: false,
  SVGGElement: false,
  SVGGeometryElement: false,
  SVGGradientElement: false,
  SVGGraphicsElement: false,
  SVGImageElement: false,
  SVGLength: false,
  SVGLengthList: false,
  SVGLinearGradientElement: false,
  SVGLineElement: false,
  SVGMarkerElement: false,
  SVGMaskElement: false,
  SVGMatrix: false,
  SVGMetadataElement: false,
  SVGMPathElement: false,
  SVGNumber: false,
  SVGNumberList: false,
  SVGPathElement: false,
  SVGPatternElement: false,
  SVGPoint: false,
  SVGPointList: false,
  SVGPolygonElement: false,
  SVGPolylineElement: false,
  SVGPreserveAspectRatio: false,
  SVGRadialGradientElement: false,
  SVGRect: false,
  SVGRectElement: false,
  SVGScriptElement: false,
  SVGSetElement: false,
  SVGStopElement: false,
  SVGStringList: false,
  SVGStyleElement: false,
  SVGSVGElement: false,
  SVGSwitchElement: false,
  SVGSymbolElement: false,
  SVGTextContentElement: false,
  SVGTextElement: false,
  SVGTextPathElement: false,
  SVGTextPositioningElement: false,
  SVGTitleElement: false,
  SVGTransform: false,
  SVGTransformList: false,
  SVGTSpanElement: false,
  SVGUnitTypes: false,
  SVGUseElement: false,
  SVGViewElement: false,
  TaskAttributionTiming: false,
  Text: false,
  TextDecoder: false,
  TextEncoder: false,
  TextEvent: false,
  TextMetrics: false,
  TextTrack: false,
  TextTrackCue: false,
  TextTrackCueList: false,
  TextTrackList: false,
  TimeRanges: false,
  toolbar: false,
  top: false,
  Touch: false,
  TouchEvent: false,
  TouchList: false,
  TrackEvent: false,
  TransitionEvent: false,
  TreeWalker: false,
  UIEvent: false,
  URL: false,
  URLSearchParams: false,
  ValidityState: false,
  visualViewport: false,
  VisualViewport: false,
  VTTCue: false,
  WaveShaperNode: false,
  WebAssembly: false,
  WebGL2RenderingContext: false,
  WebGLActiveInfo: false,
  WebGLBuffer: false,
  WebGLContextEvent: false,
  WebGLFramebuffer: false,
  WebGLProgram: false,
  WebGLQuery: false,
  WebGLRenderbuffer: false,
  WebGLRenderingContext: false,
  WebGLSampler: false,
  WebGLShader: false,
  WebGLShaderPrecisionFormat: false,
  WebGLSync: false,
  WebGLTexture: false,
  WebGLTransformFeedback: false,
  WebGLUniformLocation: false,
  WebGLVertexArrayObject: false,
  WebSocket: false,
  WheelEvent: false,
  window: false,
  Window: false,
  Worker: false,
  WritableStream: false,
  XMLDocument: false,
  XMLHttpRequest: false,
  XMLHttpRequestEventTarget: false,
  XMLHttpRequestUpload: false,
  XMLSerializer: false,
  XPathEvaluator: false,
  XPathExpression: false,
  XPathResult: false,
  XSLTProcessor: false,
}
const worker = {
  addEventListener: false,
  applicationCache: false,
  atob: false,
  Blob: false,
  BroadcastChannel: false,
  btoa: false,
  Cache: false,
  caches: false,
  clearInterval: false,
  clearTimeout: false,
  close: true,
  console: false,
  fetch: false,
  FileReaderSync: false,
  FormData: false,
  Headers: false,
  IDBCursor: false,
  IDBCursorWithValue: false,
  IDBDatabase: false,
  IDBFactory: false,
  IDBIndex: false,
  IDBKeyRange: false,
  IDBObjectStore: false,
  IDBOpenDBRequest: false,
  IDBRequest: false,
  IDBTransaction: false,
  IDBVersionChangeEvent: false,
  ImageData: false,
  importScripts: true,
  indexedDB: false,
  location: false,
  MessageChannel: false,
  MessagePort: false,
  name: false,
  navigator: false,
  Notification: false,
  onclose: true,
  onconnect: true,
  onerror: true,
  onlanguagechange: true,
  onmessage: true,
  onoffline: true,
  ononline: true,
  onrejectionhandled: true,
  onunhandledrejection: true,
  performance: false,
  Performance: false,
  PerformanceEntry: false,
  PerformanceMark: false,
  PerformanceMeasure: false,
  PerformanceNavigation: false,
  PerformanceResourceTiming: false,
  PerformanceTiming: false,
  postMessage: true,
  Promise: false,
  queueMicrotask: false,
  removeEventListener: false,
  Request: false,
  Response: false,
  self: true,
  ServiceWorkerRegistration: false,
  setInterval: false,
  setTimeout: false,
  TextDecoder: false,
  TextEncoder: false,
  URL: false,
  URLSearchParams: false,
  WebSocket: false,
  Worker: false,
  WorkerGlobalScope: false,
  XMLHttpRequest: false,
}
const node$1 = {
  __dirname: false,
  __filename: false,
  Buffer: false,
  clearImmediate: false,
  clearInterval: false,
  clearTimeout: false,
  console: false,
  exports: true,
  global: false,
  Intl: false,
  module: false,
  process: false,
  queueMicrotask: false,
  require: false,
  setImmediate: false,
  setInterval: false,
  setTimeout: false,
  TextDecoder: false,
  TextEncoder: false,
  URL: false,
  URLSearchParams: false,
}
const commonjs = {
  exports: true,
  global: false,
  module: false,
  require: false,
}
const amd = {
  define: false,
  require: false,
}
const mocha = {
  after: false,
  afterEach: false,
  before: false,
  beforeEach: false,
  context: false,
  describe: false,
  it: false,
  mocha: false,
  run: false,
  setup: false,
  specify: false,
  suite: false,
  suiteSetup: false,
  suiteTeardown: false,
  teardown: false,
  test: false,
  xcontext: false,
  xdescribe: false,
  xit: false,
  xspecify: false,
}
const jasmine = {
  afterAll: false,
  afterEach: false,
  beforeAll: false,
  beforeEach: false,
  describe: false,
  expect: false,
  fail: false,
  fdescribe: false,
  fit: false,
  it: false,
  jasmine: false,
  pending: false,
  runs: false,
  spyOn: false,
  spyOnProperty: false,
  waits: false,
  waitsFor: false,
  xdescribe: false,
  xit: false,
}
const jest = {
  afterAll: false,
  afterEach: false,
  beforeAll: false,
  beforeEach: false,
  describe: false,
  expect: false,
  fdescribe: false,
  fit: false,
  it: false,
  jest: false,
  pit: false,
  require: false,
  test: false,
  xdescribe: false,
  xit: false,
  xtest: false,
}
const qunit = {
  asyncTest: false,
  deepEqual: false,
  equal: false,
  expect: false,
  module: false,
  notDeepEqual: false,
  notEqual: false,
  notOk: false,
  notPropEqual: false,
  notStrictEqual: false,
  ok: false,
  propEqual: false,
  QUnit: false,
  raises: false,
  start: false,
  stop: false,
  strictEqual: false,
  test: false,
  throws: false,
}
const phantomjs = {
  console: true,
  exports: true,
  phantom: true,
  require: true,
  WebPage: true,
}
const couch = {
  emit: false,
  exports: false,
  getRow: false,
  log: false,
  module: false,
  provides: false,
  require: false,
  respond: false,
  send: false,
  start: false,
  sum: false,
}
const rhino = {
  defineClass: false,
  deserialize: false,
  gc: false,
  help: false,
  importClass: false,
  importPackage: false,
  java: false,
  load: false,
  loadClass: false,
  Packages: false,
  print: false,
  quit: false,
  readFile: false,
  readUrl: false,
  runCommand: false,
  seal: false,
  serialize: false,
  spawn: false,
  sync: false,
  toint32: false,
  version: false,
}
const nashorn = {
  __DIR__: false,
  __FILE__: false,
  __LINE__: false,
  com: false,
  edu: false,
  exit: false,
  java: false,
  Java: false,
  javafx: false,
  JavaImporter: false,
  javax: false,
  JSAdapter: false,
  load: false,
  loadWithNewGlobal: false,
  org: false,
  Packages: false,
  print: false,
  quit: false,
}
const wsh = {
  ActiveXObject: true,
  Enumerator: true,
  GetObject: true,
  ScriptEngine: true,
  ScriptEngineBuildVersion: true,
  ScriptEngineMajorVersion: true,
  ScriptEngineMinorVersion: true,
  VBArray: true,
  WScript: true,
  WSH: true,
  XDomainRequest: true,
}
const jquery = {
  $: false,
  jQuery: false,
}
const yui = {
  YAHOO: false,
  YAHOO_config: false,
  YUI: false,
  YUI_config: false,
}
const shelljs = {
  cat: false,
  cd: false,
  chmod: false,
  config: false,
  cp: false,
  dirs: false,
  echo: false,
  env: false,
  error: false,
  exec: false,
  exit: false,
  find: false,
  grep: false,
  ln: false,
  ls: false,
  mkdir: false,
  mv: false,
  popd: false,
  pushd: false,
  pwd: false,
  rm: false,
  sed: false,
  set: false,
  target: false,
  tempdir: false,
  test: false,
  touch: false,
  which: false,
}
const prototypejs = {
  $: false,
  $$: false,
  $A: false,
  $break: false,
  $continue: false,
  $F: false,
  $H: false,
  $R: false,
  $w: false,
  Abstract: false,
  Ajax: false,
  Autocompleter: false,
  Builder: false,
  Class: false,
  Control: false,
  Draggable: false,
  Draggables: false,
  Droppables: false,
  Effect: false,
  Element: false,
  Enumerable: false,
  Event: false,
  Field: false,
  Form: false,
  Hash: false,
  Insertion: false,
  ObjectRange: false,
  PeriodicalExecuter: false,
  Position: false,
  Prototype: false,
  Scriptaculous: false,
  Selector: false,
  Sortable: false,
  SortableObserver: false,
  Sound: false,
  Template: false,
  Toggle: false,
  Try: false,
}
const meteor = {
  _: false,
  $: false,
  Accounts: false,
  AccountsClient: false,
  AccountsCommon: false,
  AccountsServer: false,
  App: false,
  Assets: false,
  Blaze: false,
  check: false,
  Cordova: false,
  DDP: false,
  DDPRateLimiter: false,
  DDPServer: false,
  Deps: false,
  EJSON: false,
  Email: false,
  HTTP: false,
  Log: false,
  Match: false,
  Meteor: false,
  Mongo: false,
  MongoInternals: false,
  Npm: false,
  Package: false,
  Plugin: false,
  process: false,
  Random: false,
  ReactiveDict: false,
  ReactiveVar: false,
  Router: false,
  ServiceConfiguration: false,
  Session: false,
  share: false,
  Spacebars: false,
  Template: false,
  Tinytest: false,
  Tracker: false,
  UI: false,
  Utils: false,
  WebApp: false,
  WebAppInternals: false,
}
const mongo = {
  _isWindows: false,
  _rand: false,
  BulkWriteResult: false,
  cat: false,
  cd: false,
  connect: false,
  db: false,
  getHostName: false,
  getMemInfo: false,
  hostname: false,
  ISODate: false,
  listFiles: false,
  load: false,
  ls: false,
  md5sumFile: false,
  mkdir: false,
  Mongo: false,
  NumberInt: false,
  NumberLong: false,
  ObjectId: false,
  PlanCache: false,
  print: false,
  printjson: false,
  pwd: false,
  quit: false,
  removeFile: false,
  rs: false,
  sh: false,
  UUID: false,
  version: false,
  WriteResult: false,
}
const applescript = {
  $: false,
  Application: false,
  Automation: false,
  console: false,
  delay: false,
  Library: false,
  ObjC: false,
  ObjectSpecifier: false,
  Path: false,
  Progress: false,
  Ref: false,
}
const serviceworker = {
  addEventListener: false,
  applicationCache: false,
  atob: false,
  Blob: false,
  BroadcastChannel: false,
  btoa: false,
  Cache: false,
  caches: false,
  CacheStorage: false,
  clearInterval: false,
  clearTimeout: false,
  Client: false,
  clients: false,
  Clients: false,
  close: true,
  console: false,
  ExtendableEvent: false,
  ExtendableMessageEvent: false,
  fetch: false,
  FetchEvent: false,
  FileReaderSync: false,
  FormData: false,
  Headers: false,
  IDBCursor: false,
  IDBCursorWithValue: false,
  IDBDatabase: false,
  IDBFactory: false,
  IDBIndex: false,
  IDBKeyRange: false,
  IDBObjectStore: false,
  IDBOpenDBRequest: false,
  IDBRequest: false,
  IDBTransaction: false,
  IDBVersionChangeEvent: false,
  ImageData: false,
  importScripts: false,
  indexedDB: false,
  location: false,
  MessageChannel: false,
  MessagePort: false,
  name: false,
  navigator: false,
  Notification: false,
  onclose: true,
  onconnect: true,
  onerror: true,
  onfetch: true,
  oninstall: true,
  onlanguagechange: true,
  onmessage: true,
  onmessageerror: true,
  onnotificationclick: true,
  onnotificationclose: true,
  onoffline: true,
  ononline: true,
  onpush: true,
  onpushsubscriptionchange: true,
  onrejectionhandled: true,
  onsync: true,
  onunhandledrejection: true,
  performance: false,
  Performance: false,
  PerformanceEntry: false,
  PerformanceMark: false,
  PerformanceMeasure: false,
  PerformanceNavigation: false,
  PerformanceResourceTiming: false,
  PerformanceTiming: false,
  postMessage: true,
  Promise: false,
  queueMicrotask: false,
  registration: false,
  removeEventListener: false,
  Request: false,
  Response: false,
  self: false,
  ServiceWorker: false,
  ServiceWorkerContainer: false,
  ServiceWorkerGlobalScope: false,
  ServiceWorkerMessageEvent: false,
  ServiceWorkerRegistration: false,
  setInterval: false,
  setTimeout: false,
  skipWaiting: false,
  TextDecoder: false,
  TextEncoder: false,
  URL: false,
  URLSearchParams: false,
  WebSocket: false,
  WindowClient: false,
  Worker: false,
  WorkerGlobalScope: false,
  XMLHttpRequest: false,
}
const atomtest = {
  advanceClock: false,
  fakeClearInterval: false,
  fakeClearTimeout: false,
  fakeSetInterval: false,
  fakeSetTimeout: false,
  resetTimeouts: false,
  waitsForPromise: false,
}
const embertest = {
  andThen: false,
  click: false,
  currentPath: false,
  currentRouteName: false,
  currentURL: false,
  fillIn: false,
  find: false,
  findAll: false,
  findWithAssert: false,
  keyEvent: false,
  pauseTest: false,
  resumeTest: false,
  triggerEvent: false,
  visit: false,
  wait: false,
}
const protractor = {
  $: false,
  $$: false,
  browser: false,
  by: false,
  By: false,
  DartObject: false,
  element: false,
  protractor: false,
}
const webextensions = {
  browser: false,
  chrome: false,
  opr: false,
}
const greasemonkey = {
  cloneInto: false,
  createObjectIn: false,
  exportFunction: false,
  GM: false,
  GM_addStyle: false,
  GM_deleteValue: false,
  GM_getResourceText: false,
  GM_getResourceURL: false,
  GM_getValue: false,
  GM_info: false,
  GM_listValues: false,
  GM_log: false,
  GM_openInTab: false,
  GM_registerMenuCommand: false,
  GM_setClipboard: false,
  GM_setValue: false,
  GM_xmlhttpRequest: false,
  unsafeWindow: false,
}
const devtools = {
  $: false,
  $_: false,
  $$: false,
  $0: false,
  $1: false,
  $2: false,
  $3: false,
  $4: false,
  $x: false,
  chrome: false,
  clear: false,
  copy: false,
  debug: false,
  dir: false,
  dirxml: false,
  getEventListeners: false,
  inspect: false,
  keys: false,
  monitor: false,
  monitorEvents: false,
  profile: false,
  profileEnd: false,
  queryObjects: false,
  table: false,
  undebug: false,
  unmonitor: false,
  unmonitorEvents: false,
  values: false,
}
var require$$0 = {
  builtin,
  es5,
  es2015,
  es2017,
  browser: browser$1,
  worker,
  node: node$1,
  commonjs,
  amd,
  mocha,
  jasmine,
  jest,
  qunit,
  phantomjs,
  couch,
  rhino,
  nashorn,
  wsh,
  jquery,
  yui,
  shelljs,
  prototypejs,
  meteor,
  mongo,
  applescript,
  serviceworker,
  atomtest,
  embertest,
  protractor,
  'shared-node-browser': {
    clearInterval: false,
    clearTimeout: false,
    console: false,
    setInterval: false,
    setTimeout: false,
    URL: false,
    URLSearchParams: false,
  },
  webextensions,
  greasemonkey,
  devtools,
}
var globals = require$$0
Object.defineProperty(scope, '__esModule', {
  value: true,
})
scope.default = void 0
var _renamer = renamer
var _index$6 = lib$c
var _binding = binding
var _globals = globals
var _t$s = lib$b
var _cache$4 = cache
const {
  NOT_LOCAL_BINDING: NOT_LOCAL_BINDING$1,
  callExpression: callExpression$3,
  cloneNode: cloneNode$5,
  getBindingIdentifiers: getBindingIdentifiers$1,
  identifier: identifier$5,
  isArrayExpression: isArrayExpression$1,
  isBinary: isBinary$3,
  isClass,
  isClassBody,
  isClassDeclaration: isClassDeclaration$2,
  isExportAllDeclaration,
  isExportDefaultDeclaration: isExportDefaultDeclaration$2,
  isExportNamedDeclaration: isExportNamedDeclaration$1,
  isFunctionDeclaration,
  isIdentifier: isIdentifier$9,
  isImportDeclaration,
  isLiteral: isLiteral$4,
  isMethod,
  isModuleDeclaration,
  isModuleSpecifier,
  isObjectExpression: isObjectExpression$1,
  isProperty,
  isPureish,
  isSuper: isSuper$1,
  isTaggedTemplateExpression: isTaggedTemplateExpression$1,
  isTemplateLiteral: isTemplateLiteral$1,
  isThisExpression,
  isUnaryExpression,
  isVariableDeclaration,
  matchesPattern: matchesPattern$1,
  memberExpression: memberExpression$1,
  numericLiteral: numericLiteral$2,
  toIdentifier,
  unaryExpression: unaryExpression$2,
  variableDeclaration: variableDeclaration$1,
  variableDeclarator: variableDeclarator$1,
  isRecordExpression,
  isTupleExpression,
  isObjectProperty: isObjectProperty$1,
  isTopicReference,
  isMetaProperty,
  isPrivateName,
} = _t$s
function gatherNodeParts(node2, parts) {
  switch (node2 == null ? void 0 : node2.type) {
    default:
      if (isModuleDeclaration(node2)) {
        if (
          (isExportAllDeclaration(node2) || isExportNamedDeclaration$1(node2) || isImportDeclaration(node2)) &&
          node2.source
        ) {
          gatherNodeParts(node2.source, parts)
        } else if (
          (isExportNamedDeclaration$1(node2) || isImportDeclaration(node2)) &&
          node2.specifiers &&
          node2.specifiers.length
        ) {
          for (const e of node2.specifiers) gatherNodeParts(e, parts)
        } else if ((isExportDefaultDeclaration$2(node2) || isExportNamedDeclaration$1(node2)) && node2.declaration) {
          gatherNodeParts(node2.declaration, parts)
        }
      } else if (isModuleSpecifier(node2)) {
        gatherNodeParts(node2.local, parts)
      } else if (isLiteral$4(node2)) {
        parts.push(node2.value)
      }
      break
    case 'MemberExpression':
    case 'OptionalMemberExpression':
    case 'JSXMemberExpression':
      gatherNodeParts(node2.object, parts)
      gatherNodeParts(node2.property, parts)
      break
    case 'Identifier':
    case 'JSXIdentifier':
      parts.push(node2.name)
      break
    case 'CallExpression':
    case 'OptionalCallExpression':
    case 'NewExpression':
      gatherNodeParts(node2.callee, parts)
      break
    case 'ObjectExpression':
    case 'ObjectPattern':
      for (const e of node2.properties) {
        gatherNodeParts(e, parts)
      }
      break
    case 'SpreadElement':
    case 'RestElement':
      gatherNodeParts(node2.argument, parts)
      break
    case 'ObjectProperty':
    case 'ObjectMethod':
    case 'ClassProperty':
    case 'ClassMethod':
    case 'ClassPrivateProperty':
    case 'ClassPrivateMethod':
      gatherNodeParts(node2.key, parts)
      break
    case 'ThisExpression':
      parts.push('this')
      break
    case 'Super':
      parts.push('super')
      break
    case 'Import':
      parts.push('import')
      break
    case 'DoExpression':
      parts.push('do')
      break
    case 'YieldExpression':
      parts.push('yield')
      gatherNodeParts(node2.argument, parts)
      break
    case 'AwaitExpression':
      parts.push('await')
      gatherNodeParts(node2.argument, parts)
      break
    case 'AssignmentExpression':
      gatherNodeParts(node2.left, parts)
      break
    case 'VariableDeclarator':
      gatherNodeParts(node2.id, parts)
      break
    case 'FunctionExpression':
    case 'FunctionDeclaration':
    case 'ClassExpression':
    case 'ClassDeclaration':
      gatherNodeParts(node2.id, parts)
      break
    case 'PrivateName':
      gatherNodeParts(node2.id, parts)
      break
    case 'ParenthesizedExpression':
      gatherNodeParts(node2.expression, parts)
      break
    case 'UnaryExpression':
    case 'UpdateExpression':
      gatherNodeParts(node2.argument, parts)
      break
    case 'MetaProperty':
      gatherNodeParts(node2.meta, parts)
      gatherNodeParts(node2.property, parts)
      break
    case 'JSXElement':
      gatherNodeParts(node2.openingElement, parts)
      break
    case 'JSXOpeningElement':
      parts.push(node2.name)
      break
    case 'JSXFragment':
      gatherNodeParts(node2.openingFragment, parts)
      break
    case 'JSXOpeningFragment':
      parts.push('Fragment')
      break
    case 'JSXNamespacedName':
      gatherNodeParts(node2.namespace, parts)
      gatherNodeParts(node2.name, parts)
      break
  }
}
const collectorVisitor = {
  ForStatement(path2) {
    const declar = path2.get('init')
    if (declar.isVar()) {
      const { scope: scope2 } = path2
      const parentScope = scope2.getFunctionParent() || scope2.getProgramParent()
      parentScope.registerBinding('var', declar)
    }
  },
  Declaration(path2) {
    if (path2.isBlockScoped()) return
    if (path2.isImportDeclaration()) return
    if (path2.isExportDeclaration()) return
    const parent = path2.scope.getFunctionParent() || path2.scope.getProgramParent()
    parent.registerDeclaration(path2)
  },
  ImportDeclaration(path2) {
    const parent = path2.scope.getBlockParent()
    parent.registerDeclaration(path2)
  },
  ReferencedIdentifier(path2, state) {
    state.references.push(path2)
  },
  ForXStatement(path2, state) {
    const left = path2.get('left')
    if (left.isPattern() || left.isIdentifier()) {
      state.constantViolations.push(path2)
    } else if (left.isVar()) {
      const { scope: scope2 } = path2
      const parentScope = scope2.getFunctionParent() || scope2.getProgramParent()
      parentScope.registerBinding('var', left)
    }
  },
  ExportDeclaration: {
    exit(path2) {
      const { node: node2, scope: scope2 } = path2
      if (isExportAllDeclaration(node2)) return
      const declar = node2.declaration
      if (isClassDeclaration$2(declar) || isFunctionDeclaration(declar)) {
        const id = declar.id
        if (!id) return
        const binding2 = scope2.getBinding(id.name)
        binding2 == null ? void 0 : binding2.reference(path2)
      } else if (isVariableDeclaration(declar)) {
        for (const decl of declar.declarations) {
          for (const name of Object.keys(getBindingIdentifiers$1(decl))) {
            const binding2 = scope2.getBinding(name)
            binding2 == null ? void 0 : binding2.reference(path2)
          }
        }
      }
    },
  },
  LabeledStatement(path2) {
    path2.scope.getBlockParent().registerDeclaration(path2)
  },
  AssignmentExpression(path2, state) {
    state.assignments.push(path2)
  },
  UpdateExpression(path2, state) {
    state.constantViolations.push(path2)
  },
  UnaryExpression(path2, state) {
    if (path2.node.operator === 'delete') {
      state.constantViolations.push(path2)
    }
  },
  BlockScoped(path2) {
    let scope2 = path2.scope
    if (scope2.path === path2) scope2 = scope2.parent
    const parent = scope2.getBlockParent()
    parent.registerDeclaration(path2)
    if (path2.isClassDeclaration() && path2.node.id) {
      const id = path2.node.id
      const name = id.name
      path2.scope.bindings[name] = path2.scope.parent.getBinding(name)
    }
  },
  CatchClause(path2) {
    path2.scope.registerBinding('let', path2)
  },
  Function(path2) {
    const params = path2.get('params')
    for (const param of params) {
      path2.scope.registerBinding('param', param)
    }
    if (path2.isFunctionExpression() && path2.has('id') && !path2.get('id').node[NOT_LOCAL_BINDING$1]) {
      path2.scope.registerBinding('local', path2.get('id'), path2)
    }
  },
  ClassExpression(path2) {
    if (path2.has('id') && !path2.get('id').node[NOT_LOCAL_BINDING$1]) {
      path2.scope.registerBinding('local', path2)
    }
  },
}
let uid = 0
class Scope$2 {
  constructor(path2) {
    this.uid = void 0
    this.path = void 0
    this.block = void 0
    this.labels = void 0
    this.inited = void 0
    this.bindings = void 0
    this.references = void 0
    this.globals = void 0
    this.uids = void 0
    this.data = void 0
    this.crawling = void 0
    const { node: node2 } = path2
    const cached = _cache$4.scope.get(node2)
    if ((cached == null ? void 0 : cached.path) === path2) {
      return cached
    }
    _cache$4.scope.set(node2, this)
    this.uid = uid++
    this.block = node2
    this.path = path2
    this.labels = /* @__PURE__ */ new Map()
    this.inited = false
  }
  get parent() {
    var _parent
    let parent,
      path2 = this.path
    do {
      const shouldSkip = path2.key === 'key' || path2.listKey === 'decorators'
      path2 = path2.parentPath
      if (shouldSkip && path2.isMethod()) path2 = path2.parentPath
      if (path2 && path2.isScope()) parent = path2
    } while (path2 && !parent)
    return (_parent = parent) == null ? void 0 : _parent.scope
  }
  get parentBlock() {
    return this.path.parent
  }
  get hub() {
    return this.path.hub
  }
  traverse(node2, opts, state) {
    ;(0, _index$6.default)(node2, opts, this, state, this.path)
  }
  generateDeclaredUidIdentifier(name) {
    const id = this.generateUidIdentifier(name)
    this.push({
      id,
    })
    return cloneNode$5(id)
  }
  generateUidIdentifier(name) {
    return identifier$5(this.generateUid(name))
  }
  generateUid(name = 'temp') {
    name = toIdentifier(name)
      .replace(/^_+/, '')
      .replace(/[0-9]+$/g, '')
    let uid2
    let i = 1
    do {
      uid2 = this._generateUid(name, i)
      i++
    } while (this.hasLabel(uid2) || this.hasBinding(uid2) || this.hasGlobal(uid2) || this.hasReference(uid2))
    const program2 = this.getProgramParent()
    program2.references[uid2] = true
    program2.uids[uid2] = true
    return uid2
  }
  _generateUid(name, i) {
    let id = name
    if (i > 1) id += i
    return `_${id}`
  }
  generateUidBasedOnNode(node2, defaultName) {
    const parts = []
    gatherNodeParts(node2, parts)
    let id = parts.join('$')
    id = id.replace(/^_/, '') || defaultName || 'ref'
    return this.generateUid(id.slice(0, 20))
  }
  generateUidIdentifierBasedOnNode(node2, defaultName) {
    return identifier$5(this.generateUidBasedOnNode(node2, defaultName))
  }
  isStatic(node2) {
    if (isThisExpression(node2) || isSuper$1(node2) || isTopicReference(node2)) {
      return true
    }
    if (isIdentifier$9(node2)) {
      const binding2 = this.getBinding(node2.name)
      if (binding2) {
        return binding2.constant
      } else {
        return this.hasBinding(node2.name)
      }
    }
    return false
  }
  maybeGenerateMemoised(node2, dontPush) {
    if (this.isStatic(node2)) {
      return null
    } else {
      const id = this.generateUidIdentifierBasedOnNode(node2)
      if (!dontPush) {
        this.push({
          id,
        })
        return cloneNode$5(id)
      }
      return id
    }
  }
  checkBlockScopedCollisions(local, kind, name, id) {
    if (kind === 'param') return
    if (local.kind === 'local') return
    const duplicate =
      kind === 'let' ||
      local.kind === 'let' ||
      local.kind === 'const' ||
      local.kind === 'module' ||
      (local.kind === 'param' && kind === 'const')
    if (duplicate) {
      throw this.hub.buildError(id, `Duplicate declaration "${name}"`, TypeError)
    }
  }
  rename(oldName, newName, block) {
    const binding2 = this.getBinding(oldName)
    if (binding2) {
      newName = newName || this.generateUidIdentifier(oldName).name
      return new _renamer.default(binding2, oldName, newName).rename(block)
    }
  }
  _renameFromMap(map, oldName, newName, value) {
    if (map[oldName]) {
      map[newName] = value
      map[oldName] = null
    }
  }
  dump() {
    const sep = '-'.repeat(60)
    console.log(sep)
    let scope2 = this
    do {
      console.log('#', scope2.block.type)
      for (const name of Object.keys(scope2.bindings)) {
        const binding2 = scope2.bindings[name]
        console.log(' -', name, {
          constant: binding2.constant,
          references: binding2.references,
          violations: binding2.constantViolations.length,
          kind: binding2.kind,
        })
      }
    } while ((scope2 = scope2.parent))
    console.log(sep)
  }
  toArray(node2, i, arrayLikeIsIterable) {
    if (isIdentifier$9(node2)) {
      const binding2 = this.getBinding(node2.name)
      if (binding2 != null && binding2.constant && binding2.path.isGenericType('Array')) {
        return node2
      }
    }
    if (isArrayExpression$1(node2)) {
      return node2
    }
    if (
      isIdentifier$9(node2, {
        name: 'arguments',
      })
    ) {
      return callExpression$3(
        memberExpression$1(
          memberExpression$1(
            memberExpression$1(identifier$5('Array'), identifier$5('prototype')),
            identifier$5('slice')
          ),
          identifier$5('call')
        ),
        [node2]
      )
    }
    let helperName
    const args = [node2]
    if (i === true) {
      helperName = 'toConsumableArray'
    } else if (i) {
      args.push(numericLiteral$2(i))
      helperName = 'slicedToArray'
    } else {
      helperName = 'toArray'
    }
    if (arrayLikeIsIterable) {
      args.unshift(this.hub.addHelper(helperName))
      helperName = 'maybeArrayLike'
    }
    return callExpression$3(this.hub.addHelper(helperName), args)
  }
  hasLabel(name) {
    return !!this.getLabel(name)
  }
  getLabel(name) {
    return this.labels.get(name)
  }
  registerLabel(path2) {
    this.labels.set(path2.node.label.name, path2)
  }
  registerDeclaration(path2) {
    if (path2.isLabeledStatement()) {
      this.registerLabel(path2)
    } else if (path2.isFunctionDeclaration()) {
      this.registerBinding('hoisted', path2.get('id'), path2)
    } else if (path2.isVariableDeclaration()) {
      const declarations = path2.get('declarations')
      for (const declar of declarations) {
        this.registerBinding(path2.node.kind, declar)
      }
    } else if (path2.isClassDeclaration()) {
      if (path2.node.declare) return
      this.registerBinding('let', path2)
    } else if (path2.isImportDeclaration()) {
      const specifiers = path2.get('specifiers')
      for (const specifier of specifiers) {
        this.registerBinding('module', specifier)
      }
    } else if (path2.isExportDeclaration()) {
      const declar = path2.get('declaration')
      if (declar.isClassDeclaration() || declar.isFunctionDeclaration() || declar.isVariableDeclaration()) {
        this.registerDeclaration(declar)
      }
    } else {
      this.registerBinding('unknown', path2)
    }
  }
  buildUndefinedNode() {
    return unaryExpression$2('void', numericLiteral$2(0), true)
  }
  registerConstantViolation(path2) {
    const ids = path2.getBindingIdentifiers()
    for (const name of Object.keys(ids)) {
      const binding2 = this.getBinding(name)
      if (binding2) binding2.reassign(path2)
    }
  }
  registerBinding(kind, path2, bindingPath = path2) {
    if (!kind) throw new ReferenceError('no `kind`')
    if (path2.isVariableDeclaration()) {
      const declarators = path2.get('declarations')
      for (const declar of declarators) {
        this.registerBinding(kind, declar)
      }
      return
    }
    const parent = this.getProgramParent()
    const ids = path2.getOuterBindingIdentifiers(true)
    for (const name of Object.keys(ids)) {
      parent.references[name] = true
      for (const id of ids[name]) {
        const local = this.getOwnBinding(name)
        if (local) {
          if (local.identifier === id) continue
          this.checkBlockScopedCollisions(local, kind, name, id)
        }
        if (local) {
          this.registerConstantViolation(bindingPath)
        } else {
          this.bindings[name] = new _binding.default({
            identifier: id,
            scope: this,
            path: bindingPath,
            kind,
          })
        }
      }
    }
  }
  addGlobal(node2) {
    this.globals[node2.name] = node2
  }
  hasUid(name) {
    let scope2 = this
    do {
      if (scope2.uids[name]) return true
    } while ((scope2 = scope2.parent))
    return false
  }
  hasGlobal(name) {
    let scope2 = this
    do {
      if (scope2.globals[name]) return true
    } while ((scope2 = scope2.parent))
    return false
  }
  hasReference(name) {
    return !!this.getProgramParent().references[name]
  }
  isPure(node2, constantsOnly) {
    if (isIdentifier$9(node2)) {
      const binding2 = this.getBinding(node2.name)
      if (!binding2) return false
      if (constantsOnly) return binding2.constant
      return true
    } else if (isThisExpression(node2) || isMetaProperty(node2) || isTopicReference(node2) || isPrivateName(node2)) {
      return true
    } else if (isClass(node2)) {
      var _node$decorators
      if (node2.superClass && !this.isPure(node2.superClass, constantsOnly)) {
        return false
      }
      if (((_node$decorators = node2.decorators) == null ? void 0 : _node$decorators.length) > 0) {
        return false
      }
      return this.isPure(node2.body, constantsOnly)
    } else if (isClassBody(node2)) {
      for (const method of node2.body) {
        if (!this.isPure(method, constantsOnly)) return false
      }
      return true
    } else if (isBinary$3(node2)) {
      return this.isPure(node2.left, constantsOnly) && this.isPure(node2.right, constantsOnly)
    } else if (isArrayExpression$1(node2) || isTupleExpression(node2)) {
      for (const elem of node2.elements) {
        if (elem !== null && !this.isPure(elem, constantsOnly)) return false
      }
      return true
    } else if (isObjectExpression$1(node2) || isRecordExpression(node2)) {
      for (const prop of node2.properties) {
        if (!this.isPure(prop, constantsOnly)) return false
      }
      return true
    } else if (isMethod(node2)) {
      var _node$decorators2
      if (node2.computed && !this.isPure(node2.key, constantsOnly)) return false
      if (((_node$decorators2 = node2.decorators) == null ? void 0 : _node$decorators2.length) > 0) {
        return false
      }
      return true
    } else if (isProperty(node2)) {
      var _node$decorators3
      if (node2.computed && !this.isPure(node2.key, constantsOnly)) return false
      if (((_node$decorators3 = node2.decorators) == null ? void 0 : _node$decorators3.length) > 0) {
        return false
      }
      if (isObjectProperty$1(node2) || node2.static) {
        if (node2.value !== null && !this.isPure(node2.value, constantsOnly)) {
          return false
        }
      }
      return true
    } else if (isUnaryExpression(node2)) {
      return this.isPure(node2.argument, constantsOnly)
    } else if (isTaggedTemplateExpression$1(node2)) {
      return (
        matchesPattern$1(node2.tag, 'String.raw') &&
        !this.hasBinding('String', true) &&
        this.isPure(node2.quasi, constantsOnly)
      )
    } else if (isTemplateLiteral$1(node2)) {
      for (const expression2 of node2.expressions) {
        if (!this.isPure(expression2, constantsOnly)) return false
      }
      return true
    } else {
      return isPureish(node2)
    }
  }
  setData(key, val) {
    return (this.data[key] = val)
  }
  getData(key) {
    let scope2 = this
    do {
      const data = scope2.data[key]
      if (data != null) return data
    } while ((scope2 = scope2.parent))
  }
  removeData(key) {
    let scope2 = this
    do {
      const data = scope2.data[key]
      if (data != null) scope2.data[key] = null
    } while ((scope2 = scope2.parent))
  }
  init() {
    if (!this.inited) {
      this.inited = true
      this.crawl()
    }
  }
  crawl() {
    const path2 = this.path
    this.references = /* @__PURE__ */ Object.create(null)
    this.bindings = /* @__PURE__ */ Object.create(null)
    this.globals = /* @__PURE__ */ Object.create(null)
    this.uids = /* @__PURE__ */ Object.create(null)
    this.data = /* @__PURE__ */ Object.create(null)
    const programParent = this.getProgramParent()
    if (programParent.crawling) return
    const state = {
      references: [],
      constantViolations: [],
      assignments: [],
    }
    this.crawling = true
    if (path2.type !== 'Program' && collectorVisitor._exploded) {
      for (const visit2 of collectorVisitor.enter) {
        visit2(path2, state)
      }
      const typeVisitors = collectorVisitor[path2.type]
      if (typeVisitors) {
        for (const visit2 of typeVisitors.enter) {
          visit2(path2, state)
        }
      }
    }
    path2.traverse(collectorVisitor, state)
    this.crawling = false
    for (const path3 of state.assignments) {
      const ids = path3.getBindingIdentifiers()
      for (const name of Object.keys(ids)) {
        if (path3.scope.getBinding(name)) continue
        programParent.addGlobal(ids[name])
      }
      path3.scope.registerConstantViolation(path3)
    }
    for (const ref2 of state.references) {
      const binding2 = ref2.scope.getBinding(ref2.node.name)
      if (binding2) {
        binding2.reference(ref2)
      } else {
        programParent.addGlobal(ref2.node)
      }
    }
    for (const path3 of state.constantViolations) {
      path3.scope.registerConstantViolation(path3)
    }
  }
  push(opts) {
    let path2 = this.path
    if (path2.isPattern()) {
      path2 = this.getPatternParent().path
    } else if (!path2.isBlockStatement() && !path2.isProgram()) {
      path2 = this.getBlockParent().path
    }
    if (path2.isSwitchStatement()) {
      path2 = (this.getFunctionParent() || this.getProgramParent()).path
    }
    if (path2.isLoop() || path2.isCatchClause() || path2.isFunction()) {
      path2.ensureBlock()
      path2 = path2.get('body')
    }
    const unique = opts.unique
    const kind = opts.kind || 'var'
    const blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist
    const dataKey = `declaration:${kind}:${blockHoist}`
    let declarPath = !unique && path2.getData(dataKey)
    if (!declarPath) {
      const declar = variableDeclaration$1(kind, [])
      declar._blockHoist = blockHoist
      ;[declarPath] = path2.unshiftContainer('body', [declar])
      if (!unique) path2.setData(dataKey, declarPath)
    }
    const declarator = variableDeclarator$1(opts.id, opts.init)
    const len = declarPath.node.declarations.push(declarator)
    path2.scope.registerBinding(kind, declarPath.get('declarations')[len - 1])
  }
  getProgramParent() {
    let scope2 = this
    do {
      if (scope2.path.isProgram()) {
        return scope2
      }
    } while ((scope2 = scope2.parent))
    throw new Error("Couldn't find a Program")
  }
  getFunctionParent() {
    let scope2 = this
    do {
      if (scope2.path.isFunctionParent()) {
        return scope2
      }
    } while ((scope2 = scope2.parent))
    return null
  }
  getBlockParent() {
    let scope2 = this
    do {
      if (scope2.path.isBlockParent()) {
        return scope2
      }
    } while ((scope2 = scope2.parent))
    throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...")
  }
  getPatternParent() {
    let scope2 = this
    do {
      if (!scope2.path.isPattern()) {
        return scope2.getBlockParent()
      }
    } while ((scope2 = scope2.parent.parent))
    throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...")
  }
  getAllBindings() {
    const ids = /* @__PURE__ */ Object.create(null)
    let scope2 = this
    do {
      for (const key of Object.keys(scope2.bindings)) {
        if (key in ids === false) {
          ids[key] = scope2.bindings[key]
        }
      }
      scope2 = scope2.parent
    } while (scope2)
    return ids
  }
  getAllBindingsOfKind(...kinds) {
    const ids = /* @__PURE__ */ Object.create(null)
    for (const kind of kinds) {
      let scope2 = this
      do {
        for (const name of Object.keys(scope2.bindings)) {
          const binding2 = scope2.bindings[name]
          if (binding2.kind === kind) ids[name] = binding2
        }
        scope2 = scope2.parent
      } while (scope2)
    }
    return ids
  }
  bindingIdentifierEquals(name, node2) {
    return this.getBindingIdentifier(name) === node2
  }
  getBinding(name) {
    let scope2 = this
    let previousPath
    do {
      const binding2 = scope2.getOwnBinding(name)
      if (binding2) {
        var _previousPath
        if (
          (_previousPath = previousPath) != null &&
          _previousPath.isPattern() &&
          binding2.kind !== 'param' &&
          binding2.kind !== 'local'
        );
        else {
          return binding2
        }
      } else if (
        !binding2 &&
        name === 'arguments' &&
        scope2.path.isFunction() &&
        !scope2.path.isArrowFunctionExpression()
      ) {
        break
      }
      previousPath = scope2.path
    } while ((scope2 = scope2.parent))
  }
  getOwnBinding(name) {
    return this.bindings[name]
  }
  getBindingIdentifier(name) {
    var _this$getBinding
    return (_this$getBinding = this.getBinding(name)) == null ? void 0 : _this$getBinding.identifier
  }
  getOwnBindingIdentifier(name) {
    const binding2 = this.bindings[name]
    return binding2 == null ? void 0 : binding2.identifier
  }
  hasOwnBinding(name) {
    return !!this.getOwnBinding(name)
  }
  hasBinding(name, noGlobals) {
    if (!name) return false
    if (this.hasOwnBinding(name)) return true
    if (this.parentHasBinding(name, noGlobals)) return true
    if (this.hasUid(name)) return true
    if (!noGlobals && Scope$2.globals.includes(name)) return true
    if (!noGlobals && Scope$2.contextVariables.includes(name)) return true
    return false
  }
  parentHasBinding(name, noGlobals) {
    var _this$parent
    return (_this$parent = this.parent) == null ? void 0 : _this$parent.hasBinding(name, noGlobals)
  }
  moveBindingTo(name, scope2) {
    const info = this.getBinding(name)
    if (info) {
      info.scope.removeOwnBinding(name)
      info.scope = scope2
      scope2.bindings[name] = info
    }
  }
  removeOwnBinding(name) {
    delete this.bindings[name]
  }
  removeBinding(name) {
    var _this$getBinding2
    ;(_this$getBinding2 = this.getBinding(name)) == null ? void 0 : _this$getBinding2.scope.removeOwnBinding(name)
    let scope2 = this
    do {
      if (scope2.uids[name]) {
        scope2.uids[name] = false
      }
    } while ((scope2 = scope2.parent))
  }
}
scope.default = Scope$2
Scope$2.globals = Object.keys(_globals.builtin)
Scope$2.contextVariables = ['arguments', 'undefined', 'Infinity', 'NaN']
var lib$7 = {}
var sourceMap = {}
var genMapping_umd = { exports: {} }
var setArray_umd = { exports: {} }
;(function (module, exports) {
  ;(function (global2, factory) {
    factory(exports)
  })(commonjsGlobal, function (exports2) {
    exports2.get = void 0
    exports2.put = void 0
    exports2.pop = void 0
    class SetArray {
      constructor() {
        this._indexes = { __proto__: null }
        this.array = []
      }
    }
    ;(() => {
      exports2.get = (strarr, key) => strarr._indexes[key]
      exports2.put = (strarr, key) => {
        const index2 = exports2.get(strarr, key)
        if (index2 !== void 0) return index2
        const { array, _indexes: indexes } = strarr
        return (indexes[key] = array.push(key) - 1)
      }
      exports2.pop = (strarr) => {
        const { array, _indexes: indexes } = strarr
        if (array.length === 0) return
        const last2 = array.pop()
        indexes[last2] = void 0
      }
    })()
    exports2.SetArray = SetArray
    Object.defineProperty(exports2, '__esModule', { value: true })
  })
})(setArray_umd, setArray_umd.exports)
var sourcemapCodec_umd = { exports: {} }
;(function (module, exports) {
  ;(function (global2, factory) {
    factory(exports)
  })(commonjsGlobal, function (exports2) {
    const comma = ','.charCodeAt(0)
    const semicolon = ';'.charCodeAt(0)
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
    const intToChar = new Uint8Array(64)
    const charToInt = new Uint8Array(128)
    for (let i = 0; i < chars.length; i++) {
      const c = chars.charCodeAt(i)
      intToChar[i] = c
      charToInt[c] = i
    }
    const td =
      typeof TextDecoder !== 'undefined'
        ? /* @__PURE__ */ new TextDecoder()
        : typeof Buffer !== 'undefined'
        ? {
            decode(buf) {
              const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength)
              return out.toString()
            },
          }
        : {
            decode(buf) {
              let out = ''
              for (let i = 0; i < buf.length; i++) {
                out += String.fromCharCode(buf[i])
              }
              return out
            },
          }
    function decode(mappings) {
      const state = new Int32Array(5)
      const decoded = []
      let index2 = 0
      do {
        const semi = indexOf(mappings, index2)
        const line = []
        let sorted = true
        let lastCol = 0
        state[0] = 0
        for (let i = index2; i < semi; i++) {
          let seg
          i = decodeInteger(mappings, i, state, 0)
          const col = state[0]
          if (col < lastCol) sorted = false
          lastCol = col
          if (hasMoreVlq(mappings, i, semi)) {
            i = decodeInteger(mappings, i, state, 1)
            i = decodeInteger(mappings, i, state, 2)
            i = decodeInteger(mappings, i, state, 3)
            if (hasMoreVlq(mappings, i, semi)) {
              i = decodeInteger(mappings, i, state, 4)
              seg = [col, state[1], state[2], state[3], state[4]]
            } else {
              seg = [col, state[1], state[2], state[3]]
            }
          } else {
            seg = [col]
          }
          line.push(seg)
        }
        if (!sorted) sort(line)
        decoded.push(line)
        index2 = semi + 1
      } while (index2 <= mappings.length)
      return decoded
    }
    function indexOf(mappings, index2) {
      const idx = mappings.indexOf(';', index2)
      return idx === -1 ? mappings.length : idx
    }
    function decodeInteger(mappings, pos, state, j) {
      let value = 0
      let shift = 0
      let integer = 0
      do {
        const c = mappings.charCodeAt(pos++)
        integer = charToInt[c]
        value |= (integer & 31) << shift
        shift += 5
      } while (integer & 32)
      const shouldNegate = value & 1
      value >>>= 1
      if (shouldNegate) {
        value = -2147483648 | -value
      }
      state[j] += value
      return pos
    }
    function hasMoreVlq(mappings, i, length) {
      if (i >= length) return false
      return mappings.charCodeAt(i) !== comma
    }
    function sort(line) {
      line.sort(sortComparator)
    }
    function sortComparator(a, b) {
      return a[0] - b[0]
    }
    function encode(decoded) {
      const state = new Int32Array(5)
      const bufLength = 1024 * 16
      const subLength = bufLength - 36
      const buf = new Uint8Array(bufLength)
      const sub2 = buf.subarray(0, subLength)
      let pos = 0
      let out = ''
      for (let i = 0; i < decoded.length; i++) {
        const line = decoded[i]
        if (i > 0) {
          if (pos === bufLength) {
            out += td.decode(buf)
            pos = 0
          }
          buf[pos++] = semicolon
        }
        if (line.length === 0) continue
        state[0] = 0
        for (let j = 0; j < line.length; j++) {
          const segment = line[j]
          if (pos > subLength) {
            out += td.decode(sub2)
            buf.copyWithin(0, subLength, pos)
            pos -= subLength
          }
          if (j > 0) buf[pos++] = comma
          pos = encodeInteger(buf, pos, state, segment, 0)
          if (segment.length === 1) continue
          pos = encodeInteger(buf, pos, state, segment, 1)
          pos = encodeInteger(buf, pos, state, segment, 2)
          pos = encodeInteger(buf, pos, state, segment, 3)
          if (segment.length === 4) continue
          pos = encodeInteger(buf, pos, state, segment, 4)
        }
      }
      return out + td.decode(buf.subarray(0, pos))
    }
    function encodeInteger(buf, pos, state, segment, j) {
      const next = segment[j]
      let num = next - state[j]
      state[j] = next
      num = num < 0 ? (-num << 1) | 1 : num << 1
      do {
        let clamped = num & 31
        num >>>= 5
        if (num > 0) clamped |= 32
        buf[pos++] = intToChar[clamped]
      } while (num > 0)
      return pos
    }
    exports2.decode = decode
    exports2.encode = encode
    Object.defineProperty(exports2, '__esModule', { value: true })
  })
})(sourcemapCodec_umd, sourcemapCodec_umd.exports)
var traceMapping_umd = { exports: {} }
var resolveUri_umd = { exports: {} }
;(function (module, exports) {
  ;(function (global2, factory) {
    module.exports = factory()
  })(commonjsGlobal, function () {
    const schemeRegex = /^[\w+.-]+:\/\//
    const urlRegex = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?/
    const fileRegex = /^file:(?:\/\/((?![a-z]:)[^/]*)?)?(\/?.*)/i
    function isAbsoluteUrl(input) {
      return schemeRegex.test(input)
    }
    function isSchemeRelativeUrl(input) {
      return input.startsWith('//')
    }
    function isAbsolutePath(input) {
      return input.startsWith('/')
    }
    function isFileUrl(input) {
      return input.startsWith('file:')
    }
    function parseAbsoluteUrl(input) {
      const match = urlRegex.exec(input)
      return makeUrl(match[1], match[2] || '', match[3], match[4] || '', match[5] || '/')
    }
    function parseFileUrl(input) {
      const match = fileRegex.exec(input)
      const path2 = match[2]
      return makeUrl('file:', '', match[1] || '', '', isAbsolutePath(path2) ? path2 : '/' + path2)
    }
    function makeUrl(scheme, user, host, port, path2) {
      return {
        scheme,
        user,
        host,
        port,
        path: path2,
        relativePath: false,
      }
    }
    function parseUrl(input) {
      if (isSchemeRelativeUrl(input)) {
        const url2 = parseAbsoluteUrl('http:' + input)
        url2.scheme = ''
        return url2
      }
      if (isAbsolutePath(input)) {
        const url2 = parseAbsoluteUrl('http://foo.com' + input)
        url2.scheme = ''
        url2.host = ''
        return url2
      }
      if (isFileUrl(input)) return parseFileUrl(input)
      if (isAbsoluteUrl(input)) return parseAbsoluteUrl(input)
      const url = parseAbsoluteUrl('http://foo.com/' + input)
      url.scheme = ''
      url.host = ''
      url.relativePath = true
      return url
    }
    function stripPathFilename(path2) {
      if (path2.endsWith('/..')) return path2
      const index2 = path2.lastIndexOf('/')
      return path2.slice(0, index2 + 1)
    }
    function mergePaths(url, base2) {
      if (!url.relativePath) return
      normalizePath(base2)
      if (url.path === '/') {
        url.path = base2.path
      } else {
        url.path = stripPathFilename(base2.path) + url.path
      }
      url.relativePath = base2.relativePath
    }
    function normalizePath(url) {
      const { relativePath } = url
      const pieces = url.path.split('/')
      let pointer = 1
      let positive = 0
      let addTrailingSlash = false
      for (let i = 1; i < pieces.length; i++) {
        const piece = pieces[i]
        if (!piece) {
          addTrailingSlash = true
          continue
        }
        addTrailingSlash = false
        if (piece === '.') continue
        if (piece === '..') {
          if (positive) {
            addTrailingSlash = true
            positive--
            pointer--
          } else if (relativePath) {
            pieces[pointer++] = piece
          }
          continue
        }
        pieces[pointer++] = piece
        positive++
      }
      let path2 = ''
      for (let i = 1; i < pointer; i++) {
        path2 += '/' + pieces[i]
      }
      if (!path2 || (addTrailingSlash && !path2.endsWith('/..'))) {
        path2 += '/'
      }
      url.path = path2
    }
    function resolve2(input, base2) {
      if (!input && !base2) return ''
      const url = parseUrl(input)
      if (base2 && !url.scheme) {
        const baseUrl = parseUrl(base2)
        url.scheme = baseUrl.scheme
        if (!url.host) {
          url.user = baseUrl.user
          url.host = baseUrl.host
          url.port = baseUrl.port
        }
        mergePaths(url, baseUrl)
      }
      normalizePath(url)
      if (url.relativePath) {
        const path2 = url.path.slice(1)
        if (!path2) return '.'
        const keepRelative = (base2 || input).startsWith('.')
        return !keepRelative || path2.startsWith('.') ? path2 : './' + path2
      }
      if (!url.scheme && !url.host) return url.path
      return `${url.scheme}//${url.user}${url.host}${url.port}${url.path}`
    }
    return resolve2
  })
})(resolveUri_umd)
;(function (module, exports) {
  ;(function (global2, factory) {
    factory(exports, sourcemapCodec_umd.exports, resolveUri_umd.exports)
  })(commonjsGlobal, function (exports2, sourcemapCodec, resolveUri) {
    function _interopDefaultLegacy(e) {
      return e && typeof e === 'object' && 'default' in e ? e : { default: e }
    }
    var resolveUri__default = /* @__PURE__ */ _interopDefaultLegacy(resolveUri)
    function resolve2(input, base2) {
      if (base2 && !base2.endsWith('/')) base2 += '/'
      return resolveUri__default['default'](input, base2)
    }
    function stripFilename(path2) {
      if (!path2) return ''
      const index2 = path2.lastIndexOf('/')
      return path2.slice(0, index2 + 1)
    }
    const COLUMN = 0
    const SOURCES_INDEX = 1
    const SOURCE_LINE = 2
    const SOURCE_COLUMN = 3
    const NAMES_INDEX = 4
    const REV_GENERATED_LINE = 1
    const REV_GENERATED_COLUMN = 2
    function maybeSort(mappings, owned) {
      const unsortedIndex = nextUnsortedSegmentLine(mappings, 0)
      if (unsortedIndex === mappings.length) return mappings
      if (!owned) mappings = mappings.slice()
      for (let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {
        mappings[i] = sortSegments(mappings[i], owned)
      }
      return mappings
    }
    function nextUnsortedSegmentLine(mappings, start) {
      for (let i = start; i < mappings.length; i++) {
        if (!isSorted(mappings[i])) return i
      }
      return mappings.length
    }
    function isSorted(line) {
      for (let j = 1; j < line.length; j++) {
        if (line[j][COLUMN] < line[j - 1][COLUMN]) {
          return false
        }
      }
      return true
    }
    function sortSegments(line, owned) {
      if (!owned) line = line.slice()
      return line.sort(sortComparator)
    }
    function sortComparator(a, b) {
      return a[COLUMN] - b[COLUMN]
    }
    let found = false
    function binarySearch(haystack, needle, low, high) {
      while (low <= high) {
        const mid = low + ((high - low) >> 1)
        const cmp = haystack[mid][COLUMN] - needle
        if (cmp === 0) {
          found = true
          return mid
        }
        if (cmp < 0) {
          low = mid + 1
        } else {
          high = mid - 1
        }
      }
      found = false
      return low - 1
    }
    function upperBound(haystack, needle, index2) {
      for (let i = index2 + 1; i < haystack.length; index2 = i++) {
        if (haystack[i][COLUMN] !== needle) break
      }
      return index2
    }
    function lowerBound(haystack, needle, index2) {
      for (let i = index2 - 1; i >= 0; index2 = i--) {
        if (haystack[i][COLUMN] !== needle) break
      }
      return index2
    }
    function memoizedState() {
      return {
        lastKey: -1,
        lastNeedle: -1,
        lastIndex: -1,
      }
    }
    function memoizedBinarySearch(haystack, needle, state, key) {
      const { lastKey, lastNeedle, lastIndex } = state
      let low = 0
      let high = haystack.length - 1
      if (key === lastKey) {
        if (needle === lastNeedle) {
          found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle
          return lastIndex
        }
        if (needle >= lastNeedle) {
          low = lastIndex === -1 ? 0 : lastIndex
        } else {
          high = lastIndex
        }
      }
      state.lastKey = key
      state.lastNeedle = needle
      return (state.lastIndex = binarySearch(haystack, needle, low, high))
    }
    function buildBySources(decoded, memos) {
      const sources = memos.map(buildNullArray)
      for (let i = 0; i < decoded.length; i++) {
        const line = decoded[i]
        for (let j = 0; j < line.length; j++) {
          const seg = line[j]
          if (seg.length === 1) continue
          const sourceIndex = seg[SOURCES_INDEX]
          const sourceLine = seg[SOURCE_LINE]
          const sourceColumn = seg[SOURCE_COLUMN]
          const originalSource = sources[sourceIndex]
          const originalLine = originalSource[sourceLine] || (originalSource[sourceLine] = [])
          const memo = memos[sourceIndex]
          const index2 = upperBound(
            originalLine,
            sourceColumn,
            memoizedBinarySearch(originalLine, sourceColumn, memo, sourceLine)
          )
          insert(originalLine, (memo.lastIndex = index2 + 1), [sourceColumn, i, seg[COLUMN]])
        }
      }
      return sources
    }
    function insert(array, index2, value) {
      for (let i = array.length; i > index2; i--) {
        array[i] = array[i - 1]
      }
      array[index2] = value
    }
    function buildNullArray() {
      return { __proto__: null }
    }
    const AnyMap = function (map, mapUrl) {
      const parsed = typeof map === 'string' ? JSON.parse(map) : map
      if (!('sections' in parsed)) return new TraceMap(parsed, mapUrl)
      const mappings = []
      const sources = []
      const sourcesContent = []
      const names = []
      recurse(parsed, mapUrl, mappings, sources, sourcesContent, names, 0, 0, Infinity, Infinity)
      const joined = {
        version: 3,
        file: parsed.file,
        names,
        sources,
        sourcesContent,
        mappings,
      }
      return exports2.presortedDecodedMap(joined)
    }
    function recurse(
      input,
      mapUrl,
      mappings,
      sources,
      sourcesContent,
      names,
      lineOffset,
      columnOffset,
      stopLine,
      stopColumn
    ) {
      const { sections } = input
      for (let i = 0; i < sections.length; i++) {
        const { map, offset } = sections[i]
        let sl = stopLine
        let sc = stopColumn
        if (i + 1 < sections.length) {
          const nextOffset = sections[i + 1].offset
          sl = Math.min(stopLine, lineOffset + nextOffset.line)
          if (sl === stopLine) {
            sc = Math.min(stopColumn, columnOffset + nextOffset.column)
          } else if (sl < stopLine) {
            sc = columnOffset + nextOffset.column
          }
        }
        addSection(
          map,
          mapUrl,
          mappings,
          sources,
          sourcesContent,
          names,
          lineOffset + offset.line,
          columnOffset + offset.column,
          sl,
          sc
        )
      }
    }
    function addSection(
      input,
      mapUrl,
      mappings,
      sources,
      sourcesContent,
      names,
      lineOffset,
      columnOffset,
      stopLine,
      stopColumn
    ) {
      if ('sections' in input) return recurse(...arguments)
      const map = new TraceMap(input, mapUrl)
      const sourcesOffset = sources.length
      const namesOffset = names.length
      const decoded = exports2.decodedMappings(map)
      const { resolvedSources, sourcesContent: contents } = map
      append(sources, resolvedSources)
      append(names, map.names)
      if (contents) append(sourcesContent, contents)
      else for (let i = 0; i < resolvedSources.length; i++) sourcesContent.push(null)
      for (let i = 0; i < decoded.length; i++) {
        const lineI = lineOffset + i
        if (lineI > stopLine) return
        const out = getLine(mappings, lineI)
        const cOffset = i === 0 ? columnOffset : 0
        const line = decoded[i]
        for (let j = 0; j < line.length; j++) {
          const seg = line[j]
          const column = cOffset + seg[COLUMN]
          if (lineI === stopLine && column >= stopColumn) return
          if (seg.length === 1) {
            out.push([column])
            continue
          }
          const sourcesIndex = sourcesOffset + seg[SOURCES_INDEX]
          const sourceLine = seg[SOURCE_LINE]
          const sourceColumn = seg[SOURCE_COLUMN]
          out.push(
            seg.length === 4
              ? [column, sourcesIndex, sourceLine, sourceColumn]
              : [column, sourcesIndex, sourceLine, sourceColumn, namesOffset + seg[NAMES_INDEX]]
          )
        }
      }
    }
    function append(arr, other) {
      for (let i = 0; i < other.length; i++) arr.push(other[i])
    }
    function getLine(arr, index2) {
      for (let i = arr.length; i <= index2; i++) arr[i] = []
      return arr[index2]
    }
    const LINE_GTR_ZERO = '`line` must be greater than 0 (lines start at line 1)'
    const COL_GTR_EQ_ZERO = '`column` must be greater than or equal to 0 (columns start at column 0)'
    const LEAST_UPPER_BOUND = -1
    const GREATEST_LOWER_BOUND = 1
    exports2.encodedMappings = void 0
    exports2.decodedMappings = void 0
    exports2.traceSegment = void 0
    exports2.originalPositionFor = void 0
    exports2.generatedPositionFor = void 0
    exports2.eachMapping = void 0
    exports2.sourceContentFor = void 0
    exports2.presortedDecodedMap = void 0
    exports2.decodedMap = void 0
    exports2.encodedMap = void 0
    class TraceMap {
      constructor(map, mapUrl) {
        this._decodedMemo = memoizedState()
        this._bySources = void 0
        this._bySourceMemos = void 0
        const isString2 = typeof map === 'string'
        if (!isString2 && map._decodedMemo) return map
        const parsed = isString2 ? JSON.parse(map) : map
        const { version, file: file2, names, sourceRoot, sources, sourcesContent } = parsed
        this.version = version
        this.file = file2
        this.names = names
        this.sourceRoot = sourceRoot
        this.sources = sources
        this.sourcesContent = sourcesContent
        const from = resolve2(sourceRoot || '', stripFilename(mapUrl))
        this.resolvedSources = sources.map((s2) => resolve2(s2 || '', from))
        const { mappings } = parsed
        if (typeof mappings === 'string') {
          this._encoded = mappings
          this._decoded = void 0
        } else {
          this._encoded = void 0
          this._decoded = maybeSort(mappings, isString2)
        }
      }
    }
    ;(() => {
      exports2.encodedMappings = (map) => {
        var _a
        return (_a = map._encoded) !== null && _a !== void 0 ? _a : (map._encoded = sourcemapCodec.encode(map._decoded))
      }
      exports2.decodedMappings = (map) => {
        return map._decoded || (map._decoded = sourcemapCodec.decode(map._encoded))
      }
      exports2.traceSegment = (map, line, column) => {
        const decoded = exports2.decodedMappings(map)
        if (line >= decoded.length) return null
        return traceSegmentInternal(decoded[line], map._decodedMemo, line, column, GREATEST_LOWER_BOUND)
      }
      exports2.originalPositionFor = (map, { line, column, bias }) => {
        line--
        if (line < 0) throw new Error(LINE_GTR_ZERO)
        if (column < 0) throw new Error(COL_GTR_EQ_ZERO)
        const decoded = exports2.decodedMappings(map)
        if (line >= decoded.length) return OMapping(null, null, null, null)
        const segment = traceSegmentInternal(
          decoded[line],
          map._decodedMemo,
          line,
          column,
          bias || GREATEST_LOWER_BOUND
        )
        if (segment == null) return OMapping(null, null, null, null)
        if (segment.length == 1) return OMapping(null, null, null, null)
        const { names, resolvedSources } = map
        return OMapping(
          resolvedSources[segment[SOURCES_INDEX]],
          segment[SOURCE_LINE] + 1,
          segment[SOURCE_COLUMN],
          segment.length === 5 ? names[segment[NAMES_INDEX]] : null
        )
      }
      exports2.generatedPositionFor = (map, { source, line, column, bias }) => {
        line--
        if (line < 0) throw new Error(LINE_GTR_ZERO)
        if (column < 0) throw new Error(COL_GTR_EQ_ZERO)
        const { sources, resolvedSources } = map
        let sourceIndex = sources.indexOf(source)
        if (sourceIndex === -1) sourceIndex = resolvedSources.indexOf(source)
        if (sourceIndex === -1) return GMapping(null, null)
        const generated2 =
          map._bySources ||
          (map._bySources = buildBySources(
            exports2.decodedMappings(map),
            (map._bySourceMemos = sources.map(memoizedState))
          ))
        const memos = map._bySourceMemos
        const segments = generated2[sourceIndex][line]
        if (segments == null) return GMapping(null, null)
        const segment = traceSegmentInternal(segments, memos[sourceIndex], line, column, bias || GREATEST_LOWER_BOUND)
        if (segment == null) return GMapping(null, null)
        return GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN])
      }
      exports2.eachMapping = (map, cb) => {
        const decoded = exports2.decodedMappings(map)
        const { names, resolvedSources } = map
        for (let i = 0; i < decoded.length; i++) {
          const line = decoded[i]
          for (let j = 0; j < line.length; j++) {
            const seg = line[j]
            const generatedLine = i + 1
            const generatedColumn = seg[0]
            let source = null
            let originalLine = null
            let originalColumn = null
            let name = null
            if (seg.length !== 1) {
              source = resolvedSources[seg[1]]
              originalLine = seg[2] + 1
              originalColumn = seg[3]
            }
            if (seg.length === 5) name = names[seg[4]]
            cb({
              generatedLine,
              generatedColumn,
              source,
              originalLine,
              originalColumn,
              name,
            })
          }
        }
      }
      exports2.sourceContentFor = (map, source) => {
        const { sources, resolvedSources, sourcesContent } = map
        if (sourcesContent == null) return null
        let index2 = sources.indexOf(source)
        if (index2 === -1) index2 = resolvedSources.indexOf(source)
        return index2 === -1 ? null : sourcesContent[index2]
      }
      exports2.presortedDecodedMap = (map, mapUrl) => {
        const clone2 = Object.assign({}, map)
        clone2.mappings = []
        const tracer = new TraceMap(clone2, mapUrl)
        tracer._decoded = map.mappings
        return tracer
      }
      exports2.decodedMap = (map) => {
        return {
          version: 3,
          file: map.file,
          names: map.names,
          sourceRoot: map.sourceRoot,
          sources: map.sources,
          sourcesContent: map.sourcesContent,
          mappings: exports2.decodedMappings(map),
        }
      }
      exports2.encodedMap = (map) => {
        return {
          version: 3,
          file: map.file,
          names: map.names,
          sourceRoot: map.sourceRoot,
          sources: map.sources,
          sourcesContent: map.sourcesContent,
          mappings: exports2.encodedMappings(map),
        }
      }
    })()
    function OMapping(source, line, column, name) {
      return { source, line, column, name }
    }
    function GMapping(line, column) {
      return { line, column }
    }
    function traceSegmentInternal(segments, memo, line, column, bias) {
      let index2 = memoizedBinarySearch(segments, column, memo, line)
      if (found) {
        index2 = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index2)
      } else if (bias === LEAST_UPPER_BOUND) index2++
      if (index2 === -1 || index2 === segments.length) return null
      return segments[index2]
    }
    exports2.AnyMap = AnyMap
    exports2.GREATEST_LOWER_BOUND = GREATEST_LOWER_BOUND
    exports2.LEAST_UPPER_BOUND = LEAST_UPPER_BOUND
    exports2.TraceMap = TraceMap
    Object.defineProperty(exports2, '__esModule', { value: true })
  })
})(traceMapping_umd, traceMapping_umd.exports)
;(function (module, exports) {
  ;(function (global2, factory) {
    factory(exports, setArray_umd.exports, sourcemapCodec_umd.exports, traceMapping_umd.exports)
  })(commonjsGlobal, function (exports2, setArray, sourcemapCodec, traceMapping) {
    const COLUMN = 0
    const SOURCES_INDEX = 1
    const SOURCE_LINE = 2
    const SOURCE_COLUMN = 3
    const NAMES_INDEX = 4
    const NO_NAME = -1
    exports2.addSegment = void 0
    exports2.addMapping = void 0
    exports2.maybeAddSegment = void 0
    exports2.maybeAddMapping = void 0
    exports2.setSourceContent = void 0
    exports2.toDecodedMap = void 0
    exports2.toEncodedMap = void 0
    exports2.fromMap = void 0
    exports2.allMappings = void 0
    let addSegmentInternal
    class GenMapping {
      constructor({ file: file2, sourceRoot } = {}) {
        this._names = new setArray.SetArray()
        this._sources = new setArray.SetArray()
        this._sourcesContent = []
        this._mappings = []
        this.file = file2
        this.sourceRoot = sourceRoot
      }
    }
    ;(() => {
      exports2.addSegment = (map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) => {
        return addSegmentInternal(false, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content)
      }
      exports2.maybeAddSegment = (map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) => {
        return addSegmentInternal(true, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content)
      }
      exports2.addMapping = (map, mapping) => {
        return addMappingInternal(false, map, mapping)
      }
      exports2.maybeAddMapping = (map, mapping) => {
        return addMappingInternal(true, map, mapping)
      }
      exports2.setSourceContent = (map, source, content) => {
        const { _sources: sources, _sourcesContent: sourcesContent } = map
        sourcesContent[setArray.put(sources, source)] = content
      }
      exports2.toDecodedMap = (map) => {
        const {
          file: file2,
          sourceRoot,
          _mappings: mappings,
          _sources: sources,
          _sourcesContent: sourcesContent,
          _names: names,
        } = map
        removeEmptyFinalLines(mappings)
        return {
          version: 3,
          file: file2 || void 0,
          names: names.array,
          sourceRoot: sourceRoot || void 0,
          sources: sources.array,
          sourcesContent,
          mappings,
        }
      }
      exports2.toEncodedMap = (map) => {
        const decoded = exports2.toDecodedMap(map)
        return Object.assign(Object.assign({}, decoded), { mappings: sourcemapCodec.encode(decoded.mappings) })
      }
      exports2.allMappings = (map) => {
        const out = []
        const { _mappings: mappings, _sources: sources, _names: names } = map
        for (let i = 0; i < mappings.length; i++) {
          const line = mappings[i]
          for (let j = 0; j < line.length; j++) {
            const seg = line[j]
            const generated2 = { line: i + 1, column: seg[COLUMN] }
            let source = void 0
            let original = void 0
            let name = void 0
            if (seg.length !== 1) {
              source = sources.array[seg[SOURCES_INDEX]]
              original = { line: seg[SOURCE_LINE] + 1, column: seg[SOURCE_COLUMN] }
              if (seg.length === 5) name = names.array[seg[NAMES_INDEX]]
            }
            out.push({ generated: generated2, source, original, name })
          }
        }
        return out
      }
      exports2.fromMap = (input) => {
        const map = new traceMapping.TraceMap(input)
        const gen = new GenMapping({ file: map.file, sourceRoot: map.sourceRoot })
        putAll(gen._names, map.names)
        putAll(gen._sources, map.sources)
        gen._sourcesContent = map.sourcesContent || map.sources.map(() => null)
        gen._mappings = traceMapping.decodedMappings(map)
        return gen
      }
      addSegmentInternal = (skipable, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) => {
        const { _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names } = map
        const line = getLine(mappings, genLine)
        const index2 = getColumnIndex(line, genColumn)
        if (!source) {
          if (skipable && skipSourceless(line, index2)) return
          return insert(line, index2, [genColumn])
        }
        const sourcesIndex = setArray.put(sources, source)
        const namesIndex = name ? setArray.put(names, name) : NO_NAME
        if (sourcesIndex === sourcesContent.length)
          sourcesContent[sourcesIndex] = content !== null && content !== void 0 ? content : null
        if (skipable && skipSource(line, index2, sourcesIndex, sourceLine, sourceColumn, namesIndex)) {
          return
        }
        return insert(
          line,
          index2,
          name
            ? [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex]
            : [genColumn, sourcesIndex, sourceLine, sourceColumn]
        )
      }
    })()
    function getLine(mappings, index2) {
      for (let i = mappings.length; i <= index2; i++) {
        mappings[i] = []
      }
      return mappings[index2]
    }
    function getColumnIndex(line, genColumn) {
      let index2 = line.length
      for (let i = index2 - 1; i >= 0; index2 = i--) {
        const current = line[i]
        if (genColumn >= current[COLUMN]) break
      }
      return index2
    }
    function insert(array, index2, value) {
      for (let i = array.length; i > index2; i--) {
        array[i] = array[i - 1]
      }
      array[index2] = value
    }
    function removeEmptyFinalLines(mappings) {
      const { length } = mappings
      let len = length
      for (let i = len - 1; i >= 0; len = i, i--) {
        if (mappings[i].length > 0) break
      }
      if (len < length) mappings.length = len
    }
    function putAll(strarr, array) {
      for (let i = 0; i < array.length; i++) setArray.put(strarr, array[i])
    }
    function skipSourceless(line, index2) {
      if (index2 === 0) return true
      const prev = line[index2 - 1]
      return prev.length === 1
    }
    function skipSource(line, index2, sourcesIndex, sourceLine, sourceColumn, namesIndex) {
      if (index2 === 0) return false
      const prev = line[index2 - 1]
      if (prev.length === 1) return false
      return (
        sourcesIndex === prev[SOURCES_INDEX] &&
        sourceLine === prev[SOURCE_LINE] &&
        sourceColumn === prev[SOURCE_COLUMN] &&
        namesIndex === (prev.length === 5 ? prev[NAMES_INDEX] : NO_NAME)
      )
    }
    function addMappingInternal(skipable, map, mapping) {
      const { generated: generated2, source, original, name, content } = mapping
      if (!source) {
        return addSegmentInternal(skipable, map, generated2.line - 1, generated2.column, null, null, null, null, null)
      }
      const s2 = source
      return addSegmentInternal(
        skipable,
        map,
        generated2.line - 1,
        generated2.column,
        s2,
        original.line - 1,
        original.column,
        name,
        content
      )
    }
    exports2.GenMapping = GenMapping
    Object.defineProperty(exports2, '__esModule', { value: true })
  })
})(genMapping_umd, genMapping_umd.exports)
Object.defineProperty(sourceMap, '__esModule', {
  value: true,
})
sourceMap.default = void 0
var _genMapping = genMapping_umd.exports
class SourceMap {
  constructor(opts, code2) {
    var _opts$sourceFileName
    this._map = void 0
    this._rawMappings = void 0
    this._sourceFileName = void 0
    this._lastGenLine = 0
    this._lastSourceLine = 0
    this._lastSourceColumn = 0
    const map = (this._map = new _genMapping.GenMapping({
      sourceRoot: opts.sourceRoot,
    }))
    this._sourceFileName =
      (_opts$sourceFileName = opts.sourceFileName) == null ? void 0 : _opts$sourceFileName.replace(/\\/g, '/')
    this._rawMappings = void 0
    if (typeof code2 === 'string') {
      ;(0, _genMapping.setSourceContent)(map, this._sourceFileName, code2)
    } else if (typeof code2 === 'object') {
      Object.keys(code2).forEach((sourceFileName) => {
        ;(0, _genMapping.setSourceContent)(map, sourceFileName.replace(/\\/g, '/'), code2[sourceFileName])
      })
    }
  }
  get() {
    return (0, _genMapping.toEncodedMap)(this._map)
  }
  getDecoded() {
    return (0, _genMapping.toDecodedMap)(this._map)
  }
  getRawMappings() {
    return this._rawMappings || (this._rawMappings = (0, _genMapping.allMappings)(this._map))
  }
  mark(generated2, line, column, identifierName, filename) {
    this._rawMappings = void 0
    ;(0, _genMapping.maybeAddMapping)(this._map, {
      name: identifierName,
      generated: generated2,
      source:
        line == null ? void 0 : (filename == null ? void 0 : filename.replace(/\\/g, '/')) || this._sourceFileName,
      original:
        line == null
          ? void 0
          : {
              line,
              column,
            },
    })
  }
}
sourceMap.default = SourceMap
var printer = {}
var buffer$1 = {}
Object.defineProperty(buffer$1, '__esModule', {
  value: true,
})
buffer$1.default = void 0
function SourcePos() {
  return {
    identifierName: void 0,
    line: void 0,
    column: void 0,
    filename: void 0,
  }
}
const SPACES_RE = /^[ \t]+$/
class Buffer$1 {
  constructor(map) {
    this._map = null
    this._buf = ''
    this._last = 0
    this._queue = []
    this._position = {
      line: 1,
      column: 0,
    }
    this._sourcePosition = SourcePos()
    this._disallowedPop = null
    this._map = map
  }
  get() {
    this._flush()
    const map = this._map
    const result = {
      code: this._buf.trimRight(),
      decodedMap: map == null ? void 0 : map.getDecoded(),
      get map() {
        return (result.map = map ? map.get() : null)
      },
      set map(value) {
        Object.defineProperty(result, 'map', {
          value,
          writable: true,
        })
      },
      get rawMappings() {
        return (result.rawMappings = map == null ? void 0 : map.getRawMappings())
      },
      set rawMappings(value) {
        Object.defineProperty(result, 'rawMappings', {
          value,
          writable: true,
        })
      },
    }
    return result
  }
  append(str) {
    this._flush()
    const { line, column, filename, identifierName } = this._sourcePosition
    this._append(str, line, column, identifierName, filename)
  }
  queue(str) {
    if (str === '\n') {
      while (this._queue.length > 0 && SPACES_RE.test(this._queue[0][0])) {
        this._queue.shift()
      }
    }
    const { line, column, filename, identifierName } = this._sourcePosition
    this._queue.unshift([str, line, column, identifierName, filename])
  }
  queueIndentation(str) {
    this._queue.unshift([str, void 0, void 0, void 0, void 0])
  }
  _flush() {
    let item
    while ((item = this._queue.pop())) {
      this._append(...item)
    }
  }
  _append(str, line, column, identifierName, filename) {
    this._buf += str
    this._last = str.charCodeAt(str.length - 1)
    let i = str.indexOf('\n')
    let last2 = 0
    if (i !== 0) {
      this._mark(line, column, identifierName, filename)
    }
    while (i !== -1) {
      this._position.line++
      this._position.column = 0
      last2 = i + 1
      if (last2 < str.length) {
        this._mark(++line, 0, identifierName, filename)
      }
      i = str.indexOf('\n', last2)
    }
    this._position.column += str.length - last2
  }
  _mark(line, column, identifierName, filename) {
    var _this$_map
    ;(_this$_map = this._map) == null ? void 0 : _this$_map.mark(this._position, line, column, identifierName, filename)
  }
  removeTrailingNewline() {
    if (this._queue.length > 0 && this._queue[0][0] === '\n') {
      this._queue.shift()
    }
  }
  removeLastSemicolon() {
    if (this._queue.length > 0 && this._queue[0][0] === ';') {
      this._queue.shift()
    }
  }
  getLastChar() {
    let last2
    if (this._queue.length > 0) {
      const str = this._queue[0][0]
      last2 = str.charCodeAt(0)
    } else {
      last2 = this._last
    }
    return last2
  }
  endsWithCharAndNewline() {
    const queue = this._queue
    if (queue.length > 0) {
      const last2 = queue[0][0]
      const lastCp = last2.charCodeAt(0)
      if (lastCp !== 10) return
      if (queue.length > 1) {
        const secondLast = queue[1][0]
        return secondLast.charCodeAt(0)
      } else {
        return this._last
      }
    }
  }
  hasContent() {
    return this._queue.length > 0 || !!this._last
  }
  exactSource(loc, cb) {
    this.source('start', loc)
    cb()
    this.source('end', loc)
    this._disallowPop('start', loc)
  }
  source(prop, loc) {
    if (prop && !loc) return
    this._normalizePosition(prop, loc, this._sourcePosition)
  }
  withSource(prop, loc, cb) {
    if (!this._map) return cb()
    const originalLine = this._sourcePosition.line
    const originalColumn = this._sourcePosition.column
    const originalFilename = this._sourcePosition.filename
    const originalIdentifierName = this._sourcePosition.identifierName
    this.source(prop, loc)
    cb()
    if (
      !this._disallowedPop ||
      this._disallowedPop.line !== originalLine ||
      this._disallowedPop.column !== originalColumn ||
      this._disallowedPop.filename !== originalFilename
    ) {
      this._sourcePosition.line = originalLine
      this._sourcePosition.column = originalColumn
      this._sourcePosition.filename = originalFilename
      this._sourcePosition.identifierName = originalIdentifierName
      this._disallowedPop = null
    }
  }
  _disallowPop(prop, loc) {
    if (prop && !loc) return
    this._disallowedPop = this._normalizePosition(prop, loc, SourcePos())
  }
  _normalizePosition(prop, loc, targetObj) {
    const pos = loc ? loc[prop] : null
    targetObj.identifierName = (prop === 'start' && (loc == null ? void 0 : loc.identifierName)) || void 0
    targetObj.line = pos == null ? void 0 : pos.line
    targetObj.column = pos == null ? void 0 : pos.column
    targetObj.filename = loc == null ? void 0 : loc.filename
    return targetObj
  }
  getCurrentColumn() {
    const extra = this._queue.reduce((acc, item) => item[0] + acc, '')
    const lastIndex = extra.lastIndexOf('\n')
    return lastIndex === -1 ? this._position.column + extra.length : extra.length - 1 - lastIndex
  }
  getCurrentLine() {
    const extra = this._queue.reduce((acc, item) => item[0] + acc, '')
    let count = 0
    for (let i = 0; i < extra.length; i++) {
      if (extra[i] === '\n') count++
    }
    return this._position.line + count
  }
}
buffer$1.default = Buffer$1
var node = {}
var whitespace$1 = {}
Object.defineProperty(whitespace$1, '__esModule', {
  value: true,
})
whitespace$1.nodes = whitespace$1.list = void 0
var _t$r = lib$b
const {
  FLIPPED_ALIAS_KEYS: FLIPPED_ALIAS_KEYS$1,
  isArrayExpression,
  isAssignmentExpression: isAssignmentExpression$3,
  isBinary: isBinary$2,
  isBlockStatement: isBlockStatement$1,
  isCallExpression: isCallExpression$5,
  isFunction: isFunction$3,
  isIdentifier: isIdentifier$8,
  isLiteral: isLiteral$3,
  isMemberExpression: isMemberExpression$3,
  isObjectExpression,
  isOptionalCallExpression: isOptionalCallExpression$1,
  isOptionalMemberExpression: isOptionalMemberExpression$1,
  isStringLiteral: isStringLiteral$3,
} = _t$r
function crawl(node2, state = {}) {
  if (isMemberExpression$3(node2) || isOptionalMemberExpression$1(node2)) {
    crawl(node2.object, state)
    if (node2.computed) crawl(node2.property, state)
  } else if (isBinary$2(node2) || isAssignmentExpression$3(node2)) {
    crawl(node2.left, state)
    crawl(node2.right, state)
  } else if (isCallExpression$5(node2) || isOptionalCallExpression$1(node2)) {
    state.hasCall = true
    crawl(node2.callee, state)
  } else if (isFunction$3(node2)) {
    state.hasFunction = true
  } else if (isIdentifier$8(node2)) {
    state.hasHelper = state.hasHelper || isHelper(node2.callee)
  }
  return state
}
function isHelper(node2) {
  if (isMemberExpression$3(node2)) {
    return isHelper(node2.object) || isHelper(node2.property)
  } else if (isIdentifier$8(node2)) {
    return node2.name === 'require' || node2.name[0] === '_'
  } else if (isCallExpression$5(node2)) {
    return isHelper(node2.callee)
  } else if (isBinary$2(node2) || isAssignmentExpression$3(node2)) {
    return (isIdentifier$8(node2.left) && isHelper(node2.left)) || isHelper(node2.right)
  } else {
    return false
  }
}
function isType$1(node2) {
  return (
    isLiteral$3(node2) ||
    isObjectExpression(node2) ||
    isArrayExpression(node2) ||
    isIdentifier$8(node2) ||
    isMemberExpression$3(node2)
  )
}
const nodes = {
  AssignmentExpression(node2) {
    const state = crawl(node2.right)
    if ((state.hasCall && state.hasHelper) || state.hasFunction) {
      return {
        before: state.hasFunction,
        after: true,
      }
    }
  },
  SwitchCase(node2, parent) {
    return {
      before: !!node2.consequent.length || parent.cases[0] === node2,
      after: !node2.consequent.length && parent.cases[parent.cases.length - 1] === node2,
    }
  },
  LogicalExpression(node2) {
    if (isFunction$3(node2.left) || isFunction$3(node2.right)) {
      return {
        after: true,
      }
    }
  },
  Literal(node2) {
    if (isStringLiteral$3(node2) && node2.value === 'use strict') {
      return {
        after: true,
      }
    }
  },
  CallExpression(node2) {
    if (isFunction$3(node2.callee) || isHelper(node2)) {
      return {
        before: true,
        after: true,
      }
    }
  },
  OptionalCallExpression(node2) {
    if (isFunction$3(node2.callee)) {
      return {
        before: true,
        after: true,
      }
    }
  },
  VariableDeclaration(node2) {
    for (let i = 0; i < node2.declarations.length; i++) {
      const declar = node2.declarations[i]
      let enabled = isHelper(declar.id) && !isType$1(declar.init)
      if (!enabled) {
        const state = crawl(declar.init)
        enabled = (isHelper(declar.init) && state.hasCall) || state.hasFunction
      }
      if (enabled) {
        return {
          before: true,
          after: true,
        }
      }
    }
  },
  IfStatement(node2) {
    if (isBlockStatement$1(node2.consequent)) {
      return {
        before: true,
        after: true,
      }
    }
  },
}
whitespace$1.nodes = nodes
nodes.ObjectProperty =
  nodes.ObjectTypeProperty =
  nodes.ObjectMethod =
    function (node2, parent) {
      if (parent.properties[0] === node2) {
        return {
          before: true,
        }
      }
    }
nodes.ObjectTypeCallProperty = function (node2, parent) {
  var _parent$properties
  if (
    parent.callProperties[0] === node2 &&
    !((_parent$properties = parent.properties) != null && _parent$properties.length)
  ) {
    return {
      before: true,
    }
  }
}
nodes.ObjectTypeIndexer = function (node2, parent) {
  var _parent$properties2, _parent$callPropertie
  if (
    parent.indexers[0] === node2 &&
    !((_parent$properties2 = parent.properties) != null && _parent$properties2.length) &&
    !((_parent$callPropertie = parent.callProperties) != null && _parent$callPropertie.length)
  ) {
    return {
      before: true,
    }
  }
}
nodes.ObjectTypeInternalSlot = function (node2, parent) {
  var _parent$properties3, _parent$callPropertie2, _parent$indexers
  if (
    parent.internalSlots[0] === node2 &&
    !((_parent$properties3 = parent.properties) != null && _parent$properties3.length) &&
    !((_parent$callPropertie2 = parent.callProperties) != null && _parent$callPropertie2.length) &&
    !((_parent$indexers = parent.indexers) != null && _parent$indexers.length)
  ) {
    return {
      before: true,
    }
  }
}
const list = {
  VariableDeclaration(node2) {
    return node2.declarations.map((decl) => decl.init)
  },
  ArrayExpression(node2) {
    return node2.elements
  },
  ObjectExpression(node2) {
    return node2.properties
  },
}
whitespace$1.list = list
;[
  ['Function', true],
  ['Class', true],
  ['Loop', true],
  ['LabeledStatement', true],
  ['SwitchStatement', true],
  ['TryStatement', true],
].forEach(function ([type, amounts]) {
  if (typeof amounts === 'boolean') {
    amounts = {
      after: amounts,
      before: amounts,
    }
  }
  ;[type].concat(FLIPPED_ALIAS_KEYS$1[type] || []).forEach(function (type2) {
    nodes[type2] = function () {
      return amounts
    }
  })
})
var parentheses = {}
Object.defineProperty(parentheses, '__esModule', {
  value: true,
})
parentheses.ArrowFunctionExpression = ArrowFunctionExpression$1
parentheses.AssignmentExpression = AssignmentExpression$1
parentheses.Binary = Binary
parentheses.BinaryExpression = BinaryExpression
parentheses.ClassExpression = ClassExpression
parentheses.ConditionalExpression = ConditionalExpression$1
parentheses.DoExpression = DoExpression$1
parentheses.FunctionExpression = FunctionExpression$1
parentheses.FunctionTypeAnnotation = FunctionTypeAnnotation
parentheses.Identifier = Identifier$1
parentheses.LogicalExpression = LogicalExpression
parentheses.NullableTypeAnnotation = NullableTypeAnnotation
parentheses.ObjectExpression = ObjectExpression$1
parentheses.OptionalIndexedAccessType = OptionalIndexedAccessType
parentheses.OptionalCallExpression = parentheses.OptionalMemberExpression = OptionalMemberExpression$1
parentheses.SequenceExpression = SequenceExpression$1
parentheses.TSAsExpression = TSAsExpression$1
parentheses.TSInferType = TSInferType$1
parentheses.TSInstantiationExpression = TSInstantiationExpression$1
parentheses.TSTypeAssertion = TSTypeAssertion$1
parentheses.TSIntersectionType = parentheses.TSUnionType = TSUnionType$1
parentheses.UnaryLike = UnaryLike
parentheses.IntersectionTypeAnnotation = parentheses.UnionTypeAnnotation = UnionTypeAnnotation
parentheses.UpdateExpression = UpdateExpression$1
parentheses.AwaitExpression = parentheses.YieldExpression = YieldExpression$1
var _t$q = lib$b
const {
  isArrayTypeAnnotation,
  isArrowFunctionExpression,
  isAssignmentExpression: isAssignmentExpression$2,
  isAwaitExpression,
  isBinary: isBinary$1,
  isBinaryExpression,
  isUpdateExpression,
  isCallExpression: isCallExpression$4,
  isClassDeclaration: isClassDeclaration$1,
  isClassExpression,
  isConditional,
  isConditionalExpression,
  isExportDeclaration,
  isExportDefaultDeclaration: isExportDefaultDeclaration$1,
  isExpressionStatement: isExpressionStatement$2,
  isFor: isFor$1,
  isForInStatement,
  isForOfStatement,
  isForStatement: isForStatement$1,
  isFunctionExpression,
  isIfStatement: isIfStatement$1,
  isIndexedAccessType,
  isIntersectionTypeAnnotation,
  isLogicalExpression,
  isMemberExpression: isMemberExpression$2,
  isNewExpression: isNewExpression$3,
  isNullableTypeAnnotation,
  isObjectPattern,
  isOptionalCallExpression,
  isOptionalMemberExpression,
  isReturnStatement,
  isSequenceExpression: isSequenceExpression$1,
  isSwitchStatement,
  isTSArrayType,
  isTSAsExpression,
  isTSInstantiationExpression,
  isTSIntersectionType,
  isTSNonNullExpression,
  isTSOptionalType,
  isTSRestType,
  isTSTypeAssertion,
  isTSUnionType,
  isTaggedTemplateExpression,
  isThrowStatement,
  isTypeAnnotation: isTypeAnnotation$1,
  isUnaryLike,
  isUnionTypeAnnotation: isUnionTypeAnnotation$1,
  isVariableDeclarator: isVariableDeclarator$1,
  isWhileStatement,
  isYieldExpression,
} = _t$q
const PRECEDENCE = {
  '||': 0,
  '??': 0,
  '&&': 1,
  '|': 2,
  '^': 3,
  '&': 4,
  '==': 5,
  '===': 5,
  '!=': 5,
  '!==': 5,
  '<': 6,
  '>': 6,
  '<=': 6,
  '>=': 6,
  in: 6,
  instanceof: 6,
  '>>': 7,
  '<<': 7,
  '>>>': 7,
  '+': 8,
  '-': 8,
  '*': 9,
  '/': 9,
  '%': 9,
  '**': 10,
}
const isClassExtendsClause = (node2, parent) =>
  (isClassDeclaration$1(parent) || isClassExpression(parent)) && parent.superClass === node2
const hasPostfixPart = (node2, parent) =>
  ((isMemberExpression$2(parent) || isOptionalMemberExpression(parent)) && parent.object === node2) ||
  ((isCallExpression$4(parent) || isOptionalCallExpression(parent) || isNewExpression$3(parent)) &&
    parent.callee === node2) ||
  (isTaggedTemplateExpression(parent) && parent.tag === node2) ||
  isTSNonNullExpression(parent)
function NullableTypeAnnotation(node2, parent) {
  return isArrayTypeAnnotation(parent)
}
function FunctionTypeAnnotation(node2, parent, printStack) {
  return (
    isUnionTypeAnnotation$1(parent) ||
    isIntersectionTypeAnnotation(parent) ||
    isArrayTypeAnnotation(parent) ||
    (isTypeAnnotation$1(parent) && isArrowFunctionExpression(printStack[printStack.length - 3]))
  )
}
function UpdateExpression$1(node2, parent) {
  return hasPostfixPart(node2, parent) || isClassExtendsClause(node2, parent)
}
function ObjectExpression$1(node2, parent, printStack) {
  return isFirstInContext(printStack, {
    expressionStatement: true,
    arrowBody: true,
  })
}
function DoExpression$1(node2, parent, printStack) {
  return (
    !node2.async &&
    isFirstInContext(printStack, {
      expressionStatement: true,
    })
  )
}
function Binary(node2, parent) {
  if (
    node2.operator === '**' &&
    isBinaryExpression(parent, {
      operator: '**',
    })
  ) {
    return parent.left === node2
  }
  if (isClassExtendsClause(node2, parent)) {
    return true
  }
  if (hasPostfixPart(node2, parent) || isUnaryLike(parent) || isAwaitExpression(parent)) {
    return true
  }
  if (isBinary$1(parent)) {
    const parentOp = parent.operator
    const parentPos = PRECEDENCE[parentOp]
    const nodeOp = node2.operator
    const nodePos = PRECEDENCE[nodeOp]
    if ((parentPos === nodePos && parent.right === node2 && !isLogicalExpression(parent)) || parentPos > nodePos) {
      return true
    }
  }
}
function UnionTypeAnnotation(node2, parent) {
  return (
    isArrayTypeAnnotation(parent) ||
    isNullableTypeAnnotation(parent) ||
    isIntersectionTypeAnnotation(parent) ||
    isUnionTypeAnnotation$1(parent)
  )
}
function OptionalIndexedAccessType(node2, parent) {
  return isIndexedAccessType(parent, {
    objectType: node2,
  })
}
function TSAsExpression$1() {
  return true
}
function TSTypeAssertion$1() {
  return true
}
function TSUnionType$1(node2, parent) {
  return (
    isTSArrayType(parent) ||
    isTSOptionalType(parent) ||
    isTSIntersectionType(parent) ||
    isTSUnionType(parent) ||
    isTSRestType(parent)
  )
}
function TSInferType$1(node2, parent) {
  return isTSArrayType(parent) || isTSOptionalType(parent)
}
function TSInstantiationExpression$1(node2, parent) {
  return (
    (isCallExpression$4(parent) ||
      isOptionalCallExpression(parent) ||
      isNewExpression$3(parent) ||
      isTSInstantiationExpression(parent)) &&
    !!parent.typeParameters
  )
}
function BinaryExpression(node2, parent) {
  return node2.operator === 'in' && (isVariableDeclarator$1(parent) || isFor$1(parent))
}
function SequenceExpression$1(node2, parent) {
  if (
    isForStatement$1(parent) ||
    isThrowStatement(parent) ||
    isReturnStatement(parent) ||
    (isIfStatement$1(parent) && parent.test === node2) ||
    (isWhileStatement(parent) && parent.test === node2) ||
    (isForInStatement(parent) && parent.right === node2) ||
    (isSwitchStatement(parent) && parent.discriminant === node2) ||
    (isExpressionStatement$2(parent) && parent.expression === node2)
  ) {
    return false
  }
  return true
}
function YieldExpression$1(node2, parent) {
  return (
    isBinary$1(parent) ||
    isUnaryLike(parent) ||
    hasPostfixPart(node2, parent) ||
    (isAwaitExpression(parent) && isYieldExpression(node2)) ||
    (isConditionalExpression(parent) && node2 === parent.test) ||
    isClassExtendsClause(node2, parent)
  )
}
function ClassExpression(node2, parent, printStack) {
  return isFirstInContext(printStack, {
    expressionStatement: true,
    exportDefault: true,
  })
}
function UnaryLike(node2, parent) {
  return (
    hasPostfixPart(node2, parent) ||
    isBinaryExpression(parent, {
      operator: '**',
      left: node2,
    }) ||
    isClassExtendsClause(node2, parent)
  )
}
function FunctionExpression$1(node2, parent, printStack) {
  return isFirstInContext(printStack, {
    expressionStatement: true,
    exportDefault: true,
  })
}
function ArrowFunctionExpression$1(node2, parent) {
  return isExportDeclaration(parent) || ConditionalExpression$1(node2, parent)
}
function ConditionalExpression$1(node2, parent) {
  if (
    isUnaryLike(parent) ||
    isBinary$1(parent) ||
    isConditionalExpression(parent, {
      test: node2,
    }) ||
    isAwaitExpression(parent) ||
    isTSTypeAssertion(parent) ||
    isTSAsExpression(parent)
  ) {
    return true
  }
  return UnaryLike(node2, parent)
}
function OptionalMemberExpression$1(node2, parent) {
  return (
    isCallExpression$4(parent, {
      callee: node2,
    }) ||
    isMemberExpression$2(parent, {
      object: node2,
    })
  )
}
function AssignmentExpression$1(node2, parent) {
  if (isObjectPattern(node2.left)) {
    return true
  } else {
    return ConditionalExpression$1(node2, parent)
  }
}
function LogicalExpression(node2, parent) {
  switch (node2.operator) {
    case '||':
      if (!isLogicalExpression(parent)) return false
      return parent.operator === '??' || parent.operator === '&&'
    case '&&':
      return isLogicalExpression(parent, {
        operator: '??',
      })
    case '??':
      return isLogicalExpression(parent) && parent.operator !== '??'
  }
}
function Identifier$1(node2, parent, printStack) {
  var _node$extra
  if (
    (_node$extra = node2.extra) != null &&
    _node$extra.parenthesized &&
    isAssignmentExpression$2(parent, {
      left: node2,
    }) &&
    (isFunctionExpression(parent.right) || isClassExpression(parent.right)) &&
    parent.right.id == null
  ) {
    return true
  }
  if (node2.name === 'let') {
    const isFollowedByBracket =
      isMemberExpression$2(parent, {
        object: node2,
        computed: true,
      }) ||
      isOptionalMemberExpression(parent, {
        object: node2,
        computed: true,
        optional: false,
      })
    return isFirstInContext(printStack, {
      expressionStatement: isFollowedByBracket,
      forHead: isFollowedByBracket,
      forInHead: isFollowedByBracket,
      forOfHead: true,
    })
  }
  return node2.name === 'async' && isForOfStatement(parent) && node2 === parent.left
}
function isFirstInContext(
  printStack,
  {
    expressionStatement: expressionStatement2 = false,
    arrowBody = false,
    exportDefault = false,
    forHead = false,
    forInHead = false,
    forOfHead = false,
  }
) {
  let i = printStack.length - 1
  let node2 = printStack[i]
  i--
  let parent = printStack[i]
  while (i >= 0) {
    if (
      (expressionStatement2 &&
        isExpressionStatement$2(parent, {
          expression: node2,
        })) ||
      (exportDefault &&
        isExportDefaultDeclaration$1(parent, {
          declaration: node2,
        })) ||
      (arrowBody &&
        isArrowFunctionExpression(parent, {
          body: node2,
        })) ||
      (forHead &&
        isForStatement$1(parent, {
          init: node2,
        })) ||
      (forInHead &&
        isForInStatement(parent, {
          left: node2,
        })) ||
      (forOfHead &&
        isForOfStatement(parent, {
          left: node2,
        }))
    ) {
      return true
    }
    if (
      (hasPostfixPart(node2, parent) && !isNewExpression$3(parent)) ||
      (isSequenceExpression$1(parent) && parent.expressions[0] === node2) ||
      (isUpdateExpression(parent) && !parent.prefix) ||
      isConditional(parent, {
        test: node2,
      }) ||
      isBinary$1(parent, {
        left: node2,
      }) ||
      isAssignmentExpression$2(parent, {
        left: node2,
      })
    ) {
      node2 = parent
      i--
      parent = printStack[i]
    } else {
      return false
    }
  }
  return false
}
Object.defineProperty(node, '__esModule', {
  value: true,
})
node.needsParens = needsParens$1
node.needsWhitespace = needsWhitespace
node.needsWhitespaceAfter = needsWhitespaceAfter$1
node.needsWhitespaceBefore = needsWhitespaceBefore$1
var whitespace = whitespace$1
var parens = parentheses
var _t$p = lib$b
const {
  FLIPPED_ALIAS_KEYS,
  isCallExpression: isCallExpression$3,
  isExpressionStatement: isExpressionStatement$1,
  isMemberExpression: isMemberExpression$1,
  isNewExpression: isNewExpression$2,
} = _t$p
function expandAliases(obj) {
  const newObj = {}
  function add2(type, func) {
    const fn = newObj[type]
    newObj[type] = fn
      ? function (node2, parent, stack) {
          const result = fn(node2, parent, stack)
          return result == null ? func(node2, parent, stack) : result
        }
      : func
  }
  for (const type of Object.keys(obj)) {
    const aliases = FLIPPED_ALIAS_KEYS[type]
    if (aliases) {
      for (const alias of aliases) {
        add2(alias, obj[type])
      }
    } else {
      add2(type, obj[type])
    }
  }
  return newObj
}
const expandedParens = expandAliases(parens)
const expandedWhitespaceNodes = expandAliases(whitespace.nodes)
const expandedWhitespaceList = expandAliases(whitespace.list)
function find$1(obj, node2, parent, printStack) {
  const fn = obj[node2.type]
  return fn ? fn(node2, parent, printStack) : null
}
function isOrHasCallExpression(node2) {
  if (isCallExpression$3(node2)) {
    return true
  }
  return isMemberExpression$1(node2) && isOrHasCallExpression(node2.object)
}
function needsWhitespace(node2, parent, type) {
  if (!node2) return 0
  if (isExpressionStatement$1(node2)) {
    node2 = node2.expression
  }
  let linesInfo = find$1(expandedWhitespaceNodes, node2, parent)
  if (!linesInfo) {
    const items = find$1(expandedWhitespaceList, node2, parent)
    if (items) {
      for (let i = 0; i < items.length; i++) {
        linesInfo = needsWhitespace(items[i], node2, type)
        if (linesInfo) break
      }
    }
  }
  if (typeof linesInfo === 'object' && linesInfo !== null) {
    return linesInfo[type] || 0
  }
  return 0
}
function needsWhitespaceBefore$1(node2, parent) {
  return needsWhitespace(node2, parent, 'before')
}
function needsWhitespaceAfter$1(node2, parent) {
  return needsWhitespace(node2, parent, 'after')
}
function needsParens$1(node2, parent, printStack) {
  if (!parent) return false
  if (isNewExpression$2(parent) && parent.callee === node2) {
    if (isOrHasCallExpression(node2)) return true
  }
  return find$1(expandedParens, node2, parent, printStack)
}
var generators = {}
var templateLiterals = {}
Object.defineProperty(templateLiterals, '__esModule', {
  value: true,
})
templateLiterals.TaggedTemplateExpression = TaggedTemplateExpression
templateLiterals.TemplateElement = TemplateElement
templateLiterals.TemplateLiteral = TemplateLiteral
function TaggedTemplateExpression(node2) {
  this.print(node2.tag, node2)
  this.print(node2.typeParameters, node2)
  this.print(node2.quasi, node2)
}
function TemplateElement(node2, parent) {
  const isFirst = parent.quasis[0] === node2
  const isLast = parent.quasis[parent.quasis.length - 1] === node2
  const value = (isFirst ? '`' : '}') + node2.value.raw + (isLast ? '`' : '${')
  this.token(value)
}
function TemplateLiteral(node2) {
  const quasis = node2.quasis
  for (let i = 0; i < quasis.length; i++) {
    this.print(quasis[i], node2)
    if (i + 1 < quasis.length) {
      this.print(node2.expressions[i], node2)
    }
  }
}
var expressions = {}
Object.defineProperty(expressions, '__esModule', {
  value: true,
})
expressions.LogicalExpression = expressions.BinaryExpression = expressions.AssignmentExpression = AssignmentExpression
expressions.AssignmentPattern = AssignmentPattern
expressions.AwaitExpression = void 0
expressions.BindExpression = BindExpression
expressions.CallExpression = CallExpression
expressions.ConditionalExpression = ConditionalExpression
expressions.Decorator = Decorator
expressions.DoExpression = DoExpression
expressions.EmptyStatement = EmptyStatement
expressions.ExpressionStatement = ExpressionStatement
expressions.Import = Import
expressions.MemberExpression = MemberExpression
expressions.MetaProperty = MetaProperty
expressions.ModuleExpression = ModuleExpression
expressions.NewExpression = NewExpression
expressions.OptionalCallExpression = OptionalCallExpression
expressions.OptionalMemberExpression = OptionalMemberExpression
expressions.ParenthesizedExpression = ParenthesizedExpression
expressions.PrivateName = PrivateName
expressions.SequenceExpression = SequenceExpression
expressions.Super = Super
expressions.ThisExpression = ThisExpression
expressions.UnaryExpression = UnaryExpression
expressions.UpdateExpression = UpdateExpression
expressions.V8IntrinsicIdentifier = V8IntrinsicIdentifier
expressions.YieldExpression = void 0
var _t$o = lib$b
var n$14 = node
const {
  isCallExpression: isCallExpression$2,
  isLiteral: isLiteral$2,
  isMemberExpression,
  isNewExpression: isNewExpression$1,
} = _t$o
function UnaryExpression(node2) {
  if (
    node2.operator === 'void' ||
    node2.operator === 'delete' ||
    node2.operator === 'typeof' ||
    node2.operator === 'throw'
  ) {
    this.word(node2.operator)
    this.space()
  } else {
    this.token(node2.operator)
  }
  this.print(node2.argument, node2)
}
function DoExpression(node2) {
  if (node2.async) {
    this.word('async')
    this.space()
  }
  this.word('do')
  this.space()
  this.print(node2.body, node2)
}
function ParenthesizedExpression(node2) {
  this.token('(')
  this.print(node2.expression, node2)
  this.token(')')
}
function UpdateExpression(node2) {
  if (node2.prefix) {
    this.token(node2.operator)
    this.print(node2.argument, node2)
  } else {
    this.startTerminatorless(true)
    this.print(node2.argument, node2)
    this.endTerminatorless()
    this.token(node2.operator)
  }
}
function ConditionalExpression(node2) {
  this.print(node2.test, node2)
  this.space()
  this.token('?')
  this.space()
  this.print(node2.consequent, node2)
  this.space()
  this.token(':')
  this.space()
  this.print(node2.alternate, node2)
}
function NewExpression(node2, parent) {
  this.word('new')
  this.space()
  this.print(node2.callee, node2)
  if (
    this.format.minified &&
    node2.arguments.length === 0 &&
    !node2.optional &&
    !isCallExpression$2(parent, {
      callee: node2,
    }) &&
    !isMemberExpression(parent) &&
    !isNewExpression$1(parent)
  ) {
    return
  }
  this.print(node2.typeArguments, node2)
  this.print(node2.typeParameters, node2)
  if (node2.optional) {
    this.token('?.')
  }
  this.token('(')
  this.printList(node2.arguments, node2)
  this.token(')')
}
function SequenceExpression(node2) {
  this.printList(node2.expressions, node2)
}
function ThisExpression() {
  this.word('this')
}
function Super() {
  this.word('super')
}
function isDecoratorMemberExpression(node2) {
  switch (node2.type) {
    case 'Identifier':
      return true
    case 'MemberExpression':
      return !node2.computed && node2.property.type === 'Identifier' && isDecoratorMemberExpression(node2.object)
    default:
      return false
  }
}
function shouldParenthesizeDecoratorExpression(node2) {
  if (node2.type === 'CallExpression') {
    node2 = node2.callee
  }
  if (node2.type === 'ParenthesizedExpression') {
    return false
  }
  return !isDecoratorMemberExpression(node2)
}
function Decorator(node2) {
  this.token('@')
  const { expression: expression2 } = node2
  if (shouldParenthesizeDecoratorExpression(expression2)) {
    this.token('(')
    this.print(expression2, node2)
    this.token(')')
  } else {
    this.print(expression2, node2)
  }
  this.newline()
}
function OptionalMemberExpression(node2) {
  this.print(node2.object, node2)
  if (!node2.computed && isMemberExpression(node2.property)) {
    throw new TypeError('Got a MemberExpression for MemberExpression property')
  }
  let computed2 = node2.computed
  if (isLiteral$2(node2.property) && typeof node2.property.value === 'number') {
    computed2 = true
  }
  if (node2.optional) {
    this.token('?.')
  }
  if (computed2) {
    this.token('[')
    this.print(node2.property, node2)
    this.token(']')
  } else {
    if (!node2.optional) {
      this.token('.')
    }
    this.print(node2.property, node2)
  }
}
function OptionalCallExpression(node2) {
  this.print(node2.callee, node2)
  this.print(node2.typeArguments, node2)
  this.print(node2.typeParameters, node2)
  if (node2.optional) {
    this.token('?.')
  }
  this.token('(')
  this.printList(node2.arguments, node2)
  this.token(')')
}
function CallExpression(node2) {
  this.print(node2.callee, node2)
  this.print(node2.typeArguments, node2)
  this.print(node2.typeParameters, node2)
  this.token('(')
  this.printList(node2.arguments, node2)
  this.token(')')
}
function Import() {
  this.word('import')
}
function buildYieldAwait(keyword2) {
  return function (node2) {
    this.word(keyword2)
    if (node2.delegate) {
      this.token('*')
    }
    if (node2.argument) {
      this.space()
      const terminatorState = this.startTerminatorless()
      this.print(node2.argument, node2)
      this.endTerminatorless(terminatorState)
    }
  }
}
const YieldExpression = buildYieldAwait('yield')
expressions.YieldExpression = YieldExpression
const AwaitExpression = buildYieldAwait('await')
expressions.AwaitExpression = AwaitExpression
function EmptyStatement() {
  this.semicolon(true)
}
function ExpressionStatement(node2) {
  this.print(node2.expression, node2)
  this.semicolon()
}
function AssignmentPattern(node2) {
  this.print(node2.left, node2)
  if (node2.left.optional) this.token('?')
  this.print(node2.left.typeAnnotation, node2)
  this.space()
  this.token('=')
  this.space()
  this.print(node2.right, node2)
}
function AssignmentExpression(node2, parent) {
  const parens2 = this.inForStatementInitCounter && node2.operator === 'in' && !n$14.needsParens(node2, parent)
  if (parens2) {
    this.token('(')
  }
  this.print(node2.left, node2)
  this.space()
  if (node2.operator === 'in' || node2.operator === 'instanceof') {
    this.word(node2.operator)
  } else {
    this.token(node2.operator)
  }
  this.space()
  this.print(node2.right, node2)
  if (parens2) {
    this.token(')')
  }
}
function BindExpression(node2) {
  this.print(node2.object, node2)
  this.token('::')
  this.print(node2.callee, node2)
}
function MemberExpression(node2) {
  this.print(node2.object, node2)
  if (!node2.computed && isMemberExpression(node2.property)) {
    throw new TypeError('Got a MemberExpression for MemberExpression property')
  }
  let computed2 = node2.computed
  if (isLiteral$2(node2.property) && typeof node2.property.value === 'number') {
    computed2 = true
  }
  if (computed2) {
    this.token('[')
    this.print(node2.property, node2)
    this.token(']')
  } else {
    this.token('.')
    this.print(node2.property, node2)
  }
}
function MetaProperty(node2) {
  this.print(node2.meta, node2)
  this.token('.')
  this.print(node2.property, node2)
}
function PrivateName(node2) {
  this.token('#')
  this.print(node2.id, node2)
}
function V8IntrinsicIdentifier(node2) {
  this.token('%')
  this.word(node2.name)
}
function ModuleExpression(node2) {
  this.word('module')
  this.space()
  this.token('{')
  if (node2.body.body.length === 0) {
    this.token('}')
  } else {
    this.newline()
    this.printSequence(node2.body.body, node2, {
      indent: true,
    })
    this.rightBrace()
  }
}
var statements$2 = {}
Object.defineProperty(statements$2, '__esModule', {
  value: true,
})
statements$2.BreakStatement = void 0
statements$2.CatchClause = CatchClause
statements$2.ContinueStatement = void 0
statements$2.DebuggerStatement = DebuggerStatement
statements$2.DoWhileStatement = DoWhileStatement
statements$2.ForOfStatement = statements$2.ForInStatement = void 0
statements$2.ForStatement = ForStatement
statements$2.IfStatement = IfStatement
statements$2.LabeledStatement = LabeledStatement
statements$2.ReturnStatement = void 0
statements$2.SwitchCase = SwitchCase
statements$2.SwitchStatement = SwitchStatement
statements$2.ThrowStatement = void 0
statements$2.TryStatement = TryStatement
statements$2.VariableDeclaration = VariableDeclaration
statements$2.VariableDeclarator = VariableDeclarator
statements$2.WhileStatement = WhileStatement
statements$2.WithStatement = WithStatement
var _t$n = lib$b
const { isFor, isForStatement, isIfStatement, isStatement: isStatement$4 } = _t$n
function WithStatement(node2) {
  this.word('with')
  this.space()
  this.token('(')
  this.print(node2.object, node2)
  this.token(')')
  this.printBlock(node2)
}
function IfStatement(node2) {
  this.word('if')
  this.space()
  this.token('(')
  this.print(node2.test, node2)
  this.token(')')
  this.space()
  const needsBlock = node2.alternate && isIfStatement(getLastStatement(node2.consequent))
  if (needsBlock) {
    this.token('{')
    this.newline()
    this.indent()
  }
  this.printAndIndentOnComments(node2.consequent, node2)
  if (needsBlock) {
    this.dedent()
    this.newline()
    this.token('}')
  }
  if (node2.alternate) {
    if (this.endsWith(125)) this.space()
    this.word('else')
    this.space()
    this.printAndIndentOnComments(node2.alternate, node2)
  }
}
function getLastStatement(statement2) {
  if (!isStatement$4(statement2.body)) return statement2
  return getLastStatement(statement2.body)
}
function ForStatement(node2) {
  this.word('for')
  this.space()
  this.token('(')
  this.inForStatementInitCounter++
  this.print(node2.init, node2)
  this.inForStatementInitCounter--
  this.token(';')
  if (node2.test) {
    this.space()
    this.print(node2.test, node2)
  }
  this.token(';')
  if (node2.update) {
    this.space()
    this.print(node2.update, node2)
  }
  this.token(')')
  this.printBlock(node2)
}
function WhileStatement(node2) {
  this.word('while')
  this.space()
  this.token('(')
  this.print(node2.test, node2)
  this.token(')')
  this.printBlock(node2)
}
const buildForXStatement = function (op) {
  return function (node2) {
    this.word('for')
    this.space()
    if (op === 'of' && node2.await) {
      this.word('await')
      this.space()
    }
    this.token('(')
    this.print(node2.left, node2)
    this.space()
    this.word(op)
    this.space()
    this.print(node2.right, node2)
    this.token(')')
    this.printBlock(node2)
  }
}
const ForInStatement = buildForXStatement('in')
statements$2.ForInStatement = ForInStatement
const ForOfStatement = buildForXStatement('of')
statements$2.ForOfStatement = ForOfStatement
function DoWhileStatement(node2) {
  this.word('do')
  this.space()
  this.print(node2.body, node2)
  this.space()
  this.word('while')
  this.space()
  this.token('(')
  this.print(node2.test, node2)
  this.token(')')
  this.semicolon()
}
function buildLabelStatement(prefix2, key = 'label') {
  return function (node2) {
    this.word(prefix2)
    const label = node2[key]
    if (label) {
      this.space()
      const isLabel = key == 'label'
      const terminatorState = this.startTerminatorless(isLabel)
      this.print(label, node2)
      this.endTerminatorless(terminatorState)
    }
    this.semicolon()
  }
}
const ContinueStatement = buildLabelStatement('continue')
statements$2.ContinueStatement = ContinueStatement
const ReturnStatement = buildLabelStatement('return', 'argument')
statements$2.ReturnStatement = ReturnStatement
const BreakStatement = buildLabelStatement('break')
statements$2.BreakStatement = BreakStatement
const ThrowStatement = buildLabelStatement('throw', 'argument')
statements$2.ThrowStatement = ThrowStatement
function LabeledStatement(node2) {
  this.print(node2.label, node2)
  this.token(':')
  this.space()
  this.print(node2.body, node2)
}
function TryStatement(node2) {
  this.word('try')
  this.space()
  this.print(node2.block, node2)
  this.space()
  if (node2.handlers) {
    this.print(node2.handlers[0], node2)
  } else {
    this.print(node2.handler, node2)
  }
  if (node2.finalizer) {
    this.space()
    this.word('finally')
    this.space()
    this.print(node2.finalizer, node2)
  }
}
function CatchClause(node2) {
  this.word('catch')
  this.space()
  if (node2.param) {
    this.token('(')
    this.print(node2.param, node2)
    this.print(node2.param.typeAnnotation, node2)
    this.token(')')
    this.space()
  }
  this.print(node2.body, node2)
}
function SwitchStatement(node2) {
  this.word('switch')
  this.space()
  this.token('(')
  this.print(node2.discriminant, node2)
  this.token(')')
  this.space()
  this.token('{')
  this.printSequence(node2.cases, node2, {
    indent: true,
    addNewlines(leading, cas) {
      if (!leading && node2.cases[node2.cases.length - 1] === cas) return -1
    },
  })
  this.token('}')
}
function SwitchCase(node2) {
  if (node2.test) {
    this.word('case')
    this.space()
    this.print(node2.test, node2)
    this.token(':')
  } else {
    this.word('default')
    this.token(':')
  }
  if (node2.consequent.length) {
    this.newline()
    this.printSequence(node2.consequent, node2, {
      indent: true,
    })
  }
}
function DebuggerStatement() {
  this.word('debugger')
  this.semicolon()
}
function variableDeclarationIndent() {
  this.token(',')
  this.newline()
  if (this.endsWith(10)) {
    for (let i = 0; i < 4; i++) this.space(true)
  }
}
function constDeclarationIndent() {
  this.token(',')
  this.newline()
  if (this.endsWith(10)) {
    for (let i = 0; i < 6; i++) this.space(true)
  }
}
function VariableDeclaration(node2, parent) {
  if (node2.declare) {
    this.word('declare')
    this.space()
  }
  this.word(node2.kind)
  this.space()
  let hasInits = false
  if (!isFor(parent)) {
    for (const declar of node2.declarations) {
      if (declar.init) {
        hasInits = true
      }
    }
  }
  let separator
  if (hasInits) {
    separator = node2.kind === 'const' ? constDeclarationIndent : variableDeclarationIndent
  }
  this.printList(node2.declarations, node2, {
    separator,
  })
  if (isFor(parent)) {
    if (isForStatement(parent)) {
      if (parent.init === node2) return
    } else {
      if (parent.left === node2) return
    }
  }
  this.semicolon()
}
function VariableDeclarator(node2) {
  this.print(node2.id, node2)
  if (node2.definite) this.token('!')
  this.print(node2.id.typeAnnotation, node2)
  if (node2.init) {
    this.space()
    this.token('=')
    this.space()
    this.print(node2.init, node2)
  }
}
var classes$T = {}
Object.defineProperty(classes$T, '__esModule', {
  value: true,
})
classes$T.ClassAccessorProperty = ClassAccessorProperty
classes$T.ClassBody = ClassBody
classes$T.ClassExpression = classes$T.ClassDeclaration = ClassDeclaration
classes$T.ClassMethod = ClassMethod
classes$T.ClassPrivateMethod = ClassPrivateMethod
classes$T.ClassPrivateProperty = ClassPrivateProperty
classes$T.ClassProperty = ClassProperty
classes$T.StaticBlock = StaticBlock
classes$T._classMethodHead = _classMethodHead
var _t$m = lib$b
const { isExportDefaultDeclaration, isExportNamedDeclaration } = _t$m
function ClassDeclaration(node2, parent) {
  if (
    !this.format.decoratorsBeforeExport ||
    (!isExportDefaultDeclaration(parent) && !isExportNamedDeclaration(parent))
  ) {
    this.printJoin(node2.decorators, node2)
  }
  if (node2.declare) {
    this.word('declare')
    this.space()
  }
  if (node2.abstract) {
    this.word('abstract')
    this.space()
  }
  this.word('class')
  this.printInnerComments(node2)
  if (node2.id) {
    this.space()
    this.print(node2.id, node2)
  }
  this.print(node2.typeParameters, node2)
  if (node2.superClass) {
    this.space()
    this.word('extends')
    this.space()
    this.print(node2.superClass, node2)
    this.print(node2.superTypeParameters, node2)
  }
  if (node2.implements) {
    this.space()
    this.word('implements')
    this.space()
    this.printList(node2.implements, node2)
  }
  this.space()
  this.print(node2.body, node2)
}
function ClassBody(node2) {
  this.token('{')
  this.printInnerComments(node2)
  if (node2.body.length === 0) {
    this.token('}')
  } else {
    this.newline()
    this.indent()
    this.printSequence(node2.body, node2)
    this.dedent()
    if (!this.endsWith(10)) this.newline()
    this.rightBrace()
  }
}
function ClassProperty(node2) {
  this.printJoin(node2.decorators, node2)
  this.source('end', node2.key.loc)
  this.tsPrintClassMemberModifiers(node2, true)
  if (node2.computed) {
    this.token('[')
    this.print(node2.key, node2)
    this.token(']')
  } else {
    this._variance(node2)
    this.print(node2.key, node2)
  }
  if (node2.optional) {
    this.token('?')
  }
  if (node2.definite) {
    this.token('!')
  }
  this.print(node2.typeAnnotation, node2)
  if (node2.value) {
    this.space()
    this.token('=')
    this.space()
    this.print(node2.value, node2)
  }
  this.semicolon()
}
function ClassAccessorProperty(node2) {
  this.printJoin(node2.decorators, node2)
  this.source('end', node2.key.loc)
  this.tsPrintClassMemberModifiers(node2, true)
  this.word('accessor')
  this.printInnerComments(node2)
  this.space()
  if (node2.computed) {
    this.token('[')
    this.print(node2.key, node2)
    this.token(']')
  } else {
    this._variance(node2)
    this.print(node2.key, node2)
  }
  if (node2.optional) {
    this.token('?')
  }
  if (node2.definite) {
    this.token('!')
  }
  this.print(node2.typeAnnotation, node2)
  if (node2.value) {
    this.space()
    this.token('=')
    this.space()
    this.print(node2.value, node2)
  }
  this.semicolon()
}
function ClassPrivateProperty(node2) {
  this.printJoin(node2.decorators, node2)
  if (node2.static) {
    this.word('static')
    this.space()
  }
  this.print(node2.key, node2)
  this.print(node2.typeAnnotation, node2)
  if (node2.value) {
    this.space()
    this.token('=')
    this.space()
    this.print(node2.value, node2)
  }
  this.semicolon()
}
function ClassMethod(node2) {
  this._classMethodHead(node2)
  this.space()
  this.print(node2.body, node2)
}
function ClassPrivateMethod(node2) {
  this._classMethodHead(node2)
  this.space()
  this.print(node2.body, node2)
}
function _classMethodHead(node2) {
  this.printJoin(node2.decorators, node2)
  this.source('end', node2.key.loc)
  this.tsPrintClassMemberModifiers(node2, false)
  this._methodHead(node2)
}
function StaticBlock(node2) {
  this.word('static')
  this.space()
  this.token('{')
  if (node2.body.length === 0) {
    this.token('}')
  } else {
    this.newline()
    this.printSequence(node2.body, node2, {
      indent: true,
    })
    this.rightBrace()
  }
}
var methods = {}
Object.defineProperty(methods, '__esModule', {
  value: true,
})
methods.ArrowFunctionExpression = ArrowFunctionExpression
methods.FunctionDeclaration = methods.FunctionExpression = FunctionExpression
methods._functionHead = _functionHead
methods._methodHead = _methodHead
methods._param = _param
methods._parameters = _parameters
methods._params = _params
methods._predicate = _predicate
var _t$l = lib$b
const { isIdentifier: isIdentifier$7 } = _t$l
function _params(node2) {
  this.print(node2.typeParameters, node2)
  this.token('(')
  this._parameters(node2.params, node2)
  this.token(')')
  this.print(node2.returnType, node2)
}
function _parameters(parameters, parent) {
  for (let i = 0; i < parameters.length; i++) {
    this._param(parameters[i], parent)
    if (i < parameters.length - 1) {
      this.token(',')
      this.space()
    }
  }
}
function _param(parameter, parent) {
  this.printJoin(parameter.decorators, parameter)
  this.print(parameter, parent)
  if (parameter.optional) this.token('?')
  this.print(parameter.typeAnnotation, parameter)
}
function _methodHead(node2) {
  const kind = node2.kind
  const key = node2.key
  if (kind === 'get' || kind === 'set') {
    this.word(kind)
    this.space()
  }
  if (node2.async) {
    this._catchUp('start', key.loc)
    this.word('async')
    this.space()
  }
  if (kind === 'method' || kind === 'init') {
    if (node2.generator) {
      this.token('*')
    }
  }
  if (node2.computed) {
    this.token('[')
    this.print(key, node2)
    this.token(']')
  } else {
    this.print(key, node2)
  }
  if (node2.optional) {
    this.token('?')
  }
  this._params(node2)
}
function _predicate(node2) {
  if (node2.predicate) {
    if (!node2.returnType) {
      this.token(':')
    }
    this.space()
    this.print(node2.predicate, node2)
  }
}
function _functionHead(node2) {
  if (node2.async) {
    this.word('async')
    this.space()
  }
  this.word('function')
  if (node2.generator) this.token('*')
  this.printInnerComments(node2)
  this.space()
  if (node2.id) {
    this.print(node2.id, node2)
  }
  this._params(node2)
  this._predicate(node2)
}
function FunctionExpression(node2) {
  this._functionHead(node2)
  this.space()
  this.print(node2.body, node2)
}
function ArrowFunctionExpression(node2) {
  if (node2.async) {
    this.word('async')
    this.space()
  }
  const firstParam = node2.params[0]
  if (
    !this.format.retainLines &&
    !this.format.auxiliaryCommentBefore &&
    !this.format.auxiliaryCommentAfter &&
    node2.params.length === 1 &&
    isIdentifier$7(firstParam) &&
    !hasTypesOrComments(node2, firstParam)
  ) {
    this.print(firstParam, node2)
  } else {
    this._params(node2)
  }
  this._predicate(node2)
  this.space()
  this.token('=>')
  this.space()
  this.print(node2.body, node2)
}
function hasTypesOrComments(node2, param) {
  var _param$leadingComment, _param$trailingCommen
  return !!(
    node2.typeParameters ||
    node2.returnType ||
    node2.predicate ||
    param.typeAnnotation ||
    param.optional ||
    ((_param$leadingComment = param.leadingComments) != null && _param$leadingComment.length) ||
    ((_param$trailingCommen = param.trailingComments) != null && _param$trailingCommen.length)
  )
}
var modules = {}
Object.defineProperty(modules, '__esModule', {
  value: true,
})
modules.ExportAllDeclaration = ExportAllDeclaration
modules.ExportDefaultDeclaration = ExportDefaultDeclaration
modules.ExportDefaultSpecifier = ExportDefaultSpecifier
modules.ExportNamedDeclaration = ExportNamedDeclaration
modules.ExportNamespaceSpecifier = ExportNamespaceSpecifier
modules.ExportSpecifier = ExportSpecifier
modules.ImportAttribute = ImportAttribute
modules.ImportDeclaration = ImportDeclaration
modules.ImportDefaultSpecifier = ImportDefaultSpecifier
modules.ImportNamespaceSpecifier = ImportNamespaceSpecifier
modules.ImportSpecifier = ImportSpecifier
var _t$k = lib$b
const {
  isClassDeclaration,
  isExportDefaultSpecifier,
  isExportNamespaceSpecifier,
  isImportDefaultSpecifier,
  isImportNamespaceSpecifier,
  isStatement: isStatement$3,
} = _t$k
function ImportSpecifier(node2) {
  if (node2.importKind === 'type' || node2.importKind === 'typeof') {
    this.word(node2.importKind)
    this.space()
  }
  this.print(node2.imported, node2)
  if (node2.local && node2.local.name !== node2.imported.name) {
    this.space()
    this.word('as')
    this.space()
    this.print(node2.local, node2)
  }
}
function ImportDefaultSpecifier(node2) {
  this.print(node2.local, node2)
}
function ExportDefaultSpecifier(node2) {
  this.print(node2.exported, node2)
}
function ExportSpecifier(node2) {
  if (node2.exportKind === 'type') {
    this.word('type')
    this.space()
  }
  this.print(node2.local, node2)
  if (node2.exported && node2.local.name !== node2.exported.name) {
    this.space()
    this.word('as')
    this.space()
    this.print(node2.exported, node2)
  }
}
function ExportNamespaceSpecifier(node2) {
  this.token('*')
  this.space()
  this.word('as')
  this.space()
  this.print(node2.exported, node2)
}
function ExportAllDeclaration(node2) {
  this.word('export')
  this.space()
  if (node2.exportKind === 'type') {
    this.word('type')
    this.space()
  }
  this.token('*')
  this.space()
  this.word('from')
  this.space()
  this.print(node2.source, node2)
  this.printAssertions(node2)
  this.semicolon()
}
function ExportNamedDeclaration(node2) {
  if (this.format.decoratorsBeforeExport && isClassDeclaration(node2.declaration)) {
    this.printJoin(node2.declaration.decorators, node2)
  }
  this.word('export')
  this.space()
  ExportDeclaration.apply(this, arguments)
}
function ExportDefaultDeclaration(node2) {
  if (this.format.decoratorsBeforeExport && isClassDeclaration(node2.declaration)) {
    this.printJoin(node2.declaration.decorators, node2)
  }
  this.word('export')
  this.space()
  this.word('default')
  this.space()
  ExportDeclaration.apply(this, arguments)
}
function ExportDeclaration(node2) {
  if (node2.declaration) {
    const declar = node2.declaration
    this.print(declar, node2)
    if (!isStatement$3(declar)) this.semicolon()
  } else {
    if (node2.exportKind === 'type') {
      this.word('type')
      this.space()
    }
    const specifiers = node2.specifiers.slice(0)
    let hasSpecial = false
    for (;;) {
      const first = specifiers[0]
      if (isExportDefaultSpecifier(first) || isExportNamespaceSpecifier(first)) {
        hasSpecial = true
        this.print(specifiers.shift(), node2)
        if (specifiers.length) {
          this.token(',')
          this.space()
        }
      } else {
        break
      }
    }
    if (specifiers.length || (!specifiers.length && !hasSpecial)) {
      this.token('{')
      if (specifiers.length) {
        this.space()
        this.printList(specifiers, node2)
        this.space()
      }
      this.token('}')
    }
    if (node2.source) {
      this.space()
      this.word('from')
      this.space()
      this.print(node2.source, node2)
      this.printAssertions(node2)
    }
    this.semicolon()
  }
}
function ImportDeclaration(node2) {
  this.word('import')
  this.space()
  const isTypeKind = node2.importKind === 'type' || node2.importKind === 'typeof'
  if (isTypeKind) {
    this.word(node2.importKind)
    this.space()
  }
  const specifiers = node2.specifiers.slice(0)
  const hasSpecifiers = !!specifiers.length
  while (hasSpecifiers) {
    const first = specifiers[0]
    if (isImportDefaultSpecifier(first) || isImportNamespaceSpecifier(first)) {
      this.print(specifiers.shift(), node2)
      if (specifiers.length) {
        this.token(',')
        this.space()
      }
    } else {
      break
    }
  }
  if (specifiers.length) {
    this.token('{')
    this.space()
    this.printList(specifiers, node2)
    this.space()
    this.token('}')
  } else if (isTypeKind && !hasSpecifiers) {
    this.token('{')
    this.token('}')
  }
  if (hasSpecifiers || isTypeKind) {
    this.space()
    this.word('from')
    this.space()
  }
  this.print(node2.source, node2)
  this.printAssertions(node2)
  {
    var _node$attributes
    if ((_node$attributes = node2.attributes) != null && _node$attributes.length) {
      this.space()
      this.word('with')
      this.space()
      this.printList(node2.attributes, node2)
    }
  }
  this.semicolon()
}
function ImportAttribute(node2) {
  this.print(node2.key)
  this.token(':')
  this.space()
  this.print(node2.value)
}
function ImportNamespaceSpecifier(node2) {
  this.token('*')
  this.space()
  this.word('as')
  this.space()
  this.print(node2.local, node2)
}
var types$2 = {}
const object = {}
const hasOwnProperty = object.hasOwnProperty
const forOwn = (object2, callback) => {
  for (const key in object2) {
    if (hasOwnProperty.call(object2, key)) {
      callback(key, object2[key])
    }
  }
}
const extend = (destination, source) => {
  if (!source) {
    return destination
  }
  forOwn(source, (key, value) => {
    destination[key] = value
  })
  return destination
}
const forEach = (array, callback) => {
  const length = array.length
  let index2 = -1
  while (++index2 < length) {
    callback(array[index2])
  }
}
const toString = object.toString
const isArray$2 = Array.isArray
const isBuffer = Buffer.isBuffer
const isObject$1 = (value) => {
  return toString.call(value) == '[object Object]'
}
const isString$2 = (value) => {
  return typeof value == 'string' || toString.call(value) == '[object String]'
}
const isNumber$1 = (value) => {
  return typeof value == 'number' || toString.call(value) == '[object Number]'
}
const isFunction$2 = (value) => {
  return typeof value == 'function'
}
const isMap = (value) => {
  return toString.call(value) == '[object Map]'
}
const isSet = (value) => {
  return toString.call(value) == '[object Set]'
}
const singleEscapes = {
  '"': '\\"',
  "'": "\\'",
  '\\': '\\\\',
  '\b': '\\b',
  '\f': '\\f',
  '\n': '\\n',
  '\r': '\\r',
  '	': '\\t',
}
const regexSingleEscape = /["'\\\b\f\n\r\t]/
const regexDigit = /[0-9]/
const regexWhitelist = /[ !#-&\(-\[\]-_a-~]/
const jsesc = (argument, options2) => {
  const increaseIndentation = () => {
    oldIndent = indent
    ++options2.indentLevel
    indent = options2.indent.repeat(options2.indentLevel)
  }
  const defaults = {
    escapeEverything: false,
    minimal: false,
    isScriptContext: false,
    quotes: 'single',
    wrap: false,
    es6: false,
    json: false,
    compact: true,
    lowercaseHex: false,
    numbers: 'decimal',
    indent: '	',
    indentLevel: 0,
    __inline1__: false,
    __inline2__: false,
  }
  const json = options2 && options2.json
  if (json) {
    defaults.quotes = 'double'
    defaults.wrap = true
  }
  options2 = extend(defaults, options2)
  if (options2.quotes != 'single' && options2.quotes != 'double' && options2.quotes != 'backtick') {
    options2.quotes = 'single'
  }
  const quote = options2.quotes == 'double' ? '"' : options2.quotes == 'backtick' ? '`' : "'"
  const compact = options2.compact
  const lowercaseHex = options2.lowercaseHex
  let indent = options2.indent.repeat(options2.indentLevel)
  let oldIndent = ''
  const inline1 = options2.__inline1__
  const inline2 = options2.__inline2__
  const newLine = compact ? '' : '\n'
  let result
  let isEmpty2 = true
  const useBinNumbers = options2.numbers == 'binary'
  const useOctNumbers = options2.numbers == 'octal'
  const useDecNumbers = options2.numbers == 'decimal'
  const useHexNumbers = options2.numbers == 'hexadecimal'
  if (json && argument && isFunction$2(argument.toJSON)) {
    argument = argument.toJSON()
  }
  if (!isString$2(argument)) {
    if (isMap(argument)) {
      if (argument.size == 0) {
        return 'new Map()'
      }
      if (!compact) {
        options2.__inline1__ = true
        options2.__inline2__ = false
      }
      return 'new Map(' + jsesc(Array.from(argument), options2) + ')'
    }
    if (isSet(argument)) {
      if (argument.size == 0) {
        return 'new Set()'
      }
      return 'new Set(' + jsesc(Array.from(argument), options2) + ')'
    }
    if (isBuffer(argument)) {
      if (argument.length == 0) {
        return 'Buffer.from([])'
      }
      return 'Buffer.from(' + jsesc(Array.from(argument), options2) + ')'
    }
    if (isArray$2(argument)) {
      result = []
      options2.wrap = true
      if (inline1) {
        options2.__inline1__ = false
        options2.__inline2__ = true
      }
      if (!inline2) {
        increaseIndentation()
      }
      forEach(argument, (value) => {
        isEmpty2 = false
        if (inline2) {
          options2.__inline2__ = false
        }
        result.push((compact || inline2 ? '' : indent) + jsesc(value, options2))
      })
      if (isEmpty2) {
        return '[]'
      }
      if (inline2) {
        return '[' + result.join(', ') + ']'
      }
      return '[' + newLine + result.join(',' + newLine) + newLine + (compact ? '' : oldIndent) + ']'
    } else if (isNumber$1(argument)) {
      if (json) {
        return JSON.stringify(argument)
      }
      if (useDecNumbers) {
        return String(argument)
      }
      if (useHexNumbers) {
        let hexadecimal = argument.toString(16)
        if (!lowercaseHex) {
          hexadecimal = hexadecimal.toUpperCase()
        }
        return '0x' + hexadecimal
      }
      if (useBinNumbers) {
        return '0b' + argument.toString(2)
      }
      if (useOctNumbers) {
        return '0o' + argument.toString(8)
      }
    } else if (!isObject$1(argument)) {
      if (json) {
        return JSON.stringify(argument) || 'null'
      }
      return String(argument)
    } else {
      result = []
      options2.wrap = true
      increaseIndentation()
      forOwn(argument, (key, value) => {
        isEmpty2 = false
        result.push(
          (compact ? '' : indent) + jsesc(key, options2) + ':' + (compact ? '' : ' ') + jsesc(value, options2)
        )
      })
      if (isEmpty2) {
        return '{}'
      }
      return '{' + newLine + result.join(',' + newLine) + newLine + (compact ? '' : oldIndent) + '}'
    }
  }
  const string2 = argument
  let index2 = -1
  const length = string2.length
  result = ''
  while (++index2 < length) {
    const character = string2.charAt(index2)
    if (options2.es6) {
      const first = string2.charCodeAt(index2)
      if (first >= 55296 && first <= 56319 && length > index2 + 1) {
        const second = string2.charCodeAt(index2 + 1)
        if (second >= 56320 && second <= 57343) {
          const codePoint = (first - 55296) * 1024 + second - 56320 + 65536
          let hexadecimal2 = codePoint.toString(16)
          if (!lowercaseHex) {
            hexadecimal2 = hexadecimal2.toUpperCase()
          }
          result += '\\u{' + hexadecimal2 + '}'
          ++index2
          continue
        }
      }
    }
    if (!options2.escapeEverything) {
      if (regexWhitelist.test(character)) {
        result += character
        continue
      }
      if (character == '"') {
        result += quote == character ? '\\"' : character
        continue
      }
      if (character == '`') {
        result += quote == character ? '\\`' : character
        continue
      }
      if (character == "'") {
        result += quote == character ? "\\'" : character
        continue
      }
    }
    if (character == '\0' && !json && !regexDigit.test(string2.charAt(index2 + 1))) {
      result += '\\0'
      continue
    }
    if (regexSingleEscape.test(character)) {
      result += singleEscapes[character]
      continue
    }
    const charCode = character.charCodeAt(0)
    if (options2.minimal && charCode != 8232 && charCode != 8233) {
      result += character
      continue
    }
    let hexadecimal = charCode.toString(16)
    if (!lowercaseHex) {
      hexadecimal = hexadecimal.toUpperCase()
    }
    const longhand = hexadecimal.length > 2 || json
    const escaped = '\\' + (longhand ? 'u' : 'x') + ('0000' + hexadecimal).slice(longhand ? -4 : -2)
    result += escaped
    continue
  }
  if (options2.wrap) {
    result = quote + result + quote
  }
  if (quote == '`') {
    result = result.replace(/\$\{/g, '\\${')
  }
  if (options2.isScriptContext) {
    return result.replace(/<\/(script|style)/gi, '<\\/$1').replace(/<!--/g, json ? '\\u003C!--' : '\\x3C!--')
  }
  return result
}
jsesc.version = '2.5.2'
var jsesc_1 = jsesc
Object.defineProperty(types$2, '__esModule', {
  value: true,
})
types$2.ArgumentPlaceholder = ArgumentPlaceholder
types$2.ArrayPattern = types$2.ArrayExpression = ArrayExpression
types$2.BigIntLiteral = BigIntLiteral
types$2.BooleanLiteral = BooleanLiteral
types$2.DecimalLiteral = DecimalLiteral
types$2.Identifier = Identifier
types$2.NullLiteral = NullLiteral
types$2.NumericLiteral = NumericLiteral
types$2.ObjectPattern = types$2.ObjectExpression = ObjectExpression
types$2.ObjectMethod = ObjectMethod
types$2.ObjectProperty = ObjectProperty
types$2.PipelineBareFunction = PipelineBareFunction
types$2.PipelinePrimaryTopicReference = PipelinePrimaryTopicReference
types$2.PipelineTopicExpression = PipelineTopicExpression
types$2.RecordExpression = RecordExpression
types$2.RegExpLiteral = RegExpLiteral
types$2.SpreadElement = types$2.RestElement = RestElement
types$2.StringLiteral = StringLiteral
types$2.TopicReference = TopicReference
types$2.TupleExpression = TupleExpression
var _t$j = lib$b
var _jsesc = jsesc_1
const { isAssignmentPattern: isAssignmentPattern$1, isIdentifier: isIdentifier$6 } = _t$j
function Identifier(node2) {
  this.exactSource(node2.loc, () => {
    this.word(node2.name)
  })
}
function ArgumentPlaceholder() {
  this.token('?')
}
function RestElement(node2) {
  this.token('...')
  this.print(node2.argument, node2)
}
function ObjectExpression(node2) {
  const props2 = node2.properties
  this.token('{')
  this.printInnerComments(node2)
  if (props2.length) {
    this.space()
    this.printList(props2, node2, {
      indent: true,
      statement: true,
    })
    this.space()
  }
  this.token('}')
}
function ObjectMethod(node2) {
  this.printJoin(node2.decorators, node2)
  this._methodHead(node2)
  this.space()
  this.print(node2.body, node2)
}
function ObjectProperty(node2) {
  this.printJoin(node2.decorators, node2)
  if (node2.computed) {
    this.token('[')
    this.print(node2.key, node2)
    this.token(']')
  } else {
    if (isAssignmentPattern$1(node2.value) && isIdentifier$6(node2.key) && node2.key.name === node2.value.left.name) {
      this.print(node2.value, node2)
      return
    }
    this.print(node2.key, node2)
    if (
      node2.shorthand &&
      isIdentifier$6(node2.key) &&
      isIdentifier$6(node2.value) &&
      node2.key.name === node2.value.name
    ) {
      return
    }
  }
  this.token(':')
  this.space()
  this.print(node2.value, node2)
}
function ArrayExpression(node2) {
  const elems = node2.elements
  const len = elems.length
  this.token('[')
  this.printInnerComments(node2)
  for (let i = 0; i < elems.length; i++) {
    const elem = elems[i]
    if (elem) {
      if (i > 0) this.space()
      this.print(elem, node2)
      if (i < len - 1) this.token(',')
    } else {
      this.token(',')
    }
  }
  this.token(']')
}
function RecordExpression(node2) {
  const props2 = node2.properties
  let startToken
  let endToken
  if (this.format.recordAndTupleSyntaxType === 'bar') {
    startToken = '{|'
    endToken = '|}'
  } else if (this.format.recordAndTupleSyntaxType === 'hash') {
    startToken = '#{'
    endToken = '}'
  } else {
    throw new Error(
      `The "recordAndTupleSyntaxType" generator option must be "bar" or "hash" (${JSON.stringify(
        this.format.recordAndTupleSyntaxType
      )} received).`
    )
  }
  this.token(startToken)
  this.printInnerComments(node2)
  if (props2.length) {
    this.space()
    this.printList(props2, node2, {
      indent: true,
      statement: true,
    })
    this.space()
  }
  this.token(endToken)
}
function TupleExpression(node2) {
  const elems = node2.elements
  const len = elems.length
  let startToken
  let endToken
  if (this.format.recordAndTupleSyntaxType === 'bar') {
    startToken = '[|'
    endToken = '|]'
  } else if (this.format.recordAndTupleSyntaxType === 'hash') {
    startToken = '#['
    endToken = ']'
  } else {
    throw new Error(`${this.format.recordAndTupleSyntaxType} is not a valid recordAndTuple syntax type`)
  }
  this.token(startToken)
  this.printInnerComments(node2)
  for (let i = 0; i < elems.length; i++) {
    const elem = elems[i]
    if (elem) {
      if (i > 0) this.space()
      this.print(elem, node2)
      if (i < len - 1) this.token(',')
    }
  }
  this.token(endToken)
}
function RegExpLiteral(node2) {
  this.word(`/${node2.pattern}/${node2.flags}`)
}
function BooleanLiteral(node2) {
  this.word(node2.value ? 'true' : 'false')
}
function NullLiteral() {
  this.word('null')
}
function NumericLiteral(node2) {
  const raw = this.getPossibleRaw(node2)
  const opts = this.format.jsescOption
  const value = node2.value + ''
  if (opts.numbers) {
    this.number(_jsesc(node2.value, opts))
  } else if (raw == null) {
    this.number(value)
  } else if (this.format.minified) {
    this.number(raw.length < value.length ? raw : value)
  } else {
    this.number(raw)
  }
}
function StringLiteral(node2) {
  const raw = this.getPossibleRaw(node2)
  if (!this.format.minified && raw != null) {
    this.token(raw)
    return
  }
  const val = _jsesc(
    node2.value,
    Object.assign(
      this.format.jsescOption,
      this.format.jsonCompatibleStrings && {
        json: true,
      }
    )
  )
  return this.token(val)
}
function BigIntLiteral(node2) {
  const raw = this.getPossibleRaw(node2)
  if (!this.format.minified && raw != null) {
    this.word(raw)
    return
  }
  this.word(node2.value + 'n')
}
function DecimalLiteral(node2) {
  const raw = this.getPossibleRaw(node2)
  if (!this.format.minified && raw != null) {
    this.word(raw)
    return
  }
  this.word(node2.value + 'm')
}
const validTopicTokenSet = /* @__PURE__ */ new Set(['^^', '@@', '^', '%', '#'])
function TopicReference() {
  const { topicToken } = this.format
  if (validTopicTokenSet.has(topicToken)) {
    this.token(topicToken)
  } else {
    const givenTopicTokenJSON = JSON.stringify(topicToken)
    const validTopics = Array.from(validTopicTokenSet, (v) => JSON.stringify(v))
    throw new Error(
      `The "topicToken" generator option must be one of ${validTopics.join(
        ', '
      )} (${givenTopicTokenJSON} received instead).`
    )
  }
}
function PipelineTopicExpression(node2) {
  this.print(node2.expression, node2)
}
function PipelineBareFunction(node2) {
  this.print(node2.callee, node2)
}
function PipelinePrimaryTopicReference() {
  this.token('#')
}
var flow$2 = {}
;(function (exports) {
  Object.defineProperty(exports, '__esModule', {
    value: true,
  })
  exports.AnyTypeAnnotation = AnyTypeAnnotation
  exports.ArrayTypeAnnotation = ArrayTypeAnnotation
  exports.BooleanLiteralTypeAnnotation = BooleanLiteralTypeAnnotation
  exports.BooleanTypeAnnotation = BooleanTypeAnnotation
  exports.DeclareClass = DeclareClass
  exports.DeclareExportAllDeclaration = DeclareExportAllDeclaration
  exports.DeclareExportDeclaration = DeclareExportDeclaration
  exports.DeclareFunction = DeclareFunction
  exports.DeclareInterface = DeclareInterface
  exports.DeclareModule = DeclareModule
  exports.DeclareModuleExports = DeclareModuleExports
  exports.DeclareOpaqueType = DeclareOpaqueType
  exports.DeclareTypeAlias = DeclareTypeAlias
  exports.DeclareVariable = DeclareVariable
  exports.DeclaredPredicate = DeclaredPredicate
  exports.EmptyTypeAnnotation = EmptyTypeAnnotation
  exports.EnumBooleanBody = EnumBooleanBody
  exports.EnumBooleanMember = EnumBooleanMember
  exports.EnumDeclaration = EnumDeclaration
  exports.EnumDefaultedMember = EnumDefaultedMember
  exports.EnumNumberBody = EnumNumberBody
  exports.EnumNumberMember = EnumNumberMember
  exports.EnumStringBody = EnumStringBody
  exports.EnumStringMember = EnumStringMember
  exports.EnumSymbolBody = EnumSymbolBody
  exports.ExistsTypeAnnotation = ExistsTypeAnnotation
  exports.FunctionTypeAnnotation = FunctionTypeAnnotation2
  exports.FunctionTypeParam = FunctionTypeParam
  exports.IndexedAccessType = IndexedAccessType
  exports.InferredPredicate = InferredPredicate
  exports.InterfaceDeclaration = InterfaceDeclaration
  exports.GenericTypeAnnotation = exports.ClassImplements = exports.InterfaceExtends = InterfaceExtends
  exports.InterfaceTypeAnnotation = InterfaceTypeAnnotation
  exports.IntersectionTypeAnnotation = IntersectionTypeAnnotation
  exports.MixedTypeAnnotation = MixedTypeAnnotation
  exports.NullLiteralTypeAnnotation = NullLiteralTypeAnnotation
  exports.NullableTypeAnnotation = NullableTypeAnnotation2
  Object.defineProperty(exports, 'NumberLiteralTypeAnnotation', {
    enumerable: true,
    get: function () {
      return _types2.NumericLiteral
    },
  })
  exports.NumberTypeAnnotation = NumberTypeAnnotation
  exports.ObjectTypeAnnotation = ObjectTypeAnnotation
  exports.ObjectTypeCallProperty = ObjectTypeCallProperty
  exports.ObjectTypeIndexer = ObjectTypeIndexer
  exports.ObjectTypeInternalSlot = ObjectTypeInternalSlot
  exports.ObjectTypeProperty = ObjectTypeProperty
  exports.ObjectTypeSpreadProperty = ObjectTypeSpreadProperty
  exports.OpaqueType = OpaqueType
  exports.OptionalIndexedAccessType = OptionalIndexedAccessType2
  exports.QualifiedTypeIdentifier = QualifiedTypeIdentifier
  Object.defineProperty(exports, 'StringLiteralTypeAnnotation', {
    enumerable: true,
    get: function () {
      return _types2.StringLiteral
    },
  })
  exports.StringTypeAnnotation = StringTypeAnnotation
  exports.SymbolTypeAnnotation = SymbolTypeAnnotation
  exports.ThisTypeAnnotation = ThisTypeAnnotation
  exports.TupleTypeAnnotation = TupleTypeAnnotation
  exports.TypeAlias = TypeAlias
  exports.TypeAnnotation = TypeAnnotation
  exports.TypeCastExpression = TypeCastExpression
  exports.TypeParameter = TypeParameter
  exports.TypeParameterDeclaration = exports.TypeParameterInstantiation = TypeParameterInstantiation
  exports.TypeofTypeAnnotation = TypeofTypeAnnotation
  exports.UnionTypeAnnotation = UnionTypeAnnotation2
  exports.Variance = Variance
  exports.VoidTypeAnnotation = VoidTypeAnnotation
  exports._interfaceish = _interfaceish
  exports._variance = _variance
  var _t3 = lib$b
  var _modules = modules
  var _types2 = types$2
  const { isDeclareExportDeclaration: isDeclareExportDeclaration2, isStatement: isStatement2 } = _t3
  function AnyTypeAnnotation() {
    this.word('any')
  }
  function ArrayTypeAnnotation(node2) {
    this.print(node2.elementType, node2)
    this.token('[')
    this.token(']')
  }
  function BooleanTypeAnnotation() {
    this.word('boolean')
  }
  function BooleanLiteralTypeAnnotation(node2) {
    this.word(node2.value ? 'true' : 'false')
  }
  function NullLiteralTypeAnnotation() {
    this.word('null')
  }
  function DeclareClass(node2, parent) {
    if (!isDeclareExportDeclaration2(parent)) {
      this.word('declare')
      this.space()
    }
    this.word('class')
    this.space()
    this._interfaceish(node2)
  }
  function DeclareFunction(node2, parent) {
    if (!isDeclareExportDeclaration2(parent)) {
      this.word('declare')
      this.space()
    }
    this.word('function')
    this.space()
    this.print(node2.id, node2)
    this.print(node2.id.typeAnnotation.typeAnnotation, node2)
    if (node2.predicate) {
      this.space()
      this.print(node2.predicate, node2)
    }
    this.semicolon()
  }
  function InferredPredicate() {
    this.token('%')
    this.word('checks')
  }
  function DeclaredPredicate(node2) {
    this.token('%')
    this.word('checks')
    this.token('(')
    this.print(node2.value, node2)
    this.token(')')
  }
  function DeclareInterface(node2) {
    this.word('declare')
    this.space()
    this.InterfaceDeclaration(node2)
  }
  function DeclareModule(node2) {
    this.word('declare')
    this.space()
    this.word('module')
    this.space()
    this.print(node2.id, node2)
    this.space()
    this.print(node2.body, node2)
  }
  function DeclareModuleExports(node2) {
    this.word('declare')
    this.space()
    this.word('module')
    this.token('.')
    this.word('exports')
    this.print(node2.typeAnnotation, node2)
  }
  function DeclareTypeAlias(node2) {
    this.word('declare')
    this.space()
    this.TypeAlias(node2)
  }
  function DeclareOpaqueType(node2, parent) {
    if (!isDeclareExportDeclaration2(parent)) {
      this.word('declare')
      this.space()
    }
    this.OpaqueType(node2)
  }
  function DeclareVariable(node2, parent) {
    if (!isDeclareExportDeclaration2(parent)) {
      this.word('declare')
      this.space()
    }
    this.word('var')
    this.space()
    this.print(node2.id, node2)
    this.print(node2.id.typeAnnotation, node2)
    this.semicolon()
  }
  function DeclareExportDeclaration(node2) {
    this.word('declare')
    this.space()
    this.word('export')
    this.space()
    if (node2.default) {
      this.word('default')
      this.space()
    }
    FlowExportDeclaration.apply(this, arguments)
  }
  function DeclareExportAllDeclaration() {
    this.word('declare')
    this.space()
    _modules.ExportAllDeclaration.apply(this, arguments)
  }
  function EnumDeclaration(node2) {
    const { id, body } = node2
    this.word('enum')
    this.space()
    this.print(id, node2)
    this.print(body, node2)
  }
  function enumExplicitType(context2, name, hasExplicitType) {
    if (hasExplicitType) {
      context2.space()
      context2.word('of')
      context2.space()
      context2.word(name)
    }
    context2.space()
  }
  function enumBody(context2, node2) {
    const { members } = node2
    context2.token('{')
    context2.indent()
    context2.newline()
    for (const member of members) {
      context2.print(member, node2)
      context2.newline()
    }
    if (node2.hasUnknownMembers) {
      context2.token('...')
      context2.newline()
    }
    context2.dedent()
    context2.token('}')
  }
  function EnumBooleanBody(node2) {
    const { explicitType } = node2
    enumExplicitType(this, 'boolean', explicitType)
    enumBody(this, node2)
  }
  function EnumNumberBody(node2) {
    const { explicitType } = node2
    enumExplicitType(this, 'number', explicitType)
    enumBody(this, node2)
  }
  function EnumStringBody(node2) {
    const { explicitType } = node2
    enumExplicitType(this, 'string', explicitType)
    enumBody(this, node2)
  }
  function EnumSymbolBody(node2) {
    enumExplicitType(this, 'symbol', true)
    enumBody(this, node2)
  }
  function EnumDefaultedMember(node2) {
    const { id } = node2
    this.print(id, node2)
    this.token(',')
  }
  function enumInitializedMember(context2, node2) {
    const { id, init } = node2
    context2.print(id, node2)
    context2.space()
    context2.token('=')
    context2.space()
    context2.print(init, node2)
    context2.token(',')
  }
  function EnumBooleanMember(node2) {
    enumInitializedMember(this, node2)
  }
  function EnumNumberMember(node2) {
    enumInitializedMember(this, node2)
  }
  function EnumStringMember(node2) {
    enumInitializedMember(this, node2)
  }
  function FlowExportDeclaration(node2) {
    if (node2.declaration) {
      const declar = node2.declaration
      this.print(declar, node2)
      if (!isStatement2(declar)) this.semicolon()
    } else {
      this.token('{')
      if (node2.specifiers.length) {
        this.space()
        this.printList(node2.specifiers, node2)
        this.space()
      }
      this.token('}')
      if (node2.source) {
        this.space()
        this.word('from')
        this.space()
        this.print(node2.source, node2)
      }
      this.semicolon()
    }
  }
  function ExistsTypeAnnotation() {
    this.token('*')
  }
  function FunctionTypeAnnotation2(node2, parent) {
    this.print(node2.typeParameters, node2)
    this.token('(')
    if (node2.this) {
      this.word('this')
      this.token(':')
      this.space()
      this.print(node2.this.typeAnnotation, node2)
      if (node2.params.length || node2.rest) {
        this.token(',')
        this.space()
      }
    }
    this.printList(node2.params, node2)
    if (node2.rest) {
      if (node2.params.length) {
        this.token(',')
        this.space()
      }
      this.token('...')
      this.print(node2.rest, node2)
    }
    this.token(')')
    if (
      parent &&
      (parent.type === 'ObjectTypeCallProperty' ||
        parent.type === 'DeclareFunction' ||
        (parent.type === 'ObjectTypeProperty' && parent.method))
    ) {
      this.token(':')
    } else {
      this.space()
      this.token('=>')
    }
    this.space()
    this.print(node2.returnType, node2)
  }
  function FunctionTypeParam(node2) {
    this.print(node2.name, node2)
    if (node2.optional) this.token('?')
    if (node2.name) {
      this.token(':')
      this.space()
    }
    this.print(node2.typeAnnotation, node2)
  }
  function InterfaceExtends(node2) {
    this.print(node2.id, node2)
    this.print(node2.typeParameters, node2)
  }
  function _interfaceish(node2) {
    var _node$extends
    this.print(node2.id, node2)
    this.print(node2.typeParameters, node2)
    if ((_node$extends = node2.extends) != null && _node$extends.length) {
      this.space()
      this.word('extends')
      this.space()
      this.printList(node2.extends, node2)
    }
    if (node2.mixins && node2.mixins.length) {
      this.space()
      this.word('mixins')
      this.space()
      this.printList(node2.mixins, node2)
    }
    if (node2.implements && node2.implements.length) {
      this.space()
      this.word('implements')
      this.space()
      this.printList(node2.implements, node2)
    }
    this.space()
    this.print(node2.body, node2)
  }
  function _variance(node2) {
    if (node2.variance) {
      if (node2.variance.kind === 'plus') {
        this.token('+')
      } else if (node2.variance.kind === 'minus') {
        this.token('-')
      }
    }
  }
  function InterfaceDeclaration(node2) {
    this.word('interface')
    this.space()
    this._interfaceish(node2)
  }
  function andSeparator() {
    this.space()
    this.token('&')
    this.space()
  }
  function InterfaceTypeAnnotation(node2) {
    this.word('interface')
    if (node2.extends && node2.extends.length) {
      this.space()
      this.word('extends')
      this.space()
      this.printList(node2.extends, node2)
    }
    this.space()
    this.print(node2.body, node2)
  }
  function IntersectionTypeAnnotation(node2) {
    this.printJoin(node2.types, node2, {
      separator: andSeparator,
    })
  }
  function MixedTypeAnnotation() {
    this.word('mixed')
  }
  function EmptyTypeAnnotation() {
    this.word('empty')
  }
  function NullableTypeAnnotation2(node2) {
    this.token('?')
    this.print(node2.typeAnnotation, node2)
  }
  function NumberTypeAnnotation() {
    this.word('number')
  }
  function StringTypeAnnotation() {
    this.word('string')
  }
  function ThisTypeAnnotation() {
    this.word('this')
  }
  function TupleTypeAnnotation(node2) {
    this.token('[')
    this.printList(node2.types, node2)
    this.token(']')
  }
  function TypeofTypeAnnotation(node2) {
    this.word('typeof')
    this.space()
    this.print(node2.argument, node2)
  }
  function TypeAlias(node2) {
    this.word('type')
    this.space()
    this.print(node2.id, node2)
    this.print(node2.typeParameters, node2)
    this.space()
    this.token('=')
    this.space()
    this.print(node2.right, node2)
    this.semicolon()
  }
  function TypeAnnotation(node2) {
    this.token(':')
    this.space()
    if (node2.optional) this.token('?')
    this.print(node2.typeAnnotation, node2)
  }
  function TypeParameterInstantiation(node2) {
    this.token('<')
    this.printList(node2.params, node2, {})
    this.token('>')
  }
  function TypeParameter(node2) {
    this._variance(node2)
    this.word(node2.name)
    if (node2.bound) {
      this.print(node2.bound, node2)
    }
    if (node2.default) {
      this.space()
      this.token('=')
      this.space()
      this.print(node2.default, node2)
    }
  }
  function OpaqueType(node2) {
    this.word('opaque')
    this.space()
    this.word('type')
    this.space()
    this.print(node2.id, node2)
    this.print(node2.typeParameters, node2)
    if (node2.supertype) {
      this.token(':')
      this.space()
      this.print(node2.supertype, node2)
    }
    if (node2.impltype) {
      this.space()
      this.token('=')
      this.space()
      this.print(node2.impltype, node2)
    }
    this.semicolon()
  }
  function ObjectTypeAnnotation(node2) {
    if (node2.exact) {
      this.token('{|')
    } else {
      this.token('{')
    }
    const props2 = [
      ...node2.properties,
      ...(node2.callProperties || []),
      ...(node2.indexers || []),
      ...(node2.internalSlots || []),
    ]
    if (props2.length) {
      this.space()
      this.printJoin(props2, node2, {
        addNewlines(leading) {
          if (leading && !props2[0]) return 1
        },
        indent: true,
        statement: true,
        iterator: () => {
          if (props2.length !== 1 || node2.inexact) {
            this.token(',')
            this.space()
          }
        },
      })
      this.space()
    }
    if (node2.inexact) {
      this.indent()
      this.token('...')
      if (props2.length) {
        this.newline()
      }
      this.dedent()
    }
    if (node2.exact) {
      this.token('|}')
    } else {
      this.token('}')
    }
  }
  function ObjectTypeInternalSlot(node2) {
    if (node2.static) {
      this.word('static')
      this.space()
    }
    this.token('[')
    this.token('[')
    this.print(node2.id, node2)
    this.token(']')
    this.token(']')
    if (node2.optional) this.token('?')
    if (!node2.method) {
      this.token(':')
      this.space()
    }
    this.print(node2.value, node2)
  }
  function ObjectTypeCallProperty(node2) {
    if (node2.static) {
      this.word('static')
      this.space()
    }
    this.print(node2.value, node2)
  }
  function ObjectTypeIndexer(node2) {
    if (node2.static) {
      this.word('static')
      this.space()
    }
    this._variance(node2)
    this.token('[')
    if (node2.id) {
      this.print(node2.id, node2)
      this.token(':')
      this.space()
    }
    this.print(node2.key, node2)
    this.token(']')
    this.token(':')
    this.space()
    this.print(node2.value, node2)
  }
  function ObjectTypeProperty(node2) {
    if (node2.proto) {
      this.word('proto')
      this.space()
    }
    if (node2.static) {
      this.word('static')
      this.space()
    }
    if (node2.kind === 'get' || node2.kind === 'set') {
      this.word(node2.kind)
      this.space()
    }
    this._variance(node2)
    this.print(node2.key, node2)
    if (node2.optional) this.token('?')
    if (!node2.method) {
      this.token(':')
      this.space()
    }
    this.print(node2.value, node2)
  }
  function ObjectTypeSpreadProperty(node2) {
    this.token('...')
    this.print(node2.argument, node2)
  }
  function QualifiedTypeIdentifier(node2) {
    this.print(node2.qualification, node2)
    this.token('.')
    this.print(node2.id, node2)
  }
  function SymbolTypeAnnotation() {
    this.word('symbol')
  }
  function orSeparator() {
    this.space()
    this.token('|')
    this.space()
  }
  function UnionTypeAnnotation2(node2) {
    this.printJoin(node2.types, node2, {
      separator: orSeparator,
    })
  }
  function TypeCastExpression(node2) {
    this.token('(')
    this.print(node2.expression, node2)
    this.print(node2.typeAnnotation, node2)
    this.token(')')
  }
  function Variance(node2) {
    if (node2.kind === 'plus') {
      this.token('+')
    } else {
      this.token('-')
    }
  }
  function VoidTypeAnnotation() {
    this.word('void')
  }
  function IndexedAccessType(node2) {
    this.print(node2.objectType, node2)
    this.token('[')
    this.print(node2.indexType, node2)
    this.token(']')
  }
  function OptionalIndexedAccessType2(node2) {
    this.print(node2.objectType, node2)
    if (node2.optional) {
      this.token('?.')
    }
    this.token('[')
    this.print(node2.indexType, node2)
    this.token(']')
  }
})(flow$2)
var base = {}
Object.defineProperty(base, '__esModule', {
  value: true,
})
base.BlockStatement = BlockStatement
base.Directive = Directive
base.DirectiveLiteral = DirectiveLiteral
base.File = File
base.InterpreterDirective = InterpreterDirective
base.Placeholder = Placeholder
base.Program = Program
function File(node2) {
  if (node2.program) {
    this.print(node2.program.interpreter, node2)
  }
  this.print(node2.program, node2)
}
function Program(node2) {
  this.printInnerComments(node2, false)
  this.printSequence(node2.directives, node2)
  if (node2.directives && node2.directives.length) this.newline()
  this.printSequence(node2.body, node2)
}
function BlockStatement(node2) {
  var _node$directives
  this.token('{')
  this.printInnerComments(node2)
  const hasDirectives = (_node$directives = node2.directives) == null ? void 0 : _node$directives.length
  if (node2.body.length || hasDirectives) {
    this.newline()
    this.printSequence(node2.directives, node2, {
      indent: true,
    })
    if (hasDirectives) this.newline()
    this.printSequence(node2.body, node2, {
      indent: true,
    })
    this.removeTrailingNewline()
    this.source('end', node2.loc)
    if (!this.endsWith(10)) this.newline()
    this.rightBrace()
  } else {
    this.source('end', node2.loc)
    this.token('}')
  }
}
function Directive(node2) {
  this.print(node2.value, node2)
  this.semicolon()
}
const unescapedSingleQuoteRE = /(?:^|[^\\])(?:\\\\)*'/
const unescapedDoubleQuoteRE = /(?:^|[^\\])(?:\\\\)*"/
function DirectiveLiteral(node2) {
  const raw = this.getPossibleRaw(node2)
  if (!this.format.minified && raw != null) {
    this.token(raw)
    return
  }
  const { value } = node2
  if (!unescapedDoubleQuoteRE.test(value)) {
    this.token(`"${value}"`)
  } else if (!unescapedSingleQuoteRE.test(value)) {
    this.token(`'${value}'`)
  } else {
    throw new Error(
      'Malformed AST: it is not possible to print a directive containing both unescaped single and double quotes.'
    )
  }
}
function InterpreterDirective(node2) {
  this.token(`#!${node2.value}
`)
}
function Placeholder(node2) {
  this.token('%%')
  this.print(node2.name)
  this.token('%%')
  if (node2.expectedNode === 'Statement') {
    this.semicolon()
  }
}
var jsx$2 = {}
Object.defineProperty(jsx$2, '__esModule', {
  value: true,
})
jsx$2.JSXAttribute = JSXAttribute
jsx$2.JSXClosingElement = JSXClosingElement
jsx$2.JSXClosingFragment = JSXClosingFragment
jsx$2.JSXElement = JSXElement
jsx$2.JSXEmptyExpression = JSXEmptyExpression
jsx$2.JSXExpressionContainer = JSXExpressionContainer
jsx$2.JSXFragment = JSXFragment
jsx$2.JSXIdentifier = JSXIdentifier
jsx$2.JSXMemberExpression = JSXMemberExpression
jsx$2.JSXNamespacedName = JSXNamespacedName
jsx$2.JSXOpeningElement = JSXOpeningElement
jsx$2.JSXOpeningFragment = JSXOpeningFragment
jsx$2.JSXSpreadAttribute = JSXSpreadAttribute
jsx$2.JSXSpreadChild = JSXSpreadChild
jsx$2.JSXText = JSXText
function JSXAttribute(node2) {
  this.print(node2.name, node2)
  if (node2.value) {
    this.token('=')
    this.print(node2.value, node2)
  }
}
function JSXIdentifier(node2) {
  this.word(node2.name)
}
function JSXNamespacedName(node2) {
  this.print(node2.namespace, node2)
  this.token(':')
  this.print(node2.name, node2)
}
function JSXMemberExpression(node2) {
  this.print(node2.object, node2)
  this.token('.')
  this.print(node2.property, node2)
}
function JSXSpreadAttribute(node2) {
  this.token('{')
  this.token('...')
  this.print(node2.argument, node2)
  this.token('}')
}
function JSXExpressionContainer(node2) {
  this.token('{')
  this.print(node2.expression, node2)
  this.token('}')
}
function JSXSpreadChild(node2) {
  this.token('{')
  this.token('...')
  this.print(node2.expression, node2)
  this.token('}')
}
function JSXText(node2) {
  const raw = this.getPossibleRaw(node2)
  if (raw != null) {
    this.token(raw)
  } else {
    this.token(node2.value)
  }
}
function JSXElement(node2) {
  const open2 = node2.openingElement
  this.print(open2, node2)
  if (open2.selfClosing) return
  this.indent()
  for (const child of node2.children) {
    this.print(child, node2)
  }
  this.dedent()
  this.print(node2.closingElement, node2)
}
function spaceSeparator() {
  this.space()
}
function JSXOpeningElement(node2) {
  this.token('<')
  this.print(node2.name, node2)
  this.print(node2.typeParameters, node2)
  if (node2.attributes.length > 0) {
    this.space()
    this.printJoin(node2.attributes, node2, {
      separator: spaceSeparator,
    })
  }
  if (node2.selfClosing) {
    this.space()
    this.token('/>')
  } else {
    this.token('>')
  }
}
function JSXClosingElement(node2) {
  this.token('</')
  this.print(node2.name, node2)
  this.token('>')
}
function JSXEmptyExpression(node2) {
  this.printInnerComments(node2)
}
function JSXFragment(node2) {
  this.print(node2.openingFragment, node2)
  this.indent()
  for (const child of node2.children) {
    this.print(child, node2)
  }
  this.dedent()
  this.print(node2.closingFragment, node2)
}
function JSXOpeningFragment() {
  this.token('<')
  this.token('>')
}
function JSXClosingFragment() {
  this.token('</')
  this.token('>')
}
var typescript$2 = {}
Object.defineProperty(typescript$2, '__esModule', {
  value: true,
})
typescript$2.TSAnyKeyword = TSAnyKeyword
typescript$2.TSArrayType = TSArrayType
typescript$2.TSAsExpression = TSAsExpression
typescript$2.TSBigIntKeyword = TSBigIntKeyword
typescript$2.TSBooleanKeyword = TSBooleanKeyword
typescript$2.TSCallSignatureDeclaration = TSCallSignatureDeclaration
typescript$2.TSConditionalType = TSConditionalType
typescript$2.TSConstructSignatureDeclaration = TSConstructSignatureDeclaration
typescript$2.TSConstructorType = TSConstructorType
typescript$2.TSDeclareFunction = TSDeclareFunction
typescript$2.TSDeclareMethod = TSDeclareMethod
typescript$2.TSEnumDeclaration = TSEnumDeclaration
typescript$2.TSEnumMember = TSEnumMember
typescript$2.TSExportAssignment = TSExportAssignment
typescript$2.TSExpressionWithTypeArguments = TSExpressionWithTypeArguments
typescript$2.TSExternalModuleReference = TSExternalModuleReference
typescript$2.TSFunctionType = TSFunctionType
typescript$2.TSImportEqualsDeclaration = TSImportEqualsDeclaration
typescript$2.TSImportType = TSImportType
typescript$2.TSIndexSignature = TSIndexSignature
typescript$2.TSIndexedAccessType = TSIndexedAccessType
typescript$2.TSInferType = TSInferType
typescript$2.TSInstantiationExpression = TSInstantiationExpression
typescript$2.TSInterfaceBody = TSInterfaceBody
typescript$2.TSInterfaceDeclaration = TSInterfaceDeclaration
typescript$2.TSIntersectionType = TSIntersectionType
typescript$2.TSIntrinsicKeyword = TSIntrinsicKeyword
typescript$2.TSLiteralType = TSLiteralType
typescript$2.TSMappedType = TSMappedType
typescript$2.TSMethodSignature = TSMethodSignature
typescript$2.TSModuleBlock = TSModuleBlock
typescript$2.TSModuleDeclaration = TSModuleDeclaration
typescript$2.TSNamedTupleMember = TSNamedTupleMember
typescript$2.TSNamespaceExportDeclaration = TSNamespaceExportDeclaration
typescript$2.TSNeverKeyword = TSNeverKeyword
typescript$2.TSNonNullExpression = TSNonNullExpression
typescript$2.TSNullKeyword = TSNullKeyword
typescript$2.TSNumberKeyword = TSNumberKeyword
typescript$2.TSObjectKeyword = TSObjectKeyword
typescript$2.TSOptionalType = TSOptionalType
typescript$2.TSParameterProperty = TSParameterProperty
typescript$2.TSParenthesizedType = TSParenthesizedType
typescript$2.TSPropertySignature = TSPropertySignature
typescript$2.TSQualifiedName = TSQualifiedName
typescript$2.TSRestType = TSRestType
typescript$2.TSStringKeyword = TSStringKeyword
typescript$2.TSSymbolKeyword = TSSymbolKeyword
typescript$2.TSThisType = TSThisType
typescript$2.TSTupleType = TSTupleType
typescript$2.TSTypeAliasDeclaration = TSTypeAliasDeclaration
typescript$2.TSTypeAnnotation = TSTypeAnnotation
typescript$2.TSTypeAssertion = TSTypeAssertion
typescript$2.TSTypeLiteral = TSTypeLiteral
typescript$2.TSTypeOperator = TSTypeOperator
typescript$2.TSTypeParameter = TSTypeParameter
typescript$2.TSTypeParameterDeclaration = typescript$2.TSTypeParameterInstantiation = TSTypeParameterInstantiation
typescript$2.TSTypePredicate = TSTypePredicate
typescript$2.TSTypeQuery = TSTypeQuery
typescript$2.TSTypeReference = TSTypeReference
typescript$2.TSUndefinedKeyword = TSUndefinedKeyword
typescript$2.TSUnionType = TSUnionType
typescript$2.TSUnknownKeyword = TSUnknownKeyword
typescript$2.TSVoidKeyword = TSVoidKeyword
typescript$2.tsPrintBraced = tsPrintBraced
typescript$2.tsPrintClassMemberModifiers = tsPrintClassMemberModifiers
typescript$2.tsPrintFunctionOrConstructorType = tsPrintFunctionOrConstructorType
typescript$2.tsPrintPropertyOrMethodName = tsPrintPropertyOrMethodName
typescript$2.tsPrintSignatureDeclarationBase = tsPrintSignatureDeclarationBase
typescript$2.tsPrintTypeLiteralOrInterfaceBody = tsPrintTypeLiteralOrInterfaceBody
typescript$2.tsPrintUnionOrIntersectionType = tsPrintUnionOrIntersectionType
function TSTypeAnnotation(node2) {
  this.token(':')
  this.space()
  if (node2.optional) this.token('?')
  this.print(node2.typeAnnotation, node2)
}
function TSTypeParameterInstantiation(node2, parent) {
  this.token('<')
  this.printList(node2.params, node2, {})
  if (parent.type === 'ArrowFunctionExpression' && node2.params.length === 1) {
    this.token(',')
  }
  this.token('>')
}
function TSTypeParameter(node2) {
  if (node2.in) {
    this.word('in')
    this.space()
  }
  if (node2.out) {
    this.word('out')
    this.space()
  }
  this.word(node2.name)
  if (node2.constraint) {
    this.space()
    this.word('extends')
    this.space()
    this.print(node2.constraint, node2)
  }
  if (node2.default) {
    this.space()
    this.token('=')
    this.space()
    this.print(node2.default, node2)
  }
}
function TSParameterProperty(node2) {
  if (node2.accessibility) {
    this.word(node2.accessibility)
    this.space()
  }
  if (node2.readonly) {
    this.word('readonly')
    this.space()
  }
  this._param(node2.parameter)
}
function TSDeclareFunction(node2) {
  if (node2.declare) {
    this.word('declare')
    this.space()
  }
  this._functionHead(node2)
  this.token(';')
}
function TSDeclareMethod(node2) {
  this._classMethodHead(node2)
  this.token(';')
}
function TSQualifiedName(node2) {
  this.print(node2.left, node2)
  this.token('.')
  this.print(node2.right, node2)
}
function TSCallSignatureDeclaration(node2) {
  this.tsPrintSignatureDeclarationBase(node2)
  this.token(';')
}
function TSConstructSignatureDeclaration(node2) {
  this.word('new')
  this.space()
  this.tsPrintSignatureDeclarationBase(node2)
  this.token(';')
}
function TSPropertySignature(node2) {
  const { readonly, initializer } = node2
  if (readonly) {
    this.word('readonly')
    this.space()
  }
  this.tsPrintPropertyOrMethodName(node2)
  this.print(node2.typeAnnotation, node2)
  if (initializer) {
    this.space()
    this.token('=')
    this.space()
    this.print(initializer, node2)
  }
  this.token(';')
}
function tsPrintPropertyOrMethodName(node2) {
  if (node2.computed) {
    this.token('[')
  }
  this.print(node2.key, node2)
  if (node2.computed) {
    this.token(']')
  }
  if (node2.optional) {
    this.token('?')
  }
}
function TSMethodSignature(node2) {
  const { kind } = node2
  if (kind === 'set' || kind === 'get') {
    this.word(kind)
    this.space()
  }
  this.tsPrintPropertyOrMethodName(node2)
  this.tsPrintSignatureDeclarationBase(node2)
  this.token(';')
}
function TSIndexSignature(node2) {
  const { readonly, static: isStatic2 } = node2
  if (isStatic2) {
    this.word('static')
    this.space()
  }
  if (readonly) {
    this.word('readonly')
    this.space()
  }
  this.token('[')
  this._parameters(node2.parameters, node2)
  this.token(']')
  this.print(node2.typeAnnotation, node2)
  this.token(';')
}
function TSAnyKeyword() {
  this.word('any')
}
function TSBigIntKeyword() {
  this.word('bigint')
}
function TSUnknownKeyword() {
  this.word('unknown')
}
function TSNumberKeyword() {
  this.word('number')
}
function TSObjectKeyword() {
  this.word('object')
}
function TSBooleanKeyword() {
  this.word('boolean')
}
function TSStringKeyword() {
  this.word('string')
}
function TSSymbolKeyword() {
  this.word('symbol')
}
function TSVoidKeyword() {
  this.word('void')
}
function TSUndefinedKeyword() {
  this.word('undefined')
}
function TSNullKeyword() {
  this.word('null')
}
function TSNeverKeyword() {
  this.word('never')
}
function TSIntrinsicKeyword() {
  this.word('intrinsic')
}
function TSThisType() {
  this.word('this')
}
function TSFunctionType(node2) {
  this.tsPrintFunctionOrConstructorType(node2)
}
function TSConstructorType(node2) {
  if (node2.abstract) {
    this.word('abstract')
    this.space()
  }
  this.word('new')
  this.space()
  this.tsPrintFunctionOrConstructorType(node2)
}
function tsPrintFunctionOrConstructorType(node2) {
  const { typeParameters } = node2
  const parameters = node2.parameters
  this.print(typeParameters, node2)
  this.token('(')
  this._parameters(parameters, node2)
  this.token(')')
  this.space()
  this.token('=>')
  this.space()
  const returnType = node2.typeAnnotation
  this.print(returnType.typeAnnotation, node2)
}
function TSTypeReference(node2) {
  this.print(node2.typeName, node2)
  this.print(node2.typeParameters, node2)
}
function TSTypePredicate(node2) {
  if (node2.asserts) {
    this.word('asserts')
    this.space()
  }
  this.print(node2.parameterName)
  if (node2.typeAnnotation) {
    this.space()
    this.word('is')
    this.space()
    this.print(node2.typeAnnotation.typeAnnotation)
  }
}
function TSTypeQuery(node2) {
  this.word('typeof')
  this.space()
  this.print(node2.exprName)
  if (node2.typeParameters) {
    this.print(node2.typeParameters, node2)
  }
}
function TSTypeLiteral(node2) {
  this.tsPrintTypeLiteralOrInterfaceBody(node2.members, node2)
}
function tsPrintTypeLiteralOrInterfaceBody(members, node2) {
  this.tsPrintBraced(members, node2)
}
function tsPrintBraced(members, node2) {
  this.token('{')
  if (members.length) {
    this.indent()
    this.newline()
    for (const member of members) {
      this.print(member, node2)
      this.newline()
    }
    this.dedent()
    this.rightBrace()
  } else {
    this.token('}')
  }
}
function TSArrayType(node2) {
  this.print(node2.elementType, node2)
  this.token('[]')
}
function TSTupleType(node2) {
  this.token('[')
  this.printList(node2.elementTypes, node2)
  this.token(']')
}
function TSOptionalType(node2) {
  this.print(node2.typeAnnotation, node2)
  this.token('?')
}
function TSRestType(node2) {
  this.token('...')
  this.print(node2.typeAnnotation, node2)
}
function TSNamedTupleMember(node2) {
  this.print(node2.label, node2)
  if (node2.optional) this.token('?')
  this.token(':')
  this.space()
  this.print(node2.elementType, node2)
}
function TSUnionType(node2) {
  this.tsPrintUnionOrIntersectionType(node2, '|')
}
function TSIntersectionType(node2) {
  this.tsPrintUnionOrIntersectionType(node2, '&')
}
function tsPrintUnionOrIntersectionType(node2, sep) {
  this.printJoin(node2.types, node2, {
    separator() {
      this.space()
      this.token(sep)
      this.space()
    },
  })
}
function TSConditionalType(node2) {
  this.print(node2.checkType)
  this.space()
  this.word('extends')
  this.space()
  this.print(node2.extendsType)
  this.space()
  this.token('?')
  this.space()
  this.print(node2.trueType)
  this.space()
  this.token(':')
  this.space()
  this.print(node2.falseType)
}
function TSInferType(node2) {
  this.token('infer')
  this.space()
  this.print(node2.typeParameter)
}
function TSParenthesizedType(node2) {
  this.token('(')
  this.print(node2.typeAnnotation, node2)
  this.token(')')
}
function TSTypeOperator(node2) {
  this.word(node2.operator)
  this.space()
  this.print(node2.typeAnnotation, node2)
}
function TSIndexedAccessType(node2) {
  this.print(node2.objectType, node2)
  this.token('[')
  this.print(node2.indexType, node2)
  this.token(']')
}
function TSMappedType(node2) {
  const { nameType, optional, readonly, typeParameter: typeParameter2 } = node2
  this.token('{')
  this.space()
  if (readonly) {
    tokenIfPlusMinus(this, readonly)
    this.word('readonly')
    this.space()
  }
  this.token('[')
  this.word(typeParameter2.name)
  this.space()
  this.word('in')
  this.space()
  this.print(typeParameter2.constraint, typeParameter2)
  if (nameType) {
    this.space()
    this.word('as')
    this.space()
    this.print(nameType, node2)
  }
  this.token(']')
  if (optional) {
    tokenIfPlusMinus(this, optional)
    this.token('?')
  }
  this.token(':')
  this.space()
  this.print(node2.typeAnnotation, node2)
  this.space()
  this.token('}')
}
function tokenIfPlusMinus(self2, tok) {
  if (tok !== true) {
    self2.token(tok)
  }
}
function TSLiteralType(node2) {
  this.print(node2.literal, node2)
}
function TSExpressionWithTypeArguments(node2) {
  this.print(node2.expression, node2)
  this.print(node2.typeParameters, node2)
}
function TSInterfaceDeclaration(node2) {
  const { declare, id, typeParameters, extends: extendz, body } = node2
  if (declare) {
    this.word('declare')
    this.space()
  }
  this.word('interface')
  this.space()
  this.print(id, node2)
  this.print(typeParameters, node2)
  if (extendz != null && extendz.length) {
    this.space()
    this.word('extends')
    this.space()
    this.printList(extendz, node2)
  }
  this.space()
  this.print(body, node2)
}
function TSInterfaceBody(node2) {
  this.tsPrintTypeLiteralOrInterfaceBody(node2.body, node2)
}
function TSTypeAliasDeclaration(node2) {
  const { declare, id, typeParameters, typeAnnotation: typeAnnotation2 } = node2
  if (declare) {
    this.word('declare')
    this.space()
  }
  this.word('type')
  this.space()
  this.print(id, node2)
  this.print(typeParameters, node2)
  this.space()
  this.token('=')
  this.space()
  this.print(typeAnnotation2, node2)
  this.token(';')
}
function TSAsExpression(node2) {
  const { expression: expression2, typeAnnotation: typeAnnotation2 } = node2
  this.print(expression2, node2)
  this.space()
  this.word('as')
  this.space()
  this.print(typeAnnotation2, node2)
}
function TSTypeAssertion(node2) {
  const { typeAnnotation: typeAnnotation2, expression: expression2 } = node2
  this.token('<')
  this.print(typeAnnotation2, node2)
  this.token('>')
  this.space()
  this.print(expression2, node2)
}
function TSInstantiationExpression(node2) {
  this.print(node2.expression, node2)
  this.print(node2.typeParameters, node2)
}
function TSEnumDeclaration(node2) {
  const { declare, const: isConst, id, members } = node2
  if (declare) {
    this.word('declare')
    this.space()
  }
  if (isConst) {
    this.word('const')
    this.space()
  }
  this.word('enum')
  this.space()
  this.print(id, node2)
  this.space()
  this.tsPrintBraced(members, node2)
}
function TSEnumMember(node2) {
  const { id, initializer } = node2
  this.print(id, node2)
  if (initializer) {
    this.space()
    this.token('=')
    this.space()
    this.print(initializer, node2)
  }
  this.token(',')
}
function TSModuleDeclaration(node2) {
  const { declare, id } = node2
  if (declare) {
    this.word('declare')
    this.space()
  }
  if (!node2.global) {
    this.word(id.type === 'Identifier' ? 'namespace' : 'module')
    this.space()
  }
  this.print(id, node2)
  if (!node2.body) {
    this.token(';')
    return
  }
  let body = node2.body
  while (body.type === 'TSModuleDeclaration') {
    this.token('.')
    this.print(body.id, body)
    body = body.body
  }
  this.space()
  this.print(body, node2)
}
function TSModuleBlock(node2) {
  this.tsPrintBraced(node2.body, node2)
}
function TSImportType(node2) {
  const { argument, qualifier, typeParameters } = node2
  this.word('import')
  this.token('(')
  this.print(argument, node2)
  this.token(')')
  if (qualifier) {
    this.token('.')
    this.print(qualifier, node2)
  }
  if (typeParameters) {
    this.print(typeParameters, node2)
  }
}
function TSImportEqualsDeclaration(node2) {
  const { isExport, id, moduleReference } = node2
  if (isExport) {
    this.word('export')
    this.space()
  }
  this.word('import')
  this.space()
  this.print(id, node2)
  this.space()
  this.token('=')
  this.space()
  this.print(moduleReference, node2)
  this.token(';')
}
function TSExternalModuleReference(node2) {
  this.token('require(')
  this.print(node2.expression, node2)
  this.token(')')
}
function TSNonNullExpression(node2) {
  this.print(node2.expression, node2)
  this.token('!')
}
function TSExportAssignment(node2) {
  this.word('export')
  this.space()
  this.token('=')
  this.space()
  this.print(node2.expression, node2)
  this.token(';')
}
function TSNamespaceExportDeclaration(node2) {
  this.word('export')
  this.space()
  this.word('as')
  this.space()
  this.word('namespace')
  this.space()
  this.print(node2.id, node2)
}
function tsPrintSignatureDeclarationBase(node2) {
  const { typeParameters } = node2
  const parameters = node2.parameters
  this.print(typeParameters, node2)
  this.token('(')
  this._parameters(parameters, node2)
  this.token(')')
  const returnType = node2.typeAnnotation
  this.print(returnType, node2)
}
function tsPrintClassMemberModifiers(node2, isField) {
  if (isField && node2.declare) {
    this.word('declare')
    this.space()
  }
  if (node2.accessibility) {
    this.word(node2.accessibility)
    this.space()
  }
  if (node2.static) {
    this.word('static')
    this.space()
  }
  if (node2.override) {
    this.word('override')
    this.space()
  }
  if (node2.abstract) {
    this.word('abstract')
    this.space()
  }
  if (isField && node2.readonly) {
    this.word('readonly')
    this.space()
  }
}
;(function (exports) {
  Object.defineProperty(exports, '__esModule', {
    value: true,
  })
  var _templateLiterals = templateLiterals
  Object.keys(_templateLiterals).forEach(function (key) {
    if (key === 'default' || key === '__esModule') return
    if (key in exports && exports[key] === _templateLiterals[key]) return
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _templateLiterals[key]
      },
    })
  })
  var _expressions = expressions
  Object.keys(_expressions).forEach(function (key) {
    if (key === 'default' || key === '__esModule') return
    if (key in exports && exports[key] === _expressions[key]) return
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _expressions[key]
      },
    })
  })
  var _statements = statements$2
  Object.keys(_statements).forEach(function (key) {
    if (key === 'default' || key === '__esModule') return
    if (key in exports && exports[key] === _statements[key]) return
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _statements[key]
      },
    })
  })
  var _classes = classes$T
  Object.keys(_classes).forEach(function (key) {
    if (key === 'default' || key === '__esModule') return
    if (key in exports && exports[key] === _classes[key]) return
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _classes[key]
      },
    })
  })
  var _methods = methods
  Object.keys(_methods).forEach(function (key) {
    if (key === 'default' || key === '__esModule') return
    if (key in exports && exports[key] === _methods[key]) return
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _methods[key]
      },
    })
  })
  var _modules = modules
  Object.keys(_modules).forEach(function (key) {
    if (key === 'default' || key === '__esModule') return
    if (key in exports && exports[key] === _modules[key]) return
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _modules[key]
      },
    })
  })
  var _types = types$2
  Object.keys(_types).forEach(function (key) {
    if (key === 'default' || key === '__esModule') return
    if (key in exports && exports[key] === _types[key]) return
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _types[key]
      },
    })
  })
  var _flow = flow$2
  Object.keys(_flow).forEach(function (key) {
    if (key === 'default' || key === '__esModule') return
    if (key in exports && exports[key] === _flow[key]) return
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _flow[key]
      },
    })
  })
  var _base = base
  Object.keys(_base).forEach(function (key) {
    if (key === 'default' || key === '__esModule') return
    if (key in exports && exports[key] === _base[key]) return
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _base[key]
      },
    })
  })
  var _jsx = jsx$2
  Object.keys(_jsx).forEach(function (key) {
    if (key === 'default' || key === '__esModule') return
    if (key in exports && exports[key] === _jsx[key]) return
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _jsx[key]
      },
    })
  })
  var _typescript = typescript$2
  Object.keys(_typescript).forEach(function (key) {
    if (key === 'default' || key === '__esModule') return
    if (key in exports && exports[key] === _typescript[key]) return
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _typescript[key]
      },
    })
  })
})(generators)
Object.defineProperty(printer, '__esModule', {
  value: true,
})
printer.default = void 0
var _buffer = buffer$1
var n$13 = node
var _t$i = lib$b
var generatorFunctions = generators
const { isProgram: isProgram$1, isFile, isEmptyStatement } = _t$i
const SCIENTIFIC_NOTATION = /e/i
const ZERO_DECIMAL_INTEGER = /\.0+$/
const NON_DECIMAL_LITERAL = /^0[box]/
const PURE_ANNOTATION_RE = /^\s*[@#]__PURE__\s*$/
const { needsParens, needsWhitespaceAfter, needsWhitespaceBefore } = n$13
class Printer {
  constructor(format, map) {
    this.inForStatementInitCounter = 0
    this._printStack = []
    this._indent = 0
    this._insideAux = false
    this._parenPushNewlineState = null
    this._noLineTerminator = false
    this._printAuxAfterOnNextUserNode = false
    this._printedComments = /* @__PURE__ */ new WeakSet()
    this._endsWithInteger = false
    this._endsWithWord = false
    this.format = format
    this._buf = new _buffer.default(map)
  }
  generate(ast) {
    this.print(ast)
    this._maybeAddAuxComment()
    return this._buf.get()
  }
  indent() {
    if (this.format.compact || this.format.concise) return
    this._indent++
  }
  dedent() {
    if (this.format.compact || this.format.concise) return
    this._indent--
  }
  semicolon(force = false) {
    this._maybeAddAuxComment()
    this._append(';', !force)
  }
  rightBrace() {
    if (this.format.minified) {
      this._buf.removeLastSemicolon()
    }
    this.token('}')
  }
  space(force = false) {
    if (this.format.compact) return
    if (force) {
      this._space()
    } else if (this._buf.hasContent()) {
      const lastCp = this.getLastChar()
      if (lastCp !== 32 && lastCp !== 10) {
        this._space()
      }
    }
  }
  word(str) {
    if (this._endsWithWord || (this.endsWith(47) && str.charCodeAt(0) === 47)) {
      this._space()
    }
    this._maybeAddAuxComment()
    this._append(str)
    this._endsWithWord = true
  }
  number(str) {
    this.word(str)
    this._endsWithInteger =
      Number.isInteger(+str) &&
      !NON_DECIMAL_LITERAL.test(str) &&
      !SCIENTIFIC_NOTATION.test(str) &&
      !ZERO_DECIMAL_INTEGER.test(str) &&
      str.charCodeAt(str.length - 1) !== 46
  }
  token(str) {
    const lastChar = this.getLastChar()
    const strFirst = str.charCodeAt(0)
    if (
      (str === '--' && lastChar === 33) ||
      (strFirst === 43 && lastChar === 43) ||
      (strFirst === 45 && lastChar === 45) ||
      (strFirst === 46 && this._endsWithInteger)
    ) {
      this._space()
    }
    this._maybeAddAuxComment()
    this._append(str)
  }
  newline(i = 1) {
    if (this.format.retainLines || this.format.compact) return
    if (this.format.concise) {
      this.space()
      return
    }
    const charBeforeNewline = this.endsWithCharAndNewline()
    if (charBeforeNewline === 10) return
    if (charBeforeNewline === 123 || charBeforeNewline === 58) {
      i--
    }
    if (i <= 0) return
    for (let j = 0; j < i; j++) {
      this._newline()
    }
  }
  endsWith(char) {
    return this.getLastChar() === char
  }
  getLastChar() {
    return this._buf.getLastChar()
  }
  endsWithCharAndNewline() {
    return this._buf.endsWithCharAndNewline()
  }
  removeTrailingNewline() {
    this._buf.removeTrailingNewline()
  }
  exactSource(loc, cb) {
    this._catchUp('start', loc)
    this._buf.exactSource(loc, cb)
  }
  source(prop, loc) {
    this._catchUp(prop, loc)
    this._buf.source(prop, loc)
  }
  withSource(prop, loc, cb) {
    this._catchUp(prop, loc)
    this._buf.withSource(prop, loc, cb)
  }
  _space() {
    this._append(' ', true)
  }
  _newline() {
    this._append('\n', true)
  }
  _append(str, queue = false) {
    this._maybeAddParen(str)
    this._maybeIndent(str)
    if (queue) this._buf.queue(str)
    else this._buf.append(str)
    this._endsWithWord = false
    this._endsWithInteger = false
  }
  _maybeIndent(str) {
    if (this._indent && this.endsWith(10) && str.charCodeAt(0) !== 10) {
      this._buf.queueIndentation(this._getIndent())
    }
  }
  _maybeAddParen(str) {
    const parenPushNewlineState = this._parenPushNewlineState
    if (!parenPushNewlineState) return
    let i
    for (i = 0; i < str.length && str[i] === ' '; i++) continue
    if (i === str.length) {
      return
    }
    const cha = str[i]
    if (cha !== '\n') {
      if (cha !== '/' || i + 1 === str.length) {
        this._parenPushNewlineState = null
        return
      }
      const chaPost = str[i + 1]
      if (chaPost === '*') {
        if (PURE_ANNOTATION_RE.test(str.slice(i + 2, str.length - 2))) {
          return
        }
      } else if (chaPost !== '/') {
        this._parenPushNewlineState = null
        return
      }
    }
    this.token('(')
    this.indent()
    parenPushNewlineState.printed = true
  }
  _catchUp(prop, loc) {
    if (!this.format.retainLines) return
    const pos = loc ? loc[prop] : null
    if ((pos == null ? void 0 : pos.line) != null) {
      const count = pos.line - this._buf.getCurrentLine()
      for (let i = 0; i < count; i++) {
        this._newline()
      }
    }
  }
  _getIndent() {
    return this.format.indent.style.repeat(this._indent)
  }
  startTerminatorless(isLabel = false) {
    if (isLabel) {
      this._noLineTerminator = true
      return null
    } else {
      return (this._parenPushNewlineState = {
        printed: false,
      })
    }
  }
  endTerminatorless(state) {
    this._noLineTerminator = false
    if (state != null && state.printed) {
      this.dedent()
      this.newline()
      this.token(')')
    }
  }
  print(node2, parent) {
    if (!node2) return
    const oldConcise = this.format.concise
    if (node2._compact) {
      this.format.concise = true
    }
    const printMethod = this[node2.type]
    if (!printMethod) {
      throw new ReferenceError(
        `unknown node of type ${JSON.stringify(node2.type)} with constructor ${JSON.stringify(
          node2 == null ? void 0 : node2.constructor.name
        )}`
      )
    }
    this._printStack.push(node2)
    const oldInAux = this._insideAux
    this._insideAux = !node2.loc
    this._maybeAddAuxComment(this._insideAux && !oldInAux)
    let shouldPrintParens = needsParens(node2, parent, this._printStack)
    if (
      this.format.retainFunctionParens &&
      node2.type === 'FunctionExpression' &&
      node2.extra &&
      node2.extra.parenthesized
    ) {
      shouldPrintParens = true
    }
    if (shouldPrintParens) this.token('(')
    this._printLeadingComments(node2)
    const loc = isProgram$1(node2) || isFile(node2) ? null : node2.loc
    this.withSource('start', loc, () => {
      printMethod.call(this, node2, parent)
    })
    this._printTrailingComments(node2)
    if (shouldPrintParens) this.token(')')
    this._printStack.pop()
    this.format.concise = oldConcise
    this._insideAux = oldInAux
  }
  _maybeAddAuxComment(enteredPositionlessNode) {
    if (enteredPositionlessNode) this._printAuxBeforeComment()
    if (!this._insideAux) this._printAuxAfterComment()
  }
  _printAuxBeforeComment() {
    if (this._printAuxAfterOnNextUserNode) return
    this._printAuxAfterOnNextUserNode = true
    const comment = this.format.auxiliaryCommentBefore
    if (comment) {
      this._printComment({
        type: 'CommentBlock',
        value: comment,
      })
    }
  }
  _printAuxAfterComment() {
    if (!this._printAuxAfterOnNextUserNode) return
    this._printAuxAfterOnNextUserNode = false
    const comment = this.format.auxiliaryCommentAfter
    if (comment) {
      this._printComment({
        type: 'CommentBlock',
        value: comment,
      })
    }
  }
  getPossibleRaw(node2) {
    const extra = node2.extra
    if (extra && extra.raw != null && extra.rawValue != null && node2.value === extra.rawValue) {
      return extra.raw
    }
  }
  printJoin(nodes2, parent, opts = {}) {
    if (!(nodes2 != null && nodes2.length)) return
    if (opts.indent) this.indent()
    const newlineOpts = {
      addNewlines: opts.addNewlines,
    }
    for (let i = 0; i < nodes2.length; i++) {
      const node2 = nodes2[i]
      if (!node2) continue
      if (opts.statement) this._printNewline(true, node2, parent, newlineOpts)
      this.print(node2, parent)
      if (opts.iterator) {
        opts.iterator(node2, i)
      }
      if (opts.separator && i < nodes2.length - 1) {
        opts.separator.call(this)
      }
      if (opts.statement) this._printNewline(false, node2, parent, newlineOpts)
    }
    if (opts.indent) this.dedent()
  }
  printAndIndentOnComments(node2, parent) {
    const indent = node2.leadingComments && node2.leadingComments.length > 0
    if (indent) this.indent()
    this.print(node2, parent)
    if (indent) this.dedent()
  }
  printBlock(parent) {
    const node2 = parent.body
    if (!isEmptyStatement(node2)) {
      this.space()
    }
    this.print(node2, parent)
  }
  _printTrailingComments(node2) {
    this._printComments(this._getComments(false, node2))
  }
  _printLeadingComments(node2) {
    this._printComments(this._getComments(true, node2), true)
  }
  printInnerComments(node2, indent = true) {
    var _node$innerComments
    if (!((_node$innerComments = node2.innerComments) != null && _node$innerComments.length)) return
    if (indent) this.indent()
    this._printComments(node2.innerComments)
    if (indent) this.dedent()
  }
  printSequence(nodes2, parent, opts = {}) {
    opts.statement = true
    return this.printJoin(nodes2, parent, opts)
  }
  printList(items, parent, opts = {}) {
    if (opts.separator == null) {
      opts.separator = commaSeparator
    }
    return this.printJoin(items, parent, opts)
  }
  _printNewline(leading, node2, parent, opts) {
    if (this.format.retainLines || this.format.compact) return
    if (this.format.concise) {
      this.space()
      return
    }
    let lines = 0
    if (this._buf.hasContent()) {
      if (!leading) lines++
      if (opts.addNewlines) lines += opts.addNewlines(leading, node2) || 0
      const needs = leading ? needsWhitespaceBefore : needsWhitespaceAfter
      if (needs(node2, parent)) lines++
    }
    this.newline(Math.min(2, lines))
  }
  _getComments(leading, node2) {
    return (node2 && (leading ? node2.leadingComments : node2.trailingComments)) || []
  }
  _printComment(comment, skipNewLines) {
    if (!this.format.shouldPrintComment(comment.value)) return
    if (comment.ignore) return
    if (this._printedComments.has(comment)) return
    this._printedComments.add(comment)
    const isBlockComment = comment.type === 'CommentBlock'
    const printNewLines = isBlockComment && !skipNewLines && !this._noLineTerminator
    if (printNewLines && this._buf.hasContent()) this.newline(1)
    const lastCharCode = this.getLastChar()
    if (lastCharCode !== 91 && lastCharCode !== 123) {
      this.space()
    }
    let val =
      !isBlockComment && !this._noLineTerminator
        ? `//${comment.value}
`
        : `/*${comment.value}*/`
    if (isBlockComment && this.format.indent.adjustMultilineComment) {
      var _comment$loc
      const offset = (_comment$loc = comment.loc) == null ? void 0 : _comment$loc.start.column
      if (offset) {
        const newlineRegex = new RegExp('\\n\\s{1,' + offset + '}', 'g')
        val = val.replace(newlineRegex, '\n')
      }
      const indentSize = Math.max(this._getIndent().length, this.format.retainLines ? 0 : this._buf.getCurrentColumn())
      val = val.replace(
        /\n(?!$)/g,
        `
${' '.repeat(indentSize)}`
      )
    }
    if (this.endsWith(47)) this._space()
    this.withSource('start', comment.loc, () => {
      this._append(val)
    })
    if (printNewLines) this.newline(1)
  }
  _printComments(comments2, inlinePureAnnotation) {
    if (!(comments2 != null && comments2.length)) return
    if (inlinePureAnnotation && comments2.length === 1 && PURE_ANNOTATION_RE.test(comments2[0].value)) {
      this._printComment(comments2[0], this._buf.hasContent() && !this.endsWith(10))
    } else {
      for (const comment of comments2) {
        this._printComment(comment)
      }
    }
  }
  printAssertions(node2) {
    var _node$assertions
    if ((_node$assertions = node2.assertions) != null && _node$assertions.length) {
      this.space()
      this.word('assert')
      this.space()
      this.token('{')
      this.space()
      this.printList(node2.assertions, node2)
      this.space()
      this.token('}')
    }
  }
}
Object.assign(Printer.prototype, generatorFunctions)
{
  Printer.prototype.Noop = function Noop() {}
}
var _default$6 = Printer
printer.default = _default$6
function commaSeparator() {
  this.token(',')
  this.space()
}
Object.defineProperty(lib$7, '__esModule', {
  value: true,
})
lib$7.CodeGenerator = void 0
var _default$5 = (lib$7.default = generate)
var _sourceMap = sourceMap
var _printer = printer
class Generator extends _printer.default {
  constructor(ast, opts = {}, code2) {
    const format = normalizeOptions(code2, opts)
    const map = opts.sourceMaps ? new _sourceMap.default(opts, code2) : null
    super(format, map)
    this.ast = void 0
    this.ast = ast
  }
  generate() {
    return super.generate(this.ast)
  }
}
function normalizeOptions(code2, opts) {
  const format = {
    auxiliaryCommentBefore: opts.auxiliaryCommentBefore,
    auxiliaryCommentAfter: opts.auxiliaryCommentAfter,
    shouldPrintComment: opts.shouldPrintComment,
    retainLines: opts.retainLines,
    retainFunctionParens: opts.retainFunctionParens,
    comments: opts.comments == null || opts.comments,
    compact: opts.compact,
    minified: opts.minified,
    concise: opts.concise,
    indent: {
      adjustMultilineComment: true,
      style: '  ',
      base: 0,
    },
    decoratorsBeforeExport: !!opts.decoratorsBeforeExport,
    jsescOption: Object.assign(
      {
        quotes: 'double',
        wrap: true,
        minimal: false,
      },
      opts.jsescOption
    ),
    recordAndTupleSyntaxType: opts.recordAndTupleSyntaxType,
    topicToken: opts.topicToken,
  }
  {
    format.jsonCompatibleStrings = opts.jsonCompatibleStrings
  }
  if (format.minified) {
    format.compact = true
    format.shouldPrintComment = format.shouldPrintComment || (() => format.comments)
  } else {
    format.shouldPrintComment =
      format.shouldPrintComment ||
      ((value) => format.comments || value.indexOf('@license') >= 0 || value.indexOf('@preserve') >= 0)
  }
  if (format.compact === 'auto') {
    format.compact = code2.length > 5e5
    if (format.compact) {
      console.error(
        `[BABEL] Note: The code generator has deoptimised the styling of ${
          opts.filename
        } as it exceeds the max of ${'500KB'}.`
      )
    }
  }
  if (format.compact) {
    format.indent.adjustMultilineComment = false
  }
  return format
}
class CodeGenerator {
  constructor(ast, opts, code2) {
    this._generator = void 0
    this._generator = new Generator(ast, opts, code2)
  }
  generate() {
    return this._generator.generate()
  }
}
lib$7.CodeGenerator = CodeGenerator
function generate(ast, opts, code2) {
  const gen = new Generator(ast, opts, code2)
  return gen.generate()
}
var ancestry = {}
Object.defineProperty(ancestry, '__esModule', {
  value: true,
})
ancestry.find = find
ancestry.findParent = findParent
ancestry.getAncestry = getAncestry
ancestry.getDeepestCommonAncestorFrom = getDeepestCommonAncestorFrom
ancestry.getEarliestCommonAncestorFrom = getEarliestCommonAncestorFrom
ancestry.getFunctionParent = getFunctionParent
ancestry.getStatementParent = getStatementParent
ancestry.inType = inType
ancestry.isAncestor = isAncestor
ancestry.isDescendant = isDescendant
var _t$h = lib$b
const { VISITOR_KEYS: VISITOR_KEYS$3 } = _t$h
function findParent(callback) {
  let path2 = this
  while ((path2 = path2.parentPath)) {
    if (callback(path2)) return path2
  }
  return null
}
function find(callback) {
  let path2 = this
  do {
    if (callback(path2)) return path2
  } while ((path2 = path2.parentPath))
  return null
}
function getFunctionParent() {
  return this.findParent((p) => p.isFunction())
}
function getStatementParent() {
  let path2 = this
  do {
    if (!path2.parentPath || (Array.isArray(path2.container) && path2.isStatement())) {
      break
    } else {
      path2 = path2.parentPath
    }
  } while (path2)
  if (path2 && (path2.isProgram() || path2.isFile())) {
    throw new Error("File/Program node, we can't possibly find a statement parent to this")
  }
  return path2
}
function getEarliestCommonAncestorFrom(paths) {
  return this.getDeepestCommonAncestorFrom(paths, function (deepest, i, ancestries) {
    let earliest
    const keys = VISITOR_KEYS$3[deepest.type]
    for (const ancestry2 of ancestries) {
      const path2 = ancestry2[i + 1]
      if (!earliest) {
        earliest = path2
        continue
      }
      if (path2.listKey && earliest.listKey === path2.listKey) {
        if (path2.key < earliest.key) {
          earliest = path2
          continue
        }
      }
      const earliestKeyIndex = keys.indexOf(earliest.parentKey)
      const currentKeyIndex = keys.indexOf(path2.parentKey)
      if (earliestKeyIndex > currentKeyIndex) {
        earliest = path2
      }
    }
    return earliest
  })
}
function getDeepestCommonAncestorFrom(paths, filter) {
  if (!paths.length) {
    return this
  }
  if (paths.length === 1) {
    return paths[0]
  }
  let minDepth = Infinity
  let lastCommonIndex, lastCommon
  const ancestries = paths.map((path2) => {
    const ancestry2 = []
    do {
      ancestry2.unshift(path2)
    } while ((path2 = path2.parentPath) && path2 !== this)
    if (ancestry2.length < minDepth) {
      minDepth = ancestry2.length
    }
    return ancestry2
  })
  const first = ancestries[0]
  depthLoop: for (let i = 0; i < minDepth; i++) {
    const shouldMatch = first[i]
    for (const ancestry2 of ancestries) {
      if (ancestry2[i] !== shouldMatch) {
        break depthLoop
      }
    }
    lastCommonIndex = i
    lastCommon = shouldMatch
  }
  if (lastCommon) {
    if (filter) {
      return filter(lastCommon, lastCommonIndex, ancestries)
    } else {
      return lastCommon
    }
  } else {
    throw new Error("Couldn't find intersection")
  }
}
function getAncestry() {
  let path2 = this
  const paths = []
  do {
    paths.push(path2)
  } while ((path2 = path2.parentPath))
  return paths
}
function isAncestor(maybeDescendant) {
  return maybeDescendant.isDescendant(this)
}
function isDescendant(maybeAncestor) {
  return !!this.findParent((parent) => parent === maybeAncestor)
}
function inType(...candidateTypes) {
  let path2 = this
  while (path2) {
    for (const type of candidateTypes) {
      if (path2.node.type === type) return true
    }
    path2 = path2.parentPath
  }
  return false
}
var inference = {}
var inferers$1 = {}
var infererReference = {}
Object.defineProperty(infererReference, '__esModule', {
  value: true,
})
infererReference.default = _default$4
var _t$g = lib$b
const {
  BOOLEAN_NUMBER_BINARY_OPERATORS,
  createFlowUnionType,
  createTSUnionType,
  createTypeAnnotationBasedOnTypeof,
  createUnionTypeAnnotation,
  isTSTypeAnnotation,
  numberTypeAnnotation,
  voidTypeAnnotation: voidTypeAnnotation$1,
} = _t$g
function _default$4(node2) {
  if (!this.isReferenced()) return
  const binding2 = this.scope.getBinding(node2.name)
  if (binding2) {
    if (binding2.identifier.typeAnnotation) {
      return binding2.identifier.typeAnnotation
    } else {
      return getTypeAnnotationBindingConstantViolations(binding2, this, node2.name)
    }
  }
  if (node2.name === 'undefined') {
    return voidTypeAnnotation$1()
  } else if (node2.name === 'NaN' || node2.name === 'Infinity') {
    return numberTypeAnnotation()
  } else if (node2.name === 'arguments');
}
function getTypeAnnotationBindingConstantViolations(binding2, path2, name) {
  const types2 = []
  const functionConstantViolations = []
  let constantViolations = getConstantViolationsBefore(binding2, path2, functionConstantViolations)
  const testType = getConditionalAnnotation(binding2, path2, name)
  if (testType) {
    const testConstantViolations = getConstantViolationsBefore(binding2, testType.ifStatement)
    constantViolations = constantViolations.filter((path3) => testConstantViolations.indexOf(path3) < 0)
    types2.push(testType.typeAnnotation)
  }
  if (constantViolations.length) {
    constantViolations.push(...functionConstantViolations)
    for (const violation of constantViolations) {
      types2.push(violation.getTypeAnnotation())
    }
  }
  if (!types2.length) {
    return
  }
  if (isTSTypeAnnotation(types2[0]) && createTSUnionType) {
    return createTSUnionType(types2)
  }
  if (createFlowUnionType) {
    return createFlowUnionType(types2)
  }
  return createUnionTypeAnnotation(types2)
}
function getConstantViolationsBefore(binding2, path2, functions) {
  const violations = binding2.constantViolations.slice()
  violations.unshift(binding2.path)
  return violations.filter((violation) => {
    violation = violation.resolve()
    const status = violation._guessExecutionStatusRelativeTo(path2)
    if (functions && status === 'unknown') functions.push(violation)
    return status === 'before'
  })
}
function inferAnnotationFromBinaryExpression(name, path2) {
  const operator = path2.node.operator
  const right = path2.get('right').resolve()
  const left = path2.get('left').resolve()
  let target
  if (
    left.isIdentifier({
      name,
    })
  ) {
    target = right
  } else if (
    right.isIdentifier({
      name,
    })
  ) {
    target = left
  }
  if (target) {
    if (operator === '===') {
      return target.getTypeAnnotation()
    }
    if (BOOLEAN_NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {
      return numberTypeAnnotation()
    }
    return
  }
  if (operator !== '===' && operator !== '==') return
  let typeofPath
  let typePath
  if (
    left.isUnaryExpression({
      operator: 'typeof',
    })
  ) {
    typeofPath = left
    typePath = right
  } else if (
    right.isUnaryExpression({
      operator: 'typeof',
    })
  ) {
    typeofPath = right
    typePath = left
  }
  if (!typeofPath) return
  if (
    !typeofPath.get('argument').isIdentifier({
      name,
    })
  )
    return
  typePath = typePath.resolve()
  if (!typePath.isLiteral()) return
  const typeValue = typePath.node.value
  if (typeof typeValue !== 'string') return
  return createTypeAnnotationBasedOnTypeof(typeValue)
}
function getParentConditionalPath(binding2, path2, name) {
  let parentPath
  while ((parentPath = path2.parentPath)) {
    if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {
      if (path2.key === 'test') {
        return
      }
      return parentPath
    }
    if (parentPath.isFunction()) {
      if (parentPath.parentPath.scope.getBinding(name) !== binding2) return
    }
    path2 = parentPath
  }
}
function getConditionalAnnotation(binding2, path2, name) {
  const ifStatement2 = getParentConditionalPath(binding2, path2, name)
  if (!ifStatement2) return
  const test = ifStatement2.get('test')
  const paths = [test]
  const types2 = []
  for (let i = 0; i < paths.length; i++) {
    const path3 = paths[i]
    if (path3.isLogicalExpression()) {
      if (path3.node.operator === '&&') {
        paths.push(path3.get('left'))
        paths.push(path3.get('right'))
      }
    } else if (path3.isBinaryExpression()) {
      const type = inferAnnotationFromBinaryExpression(name, path3)
      if (type) types2.push(type)
    }
  }
  if (types2.length) {
    if (isTSTypeAnnotation(types2[0]) && createTSUnionType) {
      return {
        typeAnnotation: createTSUnionType(types2),
        ifStatement: ifStatement2,
      }
    }
    if (createFlowUnionType) {
      return {
        typeAnnotation: createFlowUnionType(types2),
        ifStatement: ifStatement2,
      }
    }
    return {
      typeAnnotation: createUnionTypeAnnotation(types2),
      ifStatement: ifStatement2,
    }
  }
  return getConditionalAnnotation(ifStatement2, name)
}
;(function (exports) {
  Object.defineProperty(exports, '__esModule', {
    value: true,
  })
  exports.ArrayExpression = ArrayExpression2
  exports.AssignmentExpression = AssignmentExpression2
  exports.BinaryExpression = BinaryExpression2
  exports.BooleanLiteral = BooleanLiteral2
  exports.CallExpression = CallExpression2
  exports.ConditionalExpression = ConditionalExpression2
  exports.ClassDeclaration =
    exports.ClassExpression =
    exports.FunctionDeclaration =
    exports.ArrowFunctionExpression =
    exports.FunctionExpression =
      Func
  Object.defineProperty(exports, 'Identifier', {
    enumerable: true,
    get: function () {
      return _infererReference.default
    },
  })
  exports.LogicalExpression = LogicalExpression2
  exports.NewExpression = NewExpression2
  exports.NullLiteral = NullLiteral2
  exports.NumericLiteral = NumericLiteral2
  exports.ObjectExpression = ObjectExpression2
  exports.ParenthesizedExpression = ParenthesizedExpression2
  exports.RegExpLiteral = RegExpLiteral2
  exports.RestElement = RestElement2
  exports.SequenceExpression = SequenceExpression2
  exports.StringLiteral = StringLiteral2
  exports.TaggedTemplateExpression = TaggedTemplateExpression2
  exports.TemplateLiteral = TemplateLiteral2
  exports.TypeCastExpression = TypeCastExpression
  exports.UnaryExpression = UnaryExpression2
  exports.UpdateExpression = UpdateExpression2
  exports.VariableDeclarator = VariableDeclarator2
  var _t3 = lib$b
  var _infererReference = infererReference
  const {
    BOOLEAN_BINARY_OPERATORS: BOOLEAN_BINARY_OPERATORS2,
    BOOLEAN_UNARY_OPERATORS: BOOLEAN_UNARY_OPERATORS2,
    NUMBER_BINARY_OPERATORS: NUMBER_BINARY_OPERATORS2,
    NUMBER_UNARY_OPERATORS: NUMBER_UNARY_OPERATORS2,
    STRING_UNARY_OPERATORS: STRING_UNARY_OPERATORS2,
    anyTypeAnnotation: anyTypeAnnotation2,
    arrayTypeAnnotation: arrayTypeAnnotation2,
    booleanTypeAnnotation: booleanTypeAnnotation2,
    buildMatchMemberExpression: buildMatchMemberExpression2,
    createFlowUnionType: createFlowUnionType2,
    createTSUnionType: createTSUnionType2,
    createUnionTypeAnnotation: createUnionTypeAnnotation2,
    genericTypeAnnotation: genericTypeAnnotation2,
    identifier: identifier2,
    isTSTypeAnnotation: isTSTypeAnnotation2,
    nullLiteralTypeAnnotation: nullLiteralTypeAnnotation2,
    numberTypeAnnotation: numberTypeAnnotation2,
    stringTypeAnnotation: stringTypeAnnotation2,
    tupleTypeAnnotation: tupleTypeAnnotation2,
    unionTypeAnnotation: unionTypeAnnotation2,
    voidTypeAnnotation: voidTypeAnnotation2,
  } = _t3
  function VariableDeclarator2() {
    var _type
    const id = this.get('id')
    if (!id.isIdentifier()) return
    const init = this.get('init')
    let type = init.getTypeAnnotation()
    if (((_type = type) == null ? void 0 : _type.type) === 'AnyTypeAnnotation') {
      if (
        init.isCallExpression() &&
        init.get('callee').isIdentifier({
          name: 'Array',
        }) &&
        !init.scope.hasBinding('Array', true)
      ) {
        type = ArrayExpression2()
      }
    }
    return type
  }
  function TypeCastExpression(node2) {
    return node2.typeAnnotation
  }
  TypeCastExpression.validParent = true
  function NewExpression2(node2) {
    if (this.get('callee').isIdentifier()) {
      return genericTypeAnnotation2(node2.callee)
    }
  }
  function TemplateLiteral2() {
    return stringTypeAnnotation2()
  }
  function UnaryExpression2(node2) {
    const operator = node2.operator
    if (operator === 'void') {
      return voidTypeAnnotation2()
    } else if (NUMBER_UNARY_OPERATORS2.indexOf(operator) >= 0) {
      return numberTypeAnnotation2()
    } else if (STRING_UNARY_OPERATORS2.indexOf(operator) >= 0) {
      return stringTypeAnnotation2()
    } else if (BOOLEAN_UNARY_OPERATORS2.indexOf(operator) >= 0) {
      return booleanTypeAnnotation2()
    }
  }
  function BinaryExpression2(node2) {
    const operator = node2.operator
    if (NUMBER_BINARY_OPERATORS2.indexOf(operator) >= 0) {
      return numberTypeAnnotation2()
    } else if (BOOLEAN_BINARY_OPERATORS2.indexOf(operator) >= 0) {
      return booleanTypeAnnotation2()
    } else if (operator === '+') {
      const right = this.get('right')
      const left = this.get('left')
      if (left.isBaseType('number') && right.isBaseType('number')) {
        return numberTypeAnnotation2()
      } else if (left.isBaseType('string') || right.isBaseType('string')) {
        return stringTypeAnnotation2()
      }
      return unionTypeAnnotation2([stringTypeAnnotation2(), numberTypeAnnotation2()])
    }
  }
  function LogicalExpression2() {
    const argumentTypes = [this.get('left').getTypeAnnotation(), this.get('right').getTypeAnnotation()]
    if (isTSTypeAnnotation2(argumentTypes[0]) && createTSUnionType2) {
      return createTSUnionType2(argumentTypes)
    }
    if (createFlowUnionType2) {
      return createFlowUnionType2(argumentTypes)
    }
    return createUnionTypeAnnotation2(argumentTypes)
  }
  function ConditionalExpression2() {
    const argumentTypes = [this.get('consequent').getTypeAnnotation(), this.get('alternate').getTypeAnnotation()]
    if (isTSTypeAnnotation2(argumentTypes[0]) && createTSUnionType2) {
      return createTSUnionType2(argumentTypes)
    }
    if (createFlowUnionType2) {
      return createFlowUnionType2(argumentTypes)
    }
    return createUnionTypeAnnotation2(argumentTypes)
  }
  function SequenceExpression2() {
    return this.get('expressions').pop().getTypeAnnotation()
  }
  function ParenthesizedExpression2() {
    return this.get('expression').getTypeAnnotation()
  }
  function AssignmentExpression2() {
    return this.get('right').getTypeAnnotation()
  }
  function UpdateExpression2(node2) {
    const operator = node2.operator
    if (operator === '++' || operator === '--') {
      return numberTypeAnnotation2()
    }
  }
  function StringLiteral2() {
    return stringTypeAnnotation2()
  }
  function NumericLiteral2() {
    return numberTypeAnnotation2()
  }
  function BooleanLiteral2() {
    return booleanTypeAnnotation2()
  }
  function NullLiteral2() {
    return nullLiteralTypeAnnotation2()
  }
  function RegExpLiteral2() {
    return genericTypeAnnotation2(identifier2('RegExp'))
  }
  function ObjectExpression2() {
    return genericTypeAnnotation2(identifier2('Object'))
  }
  function ArrayExpression2() {
    return genericTypeAnnotation2(identifier2('Array'))
  }
  function RestElement2() {
    return ArrayExpression2()
  }
  RestElement2.validParent = true
  function Func() {
    return genericTypeAnnotation2(identifier2('Function'))
  }
  const isArrayFrom = buildMatchMemberExpression2('Array.from')
  const isObjectKeys = buildMatchMemberExpression2('Object.keys')
  const isObjectValues = buildMatchMemberExpression2('Object.values')
  const isObjectEntries = buildMatchMemberExpression2('Object.entries')
  function CallExpression2() {
    const { callee } = this.node
    if (isObjectKeys(callee)) {
      return arrayTypeAnnotation2(stringTypeAnnotation2())
    } else if (isArrayFrom(callee) || isObjectValues(callee)) {
      return arrayTypeAnnotation2(anyTypeAnnotation2())
    } else if (isObjectEntries(callee)) {
      return arrayTypeAnnotation2(tupleTypeAnnotation2([stringTypeAnnotation2(), anyTypeAnnotation2()]))
    }
    return resolveCall(this.get('callee'))
  }
  function TaggedTemplateExpression2() {
    return resolveCall(this.get('tag'))
  }
  function resolveCall(callee) {
    callee = callee.resolve()
    if (callee.isFunction()) {
      if (callee.is('async')) {
        if (callee.is('generator')) {
          return genericTypeAnnotation2(identifier2('AsyncIterator'))
        } else {
          return genericTypeAnnotation2(identifier2('Promise'))
        }
      } else {
        if (callee.node.returnType) {
          return callee.node.returnType
        }
      }
    }
  }
})(inferers$1)
Object.defineProperty(inference, '__esModule', {
  value: true,
})
inference._getTypeAnnotation = _getTypeAnnotation
inference.baseTypeStrictlyMatches = baseTypeStrictlyMatches
inference.couldBeBaseType = couldBeBaseType
inference.getTypeAnnotation = getTypeAnnotation
inference.isBaseType = isBaseType
inference.isGenericType = isGenericType
var inferers = inferers$1
var _t$f = lib$b
const {
  anyTypeAnnotation,
  isAnyTypeAnnotation,
  isBooleanTypeAnnotation,
  isEmptyTypeAnnotation,
  isFlowBaseAnnotation,
  isGenericTypeAnnotation,
  isIdentifier: isIdentifier$5,
  isMixedTypeAnnotation,
  isNumberTypeAnnotation,
  isStringTypeAnnotation,
  isTypeAnnotation,
  isUnionTypeAnnotation,
  isVoidTypeAnnotation,
  stringTypeAnnotation,
  voidTypeAnnotation,
} = _t$f
function getTypeAnnotation() {
  let type = this.getData('typeAnnotation')
  if (type != null) {
    return type
  }
  type = this._getTypeAnnotation() || anyTypeAnnotation()
  if (isTypeAnnotation(type)) type = type.typeAnnotation
  this.setData('typeAnnotation', type)
  return type
}
const typeAnnotationInferringNodes = /* @__PURE__ */ new WeakSet()
function _getTypeAnnotation() {
  const node2 = this.node
  if (!node2) {
    if (this.key === 'init' && this.parentPath.isVariableDeclarator()) {
      const declar = this.parentPath.parentPath
      const declarParent = declar.parentPath
      if (declar.key === 'left' && declarParent.isForInStatement()) {
        return stringTypeAnnotation()
      }
      if (declar.key === 'left' && declarParent.isForOfStatement()) {
        return anyTypeAnnotation()
      }
      return voidTypeAnnotation()
    } else {
      return
    }
  }
  if (node2.typeAnnotation) {
    return node2.typeAnnotation
  }
  if (typeAnnotationInferringNodes.has(node2)) {
    return
  }
  typeAnnotationInferringNodes.add(node2)
  try {
    var _inferer
    let inferer = inferers[node2.type]
    if (inferer) {
      return inferer.call(this, node2)
    }
    inferer = inferers[this.parentPath.type]
    if ((_inferer = inferer) != null && _inferer.validParent) {
      return this.parentPath.getTypeAnnotation()
    }
  } finally {
    typeAnnotationInferringNodes.delete(node2)
  }
}
function isBaseType(baseName, soft) {
  return _isBaseType(baseName, this.getTypeAnnotation(), soft)
}
function _isBaseType(baseName, type, soft) {
  if (baseName === 'string') {
    return isStringTypeAnnotation(type)
  } else if (baseName === 'number') {
    return isNumberTypeAnnotation(type)
  } else if (baseName === 'boolean') {
    return isBooleanTypeAnnotation(type)
  } else if (baseName === 'any') {
    return isAnyTypeAnnotation(type)
  } else if (baseName === 'mixed') {
    return isMixedTypeAnnotation(type)
  } else if (baseName === 'empty') {
    return isEmptyTypeAnnotation(type)
  } else if (baseName === 'void') {
    return isVoidTypeAnnotation(type)
  } else {
    if (soft) {
      return false
    } else {
      throw new Error(`Unknown base type ${baseName}`)
    }
  }
}
function couldBeBaseType(name) {
  const type = this.getTypeAnnotation()
  if (isAnyTypeAnnotation(type)) return true
  if (isUnionTypeAnnotation(type)) {
    for (const type2 of type.types) {
      if (isAnyTypeAnnotation(type2) || _isBaseType(name, type2, true)) {
        return true
      }
    }
    return false
  } else {
    return _isBaseType(name, type, true)
  }
}
function baseTypeStrictlyMatches(rightArg) {
  const left = this.getTypeAnnotation()
  const right = rightArg.getTypeAnnotation()
  if (!isAnyTypeAnnotation(left) && isFlowBaseAnnotation(left)) {
    return right.type === left.type
  }
  return false
}
function isGenericType(genericName) {
  const type = this.getTypeAnnotation()
  return (
    isGenericTypeAnnotation(type) &&
    isIdentifier$5(type.id, {
      name: genericName,
    })
  )
}
var replacement = {}
var lib$6 = {}
var lib$5 = {}
var jsTokens = {}
Object.defineProperty(jsTokens, '__esModule', {
  value: true,
})
jsTokens.default =
  /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g
jsTokens.matchToToken = function (match) {
  var token = { type: 'invalid', value: match[0], closed: void 0 }
  if (match[1]) (token.type = 'string'), (token.closed = !!(match[3] || match[4]))
  else if (match[5]) token.type = 'comment'
  else if (match[6]) (token.type = 'comment'), (token.closed = !!match[7])
  else if (match[8]) token.type = 'regex'
  else if (match[9]) token.type = 'number'
  else if (match[10]) token.type = 'name'
  else if (match[11]) token.type = 'punctuator'
  else if (match[12]) token.type = 'whitespace'
  return token
}
var chalk = { exports: {} }
var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g
var escapeStringRegexp = function (str) {
  if (typeof str !== 'string') {
    throw new TypeError('Expected a string')
  }
  return str.replace(matchOperatorsRe, '\\$&')
}
var ansiStyles = { exports: {} }
var conversions$2 = { exports: {} }
var colorName = {
  aliceblue: [240, 248, 255],
  antiquewhite: [250, 235, 215],
  aqua: [0, 255, 255],
  aquamarine: [127, 255, 212],
  azure: [240, 255, 255],
  beige: [245, 245, 220],
  bisque: [255, 228, 196],
  black: [0, 0, 0],
  blanchedalmond: [255, 235, 205],
  blue: [0, 0, 255],
  blueviolet: [138, 43, 226],
  brown: [165, 42, 42],
  burlywood: [222, 184, 135],
  cadetblue: [95, 158, 160],
  chartreuse: [127, 255, 0],
  chocolate: [210, 105, 30],
  coral: [255, 127, 80],
  cornflowerblue: [100, 149, 237],
  cornsilk: [255, 248, 220],
  crimson: [220, 20, 60],
  cyan: [0, 255, 255],
  darkblue: [0, 0, 139],
  darkcyan: [0, 139, 139],
  darkgoldenrod: [184, 134, 11],
  darkgray: [169, 169, 169],
  darkgreen: [0, 100, 0],
  darkgrey: [169, 169, 169],
  darkkhaki: [189, 183, 107],
  darkmagenta: [139, 0, 139],
  darkolivegreen: [85, 107, 47],
  darkorange: [255, 140, 0],
  darkorchid: [153, 50, 204],
  darkred: [139, 0, 0],
  darksalmon: [233, 150, 122],
  darkseagreen: [143, 188, 143],
  darkslateblue: [72, 61, 139],
  darkslategray: [47, 79, 79],
  darkslategrey: [47, 79, 79],
  darkturquoise: [0, 206, 209],
  darkviolet: [148, 0, 211],
  deeppink: [255, 20, 147],
  deepskyblue: [0, 191, 255],
  dimgray: [105, 105, 105],
  dimgrey: [105, 105, 105],
  dodgerblue: [30, 144, 255],
  firebrick: [178, 34, 34],
  floralwhite: [255, 250, 240],
  forestgreen: [34, 139, 34],
  fuchsia: [255, 0, 255],
  gainsboro: [220, 220, 220],
  ghostwhite: [248, 248, 255],
  gold: [255, 215, 0],
  goldenrod: [218, 165, 32],
  gray: [128, 128, 128],
  green: [0, 128, 0],
  greenyellow: [173, 255, 47],
  grey: [128, 128, 128],
  honeydew: [240, 255, 240],
  hotpink: [255, 105, 180],
  indianred: [205, 92, 92],
  indigo: [75, 0, 130],
  ivory: [255, 255, 240],
  khaki: [240, 230, 140],
  lavender: [230, 230, 250],
  lavenderblush: [255, 240, 245],
  lawngreen: [124, 252, 0],
  lemonchiffon: [255, 250, 205],
  lightblue: [173, 216, 230],
  lightcoral: [240, 128, 128],
  lightcyan: [224, 255, 255],
  lightgoldenrodyellow: [250, 250, 210],
  lightgray: [211, 211, 211],
  lightgreen: [144, 238, 144],
  lightgrey: [211, 211, 211],
  lightpink: [255, 182, 193],
  lightsalmon: [255, 160, 122],
  lightseagreen: [32, 178, 170],
  lightskyblue: [135, 206, 250],
  lightslategray: [119, 136, 153],
  lightslategrey: [119, 136, 153],
  lightsteelblue: [176, 196, 222],
  lightyellow: [255, 255, 224],
  lime: [0, 255, 0],
  limegreen: [50, 205, 50],
  linen: [250, 240, 230],
  magenta: [255, 0, 255],
  maroon: [128, 0, 0],
  mediumaquamarine: [102, 205, 170],
  mediumblue: [0, 0, 205],
  mediumorchid: [186, 85, 211],
  mediumpurple: [147, 112, 219],
  mediumseagreen: [60, 179, 113],
  mediumslateblue: [123, 104, 238],
  mediumspringgreen: [0, 250, 154],
  mediumturquoise: [72, 209, 204],
  mediumvioletred: [199, 21, 133],
  midnightblue: [25, 25, 112],
  mintcream: [245, 255, 250],
  mistyrose: [255, 228, 225],
  moccasin: [255, 228, 181],
  navajowhite: [255, 222, 173],
  navy: [0, 0, 128],
  oldlace: [253, 245, 230],
  olive: [128, 128, 0],
  olivedrab: [107, 142, 35],
  orange: [255, 165, 0],
  orangered: [255, 69, 0],
  orchid: [218, 112, 214],
  palegoldenrod: [238, 232, 170],
  palegreen: [152, 251, 152],
  paleturquoise: [175, 238, 238],
  palevioletred: [219, 112, 147],
  papayawhip: [255, 239, 213],
  peachpuff: [255, 218, 185],
  peru: [205, 133, 63],
  pink: [255, 192, 203],
  plum: [221, 160, 221],
  powderblue: [176, 224, 230],
  purple: [128, 0, 128],
  rebeccapurple: [102, 51, 153],
  red: [255, 0, 0],
  rosybrown: [188, 143, 143],
  royalblue: [65, 105, 225],
  saddlebrown: [139, 69, 19],
  salmon: [250, 128, 114],
  sandybrown: [244, 164, 96],
  seagreen: [46, 139, 87],
  seashell: [255, 245, 238],
  sienna: [160, 82, 45],
  silver: [192, 192, 192],
  skyblue: [135, 206, 235],
  slateblue: [106, 90, 205],
  slategray: [112, 128, 144],
  slategrey: [112, 128, 144],
  snow: [255, 250, 250],
  springgreen: [0, 255, 127],
  steelblue: [70, 130, 180],
  tan: [210, 180, 140],
  teal: [0, 128, 128],
  thistle: [216, 191, 216],
  tomato: [255, 99, 71],
  turquoise: [64, 224, 208],
  violet: [238, 130, 238],
  wheat: [245, 222, 179],
  white: [255, 255, 255],
  whitesmoke: [245, 245, 245],
  yellow: [255, 255, 0],
  yellowgreen: [154, 205, 50],
}
var cssKeywords = colorName
var reverseKeywords = {}
for (var key in cssKeywords) {
  if (cssKeywords.hasOwnProperty(key)) {
    reverseKeywords[cssKeywords[key]] = key
  }
}
var convert$1 = (conversions$2.exports = {
  rgb: { channels: 3, labels: 'rgb' },
  hsl: { channels: 3, labels: 'hsl' },
  hsv: { channels: 3, labels: 'hsv' },
  hwb: { channels: 3, labels: 'hwb' },
  cmyk: { channels: 4, labels: 'cmyk' },
  xyz: { channels: 3, labels: 'xyz' },
  lab: { channels: 3, labels: 'lab' },
  lch: { channels: 3, labels: 'lch' },
  hex: { channels: 1, labels: ['hex'] },
  keyword: { channels: 1, labels: ['keyword'] },
  ansi16: { channels: 1, labels: ['ansi16'] },
  ansi256: { channels: 1, labels: ['ansi256'] },
  hcg: { channels: 3, labels: ['h', 'c', 'g'] },
  apple: { channels: 3, labels: ['r16', 'g16', 'b16'] },
  gray: { channels: 1, labels: ['gray'] },
})
for (var model in convert$1) {
  if (convert$1.hasOwnProperty(model)) {
    if (!('channels' in convert$1[model])) {
      throw new Error('missing channels property: ' + model)
    }
    if (!('labels' in convert$1[model])) {
      throw new Error('missing channel labels property: ' + model)
    }
    if (convert$1[model].labels.length !== convert$1[model].channels) {
      throw new Error('channel and label counts mismatch: ' + model)
    }
    var channels = convert$1[model].channels
    var labels = convert$1[model].labels
    delete convert$1[model].channels
    delete convert$1[model].labels
    Object.defineProperty(convert$1[model], 'channels', { value: channels })
    Object.defineProperty(convert$1[model], 'labels', { value: labels })
  }
}
convert$1.rgb.hsl = function (rgb) {
  var r = rgb[0] / 255
  var g = rgb[1] / 255
  var b = rgb[2] / 255
  var min2 = Math.min(r, g, b)
  var max2 = Math.max(r, g, b)
  var delta = max2 - min2
  var h2
  var s2
  var l
  if (max2 === min2) {
    h2 = 0
  } else if (r === max2) {
    h2 = (g - b) / delta
  } else if (g === max2) {
    h2 = 2 + (b - r) / delta
  } else if (b === max2) {
    h2 = 4 + (r - g) / delta
  }
  h2 = Math.min(h2 * 60, 360)
  if (h2 < 0) {
    h2 += 360
  }
  l = (min2 + max2) / 2
  if (max2 === min2) {
    s2 = 0
  } else if (l <= 0.5) {
    s2 = delta / (max2 + min2)
  } else {
    s2 = delta / (2 - max2 - min2)
  }
  return [h2, s2 * 100, l * 100]
}
convert$1.rgb.hsv = function (rgb) {
  var rdif
  var gdif
  var bdif
  var h2
  var s2
  var r = rgb[0] / 255
  var g = rgb[1] / 255
  var b = rgb[2] / 255
  var v = Math.max(r, g, b)
  var diff2 = v - Math.min(r, g, b)
  var diffc = function (c) {
    return (v - c) / 6 / diff2 + 1 / 2
  }
  if (diff2 === 0) {
    h2 = s2 = 0
  } else {
    s2 = diff2 / v
    rdif = diffc(r)
    gdif = diffc(g)
    bdif = diffc(b)
    if (r === v) {
      h2 = bdif - gdif
    } else if (g === v) {
      h2 = 1 / 3 + rdif - bdif
    } else if (b === v) {
      h2 = 2 / 3 + gdif - rdif
    }
    if (h2 < 0) {
      h2 += 1
    } else if (h2 > 1) {
      h2 -= 1
    }
  }
  return [h2 * 360, s2 * 100, v * 100]
}
convert$1.rgb.hwb = function (rgb) {
  var r = rgb[0]
  var g = rgb[1]
  var b = rgb[2]
  var h2 = convert$1.rgb.hsl(rgb)[0]
  var w2 = (1 / 255) * Math.min(r, Math.min(g, b))
  b = 1 - (1 / 255) * Math.max(r, Math.max(g, b))
  return [h2, w2 * 100, b * 100]
}
convert$1.rgb.cmyk = function (rgb) {
  var r = rgb[0] / 255
  var g = rgb[1] / 255
  var b = rgb[2] / 255
  var c
  var m2
  var y2
  var k
  k = Math.min(1 - r, 1 - g, 1 - b)
  c = (1 - r - k) / (1 - k) || 0
  m2 = (1 - g - k) / (1 - k) || 0
  y2 = (1 - b - k) / (1 - k) || 0
  return [c * 100, m2 * 100, y2 * 100, k * 100]
}
function comparativeDistance(x, y2) {
  return Math.pow(x[0] - y2[0], 2) + Math.pow(x[1] - y2[1], 2) + Math.pow(x[2] - y2[2], 2)
}
convert$1.rgb.keyword = function (rgb) {
  var reversed = reverseKeywords[rgb]
  if (reversed) {
    return reversed
  }
  var currentClosestDistance = Infinity
  var currentClosestKeyword
  for (var keyword2 in cssKeywords) {
    if (cssKeywords.hasOwnProperty(keyword2)) {
      var value = cssKeywords[keyword2]
      var distance = comparativeDistance(rgb, value)
      if (distance < currentClosestDistance) {
        currentClosestDistance = distance
        currentClosestKeyword = keyword2
      }
    }
  }
  return currentClosestKeyword
}
convert$1.keyword.rgb = function (keyword2) {
  return cssKeywords[keyword2]
}
convert$1.rgb.xyz = function (rgb) {
  var r = rgb[0] / 255
  var g = rgb[1] / 255
  var b = rgb[2] / 255
  r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92
  g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92
  b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92
  var x = r * 0.4124 + g * 0.3576 + b * 0.1805
  var y2 = r * 0.2126 + g * 0.7152 + b * 0.0722
  var z = r * 0.0193 + g * 0.1192 + b * 0.9505
  return [x * 100, y2 * 100, z * 100]
}
convert$1.rgb.lab = function (rgb) {
  var xyz = convert$1.rgb.xyz(rgb)
  var x = xyz[0]
  var y2 = xyz[1]
  var z = xyz[2]
  var l
  var a
  var b
  x /= 95.047
  y2 /= 100
  z /= 108.883
  x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116
  y2 = y2 > 8856e-6 ? Math.pow(y2, 1 / 3) : 7.787 * y2 + 16 / 116
  z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116
  l = 116 * y2 - 16
  a = 500 * (x - y2)
  b = 200 * (y2 - z)
  return [l, a, b]
}
convert$1.hsl.rgb = function (hsl) {
  var h2 = hsl[0] / 360
  var s2 = hsl[1] / 100
  var l = hsl[2] / 100
  var t1
  var t2
  var t3
  var rgb
  var val
  if (s2 === 0) {
    val = l * 255
    return [val, val, val]
  }
  if (l < 0.5) {
    t2 = l * (1 + s2)
  } else {
    t2 = l + s2 - l * s2
  }
  t1 = 2 * l - t2
  rgb = [0, 0, 0]
  for (var i = 0; i < 3; i++) {
    t3 = h2 + (1 / 3) * -(i - 1)
    if (t3 < 0) {
      t3++
    }
    if (t3 > 1) {
      t3--
    }
    if (6 * t3 < 1) {
      val = t1 + (t2 - t1) * 6 * t3
    } else if (2 * t3 < 1) {
      val = t2
    } else if (3 * t3 < 2) {
      val = t1 + (t2 - t1) * (2 / 3 - t3) * 6
    } else {
      val = t1
    }
    rgb[i] = val * 255
  }
  return rgb
}
convert$1.hsl.hsv = function (hsl) {
  var h2 = hsl[0]
  var s2 = hsl[1] / 100
  var l = hsl[2] / 100
  var smin = s2
  var lmin = Math.max(l, 0.01)
  var sv
  var v
  l *= 2
  s2 *= l <= 1 ? l : 2 - l
  smin *= lmin <= 1 ? lmin : 2 - lmin
  v = (l + s2) / 2
  sv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s2) / (l + s2)
  return [h2, sv * 100, v * 100]
}
convert$1.hsv.rgb = function (hsv) {
  var h2 = hsv[0] / 60
  var s2 = hsv[1] / 100
  var v = hsv[2] / 100
  var hi = Math.floor(h2) % 6
  var f = h2 - Math.floor(h2)
  var p = 255 * v * (1 - s2)
  var q = 255 * v * (1 - s2 * f)
  var t2 = 255 * v * (1 - s2 * (1 - f))
  v *= 255
  switch (hi) {
    case 0:
      return [v, t2, p]
    case 1:
      return [q, v, p]
    case 2:
      return [p, v, t2]
    case 3:
      return [p, q, v]
    case 4:
      return [t2, p, v]
    case 5:
      return [v, p, q]
  }
}
convert$1.hsv.hsl = function (hsv) {
  var h2 = hsv[0]
  var s2 = hsv[1] / 100
  var v = hsv[2] / 100
  var vmin = Math.max(v, 0.01)
  var lmin
  var sl
  var l
  l = (2 - s2) * v
  lmin = (2 - s2) * vmin
  sl = s2 * vmin
  sl /= lmin <= 1 ? lmin : 2 - lmin
  sl = sl || 0
  l /= 2
  return [h2, sl * 100, l * 100]
}
convert$1.hwb.rgb = function (hwb) {
  var h2 = hwb[0] / 360
  var wh = hwb[1] / 100
  var bl = hwb[2] / 100
  var ratio = wh + bl
  var i
  var v
  var f
  var n2
  if (ratio > 1) {
    wh /= ratio
    bl /= ratio
  }
  i = Math.floor(6 * h2)
  v = 1 - bl
  f = 6 * h2 - i
  if ((i & 1) !== 0) {
    f = 1 - f
  }
  n2 = wh + f * (v - wh)
  var r
  var g
  var b
  switch (i) {
    default:
    case 6:
    case 0:
      r = v
      g = n2
      b = wh
      break
    case 1:
      r = n2
      g = v
      b = wh
      break
    case 2:
      r = wh
      g = v
      b = n2
      break
    case 3:
      r = wh
      g = n2
      b = v
      break
    case 4:
      r = n2
      g = wh
      b = v
      break
    case 5:
      r = v
      g = wh
      b = n2
      break
  }
  return [r * 255, g * 255, b * 255]
}
convert$1.cmyk.rgb = function (cmyk) {
  var c = cmyk[0] / 100
  var m2 = cmyk[1] / 100
  var y2 = cmyk[2] / 100
  var k = cmyk[3] / 100
  var r
  var g
  var b
  r = 1 - Math.min(1, c * (1 - k) + k)
  g = 1 - Math.min(1, m2 * (1 - k) + k)
  b = 1 - Math.min(1, y2 * (1 - k) + k)
  return [r * 255, g * 255, b * 255]
}
convert$1.xyz.rgb = function (xyz) {
  var x = xyz[0] / 100
  var y2 = xyz[1] / 100
  var z = xyz[2] / 100
  var r
  var g
  var b
  r = x * 3.2406 + y2 * -1.5372 + z * -0.4986
  g = x * -0.9689 + y2 * 1.8758 + z * 0.0415
  b = x * 0.0557 + y2 * -0.204 + z * 1.057
  r = r > 31308e-7 ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055 : r * 12.92
  g = g > 31308e-7 ? 1.055 * Math.pow(g, 1 / 2.4) - 0.055 : g * 12.92
  b = b > 31308e-7 ? 1.055 * Math.pow(b, 1 / 2.4) - 0.055 : b * 12.92
  r = Math.min(Math.max(0, r), 1)
  g = Math.min(Math.max(0, g), 1)
  b = Math.min(Math.max(0, b), 1)
  return [r * 255, g * 255, b * 255]
}
convert$1.xyz.lab = function (xyz) {
  var x = xyz[0]
  var y2 = xyz[1]
  var z = xyz[2]
  var l
  var a
  var b
  x /= 95.047
  y2 /= 100
  z /= 108.883
  x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116
  y2 = y2 > 8856e-6 ? Math.pow(y2, 1 / 3) : 7.787 * y2 + 16 / 116
  z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116
  l = 116 * y2 - 16
  a = 500 * (x - y2)
  b = 200 * (y2 - z)
  return [l, a, b]
}
convert$1.lab.xyz = function (lab) {
  var l = lab[0]
  var a = lab[1]
  var b = lab[2]
  var x
  var y2
  var z
  y2 = (l + 16) / 116
  x = a / 500 + y2
  z = y2 - b / 200
  var y22 = Math.pow(y2, 3)
  var x2 = Math.pow(x, 3)
  var z2 = Math.pow(z, 3)
  y2 = y22 > 8856e-6 ? y22 : (y2 - 16 / 116) / 7.787
  x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787
  z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787
  x *= 95.047
  y2 *= 100
  z *= 108.883
  return [x, y2, z]
}
convert$1.lab.lch = function (lab) {
  var l = lab[0]
  var a = lab[1]
  var b = lab[2]
  var hr
  var h2
  var c
  hr = Math.atan2(b, a)
  h2 = (hr * 360) / 2 / Math.PI
  if (h2 < 0) {
    h2 += 360
  }
  c = Math.sqrt(a * a + b * b)
  return [l, c, h2]
}
convert$1.lch.lab = function (lch) {
  var l = lch[0]
  var c = lch[1]
  var h2 = lch[2]
  var a
  var b
  var hr
  hr = (h2 / 360) * 2 * Math.PI
  a = c * Math.cos(hr)
  b = c * Math.sin(hr)
  return [l, a, b]
}
convert$1.rgb.ansi16 = function (args) {
  var r = args[0]
  var g = args[1]
  var b = args[2]
  var value = 1 in arguments ? arguments[1] : convert$1.rgb.hsv(args)[2]
  value = Math.round(value / 50)
  if (value === 0) {
    return 30
  }
  var ansi = 30 + ((Math.round(b / 255) << 2) | (Math.round(g / 255) << 1) | Math.round(r / 255))
  if (value === 2) {
    ansi += 60
  }
  return ansi
}
convert$1.hsv.ansi16 = function (args) {
  return convert$1.rgb.ansi16(convert$1.hsv.rgb(args), args[2])
}
convert$1.rgb.ansi256 = function (args) {
  var r = args[0]
  var g = args[1]
  var b = args[2]
  if (r === g && g === b) {
    if (r < 8) {
      return 16
    }
    if (r > 248) {
      return 231
    }
    return Math.round(((r - 8) / 247) * 24) + 232
  }
  var ansi = 16 + 36 * Math.round((r / 255) * 5) + 6 * Math.round((g / 255) * 5) + Math.round((b / 255) * 5)
  return ansi
}
convert$1.ansi16.rgb = function (args) {
  var color = args % 10
  if (color === 0 || color === 7) {
    if (args > 50) {
      color += 3.5
    }
    color = (color / 10.5) * 255
    return [color, color, color]
  }
  var mult = (~~(args > 50) + 1) * 0.5
  var r = (color & 1) * mult * 255
  var g = ((color >> 1) & 1) * mult * 255
  var b = ((color >> 2) & 1) * mult * 255
  return [r, g, b]
}
convert$1.ansi256.rgb = function (args) {
  if (args >= 232) {
    var c = (args - 232) * 10 + 8
    return [c, c, c]
  }
  args -= 16
  var rem
  var r = (Math.floor(args / 36) / 5) * 255
  var g = (Math.floor((rem = args % 36) / 6) / 5) * 255
  var b = ((rem % 6) / 5) * 255
  return [r, g, b]
}
convert$1.rgb.hex = function (args) {
  var integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255)
  var string2 = integer.toString(16).toUpperCase()
  return '000000'.substring(string2.length) + string2
}
convert$1.hex.rgb = function (args) {
  var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i)
  if (!match) {
    return [0, 0, 0]
  }
  var colorString = match[0]
  if (match[0].length === 3) {
    colorString = colorString
      .split('')
      .map(function (char) {
        return char + char
      })
      .join('')
  }
  var integer = parseInt(colorString, 16)
  var r = (integer >> 16) & 255
  var g = (integer >> 8) & 255
  var b = integer & 255
  return [r, g, b]
}
convert$1.rgb.hcg = function (rgb) {
  var r = rgb[0] / 255
  var g = rgb[1] / 255
  var b = rgb[2] / 255
  var max2 = Math.max(Math.max(r, g), b)
  var min2 = Math.min(Math.min(r, g), b)
  var chroma = max2 - min2
  var grayscale
  var hue
  if (chroma < 1) {
    grayscale = min2 / (1 - chroma)
  } else {
    grayscale = 0
  }
  if (chroma <= 0) {
    hue = 0
  } else if (max2 === r) {
    hue = ((g - b) / chroma) % 6
  } else if (max2 === g) {
    hue = 2 + (b - r) / chroma
  } else {
    hue = 4 + (r - g) / chroma + 4
  }
  hue /= 6
  hue %= 1
  return [hue * 360, chroma * 100, grayscale * 100]
}
convert$1.hsl.hcg = function (hsl) {
  var s2 = hsl[1] / 100
  var l = hsl[2] / 100
  var c = 1
  var f = 0
  if (l < 0.5) {
    c = 2 * s2 * l
  } else {
    c = 2 * s2 * (1 - l)
  }
  if (c < 1) {
    f = (l - 0.5 * c) / (1 - c)
  }
  return [hsl[0], c * 100, f * 100]
}
convert$1.hsv.hcg = function (hsv) {
  var s2 = hsv[1] / 100
  var v = hsv[2] / 100
  var c = s2 * v
  var f = 0
  if (c < 1) {
    f = (v - c) / (1 - c)
  }
  return [hsv[0], c * 100, f * 100]
}
convert$1.hcg.rgb = function (hcg) {
  var h2 = hcg[0] / 360
  var c = hcg[1] / 100
  var g = hcg[2] / 100
  if (c === 0) {
    return [g * 255, g * 255, g * 255]
  }
  var pure = [0, 0, 0]
  var hi = (h2 % 1) * 6
  var v = hi % 1
  var w2 = 1 - v
  var mg = 0
  switch (Math.floor(hi)) {
    case 0:
      pure[0] = 1
      pure[1] = v
      pure[2] = 0
      break
    case 1:
      pure[0] = w2
      pure[1] = 1
      pure[2] = 0
      break
    case 2:
      pure[0] = 0
      pure[1] = 1
      pure[2] = v
      break
    case 3:
      pure[0] = 0
      pure[1] = w2
      pure[2] = 1
      break
    case 4:
      pure[0] = v
      pure[1] = 0
      pure[2] = 1
      break
    default:
      pure[0] = 1
      pure[1] = 0
      pure[2] = w2
  }
  mg = (1 - c) * g
  return [(c * pure[0] + mg) * 255, (c * pure[1] + mg) * 255, (c * pure[2] + mg) * 255]
}
convert$1.hcg.hsv = function (hcg) {
  var c = hcg[1] / 100
  var g = hcg[2] / 100
  var v = c + g * (1 - c)
  var f = 0
  if (v > 0) {
    f = c / v
  }
  return [hcg[0], f * 100, v * 100]
}
convert$1.hcg.hsl = function (hcg) {
  var c = hcg[1] / 100
  var g = hcg[2] / 100
  var l = g * (1 - c) + 0.5 * c
  var s2 = 0
  if (l > 0 && l < 0.5) {
    s2 = c / (2 * l)
  } else if (l >= 0.5 && l < 1) {
    s2 = c / (2 * (1 - l))
  }
  return [hcg[0], s2 * 100, l * 100]
}
convert$1.hcg.hwb = function (hcg) {
  var c = hcg[1] / 100
  var g = hcg[2] / 100
  var v = c + g * (1 - c)
  return [hcg[0], (v - c) * 100, (1 - v) * 100]
}
convert$1.hwb.hcg = function (hwb) {
  var w2 = hwb[1] / 100
  var b = hwb[2] / 100
  var v = 1 - b
  var c = v - w2
  var g = 0
  if (c < 1) {
    g = (v - c) / (1 - c)
  }
  return [hwb[0], c * 100, g * 100]
}
convert$1.apple.rgb = function (apple) {
  return [(apple[0] / 65535) * 255, (apple[1] / 65535) * 255, (apple[2] / 65535) * 255]
}
convert$1.rgb.apple = function (rgb) {
  return [(rgb[0] / 255) * 65535, (rgb[1] / 255) * 65535, (rgb[2] / 255) * 65535]
}
convert$1.gray.rgb = function (args) {
  return [(args[0] / 100) * 255, (args[0] / 100) * 255, (args[0] / 100) * 255]
}
convert$1.gray.hsl = convert$1.gray.hsv = function (args) {
  return [0, 0, args[0]]
}
convert$1.gray.hwb = function (gray) {
  return [0, 100, gray[0]]
}
convert$1.gray.cmyk = function (gray) {
  return [0, 0, 0, gray[0]]
}
convert$1.gray.lab = function (gray) {
  return [gray[0], 0, 0]
}
convert$1.gray.hex = function (gray) {
  var val = Math.round((gray[0] / 100) * 255) & 255
  var integer = (val << 16) + (val << 8) + val
  var string2 = integer.toString(16).toUpperCase()
  return '000000'.substring(string2.length) + string2
}
convert$1.rgb.gray = function (rgb) {
  var val = (rgb[0] + rgb[1] + rgb[2]) / 3
  return [(val / 255) * 100]
}
var conversions$1 = conversions$2.exports
function buildGraph() {
  var graph = {}
  var models2 = Object.keys(conversions$1)
  for (var len = models2.length, i = 0; i < len; i++) {
    graph[models2[i]] = {
      distance: -1,
      parent: null,
    }
  }
  return graph
}
function deriveBFS(fromModel) {
  var graph = buildGraph()
  var queue = [fromModel]
  graph[fromModel].distance = 0
  while (queue.length) {
    var current = queue.pop()
    var adjacents = Object.keys(conversions$1[current])
    for (var len = adjacents.length, i = 0; i < len; i++) {
      var adjacent = adjacents[i]
      var node2 = graph[adjacent]
      if (node2.distance === -1) {
        node2.distance = graph[current].distance + 1
        node2.parent = current
        queue.unshift(adjacent)
      }
    }
  }
  return graph
}
function link(from, to) {
  return function (args) {
    return to(from(args))
  }
}
function wrapConversion(toModel, graph) {
  var path2 = [graph[toModel].parent, toModel]
  var fn = conversions$1[graph[toModel].parent][toModel]
  var cur = graph[toModel].parent
  while (graph[cur].parent) {
    path2.unshift(graph[cur].parent)
    fn = link(conversions$1[graph[cur].parent][cur], fn)
    cur = graph[cur].parent
  }
  fn.conversion = path2
  return fn
}
var route$1 = function (fromModel) {
  var graph = deriveBFS(fromModel)
  var conversion2 = {}
  var models2 = Object.keys(graph)
  for (var len = models2.length, i = 0; i < len; i++) {
    var toModel = models2[i]
    var node2 = graph[toModel]
    if (node2.parent === null) {
      continue
    }
    conversion2[toModel] = wrapConversion(toModel, graph)
  }
  return conversion2
}
var conversions = conversions$2.exports
var route = route$1
var convert = {}
var models = Object.keys(conversions)
function wrapRaw(fn) {
  var wrappedFn = function (args) {
    if (args === void 0 || args === null) {
      return args
    }
    if (arguments.length > 1) {
      args = Array.prototype.slice.call(arguments)
    }
    return fn(args)
  }
  if ('conversion' in fn) {
    wrappedFn.conversion = fn.conversion
  }
  return wrappedFn
}
function wrapRounded(fn) {
  var wrappedFn = function (args) {
    if (args === void 0 || args === null) {
      return args
    }
    if (arguments.length > 1) {
      args = Array.prototype.slice.call(arguments)
    }
    var result = fn(args)
    if (typeof result === 'object') {
      for (var len = result.length, i = 0; i < len; i++) {
        result[i] = Math.round(result[i])
      }
    }
    return result
  }
  if ('conversion' in fn) {
    wrappedFn.conversion = fn.conversion
  }
  return wrappedFn
}
models.forEach(function (fromModel) {
  convert[fromModel] = {}
  Object.defineProperty(convert[fromModel], 'channels', { value: conversions[fromModel].channels })
  Object.defineProperty(convert[fromModel], 'labels', { value: conversions[fromModel].labels })
  var routes = route(fromModel)
  var routeModels = Object.keys(routes)
  routeModels.forEach(function (toModel) {
    var fn = routes[toModel]
    convert[fromModel][toModel] = wrapRounded(fn)
    convert[fromModel][toModel].raw = wrapRaw(fn)
  })
})
var colorConvert = convert
;(function (module) {
  const colorConvert$1 = colorConvert
  const wrapAnsi16 = (fn, offset) =>
    function () {
      const code2 = fn.apply(colorConvert$1, arguments)
      return `\x1B[${code2 + offset}m`
    }
  const wrapAnsi256 = (fn, offset) =>
    function () {
      const code2 = fn.apply(colorConvert$1, arguments)
      return `\x1B[${38 + offset};5;${code2}m`
    }
  const wrapAnsi16m = (fn, offset) =>
    function () {
      const rgb = fn.apply(colorConvert$1, arguments)
      return `\x1B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`
    }
  function assembleStyles() {
    const codes = /* @__PURE__ */ new Map()
    const styles = {
      modifier: {
        reset: [0, 0],
        bold: [1, 22],
        dim: [2, 22],
        italic: [3, 23],
        underline: [4, 24],
        inverse: [7, 27],
        hidden: [8, 28],
        strikethrough: [9, 29],
      },
      color: {
        black: [30, 39],
        red: [31, 39],
        green: [32, 39],
        yellow: [33, 39],
        blue: [34, 39],
        magenta: [35, 39],
        cyan: [36, 39],
        white: [37, 39],
        gray: [90, 39],
        redBright: [91, 39],
        greenBright: [92, 39],
        yellowBright: [93, 39],
        blueBright: [94, 39],
        magentaBright: [95, 39],
        cyanBright: [96, 39],
        whiteBright: [97, 39],
      },
      bgColor: {
        bgBlack: [40, 49],
        bgRed: [41, 49],
        bgGreen: [42, 49],
        bgYellow: [43, 49],
        bgBlue: [44, 49],
        bgMagenta: [45, 49],
        bgCyan: [46, 49],
        bgWhite: [47, 49],
        bgBlackBright: [100, 49],
        bgRedBright: [101, 49],
        bgGreenBright: [102, 49],
        bgYellowBright: [103, 49],
        bgBlueBright: [104, 49],
        bgMagentaBright: [105, 49],
        bgCyanBright: [106, 49],
        bgWhiteBright: [107, 49],
      },
    }
    styles.color.grey = styles.color.gray
    for (const groupName of Object.keys(styles)) {
      const group = styles[groupName]
      for (const styleName of Object.keys(group)) {
        const style = group[styleName]
        styles[styleName] = {
          open: `\x1B[${style[0]}m`,
          close: `\x1B[${style[1]}m`,
        }
        group[styleName] = styles[styleName]
        codes.set(style[0], style[1])
      }
      Object.defineProperty(styles, groupName, {
        value: group,
        enumerable: false,
      })
      Object.defineProperty(styles, 'codes', {
        value: codes,
        enumerable: false,
      })
    }
    const ansi2ansi = (n2) => n2
    const rgb2rgb = (r, g, b) => [r, g, b]
    styles.color.close = '\x1B[39m'
    styles.bgColor.close = '\x1B[49m'
    styles.color.ansi = {
      ansi: wrapAnsi16(ansi2ansi, 0),
    }
    styles.color.ansi256 = {
      ansi256: wrapAnsi256(ansi2ansi, 0),
    }
    styles.color.ansi16m = {
      rgb: wrapAnsi16m(rgb2rgb, 0),
    }
    styles.bgColor.ansi = {
      ansi: wrapAnsi16(ansi2ansi, 10),
    }
    styles.bgColor.ansi256 = {
      ansi256: wrapAnsi256(ansi2ansi, 10),
    }
    styles.bgColor.ansi16m = {
      rgb: wrapAnsi16m(rgb2rgb, 10),
    }
    for (let key of Object.keys(colorConvert$1)) {
      if (typeof colorConvert$1[key] !== 'object') {
        continue
      }
      const suite = colorConvert$1[key]
      if (key === 'ansi16') {
        key = 'ansi'
      }
      if ('ansi16' in suite) {
        styles.color.ansi[key] = wrapAnsi16(suite.ansi16, 0)
        styles.bgColor.ansi[key] = wrapAnsi16(suite.ansi16, 10)
      }
      if ('ansi256' in suite) {
        styles.color.ansi256[key] = wrapAnsi256(suite.ansi256, 0)
        styles.bgColor.ansi256[key] = wrapAnsi256(suite.ansi256, 10)
      }
      if ('rgb' in suite) {
        styles.color.ansi16m[key] = wrapAnsi16m(suite.rgb, 0)
        styles.bgColor.ansi16m[key] = wrapAnsi16m(suite.rgb, 10)
      }
    }
    return styles
  }
  Object.defineProperty(module, 'exports', {
    enumerable: true,
    get: assembleStyles,
  })
})(ansiStyles)
var browser = {
  stdout: false,
  stderr: false,
}
const TEMPLATE_REGEX =
  /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi
const STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g
const STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/
const ESCAPE_REGEX = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi
const ESCAPES = /* @__PURE__ */ new Map([
  ['n', '\n'],
  ['r', '\r'],
  ['t', '	'],
  ['b', '\b'],
  ['f', '\f'],
  ['v', '\v'],
  ['0', '\0'],
  ['\\', '\\'],
  ['e', '\x1B'],
  ['a', '\x07'],
])
function unescape(c) {
  if ((c[0] === 'u' && c.length === 5) || (c[0] === 'x' && c.length === 3)) {
    return String.fromCharCode(parseInt(c.slice(1), 16))
  }
  return ESCAPES.get(c) || c
}
function parseArguments(name, args) {
  const results = []
  const chunks = args.trim().split(/\s*,\s*/g)
  let matches
  for (const chunk of chunks) {
    if (!isNaN(chunk)) {
      results.push(Number(chunk))
    } else if ((matches = chunk.match(STRING_REGEX))) {
      results.push(matches[2].replace(ESCAPE_REGEX, (m2, escape, chr) => (escape ? unescape(escape) : chr)))
    } else {
      throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`)
    }
  }
  return results
}
function parseStyle(style) {
  STYLE_REGEX.lastIndex = 0
  const results = []
  let matches
  while ((matches = STYLE_REGEX.exec(style)) !== null) {
    const name = matches[1]
    if (matches[2]) {
      const args = parseArguments(name, matches[2])
      results.push([name].concat(args))
    } else {
      results.push([name])
    }
  }
  return results
}
function buildStyle(chalk2, styles) {
  const enabled = {}
  for (const layer of styles) {
    for (const style of layer.styles) {
      enabled[style[0]] = layer.inverse ? null : style.slice(1)
    }
  }
  let current = chalk2
  for (const styleName of Object.keys(enabled)) {
    if (Array.isArray(enabled[styleName])) {
      if (!(styleName in current)) {
        throw new Error(`Unknown Chalk style: ${styleName}`)
      }
      if (enabled[styleName].length > 0) {
        current = current[styleName].apply(current, enabled[styleName])
      } else {
        current = current[styleName]
      }
    }
  }
  return current
}
var templates = (chalk2, tmp) => {
  const styles = []
  const chunks = []
  let chunk = []
  tmp.replace(TEMPLATE_REGEX, (m2, escapeChar, inverse, style, close, chr) => {
    if (escapeChar) {
      chunk.push(unescape(escapeChar))
    } else if (style) {
      const str = chunk.join('')
      chunk = []
      chunks.push(styles.length === 0 ? str : buildStyle(chalk2, styles)(str))
      styles.push({ inverse, styles: parseStyle(style) })
    } else if (close) {
      if (styles.length === 0) {
        throw new Error('Found extraneous } in Chalk template literal')
      }
      chunks.push(buildStyle(chalk2, styles)(chunk.join('')))
      chunk = []
      styles.pop()
    } else {
      chunk.push(chr)
    }
  })
  chunks.push(chunk.join(''))
  if (styles.length > 0) {
    const errMsg = `Chalk template literal is missing ${styles.length} closing bracket${
      styles.length === 1 ? '' : 's'
    } (\`}\`)`
    throw new Error(errMsg)
  }
  return chunks.join('')
}
;(function (module) {
  const escapeStringRegexp$1 = escapeStringRegexp
  const ansiStyles$1 = ansiStyles.exports
  const stdoutColor = browser.stdout
  const template = templates
  const isSimpleWindowsTerm = process.platform === 'win32' && !({}.TERM || '').toLowerCase().startsWith('xterm')
  const levelMapping = ['ansi', 'ansi', 'ansi256', 'ansi16m']
  const skipModels = /* @__PURE__ */ new Set(['gray'])
  const styles = /* @__PURE__ */ Object.create(null)
  function applyOptions(obj, options2) {
    options2 = options2 || {}
    const scLevel = 0
    obj.level = options2.level === void 0 ? scLevel : options2.level
    obj.enabled = 'enabled' in options2 ? options2.enabled : obj.level > 0
  }
  function Chalk(options2) {
    if (!this || !(this instanceof Chalk) || this.template) {
      const chalk2 = {}
      applyOptions(chalk2, options2)
      chalk2.template = function () {
        const args = [].slice.call(arguments)
        return chalkTag.apply(null, [chalk2.template].concat(args))
      }
      Object.setPrototypeOf(chalk2, Chalk.prototype)
      Object.setPrototypeOf(chalk2.template, chalk2)
      chalk2.template.constructor = Chalk
      return chalk2.template
    }
    applyOptions(this, options2)
  }
  if (isSimpleWindowsTerm) {
    ansiStyles$1.blue.open = '\x1B[94m'
  }
  for (const key of Object.keys(ansiStyles$1)) {
    ansiStyles$1[key].closeRe = new RegExp(escapeStringRegexp$1(ansiStyles$1[key].close), 'g')
    styles[key] = {
      get() {
        const codes = ansiStyles$1[key]
        return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, key)
      },
    }
  }
  styles.visible = {
    get() {
      return build.call(this, this._styles || [], true, 'visible')
    },
  }
  ansiStyles$1.color.closeRe = new RegExp(escapeStringRegexp$1(ansiStyles$1.color.close), 'g')
  for (const model of Object.keys(ansiStyles$1.color.ansi)) {
    if (skipModels.has(model)) {
      continue
    }
    styles[model] = {
      get() {
        const level = this.level
        return function () {
          const open2 = ansiStyles$1.color[levelMapping[level]][model].apply(null, arguments)
          const codes = {
            open: open2,
            close: ansiStyles$1.color.close,
            closeRe: ansiStyles$1.color.closeRe,
          }
          return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model)
        }
      },
    }
  }
  ansiStyles$1.bgColor.closeRe = new RegExp(escapeStringRegexp$1(ansiStyles$1.bgColor.close), 'g')
  for (const model of Object.keys(ansiStyles$1.bgColor.ansi)) {
    if (skipModels.has(model)) {
      continue
    }
    const bgModel = 'bg' + model[0].toUpperCase() + model.slice(1)
    styles[bgModel] = {
      get() {
        const level = this.level
        return function () {
          const open2 = ansiStyles$1.bgColor[levelMapping[level]][model].apply(null, arguments)
          const codes = {
            open: open2,
            close: ansiStyles$1.bgColor.close,
            closeRe: ansiStyles$1.bgColor.closeRe,
          }
          return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model)
        }
      },
    }
  }
  const proto2 = Object.defineProperties(() => {}, styles)
  function build(_styles, _empty, key) {
    const builder2 = function () {
      return applyStyle.apply(builder2, arguments)
    }
    builder2._styles = _styles
    builder2._empty = _empty
    const self2 = this
    Object.defineProperty(builder2, 'level', {
      enumerable: true,
      get() {
        return self2.level
      },
      set(level) {
        self2.level = level
      },
    })
    Object.defineProperty(builder2, 'enabled', {
      enumerable: true,
      get() {
        return self2.enabled
      },
      set(enabled) {
        self2.enabled = enabled
      },
    })
    builder2.hasGrey = this.hasGrey || key === 'gray' || key === 'grey'
    builder2.__proto__ = proto2
    return builder2
  }
  function applyStyle() {
    const args = arguments
    const argsLen = args.length
    let str = String(arguments[0])
    if (argsLen === 0) {
      return ''
    }
    if (argsLen > 1) {
      for (let a = 1; a < argsLen; a++) {
        str += ' ' + args[a]
      }
    }
    if (!this.enabled || this.level <= 0 || !str) {
      return this._empty ? '' : str
    }
    const originalDim = ansiStyles$1.dim.open
    if (isSimpleWindowsTerm && this.hasGrey) {
      ansiStyles$1.dim.open = ''
    }
    for (const code2 of this._styles.slice().reverse()) {
      str = code2.open + str.replace(code2.closeRe, code2.open) + code2.close
      str = str.replace(/\r?\n/g, `${code2.close}$&${code2.open}`)
    }
    ansiStyles$1.dim.open = originalDim
    return str
  }
  function chalkTag(chalk2, strings) {
    if (!Array.isArray(strings)) {
      return [].slice.call(arguments, 1).join(' ')
    }
    const args = [].slice.call(arguments, 2)
    const parts = [strings.raw[0]]
    for (let i = 1; i < strings.length; i++) {
      parts.push(String(args[i - 1]).replace(/[{}\\]/g, '\\$&'))
      parts.push(String(strings.raw[i]))
    }
    return template(chalk2, parts.join(''))
  }
  Object.defineProperties(Chalk.prototype, styles)
  module.exports = Chalk()
  module.exports.supportsColor = stdoutColor
  module.exports.default = module.exports
})(chalk)
Object.defineProperty(lib$5, '__esModule', {
  value: true,
})
lib$5.default = highlight
lib$5.getChalk = getChalk
lib$5.shouldHighlight = shouldHighlight
var _jsTokens = jsTokens
var _helperValidatorIdentifier = lib$a
var _chalk = chalk.exports
const sometimesKeywords = /* @__PURE__ */ new Set(['as', 'async', 'from', 'get', 'of', 'set'])
function getDefs$1(chalk2) {
  return {
    keyword: chalk2.cyan,
    capitalized: chalk2.yellow,
    jsxIdentifier: chalk2.yellow,
    punctuator: chalk2.yellow,
    number: chalk2.magenta,
    string: chalk2.green,
    regex: chalk2.magenta,
    comment: chalk2.grey,
    invalid: chalk2.white.bgRed.bold,
  }
}
const NEWLINE$1 = /\r\n|[\n\r\u2028\u2029]/
const BRACKET = /^[()[\]{}]$/
let tokenize
{
  const JSX_TAG = /^[a-z][\w-]*$/i
  const getTokenType = function (token, offset, text) {
    if (token.type === 'name') {
      if (
        (0, _helperValidatorIdentifier.isKeyword)(token.value) ||
        (0, _helperValidatorIdentifier.isStrictReservedWord)(token.value, true) ||
        sometimesKeywords.has(token.value)
      ) {
        return 'keyword'
      }
      if (JSX_TAG.test(token.value) && (text[offset - 1] === '<' || text.slice(offset - 2, offset) == '</')) {
        return 'jsxIdentifier'
      }
      if (token.value[0] !== token.value[0].toLowerCase()) {
        return 'capitalized'
      }
    }
    if (token.type === 'punctuator' && BRACKET.test(token.value)) {
      return 'bracket'
    }
    if (token.type === 'invalid' && (token.value === '@' || token.value === '#')) {
      return 'punctuator'
    }
    return token.type
  }
  tokenize = function* (text) {
    let match
    while ((match = _jsTokens.default.exec(text))) {
      const token = _jsTokens.matchToToken(match)
      yield {
        type: getTokenType(token, match.index, text),
        value: token.value,
      }
    }
  }
}
function highlightTokens(defs, text) {
  let highlighted = ''
  for (const { type, value } of tokenize(text)) {
    const colorize = defs[type]
    if (colorize) {
      highlighted += value
        .split(NEWLINE$1)
        .map((str) => colorize(str))
        .join('\n')
    } else {
      highlighted += value
    }
  }
  return highlighted
}
function shouldHighlight(options2) {
  return !!_chalk.supportsColor || options2.forceColor
}
function getChalk(options2) {
  return options2.forceColor
    ? new _chalk.constructor({
        enabled: true,
        level: 1,
      })
    : _chalk
}
function highlight(code2, options2 = {}) {
  if (code2 !== '' && shouldHighlight(options2)) {
    const chalk2 = getChalk(options2)
    const defs = getDefs$1(chalk2)
    return highlightTokens(defs, code2)
  } else {
    return code2
  }
}
Object.defineProperty(lib$6, '__esModule', {
  value: true,
})
lib$6.codeFrameColumns = codeFrameColumns
lib$6.default = _default$3
var _highlight = lib$5
let deprecationWarningShown = false
function getDefs(chalk2) {
  return {
    gutter: chalk2.grey,
    marker: chalk2.red.bold,
    message: chalk2.red.bold,
  }
}
const NEWLINE = /\r\n|[\n\r\u2028\u2029]/
function getMarkerLines(loc, source, opts) {
  const startLoc = Object.assign(
    {
      column: 0,
      line: -1,
    },
    loc.start
  )
  const endLoc = Object.assign({}, startLoc, loc.end)
  const { linesAbove = 2, linesBelow = 3 } = opts || {}
  const startLine = startLoc.line
  const startColumn = startLoc.column
  const endLine = endLoc.line
  const endColumn = endLoc.column
  let start = Math.max(startLine - (linesAbove + 1), 0)
  let end = Math.min(source.length, endLine + linesBelow)
  if (startLine === -1) {
    start = 0
  }
  if (endLine === -1) {
    end = source.length
  }
  const lineDiff = endLine - startLine
  const markerLines = {}
  if (lineDiff) {
    for (let i = 0; i <= lineDiff; i++) {
      const lineNumber = i + startLine
      if (!startColumn) {
        markerLines[lineNumber] = true
      } else if (i === 0) {
        const sourceLength = source[lineNumber - 1].length
        markerLines[lineNumber] = [startColumn, sourceLength - startColumn + 1]
      } else if (i === lineDiff) {
        markerLines[lineNumber] = [0, endColumn]
      } else {
        const sourceLength = source[lineNumber - i].length
        markerLines[lineNumber] = [0, sourceLength]
      }
    }
  } else {
    if (startColumn === endColumn) {
      if (startColumn) {
        markerLines[startLine] = [startColumn, 0]
      } else {
        markerLines[startLine] = true
      }
    } else {
      markerLines[startLine] = [startColumn, endColumn - startColumn]
    }
  }
  return {
    start,
    end,
    markerLines,
  }
}
function codeFrameColumns(rawLines, loc, opts = {}) {
  const highlighted = (opts.highlightCode || opts.forceColor) && (0, _highlight.shouldHighlight)(opts)
  const chalk2 = (0, _highlight.getChalk)(opts)
  const defs = getDefs(chalk2)
  const maybeHighlight = (chalkFn, string2) => {
    return highlighted ? chalkFn(string2) : string2
  }
  const lines = rawLines.split(NEWLINE)
  const { start, end, markerLines } = getMarkerLines(loc, lines, opts)
  const hasColumns = loc.start && typeof loc.start.column === 'number'
  const numberMaxWidth = String(end).length
  const highlightedLines = highlighted ? (0, _highlight.default)(rawLines, opts) : rawLines
  let frame = highlightedLines
    .split(NEWLINE, end)
    .slice(start, end)
    .map((line, index2) => {
      const number = start + 1 + index2
      const paddedNumber = ` ${number}`.slice(-numberMaxWidth)
      const gutter = ` ${paddedNumber} |`
      const hasMarker = markerLines[number]
      const lastMarkerLine = !markerLines[number + 1]
      if (hasMarker) {
        let markerLine = ''
        if (Array.isArray(hasMarker)) {
          const markerSpacing = line.slice(0, Math.max(hasMarker[0] - 1, 0)).replace(/[^\t]/g, ' ')
          const numberOfMarkers = hasMarker[1] || 1
          markerLine = [
            '\n ',
            maybeHighlight(defs.gutter, gutter.replace(/\d/g, ' ')),
            ' ',
            markerSpacing,
            maybeHighlight(defs.marker, '^').repeat(numberOfMarkers),
          ].join('')
          if (lastMarkerLine && opts.message) {
            markerLine += ' ' + maybeHighlight(defs.message, opts.message)
          }
        }
        return [
          maybeHighlight(defs.marker, '>'),
          maybeHighlight(defs.gutter, gutter),
          line.length > 0 ? ` ${line}` : '',
          markerLine,
        ].join('')
      } else {
        return ` ${maybeHighlight(defs.gutter, gutter)}${line.length > 0 ? ` ${line}` : ''}`
      }
    })
    .join('\n')
  if (opts.message && !hasColumns) {
    frame = `${' '.repeat(numberMaxWidth + 1)}${opts.message}
${frame}`
  }
  if (highlighted) {
    return chalk2.reset(frame)
  } else {
    return frame
  }
}
function _default$3(rawLines, lineNumber, colNumber, opts = {}) {
  if (!deprecationWarningShown) {
    deprecationWarningShown = true
    const message =
      'Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.'
    if (process.emitWarning) {
      process.emitWarning(message, 'DeprecationWarning')
    } else {
      const deprecationError = new Error(message)
      deprecationError.name = 'DeprecationWarning'
      console.warn(new Error(message))
    }
  }
  colNumber = Math.max(colNumber, 0)
  const location2 = {
    start: {
      column: colNumber,
      line: lineNumber,
    },
  }
  return codeFrameColumns(rawLines, location2, opts)
}
var lib$4 = {}
Object.defineProperty(lib$4, '__esModule', { value: true })
function _objectWithoutPropertiesLoose$3(source, excluded) {
  if (source == null) return {}
  var target = {}
  var sourceKeys = Object.keys(source)
  var key, i
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i]
    if (excluded.indexOf(key) >= 0) continue
    target[key] = source[key]
  }
  return target
}
class Position$1 {
  constructor(line, col, index2) {
    this.line = void 0
    this.column = void 0
    this.index = void 0
    this.line = line
    this.column = col
    this.index = index2
  }
}
class SourceLocation$1 {
  constructor(start, end) {
    this.start = void 0
    this.end = void 0
    this.filename = void 0
    this.identifierName = void 0
    this.start = start
    this.end = end
  }
}
function createPositionWithColumnOffset$1(position, columnOffset) {
  const { line, column, index: index2 } = position
  return new Position$1(line, column + columnOffset, index2 + columnOffset)
}
const ParseErrorCodes$1 = Object.freeze({
  SyntaxError: 'BABEL_PARSER_SYNTAX_ERROR',
  SourceTypeModuleError: 'BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED',
})
const reflect$1 = (keys, last2 = keys.length - 1) => ({
  get() {
    return keys.reduce((object2, key) => object2[key], this)
  },
  set(value) {
    keys.reduce((item, key, i) => (i === last2 ? (item[key] = value) : item[key]), this)
  },
})
const instantiate$1 = (constructor, properties, descriptors) =>
  Object.keys(descriptors)
    .map((key) => [key, descriptors[key]])
    .filter(([, descriptor]) => !!descriptor)
    .map(([key, descriptor]) => [
      key,
      typeof descriptor === 'function'
        ? {
            value: descriptor,
            enumerable: false,
          }
        : typeof descriptor.reflect === 'string'
        ? Object.assign({}, descriptor, reflect$1(descriptor.reflect.split('.')))
        : descriptor,
    ])
    .reduce(
      (instance, [key, descriptor]) =>
        Object.defineProperty(
          instance,
          key,
          Object.assign(
            {
              configurable: true,
            },
            descriptor
          )
        ),
      Object.assign(new constructor(), properties)
    )
var ModuleErrors$1 = (_2) => ({
  ImportMetaOutsideModule: _2(`import.meta may appear only with 'sourceType: "module"'`, {
    code: ParseErrorCodes$1.SourceTypeModuleError,
  }),
  ImportOutsideModule: _2(`'import' and 'export' may appear only with 'sourceType: "module"'`, {
    code: ParseErrorCodes$1.SourceTypeModuleError,
  }),
})
const NodeDescriptions$1 = {
  ArrayPattern: 'array destructuring pattern',
  AssignmentExpression: 'assignment expression',
  AssignmentPattern: 'assignment expression',
  ArrowFunctionExpression: 'arrow function expression',
  ConditionalExpression: 'conditional expression',
  ForOfStatement: 'for-of statement',
  ForInStatement: 'for-in statement',
  ForStatement: 'for-loop',
  FormalParameters: 'function parameter list',
  Identifier: 'identifier',
  ObjectPattern: 'object destructuring pattern',
  ParenthesizedExpression: 'parenthesized expression',
  RestElement: 'rest element',
  UpdateExpression: {
    true: 'prefix operation',
    false: 'postfix operation',
  },
  VariableDeclarator: 'variable declaration',
  YieldExpression: 'yield expression',
}
const toNodeDescription$1 = ({ type, prefix: prefix2 }) =>
  type === 'UpdateExpression' ? NodeDescriptions$1.UpdateExpression[String(prefix2)] : NodeDescriptions$1[type]
var StandardErrors$1 = (_2) => ({
  AccessorIsGenerator: _2(({ kind }) => `A ${kind}ter cannot be a generator.`),
  ArgumentsInClass: _2("'arguments' is only allowed in functions and class methods."),
  AsyncFunctionInSingleStatementContext: _2('Async functions can only be declared at the top level or inside a block.'),
  AwaitBindingIdentifier: _2("Can not use 'await' as identifier inside an async function."),
  AwaitBindingIdentifierInStaticBlock: _2("Can not use 'await' as identifier inside a static block."),
  AwaitExpressionFormalParameter: _2("'await' is not allowed in async function parameters."),
  AwaitNotInAsyncContext: _2("'await' is only allowed within async functions and at the top levels of modules."),
  AwaitNotInAsyncFunction: _2("'await' is only allowed within async functions."),
  BadGetterArity: _2("A 'get' accesor must not have any formal parameters."),
  BadSetterArity: _2("A 'set' accesor must have exactly one formal parameter."),
  BadSetterRestParameter: _2("A 'set' accesor function argument must not be a rest parameter."),
  ConstructorClassField: _2("Classes may not have a field named 'constructor'."),
  ConstructorClassPrivateField: _2("Classes may not have a private field named '#constructor'."),
  ConstructorIsAccessor: _2('Class constructor may not be an accessor.'),
  ConstructorIsAsync: _2("Constructor can't be an async function."),
  ConstructorIsGenerator: _2("Constructor can't be a generator."),
  DeclarationMissingInitializer: _2(({ kind }) => `Missing initializer in ${kind} declaration.`),
  DecoratorBeforeExport: _2(
    "Decorators must be placed *before* the 'export' keyword. You can set the 'decoratorsBeforeExport' option to false to use the 'export @decorator class {}' syntax."
  ),
  DecoratorConstructor: _2("Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?"),
  DecoratorExportClass: _2(
    'Using the export keyword between a decorator and a class is not allowed. Please use `export @dec class` instead.'
  ),
  DecoratorSemicolon: _2('Decorators must not be followed by a semicolon.'),
  DecoratorStaticBlock: _2("Decorators can't be used with a static block."),
  DeletePrivateField: _2('Deleting a private field is not allowed.'),
  DestructureNamedImport: _2(
    'ES2015 named imports do not destructure. Use another statement for destructuring after the import.'
  ),
  DuplicateConstructor: _2('Duplicate constructor in the same class.'),
  DuplicateDefaultExport: _2('Only one default export allowed per module.'),
  DuplicateExport: _2(
    ({ exportName }) => `\`${exportName}\` has already been exported. Exported identifiers must be unique.`
  ),
  DuplicateProto: _2('Redefinition of __proto__ property.'),
  DuplicateRegExpFlags: _2('Duplicate regular expression flag.'),
  ElementAfterRest: _2('Rest element must be last element.'),
  EscapedCharNotAnIdentifier: _2('Invalid Unicode escape.'),
  ExportBindingIsString: _2(
    ({ localName, exportName }) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${localName}' as '${exportName}' } from 'some-module'\`?`
  ),
  ExportDefaultFromAsIdentifier: _2("'from' is not allowed as an identifier after 'export default'."),
  ForInOfLoopInitializer: _2(
    ({ type }) =>
      `'${type === 'ForInStatement' ? 'for-in' : 'for-of'}' loop variable declaration may not have an initializer.`
  ),
  ForOfAsync: _2("The left-hand side of a for-of loop may not be 'async'."),
  ForOfLet: _2("The left-hand side of a for-of loop may not start with 'let'."),
  GeneratorInSingleStatementContext: _2('Generators can only be declared at the top level or inside a block.'),
  IllegalBreakContinue: _2(({ type }) => `Unsyntactic ${type === 'BreakStatement' ? 'break' : 'continue'}.`),
  IllegalLanguageModeDirective: _2("Illegal 'use strict' directive in function with non-simple parameter list."),
  IllegalReturn: _2("'return' outside of function."),
  ImportBindingIsString: _2(
    ({ importName }) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${importName}" as foo }\`?`
  ),
  ImportCallArgumentTrailingComma: _2('Trailing comma is disallowed inside import(...) arguments.'),
  ImportCallArity: _2(
    ({ maxArgumentCount }) =>
      `\`import()\` requires exactly ${maxArgumentCount === 1 ? 'one argument' : 'one or two arguments'}.`
  ),
  ImportCallNotNewExpression: _2('Cannot use new with import(...).'),
  ImportCallSpreadArgument: _2('`...` is not allowed in `import()`.'),
  IncompatibleRegExpUVFlags: _2("The 'u' and 'v' regular expression flags cannot be enabled at the same time."),
  InvalidBigIntLiteral: _2('Invalid BigIntLiteral.'),
  InvalidCodePoint: _2('Code point out of bounds.'),
  InvalidCoverInitializedName: _2('Invalid shorthand property initializer.'),
  InvalidDecimal: _2('Invalid decimal.'),
  InvalidDigit: _2(({ radix }) => `Expected number in radix ${radix}.`),
  InvalidEscapeSequence: _2('Bad character escape sequence.'),
  InvalidEscapeSequenceTemplate: _2('Invalid escape sequence in template.'),
  InvalidEscapedReservedWord: _2(({ reservedWord }) => `Escape sequence in keyword ${reservedWord}.`),
  InvalidIdentifier: _2(({ identifierName }) => `Invalid identifier ${identifierName}.`),
  InvalidLhs: _2(({ ancestor }) => `Invalid left-hand side in ${toNodeDescription$1(ancestor)}.`),
  InvalidLhsBinding: _2(({ ancestor }) => `Binding invalid left-hand side in ${toNodeDescription$1(ancestor)}.`),
  InvalidNumber: _2('Invalid number.'),
  InvalidOrMissingExponent: _2("Floating-point numbers require a valid exponent after the 'e'."),
  InvalidOrUnexpectedToken: _2(({ unexpected }) => `Unexpected character '${unexpected}'.`),
  InvalidParenthesizedAssignment: _2('Invalid parenthesized assignment pattern.'),
  InvalidPrivateFieldResolution: _2(({ identifierName }) => `Private name #${identifierName} is not defined.`),
  InvalidPropertyBindingPattern: _2('Binding member expression.'),
  InvalidRecordProperty: _2('Only properties and spread elements are allowed in record definitions.'),
  InvalidRestAssignmentPattern: _2("Invalid rest operator's argument."),
  LabelRedeclaration: _2(({ labelName }) => `Label '${labelName}' is already declared.`),
  LetInLexicalBinding: _2("'let' is not allowed to be used as a name in 'let' or 'const' declarations."),
  LineTerminatorBeforeArrow: _2("No line break is allowed before '=>'."),
  MalformedRegExpFlags: _2('Invalid regular expression flag.'),
  MissingClassName: _2('A class name is required.'),
  MissingEqInAssignment: _2("Only '=' operator can be used for specifying default value."),
  MissingSemicolon: _2('Missing semicolon.'),
  MissingPlugin: _2(
    ({ missingPlugin }) =>
      `This experimental syntax requires enabling the parser plugin: ${missingPlugin
        .map((name) => JSON.stringify(name))
        .join(', ')}.`
  ),
  MissingOneOfPlugins: _2(
    ({ missingPlugin }) =>
      `This experimental syntax requires enabling one of the following parser plugin(s): ${missingPlugin
        .map((name) => JSON.stringify(name))
        .join(', ')}.`
  ),
  MissingUnicodeEscape: _2('Expecting Unicode escape sequence \\uXXXX.'),
  MixingCoalesceWithLogical: _2('Nullish coalescing operator(??) requires parens when mixing with logical operators.'),
  ModuleAttributeDifferentFromType: _2('The only accepted module attribute is `type`.'),
  ModuleAttributeInvalidValue: _2('Only string literals are allowed as module attribute values.'),
  ModuleAttributesWithDuplicateKeys: _2(({ key }) => `Duplicate key "${key}" is not allowed in module attributes.`),
  ModuleExportNameHasLoneSurrogate: _2(
    ({ surrogateCharCode }) =>
      `An export name cannot include a lone surrogate, found '\\u${surrogateCharCode.toString(16)}'.`
  ),
  ModuleExportUndefined: _2(({ localName }) => `Export '${localName}' is not defined.`),
  MultipleDefaultsInSwitch: _2('Multiple default clauses.'),
  NewlineAfterThrow: _2('Illegal newline after throw.'),
  NoCatchOrFinally: _2('Missing catch or finally clause.'),
  NumberIdentifier: _2('Identifier directly after number.'),
  NumericSeparatorInEscapeSequence: _2(
    'Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.'
  ),
  ObsoleteAwaitStar: _2("'await*' has been removed from the async functions proposal. Use Promise.all() instead."),
  OptionalChainingNoNew: _2('Constructors in/after an Optional Chain are not allowed.'),
  OptionalChainingNoTemplate: _2('Tagged Template Literals are not allowed in optionalChain.'),
  OverrideOnConstructor: _2("'override' modifier cannot appear on a constructor declaration."),
  ParamDupe: _2('Argument name clash.'),
  PatternHasAccessor: _2("Object pattern can't contain getter or setter."),
  PatternHasMethod: _2("Object pattern can't contain methods."),
  PrivateInExpectedIn: _2(
    ({ identifierName }) =>
      `Private names are only allowed in property accesses (\`obj.#${identifierName}\`) or in \`in\` expressions (\`#${identifierName} in obj\`).`
  ),
  PrivateNameRedeclaration: _2(({ identifierName }) => `Duplicate private name #${identifierName}.`),
  RecordExpressionBarIncorrectEndSyntaxType: _2(
    "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'."
  ),
  RecordExpressionBarIncorrectStartSyntaxType: _2(
    "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'."
  ),
  RecordExpressionHashIncorrectStartSyntaxType: _2(
    "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'."
  ),
  RecordNoProto: _2("'__proto__' is not allowed in Record expressions."),
  RestTrailingComma: _2('Unexpected trailing comma after rest element.'),
  SloppyFunction: _2(
    'In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.'
  ),
  StaticPrototype: _2('Classes may not have static property named prototype.'),
  SuperNotAllowed: _2(
    "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?"
  ),
  SuperPrivateField: _2("Private fields can't be accessed on super."),
  TrailingDecorator: _2('Decorators must be attached to a class element.'),
  TupleExpressionBarIncorrectEndSyntaxType: _2(
    "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'."
  ),
  TupleExpressionBarIncorrectStartSyntaxType: _2(
    "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'."
  ),
  TupleExpressionHashIncorrectStartSyntaxType: _2(
    "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'."
  ),
  UnexpectedArgumentPlaceholder: _2('Unexpected argument placeholder.'),
  UnexpectedAwaitAfterPipelineBody: _2(
    'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.'
  ),
  UnexpectedDigitAfterHash: _2('Unexpected digit after hash token.'),
  UnexpectedImportExport: _2("'import' and 'export' may only appear at the top level."),
  UnexpectedKeyword: _2(({ keyword: keyword2 }) => `Unexpected keyword '${keyword2}'.`),
  UnexpectedLeadingDecorator: _2('Leading decorators must be attached to a class declaration.'),
  UnexpectedLexicalDeclaration: _2('Lexical declaration cannot appear in a single-statement context.'),
  UnexpectedNewTarget: _2('`new.target` can only be used in functions or class properties.'),
  UnexpectedNumericSeparator: _2('A numeric separator is only allowed between two digits.'),
  UnexpectedPrivateField: _2('Unexpected private name.'),
  UnexpectedReservedWord: _2(({ reservedWord }) => `Unexpected reserved word '${reservedWord}'.`),
  UnexpectedSuper: _2("'super' is only allowed in object methods and classes."),
  UnexpectedToken: _2(
    ({ expected, unexpected }) =>
      `Unexpected token${unexpected ? ` '${unexpected}'.` : ''}${expected ? `, expected "${expected}"` : ''}`
  ),
  UnexpectedTokenUnaryExponentiation: _2(
    'Illegal expression. Wrap left hand side or entire exponentiation in parentheses.'
  ),
  UnsupportedBind: _2('Binding should be performed on object property.'),
  UnsupportedDecoratorExport: _2('A decorated export must export a class declaration.'),
  UnsupportedDefaultExport: _2('Only expressions, functions or classes are allowed as the `default` export.'),
  UnsupportedImport: _2('`import` can only be used in `import()` or `import.meta`.'),
  UnsupportedMetaProperty: _2(
    ({ target, onlyValidPropertyName }) =>
      `The only valid meta property for ${target} is ${target}.${onlyValidPropertyName}.`
  ),
  UnsupportedParameterDecorator: _2('Decorators cannot be used to decorate parameters.'),
  UnsupportedPropertyDecorator: _2('Decorators cannot be used to decorate object literal properties.'),
  UnsupportedSuper: _2(
    "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop])."
  ),
  UnterminatedComment: _2('Unterminated comment.'),
  UnterminatedRegExp: _2('Unterminated regular expression.'),
  UnterminatedString: _2('Unterminated string constant.'),
  UnterminatedTemplate: _2('Unterminated template.'),
  VarRedeclaration: _2(({ identifierName }) => `Identifier '${identifierName}' has already been declared.`),
  YieldBindingIdentifier: _2("Can not use 'yield' as identifier inside a generator."),
  YieldInParameter: _2('Yield expression is not allowed in formal parameters.'),
  ZeroDigitNumericSeparator: _2('Numeric separator can not be used after leading 0.'),
})
var StrictModeErrors$1 = (_2) => ({
  StrictDelete: _2('Deleting local variable in strict mode.'),
  StrictEvalArguments: _2(({ referenceName }) => `Assigning to '${referenceName}' in strict mode.`),
  StrictEvalArgumentsBinding: _2(({ bindingName }) => `Binding '${bindingName}' in strict mode.`),
  StrictFunction: _2('In strict mode code, functions can only be declared at top level or inside a block.'),
  StrictNumericEscape: _2("The only valid numeric escape in strict mode is '\\0'."),
  StrictOctalLiteral: _2('Legacy octal literals are not allowed in strict mode.'),
  StrictWith: _2("'with' in strict mode."),
})
const UnparenthesizedPipeBodyDescriptions$1 = /* @__PURE__ */ new Set([
  'ArrowFunctionExpression',
  'AssignmentExpression',
  'ConditionalExpression',
  'YieldExpression',
])
var PipelineOperatorErrors$1 = (_2) => ({
  PipeBodyIsTighter: _2(
    'Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.'
  ),
  PipeTopicRequiresHackPipes: _2(
    'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.'
  ),
  PipeTopicUnbound: _2('Topic reference is unbound; it must be inside a pipe body.'),
  PipeTopicUnconfiguredToken: _2(
    ({ token }) =>
      `Invalid topic token ${token}. In order to use ${token} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${token}" }.`
  ),
  PipeTopicUnused: _2(
    'Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.'
  ),
  PipeUnparenthesizedBody: _2(
    ({ type }) =>
      `Hack-style pipe body cannot be an unparenthesized ${toNodeDescription$1({
        type,
      })}; please wrap it in parentheses.`
  ),
  PipelineBodyNoArrow: _2(
    'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.'
  ),
  PipelineBodySequenceExpression: _2('Pipeline body may not be a comma-separated sequence expression.'),
  PipelineHeadSequenceExpression: _2('Pipeline head should not be a comma-separated sequence expression.'),
  PipelineTopicUnused: _2('Pipeline is in topic style but does not use topic reference.'),
  PrimaryTopicNotAllowed: _2('Topic reference was used in a lexical context without topic binding.'),
  PrimaryTopicRequiresSmartPipeline: _2(
    'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.'
  ),
})
const _excluded$1$1 = ['toMessage']
function toParseErrorConstructor$1(_ref) {
  let { toMessage } = _ref,
    properties = _objectWithoutPropertiesLoose$3(_ref, _excluded$1$1)
  return function constructor({ loc, details }) {
    return instantiate$1(
      SyntaxError,
      Object.assign({}, properties, {
        loc,
      }),
      {
        clone(overrides = {}) {
          const loc2 = overrides.loc || {}
          return constructor({
            loc: new Position$1(
              'line' in loc2 ? loc2.line : this.loc.line,
              'column' in loc2 ? loc2.column : this.loc.column,
              'index' in loc2 ? loc2.index : this.loc.index
            ),
            details: Object.assign({}, this.details, overrides.details),
          })
        },
        details: {
          value: details,
          enumerable: false,
        },
        message: {
          get() {
            return `${toMessage(this.details)} (${this.loc.line}:${this.loc.column})`
          },
          set(value) {
            Object.defineProperty(this, 'message', {
              value,
            })
          },
        },
        pos: {
          reflect: 'loc.index',
          enumerable: true,
        },
        missingPlugin: 'missingPlugin' in details && {
          reflect: 'details.missingPlugin',
          enumerable: true,
        },
      }
    )
  }
}
function toParseErrorCredentials$1(toMessageOrMessage, credentials) {
  return Object.assign(
    {
      toMessage: typeof toMessageOrMessage === 'string' ? () => toMessageOrMessage : toMessageOrMessage,
    },
    credentials
  )
}
function ParseErrorEnum$1(argument, syntaxPlugin) {
  if (Array.isArray(argument)) {
    return (toParseErrorCredentialsMap) => ParseErrorEnum$1(toParseErrorCredentialsMap, argument[0])
  }
  const partialCredentials = argument(toParseErrorCredentials$1)
  const ParseErrorConstructors = {}
  for (const reasonCode of Object.keys(partialCredentials)) {
    ParseErrorConstructors[reasonCode] = toParseErrorConstructor$1(
      Object.assign(
        {
          code: ParseErrorCodes$1.SyntaxError,
          reasonCode,
        },
        syntaxPlugin
          ? {
              syntaxPlugin,
            }
          : {},
        partialCredentials[reasonCode]
      )
    )
  }
  return ParseErrorConstructors
}
const Errors$1 = Object.assign(
  {},
  ParseErrorEnum$1(ModuleErrors$1),
  ParseErrorEnum$1(StandardErrors$1),
  ParseErrorEnum$1(StrictModeErrors$1),
  ParseErrorEnum$1`pipelineOperator`(PipelineOperatorErrors$1)
)
const { defineProperty: defineProperty$1 } = Object
const toUnenumerable$1 = (object2, key) =>
  defineProperty$1(object2, key, {
    enumerable: false,
    value: object2[key],
  })
function toESTreeLocation$1(node2) {
  node2.loc.start && toUnenumerable$1(node2.loc.start, 'index')
  node2.loc.end && toUnenumerable$1(node2.loc.end, 'index')
  return node2
}
var estree$1 = (superClass) =>
  class extends superClass {
    parse() {
      const file2 = toESTreeLocation$1(super.parse())
      if (this.options.tokens) {
        file2.tokens = file2.tokens.map(toESTreeLocation$1)
      }
      return file2
    }
    parseRegExpLiteral({ pattern, flags }) {
      let regex = null
      try {
        regex = new RegExp(pattern, flags)
      } catch (e) {}
      const node2 = this.estreeParseLiteral(regex)
      node2.regex = {
        pattern,
        flags,
      }
      return node2
    }
    parseBigIntLiteral(value) {
      let bigInt
      try {
        bigInt = BigInt(value)
      } catch (_unused) {
        bigInt = null
      }
      const node2 = this.estreeParseLiteral(bigInt)
      node2.bigint = String(node2.value || value)
      return node2
    }
    parseDecimalLiteral(value) {
      const decimal = null
      const node2 = this.estreeParseLiteral(decimal)
      node2.decimal = String(node2.value || value)
      return node2
    }
    estreeParseLiteral(value) {
      return this.parseLiteral(value, 'Literal')
    }
    parseStringLiteral(value) {
      return this.estreeParseLiteral(value)
    }
    parseNumericLiteral(value) {
      return this.estreeParseLiteral(value)
    }
    parseNullLiteral() {
      return this.estreeParseLiteral(null)
    }
    parseBooleanLiteral(value) {
      return this.estreeParseLiteral(value)
    }
    directiveToStmt(directive2) {
      const directiveLiteral2 = directive2.value
      const stmt = this.startNodeAt(directive2.start, directive2.loc.start)
      const expression2 = this.startNodeAt(directiveLiteral2.start, directiveLiteral2.loc.start)
      expression2.value = directiveLiteral2.extra.expressionValue
      expression2.raw = directiveLiteral2.extra.raw
      stmt.expression = this.finishNodeAt(expression2, 'Literal', directiveLiteral2.loc.end)
      stmt.directive = directiveLiteral2.extra.raw.slice(1, -1)
      return this.finishNodeAt(stmt, 'ExpressionStatement', directive2.loc.end)
    }
    initFunction(node2, isAsync) {
      super.initFunction(node2, isAsync)
      node2.expression = false
    }
    checkDeclaration(node2) {
      if (node2 != null && this.isObjectProperty(node2)) {
        this.checkDeclaration(node2.value)
      } else {
        super.checkDeclaration(node2)
      }
    }
    getObjectOrClassMethodParams(method) {
      return method.value.params
    }
    isValidDirective(stmt) {
      var _stmt$expression$extr
      return (
        stmt.type === 'ExpressionStatement' &&
        stmt.expression.type === 'Literal' &&
        typeof stmt.expression.value === 'string' &&
        !((_stmt$expression$extr = stmt.expression.extra) != null && _stmt$expression$extr.parenthesized)
      )
    }
    parseBlockBody(node2, ...args) {
      super.parseBlockBody(node2, ...args)
      const directiveStatements = node2.directives.map((d2) => this.directiveToStmt(d2))
      node2.body = directiveStatements.concat(node2.body)
      delete node2.directives
    }
    pushClassMethod(classBody2, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
      this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, 'ClassMethod', true)
      if (method.typeParameters) {
        method.value.typeParameters = method.typeParameters
        delete method.typeParameters
      }
      classBody2.body.push(method)
    }
    parsePrivateName() {
      const node2 = super.parsePrivateName()
      {
        if (!this.getPluginOption('estree', 'classFeatures')) {
          return node2
        }
      }
      return this.convertPrivateNameToPrivateIdentifier(node2)
    }
    convertPrivateNameToPrivateIdentifier(node2) {
      const name = super.getPrivateNameSV(node2)
      node2 = node2
      delete node2.id
      node2.name = name
      node2.type = 'PrivateIdentifier'
      return node2
    }
    isPrivateName(node2) {
      {
        if (!this.getPluginOption('estree', 'classFeatures')) {
          return super.isPrivateName(node2)
        }
      }
      return node2.type === 'PrivateIdentifier'
    }
    getPrivateNameSV(node2) {
      {
        if (!this.getPluginOption('estree', 'classFeatures')) {
          return super.getPrivateNameSV(node2)
        }
      }
      return node2.name
    }
    parseLiteral(value, type) {
      const node2 = super.parseLiteral(value, type)
      node2.raw = node2.extra.raw
      delete node2.extra
      return node2
    }
    parseFunctionBody(node2, allowExpression, isMethod2 = false) {
      super.parseFunctionBody(node2, allowExpression, isMethod2)
      node2.expression = node2.body.type !== 'BlockStatement'
    }
    parseMethod(node2, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {
      let funcNode = this.startNode()
      funcNode.kind = node2.kind
      funcNode = super.parseMethod(funcNode, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope)
      funcNode.type = 'FunctionExpression'
      delete funcNode.kind
      node2.value = funcNode
      if (type === 'ClassPrivateMethod') {
        node2.computed = false
      }
      type = 'MethodDefinition'
      return this.finishNode(node2, type)
    }
    parseClassProperty(...args) {
      const propertyNode = super.parseClassProperty(...args)
      {
        if (!this.getPluginOption('estree', 'classFeatures')) {
          return propertyNode
        }
      }
      propertyNode.type = 'PropertyDefinition'
      return propertyNode
    }
    parseClassPrivateProperty(...args) {
      const propertyNode = super.parseClassPrivateProperty(...args)
      {
        if (!this.getPluginOption('estree', 'classFeatures')) {
          return propertyNode
        }
      }
      propertyNode.type = 'PropertyDefinition'
      propertyNode.computed = false
      return propertyNode
    }
    parseObjectMethod(prop, isGenerator, isAsync, isPattern2, isAccessor2) {
      const node2 = super.parseObjectMethod(prop, isGenerator, isAsync, isPattern2, isAccessor2)
      if (node2) {
        node2.type = 'Property'
        if (node2.kind === 'method') node2.kind = 'init'
        node2.shorthand = false
      }
      return node2
    }
    parseObjectProperty(prop, startPos, startLoc, isPattern2, refExpressionErrors) {
      const node2 = super.parseObjectProperty(prop, startPos, startLoc, isPattern2, refExpressionErrors)
      if (node2) {
        node2.kind = 'init'
        node2.type = 'Property'
      }
      return node2
    }
    isValidLVal(type, ...rest) {
      return type === 'Property' ? 'value' : super.isValidLVal(type, ...rest)
    }
    isAssignable(node2, isBinding2) {
      if (node2 != null && this.isObjectProperty(node2)) {
        return this.isAssignable(node2.value, isBinding2)
      }
      return super.isAssignable(node2, isBinding2)
    }
    toAssignable(node2, isLHS = false) {
      if (node2 != null && this.isObjectProperty(node2)) {
        const { key, value } = node2
        if (this.isPrivateName(key)) {
          this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start)
        }
        this.toAssignable(value, isLHS)
      } else {
        super.toAssignable(node2, isLHS)
      }
    }
    toAssignableObjectExpressionProp(prop) {
      if (prop.kind === 'get' || prop.kind === 'set') {
        this.raise(Errors$1.PatternHasAccessor, {
          at: prop.key,
        })
      } else if (prop.method) {
        this.raise(Errors$1.PatternHasMethod, {
          at: prop.key,
        })
      } else {
        super.toAssignableObjectExpressionProp(...arguments)
      }
    }
    finishCallExpression(node2, optional) {
      super.finishCallExpression(node2, optional)
      if (node2.callee.type === 'Import') {
        node2.type = 'ImportExpression'
        node2.source = node2.arguments[0]
        if (this.hasPlugin('importAssertions')) {
          var _node$arguments$
          node2.attributes = (_node$arguments$ = node2.arguments[1]) != null ? _node$arguments$ : null
        }
        delete node2.arguments
        delete node2.callee
      }
      return node2
    }
    toReferencedArguments(node2) {
      if (node2.type === 'ImportExpression') {
        return
      }
      super.toReferencedArguments(node2)
    }
    parseExport(node2) {
      super.parseExport(node2)
      switch (node2.type) {
        case 'ExportAllDeclaration':
          node2.exported = null
          break
        case 'ExportNamedDeclaration':
          if (node2.specifiers.length === 1 && node2.specifiers[0].type === 'ExportNamespaceSpecifier') {
            node2.type = 'ExportAllDeclaration'
            node2.exported = node2.specifiers[0].exported
            delete node2.specifiers
          }
          break
      }
      return node2
    }
    parseSubscript(base2, startPos, startLoc, noCalls, state) {
      const node2 = super.parseSubscript(base2, startPos, startLoc, noCalls, state)
      if (state.optionalChainMember) {
        if (node2.type === 'OptionalMemberExpression' || node2.type === 'OptionalCallExpression') {
          node2.type = node2.type.substring(8)
        }
        if (state.stop) {
          const chain2 = this.startNodeAtNode(node2)
          chain2.expression = node2
          return this.finishNode(chain2, 'ChainExpression')
        }
      } else if (node2.type === 'MemberExpression' || node2.type === 'CallExpression') {
        node2.optional = false
      }
      return node2
    }
    hasPropertyAsPrivateName(node2) {
      if (node2.type === 'ChainExpression') {
        node2 = node2.expression
      }
      return super.hasPropertyAsPrivateName(node2)
    }
    isOptionalChain(node2) {
      return node2.type === 'ChainExpression'
    }
    isObjectProperty(node2) {
      return node2.type === 'Property' && node2.kind === 'init' && !node2.method
    }
    isObjectMethod(node2) {
      return node2.method || node2.kind === 'get' || node2.kind === 'set'
    }
    finishNodeAt(node2, type, endLoc) {
      return toESTreeLocation$1(super.finishNodeAt(node2, type, endLoc))
    }
    resetStartLocation(node2, start, startLoc) {
      super.resetStartLocation(node2, start, startLoc)
      toESTreeLocation$1(node2)
    }
    resetEndLocation(node2, endLoc = this.state.lastTokEndLoc) {
      super.resetEndLocation(node2, endLoc)
      toESTreeLocation$1(node2)
    }
  }
class TokContext$1 {
  constructor(token, preserveSpace) {
    this.token = void 0
    this.preserveSpace = void 0
    this.token = token
    this.preserveSpace = !!preserveSpace
  }
}
const types$1 = {
  brace: new TokContext$1('{'),
  j_oTag: new TokContext$1('<tag'),
  j_cTag: new TokContext$1('</tag'),
  j_expr: new TokContext$1('<tag>...</tag>', true),
}
{
  types$1.template = new TokContext$1('`', true)
}
const beforeExpr$1 = true
const startsExpr$1 = true
const isLoop$1 = true
const isAssign$1 = true
const prefix$1 = true
const postfix$1 = true
class ExportedTokenType$1 {
  constructor(label, conf = {}) {
    this.label = void 0
    this.keyword = void 0
    this.beforeExpr = void 0
    this.startsExpr = void 0
    this.rightAssociative = void 0
    this.isLoop = void 0
    this.isAssign = void 0
    this.prefix = void 0
    this.postfix = void 0
    this.binop = void 0
    this.label = label
    this.keyword = conf.keyword
    this.beforeExpr = !!conf.beforeExpr
    this.startsExpr = !!conf.startsExpr
    this.rightAssociative = !!conf.rightAssociative
    this.isLoop = !!conf.isLoop
    this.isAssign = !!conf.isAssign
    this.prefix = !!conf.prefix
    this.postfix = !!conf.postfix
    this.binop = conf.binop != null ? conf.binop : null
    {
      this.updateContext = null
    }
  }
}
const keywords$1$1 = /* @__PURE__ */ new Map()
function createKeyword$1(name, options2 = {}) {
  options2.keyword = name
  const token = createToken$1(name, options2)
  keywords$1$1.set(name, token)
  return token
}
function createBinop$1(name, binop) {
  return createToken$1(name, {
    beforeExpr: beforeExpr$1,
    binop,
  })
}
let tokenTypeCounter$1 = -1
const tokenTypes$1 = []
const tokenLabels$1 = []
const tokenBinops$1 = []
const tokenBeforeExprs$1 = []
const tokenStartsExprs$1 = []
const tokenPrefixes$1 = []
function createToken$1(name, options2 = {}) {
  var _options$binop, _options$beforeExpr, _options$startsExpr, _options$prefix
  ++tokenTypeCounter$1
  tokenLabels$1.push(name)
  tokenBinops$1.push((_options$binop = options2.binop) != null ? _options$binop : -1)
  tokenBeforeExprs$1.push((_options$beforeExpr = options2.beforeExpr) != null ? _options$beforeExpr : false)
  tokenStartsExprs$1.push((_options$startsExpr = options2.startsExpr) != null ? _options$startsExpr : false)
  tokenPrefixes$1.push((_options$prefix = options2.prefix) != null ? _options$prefix : false)
  tokenTypes$1.push(new ExportedTokenType$1(name, options2))
  return tokenTypeCounter$1
}
function createKeywordLike$1(name, options2) {
  var _options$binop2, _options$beforeExpr2, _options$startsExpr2, _options$prefix2
  ++tokenTypeCounter$1
  keywords$1$1.set(name, tokenTypeCounter$1)
  tokenLabels$1.push(name)
  tokenBinops$1.push((_options$binop2 = options2.binop) != null ? _options$binop2 : -1)
  tokenBeforeExprs$1.push((_options$beforeExpr2 = options2.beforeExpr) != null ? _options$beforeExpr2 : false)
  tokenStartsExprs$1.push((_options$startsExpr2 = options2.startsExpr) != null ? _options$startsExpr2 : false)
  tokenPrefixes$1.push((_options$prefix2 = options2.prefix) != null ? _options$prefix2 : false)
  tokenTypes$1.push(new ExportedTokenType$1('name', options2))
  return tokenTypeCounter$1
}
const tt$1 = {
  bracketL: createToken$1('[', {
    beforeExpr: beforeExpr$1,
    startsExpr: startsExpr$1,
  }),
  bracketHashL: createToken$1('#[', {
    beforeExpr: beforeExpr$1,
    startsExpr: startsExpr$1,
  }),
  bracketBarL: createToken$1('[|', {
    beforeExpr: beforeExpr$1,
    startsExpr: startsExpr$1,
  }),
  bracketR: createToken$1(']'),
  bracketBarR: createToken$1('|]'),
  braceL: createToken$1('{', {
    beforeExpr: beforeExpr$1,
    startsExpr: startsExpr$1,
  }),
  braceBarL: createToken$1('{|', {
    beforeExpr: beforeExpr$1,
    startsExpr: startsExpr$1,
  }),
  braceHashL: createToken$1('#{', {
    beforeExpr: beforeExpr$1,
    startsExpr: startsExpr$1,
  }),
  braceR: createToken$1('}'),
  braceBarR: createToken$1('|}'),
  parenL: createToken$1('(', {
    beforeExpr: beforeExpr$1,
    startsExpr: startsExpr$1,
  }),
  parenR: createToken$1(')'),
  comma: createToken$1(',', {
    beforeExpr: beforeExpr$1,
  }),
  semi: createToken$1(';', {
    beforeExpr: beforeExpr$1,
  }),
  colon: createToken$1(':', {
    beforeExpr: beforeExpr$1,
  }),
  doubleColon: createToken$1('::', {
    beforeExpr: beforeExpr$1,
  }),
  dot: createToken$1('.'),
  question: createToken$1('?', {
    beforeExpr: beforeExpr$1,
  }),
  questionDot: createToken$1('?.'),
  arrow: createToken$1('=>', {
    beforeExpr: beforeExpr$1,
  }),
  template: createToken$1('template'),
  ellipsis: createToken$1('...', {
    beforeExpr: beforeExpr$1,
  }),
  backQuote: createToken$1('`', {
    startsExpr: startsExpr$1,
  }),
  dollarBraceL: createToken$1('${', {
    beforeExpr: beforeExpr$1,
    startsExpr: startsExpr$1,
  }),
  templateTail: createToken$1('...`', {
    startsExpr: startsExpr$1,
  }),
  templateNonTail: createToken$1('...${', {
    beforeExpr: beforeExpr$1,
    startsExpr: startsExpr$1,
  }),
  at: createToken$1('@'),
  hash: createToken$1('#', {
    startsExpr: startsExpr$1,
  }),
  interpreterDirective: createToken$1('#!...'),
  eq: createToken$1('=', {
    beforeExpr: beforeExpr$1,
    isAssign: isAssign$1,
  }),
  assign: createToken$1('_=', {
    beforeExpr: beforeExpr$1,
    isAssign: isAssign$1,
  }),
  slashAssign: createToken$1('_=', {
    beforeExpr: beforeExpr$1,
    isAssign: isAssign$1,
  }),
  xorAssign: createToken$1('_=', {
    beforeExpr: beforeExpr$1,
    isAssign: isAssign$1,
  }),
  moduloAssign: createToken$1('_=', {
    beforeExpr: beforeExpr$1,
    isAssign: isAssign$1,
  }),
  incDec: createToken$1('++/--', {
    prefix: prefix$1,
    postfix: postfix$1,
    startsExpr: startsExpr$1,
  }),
  bang: createToken$1('!', {
    beforeExpr: beforeExpr$1,
    prefix: prefix$1,
    startsExpr: startsExpr$1,
  }),
  tilde: createToken$1('~', {
    beforeExpr: beforeExpr$1,
    prefix: prefix$1,
    startsExpr: startsExpr$1,
  }),
  doubleCaret: createToken$1('^^', {
    startsExpr: startsExpr$1,
  }),
  doubleAt: createToken$1('@@', {
    startsExpr: startsExpr$1,
  }),
  pipeline: createBinop$1('|>', 0),
  nullishCoalescing: createBinop$1('??', 1),
  logicalOR: createBinop$1('||', 1),
  logicalAND: createBinop$1('&&', 2),
  bitwiseOR: createBinop$1('|', 3),
  bitwiseXOR: createBinop$1('^', 4),
  bitwiseAND: createBinop$1('&', 5),
  equality: createBinop$1('==/!=/===/!==', 6),
  lt: createBinop$1('</>/<=/>=', 7),
  gt: createBinop$1('</>/<=/>=', 7),
  relational: createBinop$1('</>/<=/>=', 7),
  bitShift: createBinop$1('<</>>/>>>', 8),
  bitShiftL: createBinop$1('<</>>/>>>', 8),
  bitShiftR: createBinop$1('<</>>/>>>', 8),
  plusMin: createToken$1('+/-', {
    beforeExpr: beforeExpr$1,
    binop: 9,
    prefix: prefix$1,
    startsExpr: startsExpr$1,
  }),
  modulo: createToken$1('%', {
    binop: 10,
    startsExpr: startsExpr$1,
  }),
  star: createToken$1('*', {
    binop: 10,
  }),
  slash: createBinop$1('/', 10),
  exponent: createToken$1('**', {
    beforeExpr: beforeExpr$1,
    binop: 11,
    rightAssociative: true,
  }),
  _in: createKeyword$1('in', {
    beforeExpr: beforeExpr$1,
    binop: 7,
  }),
  _instanceof: createKeyword$1('instanceof', {
    beforeExpr: beforeExpr$1,
    binop: 7,
  }),
  _break: createKeyword$1('break'),
  _case: createKeyword$1('case', {
    beforeExpr: beforeExpr$1,
  }),
  _catch: createKeyword$1('catch'),
  _continue: createKeyword$1('continue'),
  _debugger: createKeyword$1('debugger'),
  _default: createKeyword$1('default', {
    beforeExpr: beforeExpr$1,
  }),
  _else: createKeyword$1('else', {
    beforeExpr: beforeExpr$1,
  }),
  _finally: createKeyword$1('finally'),
  _function: createKeyword$1('function', {
    startsExpr: startsExpr$1,
  }),
  _if: createKeyword$1('if'),
  _return: createKeyword$1('return', {
    beforeExpr: beforeExpr$1,
  }),
  _switch: createKeyword$1('switch'),
  _throw: createKeyword$1('throw', {
    beforeExpr: beforeExpr$1,
    prefix: prefix$1,
    startsExpr: startsExpr$1,
  }),
  _try: createKeyword$1('try'),
  _var: createKeyword$1('var'),
  _const: createKeyword$1('const'),
  _with: createKeyword$1('with'),
  _new: createKeyword$1('new', {
    beforeExpr: beforeExpr$1,
    startsExpr: startsExpr$1,
  }),
  _this: createKeyword$1('this', {
    startsExpr: startsExpr$1,
  }),
  _super: createKeyword$1('super', {
    startsExpr: startsExpr$1,
  }),
  _class: createKeyword$1('class', {
    startsExpr: startsExpr$1,
  }),
  _extends: createKeyword$1('extends', {
    beforeExpr: beforeExpr$1,
  }),
  _export: createKeyword$1('export'),
  _import: createKeyword$1('import', {
    startsExpr: startsExpr$1,
  }),
  _null: createKeyword$1('null', {
    startsExpr: startsExpr$1,
  }),
  _true: createKeyword$1('true', {
    startsExpr: startsExpr$1,
  }),
  _false: createKeyword$1('false', {
    startsExpr: startsExpr$1,
  }),
  _typeof: createKeyword$1('typeof', {
    beforeExpr: beforeExpr$1,
    prefix: prefix$1,
    startsExpr: startsExpr$1,
  }),
  _void: createKeyword$1('void', {
    beforeExpr: beforeExpr$1,
    prefix: prefix$1,
    startsExpr: startsExpr$1,
  }),
  _delete: createKeyword$1('delete', {
    beforeExpr: beforeExpr$1,
    prefix: prefix$1,
    startsExpr: startsExpr$1,
  }),
  _do: createKeyword$1('do', {
    isLoop: isLoop$1,
    beforeExpr: beforeExpr$1,
  }),
  _for: createKeyword$1('for', {
    isLoop: isLoop$1,
  }),
  _while: createKeyword$1('while', {
    isLoop: isLoop$1,
  }),
  _as: createKeywordLike$1('as', {
    startsExpr: startsExpr$1,
  }),
  _assert: createKeywordLike$1('assert', {
    startsExpr: startsExpr$1,
  }),
  _async: createKeywordLike$1('async', {
    startsExpr: startsExpr$1,
  }),
  _await: createKeywordLike$1('await', {
    startsExpr: startsExpr$1,
  }),
  _from: createKeywordLike$1('from', {
    startsExpr: startsExpr$1,
  }),
  _get: createKeywordLike$1('get', {
    startsExpr: startsExpr$1,
  }),
  _let: createKeywordLike$1('let', {
    startsExpr: startsExpr$1,
  }),
  _meta: createKeywordLike$1('meta', {
    startsExpr: startsExpr$1,
  }),
  _of: createKeywordLike$1('of', {
    startsExpr: startsExpr$1,
  }),
  _sent: createKeywordLike$1('sent', {
    startsExpr: startsExpr$1,
  }),
  _set: createKeywordLike$1('set', {
    startsExpr: startsExpr$1,
  }),
  _static: createKeywordLike$1('static', {
    startsExpr: startsExpr$1,
  }),
  _yield: createKeywordLike$1('yield', {
    startsExpr: startsExpr$1,
  }),
  _asserts: createKeywordLike$1('asserts', {
    startsExpr: startsExpr$1,
  }),
  _checks: createKeywordLike$1('checks', {
    startsExpr: startsExpr$1,
  }),
  _exports: createKeywordLike$1('exports', {
    startsExpr: startsExpr$1,
  }),
  _global: createKeywordLike$1('global', {
    startsExpr: startsExpr$1,
  }),
  _implements: createKeywordLike$1('implements', {
    startsExpr: startsExpr$1,
  }),
  _intrinsic: createKeywordLike$1('intrinsic', {
    startsExpr: startsExpr$1,
  }),
  _infer: createKeywordLike$1('infer', {
    startsExpr: startsExpr$1,
  }),
  _is: createKeywordLike$1('is', {
    startsExpr: startsExpr$1,
  }),
  _mixins: createKeywordLike$1('mixins', {
    startsExpr: startsExpr$1,
  }),
  _proto: createKeywordLike$1('proto', {
    startsExpr: startsExpr$1,
  }),
  _require: createKeywordLike$1('require', {
    startsExpr: startsExpr$1,
  }),
  _keyof: createKeywordLike$1('keyof', {
    startsExpr: startsExpr$1,
  }),
  _readonly: createKeywordLike$1('readonly', {
    startsExpr: startsExpr$1,
  }),
  _unique: createKeywordLike$1('unique', {
    startsExpr: startsExpr$1,
  }),
  _abstract: createKeywordLike$1('abstract', {
    startsExpr: startsExpr$1,
  }),
  _declare: createKeywordLike$1('declare', {
    startsExpr: startsExpr$1,
  }),
  _enum: createKeywordLike$1('enum', {
    startsExpr: startsExpr$1,
  }),
  _module: createKeywordLike$1('module', {
    startsExpr: startsExpr$1,
  }),
  _namespace: createKeywordLike$1('namespace', {
    startsExpr: startsExpr$1,
  }),
  _interface: createKeywordLike$1('interface', {
    startsExpr: startsExpr$1,
  }),
  _type: createKeywordLike$1('type', {
    startsExpr: startsExpr$1,
  }),
  _opaque: createKeywordLike$1('opaque', {
    startsExpr: startsExpr$1,
  }),
  name: createToken$1('name', {
    startsExpr: startsExpr$1,
  }),
  string: createToken$1('string', {
    startsExpr: startsExpr$1,
  }),
  num: createToken$1('num', {
    startsExpr: startsExpr$1,
  }),
  bigint: createToken$1('bigint', {
    startsExpr: startsExpr$1,
  }),
  decimal: createToken$1('decimal', {
    startsExpr: startsExpr$1,
  }),
  regexp: createToken$1('regexp', {
    startsExpr: startsExpr$1,
  }),
  privateName: createToken$1('#name', {
    startsExpr: startsExpr$1,
  }),
  eof: createToken$1('eof'),
  jsxName: createToken$1('jsxName'),
  jsxText: createToken$1('jsxText', {
    beforeExpr: true,
  }),
  jsxTagStart: createToken$1('jsxTagStart', {
    startsExpr: true,
  }),
  jsxTagEnd: createToken$1('jsxTagEnd'),
  placeholder: createToken$1('%%', {
    startsExpr: true,
  }),
}
function tokenIsIdentifier$1(token) {
  return token >= 93 && token <= 128
}
function tokenKeywordOrIdentifierIsKeyword$1(token) {
  return token <= 92
}
function tokenIsKeywordOrIdentifier$1(token) {
  return token >= 58 && token <= 128
}
function tokenIsLiteralPropertyName$1(token) {
  return token >= 58 && token <= 132
}
function tokenComesBeforeExpression$1(token) {
  return tokenBeforeExprs$1[token]
}
function tokenCanStartExpression$1(token) {
  return tokenStartsExprs$1[token]
}
function tokenIsAssignment$1(token) {
  return token >= 29 && token <= 33
}
function tokenIsFlowInterfaceOrTypeOrOpaque$1(token) {
  return token >= 125 && token <= 127
}
function tokenIsLoop$1(token) {
  return token >= 90 && token <= 92
}
function tokenIsKeyword$1(token) {
  return token >= 58 && token <= 92
}
function tokenIsOperator$1(token) {
  return token >= 39 && token <= 59
}
function tokenIsPostfix$1(token) {
  return token === 34
}
function tokenIsPrefix$1(token) {
  return tokenPrefixes$1[token]
}
function tokenIsTSTypeOperator$1(token) {
  return token >= 117 && token <= 119
}
function tokenIsTSDeclarationStart$1(token) {
  return token >= 120 && token <= 126
}
function tokenLabelName$1(token) {
  return tokenLabels$1[token]
}
function tokenOperatorPrecedence$1(token) {
  return tokenBinops$1[token]
}
function tokenIsBinaryOperator$1(token) {
  return tokenBinops$1[token] !== -1
}
function tokenIsRightAssociative$1(token) {
  return token === 57
}
function tokenIsTemplate$1(token) {
  return token >= 24 && token <= 25
}
function getExportedToken$1(token) {
  return tokenTypes$1[token]
}
{
  tokenTypes$1[8].updateContext = (context2) => {
    context2.pop()
  }
  tokenTypes$1[5].updateContext =
    tokenTypes$1[7].updateContext =
    tokenTypes$1[23].updateContext =
      (context2) => {
        context2.push(types$1.brace)
      }
  tokenTypes$1[22].updateContext = (context2) => {
    if (context2[context2.length - 1] === types$1.template) {
      context2.pop()
    } else {
      context2.push(types$1.template)
    }
  }
  tokenTypes$1[138].updateContext = (context2) => {
    context2.push(types$1.j_expr, types$1.j_oTag)
  }
}
let nonASCIIidentifierStartChars$1 =
  '\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC'
let nonASCIIidentifierChars$1 =
  '\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F'
const nonASCIIidentifierStart$1 = new RegExp('[' + nonASCIIidentifierStartChars$1 + ']')
const nonASCIIidentifier$1 = new RegExp('[' + nonASCIIidentifierStartChars$1 + nonASCIIidentifierChars$1 + ']')
nonASCIIidentifierStartChars$1 = nonASCIIidentifierChars$1 = null
const astralIdentifierStartCodes$1 = [
  0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7,
  2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11,
  7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7,
  1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50,
  14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30,
  0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1,
  3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21,
  0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0,
  2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26,
  5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1070, 4050, 582, 8634, 568, 8, 30,
  18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8,
  8936, 3, 2, 6, 2, 1, 2, 290, 46, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3,
  3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2,
  30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 482, 44, 11, 6, 17, 0, 322, 29, 19, 43, 1269, 6, 2, 3, 2, 1, 2,
  14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2,
  1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421,
  42719, 33, 4152, 8, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938,
]
const astralIdentifierCodes$1 = [
  509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 50, 3, 123,
  2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83,
  11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9,
  214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9,
  120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1,
  2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0,
  12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23,
  4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 357, 0, 62, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719,
  239,
]
function isInAstralSet$1(code2, set) {
  let pos = 65536
  for (let i = 0, length = set.length; i < length; i += 2) {
    pos += set[i]
    if (pos > code2) return false
    pos += set[i + 1]
    if (pos >= code2) return true
  }
  return false
}
function isIdentifierStart$1(code2) {
  if (code2 < 65) return code2 === 36
  if (code2 <= 90) return true
  if (code2 < 97) return code2 === 95
  if (code2 <= 122) return true
  if (code2 <= 65535) {
    return code2 >= 170 && nonASCIIidentifierStart$1.test(String.fromCharCode(code2))
  }
  return isInAstralSet$1(code2, astralIdentifierStartCodes$1)
}
function isIdentifierChar$1(code2) {
  if (code2 < 48) return code2 === 36
  if (code2 < 58) return true
  if (code2 < 65) return false
  if (code2 <= 90) return true
  if (code2 < 97) return code2 === 95
  if (code2 <= 122) return true
  if (code2 <= 65535) {
    return code2 >= 170 && nonASCIIidentifier$1.test(String.fromCharCode(code2))
  }
  return isInAstralSet$1(code2, astralIdentifierStartCodes$1) || isInAstralSet$1(code2, astralIdentifierCodes$1)
}
const reservedWords$1 = {
  keyword: [
    'break',
    'case',
    'catch',
    'continue',
    'debugger',
    'default',
    'do',
    'else',
    'finally',
    'for',
    'function',
    'if',
    'return',
    'switch',
    'throw',
    'try',
    'var',
    'const',
    'while',
    'with',
    'new',
    'this',
    'super',
    'class',
    'extends',
    'export',
    'import',
    'null',
    'true',
    'false',
    'in',
    'instanceof',
    'typeof',
    'void',
    'delete',
  ],
  strict: ['implements', 'interface', 'let', 'package', 'private', 'protected', 'public', 'static', 'yield'],
  strictBind: ['eval', 'arguments'],
}
const keywords$2 = new Set(reservedWords$1.keyword)
const reservedWordsStrictSet$1 = new Set(reservedWords$1.strict)
const reservedWordsStrictBindSet$1 = new Set(reservedWords$1.strictBind)
function isReservedWord$1(word, inModule) {
  return (inModule && word === 'await') || word === 'enum'
}
function isStrictReservedWord$1(word, inModule) {
  return isReservedWord$1(word, inModule) || reservedWordsStrictSet$1.has(word)
}
function isStrictBindOnlyReservedWord$1(word) {
  return reservedWordsStrictBindSet$1.has(word)
}
function isStrictBindReservedWord$1(word, inModule) {
  return isStrictReservedWord$1(word, inModule) || isStrictBindOnlyReservedWord$1(word)
}
function isKeyword$1(word) {
  return keywords$2.has(word)
}
function isIteratorStart$1(current, next, next2) {
  return current === 64 && next === 64 && isIdentifierStart$1(next2)
}
const reservedWordLikeSet$1 = /* @__PURE__ */ new Set([
  'break',
  'case',
  'catch',
  'continue',
  'debugger',
  'default',
  'do',
  'else',
  'finally',
  'for',
  'function',
  'if',
  'return',
  'switch',
  'throw',
  'try',
  'var',
  'const',
  'while',
  'with',
  'new',
  'this',
  'super',
  'class',
  'extends',
  'export',
  'import',
  'null',
  'true',
  'false',
  'in',
  'instanceof',
  'typeof',
  'void',
  'delete',
  'implements',
  'interface',
  'let',
  'package',
  'private',
  'protected',
  'public',
  'static',
  'yield',
  'eval',
  'arguments',
  'enum',
  'await',
])
function canBeReservedWord$1(word) {
  return reservedWordLikeSet$1.has(word)
}
const SCOPE_OTHER$1 = 0,
  SCOPE_PROGRAM$1 = 1,
  SCOPE_FUNCTION$1 = 2,
  SCOPE_ARROW$1 = 4,
  SCOPE_SIMPLE_CATCH$1 = 8,
  SCOPE_SUPER$1 = 16,
  SCOPE_DIRECT_SUPER$1 = 32,
  SCOPE_CLASS$1 = 64,
  SCOPE_STATIC_BLOCK$1 = 128,
  SCOPE_TS_MODULE$1 = 256,
  SCOPE_VAR$1 = SCOPE_PROGRAM$1 | SCOPE_FUNCTION$1 | SCOPE_TS_MODULE$1
const BIND_KIND_VALUE$1 = 1,
  BIND_KIND_TYPE$1 = 2,
  BIND_SCOPE_VAR$1 = 4,
  BIND_SCOPE_LEXICAL$1 = 8,
  BIND_SCOPE_FUNCTION$1 = 16,
  BIND_FLAGS_NONE$1 = 64,
  BIND_FLAGS_CLASS$1 = 128,
  BIND_FLAGS_TS_ENUM$1 = 256,
  BIND_FLAGS_TS_CONST_ENUM$1 = 512,
  BIND_FLAGS_TS_EXPORT_ONLY$1 = 1024,
  BIND_FLAGS_FLOW_DECLARE_FN$1 = 2048
const BIND_CLASS$1 = BIND_KIND_VALUE$1 | BIND_KIND_TYPE$1 | BIND_SCOPE_LEXICAL$1 | BIND_FLAGS_CLASS$1,
  BIND_LEXICAL$1 = BIND_KIND_VALUE$1 | 0 | BIND_SCOPE_LEXICAL$1 | 0,
  BIND_VAR$1 = BIND_KIND_VALUE$1 | 0 | BIND_SCOPE_VAR$1 | 0,
  BIND_FUNCTION$1 = BIND_KIND_VALUE$1 | 0 | BIND_SCOPE_FUNCTION$1 | 0,
  BIND_TS_INTERFACE$1 = 0 | BIND_KIND_TYPE$1 | 0 | BIND_FLAGS_CLASS$1,
  BIND_TS_TYPE$1 = 0 | BIND_KIND_TYPE$1 | 0 | 0,
  BIND_TS_ENUM$1 = BIND_KIND_VALUE$1 | BIND_KIND_TYPE$1 | BIND_SCOPE_LEXICAL$1 | BIND_FLAGS_TS_ENUM$1,
  BIND_TS_AMBIENT$1 = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY$1,
  BIND_NONE$1 = 0 | 0 | 0 | BIND_FLAGS_NONE$1,
  BIND_OUTSIDE$1 = BIND_KIND_VALUE$1 | 0 | 0 | BIND_FLAGS_NONE$1,
  BIND_TS_CONST_ENUM$1 = BIND_TS_ENUM$1 | BIND_FLAGS_TS_CONST_ENUM$1,
  BIND_TS_NAMESPACE$1 = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY$1,
  BIND_FLOW_DECLARE_FN$1 = BIND_FLAGS_FLOW_DECLARE_FN$1
const CLASS_ELEMENT_FLAG_STATIC$1 = 4,
  CLASS_ELEMENT_KIND_GETTER$1 = 2,
  CLASS_ELEMENT_KIND_SETTER$1 = 1,
  CLASS_ELEMENT_KIND_ACCESSOR$1 = CLASS_ELEMENT_KIND_GETTER$1 | CLASS_ELEMENT_KIND_SETTER$1
const CLASS_ELEMENT_STATIC_GETTER$1 = CLASS_ELEMENT_KIND_GETTER$1 | CLASS_ELEMENT_FLAG_STATIC$1,
  CLASS_ELEMENT_STATIC_SETTER$1 = CLASS_ELEMENT_KIND_SETTER$1 | CLASS_ELEMENT_FLAG_STATIC$1,
  CLASS_ELEMENT_INSTANCE_GETTER$1 = CLASS_ELEMENT_KIND_GETTER$1,
  CLASS_ELEMENT_INSTANCE_SETTER$1 = CLASS_ELEMENT_KIND_SETTER$1,
  CLASS_ELEMENT_OTHER$1 = 0
class BaseParser$1 {
  constructor() {
    this.sawUnambiguousESM = false
    this.ambiguousScriptDifferentAst = false
  }
  hasPlugin(pluginConfig) {
    if (typeof pluginConfig === 'string') {
      return this.plugins.has(pluginConfig)
    } else {
      const [pluginName, pluginOptions] = pluginConfig
      if (!this.hasPlugin(pluginName)) {
        return false
      }
      const actualOptions = this.plugins.get(pluginName)
      for (const key of Object.keys(pluginOptions)) {
        if ((actualOptions == null ? void 0 : actualOptions[key]) !== pluginOptions[key]) {
          return false
        }
      }
      return true
    }
  }
  getPluginOption(plugin, name) {
    var _this$plugins$get
    return (_this$plugins$get = this.plugins.get(plugin)) == null ? void 0 : _this$plugins$get[name]
  }
}
function setTrailingComments$1(node2, comments2) {
  if (node2.trailingComments === void 0) {
    node2.trailingComments = comments2
  } else {
    node2.trailingComments.unshift(...comments2)
  }
}
function setLeadingComments$1(node2, comments2) {
  if (node2.leadingComments === void 0) {
    node2.leadingComments = comments2
  } else {
    node2.leadingComments.unshift(...comments2)
  }
}
function setInnerComments$1(node2, comments2) {
  if (node2.innerComments === void 0) {
    node2.innerComments = comments2
  } else {
    node2.innerComments.unshift(...comments2)
  }
}
function adjustInnerComments$1(node2, elements, commentWS) {
  let lastElement = null
  let i = elements.length
  while (lastElement === null && i > 0) {
    lastElement = elements[--i]
  }
  if (lastElement === null || lastElement.start > commentWS.start) {
    setInnerComments$1(node2, commentWS.comments)
  } else {
    setTrailingComments$1(lastElement, commentWS.comments)
  }
}
class CommentsParser$1 extends BaseParser$1 {
  addComment(comment) {
    if (this.filename) comment.loc.filename = this.filename
    this.state.comments.push(comment)
  }
  processComment(node2) {
    const { commentStack } = this.state
    const commentStackLength = commentStack.length
    if (commentStackLength === 0) return
    let i = commentStackLength - 1
    const lastCommentWS = commentStack[i]
    if (lastCommentWS.start === node2.end) {
      lastCommentWS.leadingNode = node2
      i--
    }
    const { start: nodeStart } = node2
    for (; i >= 0; i--) {
      const commentWS = commentStack[i]
      const commentEnd = commentWS.end
      if (commentEnd > nodeStart) {
        commentWS.containingNode = node2
        this.finalizeComment(commentWS)
        commentStack.splice(i, 1)
      } else {
        if (commentEnd === nodeStart) {
          commentWS.trailingNode = node2
        }
        break
      }
    }
  }
  finalizeComment(commentWS) {
    const { comments: comments2 } = commentWS
    if (commentWS.leadingNode !== null || commentWS.trailingNode !== null) {
      if (commentWS.leadingNode !== null) {
        setTrailingComments$1(commentWS.leadingNode, comments2)
      }
      if (commentWS.trailingNode !== null) {
        setLeadingComments$1(commentWS.trailingNode, comments2)
      }
    } else {
      const { containingNode: node2, start: commentStart } = commentWS
      if (this.input.charCodeAt(commentStart - 1) === 44) {
        switch (node2.type) {
          case 'ObjectExpression':
          case 'ObjectPattern':
          case 'RecordExpression':
            adjustInnerComments$1(node2, node2.properties, commentWS)
            break
          case 'CallExpression':
          case 'OptionalCallExpression':
            adjustInnerComments$1(node2, node2.arguments, commentWS)
            break
          case 'FunctionDeclaration':
          case 'FunctionExpression':
          case 'ArrowFunctionExpression':
          case 'ObjectMethod':
          case 'ClassMethod':
          case 'ClassPrivateMethod':
            adjustInnerComments$1(node2, node2.params, commentWS)
            break
          case 'ArrayExpression':
          case 'ArrayPattern':
          case 'TupleExpression':
            adjustInnerComments$1(node2, node2.elements, commentWS)
            break
          case 'ExportNamedDeclaration':
          case 'ImportDeclaration':
            adjustInnerComments$1(node2, node2.specifiers, commentWS)
            break
          default: {
            setInnerComments$1(node2, comments2)
          }
        }
      } else {
        setInnerComments$1(node2, comments2)
      }
    }
  }
  finalizeRemainingComments() {
    const { commentStack } = this.state
    for (let i = commentStack.length - 1; i >= 0; i--) {
      this.finalizeComment(commentStack[i])
    }
    this.state.commentStack = []
  }
  resetPreviousNodeTrailingComments(node2) {
    const { commentStack } = this.state
    const { length } = commentStack
    if (length === 0) return
    const commentWS = commentStack[length - 1]
    if (commentWS.leadingNode === node2) {
      commentWS.leadingNode = null
    }
  }
  takeSurroundingComments(node2, start, end) {
    const { commentStack } = this.state
    const commentStackLength = commentStack.length
    if (commentStackLength === 0) return
    let i = commentStackLength - 1
    for (; i >= 0; i--) {
      const commentWS = commentStack[i]
      const commentEnd = commentWS.end
      const commentStart = commentWS.start
      if (commentStart === end) {
        commentWS.leadingNode = node2
      } else if (commentEnd === start) {
        commentWS.trailingNode = node2
      } else if (commentEnd < start) {
        break
      }
    }
  }
}
const lineBreak$1 = /\r\n?|[\n\u2028\u2029]/
const lineBreakG$1 = new RegExp(lineBreak$1.source, 'g')
function isNewLine$1(code2) {
  switch (code2) {
    case 10:
    case 13:
    case 8232:
    case 8233:
      return true
    default:
      return false
  }
}
const skipWhiteSpace$1 = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g
const skipWhiteSpaceInLine$1 = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/y
const skipWhiteSpaceToLineBreak$1 = new RegExp(
  '(?=(' + skipWhiteSpaceInLine$1.source + '))\\1' + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source,
  'y'
)
function isWhitespace$1(code2) {
  switch (code2) {
    case 9:
    case 11:
    case 12:
    case 32:
    case 160:
    case 5760:
    case 8192:
    case 8193:
    case 8194:
    case 8195:
    case 8196:
    case 8197:
    case 8198:
    case 8199:
    case 8200:
    case 8201:
    case 8202:
    case 8239:
    case 8287:
    case 12288:
    case 65279:
      return true
    default:
      return false
  }
}
class State$1 {
  constructor() {
    this.strict = void 0
    this.curLine = void 0
    this.lineStart = void 0
    this.startLoc = void 0
    this.endLoc = void 0
    this.errors = []
    this.potentialArrowAt = -1
    this.noArrowAt = []
    this.noArrowParamsConversionAt = []
    this.maybeInArrowParameters = false
    this.inType = false
    this.noAnonFunctionType = false
    this.hasFlowComment = false
    this.isAmbientContext = false
    this.inAbstractClass = false
    this.inDisallowConditionalTypesContext = false
    this.topicContext = {
      maxNumOfResolvableTopics: 0,
      maxTopicIndex: null,
    }
    this.soloAwait = false
    this.inFSharpPipelineDirectBody = false
    this.labels = []
    this.decoratorStack = [[]]
    this.comments = []
    this.commentStack = []
    this.pos = 0
    this.type = 135
    this.value = null
    this.start = 0
    this.end = 0
    this.lastTokEndLoc = null
    this.lastTokStartLoc = null
    this.lastTokStart = 0
    this.context = [types$1.brace]
    this.canStartJSXElement = true
    this.containsEsc = false
    this.strictErrors = /* @__PURE__ */ new Map()
    this.tokensLength = 0
  }
  init({ strictMode, sourceType, startLine, startColumn }) {
    this.strict = strictMode === false ? false : strictMode === true ? true : sourceType === 'module'
    this.curLine = startLine
    this.lineStart = -startColumn
    this.startLoc = this.endLoc = new Position$1(startLine, startColumn, 0)
  }
  curPosition() {
    return new Position$1(this.curLine, this.pos - this.lineStart, this.pos)
  }
  clone(skipArrays) {
    const state = new State$1()
    const keys = Object.keys(this)
    for (let i = 0, length = keys.length; i < length; i++) {
      const key = keys[i]
      let val = this[key]
      if (!skipArrays && Array.isArray(val)) {
        val = val.slice()
      }
      state[key] = val
    }
    return state
  }
}
const _excluded$4 = ['at'],
  _excluded2$1 = ['at']
var _isDigit$1 = function isDigit(code2) {
  return code2 >= 48 && code2 <= 57
}
const VALID_REGEX_FLAGS$1 = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118])
const forbiddenNumericSeparatorSiblings$1 = {
  decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
  hex: /* @__PURE__ */ new Set([46, 88, 95, 120]),
}
const isAllowedNumericSeparatorSibling$1 = {
  bin: (ch) => ch === 48 || ch === 49,
  oct: (ch) => ch >= 48 && ch <= 55,
  dec: (ch) => ch >= 48 && ch <= 57,
  hex: (ch) => (ch >= 48 && ch <= 57) || (ch >= 65 && ch <= 70) || (ch >= 97 && ch <= 102),
}
class Token$1 {
  constructor(state) {
    this.type = state.type
    this.value = state.value
    this.start = state.start
    this.end = state.end
    this.loc = new SourceLocation$1(state.startLoc, state.endLoc)
  }
}
class Tokenizer$1 extends CommentsParser$1 {
  constructor(options2, input) {
    super()
    this.isLookahead = void 0
    this.tokens = []
    this.state = new State$1()
    this.state.init(options2)
    this.input = input
    this.length = input.length
    this.isLookahead = false
  }
  pushToken(token) {
    this.tokens.length = this.state.tokensLength
    this.tokens.push(token)
    ++this.state.tokensLength
  }
  next() {
    this.checkKeywordEscapes()
    if (this.options.tokens) {
      this.pushToken(new Token$1(this.state))
    }
    this.state.lastTokStart = this.state.start
    this.state.lastTokEndLoc = this.state.endLoc
    this.state.lastTokStartLoc = this.state.startLoc
    this.nextToken()
  }
  eat(type) {
    if (this.match(type)) {
      this.next()
      return true
    } else {
      return false
    }
  }
  match(type) {
    return this.state.type === type
  }
  createLookaheadState(state) {
    return {
      pos: state.pos,
      value: null,
      type: state.type,
      start: state.start,
      end: state.end,
      context: [this.curContext()],
      inType: state.inType,
      startLoc: state.startLoc,
      lastTokEndLoc: state.lastTokEndLoc,
      curLine: state.curLine,
      lineStart: state.lineStart,
      curPosition: state.curPosition,
    }
  }
  lookahead() {
    const old = this.state
    this.state = this.createLookaheadState(old)
    this.isLookahead = true
    this.nextToken()
    this.isLookahead = false
    const curr = this.state
    this.state = old
    return curr
  }
  nextTokenStart() {
    return this.nextTokenStartSince(this.state.pos)
  }
  nextTokenStartSince(pos) {
    skipWhiteSpace$1.lastIndex = pos
    return skipWhiteSpace$1.test(this.input) ? skipWhiteSpace$1.lastIndex : pos
  }
  lookaheadCharCode() {
    return this.input.charCodeAt(this.nextTokenStart())
  }
  codePointAtPos(pos) {
    let cp = this.input.charCodeAt(pos)
    if ((cp & 64512) === 55296 && ++pos < this.input.length) {
      const trail = this.input.charCodeAt(pos)
      if ((trail & 64512) === 56320) {
        cp = 65536 + ((cp & 1023) << 10) + (trail & 1023)
      }
    }
    return cp
  }
  setStrict(strict) {
    this.state.strict = strict
    if (strict) {
      this.state.strictErrors.forEach(([toParseError, at]) =>
        this.raise(toParseError, {
          at,
        })
      )
      this.state.strictErrors.clear()
    }
  }
  curContext() {
    return this.state.context[this.state.context.length - 1]
  }
  nextToken() {
    this.skipSpace()
    this.state.start = this.state.pos
    if (!this.isLookahead) this.state.startLoc = this.state.curPosition()
    if (this.state.pos >= this.length) {
      this.finishToken(135)
      return
    }
    this.getTokenFromCode(this.codePointAtPos(this.state.pos))
  }
  skipBlockComment() {
    let startLoc
    if (!this.isLookahead) startLoc = this.state.curPosition()
    const start = this.state.pos
    const end = this.input.indexOf('*/', start + 2)
    if (end === -1) {
      throw this.raise(Errors$1.UnterminatedComment, {
        at: this.state.curPosition(),
      })
    }
    this.state.pos = end + 2
    lineBreakG$1.lastIndex = start + 2
    while (lineBreakG$1.test(this.input) && lineBreakG$1.lastIndex <= end) {
      ++this.state.curLine
      this.state.lineStart = lineBreakG$1.lastIndex
    }
    if (this.isLookahead) return
    const comment = {
      type: 'CommentBlock',
      value: this.input.slice(start + 2, end),
      start,
      end: end + 2,
      loc: new SourceLocation$1(startLoc, this.state.curPosition()),
    }
    if (this.options.tokens) this.pushToken(comment)
    return comment
  }
  skipLineComment(startSkip) {
    const start = this.state.pos
    let startLoc
    if (!this.isLookahead) startLoc = this.state.curPosition()
    let ch = this.input.charCodeAt((this.state.pos += startSkip))
    if (this.state.pos < this.length) {
      while (!isNewLine$1(ch) && ++this.state.pos < this.length) {
        ch = this.input.charCodeAt(this.state.pos)
      }
    }
    if (this.isLookahead) return
    const end = this.state.pos
    const value = this.input.slice(start + startSkip, end)
    const comment = {
      type: 'CommentLine',
      value,
      start,
      end,
      loc: new SourceLocation$1(startLoc, this.state.curPosition()),
    }
    if (this.options.tokens) this.pushToken(comment)
    return comment
  }
  skipSpace() {
    const spaceStart = this.state.pos
    const comments2 = []
    loop: while (this.state.pos < this.length) {
      const ch = this.input.charCodeAt(this.state.pos)
      switch (ch) {
        case 32:
        case 160:
        case 9:
          ++this.state.pos
          break
        case 13:
          if (this.input.charCodeAt(this.state.pos + 1) === 10) {
            ++this.state.pos
          }
        case 10:
        case 8232:
        case 8233:
          ++this.state.pos
          ++this.state.curLine
          this.state.lineStart = this.state.pos
          break
        case 47:
          switch (this.input.charCodeAt(this.state.pos + 1)) {
            case 42: {
              const comment = this.skipBlockComment()
              if (comment !== void 0) {
                this.addComment(comment)
                if (this.options.attachComment) comments2.push(comment)
              }
              break
            }
            case 47: {
              const comment = this.skipLineComment(2)
              if (comment !== void 0) {
                this.addComment(comment)
                if (this.options.attachComment) comments2.push(comment)
              }
              break
            }
            default:
              break loop
          }
          break
        default:
          if (isWhitespace$1(ch)) {
            ++this.state.pos
          } else if (ch === 45 && !this.inModule) {
            const pos = this.state.pos
            if (
              this.input.charCodeAt(pos + 1) === 45 &&
              this.input.charCodeAt(pos + 2) === 62 &&
              (spaceStart === 0 || this.state.lineStart > spaceStart)
            ) {
              const comment = this.skipLineComment(3)
              if (comment !== void 0) {
                this.addComment(comment)
                if (this.options.attachComment) comments2.push(comment)
              }
            } else {
              break loop
            }
          } else if (ch === 60 && !this.inModule) {
            const pos = this.state.pos
            if (
              this.input.charCodeAt(pos + 1) === 33 &&
              this.input.charCodeAt(pos + 2) === 45 &&
              this.input.charCodeAt(pos + 3) === 45
            ) {
              const comment = this.skipLineComment(4)
              if (comment !== void 0) {
                this.addComment(comment)
                if (this.options.attachComment) comments2.push(comment)
              }
            } else {
              break loop
            }
          } else {
            break loop
          }
      }
    }
    if (comments2.length > 0) {
      const end = this.state.pos
      const CommentWhitespace = {
        start: spaceStart,
        end,
        comments: comments2,
        leadingNode: null,
        trailingNode: null,
        containingNode: null,
      }
      this.state.commentStack.push(CommentWhitespace)
    }
  }
  finishToken(type, val) {
    this.state.end = this.state.pos
    this.state.endLoc = this.state.curPosition()
    const prevType = this.state.type
    this.state.type = type
    this.state.value = val
    if (!this.isLookahead) {
      this.updateContext(prevType)
    }
  }
  replaceToken(type) {
    this.state.type = type
    this.updateContext()
  }
  readToken_numberSign() {
    if (this.state.pos === 0 && this.readToken_interpreter()) {
      return
    }
    const nextPos = this.state.pos + 1
    const next = this.codePointAtPos(nextPos)
    if (next >= 48 && next <= 57) {
      throw this.raise(Errors$1.UnexpectedDigitAfterHash, {
        at: this.state.curPosition(),
      })
    }
    if (next === 123 || (next === 91 && this.hasPlugin('recordAndTuple'))) {
      this.expectPlugin('recordAndTuple')
      if (this.getPluginOption('recordAndTuple', 'syntaxType') !== 'hash') {
        throw this.raise(
          next === 123
            ? Errors$1.RecordExpressionHashIncorrectStartSyntaxType
            : Errors$1.TupleExpressionHashIncorrectStartSyntaxType,
          {
            at: this.state.curPosition(),
          }
        )
      }
      this.state.pos += 2
      if (next === 123) {
        this.finishToken(7)
      } else {
        this.finishToken(1)
      }
    } else if (isIdentifierStart$1(next)) {
      ++this.state.pos
      this.finishToken(134, this.readWord1(next))
    } else if (next === 92) {
      ++this.state.pos
      this.finishToken(134, this.readWord1())
    } else {
      this.finishOp(27, 1)
    }
  }
  readToken_dot() {
    const next = this.input.charCodeAt(this.state.pos + 1)
    if (next >= 48 && next <= 57) {
      this.readNumber(true)
      return
    }
    if (next === 46 && this.input.charCodeAt(this.state.pos + 2) === 46) {
      this.state.pos += 3
      this.finishToken(21)
    } else {
      ++this.state.pos
      this.finishToken(16)
    }
  }
  readToken_slash() {
    const next = this.input.charCodeAt(this.state.pos + 1)
    if (next === 61) {
      this.finishOp(31, 2)
    } else {
      this.finishOp(56, 1)
    }
  }
  readToken_interpreter() {
    if (this.state.pos !== 0 || this.length < 2) return false
    let ch = this.input.charCodeAt(this.state.pos + 1)
    if (ch !== 33) return false
    const start = this.state.pos
    this.state.pos += 1
    while (!isNewLine$1(ch) && ++this.state.pos < this.length) {
      ch = this.input.charCodeAt(this.state.pos)
    }
    const value = this.input.slice(start + 2, this.state.pos)
    this.finishToken(28, value)
    return true
  }
  readToken_mult_modulo(code2) {
    let type = code2 === 42 ? 55 : 54
    let width = 1
    let next = this.input.charCodeAt(this.state.pos + 1)
    if (code2 === 42 && next === 42) {
      width++
      next = this.input.charCodeAt(this.state.pos + 2)
      type = 57
    }
    if (next === 61 && !this.state.inType) {
      width++
      type = code2 === 37 ? 33 : 30
    }
    this.finishOp(type, width)
  }
  readToken_pipe_amp(code2) {
    const next = this.input.charCodeAt(this.state.pos + 1)
    if (next === code2) {
      if (this.input.charCodeAt(this.state.pos + 2) === 61) {
        this.finishOp(30, 3)
      } else {
        this.finishOp(code2 === 124 ? 41 : 42, 2)
      }
      return
    }
    if (code2 === 124) {
      if (next === 62) {
        this.finishOp(39, 2)
        return
      }
      if (this.hasPlugin('recordAndTuple') && next === 125) {
        if (this.getPluginOption('recordAndTuple', 'syntaxType') !== 'bar') {
          throw this.raise(Errors$1.RecordExpressionBarIncorrectEndSyntaxType, {
            at: this.state.curPosition(),
          })
        }
        this.state.pos += 2
        this.finishToken(9)
        return
      }
      if (this.hasPlugin('recordAndTuple') && next === 93) {
        if (this.getPluginOption('recordAndTuple', 'syntaxType') !== 'bar') {
          throw this.raise(Errors$1.TupleExpressionBarIncorrectEndSyntaxType, {
            at: this.state.curPosition(),
          })
        }
        this.state.pos += 2
        this.finishToken(4)
        return
      }
    }
    if (next === 61) {
      this.finishOp(30, 2)
      return
    }
    this.finishOp(code2 === 124 ? 43 : 45, 1)
  }
  readToken_caret() {
    const next = this.input.charCodeAt(this.state.pos + 1)
    if (next === 61 && !this.state.inType) {
      this.finishOp(32, 2)
    } else if (
      next === 94 &&
      this.hasPlugin([
        'pipelineOperator',
        {
          proposal: 'hack',
          topicToken: '^^',
        },
      ])
    ) {
      this.finishOp(37, 2)
      const lookaheadCh = this.input.codePointAt(this.state.pos)
      if (lookaheadCh === 94) {
        throw this.unexpected()
      }
    } else {
      this.finishOp(44, 1)
    }
  }
  readToken_atSign() {
    const next = this.input.charCodeAt(this.state.pos + 1)
    if (
      next === 64 &&
      this.hasPlugin([
        'pipelineOperator',
        {
          proposal: 'hack',
          topicToken: '@@',
        },
      ])
    ) {
      this.finishOp(38, 2)
    } else {
      this.finishOp(26, 1)
    }
  }
  readToken_plus_min(code2) {
    const next = this.input.charCodeAt(this.state.pos + 1)
    if (next === code2) {
      this.finishOp(34, 2)
      return
    }
    if (next === 61) {
      this.finishOp(30, 2)
    } else {
      this.finishOp(53, 1)
    }
  }
  readToken_lt() {
    const { pos } = this.state
    const next = this.input.charCodeAt(pos + 1)
    if (next === 60) {
      if (this.input.charCodeAt(pos + 2) === 61) {
        this.finishOp(30, 3)
        return
      }
      this.finishOp(51, 2)
      return
    }
    if (next === 61) {
      this.finishOp(49, 2)
      return
    }
    this.finishOp(47, 1)
  }
  readToken_gt() {
    const { pos } = this.state
    const next = this.input.charCodeAt(pos + 1)
    if (next === 62) {
      const size = this.input.charCodeAt(pos + 2) === 62 ? 3 : 2
      if (this.input.charCodeAt(pos + size) === 61) {
        this.finishOp(30, size + 1)
        return
      }
      this.finishOp(52, size)
      return
    }
    if (next === 61) {
      this.finishOp(49, 2)
      return
    }
    this.finishOp(48, 1)
  }
  readToken_eq_excl(code2) {
    const next = this.input.charCodeAt(this.state.pos + 1)
    if (next === 61) {
      this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2)
      return
    }
    if (code2 === 61 && next === 62) {
      this.state.pos += 2
      this.finishToken(19)
      return
    }
    this.finishOp(code2 === 61 ? 29 : 35, 1)
  }
  readToken_question() {
    const next = this.input.charCodeAt(this.state.pos + 1)
    const next2 = this.input.charCodeAt(this.state.pos + 2)
    if (next === 63) {
      if (next2 === 61) {
        this.finishOp(30, 3)
      } else {
        this.finishOp(40, 2)
      }
    } else if (next === 46 && !(next2 >= 48 && next2 <= 57)) {
      this.state.pos += 2
      this.finishToken(18)
    } else {
      ++this.state.pos
      this.finishToken(17)
    }
  }
  getTokenFromCode(code2) {
    switch (code2) {
      case 46:
        this.readToken_dot()
        return
      case 40:
        ++this.state.pos
        this.finishToken(10)
        return
      case 41:
        ++this.state.pos
        this.finishToken(11)
        return
      case 59:
        ++this.state.pos
        this.finishToken(13)
        return
      case 44:
        ++this.state.pos
        this.finishToken(12)
        return
      case 91:
        if (this.hasPlugin('recordAndTuple') && this.input.charCodeAt(this.state.pos + 1) === 124) {
          if (this.getPluginOption('recordAndTuple', 'syntaxType') !== 'bar') {
            throw this.raise(Errors$1.TupleExpressionBarIncorrectStartSyntaxType, {
              at: this.state.curPosition(),
            })
          }
          this.state.pos += 2
          this.finishToken(2)
        } else {
          ++this.state.pos
          this.finishToken(0)
        }
        return
      case 93:
        ++this.state.pos
        this.finishToken(3)
        return
      case 123:
        if (this.hasPlugin('recordAndTuple') && this.input.charCodeAt(this.state.pos + 1) === 124) {
          if (this.getPluginOption('recordAndTuple', 'syntaxType') !== 'bar') {
            throw this.raise(Errors$1.RecordExpressionBarIncorrectStartSyntaxType, {
              at: this.state.curPosition(),
            })
          }
          this.state.pos += 2
          this.finishToken(6)
        } else {
          ++this.state.pos
          this.finishToken(5)
        }
        return
      case 125:
        ++this.state.pos
        this.finishToken(8)
        return
      case 58:
        if (this.hasPlugin('functionBind') && this.input.charCodeAt(this.state.pos + 1) === 58) {
          this.finishOp(15, 2)
        } else {
          ++this.state.pos
          this.finishToken(14)
        }
        return
      case 63:
        this.readToken_question()
        return
      case 96:
        this.readTemplateToken()
        return
      case 48: {
        const next = this.input.charCodeAt(this.state.pos + 1)
        if (next === 120 || next === 88) {
          this.readRadixNumber(16)
          return
        }
        if (next === 111 || next === 79) {
          this.readRadixNumber(8)
          return
        }
        if (next === 98 || next === 66) {
          this.readRadixNumber(2)
          return
        }
      }
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
        this.readNumber(false)
        return
      case 34:
      case 39:
        this.readString(code2)
        return
      case 47:
        this.readToken_slash()
        return
      case 37:
      case 42:
        this.readToken_mult_modulo(code2)
        return
      case 124:
      case 38:
        this.readToken_pipe_amp(code2)
        return
      case 94:
        this.readToken_caret()
        return
      case 43:
      case 45:
        this.readToken_plus_min(code2)
        return
      case 60:
        this.readToken_lt()
        return
      case 62:
        this.readToken_gt()
        return
      case 61:
      case 33:
        this.readToken_eq_excl(code2)
        return
      case 126:
        this.finishOp(36, 1)
        return
      case 64:
        this.readToken_atSign()
        return
      case 35:
        this.readToken_numberSign()
        return
      case 92:
        this.readWord()
        return
      default:
        if (isIdentifierStart$1(code2)) {
          this.readWord(code2)
          return
        }
    }
    throw this.raise(Errors$1.InvalidOrUnexpectedToken, {
      at: this.state.curPosition(),
      unexpected: String.fromCodePoint(code2),
    })
  }
  finishOp(type, size) {
    const str = this.input.slice(this.state.pos, this.state.pos + size)
    this.state.pos += size
    this.finishToken(type, str)
  }
  readRegexp() {
    const startLoc = this.state.startLoc
    const start = this.state.start + 1
    let escaped, inClass
    let { pos } = this.state
    for (; ; ++pos) {
      if (pos >= this.length) {
        throw this.raise(Errors$1.UnterminatedRegExp, {
          at: createPositionWithColumnOffset$1(startLoc, 1),
        })
      }
      const ch = this.input.charCodeAt(pos)
      if (isNewLine$1(ch)) {
        throw this.raise(Errors$1.UnterminatedRegExp, {
          at: createPositionWithColumnOffset$1(startLoc, 1),
        })
      }
      if (escaped) {
        escaped = false
      } else {
        if (ch === 91) {
          inClass = true
        } else if (ch === 93 && inClass) {
          inClass = false
        } else if (ch === 47 && !inClass) {
          break
        }
        escaped = ch === 92
      }
    }
    const content = this.input.slice(start, pos)
    ++pos
    let mods = ''
    const nextPos = () => createPositionWithColumnOffset$1(startLoc, pos + 2 - start)
    while (pos < this.length) {
      const cp = this.codePointAtPos(pos)
      const char = String.fromCharCode(cp)
      if (VALID_REGEX_FLAGS$1.has(cp)) {
        if (cp === 118) {
          this.expectPlugin('regexpUnicodeSets', nextPos())
          if (mods.includes('u')) {
            this.raise(Errors$1.IncompatibleRegExpUVFlags, {
              at: nextPos(),
            })
          }
        } else if (cp === 117) {
          if (mods.includes('v')) {
            this.raise(Errors$1.IncompatibleRegExpUVFlags, {
              at: nextPos(),
            })
          }
        }
        if (mods.includes(char)) {
          this.raise(Errors$1.DuplicateRegExpFlags, {
            at: nextPos(),
          })
        }
      } else if (isIdentifierChar$1(cp) || cp === 92) {
        this.raise(Errors$1.MalformedRegExpFlags, {
          at: nextPos(),
        })
      } else {
        break
      }
      ++pos
      mods += char
    }
    this.state.pos = pos
    this.finishToken(133, {
      pattern: content,
      flags: mods,
    })
  }
  readInt(radix, len, forceLen, allowNumSeparator = true) {
    const start = this.state.pos
    const forbiddenSiblings =
      radix === 16 ? forbiddenNumericSeparatorSiblings$1.hex : forbiddenNumericSeparatorSiblings$1.decBinOct
    const isAllowedSibling =
      radix === 16
        ? isAllowedNumericSeparatorSibling$1.hex
        : radix === 10
        ? isAllowedNumericSeparatorSibling$1.dec
        : radix === 8
        ? isAllowedNumericSeparatorSibling$1.oct
        : isAllowedNumericSeparatorSibling$1.bin
    let invalid = false
    let total = 0
    for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) {
      const code2 = this.input.charCodeAt(this.state.pos)
      let val
      if (code2 === 95 && allowNumSeparator !== 'bail') {
        const prev = this.input.charCodeAt(this.state.pos - 1)
        const next = this.input.charCodeAt(this.state.pos + 1)
        if (!allowNumSeparator) {
          this.raise(Errors$1.NumericSeparatorInEscapeSequence, {
            at: this.state.curPosition(),
          })
        } else if (
          Number.isNaN(next) ||
          !isAllowedSibling(next) ||
          forbiddenSiblings.has(prev) ||
          forbiddenSiblings.has(next)
        ) {
          this.raise(Errors$1.UnexpectedNumericSeparator, {
            at: this.state.curPosition(),
          })
        }
        ++this.state.pos
        continue
      }
      if (code2 >= 97) {
        val = code2 - 97 + 10
      } else if (code2 >= 65) {
        val = code2 - 65 + 10
      } else if (_isDigit$1(code2)) {
        val = code2 - 48
      } else {
        val = Infinity
      }
      if (val >= radix) {
        if (this.options.errorRecovery && val <= 9) {
          val = 0
          this.raise(Errors$1.InvalidDigit, {
            at: this.state.curPosition(),
            radix,
          })
        } else if (forceLen) {
          val = 0
          invalid = true
        } else {
          break
        }
      }
      ++this.state.pos
      total = total * radix + val
    }
    if (this.state.pos === start || (len != null && this.state.pos - start !== len) || invalid) {
      return null
    }
    return total
  }
  readRadixNumber(radix) {
    const startLoc = this.state.curPosition()
    let isBigInt = false
    this.state.pos += 2
    const val = this.readInt(radix)
    if (val == null) {
      this.raise(Errors$1.InvalidDigit, {
        at: createPositionWithColumnOffset$1(startLoc, 2),
        radix,
      })
    }
    const next = this.input.charCodeAt(this.state.pos)
    if (next === 110) {
      ++this.state.pos
      isBigInt = true
    } else if (next === 109) {
      throw this.raise(Errors$1.InvalidDecimal, {
        at: startLoc,
      })
    }
    if (isIdentifierStart$1(this.codePointAtPos(this.state.pos))) {
      throw this.raise(Errors$1.NumberIdentifier, {
        at: this.state.curPosition(),
      })
    }
    if (isBigInt) {
      const str = this.input.slice(startLoc.index, this.state.pos).replace(/[_n]/g, '')
      this.finishToken(131, str)
      return
    }
    this.finishToken(130, val)
  }
  readNumber(startsWithDot) {
    const start = this.state.pos
    const startLoc = this.state.curPosition()
    let isFloat = false
    let isBigInt = false
    let isDecimal2 = false
    let hasExponent = false
    let isOctal2 = false
    if (!startsWithDot && this.readInt(10) === null) {
      this.raise(Errors$1.InvalidNumber, {
        at: this.state.curPosition(),
      })
    }
    const hasLeadingZero = this.state.pos - start >= 2 && this.input.charCodeAt(start) === 48
    if (hasLeadingZero) {
      const integer = this.input.slice(start, this.state.pos)
      this.recordStrictModeErrors(Errors$1.StrictOctalLiteral, {
        at: startLoc,
      })
      if (!this.state.strict) {
        const underscorePos = integer.indexOf('_')
        if (underscorePos > 0) {
          this.raise(Errors$1.ZeroDigitNumericSeparator, {
            at: createPositionWithColumnOffset$1(startLoc, underscorePos),
          })
        }
      }
      isOctal2 = hasLeadingZero && !/[89]/.test(integer)
    }
    let next = this.input.charCodeAt(this.state.pos)
    if (next === 46 && !isOctal2) {
      ++this.state.pos
      this.readInt(10)
      isFloat = true
      next = this.input.charCodeAt(this.state.pos)
    }
    if ((next === 69 || next === 101) && !isOctal2) {
      next = this.input.charCodeAt(++this.state.pos)
      if (next === 43 || next === 45) {
        ++this.state.pos
      }
      if (this.readInt(10) === null) {
        this.raise(Errors$1.InvalidOrMissingExponent, {
          at: startLoc,
        })
      }
      isFloat = true
      hasExponent = true
      next = this.input.charCodeAt(this.state.pos)
    }
    if (next === 110) {
      if (isFloat || hasLeadingZero) {
        this.raise(Errors$1.InvalidBigIntLiteral, {
          at: startLoc,
        })
      }
      ++this.state.pos
      isBigInt = true
    }
    if (next === 109) {
      this.expectPlugin('decimal', this.state.curPosition())
      if (hasExponent || hasLeadingZero) {
        this.raise(Errors$1.InvalidDecimal, {
          at: startLoc,
        })
      }
      ++this.state.pos
      isDecimal2 = true
    }
    if (isIdentifierStart$1(this.codePointAtPos(this.state.pos))) {
      throw this.raise(Errors$1.NumberIdentifier, {
        at: this.state.curPosition(),
      })
    }
    const str = this.input.slice(start, this.state.pos).replace(/[_mn]/g, '')
    if (isBigInt) {
      this.finishToken(131, str)
      return
    }
    if (isDecimal2) {
      this.finishToken(132, str)
      return
    }
    const val = isOctal2 ? parseInt(str, 8) : parseFloat(str)
    this.finishToken(130, val)
  }
  readCodePoint(throwOnInvalid) {
    const ch = this.input.charCodeAt(this.state.pos)
    let code2
    if (ch === 123) {
      ++this.state.pos
      code2 = this.readHexChar(this.input.indexOf('}', this.state.pos) - this.state.pos, true, throwOnInvalid)
      ++this.state.pos
      if (code2 !== null && code2 > 1114111) {
        if (throwOnInvalid) {
          this.raise(Errors$1.InvalidCodePoint, {
            at: this.state.curPosition(),
          })
        } else {
          return null
        }
      }
    } else {
      code2 = this.readHexChar(4, false, throwOnInvalid)
    }
    return code2
  }
  readString(quote) {
    let out = '',
      chunkStart = ++this.state.pos
    for (;;) {
      if (this.state.pos >= this.length) {
        throw this.raise(Errors$1.UnterminatedString, {
          at: this.state.startLoc,
        })
      }
      const ch = this.input.charCodeAt(this.state.pos)
      if (ch === quote) break
      if (ch === 92) {
        out += this.input.slice(chunkStart, this.state.pos)
        out += this.readEscapedChar(false)
        chunkStart = this.state.pos
      } else if (ch === 8232 || ch === 8233) {
        ++this.state.pos
        ++this.state.curLine
        this.state.lineStart = this.state.pos
      } else if (isNewLine$1(ch)) {
        throw this.raise(Errors$1.UnterminatedString, {
          at: this.state.startLoc,
        })
      } else {
        ++this.state.pos
      }
    }
    out += this.input.slice(chunkStart, this.state.pos++)
    this.finishToken(129, out)
  }
  readTemplateContinuation() {
    if (!this.match(8)) {
      this.unexpected(null, 8)
    }
    this.state.pos--
    this.readTemplateToken()
  }
  readTemplateToken() {
    let out = '',
      chunkStart = this.state.pos,
      containsInvalid = false
    ++this.state.pos
    for (;;) {
      if (this.state.pos >= this.length) {
        throw this.raise(Errors$1.UnterminatedTemplate, {
          at: createPositionWithColumnOffset$1(this.state.startLoc, 1),
        })
      }
      const ch = this.input.charCodeAt(this.state.pos)
      if (ch === 96) {
        ++this.state.pos
        out += this.input.slice(chunkStart, this.state.pos)
        this.finishToken(24, containsInvalid ? null : out)
        return
      }
      if (ch === 36 && this.input.charCodeAt(this.state.pos + 1) === 123) {
        this.state.pos += 2
        out += this.input.slice(chunkStart, this.state.pos)
        this.finishToken(25, containsInvalid ? null : out)
        return
      }
      if (ch === 92) {
        out += this.input.slice(chunkStart, this.state.pos)
        const escaped = this.readEscapedChar(true)
        if (escaped === null) {
          containsInvalid = true
        } else {
          out += escaped
        }
        chunkStart = this.state.pos
      } else if (isNewLine$1(ch)) {
        out += this.input.slice(chunkStart, this.state.pos)
        ++this.state.pos
        switch (ch) {
          case 13:
            if (this.input.charCodeAt(this.state.pos) === 10) {
              ++this.state.pos
            }
          case 10:
            out += '\n'
            break
          default:
            out += String.fromCharCode(ch)
            break
        }
        ++this.state.curLine
        this.state.lineStart = this.state.pos
        chunkStart = this.state.pos
      } else {
        ++this.state.pos
      }
    }
  }
  recordStrictModeErrors(toParseError, { at }) {
    const index2 = at.index
    if (this.state.strict && !this.state.strictErrors.has(index2)) {
      this.raise(toParseError, {
        at,
      })
    } else {
      this.state.strictErrors.set(index2, [toParseError, at])
    }
  }
  readEscapedChar(inTemplate) {
    const throwOnInvalid = !inTemplate
    const ch = this.input.charCodeAt(++this.state.pos)
    ++this.state.pos
    switch (ch) {
      case 110:
        return '\n'
      case 114:
        return '\r'
      case 120: {
        const code2 = this.readHexChar(2, false, throwOnInvalid)
        return code2 === null ? null : String.fromCharCode(code2)
      }
      case 117: {
        const code2 = this.readCodePoint(throwOnInvalid)
        return code2 === null ? null : String.fromCodePoint(code2)
      }
      case 116:
        return '	'
      case 98:
        return '\b'
      case 118:
        return '\v'
      case 102:
        return '\f'
      case 13:
        if (this.input.charCodeAt(this.state.pos) === 10) {
          ++this.state.pos
        }
      case 10:
        this.state.lineStart = this.state.pos
        ++this.state.curLine
      case 8232:
      case 8233:
        return ''
      case 56:
      case 57:
        if (inTemplate) {
          return null
        } else {
          this.recordStrictModeErrors(Errors$1.StrictNumericEscape, {
            at: createPositionWithColumnOffset$1(this.state.curPosition(), -1),
          })
        }
      default:
        if (ch >= 48 && ch <= 55) {
          const codePos = createPositionWithColumnOffset$1(this.state.curPosition(), -1)
          const match = this.input.slice(this.state.pos - 1, this.state.pos + 2).match(/^[0-7]+/)
          let octalStr = match[0]
          let octal = parseInt(octalStr, 8)
          if (octal > 255) {
            octalStr = octalStr.slice(0, -1)
            octal = parseInt(octalStr, 8)
          }
          this.state.pos += octalStr.length - 1
          const next = this.input.charCodeAt(this.state.pos)
          if (octalStr !== '0' || next === 56 || next === 57) {
            if (inTemplate) {
              return null
            } else {
              this.recordStrictModeErrors(Errors$1.StrictNumericEscape, {
                at: codePos,
              })
            }
          }
          return String.fromCharCode(octal)
        }
        return String.fromCharCode(ch)
    }
  }
  readHexChar(len, forceLen, throwOnInvalid) {
    const codeLoc = this.state.curPosition()
    const n2 = this.readInt(16, len, forceLen, false)
    if (n2 === null) {
      if (throwOnInvalid) {
        this.raise(Errors$1.InvalidEscapeSequence, {
          at: codeLoc,
        })
      } else {
        this.state.pos = codeLoc.index - 1
      }
    }
    return n2
  }
  readWord1(firstCode) {
    this.state.containsEsc = false
    let word = ''
    const start = this.state.pos
    let chunkStart = this.state.pos
    if (firstCode !== void 0) {
      this.state.pos += firstCode <= 65535 ? 1 : 2
    }
    while (this.state.pos < this.length) {
      const ch = this.codePointAtPos(this.state.pos)
      if (isIdentifierChar$1(ch)) {
        this.state.pos += ch <= 65535 ? 1 : 2
      } else if (ch === 92) {
        this.state.containsEsc = true
        word += this.input.slice(chunkStart, this.state.pos)
        const escStart = this.state.curPosition()
        const identifierCheck = this.state.pos === start ? isIdentifierStart$1 : isIdentifierChar$1
        if (this.input.charCodeAt(++this.state.pos) !== 117) {
          this.raise(Errors$1.MissingUnicodeEscape, {
            at: this.state.curPosition(),
          })
          chunkStart = this.state.pos - 1
          continue
        }
        ++this.state.pos
        const esc = this.readCodePoint(true)
        if (esc !== null) {
          if (!identifierCheck(esc)) {
            this.raise(Errors$1.EscapedCharNotAnIdentifier, {
              at: escStart,
            })
          }
          word += String.fromCodePoint(esc)
        }
        chunkStart = this.state.pos
      } else {
        break
      }
    }
    return word + this.input.slice(chunkStart, this.state.pos)
  }
  readWord(firstCode) {
    const word = this.readWord1(firstCode)
    const type = keywords$1$1.get(word)
    if (type !== void 0) {
      this.finishToken(type, tokenLabelName$1(type))
    } else {
      this.finishToken(128, word)
    }
  }
  checkKeywordEscapes() {
    const { type } = this.state
    if (tokenIsKeyword$1(type) && this.state.containsEsc) {
      this.raise(Errors$1.InvalidEscapedReservedWord, {
        at: this.state.startLoc,
        reservedWord: tokenLabelName$1(type),
      })
    }
  }
  raise(toParseError, raiseProperties) {
    const { at } = raiseProperties,
      details = _objectWithoutPropertiesLoose$3(raiseProperties, _excluded$4)
    const loc = at instanceof Position$1 ? at : at.loc.start
    const error = toParseError({
      loc,
      details,
    })
    if (!this.options.errorRecovery) throw error
    if (!this.isLookahead) this.state.errors.push(error)
    return error
  }
  raiseOverwrite(toParseError, raiseProperties) {
    const { at } = raiseProperties,
      details = _objectWithoutPropertiesLoose$3(raiseProperties, _excluded2$1)
    const loc = at instanceof Position$1 ? at : at.loc.start
    const pos = loc.index
    const errors = this.state.errors
    for (let i = errors.length - 1; i >= 0; i--) {
      const error = errors[i]
      if (error.loc.index === pos) {
        return (errors[i] = toParseError({
          loc,
          details,
        }))
      }
      if (error.loc.index < pos) break
    }
    return this.raise(toParseError, raiseProperties)
  }
  updateContext(prevType) {}
  unexpected(loc, type) {
    throw this.raise(Errors$1.UnexpectedToken, {
      expected: type ? tokenLabelName$1(type) : null,
      at: loc != null ? loc : this.state.startLoc,
    })
  }
  expectPlugin(pluginName, loc) {
    if (this.hasPlugin(pluginName)) {
      return true
    }
    throw this.raise(Errors$1.MissingPlugin, {
      at: loc != null ? loc : this.state.startLoc,
      missingPlugin: [pluginName],
    })
  }
  expectOnePlugin(pluginNames) {
    if (!pluginNames.some((name) => this.hasPlugin(name))) {
      throw this.raise(Errors$1.MissingOneOfPlugins, {
        at: this.state.startLoc,
        missingPlugin: pluginNames,
      })
    }
  }
}
class Scope$1 {
  constructor(flags) {
    this.var = /* @__PURE__ */ new Set()
    this.lexical = /* @__PURE__ */ new Set()
    this.functions = /* @__PURE__ */ new Set()
    this.flags = flags
  }
}
class ScopeHandler$1 {
  constructor(parser, inModule) {
    this.parser = void 0
    this.scopeStack = []
    this.inModule = void 0
    this.undefinedExports = /* @__PURE__ */ new Map()
    this.parser = parser
    this.inModule = inModule
  }
  get inFunction() {
    return (this.currentVarScopeFlags() & SCOPE_FUNCTION$1) > 0
  }
  get allowSuper() {
    return (this.currentThisScopeFlags() & SCOPE_SUPER$1) > 0
  }
  get allowDirectSuper() {
    return (this.currentThisScopeFlags() & SCOPE_DIRECT_SUPER$1) > 0
  }
  get inClass() {
    return (this.currentThisScopeFlags() & SCOPE_CLASS$1) > 0
  }
  get inClassAndNotInNonArrowFunction() {
    const flags = this.currentThisScopeFlags()
    return (flags & SCOPE_CLASS$1) > 0 && (flags & SCOPE_FUNCTION$1) === 0
  }
  get inStaticBlock() {
    for (let i = this.scopeStack.length - 1; ; i--) {
      const { flags } = this.scopeStack[i]
      if (flags & SCOPE_STATIC_BLOCK$1) {
        return true
      }
      if (flags & (SCOPE_VAR$1 | SCOPE_CLASS$1)) {
        return false
      }
    }
  }
  get inNonArrowFunction() {
    return (this.currentThisScopeFlags() & SCOPE_FUNCTION$1) > 0
  }
  get treatFunctionsAsVar() {
    return this.treatFunctionsAsVarInScope(this.currentScope())
  }
  createScope(flags) {
    return new Scope$1(flags)
  }
  enter(flags) {
    this.scopeStack.push(this.createScope(flags))
  }
  exit() {
    this.scopeStack.pop()
  }
  treatFunctionsAsVarInScope(scope2) {
    return !!(
      scope2.flags & (SCOPE_FUNCTION$1 | SCOPE_STATIC_BLOCK$1) ||
      (!this.parser.inModule && scope2.flags & SCOPE_PROGRAM$1)
    )
  }
  declareName(name, bindingType, loc) {
    let scope2 = this.currentScope()
    if (bindingType & BIND_SCOPE_LEXICAL$1 || bindingType & BIND_SCOPE_FUNCTION$1) {
      this.checkRedeclarationInScope(scope2, name, bindingType, loc)
      if (bindingType & BIND_SCOPE_FUNCTION$1) {
        scope2.functions.add(name)
      } else {
        scope2.lexical.add(name)
      }
      if (bindingType & BIND_SCOPE_LEXICAL$1) {
        this.maybeExportDefined(scope2, name)
      }
    } else if (bindingType & BIND_SCOPE_VAR$1) {
      for (let i = this.scopeStack.length - 1; i >= 0; --i) {
        scope2 = this.scopeStack[i]
        this.checkRedeclarationInScope(scope2, name, bindingType, loc)
        scope2.var.add(name)
        this.maybeExportDefined(scope2, name)
        if (scope2.flags & SCOPE_VAR$1) break
      }
    }
    if (this.parser.inModule && scope2.flags & SCOPE_PROGRAM$1) {
      this.undefinedExports.delete(name)
    }
  }
  maybeExportDefined(scope2, name) {
    if (this.parser.inModule && scope2.flags & SCOPE_PROGRAM$1) {
      this.undefinedExports.delete(name)
    }
  }
  checkRedeclarationInScope(scope2, name, bindingType, loc) {
    if (this.isRedeclaredInScope(scope2, name, bindingType)) {
      this.parser.raise(Errors$1.VarRedeclaration, {
        at: loc,
        identifierName: name,
      })
    }
  }
  isRedeclaredInScope(scope2, name, bindingType) {
    if (!(bindingType & BIND_KIND_VALUE$1)) return false
    if (bindingType & BIND_SCOPE_LEXICAL$1) {
      return scope2.lexical.has(name) || scope2.functions.has(name) || scope2.var.has(name)
    }
    if (bindingType & BIND_SCOPE_FUNCTION$1) {
      return scope2.lexical.has(name) || (!this.treatFunctionsAsVarInScope(scope2) && scope2.var.has(name))
    }
    return (
      (scope2.lexical.has(name) &&
        !(scope2.flags & SCOPE_SIMPLE_CATCH$1 && scope2.lexical.values().next().value === name)) ||
      (!this.treatFunctionsAsVarInScope(scope2) && scope2.functions.has(name))
    )
  }
  checkLocalExport(id) {
    const { name } = id
    const topLevelScope = this.scopeStack[0]
    if (!topLevelScope.lexical.has(name) && !topLevelScope.var.has(name) && !topLevelScope.functions.has(name)) {
      this.undefinedExports.set(name, id.loc.start)
    }
  }
  currentScope() {
    return this.scopeStack[this.scopeStack.length - 1]
  }
  currentVarScopeFlags() {
    for (let i = this.scopeStack.length - 1; ; i--) {
      const { flags } = this.scopeStack[i]
      if (flags & SCOPE_VAR$1) {
        return flags
      }
    }
  }
  currentThisScopeFlags() {
    for (let i = this.scopeStack.length - 1; ; i--) {
      const { flags } = this.scopeStack[i]
      if (flags & (SCOPE_VAR$1 | SCOPE_CLASS$1) && !(flags & SCOPE_ARROW$1)) {
        return flags
      }
    }
  }
}
class FlowScope$1 extends Scope$1 {
  constructor(...args) {
    super(...args)
    this.declareFunctions = /* @__PURE__ */ new Set()
  }
}
class FlowScopeHandler$1 extends ScopeHandler$1 {
  createScope(flags) {
    return new FlowScope$1(flags)
  }
  declareName(name, bindingType, loc) {
    const scope2 = this.currentScope()
    if (bindingType & BIND_FLAGS_FLOW_DECLARE_FN$1) {
      this.checkRedeclarationInScope(scope2, name, bindingType, loc)
      this.maybeExportDefined(scope2, name)
      scope2.declareFunctions.add(name)
      return
    }
    super.declareName(...arguments)
  }
  isRedeclaredInScope(scope2, name, bindingType) {
    if (super.isRedeclaredInScope(...arguments)) return true
    if (bindingType & BIND_FLAGS_FLOW_DECLARE_FN$1) {
      return !scope2.declareFunctions.has(name) && (scope2.lexical.has(name) || scope2.functions.has(name))
    }
    return false
  }
  checkLocalExport(id) {
    if (!this.scopeStack[0].declareFunctions.has(id.name)) {
      super.checkLocalExport(id)
    }
  }
}
class ClassScope$1 {
  constructor() {
    this.privateNames = /* @__PURE__ */ new Set()
    this.loneAccessors = /* @__PURE__ */ new Map()
    this.undefinedPrivateNames = /* @__PURE__ */ new Map()
  }
}
class ClassScopeHandler$1 {
  constructor(parser) {
    this.parser = void 0
    this.stack = []
    this.undefinedPrivateNames = /* @__PURE__ */ new Map()
    this.parser = parser
  }
  current() {
    return this.stack[this.stack.length - 1]
  }
  enter() {
    this.stack.push(new ClassScope$1())
  }
  exit() {
    const oldClassScope = this.stack.pop()
    const current = this.current()
    for (const [name, loc] of Array.from(oldClassScope.undefinedPrivateNames)) {
      if (current) {
        if (!current.undefinedPrivateNames.has(name)) {
          current.undefinedPrivateNames.set(name, loc)
        }
      } else {
        this.parser.raise(Errors$1.InvalidPrivateFieldResolution, {
          at: loc,
          identifierName: name,
        })
      }
    }
  }
  declarePrivateName(name, elementType, loc) {
    const { privateNames, loneAccessors, undefinedPrivateNames } = this.current()
    let redefined = privateNames.has(name)
    if (elementType & CLASS_ELEMENT_KIND_ACCESSOR$1) {
      const accessor = redefined && loneAccessors.get(name)
      if (accessor) {
        const oldStatic = accessor & CLASS_ELEMENT_FLAG_STATIC$1
        const newStatic = elementType & CLASS_ELEMENT_FLAG_STATIC$1
        const oldKind = accessor & CLASS_ELEMENT_KIND_ACCESSOR$1
        const newKind = elementType & CLASS_ELEMENT_KIND_ACCESSOR$1
        redefined = oldKind === newKind || oldStatic !== newStatic
        if (!redefined) loneAccessors.delete(name)
      } else if (!redefined) {
        loneAccessors.set(name, elementType)
      }
    }
    if (redefined) {
      this.parser.raise(Errors$1.PrivateNameRedeclaration, {
        at: loc,
        identifierName: name,
      })
    }
    privateNames.add(name)
    undefinedPrivateNames.delete(name)
  }
  usePrivateName(name, loc) {
    let classScope
    for (classScope of this.stack) {
      if (classScope.privateNames.has(name)) return
    }
    if (classScope) {
      classScope.undefinedPrivateNames.set(name, loc)
    } else {
      this.parser.raise(Errors$1.InvalidPrivateFieldResolution, {
        at: loc,
        identifierName: name,
      })
    }
  }
}
const kExpression$1 = 0,
  kMaybeArrowParameterDeclaration$1 = 1,
  kMaybeAsyncArrowParameterDeclaration$1 = 2,
  kParameterDeclaration$1 = 3
class ExpressionScope$1 {
  constructor(type = kExpression$1) {
    this.type = void 0
    this.type = type
  }
  canBeArrowParameterDeclaration() {
    return this.type === kMaybeAsyncArrowParameterDeclaration$1 || this.type === kMaybeArrowParameterDeclaration$1
  }
  isCertainlyParameterDeclaration() {
    return this.type === kParameterDeclaration$1
  }
}
class ArrowHeadParsingScope$1 extends ExpressionScope$1 {
  constructor(type) {
    super(type)
    this.declarationErrors = /* @__PURE__ */ new Map()
  }
  recordDeclarationError(ParsingErrorClass, { at }) {
    const index2 = at.index
    this.declarationErrors.set(index2, [ParsingErrorClass, at])
  }
  clearDeclarationError(index2) {
    this.declarationErrors.delete(index2)
  }
  iterateErrors(iterator) {
    this.declarationErrors.forEach(iterator)
  }
}
class ExpressionScopeHandler$1 {
  constructor(parser) {
    this.parser = void 0
    this.stack = [new ExpressionScope$1()]
    this.parser = parser
  }
  enter(scope2) {
    this.stack.push(scope2)
  }
  exit() {
    this.stack.pop()
  }
  recordParameterInitializerError(toParseError, { at: node2 }) {
    const origin = {
      at: node2.loc.start,
    }
    const { stack } = this
    let i = stack.length - 1
    let scope2 = stack[i]
    while (!scope2.isCertainlyParameterDeclaration()) {
      if (scope2.canBeArrowParameterDeclaration()) {
        scope2.recordDeclarationError(toParseError, origin)
      } else {
        return
      }
      scope2 = stack[--i]
    }
    this.parser.raise(toParseError, origin)
  }
  recordArrowParemeterBindingError(error, { at: node2 }) {
    const { stack } = this
    const scope2 = stack[stack.length - 1]
    const origin = {
      at: node2.loc.start,
    }
    if (scope2.isCertainlyParameterDeclaration()) {
      this.parser.raise(error, origin)
    } else if (scope2.canBeArrowParameterDeclaration()) {
      scope2.recordDeclarationError(error, origin)
    } else {
      return
    }
  }
  recordAsyncArrowParametersError({ at }) {
    const { stack } = this
    let i = stack.length - 1
    let scope2 = stack[i]
    while (scope2.canBeArrowParameterDeclaration()) {
      if (scope2.type === kMaybeAsyncArrowParameterDeclaration$1) {
        scope2.recordDeclarationError(Errors$1.AwaitBindingIdentifier, {
          at,
        })
      }
      scope2 = stack[--i]
    }
  }
  validateAsPattern() {
    const { stack } = this
    const currentScope = stack[stack.length - 1]
    if (!currentScope.canBeArrowParameterDeclaration()) return
    currentScope.iterateErrors(([toParseError, loc]) => {
      this.parser.raise(toParseError, {
        at: loc,
      })
      let i = stack.length - 2
      let scope2 = stack[i]
      while (scope2.canBeArrowParameterDeclaration()) {
        scope2.clearDeclarationError(loc.index)
        scope2 = stack[--i]
      }
    })
  }
}
function newParameterDeclarationScope$1() {
  return new ExpressionScope$1(kParameterDeclaration$1)
}
function newArrowHeadScope$1() {
  return new ArrowHeadParsingScope$1(kMaybeArrowParameterDeclaration$1)
}
function newAsyncArrowScope$1() {
  return new ArrowHeadParsingScope$1(kMaybeAsyncArrowParameterDeclaration$1)
}
function newExpressionScope$1() {
  return new ExpressionScope$1()
}
const PARAM$1 = 0,
  PARAM_YIELD$1 = 1,
  PARAM_AWAIT$1 = 2,
  PARAM_RETURN$1 = 4,
  PARAM_IN$1 = 8
class ProductionParameterHandler$1 {
  constructor() {
    this.stacks = []
  }
  enter(flags) {
    this.stacks.push(flags)
  }
  exit() {
    this.stacks.pop()
  }
  currentFlags() {
    return this.stacks[this.stacks.length - 1]
  }
  get hasAwait() {
    return (this.currentFlags() & PARAM_AWAIT$1) > 0
  }
  get hasYield() {
    return (this.currentFlags() & PARAM_YIELD$1) > 0
  }
  get hasReturn() {
    return (this.currentFlags() & PARAM_RETURN$1) > 0
  }
  get hasIn() {
    return (this.currentFlags() & PARAM_IN$1) > 0
  }
}
function functionFlags$1(isAsync, isGenerator) {
  return (isAsync ? PARAM_AWAIT$1 : 0) | (isGenerator ? PARAM_YIELD$1 : 0)
}
class UtilParser$1 extends Tokenizer$1 {
  addExtra(node2, key, value, enumerable = true) {
    if (!node2) return
    const extra = (node2.extra = node2.extra || {})
    if (enumerable) {
      extra[key] = value
    } else {
      Object.defineProperty(extra, key, {
        enumerable,
        value,
      })
    }
  }
  isContextual(token) {
    return this.state.type === token && !this.state.containsEsc
  }
  isUnparsedContextual(nameStart, name) {
    const nameEnd = nameStart + name.length
    if (this.input.slice(nameStart, nameEnd) === name) {
      const nextCh = this.input.charCodeAt(nameEnd)
      return !(isIdentifierChar$1(nextCh) || (nextCh & 64512) === 55296)
    }
    return false
  }
  isLookaheadContextual(name) {
    const next = this.nextTokenStart()
    return this.isUnparsedContextual(next, name)
  }
  eatContextual(token) {
    if (this.isContextual(token)) {
      this.next()
      return true
    }
    return false
  }
  expectContextual(token, toParseError) {
    if (!this.eatContextual(token)) {
      if (toParseError != null) {
        throw this.raise(toParseError, {
          at: this.state.startLoc,
        })
      }
      throw this.unexpected(null, token)
    }
  }
  canInsertSemicolon() {
    return this.match(135) || this.match(8) || this.hasPrecedingLineBreak()
  }
  hasPrecedingLineBreak() {
    return lineBreak$1.test(this.input.slice(this.state.lastTokEndLoc.index, this.state.start))
  }
  hasFollowingLineBreak() {
    skipWhiteSpaceToLineBreak$1.lastIndex = this.state.end
    return skipWhiteSpaceToLineBreak$1.test(this.input)
  }
  isLineTerminator() {
    return this.eat(13) || this.canInsertSemicolon()
  }
  semicolon(allowAsi = true) {
    if (allowAsi ? this.isLineTerminator() : this.eat(13)) return
    this.raise(Errors$1.MissingSemicolon, {
      at: this.state.lastTokEndLoc,
    })
  }
  expect(type, loc) {
    this.eat(type) || this.unexpected(loc, type)
  }
  tryParse(fn, oldState = this.state.clone()) {
    const abortSignal = {
      node: null,
    }
    try {
      const node2 = fn((node3 = null) => {
        abortSignal.node = node3
        throw abortSignal
      })
      if (this.state.errors.length > oldState.errors.length) {
        const failState = this.state
        this.state = oldState
        this.state.tokensLength = failState.tokensLength
        return {
          node: node2,
          error: failState.errors[oldState.errors.length],
          thrown: false,
          aborted: false,
          failState,
        }
      }
      return {
        node: node2,
        error: null,
        thrown: false,
        aborted: false,
        failState: null,
      }
    } catch (error) {
      const failState = this.state
      this.state = oldState
      if (error instanceof SyntaxError) {
        return {
          node: null,
          error,
          thrown: true,
          aborted: false,
          failState,
        }
      }
      if (error === abortSignal) {
        return {
          node: abortSignal.node,
          error: null,
          thrown: false,
          aborted: true,
          failState,
        }
      }
      throw error
    }
  }
  checkExpressionErrors(refExpressionErrors, andThrow) {
    if (!refExpressionErrors) return false
    const { shorthandAssignLoc, doubleProtoLoc, privateKeyLoc, optionalParametersLoc } = refExpressionErrors
    const hasErrors = !!shorthandAssignLoc || !!doubleProtoLoc || !!optionalParametersLoc || !!privateKeyLoc
    if (!andThrow) {
      return hasErrors
    }
    if (shorthandAssignLoc != null) {
      this.raise(Errors$1.InvalidCoverInitializedName, {
        at: shorthandAssignLoc,
      })
    }
    if (doubleProtoLoc != null) {
      this.raise(Errors$1.DuplicateProto, {
        at: doubleProtoLoc,
      })
    }
    if (privateKeyLoc != null) {
      this.raise(Errors$1.UnexpectedPrivateField, {
        at: privateKeyLoc,
      })
    }
    if (optionalParametersLoc != null) {
      this.unexpected(optionalParametersLoc)
    }
  }
  isLiteralPropertyName() {
    return tokenIsLiteralPropertyName$1(this.state.type)
  }
  isPrivateName(node2) {
    return node2.type === 'PrivateName'
  }
  getPrivateNameSV(node2) {
    return node2.id.name
  }
  hasPropertyAsPrivateName(node2) {
    return (
      (node2.type === 'MemberExpression' || node2.type === 'OptionalMemberExpression') &&
      this.isPrivateName(node2.property)
    )
  }
  isOptionalChain(node2) {
    return node2.type === 'OptionalMemberExpression' || node2.type === 'OptionalCallExpression'
  }
  isObjectProperty(node2) {
    return node2.type === 'ObjectProperty'
  }
  isObjectMethod(node2) {
    return node2.type === 'ObjectMethod'
  }
  initializeScopes(inModule = this.options.sourceType === 'module') {
    const oldLabels = this.state.labels
    this.state.labels = []
    const oldExportedIdentifiers = this.exportedIdentifiers
    this.exportedIdentifiers = /* @__PURE__ */ new Set()
    const oldInModule = this.inModule
    this.inModule = inModule
    const oldScope = this.scope
    const ScopeHandler2 = this.getScopeHandler()
    this.scope = new ScopeHandler2(this, inModule)
    const oldProdParam = this.prodParam
    this.prodParam = new ProductionParameterHandler$1()
    const oldClassScope = this.classScope
    this.classScope = new ClassScopeHandler$1(this)
    const oldExpressionScope = this.expressionScope
    this.expressionScope = new ExpressionScopeHandler$1(this)
    return () => {
      this.state.labels = oldLabels
      this.exportedIdentifiers = oldExportedIdentifiers
      this.inModule = oldInModule
      this.scope = oldScope
      this.prodParam = oldProdParam
      this.classScope = oldClassScope
      this.expressionScope = oldExpressionScope
    }
  }
  enterInitialScopes() {
    let paramFlags = PARAM$1
    if (this.inModule) {
      paramFlags |= PARAM_AWAIT$1
    }
    this.scope.enter(SCOPE_PROGRAM$1)
    this.prodParam.enter(paramFlags)
  }
  checkDestructuringPrivate(refExpressionErrors) {
    const { privateKeyLoc } = refExpressionErrors
    if (privateKeyLoc !== null) {
      this.expectPlugin('destructuringPrivate', privateKeyLoc)
    }
  }
}
class ExpressionErrors$1 {
  constructor() {
    this.shorthandAssignLoc = null
    this.doubleProtoLoc = null
    this.privateKeyLoc = null
    this.optionalParametersLoc = null
  }
}
class Node$1 {
  constructor(parser, pos, loc) {
    this.type = ''
    this.start = pos
    this.end = 0
    this.loc = new SourceLocation$1(loc)
    if (parser != null && parser.options.ranges) this.range = [pos, 0]
    if (parser != null && parser.filename) this.loc.filename = parser.filename
  }
}
const NodePrototype$1 = Node$1.prototype
{
  NodePrototype$1.__clone = function () {
    const newNode = new Node$1()
    const keys = Object.keys(this)
    for (let i = 0, length = keys.length; i < length; i++) {
      const key = keys[i]
      if (key !== 'leadingComments' && key !== 'trailingComments' && key !== 'innerComments') {
        newNode[key] = this[key]
      }
    }
    return newNode
  }
}
function clonePlaceholder$1(node2) {
  return cloneIdentifier$1(node2)
}
function cloneIdentifier$1(node2) {
  const { type, start, end, loc, range, extra, name } = node2
  const cloned = Object.create(NodePrototype$1)
  cloned.type = type
  cloned.start = start
  cloned.end = end
  cloned.loc = loc
  cloned.range = range
  cloned.extra = extra
  cloned.name = name
  if (type === 'Placeholder') {
    cloned.expectedNode = node2.expectedNode
  }
  return cloned
}
function cloneStringLiteral$1(node2) {
  const { type, start, end, loc, range, extra } = node2
  if (type === 'Placeholder') {
    return clonePlaceholder$1(node2)
  }
  const cloned = Object.create(NodePrototype$1)
  cloned.type = type
  cloned.start = start
  cloned.end = end
  cloned.loc = loc
  cloned.range = range
  if (node2.raw !== void 0) {
    cloned.raw = node2.raw
  } else {
    cloned.extra = extra
  }
  cloned.value = node2.value
  return cloned
}
class NodeUtils$1 extends UtilParser$1 {
  startNode() {
    return new Node$1(this, this.state.start, this.state.startLoc)
  }
  startNodeAt(pos, loc) {
    return new Node$1(this, pos, loc)
  }
  startNodeAtNode(type) {
    return this.startNodeAt(type.start, type.loc.start)
  }
  finishNode(node2, type) {
    return this.finishNodeAt(node2, type, this.state.lastTokEndLoc)
  }
  finishNodeAt(node2, type, endLoc) {
    node2.type = type
    node2.end = endLoc.index
    node2.loc.end = endLoc
    if (this.options.ranges) node2.range[1] = endLoc.index
    if (this.options.attachComment) this.processComment(node2)
    return node2
  }
  resetStartLocation(node2, start, startLoc) {
    node2.start = start
    node2.loc.start = startLoc
    if (this.options.ranges) node2.range[0] = start
  }
  resetEndLocation(node2, endLoc = this.state.lastTokEndLoc) {
    node2.end = endLoc.index
    node2.loc.end = endLoc
    if (this.options.ranges) node2.range[1] = endLoc.index
  }
  resetStartLocationFromNode(node2, locationNode) {
    this.resetStartLocation(node2, locationNode.start, locationNode.loc.start)
  }
}
const reservedTypes$1 = /* @__PURE__ */ new Set([
  '_',
  'any',
  'bool',
  'boolean',
  'empty',
  'extends',
  'false',
  'interface',
  'mixed',
  'null',
  'number',
  'static',
  'string',
  'true',
  'typeof',
  'void',
])
const FlowErrors$1 = ParseErrorEnum$1`flow`((_2) => ({
  AmbiguousConditionalArrow: _2('Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.'),
  AmbiguousDeclareModuleKind: _2(
    'Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.'
  ),
  AssignReservedType: _2(({ reservedType }) => `Cannot overwrite reserved type ${reservedType}.`),
  DeclareClassElement: _2('The `declare` modifier can only appear on class fields.'),
  DeclareClassFieldInitializer: _2('Initializers are not allowed in fields with the `declare` modifier.'),
  DuplicateDeclareModuleExports: _2('Duplicate `declare module.exports` statement.'),
  EnumBooleanMemberNotInitialized: _2(
    ({ memberName, enumName }) =>
      `Boolean enum members need to be initialized. Use either \`${memberName} = true,\` or \`${memberName} = false,\` in enum \`${enumName}\`.`
  ),
  EnumDuplicateMemberName: _2(
    ({ memberName, enumName }) =>
      `Enum member names need to be unique, but the name \`${memberName}\` has already been used before in enum \`${enumName}\`.`
  ),
  EnumInconsistentMemberValues: _2(
    ({ enumName }) =>
      `Enum \`${enumName}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`
  ),
  EnumInvalidExplicitType: _2(
    ({ invalidEnumType, enumName }) =>
      `Enum type \`${invalidEnumType}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${enumName}\`.`
  ),
  EnumInvalidExplicitTypeUnknownSupplied: _2(
    ({ enumName }) =>
      `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${enumName}\`.`
  ),
  EnumInvalidMemberInitializerPrimaryType: _2(
    ({ enumName, memberName, explicitType }) =>
      `Enum \`${enumName}\` has type \`${explicitType}\`, so the initializer of \`${memberName}\` needs to be a ${explicitType} literal.`
  ),
  EnumInvalidMemberInitializerSymbolType: _2(
    ({ enumName, memberName }) =>
      `Symbol enum members cannot be initialized. Use \`${memberName},\` in enum \`${enumName}\`.`
  ),
  EnumInvalidMemberInitializerUnknownType: _2(
    ({ enumName, memberName }) =>
      `The enum member initializer for \`${memberName}\` needs to be a literal (either a boolean, number, or string) in enum \`${enumName}\`.`
  ),
  EnumInvalidMemberName: _2(
    ({ enumName, memberName, suggestion }) =>
      `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${memberName}\`, consider using \`${suggestion}\`, in enum \`${enumName}\`.`
  ),
  EnumNumberMemberNotInitialized: _2(
    ({ enumName, memberName }) =>
      `Number enum members need to be initialized, e.g. \`${memberName} = 1\` in enum \`${enumName}\`.`
  ),
  EnumStringMemberInconsistentlyInitailized: _2(
    ({ enumName }) =>
      `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${enumName}\`.`
  ),
  GetterMayNotHaveThisParam: _2('A getter cannot have a `this` parameter.'),
  ImportTypeShorthandOnlyInPureImport: _2(
    'The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.'
  ),
  InexactInsideExact: _2('Explicit inexact syntax cannot appear inside an explicit exact object type.'),
  InexactInsideNonObject: _2('Explicit inexact syntax cannot appear in class or interface definitions.'),
  InexactVariance: _2('Explicit inexact syntax cannot have variance.'),
  InvalidNonTypeImportInDeclareModule: _2(
    'Imports within a `declare module` body must always be `import type` or `import typeof`.'
  ),
  MissingTypeParamDefault: _2(
    'Type parameter declaration needs a default, since a preceding type parameter declaration has a default.'
  ),
  NestedDeclareModule: _2('`declare module` cannot be used inside another `declare module`.'),
  NestedFlowComment: _2('Cannot have a flow comment inside another flow comment.'),
  PatternIsOptional: _2('A binding pattern parameter cannot be optional in an implementation signature.', {
    reasonCode: 'OptionalBindingPattern',
  }),
  SetterMayNotHaveThisParam: _2('A setter cannot have a `this` parameter.'),
  SpreadVariance: _2('Spread properties cannot have variance.'),
  ThisParamAnnotationRequired: _2('A type annotation is required for the `this` parameter.'),
  ThisParamBannedInConstructor: _2(
    "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions."
  ),
  ThisParamMayNotBeOptional: _2('The `this` parameter cannot be optional.'),
  ThisParamMustBeFirst: _2('The `this` parameter must be the first function parameter.'),
  ThisParamNoDefault: _2('The `this` parameter may not have a default value.'),
  TypeBeforeInitializer: _2(
    'Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.'
  ),
  TypeCastInPattern: _2('The type cast expression is expected to be wrapped with parenthesis.'),
  UnexpectedExplicitInexactInObject: _2('Explicit inexact syntax must appear at the end of an inexact object.'),
  UnexpectedReservedType: _2(({ reservedType }) => `Unexpected reserved type ${reservedType}.`),
  UnexpectedReservedUnderscore: _2('`_` is only allowed as a type argument to call or new.'),
  UnexpectedSpaceBetweenModuloChecks: _2('Spaces between `%` and `checks` are not allowed here.'),
  UnexpectedSpreadType: _2('Spread operator cannot appear in class or interface definitions.'),
  UnexpectedSubtractionOperand: _2('Unexpected token, expected "number" or "bigint".'),
  UnexpectedTokenAfterTypeParameter: _2('Expected an arrow function after this type parameter declaration.'),
  UnexpectedTypeParameterBeforeAsyncArrowFunction: _2(
    'Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.'
  ),
  UnsupportedDeclareExportKind: _2(
    ({ unsupportedExportKind, suggestion }) =>
      `\`declare export ${unsupportedExportKind}\` is not supported. Use \`${suggestion}\` instead.`
  ),
  UnsupportedStatementInDeclareModule: _2('Only declares and type imports are allowed inside declare module.'),
  UnterminatedFlowComment: _2('Unterminated flow-comment.'),
}))
function isEsModuleType$1(bodyElement) {
  return (
    bodyElement.type === 'DeclareExportAllDeclaration' ||
    (bodyElement.type === 'DeclareExportDeclaration' &&
      (!bodyElement.declaration ||
        (bodyElement.declaration.type !== 'TypeAlias' && bodyElement.declaration.type !== 'InterfaceDeclaration')))
  )
}
function hasTypeImportKind$1(node2) {
  return node2.importKind === 'type' || node2.importKind === 'typeof'
}
function isMaybeDefaultImport$1(type) {
  return tokenIsKeywordOrIdentifier$1(type) && type !== 97
}
const exportSuggestions$1 = {
  const: 'declare export var',
  let: 'declare export var',
  type: 'export type',
  interface: 'export interface',
}
function partition$1(list2, test) {
  const list1 = []
  const list22 = []
  for (let i = 0; i < list2.length; i++) {
    ;(test(list2[i], i, list2) ? list1 : list22).push(list2[i])
  }
  return [list1, list22]
}
const FLOW_PRAGMA_REGEX$1 = /\*?\s*@((?:no)?flow)\b/
var flow$1 = (superClass) =>
  class extends superClass {
    constructor(...args) {
      super(...args)
      this.flowPragma = void 0
    }
    getScopeHandler() {
      return FlowScopeHandler$1
    }
    shouldParseTypes() {
      return this.getPluginOption('flow', 'all') || this.flowPragma === 'flow'
    }
    shouldParseEnums() {
      return !!this.getPluginOption('flow', 'enums')
    }
    finishToken(type, val) {
      if (type !== 129 && type !== 13 && type !== 28) {
        if (this.flowPragma === void 0) {
          this.flowPragma = null
        }
      }
      return super.finishToken(type, val)
    }
    addComment(comment) {
      if (this.flowPragma === void 0) {
        const matches = FLOW_PRAGMA_REGEX$1.exec(comment.value)
        if (!matches);
        else if (matches[1] === 'flow') {
          this.flowPragma = 'flow'
        } else if (matches[1] === 'noflow') {
          this.flowPragma = 'noflow'
        } else {
          throw new Error('Unexpected flow pragma')
        }
      }
      return super.addComment(comment)
    }
    flowParseTypeInitialiser(tok) {
      const oldInType = this.state.inType
      this.state.inType = true
      this.expect(tok || 14)
      const type = this.flowParseType()
      this.state.inType = oldInType
      return type
    }
    flowParsePredicate() {
      const node2 = this.startNode()
      const moduloLoc = this.state.startLoc
      this.next()
      this.expectContextual(107)
      if (this.state.lastTokStart > moduloLoc.index + 1) {
        this.raise(FlowErrors$1.UnexpectedSpaceBetweenModuloChecks, {
          at: moduloLoc,
        })
      }
      if (this.eat(10)) {
        node2.value = this.parseExpression()
        this.expect(11)
        return this.finishNode(node2, 'DeclaredPredicate')
      } else {
        return this.finishNode(node2, 'InferredPredicate')
      }
    }
    flowParseTypeAndPredicateInitialiser() {
      const oldInType = this.state.inType
      this.state.inType = true
      this.expect(14)
      let type = null
      let predicate = null
      if (this.match(54)) {
        this.state.inType = oldInType
        predicate = this.flowParsePredicate()
      } else {
        type = this.flowParseType()
        this.state.inType = oldInType
        if (this.match(54)) {
          predicate = this.flowParsePredicate()
        }
      }
      return [type, predicate]
    }
    flowParseDeclareClass(node2) {
      this.next()
      this.flowParseInterfaceish(node2, true)
      return this.finishNode(node2, 'DeclareClass')
    }
    flowParseDeclareFunction(node2) {
      this.next()
      const id = (node2.id = this.parseIdentifier())
      const typeNode = this.startNode()
      const typeContainer = this.startNode()
      if (this.match(47)) {
        typeNode.typeParameters = this.flowParseTypeParameterDeclaration()
      } else {
        typeNode.typeParameters = null
      }
      this.expect(10)
      const tmp = this.flowParseFunctionTypeParams()
      typeNode.params = tmp.params
      typeNode.rest = tmp.rest
      typeNode.this = tmp._this
      this.expect(11)
      ;[typeNode.returnType, node2.predicate] = this.flowParseTypeAndPredicateInitialiser()
      typeContainer.typeAnnotation = this.finishNode(typeNode, 'FunctionTypeAnnotation')
      id.typeAnnotation = this.finishNode(typeContainer, 'TypeAnnotation')
      this.resetEndLocation(id)
      this.semicolon()
      this.scope.declareName(node2.id.name, BIND_FLOW_DECLARE_FN$1, node2.id.loc.start)
      return this.finishNode(node2, 'DeclareFunction')
    }
    flowParseDeclare(node2, insideModule) {
      if (this.match(80)) {
        return this.flowParseDeclareClass(node2)
      } else if (this.match(68)) {
        return this.flowParseDeclareFunction(node2)
      } else if (this.match(74)) {
        return this.flowParseDeclareVariable(node2)
      } else if (this.eatContextual(123)) {
        if (this.match(16)) {
          return this.flowParseDeclareModuleExports(node2)
        } else {
          if (insideModule) {
            this.raise(FlowErrors$1.NestedDeclareModule, {
              at: this.state.lastTokStartLoc,
            })
          }
          return this.flowParseDeclareModule(node2)
        }
      } else if (this.isContextual(126)) {
        return this.flowParseDeclareTypeAlias(node2)
      } else if (this.isContextual(127)) {
        return this.flowParseDeclareOpaqueType(node2)
      } else if (this.isContextual(125)) {
        return this.flowParseDeclareInterface(node2)
      } else if (this.match(82)) {
        return this.flowParseDeclareExportDeclaration(node2, insideModule)
      } else {
        throw this.unexpected()
      }
    }
    flowParseDeclareVariable(node2) {
      this.next()
      node2.id = this.flowParseTypeAnnotatableIdentifier(true)
      this.scope.declareName(node2.id.name, BIND_VAR$1, node2.id.loc.start)
      this.semicolon()
      return this.finishNode(node2, 'DeclareVariable')
    }
    flowParseDeclareModule(node2) {
      this.scope.enter(SCOPE_OTHER$1)
      if (this.match(129)) {
        node2.id = this.parseExprAtom()
      } else {
        node2.id = this.parseIdentifier()
      }
      const bodyNode = (node2.body = this.startNode())
      const body = (bodyNode.body = [])
      this.expect(5)
      while (!this.match(8)) {
        let bodyNode2 = this.startNode()
        if (this.match(83)) {
          this.next()
          if (!this.isContextual(126) && !this.match(87)) {
            this.raise(FlowErrors$1.InvalidNonTypeImportInDeclareModule, {
              at: this.state.lastTokStartLoc,
            })
          }
          this.parseImport(bodyNode2)
        } else {
          this.expectContextual(121, FlowErrors$1.UnsupportedStatementInDeclareModule)
          bodyNode2 = this.flowParseDeclare(bodyNode2, true)
        }
        body.push(bodyNode2)
      }
      this.scope.exit()
      this.expect(8)
      this.finishNode(bodyNode, 'BlockStatement')
      let kind = null
      let hasModuleExport = false
      body.forEach((bodyElement) => {
        if (isEsModuleType$1(bodyElement)) {
          if (kind === 'CommonJS') {
            this.raise(FlowErrors$1.AmbiguousDeclareModuleKind, {
              at: bodyElement,
            })
          }
          kind = 'ES'
        } else if (bodyElement.type === 'DeclareModuleExports') {
          if (hasModuleExport) {
            this.raise(FlowErrors$1.DuplicateDeclareModuleExports, {
              at: bodyElement,
            })
          }
          if (kind === 'ES') {
            this.raise(FlowErrors$1.AmbiguousDeclareModuleKind, {
              at: bodyElement,
            })
          }
          kind = 'CommonJS'
          hasModuleExport = true
        }
      })
      node2.kind = kind || 'CommonJS'
      return this.finishNode(node2, 'DeclareModule')
    }
    flowParseDeclareExportDeclaration(node2, insideModule) {
      this.expect(82)
      if (this.eat(65)) {
        if (this.match(68) || this.match(80)) {
          node2.declaration = this.flowParseDeclare(this.startNode())
        } else {
          node2.declaration = this.flowParseType()
          this.semicolon()
        }
        node2.default = true
        return this.finishNode(node2, 'DeclareExportDeclaration')
      } else {
        if (this.match(75) || this.isLet() || ((this.isContextual(126) || this.isContextual(125)) && !insideModule)) {
          const label = this.state.value
          throw this.raise(FlowErrors$1.UnsupportedDeclareExportKind, {
            at: this.state.startLoc,
            unsupportedExportKind: label,
            suggestion: exportSuggestions$1[label],
          })
        }
        if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(127)) {
          node2.declaration = this.flowParseDeclare(this.startNode())
          node2.default = false
          return this.finishNode(node2, 'DeclareExportDeclaration')
        } else if (
          this.match(55) ||
          this.match(5) ||
          this.isContextual(125) ||
          this.isContextual(126) ||
          this.isContextual(127)
        ) {
          node2 = this.parseExport(node2)
          if (node2.type === 'ExportNamedDeclaration') {
            node2.type = 'ExportDeclaration'
            node2.default = false
            delete node2.exportKind
          }
          node2.type = 'Declare' + node2.type
          return node2
        }
      }
      throw this.unexpected()
    }
    flowParseDeclareModuleExports(node2) {
      this.next()
      this.expectContextual(108)
      node2.typeAnnotation = this.flowParseTypeAnnotation()
      this.semicolon()
      return this.finishNode(node2, 'DeclareModuleExports')
    }
    flowParseDeclareTypeAlias(node2) {
      this.next()
      this.flowParseTypeAlias(node2)
      node2.type = 'DeclareTypeAlias'
      return node2
    }
    flowParseDeclareOpaqueType(node2) {
      this.next()
      this.flowParseOpaqueType(node2, true)
      node2.type = 'DeclareOpaqueType'
      return node2
    }
    flowParseDeclareInterface(node2) {
      this.next()
      this.flowParseInterfaceish(node2)
      return this.finishNode(node2, 'DeclareInterface')
    }
    flowParseInterfaceish(node2, isClass2 = false) {
      node2.id = this.flowParseRestrictedIdentifier(!isClass2, true)
      this.scope.declareName(node2.id.name, isClass2 ? BIND_FUNCTION$1 : BIND_LEXICAL$1, node2.id.loc.start)
      if (this.match(47)) {
        node2.typeParameters = this.flowParseTypeParameterDeclaration()
      } else {
        node2.typeParameters = null
      }
      node2.extends = []
      node2.implements = []
      node2.mixins = []
      if (this.eat(81)) {
        do {
          node2.extends.push(this.flowParseInterfaceExtends())
        } while (!isClass2 && this.eat(12))
      }
      if (this.isContextual(114)) {
        this.next()
        do {
          node2.mixins.push(this.flowParseInterfaceExtends())
        } while (this.eat(12))
      }
      if (this.isContextual(110)) {
        this.next()
        do {
          node2.implements.push(this.flowParseInterfaceExtends())
        } while (this.eat(12))
      }
      node2.body = this.flowParseObjectType({
        allowStatic: isClass2,
        allowExact: false,
        allowSpread: false,
        allowProto: isClass2,
        allowInexact: false,
      })
    }
    flowParseInterfaceExtends() {
      const node2 = this.startNode()
      node2.id = this.flowParseQualifiedTypeIdentifier()
      if (this.match(47)) {
        node2.typeParameters = this.flowParseTypeParameterInstantiation()
      } else {
        node2.typeParameters = null
      }
      return this.finishNode(node2, 'InterfaceExtends')
    }
    flowParseInterface(node2) {
      this.flowParseInterfaceish(node2)
      return this.finishNode(node2, 'InterfaceDeclaration')
    }
    checkNotUnderscore(word) {
      if (word === '_') {
        this.raise(FlowErrors$1.UnexpectedReservedUnderscore, {
          at: this.state.startLoc,
        })
      }
    }
    checkReservedType(word, startLoc, declaration) {
      if (!reservedTypes$1.has(word)) return
      this.raise(declaration ? FlowErrors$1.AssignReservedType : FlowErrors$1.UnexpectedReservedType, {
        at: startLoc,
        reservedType: word,
      })
    }
    flowParseRestrictedIdentifier(liberal, declaration) {
      this.checkReservedType(this.state.value, this.state.startLoc, declaration)
      return this.parseIdentifier(liberal)
    }
    flowParseTypeAlias(node2) {
      node2.id = this.flowParseRestrictedIdentifier(false, true)
      this.scope.declareName(node2.id.name, BIND_LEXICAL$1, node2.id.loc.start)
      if (this.match(47)) {
        node2.typeParameters = this.flowParseTypeParameterDeclaration()
      } else {
        node2.typeParameters = null
      }
      node2.right = this.flowParseTypeInitialiser(29)
      this.semicolon()
      return this.finishNode(node2, 'TypeAlias')
    }
    flowParseOpaqueType(node2, declare) {
      this.expectContextual(126)
      node2.id = this.flowParseRestrictedIdentifier(true, true)
      this.scope.declareName(node2.id.name, BIND_LEXICAL$1, node2.id.loc.start)
      if (this.match(47)) {
        node2.typeParameters = this.flowParseTypeParameterDeclaration()
      } else {
        node2.typeParameters = null
      }
      node2.supertype = null
      if (this.match(14)) {
        node2.supertype = this.flowParseTypeInitialiser(14)
      }
      node2.impltype = null
      if (!declare) {
        node2.impltype = this.flowParseTypeInitialiser(29)
      }
      this.semicolon()
      return this.finishNode(node2, 'OpaqueType')
    }
    flowParseTypeParameter(requireDefault = false) {
      const nodeStartLoc = this.state.startLoc
      const node2 = this.startNode()
      const variance2 = this.flowParseVariance()
      const ident = this.flowParseTypeAnnotatableIdentifier()
      node2.name = ident.name
      node2.variance = variance2
      node2.bound = ident.typeAnnotation
      if (this.match(29)) {
        this.eat(29)
        node2.default = this.flowParseType()
      } else {
        if (requireDefault) {
          this.raise(FlowErrors$1.MissingTypeParamDefault, {
            at: nodeStartLoc,
          })
        }
      }
      return this.finishNode(node2, 'TypeParameter')
    }
    flowParseTypeParameterDeclaration() {
      const oldInType = this.state.inType
      const node2 = this.startNode()
      node2.params = []
      this.state.inType = true
      if (this.match(47) || this.match(138)) {
        this.next()
      } else {
        this.unexpected()
      }
      let defaultRequired = false
      do {
        const typeParameter2 = this.flowParseTypeParameter(defaultRequired)
        node2.params.push(typeParameter2)
        if (typeParameter2.default) {
          defaultRequired = true
        }
        if (!this.match(48)) {
          this.expect(12)
        }
      } while (!this.match(48))
      this.expect(48)
      this.state.inType = oldInType
      return this.finishNode(node2, 'TypeParameterDeclaration')
    }
    flowParseTypeParameterInstantiation() {
      const node2 = this.startNode()
      const oldInType = this.state.inType
      node2.params = []
      this.state.inType = true
      this.expect(47)
      const oldNoAnonFunctionType = this.state.noAnonFunctionType
      this.state.noAnonFunctionType = false
      while (!this.match(48)) {
        node2.params.push(this.flowParseType())
        if (!this.match(48)) {
          this.expect(12)
        }
      }
      this.state.noAnonFunctionType = oldNoAnonFunctionType
      this.expect(48)
      this.state.inType = oldInType
      return this.finishNode(node2, 'TypeParameterInstantiation')
    }
    flowParseTypeParameterInstantiationCallOrNew() {
      const node2 = this.startNode()
      const oldInType = this.state.inType
      node2.params = []
      this.state.inType = true
      this.expect(47)
      while (!this.match(48)) {
        node2.params.push(this.flowParseTypeOrImplicitInstantiation())
        if (!this.match(48)) {
          this.expect(12)
        }
      }
      this.expect(48)
      this.state.inType = oldInType
      return this.finishNode(node2, 'TypeParameterInstantiation')
    }
    flowParseInterfaceType() {
      const node2 = this.startNode()
      this.expectContextual(125)
      node2.extends = []
      if (this.eat(81)) {
        do {
          node2.extends.push(this.flowParseInterfaceExtends())
        } while (this.eat(12))
      }
      node2.body = this.flowParseObjectType({
        allowStatic: false,
        allowExact: false,
        allowSpread: false,
        allowProto: false,
        allowInexact: false,
      })
      return this.finishNode(node2, 'InterfaceTypeAnnotation')
    }
    flowParseObjectPropertyKey() {
      return this.match(130) || this.match(129) ? this.parseExprAtom() : this.parseIdentifier(true)
    }
    flowParseObjectTypeIndexer(node2, isStatic2, variance2) {
      node2.static = isStatic2
      if (this.lookahead().type === 14) {
        node2.id = this.flowParseObjectPropertyKey()
        node2.key = this.flowParseTypeInitialiser()
      } else {
        node2.id = null
        node2.key = this.flowParseType()
      }
      this.expect(3)
      node2.value = this.flowParseTypeInitialiser()
      node2.variance = variance2
      return this.finishNode(node2, 'ObjectTypeIndexer')
    }
    flowParseObjectTypeInternalSlot(node2, isStatic2) {
      node2.static = isStatic2
      node2.id = this.flowParseObjectPropertyKey()
      this.expect(3)
      this.expect(3)
      if (this.match(47) || this.match(10)) {
        node2.method = true
        node2.optional = false
        node2.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node2.start, node2.loc.start))
      } else {
        node2.method = false
        if (this.eat(17)) {
          node2.optional = true
        }
        node2.value = this.flowParseTypeInitialiser()
      }
      return this.finishNode(node2, 'ObjectTypeInternalSlot')
    }
    flowParseObjectTypeMethodish(node2) {
      node2.params = []
      node2.rest = null
      node2.typeParameters = null
      node2.this = null
      if (this.match(47)) {
        node2.typeParameters = this.flowParseTypeParameterDeclaration()
      }
      this.expect(10)
      if (this.match(78)) {
        node2.this = this.flowParseFunctionTypeParam(true)
        node2.this.name = null
        if (!this.match(11)) {
          this.expect(12)
        }
      }
      while (!this.match(11) && !this.match(21)) {
        node2.params.push(this.flowParseFunctionTypeParam(false))
        if (!this.match(11)) {
          this.expect(12)
        }
      }
      if (this.eat(21)) {
        node2.rest = this.flowParseFunctionTypeParam(false)
      }
      this.expect(11)
      node2.returnType = this.flowParseTypeInitialiser()
      return this.finishNode(node2, 'FunctionTypeAnnotation')
    }
    flowParseObjectTypeCallProperty(node2, isStatic2) {
      const valueNode = this.startNode()
      node2.static = isStatic2
      node2.value = this.flowParseObjectTypeMethodish(valueNode)
      return this.finishNode(node2, 'ObjectTypeCallProperty')
    }
    flowParseObjectType({ allowStatic, allowExact, allowSpread, allowProto, allowInexact }) {
      const oldInType = this.state.inType
      this.state.inType = true
      const nodeStart = this.startNode()
      nodeStart.callProperties = []
      nodeStart.properties = []
      nodeStart.indexers = []
      nodeStart.internalSlots = []
      let endDelim
      let exact
      let inexact2 = false
      if (allowExact && this.match(6)) {
        this.expect(6)
        endDelim = 9
        exact = true
      } else {
        this.expect(5)
        endDelim = 8
        exact = false
      }
      nodeStart.exact = exact
      while (!this.match(endDelim)) {
        let isStatic2 = false
        let protoStartLoc = null
        let inexactStartLoc = null
        const node2 = this.startNode()
        if (allowProto && this.isContextual(115)) {
          const lookahead = this.lookahead()
          if (lookahead.type !== 14 && lookahead.type !== 17) {
            this.next()
            protoStartLoc = this.state.startLoc
            allowStatic = false
          }
        }
        if (allowStatic && this.isContextual(104)) {
          const lookahead = this.lookahead()
          if (lookahead.type !== 14 && lookahead.type !== 17) {
            this.next()
            isStatic2 = true
          }
        }
        const variance2 = this.flowParseVariance()
        if (this.eat(0)) {
          if (protoStartLoc != null) {
            this.unexpected(protoStartLoc)
          }
          if (this.eat(0)) {
            if (variance2) {
              this.unexpected(variance2.loc.start)
            }
            nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node2, isStatic2))
          } else {
            nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node2, isStatic2, variance2))
          }
        } else if (this.match(10) || this.match(47)) {
          if (protoStartLoc != null) {
            this.unexpected(protoStartLoc)
          }
          if (variance2) {
            this.unexpected(variance2.loc.start)
          }
          nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node2, isStatic2))
        } else {
          let kind = 'init'
          if (this.isContextual(98) || this.isContextual(103)) {
            const lookahead = this.lookahead()
            if (tokenIsLiteralPropertyName$1(lookahead.type)) {
              kind = this.state.value
              this.next()
            }
          }
          const propOrInexact = this.flowParseObjectTypeProperty(
            node2,
            isStatic2,
            protoStartLoc,
            variance2,
            kind,
            allowSpread,
            allowInexact != null ? allowInexact : !exact
          )
          if (propOrInexact === null) {
            inexact2 = true
            inexactStartLoc = this.state.lastTokStartLoc
          } else {
            nodeStart.properties.push(propOrInexact)
          }
        }
        this.flowObjectTypeSemicolon()
        if (inexactStartLoc && !this.match(8) && !this.match(9)) {
          this.raise(FlowErrors$1.UnexpectedExplicitInexactInObject, {
            at: inexactStartLoc,
          })
        }
      }
      this.expect(endDelim)
      if (allowSpread) {
        nodeStart.inexact = inexact2
      }
      const out = this.finishNode(nodeStart, 'ObjectTypeAnnotation')
      this.state.inType = oldInType
      return out
    }
    flowParseObjectTypeProperty(node2, isStatic2, protoStartLoc, variance2, kind, allowSpread, allowInexact) {
      if (this.eat(21)) {
        const isInexactToken = this.match(12) || this.match(13) || this.match(8) || this.match(9)
        if (isInexactToken) {
          if (!allowSpread) {
            this.raise(FlowErrors$1.InexactInsideNonObject, {
              at: this.state.lastTokStartLoc,
            })
          } else if (!allowInexact) {
            this.raise(FlowErrors$1.InexactInsideExact, {
              at: this.state.lastTokStartLoc,
            })
          }
          if (variance2) {
            this.raise(FlowErrors$1.InexactVariance, {
              at: variance2,
            })
          }
          return null
        }
        if (!allowSpread) {
          this.raise(FlowErrors$1.UnexpectedSpreadType, {
            at: this.state.lastTokStartLoc,
          })
        }
        if (protoStartLoc != null) {
          this.unexpected(protoStartLoc)
        }
        if (variance2) {
          this.raise(FlowErrors$1.SpreadVariance, {
            at: variance2,
          })
        }
        node2.argument = this.flowParseType()
        return this.finishNode(node2, 'ObjectTypeSpreadProperty')
      } else {
        node2.key = this.flowParseObjectPropertyKey()
        node2.static = isStatic2
        node2.proto = protoStartLoc != null
        node2.kind = kind
        let optional = false
        if (this.match(47) || this.match(10)) {
          node2.method = true
          if (protoStartLoc != null) {
            this.unexpected(protoStartLoc)
          }
          if (variance2) {
            this.unexpected(variance2.loc.start)
          }
          node2.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node2.start, node2.loc.start))
          if (kind === 'get' || kind === 'set') {
            this.flowCheckGetterSetterParams(node2)
          }
          if (!allowSpread && node2.key.name === 'constructor' && node2.value.this) {
            this.raise(FlowErrors$1.ThisParamBannedInConstructor, {
              at: node2.value.this,
            })
          }
        } else {
          if (kind !== 'init') this.unexpected()
          node2.method = false
          if (this.eat(17)) {
            optional = true
          }
          node2.value = this.flowParseTypeInitialiser()
          node2.variance = variance2
        }
        node2.optional = optional
        return this.finishNode(node2, 'ObjectTypeProperty')
      }
    }
    flowCheckGetterSetterParams(property) {
      const paramCount = property.kind === 'get' ? 0 : 1
      const length = property.value.params.length + (property.value.rest ? 1 : 0)
      if (property.value.this) {
        this.raise(
          property.kind === 'get' ? FlowErrors$1.GetterMayNotHaveThisParam : FlowErrors$1.SetterMayNotHaveThisParam,
          {
            at: property.value.this,
          }
        )
      }
      if (length !== paramCount) {
        this.raise(property.kind === 'get' ? Errors$1.BadGetterArity : Errors$1.BadSetterArity, {
          at: property,
        })
      }
      if (property.kind === 'set' && property.value.rest) {
        this.raise(Errors$1.BadSetterRestParameter, {
          at: property,
        })
      }
    }
    flowObjectTypeSemicolon() {
      if (!this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9)) {
        this.unexpected()
      }
    }
    flowParseQualifiedTypeIdentifier(startPos, startLoc, id) {
      startPos = startPos || this.state.start
      startLoc = startLoc || this.state.startLoc
      let node2 = id || this.flowParseRestrictedIdentifier(true)
      while (this.eat(16)) {
        const node22 = this.startNodeAt(startPos, startLoc)
        node22.qualification = node2
        node22.id = this.flowParseRestrictedIdentifier(true)
        node2 = this.finishNode(node22, 'QualifiedTypeIdentifier')
      }
      return node2
    }
    flowParseGenericType(startPos, startLoc, id) {
      const node2 = this.startNodeAt(startPos, startLoc)
      node2.typeParameters = null
      node2.id = this.flowParseQualifiedTypeIdentifier(startPos, startLoc, id)
      if (this.match(47)) {
        node2.typeParameters = this.flowParseTypeParameterInstantiation()
      }
      return this.finishNode(node2, 'GenericTypeAnnotation')
    }
    flowParseTypeofType() {
      const node2 = this.startNode()
      this.expect(87)
      node2.argument = this.flowParsePrimaryType()
      return this.finishNode(node2, 'TypeofTypeAnnotation')
    }
    flowParseTupleType() {
      const node2 = this.startNode()
      node2.types = []
      this.expect(0)
      while (this.state.pos < this.length && !this.match(3)) {
        node2.types.push(this.flowParseType())
        if (this.match(3)) break
        this.expect(12)
      }
      this.expect(3)
      return this.finishNode(node2, 'TupleTypeAnnotation')
    }
    flowParseFunctionTypeParam(first) {
      let name = null
      let optional = false
      let typeAnnotation2 = null
      const node2 = this.startNode()
      const lh = this.lookahead()
      const isThis = this.state.type === 78
      if (lh.type === 14 || lh.type === 17) {
        if (isThis && !first) {
          this.raise(FlowErrors$1.ThisParamMustBeFirst, {
            at: node2,
          })
        }
        name = this.parseIdentifier(isThis)
        if (this.eat(17)) {
          optional = true
          if (isThis) {
            this.raise(FlowErrors$1.ThisParamMayNotBeOptional, {
              at: node2,
            })
          }
        }
        typeAnnotation2 = this.flowParseTypeInitialiser()
      } else {
        typeAnnotation2 = this.flowParseType()
      }
      node2.name = name
      node2.optional = optional
      node2.typeAnnotation = typeAnnotation2
      return this.finishNode(node2, 'FunctionTypeParam')
    }
    reinterpretTypeAsFunctionTypeParam(type) {
      const node2 = this.startNodeAt(type.start, type.loc.start)
      node2.name = null
      node2.optional = false
      node2.typeAnnotation = type
      return this.finishNode(node2, 'FunctionTypeParam')
    }
    flowParseFunctionTypeParams(params = []) {
      let rest = null
      let _this = null
      if (this.match(78)) {
        _this = this.flowParseFunctionTypeParam(true)
        _this.name = null
        if (!this.match(11)) {
          this.expect(12)
        }
      }
      while (!this.match(11) && !this.match(21)) {
        params.push(this.flowParseFunctionTypeParam(false))
        if (!this.match(11)) {
          this.expect(12)
        }
      }
      if (this.eat(21)) {
        rest = this.flowParseFunctionTypeParam(false)
      }
      return {
        params,
        rest,
        _this,
      }
    }
    flowIdentToTypeAnnotation(startPos, startLoc, node2, id) {
      switch (id.name) {
        case 'any':
          return this.finishNode(node2, 'AnyTypeAnnotation')
        case 'bool':
        case 'boolean':
          return this.finishNode(node2, 'BooleanTypeAnnotation')
        case 'mixed':
          return this.finishNode(node2, 'MixedTypeAnnotation')
        case 'empty':
          return this.finishNode(node2, 'EmptyTypeAnnotation')
        case 'number':
          return this.finishNode(node2, 'NumberTypeAnnotation')
        case 'string':
          return this.finishNode(node2, 'StringTypeAnnotation')
        case 'symbol':
          return this.finishNode(node2, 'SymbolTypeAnnotation')
        default:
          this.checkNotUnderscore(id.name)
          return this.flowParseGenericType(startPos, startLoc, id)
      }
    }
    flowParsePrimaryType() {
      const startPos = this.state.start
      const startLoc = this.state.startLoc
      const node2 = this.startNode()
      let tmp
      let type
      let isGroupedType = false
      const oldNoAnonFunctionType = this.state.noAnonFunctionType
      switch (this.state.type) {
        case 5:
          return this.flowParseObjectType({
            allowStatic: false,
            allowExact: false,
            allowSpread: true,
            allowProto: false,
            allowInexact: true,
          })
        case 6:
          return this.flowParseObjectType({
            allowStatic: false,
            allowExact: true,
            allowSpread: true,
            allowProto: false,
            allowInexact: false,
          })
        case 0:
          this.state.noAnonFunctionType = false
          type = this.flowParseTupleType()
          this.state.noAnonFunctionType = oldNoAnonFunctionType
          return type
        case 47:
          node2.typeParameters = this.flowParseTypeParameterDeclaration()
          this.expect(10)
          tmp = this.flowParseFunctionTypeParams()
          node2.params = tmp.params
          node2.rest = tmp.rest
          node2.this = tmp._this
          this.expect(11)
          this.expect(19)
          node2.returnType = this.flowParseType()
          return this.finishNode(node2, 'FunctionTypeAnnotation')
        case 10:
          this.next()
          if (!this.match(11) && !this.match(21)) {
            if (tokenIsIdentifier$1(this.state.type) || this.match(78)) {
              const token = this.lookahead().type
              isGroupedType = token !== 17 && token !== 14
            } else {
              isGroupedType = true
            }
          }
          if (isGroupedType) {
            this.state.noAnonFunctionType = false
            type = this.flowParseType()
            this.state.noAnonFunctionType = oldNoAnonFunctionType
            if (
              this.state.noAnonFunctionType ||
              !(this.match(12) || (this.match(11) && this.lookahead().type === 19))
            ) {
              this.expect(11)
              return type
            } else {
              this.eat(12)
            }
          }
          if (type) {
            tmp = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type)])
          } else {
            tmp = this.flowParseFunctionTypeParams()
          }
          node2.params = tmp.params
          node2.rest = tmp.rest
          node2.this = tmp._this
          this.expect(11)
          this.expect(19)
          node2.returnType = this.flowParseType()
          node2.typeParameters = null
          return this.finishNode(node2, 'FunctionTypeAnnotation')
        case 129:
          return this.parseLiteral(this.state.value, 'StringLiteralTypeAnnotation')
        case 85:
        case 86:
          node2.value = this.match(85)
          this.next()
          return this.finishNode(node2, 'BooleanLiteralTypeAnnotation')
        case 53:
          if (this.state.value === '-') {
            this.next()
            if (this.match(130)) {
              return this.parseLiteralAtNode(-this.state.value, 'NumberLiteralTypeAnnotation', node2)
            }
            if (this.match(131)) {
              return this.parseLiteralAtNode(-this.state.value, 'BigIntLiteralTypeAnnotation', node2)
            }
            throw this.raise(FlowErrors$1.UnexpectedSubtractionOperand, {
              at: this.state.startLoc,
            })
          }
          throw this.unexpected()
        case 130:
          return this.parseLiteral(this.state.value, 'NumberLiteralTypeAnnotation')
        case 131:
          return this.parseLiteral(this.state.value, 'BigIntLiteralTypeAnnotation')
        case 88:
          this.next()
          return this.finishNode(node2, 'VoidTypeAnnotation')
        case 84:
          this.next()
          return this.finishNode(node2, 'NullLiteralTypeAnnotation')
        case 78:
          this.next()
          return this.finishNode(node2, 'ThisTypeAnnotation')
        case 55:
          this.next()
          return this.finishNode(node2, 'ExistsTypeAnnotation')
        case 87:
          return this.flowParseTypeofType()
        default:
          if (tokenIsKeyword$1(this.state.type)) {
            const label = tokenLabelName$1(this.state.type)
            this.next()
            return super.createIdentifier(node2, label)
          } else if (tokenIsIdentifier$1(this.state.type)) {
            if (this.isContextual(125)) {
              return this.flowParseInterfaceType()
            }
            return this.flowIdentToTypeAnnotation(startPos, startLoc, node2, this.parseIdentifier())
          }
      }
      throw this.unexpected()
    }
    flowParsePostfixType() {
      const startPos = this.state.start
      const startLoc = this.state.startLoc
      let type = this.flowParsePrimaryType()
      let seenOptionalIndexedAccess = false
      while ((this.match(0) || this.match(18)) && !this.canInsertSemicolon()) {
        const node2 = this.startNodeAt(startPos, startLoc)
        const optional = this.eat(18)
        seenOptionalIndexedAccess = seenOptionalIndexedAccess || optional
        this.expect(0)
        if (!optional && this.match(3)) {
          node2.elementType = type
          this.next()
          type = this.finishNode(node2, 'ArrayTypeAnnotation')
        } else {
          node2.objectType = type
          node2.indexType = this.flowParseType()
          this.expect(3)
          if (seenOptionalIndexedAccess) {
            node2.optional = optional
            type = this.finishNode(node2, 'OptionalIndexedAccessType')
          } else {
            type = this.finishNode(node2, 'IndexedAccessType')
          }
        }
      }
      return type
    }
    flowParsePrefixType() {
      const node2 = this.startNode()
      if (this.eat(17)) {
        node2.typeAnnotation = this.flowParsePrefixType()
        return this.finishNode(node2, 'NullableTypeAnnotation')
      } else {
        return this.flowParsePostfixType()
      }
    }
    flowParseAnonFunctionWithoutParens() {
      const param = this.flowParsePrefixType()
      if (!this.state.noAnonFunctionType && this.eat(19)) {
        const node2 = this.startNodeAt(param.start, param.loc.start)
        node2.params = [this.reinterpretTypeAsFunctionTypeParam(param)]
        node2.rest = null
        node2.this = null
        node2.returnType = this.flowParseType()
        node2.typeParameters = null
        return this.finishNode(node2, 'FunctionTypeAnnotation')
      }
      return param
    }
    flowParseIntersectionType() {
      const node2 = this.startNode()
      this.eat(45)
      const type = this.flowParseAnonFunctionWithoutParens()
      node2.types = [type]
      while (this.eat(45)) {
        node2.types.push(this.flowParseAnonFunctionWithoutParens())
      }
      return node2.types.length === 1 ? type : this.finishNode(node2, 'IntersectionTypeAnnotation')
    }
    flowParseUnionType() {
      const node2 = this.startNode()
      this.eat(43)
      const type = this.flowParseIntersectionType()
      node2.types = [type]
      while (this.eat(43)) {
        node2.types.push(this.flowParseIntersectionType())
      }
      return node2.types.length === 1 ? type : this.finishNode(node2, 'UnionTypeAnnotation')
    }
    flowParseType() {
      const oldInType = this.state.inType
      this.state.inType = true
      const type = this.flowParseUnionType()
      this.state.inType = oldInType
      return type
    }
    flowParseTypeOrImplicitInstantiation() {
      if (this.state.type === 128 && this.state.value === '_') {
        const startPos = this.state.start
        const startLoc = this.state.startLoc
        const node2 = this.parseIdentifier()
        return this.flowParseGenericType(startPos, startLoc, node2)
      } else {
        return this.flowParseType()
      }
    }
    flowParseTypeAnnotation() {
      const node2 = this.startNode()
      node2.typeAnnotation = this.flowParseTypeInitialiser()
      return this.finishNode(node2, 'TypeAnnotation')
    }
    flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {
      const ident = allowPrimitiveOverride ? this.parseIdentifier() : this.flowParseRestrictedIdentifier()
      if (this.match(14)) {
        ident.typeAnnotation = this.flowParseTypeAnnotation()
        this.resetEndLocation(ident)
      }
      return ident
    }
    typeCastToParameter(node2) {
      node2.expression.typeAnnotation = node2.typeAnnotation
      this.resetEndLocation(node2.expression, node2.typeAnnotation.loc.end)
      return node2.expression
    }
    flowParseVariance() {
      let variance2 = null
      if (this.match(53)) {
        variance2 = this.startNode()
        if (this.state.value === '+') {
          variance2.kind = 'plus'
        } else {
          variance2.kind = 'minus'
        }
        this.next()
        this.finishNode(variance2, 'Variance')
      }
      return variance2
    }
    parseFunctionBody(node2, allowExpressionBody, isMethod2 = false) {
      if (allowExpressionBody) {
        return this.forwardNoArrowParamsConversionAt(node2, () => super.parseFunctionBody(node2, true, isMethod2))
      }
      return super.parseFunctionBody(node2, false, isMethod2)
    }
    parseFunctionBodyAndFinish(node2, type, isMethod2 = false) {
      if (this.match(14)) {
        const typeNode = this.startNode()
        ;[typeNode.typeAnnotation, node2.predicate] = this.flowParseTypeAndPredicateInitialiser()
        node2.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, 'TypeAnnotation') : null
      }
      super.parseFunctionBodyAndFinish(node2, type, isMethod2)
    }
    parseStatement(context2, topLevel) {
      if (this.state.strict && this.isContextual(125)) {
        const lookahead = this.lookahead()
        if (tokenIsKeywordOrIdentifier$1(lookahead.type)) {
          const node2 = this.startNode()
          this.next()
          return this.flowParseInterface(node2)
        }
      } else if (this.shouldParseEnums() && this.isContextual(122)) {
        const node2 = this.startNode()
        this.next()
        return this.flowParseEnumDeclaration(node2)
      }
      const stmt = super.parseStatement(context2, topLevel)
      if (this.flowPragma === void 0 && !this.isValidDirective(stmt)) {
        this.flowPragma = null
      }
      return stmt
    }
    parseExpressionStatement(node2, expr) {
      if (expr.type === 'Identifier') {
        if (expr.name === 'declare') {
          if (
            this.match(80) ||
            tokenIsIdentifier$1(this.state.type) ||
            this.match(68) ||
            this.match(74) ||
            this.match(82)
          ) {
            return this.flowParseDeclare(node2)
          }
        } else if (tokenIsIdentifier$1(this.state.type)) {
          if (expr.name === 'interface') {
            return this.flowParseInterface(node2)
          } else if (expr.name === 'type') {
            return this.flowParseTypeAlias(node2)
          } else if (expr.name === 'opaque') {
            return this.flowParseOpaqueType(node2, false)
          }
        }
      }
      return super.parseExpressionStatement(node2, expr)
    }
    shouldParseExportDeclaration() {
      const { type } = this.state
      if (tokenIsFlowInterfaceOrTypeOrOpaque$1(type) || (this.shouldParseEnums() && type === 122)) {
        return !this.state.containsEsc
      }
      return super.shouldParseExportDeclaration()
    }
    isExportDefaultSpecifier() {
      const { type } = this.state
      if (tokenIsFlowInterfaceOrTypeOrOpaque$1(type) || (this.shouldParseEnums() && type === 122)) {
        return this.state.containsEsc
      }
      return super.isExportDefaultSpecifier()
    }
    parseExportDefaultExpression() {
      if (this.shouldParseEnums() && this.isContextual(122)) {
        const node2 = this.startNode()
        this.next()
        return this.flowParseEnumDeclaration(node2)
      }
      return super.parseExportDefaultExpression()
    }
    parseConditional(expr, startPos, startLoc, refExpressionErrors) {
      if (!this.match(17)) return expr
      if (this.state.maybeInArrowParameters) {
        const nextCh = this.lookaheadCharCode()
        if (nextCh === 44 || nextCh === 61 || nextCh === 58 || nextCh === 41) {
          this.setOptionalParametersError(refExpressionErrors)
          return expr
        }
      }
      this.expect(17)
      const state = this.state.clone()
      const originalNoArrowAt = this.state.noArrowAt
      const node2 = this.startNodeAt(startPos, startLoc)
      let { consequent, failed } = this.tryParseConditionalConsequent()
      let [valid, invalid] = this.getArrowLikeExpressions(consequent)
      if (failed || invalid.length > 0) {
        const noArrowAt = [...originalNoArrowAt]
        if (invalid.length > 0) {
          this.state = state
          this.state.noArrowAt = noArrowAt
          for (let i = 0; i < invalid.length; i++) {
            noArrowAt.push(invalid[i].start)
          }
          ;({ consequent, failed } = this.tryParseConditionalConsequent())
          ;[valid, invalid] = this.getArrowLikeExpressions(consequent)
        }
        if (failed && valid.length > 1) {
          this.raise(FlowErrors$1.AmbiguousConditionalArrow, {
            at: state.startLoc,
          })
        }
        if (failed && valid.length === 1) {
          this.state = state
          noArrowAt.push(valid[0].start)
          this.state.noArrowAt = noArrowAt
          ;({ consequent, failed } = this.tryParseConditionalConsequent())
        }
      }
      this.getArrowLikeExpressions(consequent, true)
      this.state.noArrowAt = originalNoArrowAt
      this.expect(14)
      node2.test = expr
      node2.consequent = consequent
      node2.alternate = this.forwardNoArrowParamsConversionAt(node2, () => this.parseMaybeAssign(void 0, void 0))
      return this.finishNode(node2, 'ConditionalExpression')
    }
    tryParseConditionalConsequent() {
      this.state.noArrowParamsConversionAt.push(this.state.start)
      const consequent = this.parseMaybeAssignAllowIn()
      const failed = !this.match(14)
      this.state.noArrowParamsConversionAt.pop()
      return {
        consequent,
        failed,
      }
    }
    getArrowLikeExpressions(node2, disallowInvalid) {
      const stack = [node2]
      const arrows = []
      while (stack.length !== 0) {
        const node3 = stack.pop()
        if (node3.type === 'ArrowFunctionExpression') {
          if (node3.typeParameters || !node3.returnType) {
            this.finishArrowValidation(node3)
          } else {
            arrows.push(node3)
          }
          stack.push(node3.body)
        } else if (node3.type === 'ConditionalExpression') {
          stack.push(node3.consequent)
          stack.push(node3.alternate)
        }
      }
      if (disallowInvalid) {
        arrows.forEach((node3) => this.finishArrowValidation(node3))
        return [arrows, []]
      }
      return partition$1(arrows, (node3) => node3.params.every((param) => this.isAssignable(param, true)))
    }
    finishArrowValidation(node2) {
      var _node$extra
      this.toAssignableList(
        node2.params,
        (_node$extra = node2.extra) == null ? void 0 : _node$extra.trailingCommaLoc,
        false
      )
      this.scope.enter(SCOPE_FUNCTION$1 | SCOPE_ARROW$1)
      super.checkParams(node2, false, true)
      this.scope.exit()
    }
    forwardNoArrowParamsConversionAt(node2, parse2) {
      let result
      if (this.state.noArrowParamsConversionAt.indexOf(node2.start) !== -1) {
        this.state.noArrowParamsConversionAt.push(this.state.start)
        result = parse2()
        this.state.noArrowParamsConversionAt.pop()
      } else {
        result = parse2()
      }
      return result
    }
    parseParenItem(node2, startPos, startLoc) {
      node2 = super.parseParenItem(node2, startPos, startLoc)
      if (this.eat(17)) {
        node2.optional = true
        this.resetEndLocation(node2)
      }
      if (this.match(14)) {
        const typeCastNode = this.startNodeAt(startPos, startLoc)
        typeCastNode.expression = node2
        typeCastNode.typeAnnotation = this.flowParseTypeAnnotation()
        return this.finishNode(typeCastNode, 'TypeCastExpression')
      }
      return node2
    }
    assertModuleNodeAllowed(node2) {
      if (
        (node2.type === 'ImportDeclaration' && (node2.importKind === 'type' || node2.importKind === 'typeof')) ||
        (node2.type === 'ExportNamedDeclaration' && node2.exportKind === 'type') ||
        (node2.type === 'ExportAllDeclaration' && node2.exportKind === 'type')
      ) {
        return
      }
      super.assertModuleNodeAllowed(node2)
    }
    parseExport(node2) {
      const decl = super.parseExport(node2)
      if (decl.type === 'ExportNamedDeclaration' || decl.type === 'ExportAllDeclaration') {
        decl.exportKind = decl.exportKind || 'value'
      }
      return decl
    }
    parseExportDeclaration(node2) {
      if (this.isContextual(126)) {
        node2.exportKind = 'type'
        const declarationNode = this.startNode()
        this.next()
        if (this.match(5)) {
          node2.specifiers = this.parseExportSpecifiers(true)
          this.parseExportFrom(node2)
          return null
        } else {
          return this.flowParseTypeAlias(declarationNode)
        }
      } else if (this.isContextual(127)) {
        node2.exportKind = 'type'
        const declarationNode = this.startNode()
        this.next()
        return this.flowParseOpaqueType(declarationNode, false)
      } else if (this.isContextual(125)) {
        node2.exportKind = 'type'
        const declarationNode = this.startNode()
        this.next()
        return this.flowParseInterface(declarationNode)
      } else if (this.shouldParseEnums() && this.isContextual(122)) {
        node2.exportKind = 'value'
        const declarationNode = this.startNode()
        this.next()
        return this.flowParseEnumDeclaration(declarationNode)
      } else {
        return super.parseExportDeclaration(node2)
      }
    }
    eatExportStar(node2) {
      if (super.eatExportStar(...arguments)) return true
      if (this.isContextual(126) && this.lookahead().type === 55) {
        node2.exportKind = 'type'
        this.next()
        this.next()
        return true
      }
      return false
    }
    maybeParseExportNamespaceSpecifier(node2) {
      const { startLoc } = this.state
      const hasNamespace = super.maybeParseExportNamespaceSpecifier(node2)
      if (hasNamespace && node2.exportKind === 'type') {
        this.unexpected(startLoc)
      }
      return hasNamespace
    }
    parseClassId(node2, isStatement2, optionalId) {
      super.parseClassId(node2, isStatement2, optionalId)
      if (this.match(47)) {
        node2.typeParameters = this.flowParseTypeParameterDeclaration()
      }
    }
    parseClassMember(classBody2, member, state) {
      const { startLoc } = this.state
      if (this.isContextual(121)) {
        if (this.parseClassMemberFromModifier(classBody2, member)) {
          return
        }
        member.declare = true
      }
      super.parseClassMember(classBody2, member, state)
      if (member.declare) {
        if (
          member.type !== 'ClassProperty' &&
          member.type !== 'ClassPrivateProperty' &&
          member.type !== 'PropertyDefinition'
        ) {
          this.raise(FlowErrors$1.DeclareClassElement, {
            at: startLoc,
          })
        } else if (member.value) {
          this.raise(FlowErrors$1.DeclareClassFieldInitializer, {
            at: member.value,
          })
        }
      }
    }
    isIterator(word) {
      return word === 'iterator' || word === 'asyncIterator'
    }
    readIterator() {
      const word = super.readWord1()
      const fullWord = '@@' + word
      if (!this.isIterator(word) || !this.state.inType) {
        this.raise(Errors$1.InvalidIdentifier, {
          at: this.state.curPosition(),
          identifierName: fullWord,
        })
      }
      this.finishToken(128, fullWord)
    }
    getTokenFromCode(code2) {
      const next = this.input.charCodeAt(this.state.pos + 1)
      if (code2 === 123 && next === 124) {
        return this.finishOp(6, 2)
      } else if (this.state.inType && (code2 === 62 || code2 === 60)) {
        return this.finishOp(code2 === 62 ? 48 : 47, 1)
      } else if (this.state.inType && code2 === 63) {
        if (next === 46) {
          return this.finishOp(18, 2)
        }
        return this.finishOp(17, 1)
      } else if (isIteratorStart$1(code2, next, this.input.charCodeAt(this.state.pos + 2))) {
        this.state.pos += 2
        return this.readIterator()
      } else {
        return super.getTokenFromCode(code2)
      }
    }
    isAssignable(node2, isBinding2) {
      if (node2.type === 'TypeCastExpression') {
        return this.isAssignable(node2.expression, isBinding2)
      } else {
        return super.isAssignable(node2, isBinding2)
      }
    }
    toAssignable(node2, isLHS = false) {
      if (!isLHS && node2.type === 'AssignmentExpression' && node2.left.type === 'TypeCastExpression') {
        node2.left = this.typeCastToParameter(node2.left)
      }
      super.toAssignable(...arguments)
    }
    toAssignableList(exprList, trailingCommaLoc, isLHS) {
      for (let i = 0; i < exprList.length; i++) {
        const expr = exprList[i]
        if ((expr == null ? void 0 : expr.type) === 'TypeCastExpression') {
          exprList[i] = this.typeCastToParameter(expr)
        }
      }
      super.toAssignableList(exprList, trailingCommaLoc, isLHS)
    }
    toReferencedList(exprList, isParenthesizedExpr) {
      for (let i = 0; i < exprList.length; i++) {
        var _expr$extra
        const expr = exprList[i]
        if (
          expr &&
          expr.type === 'TypeCastExpression' &&
          !((_expr$extra = expr.extra) != null && _expr$extra.parenthesized) &&
          (exprList.length > 1 || !isParenthesizedExpr)
        ) {
          this.raise(FlowErrors$1.TypeCastInPattern, {
            at: expr.typeAnnotation,
          })
        }
      }
      return exprList
    }
    parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
      const node2 = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors)
      if (canBePattern && !this.state.maybeInArrowParameters) {
        this.toReferencedList(node2.elements)
      }
      return node2
    }
    isValidLVal(type, ...rest) {
      return type === 'TypeCastExpression' || super.isValidLVal(type, ...rest)
    }
    parseClassProperty(node2) {
      if (this.match(14)) {
        node2.typeAnnotation = this.flowParseTypeAnnotation()
      }
      return super.parseClassProperty(node2)
    }
    parseClassPrivateProperty(node2) {
      if (this.match(14)) {
        node2.typeAnnotation = this.flowParseTypeAnnotation()
      }
      return super.parseClassPrivateProperty(node2)
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod()
    }
    isClassProperty() {
      return this.match(14) || super.isClassProperty()
    }
    isNonstaticConstructor(method) {
      return !this.match(14) && super.isNonstaticConstructor(method)
    }
    pushClassMethod(classBody2, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
      if (method.variance) {
        this.unexpected(method.variance.loc.start)
      }
      delete method.variance
      if (this.match(47)) {
        method.typeParameters = this.flowParseTypeParameterDeclaration()
      }
      super.pushClassMethod(classBody2, method, isGenerator, isAsync, isConstructor, allowsDirectSuper)
      if (method.params && isConstructor) {
        const params = method.params
        if (params.length > 0 && this.isThisParam(params[0])) {
          this.raise(FlowErrors$1.ThisParamBannedInConstructor, {
            at: method,
          })
        }
      } else if (method.type === 'MethodDefinition' && isConstructor && method.value.params) {
        const params = method.value.params
        if (params.length > 0 && this.isThisParam(params[0])) {
          this.raise(FlowErrors$1.ThisParamBannedInConstructor, {
            at: method,
          })
        }
      }
    }
    pushClassPrivateMethod(classBody2, method, isGenerator, isAsync) {
      if (method.variance) {
        this.unexpected(method.variance.loc.start)
      }
      delete method.variance
      if (this.match(47)) {
        method.typeParameters = this.flowParseTypeParameterDeclaration()
      }
      super.pushClassPrivateMethod(classBody2, method, isGenerator, isAsync)
    }
    parseClassSuper(node2) {
      super.parseClassSuper(node2)
      if (node2.superClass && this.match(47)) {
        node2.superTypeParameters = this.flowParseTypeParameterInstantiation()
      }
      if (this.isContextual(110)) {
        this.next()
        const implemented = (node2.implements = [])
        do {
          const node3 = this.startNode()
          node3.id = this.flowParseRestrictedIdentifier(true)
          if (this.match(47)) {
            node3.typeParameters = this.flowParseTypeParameterInstantiation()
          } else {
            node3.typeParameters = null
          }
          implemented.push(this.finishNode(node3, 'ClassImplements'))
        } while (this.eat(12))
      }
    }
    checkGetterSetterParams(method) {
      super.checkGetterSetterParams(method)
      const params = this.getObjectOrClassMethodParams(method)
      if (params.length > 0) {
        const param = params[0]
        if (this.isThisParam(param) && method.kind === 'get') {
          this.raise(FlowErrors$1.GetterMayNotHaveThisParam, {
            at: param,
          })
        } else if (this.isThisParam(param)) {
          this.raise(FlowErrors$1.SetterMayNotHaveThisParam, {
            at: param,
          })
        }
      }
    }
    parsePropertyNamePrefixOperator(node2) {
      node2.variance = this.flowParseVariance()
    }
    parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern2, isAccessor2, refExpressionErrors) {
      if (prop.variance) {
        this.unexpected(prop.variance.loc.start)
      }
      delete prop.variance
      let typeParameters
      if (this.match(47) && !isAccessor2) {
        typeParameters = this.flowParseTypeParameterDeclaration()
        if (!this.match(10)) this.unexpected()
      }
      super.parseObjPropValue(
        prop,
        startPos,
        startLoc,
        isGenerator,
        isAsync,
        isPattern2,
        isAccessor2,
        refExpressionErrors
      )
      if (typeParameters) {
        ;(prop.value || prop).typeParameters = typeParameters
      }
    }
    parseAssignableListItemTypes(param) {
      if (this.eat(17)) {
        if (param.type !== 'Identifier') {
          this.raise(FlowErrors$1.PatternIsOptional, {
            at: param,
          })
        }
        if (this.isThisParam(param)) {
          this.raise(FlowErrors$1.ThisParamMayNotBeOptional, {
            at: param,
          })
        }
        param.optional = true
      }
      if (this.match(14)) {
        param.typeAnnotation = this.flowParseTypeAnnotation()
      } else if (this.isThisParam(param)) {
        this.raise(FlowErrors$1.ThisParamAnnotationRequired, {
          at: param,
        })
      }
      if (this.match(29) && this.isThisParam(param)) {
        this.raise(FlowErrors$1.ThisParamNoDefault, {
          at: param,
        })
      }
      this.resetEndLocation(param)
      return param
    }
    parseMaybeDefault(startPos, startLoc, left) {
      const node2 = super.parseMaybeDefault(startPos, startLoc, left)
      if (
        node2.type === 'AssignmentPattern' &&
        node2.typeAnnotation &&
        node2.right.start < node2.typeAnnotation.start
      ) {
        this.raise(FlowErrors$1.TypeBeforeInitializer, {
          at: node2.typeAnnotation,
        })
      }
      return node2
    }
    shouldParseDefaultImport(node2) {
      if (!hasTypeImportKind$1(node2)) {
        return super.shouldParseDefaultImport(node2)
      }
      return isMaybeDefaultImport$1(this.state.type)
    }
    parseImportSpecifierLocal(node2, specifier, type) {
      specifier.local = hasTypeImportKind$1(node2)
        ? this.flowParseRestrictedIdentifier(true, true)
        : this.parseIdentifier()
      node2.specifiers.push(this.finishImportSpecifier(specifier, type))
    }
    maybeParseDefaultImportSpecifier(node2) {
      node2.importKind = 'value'
      let kind = null
      if (this.match(87)) {
        kind = 'typeof'
      } else if (this.isContextual(126)) {
        kind = 'type'
      }
      if (kind) {
        const lh = this.lookahead()
        const { type } = lh
        if (kind === 'type' && type === 55) {
          this.unexpected(null, lh.type)
        }
        if (isMaybeDefaultImport$1(type) || type === 5 || type === 55) {
          this.next()
          node2.importKind = kind
        }
      }
      return super.maybeParseDefaultImportSpecifier(node2)
    }
    parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly) {
      const firstIdent = specifier.imported
      let specifierTypeKind = null
      if (firstIdent.type === 'Identifier') {
        if (firstIdent.name === 'type') {
          specifierTypeKind = 'type'
        } else if (firstIdent.name === 'typeof') {
          specifierTypeKind = 'typeof'
        }
      }
      let isBinding2 = false
      if (this.isContextual(93) && !this.isLookaheadContextual('as')) {
        const as_ident = this.parseIdentifier(true)
        if (specifierTypeKind !== null && !tokenIsKeywordOrIdentifier$1(this.state.type)) {
          specifier.imported = as_ident
          specifier.importKind = specifierTypeKind
          specifier.local = cloneIdentifier$1(as_ident)
        } else {
          specifier.imported = firstIdent
          specifier.importKind = null
          specifier.local = this.parseIdentifier()
        }
      } else {
        if (specifierTypeKind !== null && tokenIsKeywordOrIdentifier$1(this.state.type)) {
          specifier.imported = this.parseIdentifier(true)
          specifier.importKind = specifierTypeKind
        } else {
          if (importedIsString) {
            throw this.raise(Errors$1.ImportBindingIsString, {
              at: specifier,
              importName: firstIdent.value,
            })
          }
          specifier.imported = firstIdent
          specifier.importKind = null
        }
        if (this.eatContextual(93)) {
          specifier.local = this.parseIdentifier()
        } else {
          isBinding2 = true
          specifier.local = cloneIdentifier$1(specifier.imported)
        }
      }
      const specifierIsTypeImport = hasTypeImportKind$1(specifier)
      if (isInTypeOnlyImport && specifierIsTypeImport) {
        this.raise(FlowErrors$1.ImportTypeShorthandOnlyInPureImport, {
          at: specifier,
        })
      }
      if (isInTypeOnlyImport || specifierIsTypeImport) {
        this.checkReservedType(specifier.local.name, specifier.local.loc.start, true)
      }
      if (isBinding2 && !isInTypeOnlyImport && !specifierIsTypeImport) {
        this.checkReservedWord(specifier.local.name, specifier.loc.start, true, true)
      }
      return this.finishImportSpecifier(specifier, 'ImportSpecifier')
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 78:
          return this.parseIdentifier(true)
        default:
          return super.parseBindingAtom()
      }
    }
    parseFunctionParams(node2, allowModifiers) {
      const kind = node2.kind
      if (kind !== 'get' && kind !== 'set' && this.match(47)) {
        node2.typeParameters = this.flowParseTypeParameterDeclaration()
      }
      super.parseFunctionParams(node2, allowModifiers)
    }
    parseVarId(decl, kind) {
      super.parseVarId(decl, kind)
      if (this.match(14)) {
        decl.id.typeAnnotation = this.flowParseTypeAnnotation()
        this.resetEndLocation(decl.id)
      }
    }
    parseAsyncArrowFromCallExpression(node2, call2) {
      if (this.match(14)) {
        const oldNoAnonFunctionType = this.state.noAnonFunctionType
        this.state.noAnonFunctionType = true
        node2.returnType = this.flowParseTypeAnnotation()
        this.state.noAnonFunctionType = oldNoAnonFunctionType
      }
      return super.parseAsyncArrowFromCallExpression(node2, call2)
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow()
    }
    parseMaybeAssign(refExpressionErrors, afterLeftParse) {
      var _jsx
      let state = null
      let jsx2
      if (this.hasPlugin('jsx') && (this.match(138) || this.match(47))) {
        state = this.state.clone()
        jsx2 = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state)
        if (!jsx2.error) return jsx2.node
        const { context: context2 } = this.state
        const currentContext = context2[context2.length - 1]
        if (currentContext === types$1.j_oTag || currentContext === types$1.j_expr) {
          context2.pop()
        }
      }
      if (((_jsx = jsx2) != null && _jsx.error) || this.match(47)) {
        var _jsx2, _jsx3
        state = state || this.state.clone()
        let typeParameters
        const arrow = this.tryParse((abort) => {
          var _arrowExpression$extr
          typeParameters = this.flowParseTypeParameterDeclaration()
          const arrowExpression2 = this.forwardNoArrowParamsConversionAt(typeParameters, () => {
            const result = super.parseMaybeAssign(refExpressionErrors, afterLeftParse)
            this.resetStartLocationFromNode(result, typeParameters)
            return result
          })
          if ((_arrowExpression$extr = arrowExpression2.extra) != null && _arrowExpression$extr.parenthesized) abort()
          const expr = this.maybeUnwrapTypeCastExpression(arrowExpression2)
          if (expr.type !== 'ArrowFunctionExpression') abort()
          expr.typeParameters = typeParameters
          this.resetStartLocationFromNode(expr, typeParameters)
          return arrowExpression2
        }, state)
        let arrowExpression = null
        if (arrow.node && this.maybeUnwrapTypeCastExpression(arrow.node).type === 'ArrowFunctionExpression') {
          if (!arrow.error && !arrow.aborted) {
            if (arrow.node.async) {
              this.raise(FlowErrors$1.UnexpectedTypeParameterBeforeAsyncArrowFunction, {
                at: typeParameters,
              })
            }
            return arrow.node
          }
          arrowExpression = arrow.node
        }
        if ((_jsx2 = jsx2) != null && _jsx2.node) {
          this.state = jsx2.failState
          return jsx2.node
        }
        if (arrowExpression) {
          this.state = arrow.failState
          return arrowExpression
        }
        if ((_jsx3 = jsx2) != null && _jsx3.thrown) throw jsx2.error
        if (arrow.thrown) throw arrow.error
        throw this.raise(FlowErrors$1.UnexpectedTokenAfterTypeParameter, {
          at: typeParameters,
        })
      }
      return super.parseMaybeAssign(refExpressionErrors, afterLeftParse)
    }
    parseArrow(node2) {
      if (this.match(14)) {
        const result = this.tryParse(() => {
          const oldNoAnonFunctionType = this.state.noAnonFunctionType
          this.state.noAnonFunctionType = true
          const typeNode = this.startNode()
          ;[typeNode.typeAnnotation, node2.predicate] = this.flowParseTypeAndPredicateInitialiser()
          this.state.noAnonFunctionType = oldNoAnonFunctionType
          if (this.canInsertSemicolon()) this.unexpected()
          if (!this.match(19)) this.unexpected()
          return typeNode
        })
        if (result.thrown) return null
        if (result.error) this.state = result.failState
        node2.returnType = result.node.typeAnnotation ? this.finishNode(result.node, 'TypeAnnotation') : null
      }
      return super.parseArrow(node2)
    }
    shouldParseArrow(params) {
      return this.match(14) || super.shouldParseArrow(params)
    }
    setArrowFunctionParameters(node2, params) {
      if (this.state.noArrowParamsConversionAt.indexOf(node2.start) !== -1) {
        node2.params = params
      } else {
        super.setArrowFunctionParameters(node2, params)
      }
    }
    checkParams(node2, allowDuplicates, isArrowFunction) {
      if (isArrowFunction && this.state.noArrowParamsConversionAt.indexOf(node2.start) !== -1) {
        return
      }
      for (let i = 0; i < node2.params.length; i++) {
        if (this.isThisParam(node2.params[i]) && i > 0) {
          this.raise(FlowErrors$1.ThisParamMustBeFirst, {
            at: node2.params[i],
          })
        }
      }
      return super.checkParams(...arguments)
    }
    parseParenAndDistinguishExpression(canBeArrow) {
      return super.parseParenAndDistinguishExpression(
        canBeArrow && this.state.noArrowAt.indexOf(this.state.start) === -1
      )
    }
    parseSubscripts(base2, startPos, startLoc, noCalls) {
      if (base2.type === 'Identifier' && base2.name === 'async' && this.state.noArrowAt.indexOf(startPos) !== -1) {
        this.next()
        const node2 = this.startNodeAt(startPos, startLoc)
        node2.callee = base2
        node2.arguments = this.parseCallExpressionArguments(11, false)
        base2 = this.finishNode(node2, 'CallExpression')
      } else if (base2.type === 'Identifier' && base2.name === 'async' && this.match(47)) {
        const state = this.state.clone()
        const arrow = this.tryParse(
          (abort) => this.parseAsyncArrowWithTypeParameters(startPos, startLoc) || abort(),
          state
        )
        if (!arrow.error && !arrow.aborted) return arrow.node
        const result = this.tryParse(() => super.parseSubscripts(base2, startPos, startLoc, noCalls), state)
        if (result.node && !result.error) return result.node
        if (arrow.node) {
          this.state = arrow.failState
          return arrow.node
        }
        if (result.node) {
          this.state = result.failState
          return result.node
        }
        throw arrow.error || result.error
      }
      return super.parseSubscripts(base2, startPos, startLoc, noCalls)
    }
    parseSubscript(base2, startPos, startLoc, noCalls, subscriptState) {
      if (this.match(18) && this.isLookaheadToken_lt()) {
        subscriptState.optionalChainMember = true
        if (noCalls) {
          subscriptState.stop = true
          return base2
        }
        this.next()
        const node2 = this.startNodeAt(startPos, startLoc)
        node2.callee = base2
        node2.typeArguments = this.flowParseTypeParameterInstantiation()
        this.expect(10)
        node2.arguments = this.parseCallExpressionArguments(11, false)
        node2.optional = true
        return this.finishCallExpression(node2, true)
      } else if (!noCalls && this.shouldParseTypes() && this.match(47)) {
        const node2 = this.startNodeAt(startPos, startLoc)
        node2.callee = base2
        const result = this.tryParse(() => {
          node2.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew()
          this.expect(10)
          node2.arguments = this.parseCallExpressionArguments(11, false)
          if (subscriptState.optionalChainMember) node2.optional = false
          return this.finishCallExpression(node2, subscriptState.optionalChainMember)
        })
        if (result.node) {
          if (result.error) this.state = result.failState
          return result.node
        }
      }
      return super.parseSubscript(base2, startPos, startLoc, noCalls, subscriptState)
    }
    parseNewCallee(node2) {
      super.parseNewCallee(node2)
      let targs = null
      if (this.shouldParseTypes() && this.match(47)) {
        targs = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node
      }
      node2.typeArguments = targs
    }
    parseAsyncArrowWithTypeParameters(startPos, startLoc) {
      const node2 = this.startNodeAt(startPos, startLoc)
      this.parseFunctionParams(node2)
      if (!this.parseArrow(node2)) return
      return this.parseArrowExpression(node2, void 0, true)
    }
    readToken_mult_modulo(code2) {
      const next = this.input.charCodeAt(this.state.pos + 1)
      if (code2 === 42 && next === 47 && this.state.hasFlowComment) {
        this.state.hasFlowComment = false
        this.state.pos += 2
        this.nextToken()
        return
      }
      super.readToken_mult_modulo(code2)
    }
    readToken_pipe_amp(code2) {
      const next = this.input.charCodeAt(this.state.pos + 1)
      if (code2 === 124 && next === 125) {
        this.finishOp(9, 2)
        return
      }
      super.readToken_pipe_amp(code2)
    }
    parseTopLevel(file2, program2) {
      const fileNode = super.parseTopLevel(file2, program2)
      if (this.state.hasFlowComment) {
        this.raise(FlowErrors$1.UnterminatedFlowComment, {
          at: this.state.curPosition(),
        })
      }
      return fileNode
    }
    skipBlockComment() {
      if (this.hasPlugin('flowComments') && this.skipFlowComment()) {
        if (this.state.hasFlowComment) {
          throw this.raise(FlowErrors$1.NestedFlowComment, {
            at: this.state.startLoc,
          })
        }
        this.hasFlowCommentCompletion()
        this.state.pos += this.skipFlowComment()
        this.state.hasFlowComment = true
        return
      }
      if (this.state.hasFlowComment) {
        const end = this.input.indexOf('*-/', this.state.pos + 2)
        if (end === -1) {
          throw this.raise(Errors$1.UnterminatedComment, {
            at: this.state.curPosition(),
          })
        }
        this.state.pos = end + 2 + 3
        return
      }
      return super.skipBlockComment()
    }
    skipFlowComment() {
      const { pos } = this.state
      let shiftToFirstNonWhiteSpace = 2
      while ([32, 9].includes(this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace))) {
        shiftToFirstNonWhiteSpace++
      }
      const ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos)
      const ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1)
      if (ch2 === 58 && ch3 === 58) {
        return shiftToFirstNonWhiteSpace + 2
      }
      if (this.input.slice(shiftToFirstNonWhiteSpace + pos, shiftToFirstNonWhiteSpace + pos + 12) === 'flow-include') {
        return shiftToFirstNonWhiteSpace + 12
      }
      if (ch2 === 58 && ch3 !== 58) {
        return shiftToFirstNonWhiteSpace
      }
      return false
    }
    hasFlowCommentCompletion() {
      const end = this.input.indexOf('*/', this.state.pos)
      if (end === -1) {
        throw this.raise(Errors$1.UnterminatedComment, {
          at: this.state.curPosition(),
        })
      }
    }
    flowEnumErrorBooleanMemberNotInitialized(loc, { enumName, memberName }) {
      this.raise(FlowErrors$1.EnumBooleanMemberNotInitialized, {
        at: loc,
        memberName,
        enumName,
      })
    }
    flowEnumErrorInvalidMemberInitializer(loc, enumContext) {
      return this.raise(
        !enumContext.explicitType
          ? FlowErrors$1.EnumInvalidMemberInitializerUnknownType
          : enumContext.explicitType === 'symbol'
          ? FlowErrors$1.EnumInvalidMemberInitializerSymbolType
          : FlowErrors$1.EnumInvalidMemberInitializerPrimaryType,
        Object.assign(
          {
            at: loc,
          },
          enumContext
        )
      )
    }
    flowEnumErrorNumberMemberNotInitialized(loc, { enumName, memberName }) {
      this.raise(FlowErrors$1.EnumNumberMemberNotInitialized, {
        at: loc,
        enumName,
        memberName,
      })
    }
    flowEnumErrorStringMemberInconsistentlyInitailized(node2, { enumName }) {
      this.raise(FlowErrors$1.EnumStringMemberInconsistentlyInitailized, {
        at: node2,
        enumName,
      })
    }
    flowEnumMemberInit() {
      const startLoc = this.state.startLoc
      const endOfInit = () => this.match(12) || this.match(8)
      switch (this.state.type) {
        case 130: {
          const literal2 = this.parseNumericLiteral(this.state.value)
          if (endOfInit()) {
            return {
              type: 'number',
              loc: literal2.loc.start,
              value: literal2,
            }
          }
          return {
            type: 'invalid',
            loc: startLoc,
          }
        }
        case 129: {
          const literal2 = this.parseStringLiteral(this.state.value)
          if (endOfInit()) {
            return {
              type: 'string',
              loc: literal2.loc.start,
              value: literal2,
            }
          }
          return {
            type: 'invalid',
            loc: startLoc,
          }
        }
        case 85:
        case 86: {
          const literal2 = this.parseBooleanLiteral(this.match(85))
          if (endOfInit()) {
            return {
              type: 'boolean',
              loc: literal2.loc.start,
              value: literal2,
            }
          }
          return {
            type: 'invalid',
            loc: startLoc,
          }
        }
        default:
          return {
            type: 'invalid',
            loc: startLoc,
          }
      }
    }
    flowEnumMemberRaw() {
      const loc = this.state.startLoc
      const id = this.parseIdentifier(true)
      const init = this.eat(29)
        ? this.flowEnumMemberInit()
        : {
            type: 'none',
            loc,
          }
      return {
        id,
        init,
      }
    }
    flowEnumCheckExplicitTypeMismatch(loc, context2, expectedType) {
      const { explicitType } = context2
      if (explicitType === null) {
        return
      }
      if (explicitType !== expectedType) {
        this.flowEnumErrorInvalidMemberInitializer(loc, context2)
      }
    }
    flowEnumMembers({ enumName, explicitType }) {
      const seenNames = /* @__PURE__ */ new Set()
      const members = {
        booleanMembers: [],
        numberMembers: [],
        stringMembers: [],
        defaultedMembers: [],
      }
      let hasUnknownMembers = false
      while (!this.match(8)) {
        if (this.eat(21)) {
          hasUnknownMembers = true
          break
        }
        const memberNode = this.startNode()
        const { id, init } = this.flowEnumMemberRaw()
        const memberName = id.name
        if (memberName === '') {
          continue
        }
        if (/^[a-z]/.test(memberName)) {
          this.raise(FlowErrors$1.EnumInvalidMemberName, {
            at: id,
            memberName,
            suggestion: memberName[0].toUpperCase() + memberName.slice(1),
            enumName,
          })
        }
        if (seenNames.has(memberName)) {
          this.raise(FlowErrors$1.EnumDuplicateMemberName, {
            at: id,
            memberName,
            enumName,
          })
        }
        seenNames.add(memberName)
        const context2 = {
          enumName,
          explicitType,
          memberName,
        }
        memberNode.id = id
        switch (init.type) {
          case 'boolean': {
            this.flowEnumCheckExplicitTypeMismatch(init.loc, context2, 'boolean')
            memberNode.init = init.value
            members.booleanMembers.push(this.finishNode(memberNode, 'EnumBooleanMember'))
            break
          }
          case 'number': {
            this.flowEnumCheckExplicitTypeMismatch(init.loc, context2, 'number')
            memberNode.init = init.value
            members.numberMembers.push(this.finishNode(memberNode, 'EnumNumberMember'))
            break
          }
          case 'string': {
            this.flowEnumCheckExplicitTypeMismatch(init.loc, context2, 'string')
            memberNode.init = init.value
            members.stringMembers.push(this.finishNode(memberNode, 'EnumStringMember'))
            break
          }
          case 'invalid': {
            throw this.flowEnumErrorInvalidMemberInitializer(init.loc, context2)
          }
          case 'none': {
            switch (explicitType) {
              case 'boolean':
                this.flowEnumErrorBooleanMemberNotInitialized(init.loc, context2)
                break
              case 'number':
                this.flowEnumErrorNumberMemberNotInitialized(init.loc, context2)
                break
              default:
                members.defaultedMembers.push(this.finishNode(memberNode, 'EnumDefaultedMember'))
            }
          }
        }
        if (!this.match(8)) {
          this.expect(12)
        }
      }
      return {
        members,
        hasUnknownMembers,
      }
    }
    flowEnumStringMembers(initializedMembers, defaultedMembers, { enumName }) {
      if (initializedMembers.length === 0) {
        return defaultedMembers
      } else if (defaultedMembers.length === 0) {
        return initializedMembers
      } else if (defaultedMembers.length > initializedMembers.length) {
        for (const member of initializedMembers) {
          this.flowEnumErrorStringMemberInconsistentlyInitailized(member, {
            enumName,
          })
        }
        return defaultedMembers
      } else {
        for (const member of defaultedMembers) {
          this.flowEnumErrorStringMemberInconsistentlyInitailized(member, {
            enumName,
          })
        }
        return initializedMembers
      }
    }
    flowEnumParseExplicitType({ enumName }) {
      if (!this.eatContextual(101)) return null
      if (!tokenIsIdentifier$1(this.state.type)) {
        throw this.raise(FlowErrors$1.EnumInvalidExplicitTypeUnknownSupplied, {
          at: this.state.startLoc,
          enumName,
        })
      }
      const { value } = this.state
      this.next()
      if (value !== 'boolean' && value !== 'number' && value !== 'string' && value !== 'symbol') {
        this.raise(FlowErrors$1.EnumInvalidExplicitType, {
          at: this.state.startLoc,
          enumName,
          invalidEnumType: value,
        })
      }
      return value
    }
    flowEnumBody(node2, id) {
      const enumName = id.name
      const nameLoc = id.loc.start
      const explicitType = this.flowEnumParseExplicitType({
        enumName,
      })
      this.expect(5)
      const { members, hasUnknownMembers } = this.flowEnumMembers({
        enumName,
        explicitType,
      })
      node2.hasUnknownMembers = hasUnknownMembers
      switch (explicitType) {
        case 'boolean':
          node2.explicitType = true
          node2.members = members.booleanMembers
          this.expect(8)
          return this.finishNode(node2, 'EnumBooleanBody')
        case 'number':
          node2.explicitType = true
          node2.members = members.numberMembers
          this.expect(8)
          return this.finishNode(node2, 'EnumNumberBody')
        case 'string':
          node2.explicitType = true
          node2.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
            enumName,
          })
          this.expect(8)
          return this.finishNode(node2, 'EnumStringBody')
        case 'symbol':
          node2.members = members.defaultedMembers
          this.expect(8)
          return this.finishNode(node2, 'EnumSymbolBody')
        default: {
          const empty = () => {
            node2.members = []
            this.expect(8)
            return this.finishNode(node2, 'EnumStringBody')
          }
          node2.explicitType = false
          const boolsLen = members.booleanMembers.length
          const numsLen = members.numberMembers.length
          const strsLen = members.stringMembers.length
          const defaultedLen = members.defaultedMembers.length
          if (!boolsLen && !numsLen && !strsLen && !defaultedLen) {
            return empty()
          } else if (!boolsLen && !numsLen) {
            node2.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
              enumName,
            })
            this.expect(8)
            return this.finishNode(node2, 'EnumStringBody')
          } else if (!numsLen && !strsLen && boolsLen >= defaultedLen) {
            for (const member of members.defaultedMembers) {
              this.flowEnumErrorBooleanMemberNotInitialized(member.loc.start, {
                enumName,
                memberName: member.id.name,
              })
            }
            node2.members = members.booleanMembers
            this.expect(8)
            return this.finishNode(node2, 'EnumBooleanBody')
          } else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {
            for (const member of members.defaultedMembers) {
              this.flowEnumErrorNumberMemberNotInitialized(member.loc.start, {
                enumName,
                memberName: member.id.name,
              })
            }
            node2.members = members.numberMembers
            this.expect(8)
            return this.finishNode(node2, 'EnumNumberBody')
          } else {
            this.raise(FlowErrors$1.EnumInconsistentMemberValues, {
              at: nameLoc,
              enumName,
            })
            return empty()
          }
        }
      }
    }
    flowParseEnumDeclaration(node2) {
      const id = this.parseIdentifier()
      node2.id = id
      node2.body = this.flowEnumBody(this.startNode(), id)
      return this.finishNode(node2, 'EnumDeclaration')
    }
    isLookaheadToken_lt() {
      const next = this.nextTokenStart()
      if (this.input.charCodeAt(next) === 60) {
        const afterNext = this.input.charCodeAt(next + 1)
        return afterNext !== 60 && afterNext !== 61
      }
      return false
    }
    maybeUnwrapTypeCastExpression(node2) {
      return node2.type === 'TypeCastExpression' ? node2.expression : node2
    }
  }
const entities$1 = {
  __proto__: null,
  quot: '"',
  amp: '&',
  apos: "'",
  lt: '<',
  gt: '>',
  nbsp: '\xA0',
  iexcl: '\xA1',
  cent: '\xA2',
  pound: '\xA3',
  curren: '\xA4',
  yen: '\xA5',
  brvbar: '\xA6',
  sect: '\xA7',
  uml: '\xA8',
  copy: '\xA9',
  ordf: '\xAA',
  laquo: '\xAB',
  not: '\xAC',
  shy: '\xAD',
  reg: '\xAE',
  macr: '\xAF',
  deg: '\xB0',
  plusmn: '\xB1',
  sup2: '\xB2',
  sup3: '\xB3',
  acute: '\xB4',
  micro: '\xB5',
  para: '\xB6',
  middot: '\xB7',
  cedil: '\xB8',
  sup1: '\xB9',
  ordm: '\xBA',
  raquo: '\xBB',
  frac14: '\xBC',
  frac12: '\xBD',
  frac34: '\xBE',
  iquest: '\xBF',
  Agrave: '\xC0',
  Aacute: '\xC1',
  Acirc: '\xC2',
  Atilde: '\xC3',
  Auml: '\xC4',
  Aring: '\xC5',
  AElig: '\xC6',
  Ccedil: '\xC7',
  Egrave: '\xC8',
  Eacute: '\xC9',
  Ecirc: '\xCA',
  Euml: '\xCB',
  Igrave: '\xCC',
  Iacute: '\xCD',
  Icirc: '\xCE',
  Iuml: '\xCF',
  ETH: '\xD0',
  Ntilde: '\xD1',
  Ograve: '\xD2',
  Oacute: '\xD3',
  Ocirc: '\xD4',
  Otilde: '\xD5',
  Ouml: '\xD6',
  times: '\xD7',
  Oslash: '\xD8',
  Ugrave: '\xD9',
  Uacute: '\xDA',
  Ucirc: '\xDB',
  Uuml: '\xDC',
  Yacute: '\xDD',
  THORN: '\xDE',
  szlig: '\xDF',
  agrave: '\xE0',
  aacute: '\xE1',
  acirc: '\xE2',
  atilde: '\xE3',
  auml: '\xE4',
  aring: '\xE5',
  aelig: '\xE6',
  ccedil: '\xE7',
  egrave: '\xE8',
  eacute: '\xE9',
  ecirc: '\xEA',
  euml: '\xEB',
  igrave: '\xEC',
  iacute: '\xED',
  icirc: '\xEE',
  iuml: '\xEF',
  eth: '\xF0',
  ntilde: '\xF1',
  ograve: '\xF2',
  oacute: '\xF3',
  ocirc: '\xF4',
  otilde: '\xF5',
  ouml: '\xF6',
  divide: '\xF7',
  oslash: '\xF8',
  ugrave: '\xF9',
  uacute: '\xFA',
  ucirc: '\xFB',
  uuml: '\xFC',
  yacute: '\xFD',
  thorn: '\xFE',
  yuml: '\xFF',
  OElig: '\u0152',
  oelig: '\u0153',
  Scaron: '\u0160',
  scaron: '\u0161',
  Yuml: '\u0178',
  fnof: '\u0192',
  circ: '\u02C6',
  tilde: '\u02DC',
  Alpha: '\u0391',
  Beta: '\u0392',
  Gamma: '\u0393',
  Delta: '\u0394',
  Epsilon: '\u0395',
  Zeta: '\u0396',
  Eta: '\u0397',
  Theta: '\u0398',
  Iota: '\u0399',
  Kappa: '\u039A',
  Lambda: '\u039B',
  Mu: '\u039C',
  Nu: '\u039D',
  Xi: '\u039E',
  Omicron: '\u039F',
  Pi: '\u03A0',
  Rho: '\u03A1',
  Sigma: '\u03A3',
  Tau: '\u03A4',
  Upsilon: '\u03A5',
  Phi: '\u03A6',
  Chi: '\u03A7',
  Psi: '\u03A8',
  Omega: '\u03A9',
  alpha: '\u03B1',
  beta: '\u03B2',
  gamma: '\u03B3',
  delta: '\u03B4',
  epsilon: '\u03B5',
  zeta: '\u03B6',
  eta: '\u03B7',
  theta: '\u03B8',
  iota: '\u03B9',
  kappa: '\u03BA',
  lambda: '\u03BB',
  mu: '\u03BC',
  nu: '\u03BD',
  xi: '\u03BE',
  omicron: '\u03BF',
  pi: '\u03C0',
  rho: '\u03C1',
  sigmaf: '\u03C2',
  sigma: '\u03C3',
  tau: '\u03C4',
  upsilon: '\u03C5',
  phi: '\u03C6',
  chi: '\u03C7',
  psi: '\u03C8',
  omega: '\u03C9',
  thetasym: '\u03D1',
  upsih: '\u03D2',
  piv: '\u03D6',
  ensp: '\u2002',
  emsp: '\u2003',
  thinsp: '\u2009',
  zwnj: '\u200C',
  zwj: '\u200D',
  lrm: '\u200E',
  rlm: '\u200F',
  ndash: '\u2013',
  mdash: '\u2014',
  lsquo: '\u2018',
  rsquo: '\u2019',
  sbquo: '\u201A',
  ldquo: '\u201C',
  rdquo: '\u201D',
  bdquo: '\u201E',
  dagger: '\u2020',
  Dagger: '\u2021',
  bull: '\u2022',
  hellip: '\u2026',
  permil: '\u2030',
  prime: '\u2032',
  Prime: '\u2033',
  lsaquo: '\u2039',
  rsaquo: '\u203A',
  oline: '\u203E',
  frasl: '\u2044',
  euro: '\u20AC',
  image: '\u2111',
  weierp: '\u2118',
  real: '\u211C',
  trade: '\u2122',
  alefsym: '\u2135',
  larr: '\u2190',
  uarr: '\u2191',
  rarr: '\u2192',
  darr: '\u2193',
  harr: '\u2194',
  crarr: '\u21B5',
  lArr: '\u21D0',
  uArr: '\u21D1',
  rArr: '\u21D2',
  dArr: '\u21D3',
  hArr: '\u21D4',
  forall: '\u2200',
  part: '\u2202',
  exist: '\u2203',
  empty: '\u2205',
  nabla: '\u2207',
  isin: '\u2208',
  notin: '\u2209',
  ni: '\u220B',
  prod: '\u220F',
  sum: '\u2211',
  minus: '\u2212',
  lowast: '\u2217',
  radic: '\u221A',
  prop: '\u221D',
  infin: '\u221E',
  ang: '\u2220',
  and: '\u2227',
  or: '\u2228',
  cap: '\u2229',
  cup: '\u222A',
  int: '\u222B',
  there4: '\u2234',
  sim: '\u223C',
  cong: '\u2245',
  asymp: '\u2248',
  ne: '\u2260',
  equiv: '\u2261',
  le: '\u2264',
  ge: '\u2265',
  sub: '\u2282',
  sup: '\u2283',
  nsub: '\u2284',
  sube: '\u2286',
  supe: '\u2287',
  oplus: '\u2295',
  otimes: '\u2297',
  perp: '\u22A5',
  sdot: '\u22C5',
  lceil: '\u2308',
  rceil: '\u2309',
  lfloor: '\u230A',
  rfloor: '\u230B',
  lang: '\u2329',
  rang: '\u232A',
  loz: '\u25CA',
  spades: '\u2660',
  clubs: '\u2663',
  hearts: '\u2665',
  diams: '\u2666',
}
const JsxErrors$1 = ParseErrorEnum$1`jsx`((_2) => ({
  AttributeIsEmpty: _2('JSX attributes must only be assigned a non-empty expression.'),
  MissingClosingTagElement: _2(
    ({ openingTagName }) => `Expected corresponding JSX closing tag for <${openingTagName}>.`
  ),
  MissingClosingTagFragment: _2('Expected corresponding JSX closing tag for <>.'),
  UnexpectedSequenceExpression: _2(
    'Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?'
  ),
  UnexpectedToken: _2(
    ({ unexpected, HTMLEntity }) =>
      `Unexpected token \`${unexpected}\`. Did you mean \`${HTMLEntity}\` or \`{'${unexpected}'}\`?`
  ),
  UnsupportedJsxValue: _2('JSX value should be either an expression or a quoted JSX text.'),
  UnterminatedJsxContent: _2('Unterminated JSX contents.'),
  UnwrappedAdjacentJSXElements: _2(
    'Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?'
  ),
}))
function isFragment$1(object2) {
  return object2 ? object2.type === 'JSXOpeningFragment' || object2.type === 'JSXClosingFragment' : false
}
function getQualifiedJSXName$1(object2) {
  if (object2.type === 'JSXIdentifier') {
    return object2.name
  }
  if (object2.type === 'JSXNamespacedName') {
    return object2.namespace.name + ':' + object2.name.name
  }
  if (object2.type === 'JSXMemberExpression') {
    return getQualifiedJSXName$1(object2.object) + '.' + getQualifiedJSXName$1(object2.property)
  }
  throw new Error('Node had unexpected type: ' + object2.type)
}
var jsx$1 = (superClass) =>
  class extends superClass {
    jsxReadToken() {
      let out = ''
      let chunkStart = this.state.pos
      for (;;) {
        if (this.state.pos >= this.length) {
          throw this.raise(JsxErrors$1.UnterminatedJsxContent, {
            at: this.state.startLoc,
          })
        }
        const ch = this.input.charCodeAt(this.state.pos)
        switch (ch) {
          case 60:
          case 123:
            if (this.state.pos === this.state.start) {
              if (ch === 60 && this.state.canStartJSXElement) {
                ++this.state.pos
                return this.finishToken(138)
              }
              return super.getTokenFromCode(ch)
            }
            out += this.input.slice(chunkStart, this.state.pos)
            return this.finishToken(137, out)
          case 38:
            out += this.input.slice(chunkStart, this.state.pos)
            out += this.jsxReadEntity()
            chunkStart = this.state.pos
            break
          case 62:
          case 125:
          default:
            if (isNewLine$1(ch)) {
              out += this.input.slice(chunkStart, this.state.pos)
              out += this.jsxReadNewLine(true)
              chunkStart = this.state.pos
            } else {
              ++this.state.pos
            }
        }
      }
    }
    jsxReadNewLine(normalizeCRLF) {
      const ch = this.input.charCodeAt(this.state.pos)
      let out
      ++this.state.pos
      if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {
        ++this.state.pos
        out = normalizeCRLF ? '\n' : '\r\n'
      } else {
        out = String.fromCharCode(ch)
      }
      ++this.state.curLine
      this.state.lineStart = this.state.pos
      return out
    }
    jsxReadString(quote) {
      let out = ''
      let chunkStart = ++this.state.pos
      for (;;) {
        if (this.state.pos >= this.length) {
          throw this.raise(Errors$1.UnterminatedString, {
            at: this.state.startLoc,
          })
        }
        const ch = this.input.charCodeAt(this.state.pos)
        if (ch === quote) break
        if (ch === 38) {
          out += this.input.slice(chunkStart, this.state.pos)
          out += this.jsxReadEntity()
          chunkStart = this.state.pos
        } else if (isNewLine$1(ch)) {
          out += this.input.slice(chunkStart, this.state.pos)
          out += this.jsxReadNewLine(false)
          chunkStart = this.state.pos
        } else {
          ++this.state.pos
        }
      }
      out += this.input.slice(chunkStart, this.state.pos++)
      return this.finishToken(129, out)
    }
    jsxReadEntity() {
      const startPos = ++this.state.pos
      if (this.codePointAtPos(this.state.pos) === 35) {
        ++this.state.pos
        let radix = 10
        if (this.codePointAtPos(this.state.pos) === 120) {
          radix = 16
          ++this.state.pos
        }
        const codePoint = this.readInt(radix, void 0, false, 'bail')
        if (codePoint !== null && this.codePointAtPos(this.state.pos) === 59) {
          ++this.state.pos
          return String.fromCodePoint(codePoint)
        }
      } else {
        let count = 0
        let semi = false
        while (count++ < 10 && this.state.pos < this.length && !(semi = this.codePointAtPos(this.state.pos) == 59)) {
          ++this.state.pos
        }
        if (semi) {
          const desc = this.input.slice(startPos, this.state.pos)
          const entity = entities$1[desc]
          ++this.state.pos
          if (entity) {
            return entity
          }
        }
      }
      this.state.pos = startPos
      return '&'
    }
    jsxReadWord() {
      let ch
      const start = this.state.pos
      do {
        ch = this.input.charCodeAt(++this.state.pos)
      } while (isIdentifierChar$1(ch) || ch === 45)
      return this.finishToken(136, this.input.slice(start, this.state.pos))
    }
    jsxParseIdentifier() {
      const node2 = this.startNode()
      if (this.match(136)) {
        node2.name = this.state.value
      } else if (tokenIsKeyword$1(this.state.type)) {
        node2.name = tokenLabelName$1(this.state.type)
      } else {
        this.unexpected()
      }
      this.next()
      return this.finishNode(node2, 'JSXIdentifier')
    }
    jsxParseNamespacedName() {
      const startPos = this.state.start
      const startLoc = this.state.startLoc
      const name = this.jsxParseIdentifier()
      if (!this.eat(14)) return name
      const node2 = this.startNodeAt(startPos, startLoc)
      node2.namespace = name
      node2.name = this.jsxParseIdentifier()
      return this.finishNode(node2, 'JSXNamespacedName')
    }
    jsxParseElementName() {
      const startPos = this.state.start
      const startLoc = this.state.startLoc
      let node2 = this.jsxParseNamespacedName()
      if (node2.type === 'JSXNamespacedName') {
        return node2
      }
      while (this.eat(16)) {
        const newNode = this.startNodeAt(startPos, startLoc)
        newNode.object = node2
        newNode.property = this.jsxParseIdentifier()
        node2 = this.finishNode(newNode, 'JSXMemberExpression')
      }
      return node2
    }
    jsxParseAttributeValue() {
      let node2
      switch (this.state.type) {
        case 5:
          node2 = this.startNode()
          this.setContext(types$1.brace)
          this.next()
          node2 = this.jsxParseExpressionContainer(node2, types$1.j_oTag)
          if (node2.expression.type === 'JSXEmptyExpression') {
            this.raise(JsxErrors$1.AttributeIsEmpty, {
              at: node2,
            })
          }
          return node2
        case 138:
        case 129:
          return this.parseExprAtom()
        default:
          throw this.raise(JsxErrors$1.UnsupportedJsxValue, {
            at: this.state.startLoc,
          })
      }
    }
    jsxParseEmptyExpression() {
      const node2 = this.startNodeAt(this.state.lastTokEndLoc.index, this.state.lastTokEndLoc)
      return this.finishNodeAt(node2, 'JSXEmptyExpression', this.state.startLoc)
    }
    jsxParseSpreadChild(node2) {
      this.next()
      node2.expression = this.parseExpression()
      this.setContext(types$1.j_oTag)
      this.state.canStartJSXElement = true
      this.expect(8)
      return this.finishNode(node2, 'JSXSpreadChild')
    }
    jsxParseExpressionContainer(node2, previousContext) {
      if (this.match(8)) {
        node2.expression = this.jsxParseEmptyExpression()
      } else {
        const expression2 = this.parseExpression()
        node2.expression = expression2
      }
      this.setContext(previousContext)
      this.state.canStartJSXElement = true
      this.expect(8)
      return this.finishNode(node2, 'JSXExpressionContainer')
    }
    jsxParseAttribute() {
      const node2 = this.startNode()
      if (this.match(5)) {
        this.setContext(types$1.brace)
        this.next()
        this.expect(21)
        node2.argument = this.parseMaybeAssignAllowIn()
        this.setContext(types$1.j_oTag)
        this.state.canStartJSXElement = true
        this.expect(8)
        return this.finishNode(node2, 'JSXSpreadAttribute')
      }
      node2.name = this.jsxParseNamespacedName()
      node2.value = this.eat(29) ? this.jsxParseAttributeValue() : null
      return this.finishNode(node2, 'JSXAttribute')
    }
    jsxParseOpeningElementAt(startPos, startLoc) {
      const node2 = this.startNodeAt(startPos, startLoc)
      if (this.eat(139)) {
        return this.finishNode(node2, 'JSXOpeningFragment')
      }
      node2.name = this.jsxParseElementName()
      return this.jsxParseOpeningElementAfterName(node2)
    }
    jsxParseOpeningElementAfterName(node2) {
      const attributes = []
      while (!this.match(56) && !this.match(139)) {
        attributes.push(this.jsxParseAttribute())
      }
      node2.attributes = attributes
      node2.selfClosing = this.eat(56)
      this.expect(139)
      return this.finishNode(node2, 'JSXOpeningElement')
    }
    jsxParseClosingElementAt(startPos, startLoc) {
      const node2 = this.startNodeAt(startPos, startLoc)
      if (this.eat(139)) {
        return this.finishNode(node2, 'JSXClosingFragment')
      }
      node2.name = this.jsxParseElementName()
      this.expect(139)
      return this.finishNode(node2, 'JSXClosingElement')
    }
    jsxParseElementAt(startPos, startLoc) {
      const node2 = this.startNodeAt(startPos, startLoc)
      const children = []
      const openingElement = this.jsxParseOpeningElementAt(startPos, startLoc)
      let closingElement = null
      if (!openingElement.selfClosing) {
        contents: for (;;) {
          switch (this.state.type) {
            case 138:
              startPos = this.state.start
              startLoc = this.state.startLoc
              this.next()
              if (this.eat(56)) {
                closingElement = this.jsxParseClosingElementAt(startPos, startLoc)
                break contents
              }
              children.push(this.jsxParseElementAt(startPos, startLoc))
              break
            case 137:
              children.push(this.parseExprAtom())
              break
            case 5: {
              const node3 = this.startNode()
              this.setContext(types$1.brace)
              this.next()
              if (this.match(21)) {
                children.push(this.jsxParseSpreadChild(node3))
              } else {
                children.push(this.jsxParseExpressionContainer(node3, types$1.j_expr))
              }
              break
            }
            default:
              throw this.unexpected()
          }
        }
        if (isFragment$1(openingElement) && !isFragment$1(closingElement) && closingElement !== null) {
          this.raise(JsxErrors$1.MissingClosingTagFragment, {
            at: closingElement,
          })
        } else if (!isFragment$1(openingElement) && isFragment$1(closingElement)) {
          this.raise(JsxErrors$1.MissingClosingTagElement, {
            at: closingElement,
            openingTagName: getQualifiedJSXName$1(openingElement.name),
          })
        } else if (!isFragment$1(openingElement) && !isFragment$1(closingElement)) {
          if (getQualifiedJSXName$1(closingElement.name) !== getQualifiedJSXName$1(openingElement.name)) {
            this.raise(JsxErrors$1.MissingClosingTagElement, {
              at: closingElement,
              openingTagName: getQualifiedJSXName$1(openingElement.name),
            })
          }
        }
      }
      if (isFragment$1(openingElement)) {
        node2.openingFragment = openingElement
        node2.closingFragment = closingElement
      } else {
        node2.openingElement = openingElement
        node2.closingElement = closingElement
      }
      node2.children = children
      if (this.match(47)) {
        throw this.raise(JsxErrors$1.UnwrappedAdjacentJSXElements, {
          at: this.state.startLoc,
        })
      }
      return isFragment$1(openingElement) ? this.finishNode(node2, 'JSXFragment') : this.finishNode(node2, 'JSXElement')
    }
    jsxParseElement() {
      const startPos = this.state.start
      const startLoc = this.state.startLoc
      this.next()
      return this.jsxParseElementAt(startPos, startLoc)
    }
    setContext(newContext) {
      const { context: context2 } = this.state
      context2[context2.length - 1] = newContext
    }
    parseExprAtom(refExpressionErrors) {
      if (this.match(137)) {
        return this.parseLiteral(this.state.value, 'JSXText')
      } else if (this.match(138)) {
        return this.jsxParseElement()
      } else if (this.match(47) && this.input.charCodeAt(this.state.pos) !== 33) {
        this.replaceToken(138)
        return this.jsxParseElement()
      } else {
        return super.parseExprAtom(refExpressionErrors)
      }
    }
    skipSpace() {
      const curContext = this.curContext()
      if (!curContext.preserveSpace) super.skipSpace()
    }
    getTokenFromCode(code2) {
      const context2 = this.curContext()
      if (context2 === types$1.j_expr) {
        return this.jsxReadToken()
      }
      if (context2 === types$1.j_oTag || context2 === types$1.j_cTag) {
        if (isIdentifierStart$1(code2)) {
          return this.jsxReadWord()
        }
        if (code2 === 62) {
          ++this.state.pos
          return this.finishToken(139)
        }
        if ((code2 === 34 || code2 === 39) && context2 === types$1.j_oTag) {
          return this.jsxReadString(code2)
        }
      }
      if (code2 === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
        ++this.state.pos
        return this.finishToken(138)
      }
      return super.getTokenFromCode(code2)
    }
    updateContext(prevType) {
      const { context: context2, type } = this.state
      if (type === 56 && prevType === 138) {
        context2.splice(-2, 2, types$1.j_cTag)
        this.state.canStartJSXElement = false
      } else if (type === 138) {
        context2.push(types$1.j_oTag)
      } else if (type === 139) {
        const out = context2[context2.length - 1]
        if ((out === types$1.j_oTag && prevType === 56) || out === types$1.j_cTag) {
          context2.pop()
          this.state.canStartJSXElement = context2[context2.length - 1] === types$1.j_expr
        } else {
          this.setContext(types$1.j_expr)
          this.state.canStartJSXElement = true
        }
      } else {
        this.state.canStartJSXElement = tokenComesBeforeExpression$1(type)
      }
    }
  }
class TypeScriptScope$1 extends Scope$1 {
  constructor(...args) {
    super(...args)
    this.types = /* @__PURE__ */ new Set()
    this.enums = /* @__PURE__ */ new Set()
    this.constEnums = /* @__PURE__ */ new Set()
    this.classes = /* @__PURE__ */ new Set()
    this.exportOnlyBindings = /* @__PURE__ */ new Set()
  }
}
class TypeScriptScopeHandler$1 extends ScopeHandler$1 {
  createScope(flags) {
    return new TypeScriptScope$1(flags)
  }
  declareName(name, bindingType, loc) {
    const scope2 = this.currentScope()
    if (bindingType & BIND_FLAGS_TS_EXPORT_ONLY$1) {
      this.maybeExportDefined(scope2, name)
      scope2.exportOnlyBindings.add(name)
      return
    }
    super.declareName(...arguments)
    if (bindingType & BIND_KIND_TYPE$1) {
      if (!(bindingType & BIND_KIND_VALUE$1)) {
        this.checkRedeclarationInScope(scope2, name, bindingType, loc)
        this.maybeExportDefined(scope2, name)
      }
      scope2.types.add(name)
    }
    if (bindingType & BIND_FLAGS_TS_ENUM$1) scope2.enums.add(name)
    if (bindingType & BIND_FLAGS_TS_CONST_ENUM$1) scope2.constEnums.add(name)
    if (bindingType & BIND_FLAGS_CLASS$1) scope2.classes.add(name)
  }
  isRedeclaredInScope(scope2, name, bindingType) {
    if (scope2.enums.has(name)) {
      if (bindingType & BIND_FLAGS_TS_ENUM$1) {
        const isConst = !!(bindingType & BIND_FLAGS_TS_CONST_ENUM$1)
        const wasConst = scope2.constEnums.has(name)
        return isConst !== wasConst
      }
      return true
    }
    if (bindingType & BIND_FLAGS_CLASS$1 && scope2.classes.has(name)) {
      if (scope2.lexical.has(name)) {
        return !!(bindingType & BIND_KIND_VALUE$1)
      } else {
        return false
      }
    }
    if (bindingType & BIND_KIND_TYPE$1 && scope2.types.has(name)) {
      return true
    }
    return super.isRedeclaredInScope(...arguments)
  }
  checkLocalExport(id) {
    const topLevelScope = this.scopeStack[0]
    const { name } = id
    if (!topLevelScope.types.has(name) && !topLevelScope.exportOnlyBindings.has(name)) {
      super.checkLocalExport(id)
    }
  }
}
const getOwn$1$1 = (object2, key) => Object.hasOwnProperty.call(object2, key) && object2[key]
function nonNull$1(x) {
  if (x == null) {
    throw new Error(`Unexpected ${x} value.`)
  }
  return x
}
function assert$1(x) {
  if (!x) {
    throw new Error('Assert fail')
  }
}
function tsTokenCanStartExpression$1(token) {
  return tokenCanStartExpression$1(token) || tokenIsBinaryOperator$1(token)
}
const TSErrors$1 = ParseErrorEnum$1`typescript`((_2) => ({
  AbstractMethodHasImplementation: _2(
    ({ methodName }) => `Method '${methodName}' cannot have an implementation because it is marked abstract.`
  ),
  AbstractPropertyHasInitializer: _2(
    ({ propertyName }) => `Property '${propertyName}' cannot have an initializer because it is marked abstract.`
  ),
  AccesorCannotDeclareThisParameter: _2("'get' and 'set' accessors cannot declare 'this' parameters."),
  AccesorCannotHaveTypeParameters: _2('An accessor cannot have type parameters.'),
  CannotFindName: _2(({ name }) => `Cannot find name '${name}'.`),
  ClassMethodHasDeclare: _2("Class methods cannot have the 'declare' modifier."),
  ClassMethodHasReadonly: _2("Class methods cannot have the 'readonly' modifier."),
  ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: _2(
    "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference."
  ),
  ConstructorHasTypeParameters: _2('Type parameters cannot appear on a constructor declaration.'),
  DeclareAccessor: _2(({ kind }) => `'declare' is not allowed in ${kind}ters.`),
  DeclareClassFieldHasInitializer: _2('Initializers are not allowed in ambient contexts.'),
  DeclareFunctionHasImplementation: _2('An implementation cannot be declared in ambient contexts.'),
  DuplicateAccessibilityModifier: _2(({ modifier }) => `Accessibility modifier already seen.`),
  DuplicateModifier: _2(({ modifier }) => `Duplicate modifier: '${modifier}'.`),
  EmptyHeritageClauseType: _2(({ token }) => `'${token}' list cannot be empty.`),
  EmptyTypeArguments: _2('Type argument list cannot be empty.'),
  EmptyTypeParameters: _2('Type parameter list cannot be empty.'),
  ExpectedAmbientAfterExportDeclare: _2("'export declare' must be followed by an ambient declaration."),
  ImportAliasHasImportType: _2("An import alias can not use 'import type'."),
  IncompatibleModifiers: _2(
    ({ modifiers }) => `'${modifiers[0]}' modifier cannot be used with '${modifiers[1]}' modifier.`
  ),
  IndexSignatureHasAbstract: _2("Index signatures cannot have the 'abstract' modifier."),
  IndexSignatureHasAccessibility: _2(
    ({ modifier }) => `Index signatures cannot have an accessibility modifier ('${modifier}').`
  ),
  IndexSignatureHasDeclare: _2("Index signatures cannot have the 'declare' modifier."),
  IndexSignatureHasOverride: _2("'override' modifier cannot appear on an index signature."),
  IndexSignatureHasStatic: _2("Index signatures cannot have the 'static' modifier."),
  InitializerNotAllowedInAmbientContext: _2('Initializers are not allowed in ambient contexts.'),
  InvalidModifierOnTypeMember: _2(({ modifier }) => `'${modifier}' modifier cannot appear on a type member.`),
  InvalidModifierOnTypeParameter: _2(({ modifier }) => `'${modifier}' modifier cannot appear on a type parameter.`),
  InvalidModifierOnTypeParameterPositions: _2(
    ({ modifier }) => `'${modifier}' modifier can only appear on a type parameter of a class, interface or type alias.`
  ),
  InvalidModifiersOrder: _2(
    ({ orderedModifiers }) => `'${orderedModifiers[0]}' modifier must precede '${orderedModifiers[1]}' modifier.`
  ),
  InvalidTupleMemberLabel: _2('Tuple members must be labeled with a simple identifier.'),
  MissingInterfaceName: _2("'interface' declarations must be followed by an identifier."),
  MixedLabeledAndUnlabeledElements: _2('Tuple members must all have names or all not have names.'),
  NonAbstractClassHasAbstractMethod: _2('Abstract methods can only appear within an abstract class.'),
  NonClassMethodPropertyHasAbstractModifer: _2(
    "'abstract' modifier can only appear on a class, method, or property declaration."
  ),
  OptionalTypeBeforeRequired: _2('A required element cannot follow an optional element.'),
  OverrideNotInSubClass: _2(
    "This member cannot have an 'override' modifier because its containing class does not extend another class."
  ),
  PatternIsOptional: _2('A binding pattern parameter cannot be optional in an implementation signature.'),
  PrivateElementHasAbstract: _2("Private elements cannot have the 'abstract' modifier."),
  PrivateElementHasAccessibility: _2(
    ({ modifier }) => `Private elements cannot have an accessibility modifier ('${modifier}').`
  ),
  ReadonlyForMethodSignature: _2("'readonly' modifier can only appear on a property declaration or index signature."),
  ReservedArrowTypeParam: _2(
    'This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.'
  ),
  ReservedTypeAssertion: _2(
    'This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.'
  ),
  SetAccesorCannotHaveOptionalParameter: _2("A 'set' accessor cannot have an optional parameter."),
  SetAccesorCannotHaveRestParameter: _2("A 'set' accessor cannot have rest parameter."),
  SetAccesorCannotHaveReturnType: _2("A 'set' accessor cannot have a return type annotation."),
  SingleTypeParameterWithoutTrailingComma: _2(
    ({ typeParameterName }) =>
      `Single type parameter ${typeParameterName} should have a trailing comma. Example usage: <${typeParameterName},>.`
  ),
  StaticBlockCannotHaveModifier: _2('Static class blocks cannot have any modifier.'),
  TypeAnnotationAfterAssign: _2(
    'Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.'
  ),
  TypeImportCannotSpecifyDefaultAndNamed: _2(
    'A type-only import can specify a default import or named bindings, but not both.'
  ),
  TypeModifierIsUsedInTypeExports: _2(
    "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement."
  ),
  TypeModifierIsUsedInTypeImports: _2(
    "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement."
  ),
  UnexpectedParameterModifier: _2('A parameter property is only allowed in a constructor implementation.'),
  UnexpectedReadonly: _2("'readonly' type modifier is only permitted on array and tuple literal types."),
  UnexpectedTypeAnnotation: _2('Did not expect a type annotation here.'),
  UnexpectedTypeCastInParameter: _2('Unexpected type cast in parameter position.'),
  UnsupportedImportTypeArgument: _2('Argument in a type import must be a string literal.'),
  UnsupportedParameterPropertyKind: _2('A parameter property may not be declared using a binding pattern.'),
  UnsupportedSignatureParameterKind: _2(
    ({ type }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${type}.`
  ),
}))
function keywordTypeFromName$1(value) {
  switch (value) {
    case 'any':
      return 'TSAnyKeyword'
    case 'boolean':
      return 'TSBooleanKeyword'
    case 'bigint':
      return 'TSBigIntKeyword'
    case 'never':
      return 'TSNeverKeyword'
    case 'number':
      return 'TSNumberKeyword'
    case 'object':
      return 'TSObjectKeyword'
    case 'string':
      return 'TSStringKeyword'
    case 'symbol':
      return 'TSSymbolKeyword'
    case 'undefined':
      return 'TSUndefinedKeyword'
    case 'unknown':
      return 'TSUnknownKeyword'
    default:
      return void 0
  }
}
function tsIsAccessModifier$1(modifier) {
  return modifier === 'private' || modifier === 'public' || modifier === 'protected'
}
function tsIsVarianceAnnotations$1(modifier) {
  return modifier === 'in' || modifier === 'out'
}
var typescript$1 = (superClass) =>
  class extends superClass {
    getScopeHandler() {
      return TypeScriptScopeHandler$1
    }
    tsIsIdentifier() {
      return tokenIsIdentifier$1(this.state.type)
    }
    tsTokenCanFollowModifier() {
      return (
        (this.match(0) ||
          this.match(5) ||
          this.match(55) ||
          this.match(21) ||
          this.match(134) ||
          this.isLiteralPropertyName()) &&
        !this.hasPrecedingLineBreak()
      )
    }
    tsNextTokenCanFollowModifier() {
      this.next()
      return this.tsTokenCanFollowModifier()
    }
    tsParseModifier(allowedModifiers, stopOnStartOfClassStaticBlock) {
      if (!tokenIsIdentifier$1(this.state.type) && this.state.type !== 58) {
        return void 0
      }
      const modifier = this.state.value
      if (allowedModifiers.indexOf(modifier) !== -1) {
        if (stopOnStartOfClassStaticBlock && this.tsIsStartOfStaticBlocks()) {
          return void 0
        }
        if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {
          return modifier
        }
      }
      return void 0
    }
    tsParseModifiers({
      modified,
      allowedModifiers,
      disallowedModifiers,
      stopOnStartOfClassStaticBlock,
      errorTemplate = TSErrors$1.InvalidModifierOnTypeMember,
    }) {
      const enforceOrder = (loc, modifier, before, after) => {
        if (modifier === before && modified[after]) {
          this.raise(TSErrors$1.InvalidModifiersOrder, {
            at: loc,
            orderedModifiers: [before, after],
          })
        }
      }
      const incompatible = (loc, modifier, mod1, mod2) => {
        if ((modified[mod1] && modifier === mod2) || (modified[mod2] && modifier === mod1)) {
          this.raise(TSErrors$1.IncompatibleModifiers, {
            at: loc,
            modifiers: [mod1, mod2],
          })
        }
      }
      for (;;) {
        const { startLoc } = this.state
        const modifier = this.tsParseModifier(
          allowedModifiers.concat(disallowedModifiers != null ? disallowedModifiers : []),
          stopOnStartOfClassStaticBlock
        )
        if (!modifier) break
        if (tsIsAccessModifier$1(modifier)) {
          if (modified.accessibility) {
            this.raise(TSErrors$1.DuplicateAccessibilityModifier, {
              at: startLoc,
              modifier,
            })
          } else {
            enforceOrder(startLoc, modifier, modifier, 'override')
            enforceOrder(startLoc, modifier, modifier, 'static')
            enforceOrder(startLoc, modifier, modifier, 'readonly')
            modified.accessibility = modifier
          }
        } else if (tsIsVarianceAnnotations$1(modifier)) {
          if (modified[modifier]) {
            this.raise(TSErrors$1.DuplicateModifier, {
              at: startLoc,
              modifier,
            })
          }
          modified[modifier] = true
          enforceOrder(startLoc, modifier, 'in', 'out')
        } else {
          if (Object.hasOwnProperty.call(modified, modifier)) {
            this.raise(TSErrors$1.DuplicateModifier, {
              at: startLoc,
              modifier,
            })
          } else {
            enforceOrder(startLoc, modifier, 'static', 'readonly')
            enforceOrder(startLoc, modifier, 'static', 'override')
            enforceOrder(startLoc, modifier, 'override', 'readonly')
            enforceOrder(startLoc, modifier, 'abstract', 'override')
            incompatible(startLoc, modifier, 'declare', 'override')
            incompatible(startLoc, modifier, 'static', 'abstract')
          }
          modified[modifier] = true
        }
        if (disallowedModifiers != null && disallowedModifiers.includes(modifier)) {
          this.raise(errorTemplate, {
            at: startLoc,
            modifier,
          })
        }
      }
    }
    tsIsListTerminator(kind) {
      switch (kind) {
        case 'EnumMembers':
        case 'TypeMembers':
          return this.match(8)
        case 'HeritageClauseElement':
          return this.match(5)
        case 'TupleElementTypes':
          return this.match(3)
        case 'TypeParametersOrArguments':
          return this.match(48)
      }
      throw new Error('Unreachable')
    }
    tsParseList(kind, parseElement) {
      const result = []
      while (!this.tsIsListTerminator(kind)) {
        result.push(parseElement())
      }
      return result
    }
    tsParseDelimitedList(kind, parseElement, refTrailingCommaPos) {
      return nonNull$1(this.tsParseDelimitedListWorker(kind, parseElement, true, refTrailingCommaPos))
    }
    tsParseDelimitedListWorker(kind, parseElement, expectSuccess, refTrailingCommaPos) {
      const result = []
      let trailingCommaPos = -1
      for (;;) {
        if (this.tsIsListTerminator(kind)) {
          break
        }
        trailingCommaPos = -1
        const element = parseElement()
        if (element == null) {
          return void 0
        }
        result.push(element)
        if (this.eat(12)) {
          trailingCommaPos = this.state.lastTokStart
          continue
        }
        if (this.tsIsListTerminator(kind)) {
          break
        }
        if (expectSuccess) {
          this.expect(12)
        }
        return void 0
      }
      if (refTrailingCommaPos) {
        refTrailingCommaPos.value = trailingCommaPos
      }
      return result
    }
    tsParseBracketedList(kind, parseElement, bracket, skipFirstToken, refTrailingCommaPos) {
      if (!skipFirstToken) {
        if (bracket) {
          this.expect(0)
        } else {
          this.expect(47)
        }
      }
      const result = this.tsParseDelimitedList(kind, parseElement, refTrailingCommaPos)
      if (bracket) {
        this.expect(3)
      } else {
        this.expect(48)
      }
      return result
    }
    tsParseImportType() {
      const node2 = this.startNode()
      this.expect(83)
      this.expect(10)
      if (!this.match(129)) {
        this.raise(TSErrors$1.UnsupportedImportTypeArgument, {
          at: this.state.startLoc,
        })
      }
      node2.argument = this.parseExprAtom()
      this.expect(11)
      if (this.eat(16)) {
        node2.qualifier = this.tsParseEntityName()
      }
      if (this.match(47)) {
        node2.typeParameters = this.tsParseTypeArguments()
      }
      return this.finishNode(node2, 'TSImportType')
    }
    tsParseEntityName(allowReservedWords = true) {
      let entity = this.parseIdentifier(allowReservedWords)
      while (this.eat(16)) {
        const node2 = this.startNodeAtNode(entity)
        node2.left = entity
        node2.right = this.parseIdentifier(allowReservedWords)
        entity = this.finishNode(node2, 'TSQualifiedName')
      }
      return entity
    }
    tsParseTypeReference() {
      const node2 = this.startNode()
      node2.typeName = this.tsParseEntityName()
      if (!this.hasPrecedingLineBreak() && this.match(47)) {
        node2.typeParameters = this.tsParseTypeArguments()
      }
      return this.finishNode(node2, 'TSTypeReference')
    }
    tsParseThisTypePredicate(lhs) {
      this.next()
      const node2 = this.startNodeAtNode(lhs)
      node2.parameterName = lhs
      node2.typeAnnotation = this.tsParseTypeAnnotation(false)
      node2.asserts = false
      return this.finishNode(node2, 'TSTypePredicate')
    }
    tsParseThisTypeNode() {
      const node2 = this.startNode()
      this.next()
      return this.finishNode(node2, 'TSThisType')
    }
    tsParseTypeQuery() {
      const node2 = this.startNode()
      this.expect(87)
      if (this.match(83)) {
        node2.exprName = this.tsParseImportType()
      } else {
        node2.exprName = this.tsParseEntityName()
      }
      if (!this.hasPrecedingLineBreak() && this.match(47)) {
        node2.typeParameters = this.tsParseTypeArguments()
      }
      return this.finishNode(node2, 'TSTypeQuery')
    }
    tsParseInOutModifiers(node2) {
      this.tsParseModifiers({
        modified: node2,
        allowedModifiers: ['in', 'out'],
        disallowedModifiers: ['public', 'private', 'protected', 'readonly', 'declare', 'abstract', 'override'],
        errorTemplate: TSErrors$1.InvalidModifierOnTypeParameter,
      })
    }
    tsParseNoneModifiers(node2) {
      this.tsParseModifiers({
        modified: node2,
        allowedModifiers: [],
        disallowedModifiers: ['in', 'out'],
        errorTemplate: TSErrors$1.InvalidModifierOnTypeParameterPositions,
      })
    }
    tsParseTypeParameter(parseModifiers = this.tsParseNoneModifiers.bind(this)) {
      const node2 = this.startNode()
      parseModifiers(node2)
      node2.name = this.tsParseTypeParameterName()
      node2.constraint = this.tsEatThenParseType(81)
      node2.default = this.tsEatThenParseType(29)
      return this.finishNode(node2, 'TSTypeParameter')
    }
    tsTryParseTypeParameters(parseModifiers) {
      if (this.match(47)) {
        return this.tsParseTypeParameters(parseModifiers)
      }
    }
    tsParseTypeParameters(parseModifiers) {
      const node2 = this.startNode()
      if (this.match(47) || this.match(138)) {
        this.next()
      } else {
        this.unexpected()
      }
      const refTrailingCommaPos = {
        value: -1,
      }
      node2.params = this.tsParseBracketedList(
        'TypeParametersOrArguments',
        this.tsParseTypeParameter.bind(this, parseModifiers),
        false,
        true,
        refTrailingCommaPos
      )
      if (node2.params.length === 0) {
        this.raise(TSErrors$1.EmptyTypeParameters, {
          at: node2,
        })
      }
      if (refTrailingCommaPos.value !== -1) {
        this.addExtra(node2, 'trailingComma', refTrailingCommaPos.value)
      }
      return this.finishNode(node2, 'TSTypeParameterDeclaration')
    }
    tsTryNextParseConstantContext() {
      if (this.lookahead().type !== 75) return null
      this.next()
      const typeReference = this.tsParseTypeReference()
      if (typeReference.typeParameters) {
        this.raise(TSErrors$1.CannotFindName, {
          at: typeReference.typeName,
          name: 'const',
        })
      }
      return typeReference
    }
    tsFillSignature(returnToken, signature) {
      const returnTokenRequired = returnToken === 19
      const paramsKey = 'parameters'
      const returnTypeKey = 'typeAnnotation'
      signature.typeParameters = this.tsTryParseTypeParameters()
      this.expect(10)
      signature[paramsKey] = this.tsParseBindingListForSignature()
      if (returnTokenRequired) {
        signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken)
      } else if (this.match(returnToken)) {
        signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken)
      }
    }
    tsParseBindingListForSignature() {
      return this.parseBindingList(11, 41).map((pattern) => {
        if (
          pattern.type !== 'Identifier' &&
          pattern.type !== 'RestElement' &&
          pattern.type !== 'ObjectPattern' &&
          pattern.type !== 'ArrayPattern'
        ) {
          this.raise(TSErrors$1.UnsupportedSignatureParameterKind, {
            at: pattern,
            type: pattern.type,
          })
        }
        return pattern
      })
    }
    tsParseTypeMemberSemicolon() {
      if (!this.eat(12) && !this.isLineTerminator()) {
        this.expect(13)
      }
    }
    tsParseSignatureMember(kind, node2) {
      this.tsFillSignature(14, node2)
      this.tsParseTypeMemberSemicolon()
      return this.finishNode(node2, kind)
    }
    tsIsUnambiguouslyIndexSignature() {
      this.next()
      if (tokenIsIdentifier$1(this.state.type)) {
        this.next()
        return this.match(14)
      }
      return false
    }
    tsTryParseIndexSignature(node2) {
      if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) {
        return void 0
      }
      this.expect(0)
      const id = this.parseIdentifier()
      id.typeAnnotation = this.tsParseTypeAnnotation()
      this.resetEndLocation(id)
      this.expect(3)
      node2.parameters = [id]
      const type = this.tsTryParseTypeAnnotation()
      if (type) node2.typeAnnotation = type
      this.tsParseTypeMemberSemicolon()
      return this.finishNode(node2, 'TSIndexSignature')
    }
    tsParsePropertyOrMethodSignature(node2, readonly) {
      if (this.eat(17)) node2.optional = true
      const nodeAny = node2
      if (this.match(10) || this.match(47)) {
        if (readonly) {
          this.raise(TSErrors$1.ReadonlyForMethodSignature, {
            at: node2,
          })
        }
        const method = nodeAny
        if (method.kind && this.match(47)) {
          this.raise(TSErrors$1.AccesorCannotHaveTypeParameters, {
            at: this.state.curPosition(),
          })
        }
        this.tsFillSignature(14, method)
        this.tsParseTypeMemberSemicolon()
        const paramsKey = 'parameters'
        const returnTypeKey = 'typeAnnotation'
        if (method.kind === 'get') {
          if (method[paramsKey].length > 0) {
            this.raise(Errors$1.BadGetterArity, {
              at: this.state.curPosition(),
            })
            if (this.isThisParam(method[paramsKey][0])) {
              this.raise(TSErrors$1.AccesorCannotDeclareThisParameter, {
                at: this.state.curPosition(),
              })
            }
          }
        } else if (method.kind === 'set') {
          if (method[paramsKey].length !== 1) {
            this.raise(Errors$1.BadSetterArity, {
              at: this.state.curPosition(),
            })
          } else {
            const firstParameter = method[paramsKey][0]
            if (this.isThisParam(firstParameter)) {
              this.raise(TSErrors$1.AccesorCannotDeclareThisParameter, {
                at: this.state.curPosition(),
              })
            }
            if (firstParameter.type === 'Identifier' && firstParameter.optional) {
              this.raise(TSErrors$1.SetAccesorCannotHaveOptionalParameter, {
                at: this.state.curPosition(),
              })
            }
            if (firstParameter.type === 'RestElement') {
              this.raise(TSErrors$1.SetAccesorCannotHaveRestParameter, {
                at: this.state.curPosition(),
              })
            }
          }
          if (method[returnTypeKey]) {
            this.raise(TSErrors$1.SetAccesorCannotHaveReturnType, {
              at: method[returnTypeKey],
            })
          }
        } else {
          method.kind = 'method'
        }
        return this.finishNode(method, 'TSMethodSignature')
      } else {
        const property = nodeAny
        if (readonly) property.readonly = true
        const type = this.tsTryParseTypeAnnotation()
        if (type) property.typeAnnotation = type
        this.tsParseTypeMemberSemicolon()
        return this.finishNode(property, 'TSPropertySignature')
      }
    }
    tsParseTypeMember() {
      const node2 = this.startNode()
      if (this.match(10) || this.match(47)) {
        return this.tsParseSignatureMember('TSCallSignatureDeclaration', node2)
      }
      if (this.match(77)) {
        const id = this.startNode()
        this.next()
        if (this.match(10) || this.match(47)) {
          return this.tsParseSignatureMember('TSConstructSignatureDeclaration', node2)
        } else {
          node2.key = this.createIdentifier(id, 'new')
          return this.tsParsePropertyOrMethodSignature(node2, false)
        }
      }
      this.tsParseModifiers({
        modified: node2,
        allowedModifiers: ['readonly'],
        disallowedModifiers: ['declare', 'abstract', 'private', 'protected', 'public', 'static', 'override'],
      })
      const idx = this.tsTryParseIndexSignature(node2)
      if (idx) {
        return idx
      }
      this.parsePropertyName(node2)
      if (
        !node2.computed &&
        node2.key.type === 'Identifier' &&
        (node2.key.name === 'get' || node2.key.name === 'set') &&
        this.tsTokenCanFollowModifier()
      ) {
        node2.kind = node2.key.name
        this.parsePropertyName(node2)
      }
      return this.tsParsePropertyOrMethodSignature(node2, !!node2.readonly)
    }
    tsParseTypeLiteral() {
      const node2 = this.startNode()
      node2.members = this.tsParseObjectTypeMembers()
      return this.finishNode(node2, 'TSTypeLiteral')
    }
    tsParseObjectTypeMembers() {
      this.expect(5)
      const members = this.tsParseList('TypeMembers', this.tsParseTypeMember.bind(this))
      this.expect(8)
      return members
    }
    tsIsStartOfMappedType() {
      this.next()
      if (this.eat(53)) {
        return this.isContextual(118)
      }
      if (this.isContextual(118)) {
        this.next()
      }
      if (!this.match(0)) {
        return false
      }
      this.next()
      if (!this.tsIsIdentifier()) {
        return false
      }
      this.next()
      return this.match(58)
    }
    tsParseMappedTypeParameter() {
      const node2 = this.startNode()
      node2.name = this.tsParseTypeParameterName()
      node2.constraint = this.tsExpectThenParseType(58)
      return this.finishNode(node2, 'TSTypeParameter')
    }
    tsParseMappedType() {
      const node2 = this.startNode()
      this.expect(5)
      if (this.match(53)) {
        node2.readonly = this.state.value
        this.next()
        this.expectContextual(118)
      } else if (this.eatContextual(118)) {
        node2.readonly = true
      }
      this.expect(0)
      node2.typeParameter = this.tsParseMappedTypeParameter()
      node2.nameType = this.eatContextual(93) ? this.tsParseType() : null
      this.expect(3)
      if (this.match(53)) {
        node2.optional = this.state.value
        this.next()
        this.expect(17)
      } else if (this.eat(17)) {
        node2.optional = true
      }
      node2.typeAnnotation = this.tsTryParseType()
      this.semicolon()
      this.expect(8)
      return this.finishNode(node2, 'TSMappedType')
    }
    tsParseTupleType() {
      const node2 = this.startNode()
      node2.elementTypes = this.tsParseBracketedList(
        'TupleElementTypes',
        this.tsParseTupleElementType.bind(this),
        true,
        false
      )
      let seenOptionalElement = false
      let labeledElements = null
      node2.elementTypes.forEach((elementNode) => {
        var _labeledElements
        let { type } = elementNode
        if (
          seenOptionalElement &&
          type !== 'TSRestType' &&
          type !== 'TSOptionalType' &&
          !(type === 'TSNamedTupleMember' && elementNode.optional)
        ) {
          this.raise(TSErrors$1.OptionalTypeBeforeRequired, {
            at: elementNode,
          })
        }
        seenOptionalElement =
          seenOptionalElement || (type === 'TSNamedTupleMember' && elementNode.optional) || type === 'TSOptionalType'
        if (type === 'TSRestType') {
          elementNode = elementNode.typeAnnotation
          type = elementNode.type
        }
        const isLabeled = type === 'TSNamedTupleMember'
        labeledElements = (_labeledElements = labeledElements) != null ? _labeledElements : isLabeled
        if (labeledElements !== isLabeled) {
          this.raise(TSErrors$1.MixedLabeledAndUnlabeledElements, {
            at: elementNode,
          })
        }
      })
      return this.finishNode(node2, 'TSTupleType')
    }
    tsParseTupleElementType() {
      const { start: startPos, startLoc } = this.state
      const rest = this.eat(21)
      let type = this.tsParseType()
      const optional = this.eat(17)
      const labeled = this.eat(14)
      if (labeled) {
        const labeledNode = this.startNodeAtNode(type)
        labeledNode.optional = optional
        if (type.type === 'TSTypeReference' && !type.typeParameters && type.typeName.type === 'Identifier') {
          labeledNode.label = type.typeName
        } else {
          this.raise(TSErrors$1.InvalidTupleMemberLabel, {
            at: type,
          })
          labeledNode.label = type
        }
        labeledNode.elementType = this.tsParseType()
        type = this.finishNode(labeledNode, 'TSNamedTupleMember')
      } else if (optional) {
        const optionalTypeNode = this.startNodeAtNode(type)
        optionalTypeNode.typeAnnotation = type
        type = this.finishNode(optionalTypeNode, 'TSOptionalType')
      }
      if (rest) {
        const restNode = this.startNodeAt(startPos, startLoc)
        restNode.typeAnnotation = type
        type = this.finishNode(restNode, 'TSRestType')
      }
      return type
    }
    tsParseParenthesizedType() {
      const node2 = this.startNode()
      this.expect(10)
      node2.typeAnnotation = this.tsParseType()
      this.expect(11)
      return this.finishNode(node2, 'TSParenthesizedType')
    }
    tsParseFunctionOrConstructorType(type, abstract) {
      const node2 = this.startNode()
      if (type === 'TSConstructorType') {
        node2.abstract = !!abstract
        if (abstract) this.next()
        this.next()
      }
      this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, node2))
      return this.finishNode(node2, type)
    }
    tsParseLiteralTypeNode() {
      const node2 = this.startNode()
      node2.literal = (() => {
        switch (this.state.type) {
          case 130:
          case 131:
          case 129:
          case 85:
          case 86:
            return this.parseExprAtom()
          default:
            throw this.unexpected()
        }
      })()
      return this.finishNode(node2, 'TSLiteralType')
    }
    tsParseTemplateLiteralType() {
      const node2 = this.startNode()
      node2.literal = this.parseTemplate(false)
      return this.finishNode(node2, 'TSLiteralType')
    }
    parseTemplateSubstitution() {
      if (this.state.inType) return this.tsParseType()
      return super.parseTemplateSubstitution()
    }
    tsParseThisTypeOrThisTypePredicate() {
      const thisKeyword = this.tsParseThisTypeNode()
      if (this.isContextual(113) && !this.hasPrecedingLineBreak()) {
        return this.tsParseThisTypePredicate(thisKeyword)
      } else {
        return thisKeyword
      }
    }
    tsParseNonArrayType() {
      switch (this.state.type) {
        case 129:
        case 130:
        case 131:
        case 85:
        case 86:
          return this.tsParseLiteralTypeNode()
        case 53:
          if (this.state.value === '-') {
            const node2 = this.startNode()
            const nextToken = this.lookahead()
            if (nextToken.type !== 130 && nextToken.type !== 131) {
              throw this.unexpected()
            }
            node2.literal = this.parseMaybeUnary()
            return this.finishNode(node2, 'TSLiteralType')
          }
          break
        case 78:
          return this.tsParseThisTypeOrThisTypePredicate()
        case 87:
          return this.tsParseTypeQuery()
        case 83:
          return this.tsParseImportType()
        case 5:
          return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this))
            ? this.tsParseMappedType()
            : this.tsParseTypeLiteral()
        case 0:
          return this.tsParseTupleType()
        case 10:
          return this.tsParseParenthesizedType()
        case 25:
        case 24:
          return this.tsParseTemplateLiteralType()
        default: {
          const { type } = this.state
          if (tokenIsIdentifier$1(type) || type === 88 || type === 84) {
            const nodeType =
              type === 88 ? 'TSVoidKeyword' : type === 84 ? 'TSNullKeyword' : keywordTypeFromName$1(this.state.value)
            if (nodeType !== void 0 && this.lookaheadCharCode() !== 46) {
              const node2 = this.startNode()
              this.next()
              return this.finishNode(node2, nodeType)
            }
            return this.tsParseTypeReference()
          }
        }
      }
      throw this.unexpected()
    }
    tsParseArrayTypeOrHigher() {
      let type = this.tsParseNonArrayType()
      while (!this.hasPrecedingLineBreak() && this.eat(0)) {
        if (this.match(3)) {
          const node2 = this.startNodeAtNode(type)
          node2.elementType = type
          this.expect(3)
          type = this.finishNode(node2, 'TSArrayType')
        } else {
          const node2 = this.startNodeAtNode(type)
          node2.objectType = type
          node2.indexType = this.tsParseType()
          this.expect(3)
          type = this.finishNode(node2, 'TSIndexedAccessType')
        }
      }
      return type
    }
    tsParseTypeOperator() {
      const node2 = this.startNode()
      const operator = this.state.value
      this.next()
      node2.operator = operator
      node2.typeAnnotation = this.tsParseTypeOperatorOrHigher()
      if (operator === 'readonly') {
        this.tsCheckTypeAnnotationForReadOnly(node2)
      }
      return this.finishNode(node2, 'TSTypeOperator')
    }
    tsCheckTypeAnnotationForReadOnly(node2) {
      switch (node2.typeAnnotation.type) {
        case 'TSTupleType':
        case 'TSArrayType':
          return
        default:
          this.raise(TSErrors$1.UnexpectedReadonly, {
            at: node2,
          })
      }
    }
    tsParseInferType() {
      const node2 = this.startNode()
      this.expectContextual(112)
      const typeParameter2 = this.startNode()
      typeParameter2.name = this.tsParseTypeParameterName()
      typeParameter2.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType())
      node2.typeParameter = this.finishNode(typeParameter2, 'TSTypeParameter')
      return this.finishNode(node2, 'TSInferType')
    }
    tsParseConstraintForInferType() {
      if (this.eat(81)) {
        const constraint = this.tsInDisallowConditionalTypesContext(() => this.tsParseType())
        if (this.state.inDisallowConditionalTypesContext || !this.match(17)) {
          return constraint
        }
      }
    }
    tsParseTypeOperatorOrHigher() {
      const isTypeOperator = tokenIsTSTypeOperator$1(this.state.type) && !this.state.containsEsc
      return isTypeOperator
        ? this.tsParseTypeOperator()
        : this.isContextual(112)
        ? this.tsParseInferType()
        : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher())
    }
    tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {
      const node2 = this.startNode()
      const hasLeadingOperator = this.eat(operator)
      const types2 = []
      do {
        types2.push(parseConstituentType())
      } while (this.eat(operator))
      if (types2.length === 1 && !hasLeadingOperator) {
        return types2[0]
      }
      node2.types = types2
      return this.finishNode(node2, kind)
    }
    tsParseIntersectionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType('TSIntersectionType', this.tsParseTypeOperatorOrHigher.bind(this), 45)
    }
    tsParseUnionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType('TSUnionType', this.tsParseIntersectionTypeOrHigher.bind(this), 43)
    }
    tsIsStartOfFunctionType() {
      if (this.match(47)) {
        return true
      }
      return this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this))
    }
    tsSkipParameterStart() {
      if (tokenIsIdentifier$1(this.state.type) || this.match(78)) {
        this.next()
        return true
      }
      if (this.match(5)) {
        const { errors } = this.state
        const previousErrorCount = errors.length
        try {
          this.parseObjectLike(8, true)
          return errors.length === previousErrorCount
        } catch (_unused) {
          return false
        }
      }
      if (this.match(0)) {
        this.next()
        const { errors } = this.state
        const previousErrorCount = errors.length
        try {
          this.parseBindingList(3, 93, true)
          return errors.length === previousErrorCount
        } catch (_unused2) {
          return false
        }
      }
      return false
    }
    tsIsUnambiguouslyStartOfFunctionType() {
      this.next()
      if (this.match(11) || this.match(21)) {
        return true
      }
      if (this.tsSkipParameterStart()) {
        if (this.match(14) || this.match(12) || this.match(17) || this.match(29)) {
          return true
        }
        if (this.match(11)) {
          this.next()
          if (this.match(19)) {
            return true
          }
        }
      }
      return false
    }
    tsParseTypeOrTypePredicateAnnotation(returnToken) {
      return this.tsInType(() => {
        const t2 = this.startNode()
        this.expect(returnToken)
        const node2 = this.startNode()
        const asserts = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this))
        if (asserts && this.match(78)) {
          let thisTypePredicate = this.tsParseThisTypeOrThisTypePredicate()
          if (thisTypePredicate.type === 'TSThisType') {
            node2.parameterName = thisTypePredicate
            node2.asserts = true
            node2.typeAnnotation = null
            thisTypePredicate = this.finishNode(node2, 'TSTypePredicate')
          } else {
            this.resetStartLocationFromNode(thisTypePredicate, node2)
            thisTypePredicate.asserts = true
          }
          t2.typeAnnotation = thisTypePredicate
          return this.finishNode(t2, 'TSTypeAnnotation')
        }
        const typePredicateVariable =
          this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this))
        if (!typePredicateVariable) {
          if (!asserts) {
            return this.tsParseTypeAnnotation(false, t2)
          }
          node2.parameterName = this.parseIdentifier()
          node2.asserts = asserts
          node2.typeAnnotation = null
          t2.typeAnnotation = this.finishNode(node2, 'TSTypePredicate')
          return this.finishNode(t2, 'TSTypeAnnotation')
        }
        const type = this.tsParseTypeAnnotation(false)
        node2.parameterName = typePredicateVariable
        node2.typeAnnotation = type
        node2.asserts = asserts
        t2.typeAnnotation = this.finishNode(node2, 'TSTypePredicate')
        return this.finishNode(t2, 'TSTypeAnnotation')
      })
    }
    tsTryParseTypeOrTypePredicateAnnotation() {
      return this.match(14) ? this.tsParseTypeOrTypePredicateAnnotation(14) : void 0
    }
    tsTryParseTypeAnnotation() {
      return this.match(14) ? this.tsParseTypeAnnotation() : void 0
    }
    tsTryParseType() {
      return this.tsEatThenParseType(14)
    }
    tsParseTypePredicatePrefix() {
      const id = this.parseIdentifier()
      if (this.isContextual(113) && !this.hasPrecedingLineBreak()) {
        this.next()
        return id
      }
    }
    tsParseTypePredicateAsserts() {
      if (this.state.type !== 106) {
        return false
      }
      const containsEsc = this.state.containsEsc
      this.next()
      if (!tokenIsIdentifier$1(this.state.type) && !this.match(78)) {
        return false
      }
      if (containsEsc) {
        this.raise(Errors$1.InvalidEscapedReservedWord, {
          at: this.state.lastTokStartLoc,
          reservedWord: 'asserts',
        })
      }
      return true
    }
    tsParseTypeAnnotation(eatColon = true, t2 = this.startNode()) {
      this.tsInType(() => {
        if (eatColon) this.expect(14)
        t2.typeAnnotation = this.tsParseType()
      })
      return this.finishNode(t2, 'TSTypeAnnotation')
    }
    tsParseType() {
      assert$1(this.state.inType)
      const type = this.tsParseNonConditionalType()
      if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81)) {
        return type
      }
      const node2 = this.startNodeAtNode(type)
      node2.checkType = type
      node2.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType())
      this.expect(17)
      node2.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType())
      this.expect(14)
      node2.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType())
      return this.finishNode(node2, 'TSConditionalType')
    }
    isAbstractConstructorSignature() {
      return this.isContextual(120) && this.lookahead().type === 77
    }
    tsParseNonConditionalType() {
      if (this.tsIsStartOfFunctionType()) {
        return this.tsParseFunctionOrConstructorType('TSFunctionType')
      }
      if (this.match(77)) {
        return this.tsParseFunctionOrConstructorType('TSConstructorType')
      } else if (this.isAbstractConstructorSignature()) {
        return this.tsParseFunctionOrConstructorType('TSConstructorType', true)
      }
      return this.tsParseUnionTypeOrHigher()
    }
    tsParseTypeAssertion() {
      if (this.getPluginOption('typescript', 'disallowAmbiguousJSXLike')) {
        this.raise(TSErrors$1.ReservedTypeAssertion, {
          at: this.state.startLoc,
        })
      }
      const node2 = this.startNode()
      const _const = this.tsTryNextParseConstantContext()
      node2.typeAnnotation = _const || this.tsNextThenParseType()
      this.expect(48)
      node2.expression = this.parseMaybeUnary()
      return this.finishNode(node2, 'TSTypeAssertion')
    }
    tsParseHeritageClause(token) {
      const originalStartLoc = this.state.startLoc
      const delimitedList = this.tsParseDelimitedList('HeritageClauseElement', () => {
        const node2 = this.startNode()
        node2.expression = this.tsParseEntityName()
        if (this.match(47)) {
          node2.typeParameters = this.tsParseTypeArguments()
        }
        return this.finishNode(node2, 'TSExpressionWithTypeArguments')
      })
      if (!delimitedList.length) {
        this.raise(TSErrors$1.EmptyHeritageClauseType, {
          at: originalStartLoc,
          token,
        })
      }
      return delimitedList
    }
    tsParseInterfaceDeclaration(node2, properties = {}) {
      if (this.hasFollowingLineBreak()) return null
      this.expectContextual(125)
      if (properties.declare) node2.declare = true
      if (tokenIsIdentifier$1(this.state.type)) {
        node2.id = this.parseIdentifier()
        this.checkIdentifier(node2.id, BIND_TS_INTERFACE$1)
      } else {
        node2.id = null
        this.raise(TSErrors$1.MissingInterfaceName, {
          at: this.state.startLoc,
        })
      }
      node2.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this))
      if (this.eat(81)) {
        node2.extends = this.tsParseHeritageClause('extends')
      }
      const body = this.startNode()
      body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this))
      node2.body = this.finishNode(body, 'TSInterfaceBody')
      return this.finishNode(node2, 'TSInterfaceDeclaration')
    }
    tsParseTypeAliasDeclaration(node2) {
      node2.id = this.parseIdentifier()
      this.checkIdentifier(node2.id, BIND_TS_TYPE$1)
      node2.typeAnnotation = this.tsInType(() => {
        node2.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this))
        this.expect(29)
        if (this.isContextual(111) && this.lookahead().type !== 16) {
          const node3 = this.startNode()
          this.next()
          return this.finishNode(node3, 'TSIntrinsicKeyword')
        }
        return this.tsParseType()
      })
      this.semicolon()
      return this.finishNode(node2, 'TSTypeAliasDeclaration')
    }
    tsInNoContext(cb) {
      const oldContext = this.state.context
      this.state.context = [oldContext[0]]
      try {
        return cb()
      } finally {
        this.state.context = oldContext
      }
    }
    tsInType(cb) {
      const oldInType = this.state.inType
      this.state.inType = true
      try {
        return cb()
      } finally {
        this.state.inType = oldInType
      }
    }
    tsInDisallowConditionalTypesContext(cb) {
      const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext
      this.state.inDisallowConditionalTypesContext = true
      try {
        return cb()
      } finally {
        this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext
      }
    }
    tsInAllowConditionalTypesContext(cb) {
      const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext
      this.state.inDisallowConditionalTypesContext = false
      try {
        return cb()
      } finally {
        this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext
      }
    }
    tsEatThenParseType(token) {
      return !this.match(token) ? void 0 : this.tsNextThenParseType()
    }
    tsExpectThenParseType(token) {
      return this.tsDoThenParseType(() => this.expect(token))
    }
    tsNextThenParseType() {
      return this.tsDoThenParseType(() => this.next())
    }
    tsDoThenParseType(cb) {
      return this.tsInType(() => {
        cb()
        return this.tsParseType()
      })
    }
    tsParseEnumMember() {
      const node2 = this.startNode()
      node2.id = this.match(129) ? this.parseExprAtom() : this.parseIdentifier(true)
      if (this.eat(29)) {
        node2.initializer = this.parseMaybeAssignAllowIn()
      }
      return this.finishNode(node2, 'TSEnumMember')
    }
    tsParseEnumDeclaration(node2, properties = {}) {
      if (properties.const) node2.const = true
      if (properties.declare) node2.declare = true
      this.expectContextual(122)
      node2.id = this.parseIdentifier()
      this.checkIdentifier(node2.id, node2.const ? BIND_TS_CONST_ENUM$1 : BIND_TS_ENUM$1)
      this.expect(5)
      node2.members = this.tsParseDelimitedList('EnumMembers', this.tsParseEnumMember.bind(this))
      this.expect(8)
      return this.finishNode(node2, 'TSEnumDeclaration')
    }
    tsParseModuleBlock() {
      const node2 = this.startNode()
      this.scope.enter(SCOPE_OTHER$1)
      this.expect(5)
      this.parseBlockOrModuleBlockBody((node2.body = []), void 0, true, 8)
      this.scope.exit()
      return this.finishNode(node2, 'TSModuleBlock')
    }
    tsParseModuleOrNamespaceDeclaration(node2, nested = false) {
      node2.id = this.parseIdentifier()
      if (!nested) {
        this.checkIdentifier(node2.id, BIND_TS_NAMESPACE$1)
      }
      if (this.eat(16)) {
        const inner = this.startNode()
        this.tsParseModuleOrNamespaceDeclaration(inner, true)
        node2.body = inner
      } else {
        this.scope.enter(SCOPE_TS_MODULE$1)
        this.prodParam.enter(PARAM$1)
        node2.body = this.tsParseModuleBlock()
        this.prodParam.exit()
        this.scope.exit()
      }
      return this.finishNode(node2, 'TSModuleDeclaration')
    }
    tsParseAmbientExternalModuleDeclaration(node2) {
      if (this.isContextual(109)) {
        node2.global = true
        node2.id = this.parseIdentifier()
      } else if (this.match(129)) {
        node2.id = this.parseExprAtom()
      } else {
        this.unexpected()
      }
      if (this.match(5)) {
        this.scope.enter(SCOPE_TS_MODULE$1)
        this.prodParam.enter(PARAM$1)
        node2.body = this.tsParseModuleBlock()
        this.prodParam.exit()
        this.scope.exit()
      } else {
        this.semicolon()
      }
      return this.finishNode(node2, 'TSModuleDeclaration')
    }
    tsParseImportEqualsDeclaration(node2, isExport) {
      node2.isExport = isExport || false
      node2.id = this.parseIdentifier()
      this.checkIdentifier(node2.id, BIND_LEXICAL$1)
      this.expect(29)
      const moduleReference = this.tsParseModuleReference()
      if (node2.importKind === 'type' && moduleReference.type !== 'TSExternalModuleReference') {
        this.raise(TSErrors$1.ImportAliasHasImportType, {
          at: moduleReference,
        })
      }
      node2.moduleReference = moduleReference
      this.semicolon()
      return this.finishNode(node2, 'TSImportEqualsDeclaration')
    }
    tsIsExternalModuleReference() {
      return this.isContextual(116) && this.lookaheadCharCode() === 40
    }
    tsParseModuleReference() {
      return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false)
    }
    tsParseExternalModuleReference() {
      const node2 = this.startNode()
      this.expectContextual(116)
      this.expect(10)
      if (!this.match(129)) {
        throw this.unexpected()
      }
      node2.expression = this.parseExprAtom()
      this.expect(11)
      return this.finishNode(node2, 'TSExternalModuleReference')
    }
    tsLookAhead(f) {
      const state = this.state.clone()
      const res = f()
      this.state = state
      return res
    }
    tsTryParseAndCatch(f) {
      const result = this.tryParse((abort) => f() || abort())
      if (result.aborted || !result.node) return void 0
      if (result.error) this.state = result.failState
      return result.node
    }
    tsTryParse(f) {
      const state = this.state.clone()
      const result = f()
      if (result !== void 0 && result !== false) {
        return result
      } else {
        this.state = state
        return void 0
      }
    }
    tsTryParseDeclare(nany) {
      if (this.isLineTerminator()) {
        return
      }
      let starttype = this.state.type
      let kind
      if (this.isContextual(99)) {
        starttype = 74
        kind = 'let'
      }
      return this.tsInAmbientContext(() => {
        if (starttype === 68) {
          nany.declare = true
          return this.parseFunctionStatement(nany, false, true)
        }
        if (starttype === 80) {
          nany.declare = true
          return this.parseClass(nany, true, false)
        }
        if (starttype === 122) {
          return this.tsParseEnumDeclaration(nany, {
            declare: true,
          })
        }
        if (starttype === 109) {
          return this.tsParseAmbientExternalModuleDeclaration(nany)
        }
        if (starttype === 75 || starttype === 74) {
          if (!this.match(75) || !this.isLookaheadContextual('enum')) {
            nany.declare = true
            return this.parseVarStatement(nany, kind || this.state.value, true)
          }
          this.expect(75)
          return this.tsParseEnumDeclaration(nany, {
            const: true,
            declare: true,
          })
        }
        if (starttype === 125) {
          const result = this.tsParseInterfaceDeclaration(nany, {
            declare: true,
          })
          if (result) return result
        }
        if (tokenIsIdentifier$1(starttype)) {
          return this.tsParseDeclaration(nany, this.state.value, true)
        }
      })
    }
    tsTryParseExportDeclaration() {
      return this.tsParseDeclaration(this.startNode(), this.state.value, true)
    }
    tsParseExpressionStatement(node2, expr) {
      switch (expr.name) {
        case 'declare': {
          const declaration = this.tsTryParseDeclare(node2)
          if (declaration) {
            declaration.declare = true
            return declaration
          }
          break
        }
        case 'global':
          if (this.match(5)) {
            this.scope.enter(SCOPE_TS_MODULE$1)
            this.prodParam.enter(PARAM$1)
            const mod2 = node2
            mod2.global = true
            mod2.id = expr
            mod2.body = this.tsParseModuleBlock()
            this.scope.exit()
            this.prodParam.exit()
            return this.finishNode(mod2, 'TSModuleDeclaration')
          }
          break
        default:
          return this.tsParseDeclaration(node2, expr.name, false)
      }
    }
    tsParseDeclaration(node2, value, next) {
      switch (value) {
        case 'abstract':
          if (this.tsCheckLineTerminator(next) && (this.match(80) || tokenIsIdentifier$1(this.state.type))) {
            return this.tsParseAbstractDeclaration(node2)
          }
          break
        case 'module':
          if (this.tsCheckLineTerminator(next)) {
            if (this.match(129)) {
              return this.tsParseAmbientExternalModuleDeclaration(node2)
            } else if (tokenIsIdentifier$1(this.state.type)) {
              return this.tsParseModuleOrNamespaceDeclaration(node2)
            }
          }
          break
        case 'namespace':
          if (this.tsCheckLineTerminator(next) && tokenIsIdentifier$1(this.state.type)) {
            return this.tsParseModuleOrNamespaceDeclaration(node2)
          }
          break
        case 'type':
          if (this.tsCheckLineTerminator(next) && tokenIsIdentifier$1(this.state.type)) {
            return this.tsParseTypeAliasDeclaration(node2)
          }
          break
      }
    }
    tsCheckLineTerminator(next) {
      if (next) {
        if (this.hasFollowingLineBreak()) return false
        this.next()
        return true
      }
      return !this.isLineTerminator()
    }
    tsTryParseGenericAsyncArrowFunction(startPos, startLoc) {
      if (!this.match(47)) {
        return void 0
      }
      const oldMaybeInArrowParameters = this.state.maybeInArrowParameters
      this.state.maybeInArrowParameters = true
      const res = this.tsTryParseAndCatch(() => {
        const node2 = this.startNodeAt(startPos, startLoc)
        node2.typeParameters = this.tsParseTypeParameters()
        super.parseFunctionParams(node2)
        node2.returnType = this.tsTryParseTypeOrTypePredicateAnnotation()
        this.expect(19)
        return node2
      })
      this.state.maybeInArrowParameters = oldMaybeInArrowParameters
      if (!res) {
        return void 0
      }
      return this.parseArrowExpression(res, null, true)
    }
    tsParseTypeArgumentsInExpression() {
      if (this.reScan_lt() !== 47) {
        return void 0
      }
      return this.tsParseTypeArguments()
    }
    tsParseTypeArguments() {
      const node2 = this.startNode()
      node2.params = this.tsInType(() =>
        this.tsInNoContext(() => {
          this.expect(47)
          return this.tsParseDelimitedList('TypeParametersOrArguments', this.tsParseType.bind(this))
        })
      )
      if (node2.params.length === 0) {
        this.raise(TSErrors$1.EmptyTypeArguments, {
          at: node2,
        })
      }
      this.expect(48)
      return this.finishNode(node2, 'TSTypeParameterInstantiation')
    }
    tsIsDeclarationStart() {
      return tokenIsTSDeclarationStart$1(this.state.type)
    }
    isExportDefaultSpecifier() {
      if (this.tsIsDeclarationStart()) return false
      return super.isExportDefaultSpecifier()
    }
    parseAssignableListItem(allowModifiers, decorators) {
      const startPos = this.state.start
      const startLoc = this.state.startLoc
      let accessibility
      let readonly = false
      let override = false
      if (allowModifiers !== void 0) {
        const modified = {}
        this.tsParseModifiers({
          modified,
          allowedModifiers: ['public', 'private', 'protected', 'override', 'readonly'],
        })
        accessibility = modified.accessibility
        override = modified.override
        readonly = modified.readonly
        if (allowModifiers === false && (accessibility || readonly || override)) {
          this.raise(TSErrors$1.UnexpectedParameterModifier, {
            at: startLoc,
          })
        }
      }
      const left = this.parseMaybeDefault()
      this.parseAssignableListItemTypes(left)
      const elt = this.parseMaybeDefault(left.start, left.loc.start, left)
      if (accessibility || readonly || override) {
        const pp = this.startNodeAt(startPos, startLoc)
        if (decorators.length) {
          pp.decorators = decorators
        }
        if (accessibility) pp.accessibility = accessibility
        if (readonly) pp.readonly = readonly
        if (override) pp.override = override
        if (elt.type !== 'Identifier' && elt.type !== 'AssignmentPattern') {
          this.raise(TSErrors$1.UnsupportedParameterPropertyKind, {
            at: pp,
          })
        }
        pp.parameter = elt
        return this.finishNode(pp, 'TSParameterProperty')
      }
      if (decorators.length) {
        left.decorators = decorators
      }
      return elt
    }
    isSimpleParameter(node2) {
      return (
        (node2.type === 'TSParameterProperty' && super.isSimpleParameter(node2.parameter)) ||
        super.isSimpleParameter(node2)
      )
    }
    parseFunctionBodyAndFinish(node2, type, isMethod2 = false) {
      if (this.match(14)) {
        node2.returnType = this.tsParseTypeOrTypePredicateAnnotation(14)
      }
      const bodilessType =
        type === 'FunctionDeclaration'
          ? 'TSDeclareFunction'
          : type === 'ClassMethod' || type === 'ClassPrivateMethod'
          ? 'TSDeclareMethod'
          : void 0
      if (bodilessType && !this.match(5) && this.isLineTerminator()) {
        this.finishNode(node2, bodilessType)
        return
      }
      if (bodilessType === 'TSDeclareFunction' && this.state.isAmbientContext) {
        this.raise(TSErrors$1.DeclareFunctionHasImplementation, {
          at: node2,
        })
        if (node2.declare) {
          super.parseFunctionBodyAndFinish(node2, bodilessType, isMethod2)
          return
        }
      }
      super.parseFunctionBodyAndFinish(node2, type, isMethod2)
    }
    registerFunctionStatementId(node2) {
      if (!node2.body && node2.id) {
        this.checkIdentifier(node2.id, BIND_TS_AMBIENT$1)
      } else {
        super.registerFunctionStatementId(...arguments)
      }
    }
    tsCheckForInvalidTypeCasts(items) {
      items.forEach((node2) => {
        if ((node2 == null ? void 0 : node2.type) === 'TSTypeCastExpression') {
          this.raise(TSErrors$1.UnexpectedTypeAnnotation, {
            at: node2.typeAnnotation,
          })
        }
      })
    }
    toReferencedList(exprList, isInParens) {
      this.tsCheckForInvalidTypeCasts(exprList)
      return exprList
    }
    parseArrayLike(...args) {
      const node2 = super.parseArrayLike(...args)
      if (node2.type === 'ArrayExpression') {
        this.tsCheckForInvalidTypeCasts(node2.elements)
      }
      return node2
    }
    parseSubscript(base2, startPos, startLoc, noCalls, state) {
      if (!this.hasPrecedingLineBreak() && this.match(35)) {
        this.state.canStartJSXElement = false
        this.next()
        const nonNullExpression = this.startNodeAt(startPos, startLoc)
        nonNullExpression.expression = base2
        return this.finishNode(nonNullExpression, 'TSNonNullExpression')
      }
      let isOptionalCall = false
      if (this.match(18) && this.lookaheadCharCode() === 60) {
        if (noCalls) {
          state.stop = true
          return base2
        }
        state.optionalChainMember = isOptionalCall = true
        this.next()
      }
      if (this.match(47) || this.match(51)) {
        let missingParenErrorLoc
        const result = this.tsTryParseAndCatch(() => {
          if (!noCalls && this.atPossibleAsyncArrow(base2)) {
            const asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(startPos, startLoc)
            if (asyncArrowFn) {
              return asyncArrowFn
            }
          }
          const typeArguments = this.tsParseTypeArgumentsInExpression()
          if (!typeArguments) throw this.unexpected()
          if (isOptionalCall && !this.match(10)) {
            missingParenErrorLoc = this.state.curPosition()
            throw this.unexpected()
          }
          if (tokenIsTemplate$1(this.state.type)) {
            const result2 = this.parseTaggedTemplateExpression(base2, startPos, startLoc, state)
            result2.typeParameters = typeArguments
            return result2
          }
          if (!noCalls && this.eat(10)) {
            const node3 = this.startNodeAt(startPos, startLoc)
            node3.callee = base2
            node3.arguments = this.parseCallExpressionArguments(11, false)
            this.tsCheckForInvalidTypeCasts(node3.arguments)
            node3.typeParameters = typeArguments
            if (state.optionalChainMember) {
              node3.optional = isOptionalCall
            }
            return this.finishCallExpression(node3, state.optionalChainMember)
          }
          if (tsTokenCanStartExpression$1(this.state.type) && this.state.type !== 10) {
            throw this.unexpected()
          }
          const node2 = this.startNodeAt(startPos, startLoc)
          node2.expression = base2
          node2.typeParameters = typeArguments
          return this.finishNode(node2, 'TSInstantiationExpression')
        })
        if (missingParenErrorLoc) {
          this.unexpected(missingParenErrorLoc, 10)
        }
        if (result) return result
      }
      return super.parseSubscript(base2, startPos, startLoc, noCalls, state)
    }
    parseNewCallee(node2) {
      var _callee$extra
      super.parseNewCallee(node2)
      const { callee } = node2
      if (
        callee.type === 'TSInstantiationExpression' &&
        !((_callee$extra = callee.extra) != null && _callee$extra.parenthesized)
      ) {
        node2.typeParameters = callee.typeParameters
        node2.callee = callee.expression
      }
    }
    parseExprOp(left, leftStartPos, leftStartLoc, minPrec) {
      if (tokenOperatorPrecedence$1(58) > minPrec && !this.hasPrecedingLineBreak() && this.isContextual(93)) {
        const node2 = this.startNodeAt(leftStartPos, leftStartLoc)
        node2.expression = left
        const _const = this.tsTryNextParseConstantContext()
        if (_const) {
          node2.typeAnnotation = _const
        } else {
          node2.typeAnnotation = this.tsNextThenParseType()
        }
        this.finishNode(node2, 'TSAsExpression')
        this.reScan_lt_gt()
        return this.parseExprOp(node2, leftStartPos, leftStartLoc, minPrec)
      }
      return super.parseExprOp(left, leftStartPos, leftStartLoc, minPrec)
    }
    checkReservedWord(word, startLoc, checkKeywords, isBinding2) {
      if (!this.state.isAmbientContext) {
        super.checkReservedWord(word, startLoc, checkKeywords, isBinding2)
      }
    }
    checkDuplicateExports() {}
    parseImport(node2) {
      node2.importKind = 'value'
      if (tokenIsIdentifier$1(this.state.type) || this.match(55) || this.match(5)) {
        let ahead = this.lookahead()
        if (this.isContextual(126) && ahead.type !== 12 && ahead.type !== 97 && ahead.type !== 29) {
          node2.importKind = 'type'
          this.next()
          ahead = this.lookahead()
        }
        if (tokenIsIdentifier$1(this.state.type) && ahead.type === 29) {
          return this.tsParseImportEqualsDeclaration(node2)
        }
      }
      const importNode = super.parseImport(node2)
      if (
        importNode.importKind === 'type' &&
        importNode.specifiers.length > 1 &&
        importNode.specifiers[0].type === 'ImportDefaultSpecifier'
      ) {
        this.raise(TSErrors$1.TypeImportCannotSpecifyDefaultAndNamed, {
          at: importNode,
        })
      }
      return importNode
    }
    parseExport(node2) {
      if (this.match(83)) {
        this.next()
        if (this.isContextual(126) && this.lookaheadCharCode() !== 61) {
          node2.importKind = 'type'
          this.next()
        } else {
          node2.importKind = 'value'
        }
        return this.tsParseImportEqualsDeclaration(node2, true)
      } else if (this.eat(29)) {
        const assign = node2
        assign.expression = this.parseExpression()
        this.semicolon()
        return this.finishNode(assign, 'TSExportAssignment')
      } else if (this.eatContextual(93)) {
        const decl = node2
        this.expectContextual(124)
        decl.id = this.parseIdentifier()
        this.semicolon()
        return this.finishNode(decl, 'TSNamespaceExportDeclaration')
      } else {
        if (this.isContextual(126) && this.lookahead().type === 5) {
          this.next()
          node2.exportKind = 'type'
        } else {
          node2.exportKind = 'value'
        }
        return super.parseExport(node2)
      }
    }
    isAbstractClass() {
      return this.isContextual(120) && this.lookahead().type === 80
    }
    parseExportDefaultExpression() {
      if (this.isAbstractClass()) {
        const cls = this.startNode()
        this.next()
        cls.abstract = true
        this.parseClass(cls, true, true)
        return cls
      }
      if (this.match(125)) {
        const result = this.tsParseInterfaceDeclaration(this.startNode())
        if (result) return result
      }
      return super.parseExportDefaultExpression()
    }
    parseVarStatement(node2, kind, allowMissingInitializer = false) {
      const { isAmbientContext } = this.state
      const declaration = super.parseVarStatement(node2, kind, allowMissingInitializer || isAmbientContext)
      if (!isAmbientContext) return declaration
      for (const { id, init } of declaration.declarations) {
        if (!init) continue
        if (kind !== 'const' || !!id.typeAnnotation) {
          this.raise(TSErrors$1.InitializerNotAllowedInAmbientContext, {
            at: init,
          })
        } else if (
          init.type !== 'StringLiteral' &&
          init.type !== 'BooleanLiteral' &&
          init.type !== 'NumericLiteral' &&
          init.type !== 'BigIntLiteral' &&
          (init.type !== 'TemplateLiteral' || init.expressions.length > 0) &&
          !isPossiblyLiteralEnum$1(init)
        ) {
          this.raise(TSErrors$1.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference, {
            at: init,
          })
        }
      }
      return declaration
    }
    parseStatementContent(context2, topLevel) {
      if (this.match(75) && this.isLookaheadContextual('enum')) {
        const node2 = this.startNode()
        this.expect(75)
        return this.tsParseEnumDeclaration(node2, {
          const: true,
        })
      }
      if (this.isContextual(122)) {
        return this.tsParseEnumDeclaration(this.startNode())
      }
      if (this.isContextual(125)) {
        const result = this.tsParseInterfaceDeclaration(this.startNode())
        if (result) return result
      }
      return super.parseStatementContent(context2, topLevel)
    }
    parseAccessModifier() {
      return this.tsParseModifier(['public', 'protected', 'private'])
    }
    tsHasSomeModifiers(member, modifiers) {
      return modifiers.some((modifier) => {
        if (tsIsAccessModifier$1(modifier)) {
          return member.accessibility === modifier
        }
        return !!member[modifier]
      })
    }
    tsIsStartOfStaticBlocks() {
      return this.isContextual(104) && this.lookaheadCharCode() === 123
    }
    parseClassMember(classBody2, member, state) {
      const modifiers = ['declare', 'private', 'public', 'protected', 'override', 'abstract', 'readonly', 'static']
      this.tsParseModifiers({
        modified: member,
        allowedModifiers: modifiers,
        disallowedModifiers: ['in', 'out'],
        stopOnStartOfClassStaticBlock: true,
        errorTemplate: TSErrors$1.InvalidModifierOnTypeParameterPositions,
      })
      const callParseClassMemberWithIsStatic = () => {
        if (this.tsIsStartOfStaticBlocks()) {
          this.next()
          this.next()
          if (this.tsHasSomeModifiers(member, modifiers)) {
            this.raise(TSErrors$1.StaticBlockCannotHaveModifier, {
              at: this.state.curPosition(),
            })
          }
          this.parseClassStaticBlock(classBody2, member)
        } else {
          this.parseClassMemberWithIsStatic(classBody2, member, state, !!member.static)
        }
      }
      if (member.declare) {
        this.tsInAmbientContext(callParseClassMemberWithIsStatic)
      } else {
        callParseClassMemberWithIsStatic()
      }
    }
    parseClassMemberWithIsStatic(classBody2, member, state, isStatic2) {
      const idx = this.tsTryParseIndexSignature(member)
      if (idx) {
        classBody2.body.push(idx)
        if (member.abstract) {
          this.raise(TSErrors$1.IndexSignatureHasAbstract, {
            at: member,
          })
        }
        if (member.accessibility) {
          this.raise(TSErrors$1.IndexSignatureHasAccessibility, {
            at: member,
            modifier: member.accessibility,
          })
        }
        if (member.declare) {
          this.raise(TSErrors$1.IndexSignatureHasDeclare, {
            at: member,
          })
        }
        if (member.override) {
          this.raise(TSErrors$1.IndexSignatureHasOverride, {
            at: member,
          })
        }
        return
      }
      if (!this.state.inAbstractClass && member.abstract) {
        this.raise(TSErrors$1.NonAbstractClassHasAbstractMethod, {
          at: member,
        })
      }
      if (member.override) {
        if (!state.hadSuperClass) {
          this.raise(TSErrors$1.OverrideNotInSubClass, {
            at: member,
          })
        }
      }
      super.parseClassMemberWithIsStatic(classBody2, member, state, isStatic2)
    }
    parsePostMemberNameModifiers(methodOrProp) {
      const optional = this.eat(17)
      if (optional) methodOrProp.optional = true
      if (methodOrProp.readonly && this.match(10)) {
        this.raise(TSErrors$1.ClassMethodHasReadonly, {
          at: methodOrProp,
        })
      }
      if (methodOrProp.declare && this.match(10)) {
        this.raise(TSErrors$1.ClassMethodHasDeclare, {
          at: methodOrProp,
        })
      }
    }
    parseExpressionStatement(node2, expr) {
      const decl = expr.type === 'Identifier' ? this.tsParseExpressionStatement(node2, expr) : void 0
      return decl || super.parseExpressionStatement(node2, expr)
    }
    shouldParseExportDeclaration() {
      if (this.tsIsDeclarationStart()) return true
      return super.shouldParseExportDeclaration()
    }
    parseConditional(expr, startPos, startLoc, refExpressionErrors) {
      if (!this.state.maybeInArrowParameters || !this.match(17)) {
        return super.parseConditional(expr, startPos, startLoc, refExpressionErrors)
      }
      const result = this.tryParse(() => super.parseConditional(expr, startPos, startLoc))
      if (!result.node) {
        if (result.error) {
          super.setOptionalParametersError(refExpressionErrors, result.error)
        }
        return expr
      }
      if (result.error) this.state = result.failState
      return result.node
    }
    parseParenItem(node2, startPos, startLoc) {
      node2 = super.parseParenItem(node2, startPos, startLoc)
      if (this.eat(17)) {
        node2.optional = true
        this.resetEndLocation(node2)
      }
      if (this.match(14)) {
        const typeCastNode = this.startNodeAt(startPos, startLoc)
        typeCastNode.expression = node2
        typeCastNode.typeAnnotation = this.tsParseTypeAnnotation()
        return this.finishNode(typeCastNode, 'TSTypeCastExpression')
      }
      return node2
    }
    parseExportDeclaration(node2) {
      if (!this.state.isAmbientContext && this.isContextual(121)) {
        return this.tsInAmbientContext(() => this.parseExportDeclaration(node2))
      }
      const startPos = this.state.start
      const startLoc = this.state.startLoc
      const isDeclare = this.eatContextual(121)
      if (isDeclare && (this.isContextual(121) || !this.shouldParseExportDeclaration())) {
        throw this.raise(TSErrors$1.ExpectedAmbientAfterExportDeclare, {
          at: this.state.startLoc,
        })
      }
      const isIdentifier2 = tokenIsIdentifier$1(this.state.type)
      const declaration = (isIdentifier2 && this.tsTryParseExportDeclaration()) || super.parseExportDeclaration(node2)
      if (!declaration) return null
      if (declaration.type === 'TSInterfaceDeclaration' || declaration.type === 'TSTypeAliasDeclaration' || isDeclare) {
        node2.exportKind = 'type'
      }
      if (isDeclare) {
        this.resetStartLocation(declaration, startPos, startLoc)
        declaration.declare = true
      }
      return declaration
    }
    parseClassId(node2, isStatement2, optionalId) {
      if ((!isStatement2 || optionalId) && this.isContextual(110)) {
        return
      }
      super.parseClassId(node2, isStatement2, optionalId, node2.declare ? BIND_TS_AMBIENT$1 : BIND_CLASS$1)
      const typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this))
      if (typeParameters) node2.typeParameters = typeParameters
    }
    parseClassPropertyAnnotation(node2) {
      if (!node2.optional && this.eat(35)) {
        node2.definite = true
      }
      const type = this.tsTryParseTypeAnnotation()
      if (type) node2.typeAnnotation = type
    }
    parseClassProperty(node2) {
      this.parseClassPropertyAnnotation(node2)
      if (this.state.isAmbientContext && this.match(29)) {
        this.raise(TSErrors$1.DeclareClassFieldHasInitializer, {
          at: this.state.startLoc,
        })
      }
      if (node2.abstract && this.match(29)) {
        const { key } = node2
        this.raise(TSErrors$1.AbstractPropertyHasInitializer, {
          at: this.state.startLoc,
          propertyName:
            key.type === 'Identifier' && !node2.computed ? key.name : `[${this.input.slice(key.start, key.end)}]`,
        })
      }
      return super.parseClassProperty(node2)
    }
    parseClassPrivateProperty(node2) {
      if (node2.abstract) {
        this.raise(TSErrors$1.PrivateElementHasAbstract, {
          at: node2,
        })
      }
      if (node2.accessibility) {
        this.raise(TSErrors$1.PrivateElementHasAccessibility, {
          at: node2,
          modifier: node2.accessibility,
        })
      }
      this.parseClassPropertyAnnotation(node2)
      return super.parseClassPrivateProperty(node2)
    }
    pushClassMethod(classBody2, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
      const typeParameters = this.tsTryParseTypeParameters()
      if (typeParameters && isConstructor) {
        this.raise(TSErrors$1.ConstructorHasTypeParameters, {
          at: typeParameters,
        })
      }
      const { declare = false, kind } = method
      if (declare && (kind === 'get' || kind === 'set')) {
        this.raise(TSErrors$1.DeclareAccessor, {
          at: method,
          kind,
        })
      }
      if (typeParameters) method.typeParameters = typeParameters
      super.pushClassMethod(classBody2, method, isGenerator, isAsync, isConstructor, allowsDirectSuper)
    }
    pushClassPrivateMethod(classBody2, method, isGenerator, isAsync) {
      const typeParameters = this.tsTryParseTypeParameters()
      if (typeParameters) method.typeParameters = typeParameters
      super.pushClassPrivateMethod(classBody2, method, isGenerator, isAsync)
    }
    declareClassPrivateMethodInScope(node2, kind) {
      if (node2.type === 'TSDeclareMethod') return
      if (node2.type === 'MethodDefinition' && !node2.value.body) return
      super.declareClassPrivateMethodInScope(node2, kind)
    }
    parseClassSuper(node2) {
      super.parseClassSuper(node2)
      if (node2.superClass && (this.match(47) || this.match(51))) {
        node2.superTypeParameters = this.tsParseTypeArgumentsInExpression()
      }
      if (this.eatContextual(110)) {
        node2.implements = this.tsParseHeritageClause('implements')
      }
    }
    parseObjPropValue(prop, ...args) {
      const typeParameters = this.tsTryParseTypeParameters()
      if (typeParameters) prop.typeParameters = typeParameters
      super.parseObjPropValue(prop, ...args)
    }
    parseFunctionParams(node2, allowModifiers) {
      const typeParameters = this.tsTryParseTypeParameters()
      if (typeParameters) node2.typeParameters = typeParameters
      super.parseFunctionParams(node2, allowModifiers)
    }
    parseVarId(decl, kind) {
      super.parseVarId(decl, kind)
      if (decl.id.type === 'Identifier' && !this.hasPrecedingLineBreak() && this.eat(35)) {
        decl.definite = true
      }
      const type = this.tsTryParseTypeAnnotation()
      if (type) {
        decl.id.typeAnnotation = type
        this.resetEndLocation(decl.id)
      }
    }
    parseAsyncArrowFromCallExpression(node2, call2) {
      if (this.match(14)) {
        node2.returnType = this.tsParseTypeAnnotation()
      }
      return super.parseAsyncArrowFromCallExpression(node2, call2)
    }
    parseMaybeAssign(...args) {
      var _jsx, _jsx2, _typeCast, _jsx3, _typeCast2, _jsx4, _typeCast3
      let state
      let jsx2
      let typeCast
      if (this.hasPlugin('jsx') && (this.match(138) || this.match(47))) {
        state = this.state.clone()
        jsx2 = this.tryParse(() => super.parseMaybeAssign(...args), state)
        if (!jsx2.error) return jsx2.node
        const { context: context2 } = this.state
        const currentContext = context2[context2.length - 1]
        if (currentContext === types$1.j_oTag || currentContext === types$1.j_expr) {
          context2.pop()
        }
      }
      if (!((_jsx = jsx2) != null && _jsx.error) && !this.match(47)) {
        return super.parseMaybeAssign(...args)
      }
      if (!state || state === this.state) state = this.state.clone()
      let typeParameters
      const arrow = this.tryParse((abort) => {
        var _expr$extra, _typeParameters
        typeParameters = this.tsParseTypeParameters()
        const expr = super.parseMaybeAssign(...args)
        if (
          expr.type !== 'ArrowFunctionExpression' ||
          ((_expr$extra = expr.extra) != null && _expr$extra.parenthesized)
        ) {
          abort()
        }
        if (((_typeParameters = typeParameters) == null ? void 0 : _typeParameters.params.length) !== 0) {
          this.resetStartLocationFromNode(expr, typeParameters)
        }
        expr.typeParameters = typeParameters
        return expr
      }, state)
      if (!arrow.error && !arrow.aborted) {
        if (typeParameters) this.reportReservedArrowTypeParam(typeParameters)
        return arrow.node
      }
      if (!jsx2) {
        assert$1(!this.hasPlugin('jsx'))
        typeCast = this.tryParse(() => super.parseMaybeAssign(...args), state)
        if (!typeCast.error) return typeCast.node
      }
      if ((_jsx2 = jsx2) != null && _jsx2.node) {
        this.state = jsx2.failState
        return jsx2.node
      }
      if (arrow.node) {
        this.state = arrow.failState
        if (typeParameters) this.reportReservedArrowTypeParam(typeParameters)
        return arrow.node
      }
      if ((_typeCast = typeCast) != null && _typeCast.node) {
        this.state = typeCast.failState
        return typeCast.node
      }
      if ((_jsx3 = jsx2) != null && _jsx3.thrown) throw jsx2.error
      if (arrow.thrown) throw arrow.error
      if ((_typeCast2 = typeCast) != null && _typeCast2.thrown) throw typeCast.error
      throw (
        ((_jsx4 = jsx2) == null ? void 0 : _jsx4.error) ||
        arrow.error ||
        ((_typeCast3 = typeCast) == null ? void 0 : _typeCast3.error)
      )
    }
    reportReservedArrowTypeParam(node2) {
      var _node$extra
      if (
        node2.params.length === 1 &&
        !((_node$extra = node2.extra) != null && _node$extra.trailingComma) &&
        this.getPluginOption('typescript', 'disallowAmbiguousJSXLike')
      ) {
        this.raise(TSErrors$1.ReservedArrowTypeParam, {
          at: node2,
        })
      }
    }
    parseMaybeUnary(refExpressionErrors) {
      if (!this.hasPlugin('jsx') && this.match(47)) {
        return this.tsParseTypeAssertion()
      } else {
        return super.parseMaybeUnary(refExpressionErrors)
      }
    }
    parseArrow(node2) {
      if (this.match(14)) {
        const result = this.tryParse((abort) => {
          const returnType = this.tsParseTypeOrTypePredicateAnnotation(14)
          if (this.canInsertSemicolon() || !this.match(19)) abort()
          return returnType
        })
        if (result.aborted) return
        if (!result.thrown) {
          if (result.error) this.state = result.failState
          node2.returnType = result.node
        }
      }
      return super.parseArrow(node2)
    }
    parseAssignableListItemTypes(param) {
      if (this.eat(17)) {
        if (param.type !== 'Identifier' && !this.state.isAmbientContext && !this.state.inType) {
          this.raise(TSErrors$1.PatternIsOptional, {
            at: param,
          })
        }
        param.optional = true
      }
      const type = this.tsTryParseTypeAnnotation()
      if (type) param.typeAnnotation = type
      this.resetEndLocation(param)
      return param
    }
    isAssignable(node2, isBinding2) {
      switch (node2.type) {
        case 'TSTypeCastExpression':
          return this.isAssignable(node2.expression, isBinding2)
        case 'TSParameterProperty':
          return true
        default:
          return super.isAssignable(node2, isBinding2)
      }
    }
    toAssignable(node2, isLHS = false) {
      switch (node2.type) {
        case 'ParenthesizedExpression':
          this.toAssignableParenthesizedExpression(node2, isLHS)
          break
        case 'TSAsExpression':
        case 'TSNonNullExpression':
        case 'TSTypeAssertion':
          if (isLHS) {
            this.expressionScope.recordArrowParemeterBindingError(TSErrors$1.UnexpectedTypeCastInParameter, {
              at: node2,
            })
          } else {
            this.raise(TSErrors$1.UnexpectedTypeCastInParameter, {
              at: node2,
            })
          }
          this.toAssignable(node2.expression, isLHS)
          break
        case 'AssignmentExpression':
          if (!isLHS && node2.left.type === 'TSTypeCastExpression') {
            node2.left = this.typeCastToParameter(node2.left)
          }
        default:
          super.toAssignable(node2, isLHS)
      }
    }
    toAssignableParenthesizedExpression(node2, isLHS) {
      switch (node2.expression.type) {
        case 'TSAsExpression':
        case 'TSNonNullExpression':
        case 'TSTypeAssertion':
        case 'ParenthesizedExpression':
          this.toAssignable(node2.expression, isLHS)
          break
        default:
          super.toAssignable(node2, isLHS)
      }
    }
    checkToRestConversion(node2, allowPattern) {
      switch (node2.type) {
        case 'TSAsExpression':
        case 'TSTypeAssertion':
        case 'TSNonNullExpression':
          this.checkToRestConversion(node2.expression, false)
          break
        default:
          super.checkToRestConversion(node2, allowPattern)
      }
    }
    isValidLVal(type, isUnparenthesizedInAssign, binding2) {
      return (
        getOwn$1$1(
          {
            TSTypeCastExpression: true,
            TSParameterProperty: 'parameter',
            TSNonNullExpression: 'expression',
            TSAsExpression: (binding2 !== BIND_NONE$1 || !isUnparenthesizedInAssign) && ['expression', true],
            TSTypeAssertion: (binding2 !== BIND_NONE$1 || !isUnparenthesizedInAssign) && ['expression', true],
          },
          type
        ) || super.isValidLVal(type, isUnparenthesizedInAssign, binding2)
      )
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 78:
          return this.parseIdentifier(true)
        default:
          return super.parseBindingAtom()
      }
    }
    parseMaybeDecoratorArguments(expr) {
      if (this.match(47) || this.match(51)) {
        const typeArguments = this.tsParseTypeArgumentsInExpression()
        if (this.match(10)) {
          const call2 = super.parseMaybeDecoratorArguments(expr)
          call2.typeParameters = typeArguments
          return call2
        }
        this.unexpected(null, 10)
      }
      return super.parseMaybeDecoratorArguments(expr)
    }
    checkCommaAfterRest(close) {
      if (this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === close) {
        this.next()
        return false
      } else {
        return super.checkCommaAfterRest(close)
      }
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod()
    }
    isClassProperty() {
      return this.match(35) || this.match(14) || super.isClassProperty()
    }
    parseMaybeDefault(...args) {
      const node2 = super.parseMaybeDefault(...args)
      if (
        node2.type === 'AssignmentPattern' &&
        node2.typeAnnotation &&
        node2.right.start < node2.typeAnnotation.start
      ) {
        this.raise(TSErrors$1.TypeAnnotationAfterAssign, {
          at: node2.typeAnnotation,
        })
      }
      return node2
    }
    getTokenFromCode(code2) {
      if (this.state.inType) {
        if (code2 === 62) {
          return this.finishOp(48, 1)
        }
        if (code2 === 60) {
          return this.finishOp(47, 1)
        }
      }
      return super.getTokenFromCode(code2)
    }
    reScan_lt_gt() {
      const { type } = this.state
      if (type === 47) {
        this.state.pos -= 1
        this.readToken_lt()
      } else if (type === 48) {
        this.state.pos -= 1
        this.readToken_gt()
      }
    }
    reScan_lt() {
      const { type } = this.state
      if (type === 51) {
        this.state.pos -= 2
        this.finishOp(47, 1)
        return 47
      }
      return type
    }
    toAssignableList(exprList) {
      for (let i = 0; i < exprList.length; i++) {
        const expr = exprList[i]
        if ((expr == null ? void 0 : expr.type) === 'TSTypeCastExpression') {
          exprList[i] = this.typeCastToParameter(expr)
        }
      }
      super.toAssignableList(...arguments)
    }
    typeCastToParameter(node2) {
      node2.expression.typeAnnotation = node2.typeAnnotation
      this.resetEndLocation(node2.expression, node2.typeAnnotation.loc.end)
      return node2.expression
    }
    shouldParseArrow(params) {
      if (this.match(14)) {
        return params.every((expr) => this.isAssignable(expr, true))
      }
      return super.shouldParseArrow(params)
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow()
    }
    canHaveLeadingDecorator() {
      return super.canHaveLeadingDecorator() || this.isAbstractClass()
    }
    jsxParseOpeningElementAfterName(node2) {
      if (this.match(47) || this.match(51)) {
        const typeArguments = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression())
        if (typeArguments) node2.typeParameters = typeArguments
      }
      return super.jsxParseOpeningElementAfterName(node2)
    }
    getGetterSetterExpectedParamCount(method) {
      const baseCount = super.getGetterSetterExpectedParamCount(method)
      const params = this.getObjectOrClassMethodParams(method)
      const firstParam = params[0]
      const hasContextParam = firstParam && this.isThisParam(firstParam)
      return hasContextParam ? baseCount + 1 : baseCount
    }
    parseCatchClauseParam() {
      const param = super.parseCatchClauseParam()
      const type = this.tsTryParseTypeAnnotation()
      if (type) {
        param.typeAnnotation = type
        this.resetEndLocation(param)
      }
      return param
    }
    tsInAmbientContext(cb) {
      const oldIsAmbientContext = this.state.isAmbientContext
      this.state.isAmbientContext = true
      try {
        return cb()
      } finally {
        this.state.isAmbientContext = oldIsAmbientContext
      }
    }
    parseClass(node2, ...args) {
      const oldInAbstractClass = this.state.inAbstractClass
      this.state.inAbstractClass = !!node2.abstract
      try {
        return super.parseClass(node2, ...args)
      } finally {
        this.state.inAbstractClass = oldInAbstractClass
      }
    }
    tsParseAbstractDeclaration(node2) {
      if (this.match(80)) {
        node2.abstract = true
        return this.parseClass(node2, true, false)
      } else if (this.isContextual(125)) {
        if (!this.hasFollowingLineBreak()) {
          node2.abstract = true
          this.raise(TSErrors$1.NonClassMethodPropertyHasAbstractModifer, {
            at: node2,
          })
          return this.tsParseInterfaceDeclaration(node2)
        }
      } else {
        this.unexpected(null, 80)
      }
    }
    parseMethod(...args) {
      const method = super.parseMethod(...args)
      if (method.abstract) {
        const hasBody = this.hasPlugin('estree') ? !!method.value.body : !!method.body
        if (hasBody) {
          const { key } = method
          this.raise(TSErrors$1.AbstractMethodHasImplementation, {
            at: method,
            methodName:
              key.type === 'Identifier' && !method.computed ? key.name : `[${this.input.slice(key.start, key.end)}]`,
          })
        }
      }
      return method
    }
    tsParseTypeParameterName() {
      const typeName = this.parseIdentifier()
      return typeName.name
    }
    shouldParseAsAmbientContext() {
      return !!this.getPluginOption('typescript', 'dts')
    }
    parse() {
      if (this.shouldParseAsAmbientContext()) {
        this.state.isAmbientContext = true
      }
      return super.parse()
    }
    getExpression() {
      if (this.shouldParseAsAmbientContext()) {
        this.state.isAmbientContext = true
      }
      return super.getExpression()
    }
    parseExportSpecifier(node2, isString2, isInTypeExport, isMaybeTypeOnly) {
      if (!isString2 && isMaybeTypeOnly) {
        this.parseTypeOnlyImportExportSpecifier(node2, false, isInTypeExport)
        return this.finishNode(node2, 'ExportSpecifier')
      }
      node2.exportKind = 'value'
      return super.parseExportSpecifier(node2, isString2, isInTypeExport, isMaybeTypeOnly)
    }
    parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly) {
      if (!importedIsString && isMaybeTypeOnly) {
        this.parseTypeOnlyImportExportSpecifier(specifier, true, isInTypeOnlyImport)
        return this.finishNode(specifier, 'ImportSpecifier')
      }
      specifier.importKind = 'value'
      return super.parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly)
    }
    parseTypeOnlyImportExportSpecifier(node2, isImport2, isInTypeOnlyImportExport) {
      const leftOfAsKey = isImport2 ? 'imported' : 'local'
      const rightOfAsKey = isImport2 ? 'local' : 'exported'
      let leftOfAs = node2[leftOfAsKey]
      let rightOfAs
      let hasTypeSpecifier = false
      let canParseAsKeyword = true
      const loc = leftOfAs.loc.start
      if (this.isContextual(93)) {
        const firstAs = this.parseIdentifier()
        if (this.isContextual(93)) {
          const secondAs = this.parseIdentifier()
          if (tokenIsKeywordOrIdentifier$1(this.state.type)) {
            hasTypeSpecifier = true
            leftOfAs = firstAs
            rightOfAs = isImport2 ? this.parseIdentifier() : this.parseModuleExportName()
            canParseAsKeyword = false
          } else {
            rightOfAs = secondAs
            canParseAsKeyword = false
          }
        } else if (tokenIsKeywordOrIdentifier$1(this.state.type)) {
          canParseAsKeyword = false
          rightOfAs = isImport2 ? this.parseIdentifier() : this.parseModuleExportName()
        } else {
          hasTypeSpecifier = true
          leftOfAs = firstAs
        }
      } else if (tokenIsKeywordOrIdentifier$1(this.state.type)) {
        hasTypeSpecifier = true
        if (isImport2) {
          leftOfAs = this.parseIdentifier(true)
          if (!this.isContextual(93)) {
            this.checkReservedWord(leftOfAs.name, leftOfAs.loc.start, true, true)
          }
        } else {
          leftOfAs = this.parseModuleExportName()
        }
      }
      if (hasTypeSpecifier && isInTypeOnlyImportExport) {
        this.raise(
          isImport2 ? TSErrors$1.TypeModifierIsUsedInTypeImports : TSErrors$1.TypeModifierIsUsedInTypeExports,
          {
            at: loc,
          }
        )
      }
      node2[leftOfAsKey] = leftOfAs
      node2[rightOfAsKey] = rightOfAs
      const kindKey = isImport2 ? 'importKind' : 'exportKind'
      node2[kindKey] = hasTypeSpecifier ? 'type' : 'value'
      if (canParseAsKeyword && this.eatContextual(93)) {
        node2[rightOfAsKey] = isImport2 ? this.parseIdentifier() : this.parseModuleExportName()
      }
      if (!node2[rightOfAsKey]) {
        node2[rightOfAsKey] = cloneIdentifier$1(node2[leftOfAsKey])
      }
      if (isImport2) {
        this.checkIdentifier(node2[rightOfAsKey], BIND_LEXICAL$1)
      }
    }
  }
function isPossiblyLiteralEnum$1(expression2) {
  if (expression2.type !== 'MemberExpression') return false
  const { computed: computed2, property } = expression2
  if (
    computed2 &&
    property.type !== 'StringLiteral' &&
    (property.type !== 'TemplateLiteral' || property.expressions.length > 0)
  ) {
    return false
  }
  return isUncomputedMemberExpressionChain$1(expression2.object)
}
function isUncomputedMemberExpressionChain$1(expression2) {
  if (expression2.type === 'Identifier') return true
  if (expression2.type !== 'MemberExpression') return false
  if (expression2.computed) return false
  return isUncomputedMemberExpressionChain$1(expression2.object)
}
const PlaceholderErrors$1 = ParseErrorEnum$1`placeholders`((_2) => ({
  ClassNameIsRequired: _2('A class name is required.'),
  UnexpectedSpace: _2('Unexpected space in placeholder.'),
}))
var placeholders$1 = (superClass) =>
  class extends superClass {
    parsePlaceholder(expectedNode) {
      if (this.match(140)) {
        const node2 = this.startNode()
        this.next()
        this.assertNoSpace()
        node2.name = super.parseIdentifier(true)
        this.assertNoSpace()
        this.expect(140)
        return this.finishPlaceholder(node2, expectedNode)
      }
    }
    finishPlaceholder(node2, expectedNode) {
      const isFinished = !!(node2.expectedNode && node2.type === 'Placeholder')
      node2.expectedNode = expectedNode
      return isFinished ? node2 : this.finishNode(node2, 'Placeholder')
    }
    getTokenFromCode(code2) {
      if (code2 === 37 && this.input.charCodeAt(this.state.pos + 1) === 37) {
        return this.finishOp(140, 2)
      }
      return super.getTokenFromCode(...arguments)
    }
    parseExprAtom() {
      return this.parsePlaceholder('Expression') || super.parseExprAtom(...arguments)
    }
    parseIdentifier() {
      return this.parsePlaceholder('Identifier') || super.parseIdentifier(...arguments)
    }
    checkReservedWord(word) {
      if (word !== void 0) super.checkReservedWord(...arguments)
    }
    parseBindingAtom() {
      return this.parsePlaceholder('Pattern') || super.parseBindingAtom(...arguments)
    }
    isValidLVal(type, ...rest) {
      return type === 'Placeholder' || super.isValidLVal(type, ...rest)
    }
    toAssignable(node2) {
      if (node2 && node2.type === 'Placeholder' && node2.expectedNode === 'Expression') {
        node2.expectedNode = 'Pattern'
      } else {
        super.toAssignable(...arguments)
      }
    }
    isLet(context2) {
      if (super.isLet(context2)) {
        return true
      }
      if (!this.isContextual(99)) {
        return false
      }
      if (context2) return false
      const nextToken = this.lookahead()
      if (nextToken.type === 140) {
        return true
      }
      return false
    }
    verifyBreakContinue(node2) {
      if (node2.label && node2.label.type === 'Placeholder') return
      super.verifyBreakContinue(...arguments)
    }
    parseExpressionStatement(node2, expr) {
      if (expr.type !== 'Placeholder' || (expr.extra && expr.extra.parenthesized)) {
        return super.parseExpressionStatement(...arguments)
      }
      if (this.match(14)) {
        const stmt = node2
        stmt.label = this.finishPlaceholder(expr, 'Identifier')
        this.next()
        stmt.body = this.parseStatement('label')
        return this.finishNode(stmt, 'LabeledStatement')
      }
      this.semicolon()
      node2.name = expr.name
      return this.finishPlaceholder(node2, 'Statement')
    }
    parseBlock() {
      return this.parsePlaceholder('BlockStatement') || super.parseBlock(...arguments)
    }
    parseFunctionId() {
      return this.parsePlaceholder('Identifier') || super.parseFunctionId(...arguments)
    }
    parseClass(node2, isStatement2, optionalId) {
      const type = isStatement2 ? 'ClassDeclaration' : 'ClassExpression'
      this.next()
      this.takeDecorators(node2)
      const oldStrict = this.state.strict
      const placeholder2 = this.parsePlaceholder('Identifier')
      if (placeholder2) {
        if (this.match(81) || this.match(140) || this.match(5)) {
          node2.id = placeholder2
        } else if (optionalId || !isStatement2) {
          node2.id = null
          node2.body = this.finishPlaceholder(placeholder2, 'ClassBody')
          return this.finishNode(node2, type)
        } else {
          throw this.raise(PlaceholderErrors$1.ClassNameIsRequired, {
            at: this.state.startLoc,
          })
        }
      } else {
        this.parseClassId(node2, isStatement2, optionalId)
      }
      this.parseClassSuper(node2)
      node2.body = this.parsePlaceholder('ClassBody') || this.parseClassBody(!!node2.superClass, oldStrict)
      return this.finishNode(node2, type)
    }
    parseExport(node2) {
      const placeholder2 = this.parsePlaceholder('Identifier')
      if (!placeholder2) return super.parseExport(...arguments)
      if (!this.isContextual(97) && !this.match(12)) {
        node2.specifiers = []
        node2.source = null
        node2.declaration = this.finishPlaceholder(placeholder2, 'Declaration')
        return this.finishNode(node2, 'ExportNamedDeclaration')
      }
      this.expectPlugin('exportDefaultFrom')
      const specifier = this.startNode()
      specifier.exported = placeholder2
      node2.specifiers = [this.finishNode(specifier, 'ExportDefaultSpecifier')]
      return super.parseExport(node2)
    }
    isExportDefaultSpecifier() {
      if (this.match(65)) {
        const next = this.nextTokenStart()
        if (this.isUnparsedContextual(next, 'from')) {
          if (this.input.startsWith(tokenLabelName$1(140), this.nextTokenStartSince(next + 4))) {
            return true
          }
        }
      }
      return super.isExportDefaultSpecifier()
    }
    maybeParseExportDefaultSpecifier(node2) {
      if (node2.specifiers && node2.specifiers.length > 0) {
        return true
      }
      return super.maybeParseExportDefaultSpecifier(...arguments)
    }
    checkExport(node2) {
      const { specifiers } = node2
      if (specifiers != null && specifiers.length) {
        node2.specifiers = specifiers.filter((node3) => node3.exported.type === 'Placeholder')
      }
      super.checkExport(node2)
      node2.specifiers = specifiers
    }
    parseImport(node2) {
      const placeholder2 = this.parsePlaceholder('Identifier')
      if (!placeholder2) return super.parseImport(...arguments)
      node2.specifiers = []
      if (!this.isContextual(97) && !this.match(12)) {
        node2.source = this.finishPlaceholder(placeholder2, 'StringLiteral')
        this.semicolon()
        return this.finishNode(node2, 'ImportDeclaration')
      }
      const specifier = this.startNodeAtNode(placeholder2)
      specifier.local = placeholder2
      this.finishNode(specifier, 'ImportDefaultSpecifier')
      node2.specifiers.push(specifier)
      if (this.eat(12)) {
        const hasStarImport = this.maybeParseStarImportSpecifier(node2)
        if (!hasStarImport) this.parseNamedImportSpecifiers(node2)
      }
      this.expectContextual(97)
      node2.source = this.parseImportSource()
      this.semicolon()
      return this.finishNode(node2, 'ImportDeclaration')
    }
    parseImportSource() {
      return this.parsePlaceholder('StringLiteral') || super.parseImportSource(...arguments)
    }
    assertNoSpace() {
      if (this.state.start > this.state.lastTokEndLoc.index) {
        this.raise(PlaceholderErrors$1.UnexpectedSpace, {
          at: this.state.lastTokEndLoc,
        })
      }
    }
  }
var v8intrinsic$1 = (superClass) =>
  class extends superClass {
    parseV8Intrinsic() {
      if (this.match(54)) {
        const v8IntrinsicStartLoc = this.state.startLoc
        const node2 = this.startNode()
        this.next()
        if (tokenIsIdentifier$1(this.state.type)) {
          const name = this.parseIdentifierName(this.state.start)
          const identifier2 = this.createIdentifier(node2, name)
          identifier2.type = 'V8IntrinsicIdentifier'
          if (this.match(10)) {
            return identifier2
          }
        }
        this.unexpected(v8IntrinsicStartLoc)
      }
    }
    parseExprAtom() {
      return this.parseV8Intrinsic() || super.parseExprAtom(...arguments)
    }
  }
function hasPlugin$1(plugins, expectedConfig) {
  const [expectedName, expectedOptions] = typeof expectedConfig === 'string' ? [expectedConfig, {}] : expectedConfig
  const expectedKeys = Object.keys(expectedOptions)
  const expectedOptionsIsEmpty = expectedKeys.length === 0
  return plugins.some((p) => {
    if (typeof p === 'string') {
      return expectedOptionsIsEmpty && p === expectedName
    } else {
      const [pluginName, pluginOptions] = p
      if (pluginName !== expectedName) {
        return false
      }
      for (const key of expectedKeys) {
        if (pluginOptions[key] !== expectedOptions[key]) {
          return false
        }
      }
      return true
    }
  })
}
function getPluginOption$1(plugins, name, option) {
  const plugin = plugins.find((plugin2) => {
    if (Array.isArray(plugin2)) {
      return plugin2[0] === name
    } else {
      return plugin2 === name
    }
  })
  if (plugin && Array.isArray(plugin)) {
    return plugin[1][option]
  }
  return null
}
const PIPELINE_PROPOSALS$1 = ['minimal', 'fsharp', 'hack', 'smart']
const TOPIC_TOKENS$1 = ['^^', '@@', '^', '%', '#']
const RECORD_AND_TUPLE_SYNTAX_TYPES$1 = ['hash', 'bar']
function validatePlugins$1(plugins) {
  if (hasPlugin$1(plugins, 'decorators')) {
    if (hasPlugin$1(plugins, 'decorators-legacy')) {
      throw new Error('Cannot use the decorators and decorators-legacy plugin together')
    }
    const decoratorsBeforeExport = getPluginOption$1(plugins, 'decorators', 'decoratorsBeforeExport')
    if (decoratorsBeforeExport == null) {
      throw new Error(
        "The 'decorators' plugin requires a 'decoratorsBeforeExport' option, whose value must be a boolean. If you are migrating from Babylon/Babel 6 or want to use the old decorators proposal, you should use the 'decorators-legacy' plugin instead of 'decorators'."
      )
    } else if (typeof decoratorsBeforeExport !== 'boolean') {
      throw new Error("'decoratorsBeforeExport' must be a boolean.")
    }
  }
  if (hasPlugin$1(plugins, 'flow') && hasPlugin$1(plugins, 'typescript')) {
    throw new Error('Cannot combine flow and typescript plugins.')
  }
  if (hasPlugin$1(plugins, 'placeholders') && hasPlugin$1(plugins, 'v8intrinsic')) {
    throw new Error('Cannot combine placeholders and v8intrinsic plugins.')
  }
  if (hasPlugin$1(plugins, 'pipelineOperator')) {
    const proposal = getPluginOption$1(plugins, 'pipelineOperator', 'proposal')
    if (!PIPELINE_PROPOSALS$1.includes(proposal)) {
      const proposalList = PIPELINE_PROPOSALS$1.map((p) => `"${p}"`).join(', ')
      throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${proposalList}.`)
    }
    const tupleSyntaxIsHash = hasPlugin$1(plugins, [
      'recordAndTuple',
      {
        syntaxType: 'hash',
      },
    ])
    if (proposal === 'hack') {
      if (hasPlugin$1(plugins, 'placeholders')) {
        throw new Error('Cannot combine placeholders plugin and Hack-style pipes.')
      }
      if (hasPlugin$1(plugins, 'v8intrinsic')) {
        throw new Error('Cannot combine v8intrinsic plugin and Hack-style pipes.')
      }
      const topicToken = getPluginOption$1(plugins, 'pipelineOperator', 'topicToken')
      if (!TOPIC_TOKENS$1.includes(topicToken)) {
        const tokenList = TOPIC_TOKENS$1.map((t2) => `"${t2}"`).join(', ')
        throw new Error(
          `"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${tokenList}.`
        )
      }
      if (topicToken === '#' && tupleSyntaxIsHash) {
        throw new Error(
          'Plugin conflict between `["pipelineOperator", { proposal: "hack", topicToken: "#" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.'
        )
      }
    } else if (proposal === 'smart' && tupleSyntaxIsHash) {
      throw new Error(
        'Plugin conflict between `["pipelineOperator", { proposal: "smart" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.'
      )
    }
  }
  if (hasPlugin$1(plugins, 'moduleAttributes')) {
    {
      if (hasPlugin$1(plugins, 'importAssertions')) {
        throw new Error('Cannot combine importAssertions and moduleAttributes plugins.')
      }
      const moduleAttributesVersionPluginOption = getPluginOption$1(plugins, 'moduleAttributes', 'version')
      if (moduleAttributesVersionPluginOption !== 'may-2020') {
        throw new Error(
          "The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'."
        )
      }
    }
  }
  if (
    hasPlugin$1(plugins, 'recordAndTuple') &&
    !RECORD_AND_TUPLE_SYNTAX_TYPES$1.includes(getPluginOption$1(plugins, 'recordAndTuple', 'syntaxType'))
  ) {
    throw new Error(
      "'recordAndTuple' requires 'syntaxType' option whose value should be one of: " +
        RECORD_AND_TUPLE_SYNTAX_TYPES$1.map((p) => `'${p}'`).join(', ')
    )
  }
  if (hasPlugin$1(plugins, 'asyncDoExpressions') && !hasPlugin$1(plugins, 'doExpressions')) {
    const error = new Error(
      "'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins."
    )
    error.missingPlugins = 'doExpressions'
    throw error
  }
}
const mixinPlugins$1 = {
  estree: estree$1,
  jsx: jsx$1,
  flow: flow$1,
  typescript: typescript$1,
  v8intrinsic: v8intrinsic$1,
  placeholders: placeholders$1,
}
const mixinPluginNames$1 = Object.keys(mixinPlugins$1)
const defaultOptions$1 = {
  sourceType: 'script',
  sourceFilename: void 0,
  startColumn: 0,
  startLine: 1,
  allowAwaitOutsideFunction: false,
  allowReturnOutsideFunction: false,
  allowImportExportEverywhere: false,
  allowSuperOutsideMethod: false,
  allowUndeclaredExports: false,
  plugins: [],
  strictMode: null,
  ranges: false,
  tokens: false,
  createParenthesizedExpressions: false,
  errorRecovery: false,
  attachComment: true,
}
function getOptions$1(opts) {
  const options2 = {}
  for (const key of Object.keys(defaultOptions$1)) {
    options2[key] = opts && opts[key] != null ? opts[key] : defaultOptions$1[key]
  }
  return options2
}
const getOwn$2 = (object2, key) => Object.hasOwnProperty.call(object2, key) && object2[key]
const unwrapParenthesizedExpression$1 = (node2) => {
  return node2.type === 'ParenthesizedExpression' ? unwrapParenthesizedExpression$1(node2.expression) : node2
}
class LValParser$1 extends NodeUtils$1 {
  toAssignable(node2, isLHS = false) {
    var _node$extra, _node$extra3
    let parenthesized = void 0
    if (
      node2.type === 'ParenthesizedExpression' ||
      ((_node$extra = node2.extra) != null && _node$extra.parenthesized)
    ) {
      parenthesized = unwrapParenthesizedExpression$1(node2)
      if (isLHS) {
        if (parenthesized.type === 'Identifier') {
          this.expressionScope.recordArrowParemeterBindingError(Errors$1.InvalidParenthesizedAssignment, {
            at: node2,
          })
        } else if (parenthesized.type !== 'MemberExpression') {
          this.raise(Errors$1.InvalidParenthesizedAssignment, {
            at: node2,
          })
        }
      } else {
        this.raise(Errors$1.InvalidParenthesizedAssignment, {
          at: node2,
        })
      }
    }
    switch (node2.type) {
      case 'Identifier':
      case 'ObjectPattern':
      case 'ArrayPattern':
      case 'AssignmentPattern':
      case 'RestElement':
        break
      case 'ObjectExpression':
        node2.type = 'ObjectPattern'
        for (let i = 0, length = node2.properties.length, last2 = length - 1; i < length; i++) {
          var _node$extra2
          const prop = node2.properties[i]
          const isLast = i === last2
          this.toAssignableObjectExpressionProp(prop, isLast, isLHS)
          if (
            isLast &&
            prop.type === 'RestElement' &&
            (_node$extra2 = node2.extra) != null &&
            _node$extra2.trailingCommaLoc
          ) {
            this.raise(Errors$1.RestTrailingComma, {
              at: node2.extra.trailingCommaLoc,
            })
          }
        }
        break
      case 'ObjectProperty': {
        const { key, value } = node2
        if (this.isPrivateName(key)) {
          this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start)
        }
        this.toAssignable(value, isLHS)
        break
      }
      case 'SpreadElement': {
        throw new Error(
          "Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller."
        )
      }
      case 'ArrayExpression':
        node2.type = 'ArrayPattern'
        this.toAssignableList(
          node2.elements,
          (_node$extra3 = node2.extra) == null ? void 0 : _node$extra3.trailingCommaLoc,
          isLHS
        )
        break
      case 'AssignmentExpression':
        if (node2.operator !== '=') {
          this.raise(Errors$1.MissingEqInAssignment, {
            at: node2.left.loc.end,
          })
        }
        node2.type = 'AssignmentPattern'
        delete node2.operator
        this.toAssignable(node2.left, isLHS)
        break
      case 'ParenthesizedExpression':
        this.toAssignable(parenthesized, isLHS)
        break
    }
  }
  toAssignableObjectExpressionProp(prop, isLast, isLHS) {
    if (prop.type === 'ObjectMethod') {
      this.raise(prop.kind === 'get' || prop.kind === 'set' ? Errors$1.PatternHasAccessor : Errors$1.PatternHasMethod, {
        at: prop.key,
      })
    } else if (prop.type === 'SpreadElement') {
      prop.type = 'RestElement'
      const arg = prop.argument
      this.checkToRestConversion(arg, false)
      this.toAssignable(arg, isLHS)
      if (!isLast) {
        this.raise(Errors$1.RestTrailingComma, {
          at: prop,
        })
      }
    } else {
      this.toAssignable(prop, isLHS)
    }
  }
  toAssignableList(exprList, trailingCommaLoc, isLHS) {
    const end = exprList.length - 1
    for (let i = 0; i <= end; i++) {
      const elt = exprList[i]
      if (!elt) continue
      if (elt.type === 'SpreadElement') {
        elt.type = 'RestElement'
        const arg = elt.argument
        this.checkToRestConversion(arg, true)
        this.toAssignable(arg, isLHS)
      } else {
        this.toAssignable(elt, isLHS)
      }
      if (elt.type === 'RestElement') {
        if (i < end) {
          this.raise(Errors$1.RestTrailingComma, {
            at: elt,
          })
        } else if (trailingCommaLoc) {
          this.raise(Errors$1.RestTrailingComma, {
            at: trailingCommaLoc,
          })
        }
      }
    }
  }
  isAssignable(node2, isBinding2) {
    switch (node2.type) {
      case 'Identifier':
      case 'ObjectPattern':
      case 'ArrayPattern':
      case 'AssignmentPattern':
      case 'RestElement':
        return true
      case 'ObjectExpression': {
        const last2 = node2.properties.length - 1
        return node2.properties.every((prop, i) => {
          return (
            prop.type !== 'ObjectMethod' && (i === last2 || prop.type !== 'SpreadElement') && this.isAssignable(prop)
          )
        })
      }
      case 'ObjectProperty':
        return this.isAssignable(node2.value)
      case 'SpreadElement':
        return this.isAssignable(node2.argument)
      case 'ArrayExpression':
        return node2.elements.every((element) => element === null || this.isAssignable(element))
      case 'AssignmentExpression':
        return node2.operator === '='
      case 'ParenthesizedExpression':
        return this.isAssignable(node2.expression)
      case 'MemberExpression':
      case 'OptionalMemberExpression':
        return !isBinding2
      default:
        return false
    }
  }
  toReferencedList(exprList, isParenthesizedExpr) {
    return exprList
  }
  toReferencedListDeep(exprList, isParenthesizedExpr) {
    this.toReferencedList(exprList, isParenthesizedExpr)
    for (const expr of exprList) {
      if ((expr == null ? void 0 : expr.type) === 'ArrayExpression') {
        this.toReferencedListDeep(expr.elements)
      }
    }
  }
  parseSpread(refExpressionErrors, refNeedsArrowPos) {
    const node2 = this.startNode()
    this.next()
    node2.argument = this.parseMaybeAssignAllowIn(refExpressionErrors, void 0, refNeedsArrowPos)
    return this.finishNode(node2, 'SpreadElement')
  }
  parseRestBinding() {
    const node2 = this.startNode()
    this.next()
    node2.argument = this.parseBindingAtom()
    return this.finishNode(node2, 'RestElement')
  }
  parseBindingAtom() {
    switch (this.state.type) {
      case 0: {
        const node2 = this.startNode()
        this.next()
        node2.elements = this.parseBindingList(3, 93, true)
        return this.finishNode(node2, 'ArrayPattern')
      }
      case 5:
        return this.parseObjectLike(8, true)
    }
    return this.parseIdentifier()
  }
  parseBindingList(close, closeCharCode, allowEmpty, allowModifiers) {
    const elts = []
    let first = true
    while (!this.eat(close)) {
      if (first) {
        first = false
      } else {
        this.expect(12)
      }
      if (allowEmpty && this.match(12)) {
        elts.push(null)
      } else if (this.eat(close)) {
        break
      } else if (this.match(21)) {
        elts.push(this.parseAssignableListItemTypes(this.parseRestBinding()))
        if (!this.checkCommaAfterRest(closeCharCode)) {
          this.expect(close)
          break
        }
      } else {
        const decorators = []
        if (this.match(26) && this.hasPlugin('decorators')) {
          this.raise(Errors$1.UnsupportedParameterDecorator, {
            at: this.state.startLoc,
          })
        }
        while (this.match(26)) {
          decorators.push(this.parseDecorator())
        }
        elts.push(this.parseAssignableListItem(allowModifiers, decorators))
      }
    }
    return elts
  }
  parseBindingRestProperty(prop) {
    this.next()
    prop.argument = this.parseIdentifier()
    this.checkCommaAfterRest(125)
    return this.finishNode(prop, 'RestElement')
  }
  parseBindingProperty() {
    const prop = this.startNode()
    const { type, start: startPos, startLoc } = this.state
    if (type === 21) {
      return this.parseBindingRestProperty(prop)
    } else if (type === 134) {
      this.expectPlugin('destructuringPrivate', startLoc)
      this.classScope.usePrivateName(this.state.value, startLoc)
      prop.key = this.parsePrivateName()
    } else {
      this.parsePropertyName(prop)
    }
    prop.method = false
    this.parseObjPropValue(prop, startPos, startLoc, false, false, true, false)
    return prop
  }
  parseAssignableListItem(allowModifiers, decorators) {
    const left = this.parseMaybeDefault()
    this.parseAssignableListItemTypes(left)
    const elt = this.parseMaybeDefault(left.start, left.loc.start, left)
    if (decorators.length) {
      left.decorators = decorators
    }
    return elt
  }
  parseAssignableListItemTypes(param) {
    return param
  }
  parseMaybeDefault(startPos, startLoc, left) {
    var _startLoc, _startPos, _left
    startLoc = (_startLoc = startLoc) != null ? _startLoc : this.state.startLoc
    startPos = (_startPos = startPos) != null ? _startPos : this.state.start
    left = (_left = left) != null ? _left : this.parseBindingAtom()
    if (!this.eat(29)) return left
    const node2 = this.startNodeAt(startPos, startLoc)
    node2.left = left
    node2.right = this.parseMaybeAssignAllowIn()
    return this.finishNode(node2, 'AssignmentPattern')
  }
  isValidLVal(type, isUnparenthesizedInAssign, binding2) {
    return getOwn$2(
      {
        AssignmentPattern: 'left',
        RestElement: 'argument',
        ObjectProperty: 'value',
        ParenthesizedExpression: 'expression',
        ArrayPattern: 'elements',
        ObjectPattern: 'properties',
      },
      type
    )
  }
  checkLVal(
    expression2,
    {
      in: ancestor,
      binding: binding2 = BIND_NONE$1,
      checkClashes = false,
      strictModeChanged = false,
      allowingSloppyLetBinding = !(binding2 & BIND_SCOPE_LEXICAL$1),
      hasParenthesizedAncestor = false,
    }
  ) {
    var _expression$extra
    const type = expression2.type
    if (this.isObjectMethod(expression2)) return
    if (type === 'MemberExpression') {
      if (binding2 !== BIND_NONE$1) {
        this.raise(Errors$1.InvalidPropertyBindingPattern, {
          at: expression2,
        })
      }
      return
    }
    if (expression2.type === 'Identifier') {
      this.checkIdentifier(expression2, binding2, strictModeChanged, allowingSloppyLetBinding)
      const { name } = expression2
      if (checkClashes) {
        if (checkClashes.has(name)) {
          this.raise(Errors$1.ParamDupe, {
            at: expression2,
          })
        } else {
          checkClashes.add(name)
        }
      }
      return
    }
    const validity = this.isValidLVal(
      expression2.type,
      !(
        hasParenthesizedAncestor ||
        ((_expression$extra = expression2.extra) != null && _expression$extra.parenthesized)
      ) && ancestor.type === 'AssignmentExpression',
      binding2
    )
    if (validity === true) return
    if (validity === false) {
      const ParseErrorClass = binding2 === BIND_NONE$1 ? Errors$1.InvalidLhs : Errors$1.InvalidLhsBinding
      this.raise(ParseErrorClass, {
        at: expression2,
        ancestor:
          ancestor.type === 'UpdateExpression'
            ? {
                type: 'UpdateExpression',
                prefix: ancestor.prefix,
              }
            : {
                type: ancestor.type,
              },
      })
      return
    }
    const [key, isParenthesizedExpression2] = Array.isArray(validity)
      ? validity
      : [validity, type === 'ParenthesizedExpression']
    const nextAncestor =
      expression2.type === 'ArrayPattern' ||
      expression2.type === 'ObjectPattern' ||
      expression2.type === 'ParenthesizedExpression'
        ? expression2
        : ancestor
    for (const child of [].concat(expression2[key])) {
      if (child) {
        this.checkLVal(child, {
          in: nextAncestor,
          binding: binding2,
          checkClashes,
          allowingSloppyLetBinding,
          strictModeChanged,
          hasParenthesizedAncestor: isParenthesizedExpression2,
        })
      }
    }
  }
  checkIdentifier(at, bindingType, strictModeChanged = false, allowLetBinding = !(bindingType & BIND_SCOPE_LEXICAL$1)) {
    if (
      this.state.strict &&
      (strictModeChanged ? isStrictBindReservedWord$1(at.name, this.inModule) : isStrictBindOnlyReservedWord$1(at.name))
    ) {
      if (bindingType === BIND_NONE$1) {
        this.raise(Errors$1.StrictEvalArguments, {
          at,
          referenceName: at.name,
        })
      } else {
        this.raise(Errors$1.StrictEvalArgumentsBinding, {
          at,
          bindingName: at.name,
        })
      }
    }
    if (!allowLetBinding && at.name === 'let') {
      this.raise(Errors$1.LetInLexicalBinding, {
        at,
      })
    }
    if (!(bindingType & BIND_NONE$1)) {
      this.declareNameFromIdentifier(at, bindingType)
    }
  }
  declareNameFromIdentifier(identifier2, binding2) {
    this.scope.declareName(identifier2.name, binding2, identifier2.loc.start)
  }
  checkToRestConversion(node2, allowPattern) {
    switch (node2.type) {
      case 'ParenthesizedExpression':
        this.checkToRestConversion(node2.expression, allowPattern)
        break
      case 'Identifier':
      case 'MemberExpression':
        break
      case 'ArrayExpression':
      case 'ObjectExpression':
        if (allowPattern) break
      default:
        this.raise(Errors$1.InvalidRestAssignmentPattern, {
          at: node2,
        })
    }
  }
  checkCommaAfterRest(close) {
    if (!this.match(12)) {
      return false
    }
    this.raise(this.lookaheadCharCode() === close ? Errors$1.RestTrailingComma : Errors$1.ElementAfterRest, {
      at: this.state.startLoc,
    })
    return true
  }
}
class ExpressionParser$1 extends LValParser$1 {
  checkProto(prop, isRecord, protoRef, refExpressionErrors) {
    if (prop.type === 'SpreadElement' || this.isObjectMethod(prop) || prop.computed || prop.shorthand) {
      return
    }
    const key = prop.key
    const name = key.type === 'Identifier' ? key.name : key.value
    if (name === '__proto__') {
      if (isRecord) {
        this.raise(Errors$1.RecordNoProto, {
          at: key,
        })
        return
      }
      if (protoRef.used) {
        if (refExpressionErrors) {
          if (refExpressionErrors.doubleProtoLoc === null) {
            refExpressionErrors.doubleProtoLoc = key.loc.start
          }
        } else {
          this.raise(Errors$1.DuplicateProto, {
            at: key,
          })
        }
      }
      protoRef.used = true
    }
  }
  shouldExitDescending(expr, potentialArrowAt) {
    return expr.type === 'ArrowFunctionExpression' && expr.start === potentialArrowAt
  }
  getExpression() {
    this.enterInitialScopes()
    this.nextToken()
    const expr = this.parseExpression()
    if (!this.match(135)) {
      this.unexpected()
    }
    this.finalizeRemainingComments()
    expr.comments = this.state.comments
    expr.errors = this.state.errors
    if (this.options.tokens) {
      expr.tokens = this.tokens
    }
    return expr
  }
  parseExpression(disallowIn, refExpressionErrors) {
    if (disallowIn) {
      return this.disallowInAnd(() => this.parseExpressionBase(refExpressionErrors))
    }
    return this.allowInAnd(() => this.parseExpressionBase(refExpressionErrors))
  }
  parseExpressionBase(refExpressionErrors) {
    const startPos = this.state.start
    const startLoc = this.state.startLoc
    const expr = this.parseMaybeAssign(refExpressionErrors)
    if (this.match(12)) {
      const node2 = this.startNodeAt(startPos, startLoc)
      node2.expressions = [expr]
      while (this.eat(12)) {
        node2.expressions.push(this.parseMaybeAssign(refExpressionErrors))
      }
      this.toReferencedList(node2.expressions)
      return this.finishNode(node2, 'SequenceExpression')
    }
    return expr
  }
  parseMaybeAssignDisallowIn(refExpressionErrors, afterLeftParse) {
    return this.disallowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse))
  }
  parseMaybeAssignAllowIn(refExpressionErrors, afterLeftParse) {
    return this.allowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse))
  }
  setOptionalParametersError(refExpressionErrors, resultError) {
    var _resultError$loc
    refExpressionErrors.optionalParametersLoc =
      (_resultError$loc = resultError == null ? void 0 : resultError.loc) != null
        ? _resultError$loc
        : this.state.startLoc
  }
  parseMaybeAssign(refExpressionErrors, afterLeftParse) {
    const startPos = this.state.start
    const startLoc = this.state.startLoc
    if (this.isContextual(105)) {
      if (this.prodParam.hasYield) {
        let left2 = this.parseYield()
        if (afterLeftParse) {
          left2 = afterLeftParse.call(this, left2, startPos, startLoc)
        }
        return left2
      }
    }
    let ownExpressionErrors
    if (refExpressionErrors) {
      ownExpressionErrors = false
    } else {
      refExpressionErrors = new ExpressionErrors$1()
      ownExpressionErrors = true
    }
    const { type } = this.state
    if (type === 10 || tokenIsIdentifier$1(type)) {
      this.state.potentialArrowAt = this.state.start
    }
    let left = this.parseMaybeConditional(refExpressionErrors)
    if (afterLeftParse) {
      left = afterLeftParse.call(this, left, startPos, startLoc)
    }
    if (tokenIsAssignment$1(this.state.type)) {
      const node2 = this.startNodeAt(startPos, startLoc)
      const operator = this.state.value
      node2.operator = operator
      if (this.match(29)) {
        this.toAssignable(left, true)
        node2.left = left
        if (refExpressionErrors.doubleProtoLoc != null && refExpressionErrors.doubleProtoLoc.index >= startPos) {
          refExpressionErrors.doubleProtoLoc = null
        }
        if (
          refExpressionErrors.shorthandAssignLoc != null &&
          refExpressionErrors.shorthandAssignLoc.index >= startPos
        ) {
          refExpressionErrors.shorthandAssignLoc = null
        }
        if (refExpressionErrors.privateKeyLoc != null && refExpressionErrors.privateKeyLoc.index >= startPos) {
          this.checkDestructuringPrivate(refExpressionErrors)
          refExpressionErrors.privateKeyLoc = null
        }
      } else {
        node2.left = left
      }
      this.next()
      node2.right = this.parseMaybeAssign()
      this.checkLVal(left, {
        in: this.finishNode(node2, 'AssignmentExpression'),
      })
      return node2
    } else if (ownExpressionErrors) {
      this.checkExpressionErrors(refExpressionErrors, true)
    }
    return left
  }
  parseMaybeConditional(refExpressionErrors) {
    const startPos = this.state.start
    const startLoc = this.state.startLoc
    const potentialArrowAt = this.state.potentialArrowAt
    const expr = this.parseExprOps(refExpressionErrors)
    if (this.shouldExitDescending(expr, potentialArrowAt)) {
      return expr
    }
    return this.parseConditional(expr, startPos, startLoc, refExpressionErrors)
  }
  parseConditional(expr, startPos, startLoc, refExpressionErrors) {
    if (this.eat(17)) {
      const node2 = this.startNodeAt(startPos, startLoc)
      node2.test = expr
      node2.consequent = this.parseMaybeAssignAllowIn()
      this.expect(14)
      node2.alternate = this.parseMaybeAssign()
      return this.finishNode(node2, 'ConditionalExpression')
    }
    return expr
  }
  parseMaybeUnaryOrPrivate(refExpressionErrors) {
    return this.match(134) ? this.parsePrivateName() : this.parseMaybeUnary(refExpressionErrors)
  }
  parseExprOps(refExpressionErrors) {
    const startPos = this.state.start
    const startLoc = this.state.startLoc
    const potentialArrowAt = this.state.potentialArrowAt
    const expr = this.parseMaybeUnaryOrPrivate(refExpressionErrors)
    if (this.shouldExitDescending(expr, potentialArrowAt)) {
      return expr
    }
    return this.parseExprOp(expr, startPos, startLoc, -1)
  }
  parseExprOp(left, leftStartPos, leftStartLoc, minPrec) {
    if (this.isPrivateName(left)) {
      const value = this.getPrivateNameSV(left)
      if (minPrec >= tokenOperatorPrecedence$1(58) || !this.prodParam.hasIn || !this.match(58)) {
        this.raise(Errors$1.PrivateInExpectedIn, {
          at: left,
          identifierName: value,
        })
      }
      this.classScope.usePrivateName(value, left.loc.start)
    }
    const op = this.state.type
    if (tokenIsOperator$1(op) && (this.prodParam.hasIn || !this.match(58))) {
      let prec = tokenOperatorPrecedence$1(op)
      if (prec > minPrec) {
        if (op === 39) {
          this.expectPlugin('pipelineOperator')
          if (this.state.inFSharpPipelineDirectBody) {
            return left
          }
          this.checkPipelineAtInfixOperator(left, leftStartLoc)
        }
        const node2 = this.startNodeAt(leftStartPos, leftStartLoc)
        node2.left = left
        node2.operator = this.state.value
        const logical = op === 41 || op === 42
        const coalesce = op === 40
        if (coalesce) {
          prec = tokenOperatorPrecedence$1(42)
        }
        this.next()
        if (
          op === 39 &&
          this.hasPlugin([
            'pipelineOperator',
            {
              proposal: 'minimal',
            },
          ])
        ) {
          if (this.state.type === 96 && this.prodParam.hasAwait) {
            throw this.raise(Errors$1.UnexpectedAwaitAfterPipelineBody, {
              at: this.state.startLoc,
            })
          }
        }
        node2.right = this.parseExprOpRightExpr(op, prec)
        this.finishNode(node2, logical || coalesce ? 'LogicalExpression' : 'BinaryExpression')
        const nextOp = this.state.type
        if ((coalesce && (nextOp === 41 || nextOp === 42)) || (logical && nextOp === 40)) {
          throw this.raise(Errors$1.MixingCoalesceWithLogical, {
            at: this.state.startLoc,
          })
        }
        return this.parseExprOp(node2, leftStartPos, leftStartLoc, minPrec)
      }
    }
    return left
  }
  parseExprOpRightExpr(op, prec) {
    const startPos = this.state.start
    const startLoc = this.state.startLoc
    switch (op) {
      case 39:
        switch (this.getPluginOption('pipelineOperator', 'proposal')) {
          case 'hack':
            return this.withTopicBindingContext(() => {
              return this.parseHackPipeBody()
            })
          case 'smart':
            return this.withTopicBindingContext(() => {
              if (this.prodParam.hasYield && this.isContextual(105)) {
                throw this.raise(Errors$1.PipeBodyIsTighter, {
                  at: this.state.startLoc,
                })
              }
              return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(op, prec), startPos, startLoc)
            })
          case 'fsharp':
            return this.withSoloAwaitPermittingContext(() => {
              return this.parseFSharpPipelineBody(prec)
            })
        }
      default:
        return this.parseExprOpBaseRightExpr(op, prec)
    }
  }
  parseExprOpBaseRightExpr(op, prec) {
    const startPos = this.state.start
    const startLoc = this.state.startLoc
    return this.parseExprOp(
      this.parseMaybeUnaryOrPrivate(),
      startPos,
      startLoc,
      tokenIsRightAssociative$1(op) ? prec - 1 : prec
    )
  }
  parseHackPipeBody() {
    var _body$extra
    const { startLoc } = this.state
    const body = this.parseMaybeAssign()
    const requiredParentheses = UnparenthesizedPipeBodyDescriptions$1.has(body.type)
    if (requiredParentheses && !((_body$extra = body.extra) != null && _body$extra.parenthesized)) {
      this.raise(Errors$1.PipeUnparenthesizedBody, {
        at: startLoc,
        type: body.type,
      })
    }
    if (!this.topicReferenceWasUsedInCurrentContext()) {
      this.raise(Errors$1.PipeTopicUnused, {
        at: startLoc,
      })
    }
    return body
  }
  checkExponentialAfterUnary(node2) {
    if (this.match(57)) {
      this.raise(Errors$1.UnexpectedTokenUnaryExponentiation, {
        at: node2.argument,
      })
    }
  }
  parseMaybeUnary(refExpressionErrors, sawUnary) {
    const startPos = this.state.start
    const startLoc = this.state.startLoc
    const isAwait = this.isContextual(96)
    if (isAwait && this.isAwaitAllowed()) {
      this.next()
      const expr2 = this.parseAwait(startPos, startLoc)
      if (!sawUnary) this.checkExponentialAfterUnary(expr2)
      return expr2
    }
    const update = this.match(34)
    const node2 = this.startNode()
    if (tokenIsPrefix$1(this.state.type)) {
      node2.operator = this.state.value
      node2.prefix = true
      if (this.match(72)) {
        this.expectPlugin('throwExpressions')
      }
      const isDelete = this.match(89)
      this.next()
      node2.argument = this.parseMaybeUnary(null, true)
      this.checkExpressionErrors(refExpressionErrors, true)
      if (this.state.strict && isDelete) {
        const arg = node2.argument
        if (arg.type === 'Identifier') {
          this.raise(Errors$1.StrictDelete, {
            at: node2,
          })
        } else if (this.hasPropertyAsPrivateName(arg)) {
          this.raise(Errors$1.DeletePrivateField, {
            at: node2,
          })
        }
      }
      if (!update) {
        if (!sawUnary) this.checkExponentialAfterUnary(node2)
        return this.finishNode(node2, 'UnaryExpression')
      }
    }
    const expr = this.parseUpdate(node2, update, refExpressionErrors)
    if (isAwait) {
      const { type } = this.state
      const startsExpr2 = this.hasPlugin('v8intrinsic')
        ? tokenCanStartExpression$1(type)
        : tokenCanStartExpression$1(type) && !this.match(54)
      if (startsExpr2 && !this.isAmbiguousAwait()) {
        this.raiseOverwrite(Errors$1.AwaitNotInAsyncContext, {
          at: startLoc,
        })
        return this.parseAwait(startPos, startLoc)
      }
    }
    return expr
  }
  parseUpdate(node2, update, refExpressionErrors) {
    if (update) {
      this.checkLVal(node2.argument, {
        in: this.finishNode(node2, 'UpdateExpression'),
      })
      return node2
    }
    const startPos = this.state.start
    const startLoc = this.state.startLoc
    let expr = this.parseExprSubscripts(refExpressionErrors)
    if (this.checkExpressionErrors(refExpressionErrors, false)) return expr
    while (tokenIsPostfix$1(this.state.type) && !this.canInsertSemicolon()) {
      const node3 = this.startNodeAt(startPos, startLoc)
      node3.operator = this.state.value
      node3.prefix = false
      node3.argument = expr
      this.next()
      this.checkLVal(expr, {
        in: (expr = this.finishNode(node3, 'UpdateExpression')),
      })
    }
    return expr
  }
  parseExprSubscripts(refExpressionErrors) {
    const startPos = this.state.start
    const startLoc = this.state.startLoc
    const potentialArrowAt = this.state.potentialArrowAt
    const expr = this.parseExprAtom(refExpressionErrors)
    if (this.shouldExitDescending(expr, potentialArrowAt)) {
      return expr
    }
    return this.parseSubscripts(expr, startPos, startLoc)
  }
  parseSubscripts(base2, startPos, startLoc, noCalls) {
    const state = {
      optionalChainMember: false,
      maybeAsyncArrow: this.atPossibleAsyncArrow(base2),
      stop: false,
    }
    do {
      base2 = this.parseSubscript(base2, startPos, startLoc, noCalls, state)
      state.maybeAsyncArrow = false
    } while (!state.stop)
    return base2
  }
  parseSubscript(base2, startPos, startLoc, noCalls, state) {
    const { type } = this.state
    if (!noCalls && type === 15) {
      return this.parseBind(base2, startPos, startLoc, noCalls, state)
    } else if (tokenIsTemplate$1(type)) {
      return this.parseTaggedTemplateExpression(base2, startPos, startLoc, state)
    }
    let optional = false
    if (type === 18) {
      if (noCalls && this.lookaheadCharCode() === 40) {
        state.stop = true
        return base2
      }
      state.optionalChainMember = optional = true
      this.next()
    }
    if (!noCalls && this.match(10)) {
      return this.parseCoverCallAndAsyncArrowHead(base2, startPos, startLoc, state, optional)
    } else {
      const computed2 = this.eat(0)
      if (computed2 || optional || this.eat(16)) {
        return this.parseMember(base2, startPos, startLoc, state, computed2, optional)
      } else {
        state.stop = true
        return base2
      }
    }
  }
  parseMember(base2, startPos, startLoc, state, computed2, optional) {
    const node2 = this.startNodeAt(startPos, startLoc)
    node2.object = base2
    node2.computed = computed2
    if (computed2) {
      node2.property = this.parseExpression()
      this.expect(3)
    } else if (this.match(134)) {
      if (base2.type === 'Super') {
        this.raise(Errors$1.SuperPrivateField, {
          at: startLoc,
        })
      }
      this.classScope.usePrivateName(this.state.value, this.state.startLoc)
      node2.property = this.parsePrivateName()
    } else {
      node2.property = this.parseIdentifier(true)
    }
    if (state.optionalChainMember) {
      node2.optional = optional
      return this.finishNode(node2, 'OptionalMemberExpression')
    } else {
      return this.finishNode(node2, 'MemberExpression')
    }
  }
  parseBind(base2, startPos, startLoc, noCalls, state) {
    const node2 = this.startNodeAt(startPos, startLoc)
    node2.object = base2
    this.next()
    node2.callee = this.parseNoCallExpr()
    state.stop = true
    return this.parseSubscripts(this.finishNode(node2, 'BindExpression'), startPos, startLoc, noCalls)
  }
  parseCoverCallAndAsyncArrowHead(base2, startPos, startLoc, state, optional) {
    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters
    let refExpressionErrors = null
    this.state.maybeInArrowParameters = true
    this.next()
    let node2 = this.startNodeAt(startPos, startLoc)
    node2.callee = base2
    const { maybeAsyncArrow, optionalChainMember } = state
    if (maybeAsyncArrow) {
      this.expressionScope.enter(newAsyncArrowScope$1())
      refExpressionErrors = new ExpressionErrors$1()
    }
    if (optionalChainMember) {
      node2.optional = optional
    }
    if (optional) {
      node2.arguments = this.parseCallExpressionArguments(11)
    } else {
      node2.arguments = this.parseCallExpressionArguments(
        11,
        base2.type === 'Import',
        base2.type !== 'Super',
        node2,
        refExpressionErrors
      )
    }
    this.finishCallExpression(node2, optionalChainMember)
    if (maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional) {
      state.stop = true
      this.checkDestructuringPrivate(refExpressionErrors)
      this.expressionScope.validateAsPattern()
      this.expressionScope.exit()
      node2 = this.parseAsyncArrowFromCallExpression(this.startNodeAt(startPos, startLoc), node2)
    } else {
      if (maybeAsyncArrow) {
        this.checkExpressionErrors(refExpressionErrors, true)
        this.expressionScope.exit()
      }
      this.toReferencedArguments(node2)
    }
    this.state.maybeInArrowParameters = oldMaybeInArrowParameters
    return node2
  }
  toReferencedArguments(node2, isParenthesizedExpr) {
    this.toReferencedListDeep(node2.arguments, isParenthesizedExpr)
  }
  parseTaggedTemplateExpression(base2, startPos, startLoc, state) {
    const node2 = this.startNodeAt(startPos, startLoc)
    node2.tag = base2
    node2.quasi = this.parseTemplate(true)
    if (state.optionalChainMember) {
      this.raise(Errors$1.OptionalChainingNoTemplate, {
        at: startLoc,
      })
    }
    return this.finishNode(node2, 'TaggedTemplateExpression')
  }
  atPossibleAsyncArrow(base2) {
    return (
      base2.type === 'Identifier' &&
      base2.name === 'async' &&
      this.state.lastTokEndLoc.index === base2.end &&
      !this.canInsertSemicolon() &&
      base2.end - base2.start === 5 &&
      base2.start === this.state.potentialArrowAt
    )
  }
  finishCallExpression(node2, optional) {
    if (node2.callee.type === 'Import') {
      if (node2.arguments.length === 2) {
        {
          if (!this.hasPlugin('moduleAttributes')) {
            this.expectPlugin('importAssertions')
          }
        }
      }
      if (node2.arguments.length === 0 || node2.arguments.length > 2) {
        this.raise(Errors$1.ImportCallArity, {
          at: node2,
          maxArgumentCount: this.hasPlugin('importAssertions') || this.hasPlugin('moduleAttributes') ? 2 : 1,
        })
      } else {
        for (const arg of node2.arguments) {
          if (arg.type === 'SpreadElement') {
            this.raise(Errors$1.ImportCallSpreadArgument, {
              at: arg,
            })
          }
        }
      }
    }
    return this.finishNode(node2, optional ? 'OptionalCallExpression' : 'CallExpression')
  }
  parseCallExpressionArguments(close, dynamicImport, allowPlaceholder, nodeForExtra, refExpressionErrors) {
    const elts = []
    let first = true
    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody
    this.state.inFSharpPipelineDirectBody = false
    while (!this.eat(close)) {
      if (first) {
        first = false
      } else {
        this.expect(12)
        if (this.match(close)) {
          if (dynamicImport && !this.hasPlugin('importAssertions') && !this.hasPlugin('moduleAttributes')) {
            this.raise(Errors$1.ImportCallArgumentTrailingComma, {
              at: this.state.lastTokStartLoc,
            })
          }
          if (nodeForExtra) {
            this.addTrailingCommaExtraToNode(nodeForExtra)
          }
          this.next()
          break
        }
      }
      elts.push(this.parseExprListItem(false, refExpressionErrors, allowPlaceholder))
    }
    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody
    return elts
  }
  shouldParseAsyncArrow() {
    return this.match(19) && !this.canInsertSemicolon()
  }
  parseAsyncArrowFromCallExpression(node2, call2) {
    var _call$extra
    this.resetPreviousNodeTrailingComments(call2)
    this.expect(19)
    this.parseArrowExpression(
      node2,
      call2.arguments,
      true,
      (_call$extra = call2.extra) == null ? void 0 : _call$extra.trailingCommaLoc
    )
    if (call2.innerComments) {
      setInnerComments$1(node2, call2.innerComments)
    }
    if (call2.callee.trailingComments) {
      setInnerComments$1(node2, call2.callee.trailingComments)
    }
    return node2
  }
  parseNoCallExpr() {
    const startPos = this.state.start
    const startLoc = this.state.startLoc
    return this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true)
  }
  parseExprAtom(refExpressionErrors) {
    let node2
    const { type } = this.state
    switch (type) {
      case 79:
        return this.parseSuper()
      case 83:
        node2 = this.startNode()
        this.next()
        if (this.match(16)) {
          return this.parseImportMetaProperty(node2)
        }
        if (!this.match(10)) {
          this.raise(Errors$1.UnsupportedImport, {
            at: this.state.lastTokStartLoc,
          })
        }
        return this.finishNode(node2, 'Import')
      case 78:
        node2 = this.startNode()
        this.next()
        return this.finishNode(node2, 'ThisExpression')
      case 90: {
        return this.parseDo(this.startNode(), false)
      }
      case 56:
      case 31: {
        this.readRegexp()
        return this.parseRegExpLiteral(this.state.value)
      }
      case 130:
        return this.parseNumericLiteral(this.state.value)
      case 131:
        return this.parseBigIntLiteral(this.state.value)
      case 132:
        return this.parseDecimalLiteral(this.state.value)
      case 129:
        return this.parseStringLiteral(this.state.value)
      case 84:
        return this.parseNullLiteral()
      case 85:
        return this.parseBooleanLiteral(true)
      case 86:
        return this.parseBooleanLiteral(false)
      case 10: {
        const canBeArrow = this.state.potentialArrowAt === this.state.start
        return this.parseParenAndDistinguishExpression(canBeArrow)
      }
      case 2:
      case 1: {
        return this.parseArrayLike(this.state.type === 2 ? 4 : 3, false, true)
      }
      case 0: {
        return this.parseArrayLike(3, true, false, refExpressionErrors)
      }
      case 6:
      case 7: {
        return this.parseObjectLike(this.state.type === 6 ? 9 : 8, false, true)
      }
      case 5: {
        return this.parseObjectLike(8, false, false, refExpressionErrors)
      }
      case 68:
        return this.parseFunctionOrFunctionSent()
      case 26:
        this.parseDecorators()
      case 80:
        node2 = this.startNode()
        this.takeDecorators(node2)
        return this.parseClass(node2, false)
      case 77:
        return this.parseNewOrNewTarget()
      case 25:
      case 24:
        return this.parseTemplate(false)
      case 15: {
        node2 = this.startNode()
        this.next()
        node2.object = null
        const callee = (node2.callee = this.parseNoCallExpr())
        if (callee.type === 'MemberExpression') {
          return this.finishNode(node2, 'BindExpression')
        } else {
          throw this.raise(Errors$1.UnsupportedBind, {
            at: callee,
          })
        }
      }
      case 134: {
        this.raise(Errors$1.PrivateInExpectedIn, {
          at: this.state.startLoc,
          identifierName: this.state.value,
        })
        return this.parsePrivateName()
      }
      case 33: {
        return this.parseTopicReferenceThenEqualsSign(54, '%')
      }
      case 32: {
        return this.parseTopicReferenceThenEqualsSign(44, '^')
      }
      case 37:
      case 38: {
        return this.parseTopicReference('hack')
      }
      case 44:
      case 54:
      case 27: {
        const pipeProposal = this.getPluginOption('pipelineOperator', 'proposal')
        if (pipeProposal) {
          return this.parseTopicReference(pipeProposal)
        } else {
          throw this.unexpected()
        }
      }
      case 47: {
        const lookaheadCh = this.input.codePointAt(this.nextTokenStart())
        if (isIdentifierStart$1(lookaheadCh) || lookaheadCh === 62) {
          this.expectOnePlugin(['jsx', 'flow', 'typescript'])
          break
        } else {
          throw this.unexpected()
        }
      }
      default:
        if (tokenIsIdentifier$1(type)) {
          if (this.isContextual(123) && this.lookaheadCharCode() === 123 && !this.hasFollowingLineBreak()) {
            return this.parseModuleExpression()
          }
          const canBeArrow = this.state.potentialArrowAt === this.state.start
          const containsEsc = this.state.containsEsc
          const id = this.parseIdentifier()
          if (!containsEsc && id.name === 'async' && !this.canInsertSemicolon()) {
            const { type: type2 } = this.state
            if (type2 === 68) {
              this.resetPreviousNodeTrailingComments(id)
              this.next()
              return this.parseFunction(this.startNodeAtNode(id), void 0, true)
            } else if (tokenIsIdentifier$1(type2)) {
              if (this.lookaheadCharCode() === 61) {
                return this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(id))
              } else {
                return id
              }
            } else if (type2 === 90) {
              this.resetPreviousNodeTrailingComments(id)
              return this.parseDo(this.startNodeAtNode(id), true)
            }
          }
          if (canBeArrow && this.match(19) && !this.canInsertSemicolon()) {
            this.next()
            return this.parseArrowExpression(this.startNodeAtNode(id), [id], false)
          }
          return id
        } else {
          throw this.unexpected()
        }
    }
  }
  parseTopicReferenceThenEqualsSign(topicTokenType, topicTokenValue) {
    const pipeProposal = this.getPluginOption('pipelineOperator', 'proposal')
    if (pipeProposal) {
      this.state.type = topicTokenType
      this.state.value = topicTokenValue
      this.state.pos--
      this.state.end--
      this.state.endLoc = createPositionWithColumnOffset$1(this.state.endLoc, -1)
      return this.parseTopicReference(pipeProposal)
    } else {
      throw this.unexpected()
    }
  }
  parseTopicReference(pipeProposal) {
    const node2 = this.startNode()
    const startLoc = this.state.startLoc
    const tokenType = this.state.type
    this.next()
    return this.finishTopicReference(node2, startLoc, pipeProposal, tokenType)
  }
  finishTopicReference(node2, startLoc, pipeProposal, tokenType) {
    if (this.testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType)) {
      const nodeType = pipeProposal === 'smart' ? 'PipelinePrimaryTopicReference' : 'TopicReference'
      if (!this.topicReferenceIsAllowedInCurrentContext()) {
        this.raise(pipeProposal === 'smart' ? Errors$1.PrimaryTopicNotAllowed : Errors$1.PipeTopicUnbound, {
          at: startLoc,
        })
      }
      this.registerTopicReference()
      return this.finishNode(node2, nodeType)
    } else {
      throw this.raise(Errors$1.PipeTopicUnconfiguredToken, {
        at: startLoc,
        token: tokenLabelName$1(tokenType),
      })
    }
  }
  testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType) {
    switch (pipeProposal) {
      case 'hack': {
        return this.hasPlugin([
          'pipelineOperator',
          {
            topicToken: tokenLabelName$1(tokenType),
          },
        ])
      }
      case 'smart':
        return tokenType === 27
      default:
        throw this.raise(Errors$1.PipeTopicRequiresHackPipes, {
          at: startLoc,
        })
    }
  }
  parseAsyncArrowUnaryFunction(node2) {
    this.prodParam.enter(functionFlags$1(true, this.prodParam.hasYield))
    const params = [this.parseIdentifier()]
    this.prodParam.exit()
    if (this.hasPrecedingLineBreak()) {
      this.raise(Errors$1.LineTerminatorBeforeArrow, {
        at: this.state.curPosition(),
      })
    }
    this.expect(19)
    this.parseArrowExpression(node2, params, true)
    return node2
  }
  parseDo(node2, isAsync) {
    this.expectPlugin('doExpressions')
    if (isAsync) {
      this.expectPlugin('asyncDoExpressions')
    }
    node2.async = isAsync
    this.next()
    const oldLabels = this.state.labels
    this.state.labels = []
    if (isAsync) {
      this.prodParam.enter(PARAM_AWAIT$1)
      node2.body = this.parseBlock()
      this.prodParam.exit()
    } else {
      node2.body = this.parseBlock()
    }
    this.state.labels = oldLabels
    return this.finishNode(node2, 'DoExpression')
  }
  parseSuper() {
    const node2 = this.startNode()
    this.next()
    if (this.match(10) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod) {
      this.raise(Errors$1.SuperNotAllowed, {
        at: node2,
      })
    } else if (!this.scope.allowSuper && !this.options.allowSuperOutsideMethod) {
      this.raise(Errors$1.UnexpectedSuper, {
        at: node2,
      })
    }
    if (!this.match(10) && !this.match(0) && !this.match(16)) {
      this.raise(Errors$1.UnsupportedSuper, {
        at: node2,
      })
    }
    return this.finishNode(node2, 'Super')
  }
  parsePrivateName() {
    const node2 = this.startNode()
    const id = this.startNodeAt(
      this.state.start + 1,
      new Position$1(this.state.curLine, this.state.start + 1 - this.state.lineStart, this.state.start + 1)
    )
    const name = this.state.value
    this.next()
    node2.id = this.createIdentifier(id, name)
    return this.finishNode(node2, 'PrivateName')
  }
  parseFunctionOrFunctionSent() {
    const node2 = this.startNode()
    this.next()
    if (this.prodParam.hasYield && this.match(16)) {
      const meta = this.createIdentifier(this.startNodeAtNode(node2), 'function')
      this.next()
      if (this.match(102)) {
        this.expectPlugin('functionSent')
      } else if (!this.hasPlugin('functionSent')) {
        this.unexpected()
      }
      return this.parseMetaProperty(node2, meta, 'sent')
    }
    return this.parseFunction(node2)
  }
  parseMetaProperty(node2, meta, propertyName) {
    node2.meta = meta
    const containsEsc = this.state.containsEsc
    node2.property = this.parseIdentifier(true)
    if (node2.property.name !== propertyName || containsEsc) {
      this.raise(Errors$1.UnsupportedMetaProperty, {
        at: node2.property,
        target: meta.name,
        onlyValidPropertyName: propertyName,
      })
    }
    return this.finishNode(node2, 'MetaProperty')
  }
  parseImportMetaProperty(node2) {
    const id = this.createIdentifier(this.startNodeAtNode(node2), 'import')
    this.next()
    if (this.isContextual(100)) {
      if (!this.inModule) {
        this.raise(Errors$1.ImportMetaOutsideModule, {
          at: id,
        })
      }
      this.sawUnambiguousESM = true
    }
    return this.parseMetaProperty(node2, id, 'meta')
  }
  parseLiteralAtNode(value, type, node2) {
    this.addExtra(node2, 'rawValue', value)
    this.addExtra(node2, 'raw', this.input.slice(node2.start, this.state.end))
    node2.value = value
    this.next()
    return this.finishNode(node2, type)
  }
  parseLiteral(value, type) {
    const node2 = this.startNode()
    return this.parseLiteralAtNode(value, type, node2)
  }
  parseStringLiteral(value) {
    return this.parseLiteral(value, 'StringLiteral')
  }
  parseNumericLiteral(value) {
    return this.parseLiteral(value, 'NumericLiteral')
  }
  parseBigIntLiteral(value) {
    return this.parseLiteral(value, 'BigIntLiteral')
  }
  parseDecimalLiteral(value) {
    return this.parseLiteral(value, 'DecimalLiteral')
  }
  parseRegExpLiteral(value) {
    const node2 = this.parseLiteral(value.value, 'RegExpLiteral')
    node2.pattern = value.pattern
    node2.flags = value.flags
    return node2
  }
  parseBooleanLiteral(value) {
    const node2 = this.startNode()
    node2.value = value
    this.next()
    return this.finishNode(node2, 'BooleanLiteral')
  }
  parseNullLiteral() {
    const node2 = this.startNode()
    this.next()
    return this.finishNode(node2, 'NullLiteral')
  }
  parseParenAndDistinguishExpression(canBeArrow) {
    const startPos = this.state.start
    const startLoc = this.state.startLoc
    let val
    this.next()
    this.expressionScope.enter(newArrowHeadScope$1())
    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters
    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody
    this.state.maybeInArrowParameters = true
    this.state.inFSharpPipelineDirectBody = false
    const innerStartPos = this.state.start
    const innerStartLoc = this.state.startLoc
    const exprList = []
    const refExpressionErrors = new ExpressionErrors$1()
    let first = true
    let spreadStartLoc
    let optionalCommaStartLoc
    while (!this.match(11)) {
      if (first) {
        first = false
      } else {
        this.expect(
          12,
          refExpressionErrors.optionalParametersLoc === null ? null : refExpressionErrors.optionalParametersLoc
        )
        if (this.match(11)) {
          optionalCommaStartLoc = this.state.startLoc
          break
        }
      }
      if (this.match(21)) {
        const spreadNodeStartPos = this.state.start
        const spreadNodeStartLoc = this.state.startLoc
        spreadStartLoc = this.state.startLoc
        exprList.push(this.parseParenItem(this.parseRestBinding(), spreadNodeStartPos, spreadNodeStartLoc))
        if (!this.checkCommaAfterRest(41)) {
          break
        }
      } else {
        exprList.push(this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem))
      }
    }
    const innerEndLoc = this.state.lastTokEndLoc
    this.expect(11)
    this.state.maybeInArrowParameters = oldMaybeInArrowParameters
    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody
    let arrowNode = this.startNodeAt(startPos, startLoc)
    if (canBeArrow && this.shouldParseArrow(exprList) && (arrowNode = this.parseArrow(arrowNode))) {
      this.checkDestructuringPrivate(refExpressionErrors)
      this.expressionScope.validateAsPattern()
      this.expressionScope.exit()
      this.parseArrowExpression(arrowNode, exprList, false)
      return arrowNode
    }
    this.expressionScope.exit()
    if (!exprList.length) {
      this.unexpected(this.state.lastTokStartLoc)
    }
    if (optionalCommaStartLoc) this.unexpected(optionalCommaStartLoc)
    if (spreadStartLoc) this.unexpected(spreadStartLoc)
    this.checkExpressionErrors(refExpressionErrors, true)
    this.toReferencedListDeep(exprList, true)
    if (exprList.length > 1) {
      val = this.startNodeAt(innerStartPos, innerStartLoc)
      val.expressions = exprList
      this.finishNode(val, 'SequenceExpression')
      this.resetEndLocation(val, innerEndLoc)
    } else {
      val = exprList[0]
    }
    return this.wrapParenthesis(startPos, startLoc, val)
  }
  wrapParenthesis(startPos, startLoc, expression2) {
    if (!this.options.createParenthesizedExpressions) {
      this.addExtra(expression2, 'parenthesized', true)
      this.addExtra(expression2, 'parenStart', startPos)
      this.takeSurroundingComments(expression2, startPos, this.state.lastTokEndLoc.index)
      return expression2
    }
    const parenExpression = this.startNodeAt(startPos, startLoc)
    parenExpression.expression = expression2
    this.finishNode(parenExpression, 'ParenthesizedExpression')
    return parenExpression
  }
  shouldParseArrow(params) {
    return !this.canInsertSemicolon()
  }
  parseArrow(node2) {
    if (this.eat(19)) {
      return node2
    }
  }
  parseParenItem(node2, startPos, startLoc) {
    return node2
  }
  parseNewOrNewTarget() {
    const node2 = this.startNode()
    this.next()
    if (this.match(16)) {
      const meta = this.createIdentifier(this.startNodeAtNode(node2), 'new')
      this.next()
      const metaProp = this.parseMetaProperty(node2, meta, 'target')
      if (!this.scope.inNonArrowFunction && !this.scope.inClass) {
        this.raise(Errors$1.UnexpectedNewTarget, {
          at: metaProp,
        })
      }
      return metaProp
    }
    return this.parseNew(node2)
  }
  parseNew(node2) {
    this.parseNewCallee(node2)
    if (this.eat(10)) {
      const args = this.parseExprList(11)
      this.toReferencedList(args)
      node2.arguments = args
    } else {
      node2.arguments = []
    }
    return this.finishNode(node2, 'NewExpression')
  }
  parseNewCallee(node2) {
    node2.callee = this.parseNoCallExpr()
    if (node2.callee.type === 'Import') {
      this.raise(Errors$1.ImportCallNotNewExpression, {
        at: node2.callee,
      })
    } else if (this.isOptionalChain(node2.callee)) {
      this.raise(Errors$1.OptionalChainingNoNew, {
        at: this.state.lastTokEndLoc,
      })
    } else if (this.eat(18)) {
      this.raise(Errors$1.OptionalChainingNoNew, {
        at: this.state.startLoc,
      })
    }
  }
  parseTemplateElement(isTagged) {
    const { start, startLoc, end, value } = this.state
    const elemStart = start + 1
    const elem = this.startNodeAt(elemStart, createPositionWithColumnOffset$1(startLoc, 1))
    if (value === null) {
      if (!isTagged) {
        this.raise(Errors$1.InvalidEscapeSequenceTemplate, {
          at: createPositionWithColumnOffset$1(startLoc, 2),
        })
      }
    }
    const isTail = this.match(24)
    const endOffset = isTail ? -1 : -2
    const elemEnd = end + endOffset
    elem.value = {
      raw: this.input.slice(elemStart, elemEnd).replace(/\r\n?/g, '\n'),
      cooked: value === null ? null : value.slice(1, endOffset),
    }
    elem.tail = isTail
    this.next()
    this.finishNode(elem, 'TemplateElement')
    this.resetEndLocation(elem, createPositionWithColumnOffset$1(this.state.lastTokEndLoc, endOffset))
    return elem
  }
  parseTemplate(isTagged) {
    const node2 = this.startNode()
    node2.expressions = []
    let curElt = this.parseTemplateElement(isTagged)
    node2.quasis = [curElt]
    while (!curElt.tail) {
      node2.expressions.push(this.parseTemplateSubstitution())
      this.readTemplateContinuation()
      node2.quasis.push((curElt = this.parseTemplateElement(isTagged)))
    }
    return this.finishNode(node2, 'TemplateLiteral')
  }
  parseTemplateSubstitution() {
    return this.parseExpression()
  }
  parseObjectLike(close, isPattern2, isRecord, refExpressionErrors) {
    if (isRecord) {
      this.expectPlugin('recordAndTuple')
    }
    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody
    this.state.inFSharpPipelineDirectBody = false
    const propHash = /* @__PURE__ */ Object.create(null)
    let first = true
    const node2 = this.startNode()
    node2.properties = []
    this.next()
    while (!this.match(close)) {
      if (first) {
        first = false
      } else {
        this.expect(12)
        if (this.match(close)) {
          this.addTrailingCommaExtraToNode(node2)
          break
        }
      }
      let prop
      if (isPattern2) {
        prop = this.parseBindingProperty()
      } else {
        prop = this.parsePropertyDefinition(refExpressionErrors)
        this.checkProto(prop, isRecord, propHash, refExpressionErrors)
      }
      if (isRecord && !this.isObjectProperty(prop) && prop.type !== 'SpreadElement') {
        this.raise(Errors$1.InvalidRecordProperty, {
          at: prop,
        })
      }
      if (prop.shorthand) {
        this.addExtra(prop, 'shorthand', true)
      }
      node2.properties.push(prop)
    }
    this.next()
    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody
    let type = 'ObjectExpression'
    if (isPattern2) {
      type = 'ObjectPattern'
    } else if (isRecord) {
      type = 'RecordExpression'
    }
    return this.finishNode(node2, type)
  }
  addTrailingCommaExtraToNode(node2) {
    this.addExtra(node2, 'trailingComma', this.state.lastTokStart)
    this.addExtra(node2, 'trailingCommaLoc', this.state.lastTokStartLoc, false)
  }
  maybeAsyncOrAccessorProp(prop) {
    return (
      !prop.computed &&
      prop.key.type === 'Identifier' &&
      (this.isLiteralPropertyName() || this.match(0) || this.match(55))
    )
  }
  parsePropertyDefinition(refExpressionErrors) {
    let decorators = []
    if (this.match(26)) {
      if (this.hasPlugin('decorators')) {
        this.raise(Errors$1.UnsupportedPropertyDecorator, {
          at: this.state.startLoc,
        })
      }
      while (this.match(26)) {
        decorators.push(this.parseDecorator())
      }
    }
    const prop = this.startNode()
    let isAsync = false
    let isAccessor2 = false
    let startPos
    let startLoc
    if (this.match(21)) {
      if (decorators.length) this.unexpected()
      return this.parseSpread()
    }
    if (decorators.length) {
      prop.decorators = decorators
      decorators = []
    }
    prop.method = false
    if (refExpressionErrors) {
      startPos = this.state.start
      startLoc = this.state.startLoc
    }
    let isGenerator = this.eat(55)
    this.parsePropertyNamePrefixOperator(prop)
    const containsEsc = this.state.containsEsc
    const key = this.parsePropertyName(prop, refExpressionErrors)
    if (!isGenerator && !containsEsc && this.maybeAsyncOrAccessorProp(prop)) {
      const keyName = key.name
      if (keyName === 'async' && !this.hasPrecedingLineBreak()) {
        isAsync = true
        this.resetPreviousNodeTrailingComments(key)
        isGenerator = this.eat(55)
        this.parsePropertyName(prop)
      }
      if (keyName === 'get' || keyName === 'set') {
        isAccessor2 = true
        this.resetPreviousNodeTrailingComments(key)
        prop.kind = keyName
        if (this.match(55)) {
          isGenerator = true
          this.raise(Errors$1.AccessorIsGenerator, {
            at: this.state.curPosition(),
            kind: keyName,
          })
          this.next()
        }
        this.parsePropertyName(prop)
      }
    }
    this.parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, false, isAccessor2, refExpressionErrors)
    return prop
  }
  getGetterSetterExpectedParamCount(method) {
    return method.kind === 'get' ? 0 : 1
  }
  getObjectOrClassMethodParams(method) {
    return method.params
  }
  checkGetterSetterParams(method) {
    var _params2
    const paramCount = this.getGetterSetterExpectedParamCount(method)
    const params = this.getObjectOrClassMethodParams(method)
    if (params.length !== paramCount) {
      this.raise(method.kind === 'get' ? Errors$1.BadGetterArity : Errors$1.BadSetterArity, {
        at: method,
      })
    }
    if (
      method.kind === 'set' &&
      ((_params2 = params[params.length - 1]) == null ? void 0 : _params2.type) === 'RestElement'
    ) {
      this.raise(Errors$1.BadSetterRestParameter, {
        at: method,
      })
    }
  }
  parseObjectMethod(prop, isGenerator, isAsync, isPattern2, isAccessor2) {
    if (isAccessor2) {
      this.parseMethod(prop, isGenerator, false, false, false, 'ObjectMethod')
      this.checkGetterSetterParams(prop)
      return prop
    }
    if (isAsync || isGenerator || this.match(10)) {
      if (isPattern2) this.unexpected()
      prop.kind = 'method'
      prop.method = true
      return this.parseMethod(prop, isGenerator, isAsync, false, false, 'ObjectMethod')
    }
  }
  parseObjectProperty(prop, startPos, startLoc, isPattern2, refExpressionErrors) {
    prop.shorthand = false
    if (this.eat(14)) {
      prop.value = isPattern2
        ? this.parseMaybeDefault(this.state.start, this.state.startLoc)
        : this.parseMaybeAssignAllowIn(refExpressionErrors)
      return this.finishNode(prop, 'ObjectProperty')
    }
    if (!prop.computed && prop.key.type === 'Identifier') {
      this.checkReservedWord(prop.key.name, prop.key.loc.start, true, false)
      if (isPattern2) {
        prop.value = this.parseMaybeDefault(startPos, startLoc, cloneIdentifier$1(prop.key))
      } else if (this.match(29)) {
        const shorthandAssignLoc = this.state.startLoc
        if (refExpressionErrors != null) {
          if (refExpressionErrors.shorthandAssignLoc === null) {
            refExpressionErrors.shorthandAssignLoc = shorthandAssignLoc
          }
        } else {
          this.raise(Errors$1.InvalidCoverInitializedName, {
            at: shorthandAssignLoc,
          })
        }
        prop.value = this.parseMaybeDefault(startPos, startLoc, cloneIdentifier$1(prop.key))
      } else {
        prop.value = cloneIdentifier$1(prop.key)
      }
      prop.shorthand = true
      return this.finishNode(prop, 'ObjectProperty')
    }
  }
  parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern2, isAccessor2, refExpressionErrors) {
    const node2 =
      this.parseObjectMethod(prop, isGenerator, isAsync, isPattern2, isAccessor2) ||
      this.parseObjectProperty(prop, startPos, startLoc, isPattern2, refExpressionErrors)
    if (!node2) this.unexpected()
    return node2
  }
  parsePropertyName(prop, refExpressionErrors) {
    if (this.eat(0)) {
      prop.computed = true
      prop.key = this.parseMaybeAssignAllowIn()
      this.expect(3)
    } else {
      const { type, value } = this.state
      let key
      if (tokenIsKeywordOrIdentifier$1(type)) {
        key = this.parseIdentifier(true)
      } else {
        switch (type) {
          case 130:
            key = this.parseNumericLiteral(value)
            break
          case 129:
            key = this.parseStringLiteral(value)
            break
          case 131:
            key = this.parseBigIntLiteral(value)
            break
          case 132:
            key = this.parseDecimalLiteral(value)
            break
          case 134: {
            const privateKeyLoc = this.state.startLoc
            if (refExpressionErrors != null) {
              if (refExpressionErrors.privateKeyLoc === null) {
                refExpressionErrors.privateKeyLoc = privateKeyLoc
              }
            } else {
              this.raise(Errors$1.UnexpectedPrivateField, {
                at: privateKeyLoc,
              })
            }
            key = this.parsePrivateName()
            break
          }
          default:
            throw this.unexpected()
        }
      }
      prop.key = key
      if (type !== 134) {
        prop.computed = false
      }
    }
    return prop.key
  }
  initFunction(node2, isAsync) {
    node2.id = null
    node2.generator = false
    node2.async = !!isAsync
  }
  parseMethod(node2, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {
    this.initFunction(node2, isAsync)
    node2.generator = !!isGenerator
    const allowModifiers = isConstructor
    this.scope.enter(
      SCOPE_FUNCTION$1 |
        SCOPE_SUPER$1 |
        (inClassScope ? SCOPE_CLASS$1 : 0) |
        (allowDirectSuper ? SCOPE_DIRECT_SUPER$1 : 0)
    )
    this.prodParam.enter(functionFlags$1(isAsync, node2.generator))
    this.parseFunctionParams(node2, allowModifiers)
    this.parseFunctionBodyAndFinish(node2, type, true)
    this.prodParam.exit()
    this.scope.exit()
    return node2
  }
  parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
    if (isTuple) {
      this.expectPlugin('recordAndTuple')
    }
    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody
    this.state.inFSharpPipelineDirectBody = false
    const node2 = this.startNode()
    this.next()
    node2.elements = this.parseExprList(close, !isTuple, refExpressionErrors, node2)
    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody
    return this.finishNode(node2, isTuple ? 'TupleExpression' : 'ArrayExpression')
  }
  parseArrowExpression(node2, params, isAsync, trailingCommaLoc) {
    this.scope.enter(SCOPE_FUNCTION$1 | SCOPE_ARROW$1)
    let flags = functionFlags$1(isAsync, false)
    if (!this.match(5) && this.prodParam.hasIn) {
      flags |= PARAM_IN$1
    }
    this.prodParam.enter(flags)
    this.initFunction(node2, isAsync)
    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters
    if (params) {
      this.state.maybeInArrowParameters = true
      this.setArrowFunctionParameters(node2, params, trailingCommaLoc)
    }
    this.state.maybeInArrowParameters = false
    this.parseFunctionBody(node2, true)
    this.prodParam.exit()
    this.scope.exit()
    this.state.maybeInArrowParameters = oldMaybeInArrowParameters
    return this.finishNode(node2, 'ArrowFunctionExpression')
  }
  setArrowFunctionParameters(node2, params, trailingCommaLoc) {
    this.toAssignableList(params, trailingCommaLoc, false)
    node2.params = params
  }
  parseFunctionBodyAndFinish(node2, type, isMethod2 = false) {
    this.parseFunctionBody(node2, false, isMethod2)
    this.finishNode(node2, type)
  }
  parseFunctionBody(node2, allowExpression, isMethod2 = false) {
    const isExpression2 = allowExpression && !this.match(5)
    this.expressionScope.enter(newExpressionScope$1())
    if (isExpression2) {
      node2.body = this.parseMaybeAssign()
      this.checkParams(node2, false, allowExpression, false)
    } else {
      const oldStrict = this.state.strict
      const oldLabels = this.state.labels
      this.state.labels = []
      this.prodParam.enter(this.prodParam.currentFlags() | PARAM_RETURN$1)
      node2.body = this.parseBlock(true, false, (hasStrictModeDirective) => {
        const nonSimple = !this.isSimpleParamList(node2.params)
        if (hasStrictModeDirective && nonSimple) {
          this.raise(Errors$1.IllegalLanguageModeDirective, {
            at: (node2.kind === 'method' || node2.kind === 'constructor') && !!node2.key ? node2.key.loc.end : node2,
          })
        }
        const strictModeChanged = !oldStrict && this.state.strict
        this.checkParams(
          node2,
          !this.state.strict && !allowExpression && !isMethod2 && !nonSimple,
          allowExpression,
          strictModeChanged
        )
        if (this.state.strict && node2.id) {
          this.checkIdentifier(node2.id, BIND_OUTSIDE$1, strictModeChanged)
        }
      })
      this.prodParam.exit()
      this.state.labels = oldLabels
    }
    this.expressionScope.exit()
  }
  isSimpleParameter(node2) {
    return node2.type === 'Identifier'
  }
  isSimpleParamList(params) {
    for (let i = 0, len = params.length; i < len; i++) {
      if (!this.isSimpleParameter(params[i])) return false
    }
    return true
  }
  checkParams(node2, allowDuplicates, isArrowFunction, strictModeChanged = true) {
    const checkClashes = !allowDuplicates && /* @__PURE__ */ new Set()
    const formalParameters = {
      type: 'FormalParameters',
    }
    for (const param of node2.params) {
      this.checkLVal(param, {
        in: formalParameters,
        binding: BIND_VAR$1,
        checkClashes,
        strictModeChanged,
      })
    }
  }
  parseExprList(close, allowEmpty, refExpressionErrors, nodeForExtra) {
    const elts = []
    let first = true
    while (!this.eat(close)) {
      if (first) {
        first = false
      } else {
        this.expect(12)
        if (this.match(close)) {
          if (nodeForExtra) {
            this.addTrailingCommaExtraToNode(nodeForExtra)
          }
          this.next()
          break
        }
      }
      elts.push(this.parseExprListItem(allowEmpty, refExpressionErrors))
    }
    return elts
  }
  parseExprListItem(allowEmpty, refExpressionErrors, allowPlaceholder) {
    let elt
    if (this.match(12)) {
      if (!allowEmpty) {
        this.raise(Errors$1.UnexpectedToken, {
          at: this.state.curPosition(),
          unexpected: ',',
        })
      }
      elt = null
    } else if (this.match(21)) {
      const spreadNodeStartPos = this.state.start
      const spreadNodeStartLoc = this.state.startLoc
      elt = this.parseParenItem(this.parseSpread(refExpressionErrors), spreadNodeStartPos, spreadNodeStartLoc)
    } else if (this.match(17)) {
      this.expectPlugin('partialApplication')
      if (!allowPlaceholder) {
        this.raise(Errors$1.UnexpectedArgumentPlaceholder, {
          at: this.state.startLoc,
        })
      }
      const node2 = this.startNode()
      this.next()
      elt = this.finishNode(node2, 'ArgumentPlaceholder')
    } else {
      elt = this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem)
    }
    return elt
  }
  parseIdentifier(liberal) {
    const node2 = this.startNode()
    const name = this.parseIdentifierName(node2.start, liberal)
    return this.createIdentifier(node2, name)
  }
  createIdentifier(node2, name) {
    node2.name = name
    node2.loc.identifierName = name
    return this.finishNode(node2, 'Identifier')
  }
  parseIdentifierName(pos, liberal) {
    let name
    const { startLoc, type } = this.state
    if (tokenIsKeywordOrIdentifier$1(type)) {
      name = this.state.value
    } else {
      throw this.unexpected()
    }
    const tokenIsKeyword2 = tokenKeywordOrIdentifierIsKeyword$1(type)
    if (liberal) {
      if (tokenIsKeyword2) {
        this.replaceToken(128)
      }
    } else {
      this.checkReservedWord(name, startLoc, tokenIsKeyword2, false)
    }
    this.next()
    return name
  }
  checkReservedWord(word, startLoc, checkKeywords, isBinding2) {
    if (word.length > 10) {
      return
    }
    if (!canBeReservedWord$1(word)) {
      return
    }
    if (word === 'yield') {
      if (this.prodParam.hasYield) {
        this.raise(Errors$1.YieldBindingIdentifier, {
          at: startLoc,
        })
        return
      }
    } else if (word === 'await') {
      if (this.prodParam.hasAwait) {
        this.raise(Errors$1.AwaitBindingIdentifier, {
          at: startLoc,
        })
        return
      }
      if (this.scope.inStaticBlock) {
        this.raise(Errors$1.AwaitBindingIdentifierInStaticBlock, {
          at: startLoc,
        })
        return
      }
      this.expressionScope.recordAsyncArrowParametersError({
        at: startLoc,
      })
    } else if (word === 'arguments') {
      if (this.scope.inClassAndNotInNonArrowFunction) {
        this.raise(Errors$1.ArgumentsInClass, {
          at: startLoc,
        })
        return
      }
    }
    if (checkKeywords && isKeyword$1(word)) {
      this.raise(Errors$1.UnexpectedKeyword, {
        at: startLoc,
        keyword: word,
      })
      return
    }
    const reservedTest = !this.state.strict
      ? isReservedWord$1
      : isBinding2
      ? isStrictBindReservedWord$1
      : isStrictReservedWord$1
    if (reservedTest(word, this.inModule)) {
      this.raise(Errors$1.UnexpectedReservedWord, {
        at: startLoc,
        reservedWord: word,
      })
    }
  }
  isAwaitAllowed() {
    if (this.prodParam.hasAwait) return true
    if (this.options.allowAwaitOutsideFunction && !this.scope.inFunction) {
      return true
    }
    return false
  }
  parseAwait(startPos, startLoc) {
    const node2 = this.startNodeAt(startPos, startLoc)
    this.expressionScope.recordParameterInitializerError(Errors$1.AwaitExpressionFormalParameter, {
      at: node2,
    })
    if (this.eat(55)) {
      this.raise(Errors$1.ObsoleteAwaitStar, {
        at: node2,
      })
    }
    if (!this.scope.inFunction && !this.options.allowAwaitOutsideFunction) {
      if (this.isAmbiguousAwait()) {
        this.ambiguousScriptDifferentAst = true
      } else {
        this.sawUnambiguousESM = true
      }
    }
    if (!this.state.soloAwait) {
      node2.argument = this.parseMaybeUnary(null, true)
    }
    return this.finishNode(node2, 'AwaitExpression')
  }
  isAmbiguousAwait() {
    if (this.hasPrecedingLineBreak()) return true
    const { type } = this.state
    return (
      type === 53 ||
      type === 10 ||
      type === 0 ||
      tokenIsTemplate$1(type) ||
      type === 133 ||
      type === 56 ||
      (this.hasPlugin('v8intrinsic') && type === 54)
    )
  }
  parseYield() {
    const node2 = this.startNode()
    this.expressionScope.recordParameterInitializerError(Errors$1.YieldInParameter, {
      at: node2,
    })
    this.next()
    let delegating = false
    let argument = null
    if (!this.hasPrecedingLineBreak()) {
      delegating = this.eat(55)
      switch (this.state.type) {
        case 13:
        case 135:
        case 8:
        case 11:
        case 3:
        case 9:
        case 14:
        case 12:
          if (!delegating) break
        default:
          argument = this.parseMaybeAssign()
      }
    }
    node2.delegate = delegating
    node2.argument = argument
    return this.finishNode(node2, 'YieldExpression')
  }
  checkPipelineAtInfixOperator(left, leftStartLoc) {
    if (
      this.hasPlugin([
        'pipelineOperator',
        {
          proposal: 'smart',
        },
      ])
    ) {
      if (left.type === 'SequenceExpression') {
        this.raise(Errors$1.PipelineHeadSequenceExpression, {
          at: leftStartLoc,
        })
      }
    }
  }
  parseSmartPipelineBodyInStyle(childExpr, startPos, startLoc) {
    const bodyNode = this.startNodeAt(startPos, startLoc)
    if (this.isSimpleReference(childExpr)) {
      bodyNode.callee = childExpr
      return this.finishNode(bodyNode, 'PipelineBareFunction')
    } else {
      this.checkSmartPipeTopicBodyEarlyErrors(startLoc)
      bodyNode.expression = childExpr
      return this.finishNode(bodyNode, 'PipelineTopicExpression')
    }
  }
  isSimpleReference(expression2) {
    switch (expression2.type) {
      case 'MemberExpression':
        return !expression2.computed && this.isSimpleReference(expression2.object)
      case 'Identifier':
        return true
      default:
        return false
    }
  }
  checkSmartPipeTopicBodyEarlyErrors(startLoc) {
    if (this.match(19)) {
      throw this.raise(Errors$1.PipelineBodyNoArrow, {
        at: this.state.startLoc,
      })
    }
    if (!this.topicReferenceWasUsedInCurrentContext()) {
      this.raise(Errors$1.PipelineTopicUnused, {
        at: startLoc,
      })
    }
  }
  withTopicBindingContext(callback) {
    const outerContextTopicState = this.state.topicContext
    this.state.topicContext = {
      maxNumOfResolvableTopics: 1,
      maxTopicIndex: null,
    }
    try {
      return callback()
    } finally {
      this.state.topicContext = outerContextTopicState
    }
  }
  withSmartMixTopicForbiddingContext(callback) {
    if (
      this.hasPlugin([
        'pipelineOperator',
        {
          proposal: 'smart',
        },
      ])
    ) {
      const outerContextTopicState = this.state.topicContext
      this.state.topicContext = {
        maxNumOfResolvableTopics: 0,
        maxTopicIndex: null,
      }
      try {
        return callback()
      } finally {
        this.state.topicContext = outerContextTopicState
      }
    } else {
      return callback()
    }
  }
  withSoloAwaitPermittingContext(callback) {
    const outerContextSoloAwaitState = this.state.soloAwait
    this.state.soloAwait = true
    try {
      return callback()
    } finally {
      this.state.soloAwait = outerContextSoloAwaitState
    }
  }
  allowInAnd(callback) {
    const flags = this.prodParam.currentFlags()
    const prodParamToSet = PARAM_IN$1 & ~flags
    if (prodParamToSet) {
      this.prodParam.enter(flags | PARAM_IN$1)
      try {
        return callback()
      } finally {
        this.prodParam.exit()
      }
    }
    return callback()
  }
  disallowInAnd(callback) {
    const flags = this.prodParam.currentFlags()
    const prodParamToClear = PARAM_IN$1 & flags
    if (prodParamToClear) {
      this.prodParam.enter(flags & ~PARAM_IN$1)
      try {
        return callback()
      } finally {
        this.prodParam.exit()
      }
    }
    return callback()
  }
  registerTopicReference() {
    this.state.topicContext.maxTopicIndex = 0
  }
  topicReferenceIsAllowedInCurrentContext() {
    return this.state.topicContext.maxNumOfResolvableTopics >= 1
  }
  topicReferenceWasUsedInCurrentContext() {
    return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0
  }
  parseFSharpPipelineBody(prec) {
    const startPos = this.state.start
    const startLoc = this.state.startLoc
    this.state.potentialArrowAt = this.state.start
    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody
    this.state.inFSharpPipelineDirectBody = true
    const ret = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startPos, startLoc, prec)
    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody
    return ret
  }
  parseModuleExpression() {
    this.expectPlugin('moduleBlocks')
    const node2 = this.startNode()
    this.next()
    this.eat(5)
    const revertScopes = this.initializeScopes(true)
    this.enterInitialScopes()
    const program2 = this.startNode()
    try {
      node2.body = this.parseProgram(program2, 8, 'module')
    } finally {
      revertScopes()
    }
    this.eat(8)
    return this.finishNode(node2, 'ModuleExpression')
  }
  parsePropertyNamePrefixOperator(prop) {}
}
const loopLabel$1 = {
    kind: 'loop',
  },
  switchLabel$1 = {
    kind: 'switch',
  }
const FUNC_NO_FLAGS$1 = 0,
  FUNC_STATEMENT$1 = 1,
  FUNC_HANGING_STATEMENT$1 = 2,
  FUNC_NULLABLE_ID$1 = 4
const loneSurrogate$1 = /[\uD800-\uDFFF]/u
const keywordRelationalOperator$1 = /in(?:stanceof)?/y
function babel7CompatTokens$1(tokens, input) {
  for (let i = 0; i < tokens.length; i++) {
    const token = tokens[i]
    const { type } = token
    if (typeof type === 'number') {
      {
        if (type === 134) {
          const { loc, start, value, end } = token
          const hashEndPos = start + 1
          const hashEndLoc = createPositionWithColumnOffset$1(loc.start, 1)
          tokens.splice(
            i,
            1,
            new Token$1({
              type: getExportedToken$1(27),
              value: '#',
              start,
              end: hashEndPos,
              startLoc: loc.start,
              endLoc: hashEndLoc,
            }),
            new Token$1({
              type: getExportedToken$1(128),
              value,
              start: hashEndPos,
              end,
              startLoc: hashEndLoc,
              endLoc: loc.end,
            })
          )
          i++
          continue
        }
        if (tokenIsTemplate$1(type)) {
          const { loc, start, value, end } = token
          const backquoteEnd = start + 1
          const backquoteEndLoc = createPositionWithColumnOffset$1(loc.start, 1)
          let startToken
          if (input.charCodeAt(start) === 96) {
            startToken = new Token$1({
              type: getExportedToken$1(22),
              value: '`',
              start,
              end: backquoteEnd,
              startLoc: loc.start,
              endLoc: backquoteEndLoc,
            })
          } else {
            startToken = new Token$1({
              type: getExportedToken$1(8),
              value: '}',
              start,
              end: backquoteEnd,
              startLoc: loc.start,
              endLoc: backquoteEndLoc,
            })
          }
          let templateValue, templateElementEnd, templateElementEndLoc, endToken
          if (type === 24) {
            templateElementEnd = end - 1
            templateElementEndLoc = createPositionWithColumnOffset$1(loc.end, -1)
            templateValue = value === null ? null : value.slice(1, -1)
            endToken = new Token$1({
              type: getExportedToken$1(22),
              value: '`',
              start: templateElementEnd,
              end,
              startLoc: templateElementEndLoc,
              endLoc: loc.end,
            })
          } else {
            templateElementEnd = end - 2
            templateElementEndLoc = createPositionWithColumnOffset$1(loc.end, -2)
            templateValue = value === null ? null : value.slice(1, -2)
            endToken = new Token$1({
              type: getExportedToken$1(23),
              value: '${',
              start: templateElementEnd,
              end,
              startLoc: templateElementEndLoc,
              endLoc: loc.end,
            })
          }
          tokens.splice(
            i,
            1,
            startToken,
            new Token$1({
              type: getExportedToken$1(20),
              value: templateValue,
              start: backquoteEnd,
              end: templateElementEnd,
              startLoc: backquoteEndLoc,
              endLoc: templateElementEndLoc,
            }),
            endToken
          )
          i += 2
          continue
        }
      }
      token.type = getExportedToken$1(type)
    }
  }
  return tokens
}
class StatementParser$1 extends ExpressionParser$1 {
  parseTopLevel(file2, program2) {
    file2.program = this.parseProgram(program2)
    file2.comments = this.state.comments
    if (this.options.tokens) {
      file2.tokens = babel7CompatTokens$1(this.tokens, this.input)
    }
    return this.finishNode(file2, 'File')
  }
  parseProgram(program2, end = 135, sourceType = this.options.sourceType) {
    program2.sourceType = sourceType
    program2.interpreter = this.parseInterpreterDirective()
    this.parseBlockBody(program2, true, true, end)
    if (this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0) {
      for (const [localName, at] of Array.from(this.scope.undefinedExports)) {
        this.raise(Errors$1.ModuleExportUndefined, {
          at,
          localName,
        })
      }
    }
    return this.finishNode(program2, 'Program')
  }
  stmtToDirective(stmt) {
    const directive2 = stmt
    directive2.type = 'Directive'
    directive2.value = directive2.expression
    delete directive2.expression
    const directiveLiteral2 = directive2.value
    const expressionValue = directiveLiteral2.value
    const raw = this.input.slice(directiveLiteral2.start, directiveLiteral2.end)
    const val = (directiveLiteral2.value = raw.slice(1, -1))
    this.addExtra(directiveLiteral2, 'raw', raw)
    this.addExtra(directiveLiteral2, 'rawValue', val)
    this.addExtra(directiveLiteral2, 'expressionValue', expressionValue)
    directiveLiteral2.type = 'DirectiveLiteral'
    return directive2
  }
  parseInterpreterDirective() {
    if (!this.match(28)) {
      return null
    }
    const node2 = this.startNode()
    node2.value = this.state.value
    this.next()
    return this.finishNode(node2, 'InterpreterDirective')
  }
  isLet(context2) {
    if (!this.isContextual(99)) {
      return false
    }
    return this.isLetKeyword(context2)
  }
  isLetKeyword(context2) {
    const next = this.nextTokenStart()
    const nextCh = this.codePointAtPos(next)
    if (nextCh === 92 || nextCh === 91) {
      return true
    }
    if (context2) return false
    if (nextCh === 123) return true
    if (isIdentifierStart$1(nextCh)) {
      keywordRelationalOperator$1.lastIndex = next
      if (keywordRelationalOperator$1.test(this.input)) {
        const endCh = this.codePointAtPos(keywordRelationalOperator$1.lastIndex)
        if (!isIdentifierChar$1(endCh) && endCh !== 92) {
          return false
        }
      }
      return true
    }
    return false
  }
  parseStatement(context2, topLevel) {
    if (this.match(26)) {
      this.parseDecorators(true)
    }
    return this.parseStatementContent(context2, topLevel)
  }
  parseStatementContent(context2, topLevel) {
    let starttype = this.state.type
    const node2 = this.startNode()
    let kind
    if (this.isLet(context2)) {
      starttype = 74
      kind = 'let'
    }
    switch (starttype) {
      case 60:
        return this.parseBreakContinueStatement(node2, true)
      case 63:
        return this.parseBreakContinueStatement(node2, false)
      case 64:
        return this.parseDebuggerStatement(node2)
      case 90:
        return this.parseDoStatement(node2)
      case 91:
        return this.parseForStatement(node2)
      case 68:
        if (this.lookaheadCharCode() === 46) break
        if (context2) {
          if (this.state.strict) {
            this.raise(Errors$1.StrictFunction, {
              at: this.state.startLoc,
            })
          } else if (context2 !== 'if' && context2 !== 'label') {
            this.raise(Errors$1.SloppyFunction, {
              at: this.state.startLoc,
            })
          }
        }
        return this.parseFunctionStatement(node2, false, !context2)
      case 80:
        if (context2) this.unexpected()
        return this.parseClass(node2, true)
      case 69:
        return this.parseIfStatement(node2)
      case 70:
        return this.parseReturnStatement(node2)
      case 71:
        return this.parseSwitchStatement(node2)
      case 72:
        return this.parseThrowStatement(node2)
      case 73:
        return this.parseTryStatement(node2)
      case 75:
      case 74:
        kind = kind || this.state.value
        if (context2 && kind !== 'var') {
          this.raise(Errors$1.UnexpectedLexicalDeclaration, {
            at: this.state.startLoc,
          })
        }
        return this.parseVarStatement(node2, kind)
      case 92:
        return this.parseWhileStatement(node2)
      case 76:
        return this.parseWithStatement(node2)
      case 5:
        return this.parseBlock()
      case 13:
        return this.parseEmptyStatement(node2)
      case 83: {
        const nextTokenCharCode = this.lookaheadCharCode()
        if (nextTokenCharCode === 40 || nextTokenCharCode === 46) {
          break
        }
      }
      case 82: {
        if (!this.options.allowImportExportEverywhere && !topLevel) {
          this.raise(Errors$1.UnexpectedImportExport, {
            at: this.state.startLoc,
          })
        }
        this.next()
        let result
        if (starttype === 83) {
          result = this.parseImport(node2)
          if (result.type === 'ImportDeclaration' && (!result.importKind || result.importKind === 'value')) {
            this.sawUnambiguousESM = true
          }
        } else {
          result = this.parseExport(node2)
          if (
            (result.type === 'ExportNamedDeclaration' && (!result.exportKind || result.exportKind === 'value')) ||
            (result.type === 'ExportAllDeclaration' && (!result.exportKind || result.exportKind === 'value')) ||
            result.type === 'ExportDefaultDeclaration'
          ) {
            this.sawUnambiguousESM = true
          }
        }
        this.assertModuleNodeAllowed(node2)
        return result
      }
      default: {
        if (this.isAsyncFunction()) {
          if (context2) {
            this.raise(Errors$1.AsyncFunctionInSingleStatementContext, {
              at: this.state.startLoc,
            })
          }
          this.next()
          return this.parseFunctionStatement(node2, true, !context2)
        }
      }
    }
    const maybeName = this.state.value
    const expr = this.parseExpression()
    if (tokenIsIdentifier$1(starttype) && expr.type === 'Identifier' && this.eat(14)) {
      return this.parseLabeledStatement(node2, maybeName, expr, context2)
    } else {
      return this.parseExpressionStatement(node2, expr)
    }
  }
  assertModuleNodeAllowed(node2) {
    if (!this.options.allowImportExportEverywhere && !this.inModule) {
      this.raise(Errors$1.ImportOutsideModule, {
        at: node2,
      })
    }
  }
  takeDecorators(node2) {
    const decorators = this.state.decoratorStack[this.state.decoratorStack.length - 1]
    if (decorators.length) {
      node2.decorators = decorators
      this.resetStartLocationFromNode(node2, decorators[0])
      this.state.decoratorStack[this.state.decoratorStack.length - 1] = []
    }
  }
  canHaveLeadingDecorator() {
    return this.match(80)
  }
  parseDecorators(allowExport) {
    const currentContextDecorators = this.state.decoratorStack[this.state.decoratorStack.length - 1]
    while (this.match(26)) {
      const decorator2 = this.parseDecorator()
      currentContextDecorators.push(decorator2)
    }
    if (this.match(82)) {
      if (!allowExport) {
        this.unexpected()
      }
      if (this.hasPlugin('decorators') && !this.getPluginOption('decorators', 'decoratorsBeforeExport')) {
        this.raise(Errors$1.DecoratorExportClass, {
          at: this.state.startLoc,
        })
      }
    } else if (!this.canHaveLeadingDecorator()) {
      throw this.raise(Errors$1.UnexpectedLeadingDecorator, {
        at: this.state.startLoc,
      })
    }
  }
  parseDecorator() {
    this.expectOnePlugin(['decorators-legacy', 'decorators'])
    const node2 = this.startNode()
    this.next()
    if (this.hasPlugin('decorators')) {
      this.state.decoratorStack.push([])
      const startPos = this.state.start
      const startLoc = this.state.startLoc
      let expr
      if (this.match(10)) {
        const startPos2 = this.state.start
        const startLoc2 = this.state.startLoc
        this.next()
        expr = this.parseExpression()
        this.expect(11)
        expr = this.wrapParenthesis(startPos2, startLoc2, expr)
      } else {
        expr = this.parseIdentifier(false)
        while (this.eat(16)) {
          const node3 = this.startNodeAt(startPos, startLoc)
          node3.object = expr
          node3.property = this.parseIdentifier(true)
          node3.computed = false
          expr = this.finishNode(node3, 'MemberExpression')
        }
      }
      node2.expression = this.parseMaybeDecoratorArguments(expr)
      this.state.decoratorStack.pop()
    } else {
      node2.expression = this.parseExprSubscripts()
    }
    return this.finishNode(node2, 'Decorator')
  }
  parseMaybeDecoratorArguments(expr) {
    if (this.eat(10)) {
      const node2 = this.startNodeAtNode(expr)
      node2.callee = expr
      node2.arguments = this.parseCallExpressionArguments(11, false)
      this.toReferencedList(node2.arguments)
      return this.finishNode(node2, 'CallExpression')
    }
    return expr
  }
  parseBreakContinueStatement(node2, isBreak) {
    this.next()
    if (this.isLineTerminator()) {
      node2.label = null
    } else {
      node2.label = this.parseIdentifier()
      this.semicolon()
    }
    this.verifyBreakContinue(node2, isBreak)
    return this.finishNode(node2, isBreak ? 'BreakStatement' : 'ContinueStatement')
  }
  verifyBreakContinue(node2, isBreak) {
    let i
    for (i = 0; i < this.state.labels.length; ++i) {
      const lab = this.state.labels[i]
      if (node2.label == null || lab.name === node2.label.name) {
        if (lab.kind != null && (isBreak || lab.kind === 'loop')) break
        if (node2.label && isBreak) break
      }
    }
    if (i === this.state.labels.length) {
      const type = isBreak ? 'BreakStatement' : 'ContinueStatement'
      this.raise(Errors$1.IllegalBreakContinue, {
        at: node2,
        type,
      })
    }
  }
  parseDebuggerStatement(node2) {
    this.next()
    this.semicolon()
    return this.finishNode(node2, 'DebuggerStatement')
  }
  parseHeaderExpression() {
    this.expect(10)
    const val = this.parseExpression()
    this.expect(11)
    return val
  }
  parseDoStatement(node2) {
    this.next()
    this.state.labels.push(loopLabel$1)
    node2.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement('do'))
    this.state.labels.pop()
    this.expect(92)
    node2.test = this.parseHeaderExpression()
    this.eat(13)
    return this.finishNode(node2, 'DoWhileStatement')
  }
  parseForStatement(node2) {
    this.next()
    this.state.labels.push(loopLabel$1)
    let awaitAt = null
    if (this.isAwaitAllowed() && this.eatContextual(96)) {
      awaitAt = this.state.lastTokStartLoc
    }
    this.scope.enter(SCOPE_OTHER$1)
    this.expect(10)
    if (this.match(13)) {
      if (awaitAt !== null) {
        this.unexpected(awaitAt)
      }
      return this.parseFor(node2, null)
    }
    const startsWithLet = this.isContextual(99)
    const isLet2 = startsWithLet && this.isLetKeyword()
    if (this.match(74) || this.match(75) || isLet2) {
      const init2 = this.startNode()
      const kind = isLet2 ? 'let' : this.state.value
      this.next()
      this.parseVar(init2, true, kind)
      this.finishNode(init2, 'VariableDeclaration')
      if ((this.match(58) || this.isContextual(101)) && init2.declarations.length === 1) {
        return this.parseForIn(node2, init2, awaitAt)
      }
      if (awaitAt !== null) {
        this.unexpected(awaitAt)
      }
      return this.parseFor(node2, init2)
    }
    const startsWithAsync = this.isContextual(95)
    const refExpressionErrors = new ExpressionErrors$1()
    const init = this.parseExpression(true, refExpressionErrors)
    const isForOf = this.isContextual(101)
    if (isForOf) {
      if (startsWithLet) {
        this.raise(Errors$1.ForOfLet, {
          at: init,
        })
      }
      if (awaitAt === null && startsWithAsync && init.type === 'Identifier') {
        this.raise(Errors$1.ForOfAsync, {
          at: init,
        })
      }
    }
    if (isForOf || this.match(58)) {
      this.checkDestructuringPrivate(refExpressionErrors)
      this.toAssignable(init, true)
      const type = isForOf ? 'ForOfStatement' : 'ForInStatement'
      this.checkLVal(init, {
        in: {
          type,
        },
      })
      return this.parseForIn(node2, init, awaitAt)
    } else {
      this.checkExpressionErrors(refExpressionErrors, true)
    }
    if (awaitAt !== null) {
      this.unexpected(awaitAt)
    }
    return this.parseFor(node2, init)
  }
  parseFunctionStatement(node2, isAsync, declarationPosition) {
    this.next()
    return this.parseFunction(node2, FUNC_STATEMENT$1 | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT$1), isAsync)
  }
  parseIfStatement(node2) {
    this.next()
    node2.test = this.parseHeaderExpression()
    node2.consequent = this.parseStatement('if')
    node2.alternate = this.eat(66) ? this.parseStatement('if') : null
    return this.finishNode(node2, 'IfStatement')
  }
  parseReturnStatement(node2) {
    if (!this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction) {
      this.raise(Errors$1.IllegalReturn, {
        at: this.state.startLoc,
      })
    }
    this.next()
    if (this.isLineTerminator()) {
      node2.argument = null
    } else {
      node2.argument = this.parseExpression()
      this.semicolon()
    }
    return this.finishNode(node2, 'ReturnStatement')
  }
  parseSwitchStatement(node2) {
    this.next()
    node2.discriminant = this.parseHeaderExpression()
    const cases = (node2.cases = [])
    this.expect(5)
    this.state.labels.push(switchLabel$1)
    this.scope.enter(SCOPE_OTHER$1)
    let cur
    for (let sawDefault; !this.match(8); ) {
      if (this.match(61) || this.match(65)) {
        const isCase = this.match(61)
        if (cur) this.finishNode(cur, 'SwitchCase')
        cases.push((cur = this.startNode()))
        cur.consequent = []
        this.next()
        if (isCase) {
          cur.test = this.parseExpression()
        } else {
          if (sawDefault) {
            this.raise(Errors$1.MultipleDefaultsInSwitch, {
              at: this.state.lastTokStartLoc,
            })
          }
          sawDefault = true
          cur.test = null
        }
        this.expect(14)
      } else {
        if (cur) {
          cur.consequent.push(this.parseStatement(null))
        } else {
          this.unexpected()
        }
      }
    }
    this.scope.exit()
    if (cur) this.finishNode(cur, 'SwitchCase')
    this.next()
    this.state.labels.pop()
    return this.finishNode(node2, 'SwitchStatement')
  }
  parseThrowStatement(node2) {
    this.next()
    if (this.hasPrecedingLineBreak()) {
      this.raise(Errors$1.NewlineAfterThrow, {
        at: this.state.lastTokEndLoc,
      })
    }
    node2.argument = this.parseExpression()
    this.semicolon()
    return this.finishNode(node2, 'ThrowStatement')
  }
  parseCatchClauseParam() {
    const param = this.parseBindingAtom()
    const simple = param.type === 'Identifier'
    this.scope.enter(simple ? SCOPE_SIMPLE_CATCH$1 : 0)
    this.checkLVal(param, {
      in: {
        type: 'CatchClause',
      },
      binding: BIND_LEXICAL$1,
      allowingSloppyLetBinding: true,
    })
    return param
  }
  parseTryStatement(node2) {
    this.next()
    node2.block = this.parseBlock()
    node2.handler = null
    if (this.match(62)) {
      const clause = this.startNode()
      this.next()
      if (this.match(10)) {
        this.expect(10)
        clause.param = this.parseCatchClauseParam()
        this.expect(11)
      } else {
        clause.param = null
        this.scope.enter(SCOPE_OTHER$1)
      }
      clause.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(false, false))
      this.scope.exit()
      node2.handler = this.finishNode(clause, 'CatchClause')
    }
    node2.finalizer = this.eat(67) ? this.parseBlock() : null
    if (!node2.handler && !node2.finalizer) {
      this.raise(Errors$1.NoCatchOrFinally, {
        at: node2,
      })
    }
    return this.finishNode(node2, 'TryStatement')
  }
  parseVarStatement(node2, kind, allowMissingInitializer = false) {
    this.next()
    this.parseVar(node2, false, kind, allowMissingInitializer)
    this.semicolon()
    return this.finishNode(node2, 'VariableDeclaration')
  }
  parseWhileStatement(node2) {
    this.next()
    node2.test = this.parseHeaderExpression()
    this.state.labels.push(loopLabel$1)
    node2.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement('while'))
    this.state.labels.pop()
    return this.finishNode(node2, 'WhileStatement')
  }
  parseWithStatement(node2) {
    if (this.state.strict) {
      this.raise(Errors$1.StrictWith, {
        at: this.state.startLoc,
      })
    }
    this.next()
    node2.object = this.parseHeaderExpression()
    node2.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement('with'))
    return this.finishNode(node2, 'WithStatement')
  }
  parseEmptyStatement(node2) {
    this.next()
    return this.finishNode(node2, 'EmptyStatement')
  }
  parseLabeledStatement(node2, maybeName, expr, context2) {
    for (const label of this.state.labels) {
      if (label.name === maybeName) {
        this.raise(Errors$1.LabelRedeclaration, {
          at: expr,
          labelName: maybeName,
        })
      }
    }
    const kind = tokenIsLoop$1(this.state.type) ? 'loop' : this.match(71) ? 'switch' : null
    for (let i = this.state.labels.length - 1; i >= 0; i--) {
      const label = this.state.labels[i]
      if (label.statementStart === node2.start) {
        label.statementStart = this.state.start
        label.kind = kind
      } else {
        break
      }
    }
    this.state.labels.push({
      name: maybeName,
      kind,
      statementStart: this.state.start,
    })
    node2.body = this.parseStatement(
      context2 ? (context2.indexOf('label') === -1 ? context2 + 'label' : context2) : 'label'
    )
    this.state.labels.pop()
    node2.label = expr
    return this.finishNode(node2, 'LabeledStatement')
  }
  parseExpressionStatement(node2, expr) {
    node2.expression = expr
    this.semicolon()
    return this.finishNode(node2, 'ExpressionStatement')
  }
  parseBlock(allowDirectives = false, createNewLexicalScope = true, afterBlockParse) {
    const node2 = this.startNode()
    if (allowDirectives) {
      this.state.strictErrors.clear()
    }
    this.expect(5)
    if (createNewLexicalScope) {
      this.scope.enter(SCOPE_OTHER$1)
    }
    this.parseBlockBody(node2, allowDirectives, false, 8, afterBlockParse)
    if (createNewLexicalScope) {
      this.scope.exit()
    }
    return this.finishNode(node2, 'BlockStatement')
  }
  isValidDirective(stmt) {
    return (
      stmt.type === 'ExpressionStatement' &&
      stmt.expression.type === 'StringLiteral' &&
      !stmt.expression.extra.parenthesized
    )
  }
  parseBlockBody(node2, allowDirectives, topLevel, end, afterBlockParse) {
    const body = (node2.body = [])
    const directives = (node2.directives = [])
    this.parseBlockOrModuleBlockBody(body, allowDirectives ? directives : void 0, topLevel, end, afterBlockParse)
  }
  parseBlockOrModuleBlockBody(body, directives, topLevel, end, afterBlockParse) {
    const oldStrict = this.state.strict
    let hasStrictModeDirective = false
    let parsedNonDirective = false
    while (!this.match(end)) {
      const stmt = this.parseStatement(null, topLevel)
      if (directives && !parsedNonDirective) {
        if (this.isValidDirective(stmt)) {
          const directive2 = this.stmtToDirective(stmt)
          directives.push(directive2)
          if (!hasStrictModeDirective && directive2.value.value === 'use strict') {
            hasStrictModeDirective = true
            this.setStrict(true)
          }
          continue
        }
        parsedNonDirective = true
        this.state.strictErrors.clear()
      }
      body.push(stmt)
    }
    if (afterBlockParse) {
      afterBlockParse.call(this, hasStrictModeDirective)
    }
    if (!oldStrict) {
      this.setStrict(false)
    }
    this.next()
  }
  parseFor(node2, init) {
    node2.init = init
    this.semicolon(false)
    node2.test = this.match(13) ? null : this.parseExpression()
    this.semicolon(false)
    node2.update = this.match(11) ? null : this.parseExpression()
    this.expect(11)
    node2.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement('for'))
    this.scope.exit()
    this.state.labels.pop()
    return this.finishNode(node2, 'ForStatement')
  }
  parseForIn(node2, init, awaitAt) {
    const isForIn = this.match(58)
    this.next()
    if (isForIn) {
      if (awaitAt !== null) this.unexpected(awaitAt)
    } else {
      node2.await = awaitAt !== null
    }
    if (
      init.type === 'VariableDeclaration' &&
      init.declarations[0].init != null &&
      (!isForIn || this.state.strict || init.kind !== 'var' || init.declarations[0].id.type !== 'Identifier')
    ) {
      this.raise(Errors$1.ForInOfLoopInitializer, {
        at: init,
        type: isForIn ? 'ForInStatement' : 'ForOfStatement',
      })
    }
    if (init.type === 'AssignmentPattern') {
      this.raise(Errors$1.InvalidLhs, {
        at: init,
        ancestor: {
          type: 'ForStatement',
        },
      })
    }
    node2.left = init
    node2.right = isForIn ? this.parseExpression() : this.parseMaybeAssignAllowIn()
    this.expect(11)
    node2.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement('for'))
    this.scope.exit()
    this.state.labels.pop()
    return this.finishNode(node2, isForIn ? 'ForInStatement' : 'ForOfStatement')
  }
  parseVar(node2, isFor2, kind, allowMissingInitializer = false) {
    const declarations = (node2.declarations = [])
    node2.kind = kind
    for (;;) {
      const decl = this.startNode()
      this.parseVarId(decl, kind)
      decl.init = !this.eat(29) ? null : isFor2 ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn()
      if (decl.init === null && !allowMissingInitializer) {
        if (decl.id.type !== 'Identifier' && !(isFor2 && (this.match(58) || this.isContextual(101)))) {
          this.raise(Errors$1.DeclarationMissingInitializer, {
            at: this.state.lastTokEndLoc,
            kind: 'destructuring',
          })
        } else if (kind === 'const' && !(this.match(58) || this.isContextual(101))) {
          this.raise(Errors$1.DeclarationMissingInitializer, {
            at: this.state.lastTokEndLoc,
            kind: 'const',
          })
        }
      }
      declarations.push(this.finishNode(decl, 'VariableDeclarator'))
      if (!this.eat(12)) break
    }
    return node2
  }
  parseVarId(decl, kind) {
    decl.id = this.parseBindingAtom()
    this.checkLVal(decl.id, {
      in: {
        type: 'VariableDeclarator',
      },
      binding: kind === 'var' ? BIND_VAR$1 : BIND_LEXICAL$1,
    })
  }
  parseFunction(node2, statement2 = FUNC_NO_FLAGS$1, isAsync = false) {
    const isStatement2 = statement2 & FUNC_STATEMENT$1
    const isHangingStatement = statement2 & FUNC_HANGING_STATEMENT$1
    const requireId = !!isStatement2 && !(statement2 & FUNC_NULLABLE_ID$1)
    this.initFunction(node2, isAsync)
    if (this.match(55) && isHangingStatement) {
      this.raise(Errors$1.GeneratorInSingleStatementContext, {
        at: this.state.startLoc,
      })
    }
    node2.generator = this.eat(55)
    if (isStatement2) {
      node2.id = this.parseFunctionId(requireId)
    }
    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters
    this.state.maybeInArrowParameters = false
    this.scope.enter(SCOPE_FUNCTION$1)
    this.prodParam.enter(functionFlags$1(isAsync, node2.generator))
    if (!isStatement2) {
      node2.id = this.parseFunctionId()
    }
    this.parseFunctionParams(node2, false)
    this.withSmartMixTopicForbiddingContext(() => {
      this.parseFunctionBodyAndFinish(node2, isStatement2 ? 'FunctionDeclaration' : 'FunctionExpression')
    })
    this.prodParam.exit()
    this.scope.exit()
    if (isStatement2 && !isHangingStatement) {
      this.registerFunctionStatementId(node2)
    }
    this.state.maybeInArrowParameters = oldMaybeInArrowParameters
    return node2
  }
  parseFunctionId(requireId) {
    return requireId || tokenIsIdentifier$1(this.state.type) ? this.parseIdentifier() : null
  }
  parseFunctionParams(node2, allowModifiers) {
    this.expect(10)
    this.expressionScope.enter(newParameterDeclarationScope$1())
    node2.params = this.parseBindingList(11, 41, false, allowModifiers)
    this.expressionScope.exit()
  }
  registerFunctionStatementId(node2) {
    if (!node2.id) return
    this.scope.declareName(
      node2.id.name,
      this.state.strict || node2.generator || node2.async
        ? this.scope.treatFunctionsAsVar
          ? BIND_VAR$1
          : BIND_LEXICAL$1
        : BIND_FUNCTION$1,
      node2.id.loc.start
    )
  }
  parseClass(node2, isStatement2, optionalId) {
    this.next()
    this.takeDecorators(node2)
    const oldStrict = this.state.strict
    this.state.strict = true
    this.parseClassId(node2, isStatement2, optionalId)
    this.parseClassSuper(node2)
    node2.body = this.parseClassBody(!!node2.superClass, oldStrict)
    return this.finishNode(node2, isStatement2 ? 'ClassDeclaration' : 'ClassExpression')
  }
  isClassProperty() {
    return this.match(29) || this.match(13) || this.match(8)
  }
  isClassMethod() {
    return this.match(10)
  }
  isNonstaticConstructor(method) {
    return (
      !method.computed && !method.static && (method.key.name === 'constructor' || method.key.value === 'constructor')
    )
  }
  parseClassBody(hadSuperClass, oldStrict) {
    this.classScope.enter()
    const state = {
      hadConstructor: false,
      hadSuperClass,
    }
    let decorators = []
    const classBody2 = this.startNode()
    classBody2.body = []
    this.expect(5)
    this.withSmartMixTopicForbiddingContext(() => {
      while (!this.match(8)) {
        if (this.eat(13)) {
          if (decorators.length > 0) {
            throw this.raise(Errors$1.DecoratorSemicolon, {
              at: this.state.lastTokEndLoc,
            })
          }
          continue
        }
        if (this.match(26)) {
          decorators.push(this.parseDecorator())
          continue
        }
        const member = this.startNode()
        if (decorators.length) {
          member.decorators = decorators
          this.resetStartLocationFromNode(member, decorators[0])
          decorators = []
        }
        this.parseClassMember(classBody2, member, state)
        if (member.kind === 'constructor' && member.decorators && member.decorators.length > 0) {
          this.raise(Errors$1.DecoratorConstructor, {
            at: member,
          })
        }
      }
    })
    this.state.strict = oldStrict
    this.next()
    if (decorators.length) {
      throw this.raise(Errors$1.TrailingDecorator, {
        at: this.state.startLoc,
      })
    }
    this.classScope.exit()
    return this.finishNode(classBody2, 'ClassBody')
  }
  parseClassMemberFromModifier(classBody2, member) {
    const key = this.parseIdentifier(true)
    if (this.isClassMethod()) {
      const method = member
      method.kind = 'method'
      method.computed = false
      method.key = key
      method.static = false
      this.pushClassMethod(classBody2, method, false, false, false, false)
      return true
    } else if (this.isClassProperty()) {
      const prop = member
      prop.computed = false
      prop.key = key
      prop.static = false
      classBody2.body.push(this.parseClassProperty(prop))
      return true
    }
    this.resetPreviousNodeTrailingComments(key)
    return false
  }
  parseClassMember(classBody2, member, state) {
    const isStatic2 = this.isContextual(104)
    if (isStatic2) {
      if (this.parseClassMemberFromModifier(classBody2, member)) {
        return
      }
      if (this.eat(5)) {
        this.parseClassStaticBlock(classBody2, member)
        return
      }
    }
    this.parseClassMemberWithIsStatic(classBody2, member, state, isStatic2)
  }
  parseClassMemberWithIsStatic(classBody2, member, state, isStatic2) {
    const publicMethod = member
    const privateMethod = member
    const publicProp = member
    const privateProp = member
    const accessorProp = member
    const method = publicMethod
    const publicMember = publicMethod
    member.static = isStatic2
    this.parsePropertyNamePrefixOperator(member)
    if (this.eat(55)) {
      method.kind = 'method'
      const isPrivateName2 = this.match(134)
      this.parseClassElementName(method)
      if (isPrivateName2) {
        this.pushClassPrivateMethod(classBody2, privateMethod, true, false)
        return
      }
      if (this.isNonstaticConstructor(publicMethod)) {
        this.raise(Errors$1.ConstructorIsGenerator, {
          at: publicMethod.key,
        })
      }
      this.pushClassMethod(classBody2, publicMethod, true, false, false, false)
      return
    }
    const isContextual = tokenIsIdentifier$1(this.state.type) && !this.state.containsEsc
    const isPrivate2 = this.match(134)
    const key = this.parseClassElementName(member)
    const maybeQuestionTokenStartLoc = this.state.startLoc
    this.parsePostMemberNameModifiers(publicMember)
    if (this.isClassMethod()) {
      method.kind = 'method'
      if (isPrivate2) {
        this.pushClassPrivateMethod(classBody2, privateMethod, false, false)
        return
      }
      const isConstructor = this.isNonstaticConstructor(publicMethod)
      let allowsDirectSuper = false
      if (isConstructor) {
        publicMethod.kind = 'constructor'
        if (state.hadConstructor && !this.hasPlugin('typescript')) {
          this.raise(Errors$1.DuplicateConstructor, {
            at: key,
          })
        }
        if (isConstructor && this.hasPlugin('typescript') && member.override) {
          this.raise(Errors$1.OverrideOnConstructor, {
            at: key,
          })
        }
        state.hadConstructor = true
        allowsDirectSuper = state.hadSuperClass
      }
      this.pushClassMethod(classBody2, publicMethod, false, false, isConstructor, allowsDirectSuper)
    } else if (this.isClassProperty()) {
      if (isPrivate2) {
        this.pushClassPrivateProperty(classBody2, privateProp)
      } else {
        this.pushClassProperty(classBody2, publicProp)
      }
    } else if (isContextual && key.name === 'async' && !this.isLineTerminator()) {
      this.resetPreviousNodeTrailingComments(key)
      const isGenerator = this.eat(55)
      if (publicMember.optional) {
        this.unexpected(maybeQuestionTokenStartLoc)
      }
      method.kind = 'method'
      const isPrivate3 = this.match(134)
      this.parseClassElementName(method)
      this.parsePostMemberNameModifiers(publicMember)
      if (isPrivate3) {
        this.pushClassPrivateMethod(classBody2, privateMethod, isGenerator, true)
      } else {
        if (this.isNonstaticConstructor(publicMethod)) {
          this.raise(Errors$1.ConstructorIsAsync, {
            at: publicMethod.key,
          })
        }
        this.pushClassMethod(classBody2, publicMethod, isGenerator, true, false, false)
      }
    } else if (
      isContextual &&
      (key.name === 'get' || key.name === 'set') &&
      !(this.match(55) && this.isLineTerminator())
    ) {
      this.resetPreviousNodeTrailingComments(key)
      method.kind = key.name
      const isPrivate3 = this.match(134)
      this.parseClassElementName(publicMethod)
      if (isPrivate3) {
        this.pushClassPrivateMethod(classBody2, privateMethod, false, false)
      } else {
        if (this.isNonstaticConstructor(publicMethod)) {
          this.raise(Errors$1.ConstructorIsAccessor, {
            at: publicMethod.key,
          })
        }
        this.pushClassMethod(classBody2, publicMethod, false, false, false, false)
      }
      this.checkGetterSetterParams(publicMethod)
    } else if (isContextual && key.name === 'accessor' && !this.isLineTerminator()) {
      this.expectPlugin('decoratorAutoAccessors')
      this.resetPreviousNodeTrailingComments(key)
      const isPrivate3 = this.match(134)
      this.parseClassElementName(publicProp)
      this.pushClassAccessorProperty(classBody2, accessorProp, isPrivate3)
    } else if (this.isLineTerminator()) {
      if (isPrivate2) {
        this.pushClassPrivateProperty(classBody2, privateProp)
      } else {
        this.pushClassProperty(classBody2, publicProp)
      }
    } else {
      this.unexpected()
    }
  }
  parseClassElementName(member) {
    const { type, value } = this.state
    if ((type === 128 || type === 129) && member.static && value === 'prototype') {
      this.raise(Errors$1.StaticPrototype, {
        at: this.state.startLoc,
      })
    }
    if (type === 134) {
      if (value === 'constructor') {
        this.raise(Errors$1.ConstructorClassPrivateField, {
          at: this.state.startLoc,
        })
      }
      const key = this.parsePrivateName()
      member.key = key
      return key
    }
    return this.parsePropertyName(member)
  }
  parseClassStaticBlock(classBody2, member) {
    var _member$decorators
    this.scope.enter(SCOPE_CLASS$1 | SCOPE_STATIC_BLOCK$1 | SCOPE_SUPER$1)
    const oldLabels = this.state.labels
    this.state.labels = []
    this.prodParam.enter(PARAM$1)
    const body = (member.body = [])
    this.parseBlockOrModuleBlockBody(body, void 0, false, 8)
    this.prodParam.exit()
    this.scope.exit()
    this.state.labels = oldLabels
    classBody2.body.push(this.finishNode(member, 'StaticBlock'))
    if ((_member$decorators = member.decorators) != null && _member$decorators.length) {
      this.raise(Errors$1.DecoratorStaticBlock, {
        at: member,
      })
    }
  }
  pushClassProperty(classBody2, prop) {
    if (!prop.computed && (prop.key.name === 'constructor' || prop.key.value === 'constructor')) {
      this.raise(Errors$1.ConstructorClassField, {
        at: prop.key,
      })
    }
    classBody2.body.push(this.parseClassProperty(prop))
  }
  pushClassPrivateProperty(classBody2, prop) {
    const node2 = this.parseClassPrivateProperty(prop)
    classBody2.body.push(node2)
    this.classScope.declarePrivateName(this.getPrivateNameSV(node2.key), CLASS_ELEMENT_OTHER$1, node2.key.loc.start)
  }
  pushClassAccessorProperty(classBody2, prop, isPrivate2) {
    if (!isPrivate2 && !prop.computed) {
      const key = prop.key
      if (key.name === 'constructor' || key.value === 'constructor') {
        this.raise(Errors$1.ConstructorClassField, {
          at: key,
        })
      }
    }
    const node2 = this.parseClassAccessorProperty(prop)
    classBody2.body.push(node2)
    if (isPrivate2) {
      this.classScope.declarePrivateName(this.getPrivateNameSV(node2.key), CLASS_ELEMENT_OTHER$1, node2.key.loc.start)
    }
  }
  pushClassMethod(classBody2, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
    classBody2.body.push(
      this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, 'ClassMethod', true)
    )
  }
  pushClassPrivateMethod(classBody2, method, isGenerator, isAsync) {
    const node2 = this.parseMethod(method, isGenerator, isAsync, false, false, 'ClassPrivateMethod', true)
    classBody2.body.push(node2)
    const kind =
      node2.kind === 'get'
        ? node2.static
          ? CLASS_ELEMENT_STATIC_GETTER$1
          : CLASS_ELEMENT_INSTANCE_GETTER$1
        : node2.kind === 'set'
        ? node2.static
          ? CLASS_ELEMENT_STATIC_SETTER$1
          : CLASS_ELEMENT_INSTANCE_SETTER$1
        : CLASS_ELEMENT_OTHER$1
    this.declareClassPrivateMethodInScope(node2, kind)
  }
  declareClassPrivateMethodInScope(node2, kind) {
    this.classScope.declarePrivateName(this.getPrivateNameSV(node2.key), kind, node2.key.loc.start)
  }
  parsePostMemberNameModifiers(methodOrProp) {}
  parseClassPrivateProperty(node2) {
    this.parseInitializer(node2)
    this.semicolon()
    return this.finishNode(node2, 'ClassPrivateProperty')
  }
  parseClassProperty(node2) {
    this.parseInitializer(node2)
    this.semicolon()
    return this.finishNode(node2, 'ClassProperty')
  }
  parseClassAccessorProperty(node2) {
    this.parseInitializer(node2)
    this.semicolon()
    return this.finishNode(node2, 'ClassAccessorProperty')
  }
  parseInitializer(node2) {
    this.scope.enter(SCOPE_CLASS$1 | SCOPE_SUPER$1)
    this.expressionScope.enter(newExpressionScope$1())
    this.prodParam.enter(PARAM$1)
    node2.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null
    this.expressionScope.exit()
    this.prodParam.exit()
    this.scope.exit()
  }
  parseClassId(node2, isStatement2, optionalId, bindingType = BIND_CLASS$1) {
    if (tokenIsIdentifier$1(this.state.type)) {
      node2.id = this.parseIdentifier()
      if (isStatement2) {
        this.declareNameFromIdentifier(node2.id, bindingType)
      }
    } else {
      if (optionalId || !isStatement2) {
        node2.id = null
      } else {
        throw this.raise(Errors$1.MissingClassName, {
          at: this.state.startLoc,
        })
      }
    }
  }
  parseClassSuper(node2) {
    node2.superClass = this.eat(81) ? this.parseExprSubscripts() : null
  }
  parseExport(node2) {
    const hasDefault = this.maybeParseExportDefaultSpecifier(node2)
    const parseAfterDefault = !hasDefault || this.eat(12)
    const hasStar = parseAfterDefault && this.eatExportStar(node2)
    const hasNamespace = hasStar && this.maybeParseExportNamespaceSpecifier(node2)
    const parseAfterNamespace = parseAfterDefault && (!hasNamespace || this.eat(12))
    const isFromRequired = hasDefault || hasStar
    if (hasStar && !hasNamespace) {
      if (hasDefault) this.unexpected()
      this.parseExportFrom(node2, true)
      return this.finishNode(node2, 'ExportAllDeclaration')
    }
    const hasSpecifiers = this.maybeParseExportNamedSpecifiers(node2)
    if (
      (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers) ||
      (hasNamespace && parseAfterNamespace && !hasSpecifiers)
    ) {
      throw this.unexpected(null, 5)
    }
    let hasDeclaration
    if (isFromRequired || hasSpecifiers) {
      hasDeclaration = false
      this.parseExportFrom(node2, isFromRequired)
    } else {
      hasDeclaration = this.maybeParseExportDeclaration(node2)
    }
    if (isFromRequired || hasSpecifiers || hasDeclaration) {
      this.checkExport(node2, true, false, !!node2.source)
      return this.finishNode(node2, 'ExportNamedDeclaration')
    }
    if (this.eat(65)) {
      node2.declaration = this.parseExportDefaultExpression()
      this.checkExport(node2, true, true)
      return this.finishNode(node2, 'ExportDefaultDeclaration')
    }
    throw this.unexpected(null, 5)
  }
  eatExportStar(node2) {
    return this.eat(55)
  }
  maybeParseExportDefaultSpecifier(node2) {
    if (this.isExportDefaultSpecifier()) {
      this.expectPlugin('exportDefaultFrom')
      const specifier = this.startNode()
      specifier.exported = this.parseIdentifier(true)
      node2.specifiers = [this.finishNode(specifier, 'ExportDefaultSpecifier')]
      return true
    }
    return false
  }
  maybeParseExportNamespaceSpecifier(node2) {
    if (this.isContextual(93)) {
      if (!node2.specifiers) node2.specifiers = []
      const specifier = this.startNodeAt(this.state.lastTokStart, this.state.lastTokStartLoc)
      this.next()
      specifier.exported = this.parseModuleExportName()
      node2.specifiers.push(this.finishNode(specifier, 'ExportNamespaceSpecifier'))
      return true
    }
    return false
  }
  maybeParseExportNamedSpecifiers(node2) {
    if (this.match(5)) {
      if (!node2.specifiers) node2.specifiers = []
      const isTypeExport = node2.exportKind === 'type'
      node2.specifiers.push(...this.parseExportSpecifiers(isTypeExport))
      node2.source = null
      node2.declaration = null
      if (this.hasPlugin('importAssertions')) {
        node2.assertions = []
      }
      return true
    }
    return false
  }
  maybeParseExportDeclaration(node2) {
    if (this.shouldParseExportDeclaration()) {
      node2.specifiers = []
      node2.source = null
      if (this.hasPlugin('importAssertions')) {
        node2.assertions = []
      }
      node2.declaration = this.parseExportDeclaration(node2)
      return true
    }
    return false
  }
  isAsyncFunction() {
    if (!this.isContextual(95)) return false
    const next = this.nextTokenStart()
    return !lineBreak$1.test(this.input.slice(this.state.pos, next)) && this.isUnparsedContextual(next, 'function')
  }
  parseExportDefaultExpression() {
    const expr = this.startNode()
    const isAsync = this.isAsyncFunction()
    if (this.match(68) || isAsync) {
      this.next()
      if (isAsync) {
        this.next()
      }
      return this.parseFunction(expr, FUNC_STATEMENT$1 | FUNC_NULLABLE_ID$1, isAsync)
    }
    if (this.match(80)) {
      return this.parseClass(expr, true, true)
    }
    if (this.match(26)) {
      if (this.hasPlugin('decorators') && this.getPluginOption('decorators', 'decoratorsBeforeExport')) {
        this.raise(Errors$1.DecoratorBeforeExport, {
          at: this.state.startLoc,
        })
      }
      this.parseDecorators(false)
      return this.parseClass(expr, true, true)
    }
    if (this.match(75) || this.match(74) || this.isLet()) {
      throw this.raise(Errors$1.UnsupportedDefaultExport, {
        at: this.state.startLoc,
      })
    }
    const res = this.parseMaybeAssignAllowIn()
    this.semicolon()
    return res
  }
  parseExportDeclaration(node2) {
    return this.parseStatement(null)
  }
  isExportDefaultSpecifier() {
    const { type } = this.state
    if (tokenIsIdentifier$1(type)) {
      if ((type === 95 && !this.state.containsEsc) || type === 99) {
        return false
      }
      if ((type === 126 || type === 125) && !this.state.containsEsc) {
        const { type: nextType } = this.lookahead()
        if ((tokenIsIdentifier$1(nextType) && nextType !== 97) || nextType === 5) {
          this.expectOnePlugin(['flow', 'typescript'])
          return false
        }
      }
    } else if (!this.match(65)) {
      return false
    }
    const next = this.nextTokenStart()
    const hasFrom = this.isUnparsedContextual(next, 'from')
    if (this.input.charCodeAt(next) === 44 || (tokenIsIdentifier$1(this.state.type) && hasFrom)) {
      return true
    }
    if (this.match(65) && hasFrom) {
      const nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next + 4))
      return nextAfterFrom === 34 || nextAfterFrom === 39
    }
    return false
  }
  parseExportFrom(node2, expect) {
    if (this.eatContextual(97)) {
      node2.source = this.parseImportSource()
      this.checkExport(node2)
      const assertions = this.maybeParseImportAssertions()
      if (assertions) {
        node2.assertions = assertions
      }
    } else if (expect) {
      this.unexpected()
    }
    this.semicolon()
  }
  shouldParseExportDeclaration() {
    const { type } = this.state
    if (type === 26) {
      this.expectOnePlugin(['decorators', 'decorators-legacy'])
      if (this.hasPlugin('decorators')) {
        if (this.getPluginOption('decorators', 'decoratorsBeforeExport')) {
          throw this.raise(Errors$1.DecoratorBeforeExport, {
            at: this.state.startLoc,
          })
        }
        return true
      }
    }
    return type === 74 || type === 75 || type === 68 || type === 80 || this.isLet() || this.isAsyncFunction()
  }
  checkExport(node2, checkNames, isDefault, isFrom) {
    if (checkNames) {
      if (isDefault) {
        this.checkDuplicateExports(node2, 'default')
        if (this.hasPlugin('exportDefaultFrom')) {
          var _declaration$extra
          const declaration = node2.declaration
          if (
            declaration.type === 'Identifier' &&
            declaration.name === 'from' &&
            declaration.end - declaration.start === 4 &&
            !((_declaration$extra = declaration.extra) != null && _declaration$extra.parenthesized)
          ) {
            this.raise(Errors$1.ExportDefaultFromAsIdentifier, {
              at: declaration,
            })
          }
        }
      } else if (node2.specifiers && node2.specifiers.length) {
        for (const specifier of node2.specifiers) {
          const { exported } = specifier
          const exportName = exported.type === 'Identifier' ? exported.name : exported.value
          this.checkDuplicateExports(specifier, exportName)
          if (!isFrom && specifier.local) {
            const { local } = specifier
            if (local.type !== 'Identifier') {
              this.raise(Errors$1.ExportBindingIsString, {
                at: specifier,
                localName: local.value,
                exportName,
              })
            } else {
              this.checkReservedWord(local.name, local.loc.start, true, false)
              this.scope.checkLocalExport(local)
            }
          }
        }
      } else if (node2.declaration) {
        if (node2.declaration.type === 'FunctionDeclaration' || node2.declaration.type === 'ClassDeclaration') {
          const id = node2.declaration.id
          if (!id) throw new Error('Assertion failure')
          this.checkDuplicateExports(node2, id.name)
        } else if (node2.declaration.type === 'VariableDeclaration') {
          for (const declaration of node2.declaration.declarations) {
            this.checkDeclaration(declaration.id)
          }
        }
      }
    }
    const currentContextDecorators = this.state.decoratorStack[this.state.decoratorStack.length - 1]
    if (currentContextDecorators.length) {
      throw this.raise(Errors$1.UnsupportedDecoratorExport, {
        at: node2,
      })
    }
  }
  checkDeclaration(node2) {
    if (node2.type === 'Identifier') {
      this.checkDuplicateExports(node2, node2.name)
    } else if (node2.type === 'ObjectPattern') {
      for (const prop of node2.properties) {
        this.checkDeclaration(prop)
      }
    } else if (node2.type === 'ArrayPattern') {
      for (const elem of node2.elements) {
        if (elem) {
          this.checkDeclaration(elem)
        }
      }
    } else if (node2.type === 'ObjectProperty') {
      this.checkDeclaration(node2.value)
    } else if (node2.type === 'RestElement') {
      this.checkDeclaration(node2.argument)
    } else if (node2.type === 'AssignmentPattern') {
      this.checkDeclaration(node2.left)
    }
  }
  checkDuplicateExports(node2, exportName) {
    if (this.exportedIdentifiers.has(exportName)) {
      if (exportName === 'default') {
        this.raise(Errors$1.DuplicateDefaultExport, {
          at: node2,
        })
      } else {
        this.raise(Errors$1.DuplicateExport, {
          at: node2,
          exportName,
        })
      }
    }
    this.exportedIdentifiers.add(exportName)
  }
  parseExportSpecifiers(isInTypeExport) {
    const nodes2 = []
    let first = true
    this.expect(5)
    while (!this.eat(8)) {
      if (first) {
        first = false
      } else {
        this.expect(12)
        if (this.eat(8)) break
      }
      const isMaybeTypeOnly = this.isContextual(126)
      const isString2 = this.match(129)
      const node2 = this.startNode()
      node2.local = this.parseModuleExportName()
      nodes2.push(this.parseExportSpecifier(node2, isString2, isInTypeExport, isMaybeTypeOnly))
    }
    return nodes2
  }
  parseExportSpecifier(node2, isString2, isInTypeExport, isMaybeTypeOnly) {
    if (this.eatContextual(93)) {
      node2.exported = this.parseModuleExportName()
    } else if (isString2) {
      node2.exported = cloneStringLiteral$1(node2.local)
    } else if (!node2.exported) {
      node2.exported = cloneIdentifier$1(node2.local)
    }
    return this.finishNode(node2, 'ExportSpecifier')
  }
  parseModuleExportName() {
    if (this.match(129)) {
      const result = this.parseStringLiteral(this.state.value)
      const surrogate = result.value.match(loneSurrogate$1)
      if (surrogate) {
        this.raise(Errors$1.ModuleExportNameHasLoneSurrogate, {
          at: result,
          surrogateCharCode: surrogate[0].charCodeAt(0),
        })
      }
      return result
    }
    return this.parseIdentifier(true)
  }
  parseImport(node2) {
    node2.specifiers = []
    if (!this.match(129)) {
      const hasDefault = this.maybeParseDefaultImportSpecifier(node2)
      const parseNext = !hasDefault || this.eat(12)
      const hasStar = parseNext && this.maybeParseStarImportSpecifier(node2)
      if (parseNext && !hasStar) this.parseNamedImportSpecifiers(node2)
      this.expectContextual(97)
    }
    node2.source = this.parseImportSource()
    const assertions = this.maybeParseImportAssertions()
    if (assertions) {
      node2.assertions = assertions
    } else {
      const attributes = this.maybeParseModuleAttributes()
      if (attributes) {
        node2.attributes = attributes
      }
    }
    this.semicolon()
    return this.finishNode(node2, 'ImportDeclaration')
  }
  parseImportSource() {
    if (!this.match(129)) this.unexpected()
    return this.parseExprAtom()
  }
  shouldParseDefaultImport(node2) {
    return tokenIsIdentifier$1(this.state.type)
  }
  parseImportSpecifierLocal(node2, specifier, type) {
    specifier.local = this.parseIdentifier()
    node2.specifiers.push(this.finishImportSpecifier(specifier, type))
  }
  finishImportSpecifier(specifier, type) {
    this.checkLVal(specifier.local, {
      in: specifier,
      binding: BIND_LEXICAL$1,
    })
    return this.finishNode(specifier, type)
  }
  parseAssertEntries() {
    const attrs = []
    const attrNames = /* @__PURE__ */ new Set()
    do {
      if (this.match(8)) {
        break
      }
      const node2 = this.startNode()
      const keyName = this.state.value
      if (attrNames.has(keyName)) {
        this.raise(Errors$1.ModuleAttributesWithDuplicateKeys, {
          at: this.state.startLoc,
          key: keyName,
        })
      }
      attrNames.add(keyName)
      if (this.match(129)) {
        node2.key = this.parseStringLiteral(keyName)
      } else {
        node2.key = this.parseIdentifier(true)
      }
      this.expect(14)
      if (!this.match(129)) {
        throw this.raise(Errors$1.ModuleAttributeInvalidValue, {
          at: this.state.startLoc,
        })
      }
      node2.value = this.parseStringLiteral(this.state.value)
      this.finishNode(node2, 'ImportAttribute')
      attrs.push(node2)
    } while (this.eat(12))
    return attrs
  }
  maybeParseModuleAttributes() {
    if (this.match(76) && !this.hasPrecedingLineBreak()) {
      this.expectPlugin('moduleAttributes')
      this.next()
    } else {
      if (this.hasPlugin('moduleAttributes')) return []
      return null
    }
    const attrs = []
    const attributes = /* @__PURE__ */ new Set()
    do {
      const node2 = this.startNode()
      node2.key = this.parseIdentifier(true)
      if (node2.key.name !== 'type') {
        this.raise(Errors$1.ModuleAttributeDifferentFromType, {
          at: node2.key,
        })
      }
      if (attributes.has(node2.key.name)) {
        this.raise(Errors$1.ModuleAttributesWithDuplicateKeys, {
          at: node2.key,
          key: node2.key.name,
        })
      }
      attributes.add(node2.key.name)
      this.expect(14)
      if (!this.match(129)) {
        throw this.raise(Errors$1.ModuleAttributeInvalidValue, {
          at: this.state.startLoc,
        })
      }
      node2.value = this.parseStringLiteral(this.state.value)
      this.finishNode(node2, 'ImportAttribute')
      attrs.push(node2)
    } while (this.eat(12))
    return attrs
  }
  maybeParseImportAssertions() {
    if (this.isContextual(94) && !this.hasPrecedingLineBreak()) {
      this.expectPlugin('importAssertions')
      this.next()
    } else {
      if (this.hasPlugin('importAssertions')) return []
      return null
    }
    this.eat(5)
    const attrs = this.parseAssertEntries()
    this.eat(8)
    return attrs
  }
  maybeParseDefaultImportSpecifier(node2) {
    if (this.shouldParseDefaultImport(node2)) {
      this.parseImportSpecifierLocal(node2, this.startNode(), 'ImportDefaultSpecifier')
      return true
    }
    return false
  }
  maybeParseStarImportSpecifier(node2) {
    if (this.match(55)) {
      const specifier = this.startNode()
      this.next()
      this.expectContextual(93)
      this.parseImportSpecifierLocal(node2, specifier, 'ImportNamespaceSpecifier')
      return true
    }
    return false
  }
  parseNamedImportSpecifiers(node2) {
    let first = true
    this.expect(5)
    while (!this.eat(8)) {
      if (first) {
        first = false
      } else {
        if (this.eat(14)) {
          throw this.raise(Errors$1.DestructureNamedImport, {
            at: this.state.startLoc,
          })
        }
        this.expect(12)
        if (this.eat(8)) break
      }
      const specifier = this.startNode()
      const importedIsString = this.match(129)
      const isMaybeTypeOnly = this.isContextual(126)
      specifier.imported = this.parseModuleExportName()
      const importSpecifier2 = this.parseImportSpecifier(
        specifier,
        importedIsString,
        node2.importKind === 'type' || node2.importKind === 'typeof',
        isMaybeTypeOnly
      )
      node2.specifiers.push(importSpecifier2)
    }
  }
  parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly) {
    if (this.eatContextual(93)) {
      specifier.local = this.parseIdentifier()
    } else {
      const { imported } = specifier
      if (importedIsString) {
        throw this.raise(Errors$1.ImportBindingIsString, {
          at: specifier,
          importName: imported.value,
        })
      }
      this.checkReservedWord(imported.name, specifier.loc.start, true, true)
      if (!specifier.local) {
        specifier.local = cloneIdentifier$1(imported)
      }
    }
    return this.finishImportSpecifier(specifier, 'ImportSpecifier')
  }
  isThisParam(param) {
    return param.type === 'Identifier' && param.name === 'this'
  }
}
class Parser$1 extends StatementParser$1 {
  constructor(options2, input) {
    options2 = getOptions$1(options2)
    super(options2, input)
    this.options = options2
    this.initializeScopes()
    this.plugins = pluginsMap$1(this.options.plugins)
    this.filename = options2.sourceFilename
  }
  getScopeHandler() {
    return ScopeHandler$1
  }
  parse() {
    this.enterInitialScopes()
    const file2 = this.startNode()
    const program2 = this.startNode()
    this.nextToken()
    file2.errors = null
    this.parseTopLevel(file2, program2)
    file2.errors = this.state.errors
    return file2
  }
}
function pluginsMap$1(plugins) {
  const pluginMap = /* @__PURE__ */ new Map()
  for (const plugin of plugins) {
    const [name, options2] = Array.isArray(plugin) ? plugin : [plugin, {}]
    if (!pluginMap.has(name)) pluginMap.set(name, options2 || {})
  }
  return pluginMap
}
function parse$2(input, options2) {
  var _options2
  if (((_options2 = options2) == null ? void 0 : _options2.sourceType) === 'unambiguous') {
    options2 = Object.assign({}, options2)
    try {
      options2.sourceType = 'module'
      const parser = getParser$1(options2, input)
      const ast = parser.parse()
      if (parser.sawUnambiguousESM) {
        return ast
      }
      if (parser.ambiguousScriptDifferentAst) {
        try {
          options2.sourceType = 'script'
          return getParser$1(options2, input).parse()
        } catch (_unused) {}
      } else {
        ast.program.sourceType = 'script'
      }
      return ast
    } catch (moduleError) {
      try {
        options2.sourceType = 'script'
        return getParser$1(options2, input).parse()
      } catch (_unused2) {}
      throw moduleError
    }
  } else {
    return getParser$1(options2, input).parse()
  }
}
function parseExpression$1(input, options2) {
  const parser = getParser$1(options2, input)
  if (parser.options.strictMode) {
    parser.state.strict = true
  }
  return parser.getExpression()
}
function generateExportedTokenTypes$1(internalTokenTypes) {
  const tokenTypes2 = {}
  for (const typeName of Object.keys(internalTokenTypes)) {
    tokenTypes2[typeName] = getExportedToken$1(internalTokenTypes[typeName])
  }
  return tokenTypes2
}
const tokTypes$1 = generateExportedTokenTypes$1(tt$1)
function getParser$1(options2, input) {
  let cls = Parser$1
  if (options2 != null && options2.plugins) {
    validatePlugins$1(options2.plugins)
    cls = getParserClass$1(options2.plugins)
  }
  return new cls(options2, input)
}
const parserClassCache$1 = {}
function getParserClass$1(pluginsFromOptions) {
  const pluginList = mixinPluginNames$1.filter((name) => hasPlugin$1(pluginsFromOptions, name))
  const key = pluginList.join('/')
  let cls = parserClassCache$1[key]
  if (!cls) {
    cls = Parser$1
    for (const plugin of pluginList) {
      cls = mixinPlugins$1[plugin](cls)
    }
    parserClassCache$1[key] = cls
  }
  return cls
}
var parse_1 = (lib$4.parse = parse$2)
lib$4.parseExpression = parseExpression$1
lib$4.tokTypes = tokTypes$1
var lib$3 = {}
Object.defineProperty(lib$3, '__esModule', {
  value: true,
})
lib$3.default = hoistVariables
var _t$e = lib$b
const {
  assignmentExpression: assignmentExpression$3,
  expressionStatement: expressionStatement$4,
  identifier: identifier$4,
} = _t$e
const visitor$1 = {
  Scope(path2, state) {
    if (state.kind === 'let') path2.skip()
  },
  FunctionParent(path2) {
    path2.skip()
  },
  VariableDeclaration(path2, state) {
    if (state.kind && path2.node.kind !== state.kind) return
    const nodes2 = []
    const declarations = path2.get('declarations')
    let firstId
    for (const declar of declarations) {
      firstId = declar.node.id
      if (declar.node.init) {
        nodes2.push(expressionStatement$4(assignmentExpression$3('=', declar.node.id, declar.node.init)))
      }
      for (const name of Object.keys(declar.getBindingIdentifiers())) {
        state.emit(identifier$4(name), name, declar.node.init !== null)
      }
    }
    if (
      path2.parentPath.isFor({
        left: path2.node,
      })
    ) {
      path2.replaceWith(firstId)
    } else {
      path2.replaceWithMultiple(nodes2)
    }
  },
}
function hoistVariables(path2, emit, kind = 'var') {
  path2.traverse(visitor$1, {
    kind,
    emit,
  })
}
Object.defineProperty(replacement, '__esModule', {
  value: true,
})
replacement._replaceWith = _replaceWith
replacement.replaceExpressionWithStatements = replaceExpressionWithStatements
replacement.replaceInline = replaceInline
replacement.replaceWith = replaceWith
replacement.replaceWithMultiple = replaceWithMultiple
replacement.replaceWithSourceString = replaceWithSourceString
var _codeFrame$1 = lib$6
var _index$5 = lib$c
var _index2 = path
var _cache$3 = cache
var _parser$1 = lib$4
var _t$d = lib$b
var _helperHoistVariables = lib$3
const {
  FUNCTION_TYPES,
  arrowFunctionExpression: arrowFunctionExpression$2,
  assignmentExpression: assignmentExpression$2,
  awaitExpression,
  blockStatement: blockStatement$3,
  callExpression: callExpression$2,
  cloneNode: cloneNode$4,
  expressionStatement: expressionStatement$3,
  identifier: identifier$3,
  inheritLeadingComments,
  inheritTrailingComments,
  inheritsComments,
  isExpression: isExpression$2,
  isProgram,
  isStatement: isStatement$2,
  removeComments,
  returnStatement: returnStatement$1,
  toSequenceExpression,
  validate: validate$3,
  yieldExpression,
} = _t$d
function replaceWithMultiple(nodes2) {
  var _pathCache$get
  this.resync()
  nodes2 = this._verifyNodeList(nodes2)
  inheritLeadingComments(nodes2[0], this.node)
  inheritTrailingComments(nodes2[nodes2.length - 1], this.node)
  ;(_pathCache$get = _cache$3.path.get(this.parent)) == null ? void 0 : _pathCache$get.delete(this.node)
  this.node = this.container[this.key] = null
  const paths = this.insertAfter(nodes2)
  if (this.node) {
    this.requeue()
  } else {
    this.remove()
  }
  return paths
}
function replaceWithSourceString(replacement2) {
  this.resync()
  try {
    replacement2 = `(${replacement2})`
    replacement2 = (0, _parser$1.parse)(replacement2)
  } catch (err) {
    const loc = err.loc
    if (loc) {
      err.message +=
        ' - make sure this is an expression.\n' +
        (0, _codeFrame$1.codeFrameColumns)(replacement2, {
          start: {
            line: loc.line,
            column: loc.column + 1,
          },
        })
      err.code = 'BABEL_REPLACE_SOURCE_ERROR'
    }
    throw err
  }
  replacement2 = replacement2.program.body[0].expression
  _index$5.default.removeProperties(replacement2)
  return this.replaceWith(replacement2)
}
function replaceWith(replacement2) {
  this.resync()
  if (this.removed) {
    throw new Error("You can't replace this node, we've already removed it")
  }
  if (replacement2 instanceof _index2.default) {
    replacement2 = replacement2.node
  }
  if (!replacement2) {
    throw new Error('You passed `path.replaceWith()` a falsy node, use `path.remove()` instead')
  }
  if (this.node === replacement2) {
    return [this]
  }
  if (this.isProgram() && !isProgram(replacement2)) {
    throw new Error('You can only replace a Program root node with another Program node')
  }
  if (Array.isArray(replacement2)) {
    throw new Error("Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`")
  }
  if (typeof replacement2 === 'string') {
    throw new Error("Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`")
  }
  let nodePath = ''
  if (this.isNodeType('Statement') && isExpression$2(replacement2)) {
    if (
      !this.canHaveVariableDeclarationOrExpression() &&
      !this.canSwapBetweenExpressionAndStatement(replacement2) &&
      !this.parentPath.isExportDefaultDeclaration()
    ) {
      replacement2 = expressionStatement$3(replacement2)
      nodePath = 'expression'
    }
  }
  if (this.isNodeType('Expression') && isStatement$2(replacement2)) {
    if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement2)) {
      return this.replaceExpressionWithStatements([replacement2])
    }
  }
  const oldNode = this.node
  if (oldNode) {
    inheritsComments(replacement2, oldNode)
    removeComments(oldNode)
  }
  this._replaceWith(replacement2)
  this.type = replacement2.type
  this.setScope()
  this.requeue()
  return [nodePath ? this.get(nodePath) : this]
}
function _replaceWith(node2) {
  var _pathCache$get2
  if (!this.container) {
    throw new ReferenceError('Container is falsy')
  }
  if (this.inList) {
    validate$3(this.parent, this.key, [node2])
  } else {
    validate$3(this.parent, this.key, node2)
  }
  this.debug(`Replace with ${node2 == null ? void 0 : node2.type}`)
  ;(_pathCache$get2 = _cache$3.path.get(this.parent)) == null
    ? void 0
    : _pathCache$get2.set(node2, this).delete(this.node)
  this.node = this.container[this.key] = node2
}
function replaceExpressionWithStatements(nodes2) {
  this.resync()
  const nodesAsSequenceExpression = toSequenceExpression(nodes2, this.scope)
  if (nodesAsSequenceExpression) {
    return this.replaceWith(nodesAsSequenceExpression)[0].get('expressions')
  }
  const functionParent = this.getFunctionParent()
  const isParentAsync = functionParent == null ? void 0 : functionParent.is('async')
  const isParentGenerator = functionParent == null ? void 0 : functionParent.is('generator')
  const container = arrowFunctionExpression$2([], blockStatement$3(nodes2))
  this.replaceWith(callExpression$2(container, []))
  const callee = this.get('callee')
  ;(0, _helperHoistVariables.default)(
    callee.get('body'),
    (id) => {
      this.scope.push({
        id,
      })
    },
    'var'
  )
  const completionRecords = this.get('callee').getCompletionRecords()
  for (const path2 of completionRecords) {
    if (!path2.isExpressionStatement()) continue
    const loop = path2.findParent((path3) => path3.isLoop())
    if (loop) {
      let uid2 = loop.getData('expressionReplacementReturnUid')
      if (!uid2) {
        uid2 = callee.scope.generateDeclaredUidIdentifier('ret')
        callee.get('body').pushContainer('body', returnStatement$1(cloneNode$4(uid2)))
        loop.setData('expressionReplacementReturnUid', uid2)
      } else {
        uid2 = identifier$3(uid2.name)
      }
      path2.get('expression').replaceWith(assignmentExpression$2('=', cloneNode$4(uid2), path2.node.expression))
    } else {
      path2.replaceWith(returnStatement$1(path2.node.expression))
    }
  }
  callee.arrowFunctionToExpression()
  const newCallee = callee
  const needToAwaitFunction =
    isParentAsync && _index$5.default.hasType(this.get('callee.body').node, 'AwaitExpression', FUNCTION_TYPES)
  const needToYieldFunction =
    isParentGenerator && _index$5.default.hasType(this.get('callee.body').node, 'YieldExpression', FUNCTION_TYPES)
  if (needToAwaitFunction) {
    newCallee.set('async', true)
    if (!needToYieldFunction) {
      this.replaceWith(awaitExpression(this.node))
    }
  }
  if (needToYieldFunction) {
    newCallee.set('generator', true)
    this.replaceWith(yieldExpression(this.node, true))
  }
  return newCallee.get('body.body')
}
function replaceInline(nodes2) {
  this.resync()
  if (Array.isArray(nodes2)) {
    if (Array.isArray(this.container)) {
      nodes2 = this._verifyNodeList(nodes2)
      const paths = this._containerInsertAfter(nodes2)
      this.remove()
      return paths
    } else {
      return this.replaceWithMultiple(nodes2)
    }
  } else {
    return this.replaceWith(nodes2)
  }
}
var evaluation = {}
Object.defineProperty(evaluation, '__esModule', {
  value: true,
})
evaluation.evaluate = evaluate
evaluation.evaluateTruthy = evaluateTruthy
const VALID_CALLEES = ['String', 'Number', 'Math']
const INVALID_METHODS = ['random']
function evaluateTruthy() {
  const res = this.evaluate()
  if (res.confident) return !!res.value
}
function deopt(path2, state) {
  if (!state.confident) return
  state.deoptPath = path2
  state.confident = false
}
function evaluateCached(path2, state) {
  const { node: node2 } = path2
  const { seen } = state
  if (seen.has(node2)) {
    const existing = seen.get(node2)
    if (existing.resolved) {
      return existing.value
    } else {
      deopt(path2, state)
      return
    }
  } else {
    const item = {
      resolved: false,
    }
    seen.set(node2, item)
    const val = _evaluate(path2, state)
    if (state.confident) {
      item.resolved = true
      item.value = val
    }
    return val
  }
}
function _evaluate(path2, state) {
  if (!state.confident) return
  if (path2.isSequenceExpression()) {
    const exprs = path2.get('expressions')
    return evaluateCached(exprs[exprs.length - 1], state)
  }
  if (path2.isStringLiteral() || path2.isNumericLiteral() || path2.isBooleanLiteral()) {
    return path2.node.value
  }
  if (path2.isNullLiteral()) {
    return null
  }
  if (path2.isTemplateLiteral()) {
    return evaluateQuasis(path2, path2.node.quasis, state)
  }
  if (path2.isTaggedTemplateExpression() && path2.get('tag').isMemberExpression()) {
    const object2 = path2.get('tag.object')
    const {
      node: { name },
    } = object2
    const property = path2.get('tag.property')
    if (
      object2.isIdentifier() &&
      name === 'String' &&
      !path2.scope.getBinding(name) &&
      property.isIdentifier() &&
      property.node.name === 'raw'
    ) {
      return evaluateQuasis(path2, path2.node.quasi.quasis, state, true)
    }
  }
  if (path2.isConditionalExpression()) {
    const testResult = evaluateCached(path2.get('test'), state)
    if (!state.confident) return
    if (testResult) {
      return evaluateCached(path2.get('consequent'), state)
    } else {
      return evaluateCached(path2.get('alternate'), state)
    }
  }
  if (path2.isExpressionWrapper()) {
    return evaluateCached(path2.get('expression'), state)
  }
  if (
    path2.isMemberExpression() &&
    !path2.parentPath.isCallExpression({
      callee: path2.node,
    })
  ) {
    const property = path2.get('property')
    const object2 = path2.get('object')
    if (object2.isLiteral() && property.isIdentifier()) {
      const value = object2.node.value
      const type = typeof value
      if (type === 'number' || type === 'string') {
        return value[property.node.name]
      }
    }
  }
  if (path2.isReferencedIdentifier()) {
    const binding2 = path2.scope.getBinding(path2.node.name)
    if (binding2 && binding2.constantViolations.length > 0) {
      return deopt(binding2.path, state)
    }
    if (binding2 && path2.node.start < binding2.path.node.end) {
      return deopt(binding2.path, state)
    }
    if (binding2 != null && binding2.hasValue) {
      return binding2.value
    } else {
      if (path2.node.name === 'undefined') {
        return binding2 ? deopt(binding2.path, state) : void 0
      } else if (path2.node.name === 'Infinity') {
        return binding2 ? deopt(binding2.path, state) : Infinity
      } else if (path2.node.name === 'NaN') {
        return binding2 ? deopt(binding2.path, state) : NaN
      }
      const resolved = path2.resolve()
      if (resolved === path2) {
        return deopt(path2, state)
      } else {
        return evaluateCached(resolved, state)
      }
    }
  }
  if (
    path2.isUnaryExpression({
      prefix: true,
    })
  ) {
    if (path2.node.operator === 'void') {
      return void 0
    }
    const argument = path2.get('argument')
    if (path2.node.operator === 'typeof' && (argument.isFunction() || argument.isClass())) {
      return 'function'
    }
    const arg = evaluateCached(argument, state)
    if (!state.confident) return
    switch (path2.node.operator) {
      case '!':
        return !arg
      case '+':
        return +arg
      case '-':
        return -arg
      case '~':
        return ~arg
      case 'typeof':
        return typeof arg
    }
  }
  if (path2.isArrayExpression()) {
    const arr = []
    const elems = path2.get('elements')
    for (const elem of elems) {
      const elemValue = elem.evaluate()
      if (elemValue.confident) {
        arr.push(elemValue.value)
      } else {
        return deopt(elemValue.deopt, state)
      }
    }
    return arr
  }
  if (path2.isObjectExpression()) {
    const obj = {}
    const props2 = path2.get('properties')
    for (const prop of props2) {
      if (prop.isObjectMethod() || prop.isSpreadElement()) {
        return deopt(prop, state)
      }
      const keyPath = prop.get('key')
      let key = keyPath
      if (prop.node.computed) {
        key = key.evaluate()
        if (!key.confident) {
          return deopt(key.deopt, state)
        }
        key = key.value
      } else if (key.isIdentifier()) {
        key = key.node.name
      } else {
        key = key.node.value
      }
      const valuePath = prop.get('value')
      let value = valuePath.evaluate()
      if (!value.confident) {
        return deopt(value.deopt, state)
      }
      value = value.value
      obj[key] = value
    }
    return obj
  }
  if (path2.isLogicalExpression()) {
    const wasConfident = state.confident
    const left = evaluateCached(path2.get('left'), state)
    const leftConfident = state.confident
    state.confident = wasConfident
    const right = evaluateCached(path2.get('right'), state)
    const rightConfident = state.confident
    switch (path2.node.operator) {
      case '||':
        state.confident = leftConfident && (!!left || rightConfident)
        if (!state.confident) return
        return left || right
      case '&&':
        state.confident = leftConfident && (!left || rightConfident)
        if (!state.confident) return
        return left && right
    }
  }
  if (path2.isBinaryExpression()) {
    const left = evaluateCached(path2.get('left'), state)
    if (!state.confident) return
    const right = evaluateCached(path2.get('right'), state)
    if (!state.confident) return
    switch (path2.node.operator) {
      case '-':
        return left - right
      case '+':
        return left + right
      case '/':
        return left / right
      case '*':
        return left * right
      case '%':
        return left % right
      case '**':
        return Math.pow(left, right)
      case '<':
        return left < right
      case '>':
        return left > right
      case '<=':
        return left <= right
      case '>=':
        return left >= right
      case '==':
        return left == right
      case '!=':
        return left != right
      case '===':
        return left === right
      case '!==':
        return left !== right
      case '|':
        return left | right
      case '&':
        return left & right
      case '^':
        return left ^ right
      case '<<':
        return left << right
      case '>>':
        return left >> right
      case '>>>':
        return left >>> right
    }
  }
  if (path2.isCallExpression()) {
    const callee = path2.get('callee')
    let context2
    let func
    if (
      callee.isIdentifier() &&
      !path2.scope.getBinding(callee.node.name) &&
      VALID_CALLEES.indexOf(callee.node.name) >= 0
    ) {
      func = commonjsGlobal[callee.node.name]
    }
    if (callee.isMemberExpression()) {
      const object2 = callee.get('object')
      const property = callee.get('property')
      if (
        object2.isIdentifier() &&
        property.isIdentifier() &&
        VALID_CALLEES.indexOf(object2.node.name) >= 0 &&
        INVALID_METHODS.indexOf(property.node.name) < 0
      ) {
        context2 = commonjsGlobal[object2.node.name]
        func = context2[property.node.name]
      }
      if (object2.isLiteral() && property.isIdentifier()) {
        const type = typeof object2.node.value
        if (type === 'string' || type === 'number') {
          context2 = object2.node.value
          func = context2[property.node.name]
        }
      }
    }
    if (func) {
      const args = path2.get('arguments').map((arg) => evaluateCached(arg, state))
      if (!state.confident) return
      return func.apply(context2, args)
    }
  }
  deopt(path2, state)
}
function evaluateQuasis(path2, quasis, state, raw = false) {
  let str = ''
  let i = 0
  const exprs = path2.get('expressions')
  for (const elem of quasis) {
    if (!state.confident) break
    str += raw ? elem.value.raw : elem.value.cooked
    const expr = exprs[i++]
    if (expr) str += String(evaluateCached(expr, state))
  }
  if (!state.confident) return
  return str
}
function evaluate() {
  const state = {
    confident: true,
    deoptPath: null,
    seen: /* @__PURE__ */ new Map(),
  }
  let value = evaluateCached(this, state)
  if (!state.confident) value = void 0
  return {
    confident: state.confident,
    deopt: state.deoptPath,
    value,
  }
}
var conversion = {}
var lib$2 = {}
var lib$1 = {}
var formatters$1 = {}
Object.defineProperty(formatters$1, '__esModule', {
  value: true,
})
formatters$1.statements =
  formatters$1.statement =
  formatters$1.smart =
  formatters$1.program =
  formatters$1.expression =
    void 0
var _t$c = lib$b
const { assertExpressionStatement } = _t$c
function makeStatementFormatter(fn) {
  return {
    code: (str) => `/* @babel/template */;
${str}`,
    validate: () => {},
    unwrap: (ast) => {
      return fn(ast.program.body.slice(1))
    },
  }
}
const smart$1 = makeStatementFormatter((body) => {
  if (body.length > 1) {
    return body
  } else {
    return body[0]
  }
})
formatters$1.smart = smart$1
const statements$1 = makeStatementFormatter((body) => body)
formatters$1.statements = statements$1
const statement$1 = makeStatementFormatter((body) => {
  if (body.length === 0) {
    throw new Error('Found nothing to return.')
  }
  if (body.length > 1) {
    throw new Error('Found multiple statements but wanted one')
  }
  return body[0]
})
formatters$1.statement = statement$1
const expression$1 = {
  code: (str) => `(
${str}
)`,
  validate: (ast) => {
    if (ast.program.body.length > 1) {
      throw new Error('Found multiple statements but wanted one')
    }
    if (expression$1.unwrap(ast).start === 0) {
      throw new Error('Parse result included parens.')
    }
  },
  unwrap: ({ program: program2 }) => {
    const [stmt] = program2.body
    assertExpressionStatement(stmt)
    return stmt.expression
  },
}
formatters$1.expression = expression$1
const program$1 = {
  code: (str) => str,
  validate: () => {},
  unwrap: (ast) => ast.program,
}
formatters$1.program = program$1
var builder = {}
var options = {}
Object.defineProperty(options, '__esModule', {
  value: true,
})
options.merge = merge$1
options.normalizeReplacements = normalizeReplacements
options.validate = validate$2
const _excluded$3 = ['placeholderWhitelist', 'placeholderPattern', 'preserveComments', 'syntacticPlaceholders']
function _objectWithoutPropertiesLoose$2(source, excluded) {
  if (source == null) return {}
  var target = {}
  var sourceKeys = Object.keys(source)
  var key, i
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i]
    if (excluded.indexOf(key) >= 0) continue
    target[key] = source[key]
  }
  return target
}
function merge$1(a, b) {
  const {
    placeholderWhitelist = a.placeholderWhitelist,
    placeholderPattern = a.placeholderPattern,
    preserveComments = a.preserveComments,
    syntacticPlaceholders = a.syntacticPlaceholders,
  } = b
  return {
    parser: Object.assign({}, a.parser, b.parser),
    placeholderWhitelist,
    placeholderPattern,
    preserveComments,
    syntacticPlaceholders,
  }
}
function validate$2(opts) {
  if (opts != null && typeof opts !== 'object') {
    throw new Error('Unknown template options.')
  }
  const _ref = opts || {},
    { placeholderWhitelist, placeholderPattern, preserveComments, syntacticPlaceholders } = _ref,
    parser = _objectWithoutPropertiesLoose$2(_ref, _excluded$3)
  if (placeholderWhitelist != null && !(placeholderWhitelist instanceof Set)) {
    throw new Error("'.placeholderWhitelist' must be a Set, null, or undefined")
  }
  if (placeholderPattern != null && !(placeholderPattern instanceof RegExp) && placeholderPattern !== false) {
    throw new Error("'.placeholderPattern' must be a RegExp, false, null, or undefined")
  }
  if (preserveComments != null && typeof preserveComments !== 'boolean') {
    throw new Error("'.preserveComments' must be a boolean, null, or undefined")
  }
  if (syntacticPlaceholders != null && typeof syntacticPlaceholders !== 'boolean') {
    throw new Error("'.syntacticPlaceholders' must be a boolean, null, or undefined")
  }
  if (syntacticPlaceholders === true && (placeholderWhitelist != null || placeholderPattern != null)) {
    throw new Error(
      "'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'"
    )
  }
  return {
    parser,
    placeholderWhitelist: placeholderWhitelist || void 0,
    placeholderPattern: placeholderPattern == null ? void 0 : placeholderPattern,
    preserveComments: preserveComments == null ? void 0 : preserveComments,
    syntacticPlaceholders: syntacticPlaceholders == null ? void 0 : syntacticPlaceholders,
  }
}
function normalizeReplacements(replacements) {
  if (Array.isArray(replacements)) {
    return replacements.reduce((acc, replacement2, i) => {
      acc['$' + i] = replacement2
      return acc
    }, {})
  } else if (typeof replacements === 'object' || replacements == null) {
    return replacements || void 0
  }
  throw new Error('Template replacements must be an array, object, null, or undefined')
}
var string = {}
var parse$1 = {}
var lib = {}
Object.defineProperty(lib, '__esModule', { value: true })
function _objectWithoutPropertiesLoose$1(source, excluded) {
  if (source == null) return {}
  var target = {}
  var sourceKeys = Object.keys(source)
  var key, i
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i]
    if (excluded.indexOf(key) >= 0) continue
    target[key] = source[key]
  }
  return target
}
class Position {
  constructor(line, col, index2) {
    this.line = void 0
    this.column = void 0
    this.index = void 0
    this.line = line
    this.column = col
    this.index = index2
  }
}
class SourceLocation {
  constructor(start, end) {
    this.start = void 0
    this.end = void 0
    this.filename = void 0
    this.identifierName = void 0
    this.start = start
    this.end = end
  }
}
function createPositionWithColumnOffset(position, columnOffset) {
  const { line, column, index: index2 } = position
  return new Position(line, column + columnOffset, index2 + columnOffset)
}
const ParseErrorCodes = Object.freeze({
  SyntaxError: 'BABEL_PARSER_SYNTAX_ERROR',
  SourceTypeModuleError: 'BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED',
})
const reflect = (keys, last2 = keys.length - 1) => ({
  get() {
    return keys.reduce((object2, key) => object2[key], this)
  },
  set(value) {
    keys.reduce((item, key, i) => (i === last2 ? (item[key] = value) : item[key]), this)
  },
})
const instantiate = (constructor, properties, descriptors) =>
  Object.keys(descriptors)
    .map((key) => [key, descriptors[key]])
    .filter(([, descriptor]) => !!descriptor)
    .map(([key, descriptor]) => [
      key,
      typeof descriptor === 'function'
        ? {
            value: descriptor,
            enumerable: false,
          }
        : typeof descriptor.reflect === 'string'
        ? Object.assign({}, descriptor, reflect(descriptor.reflect.split('.')))
        : descriptor,
    ])
    .reduce(
      (instance, [key, descriptor]) =>
        Object.defineProperty(
          instance,
          key,
          Object.assign(
            {
              configurable: true,
            },
            descriptor
          )
        ),
      Object.assign(new constructor(), properties)
    )
var ModuleErrors = (_2) => ({
  ImportMetaOutsideModule: _2(`import.meta may appear only with 'sourceType: "module"'`, {
    code: ParseErrorCodes.SourceTypeModuleError,
  }),
  ImportOutsideModule: _2(`'import' and 'export' may appear only with 'sourceType: "module"'`, {
    code: ParseErrorCodes.SourceTypeModuleError,
  }),
})
const NodeDescriptions = {
  ArrayPattern: 'array destructuring pattern',
  AssignmentExpression: 'assignment expression',
  AssignmentPattern: 'assignment expression',
  ArrowFunctionExpression: 'arrow function expression',
  ConditionalExpression: 'conditional expression',
  ForOfStatement: 'for-of statement',
  ForInStatement: 'for-in statement',
  ForStatement: 'for-loop',
  FormalParameters: 'function parameter list',
  Identifier: 'identifier',
  ObjectPattern: 'object destructuring pattern',
  ParenthesizedExpression: 'parenthesized expression',
  RestElement: 'rest element',
  UpdateExpression: {
    true: 'prefix operation',
    false: 'postfix operation',
  },
  VariableDeclarator: 'variable declaration',
  YieldExpression: 'yield expression',
}
const toNodeDescription = ({ type, prefix: prefix2 }) =>
  type === 'UpdateExpression' ? NodeDescriptions.UpdateExpression[String(prefix2)] : NodeDescriptions[type]
var StandardErrors = (_2) => ({
  AccessorIsGenerator: _2(({ kind }) => `A ${kind}ter cannot be a generator.`),
  ArgumentsInClass: _2("'arguments' is only allowed in functions and class methods."),
  AsyncFunctionInSingleStatementContext: _2('Async functions can only be declared at the top level or inside a block.'),
  AwaitBindingIdentifier: _2("Can not use 'await' as identifier inside an async function."),
  AwaitBindingIdentifierInStaticBlock: _2("Can not use 'await' as identifier inside a static block."),
  AwaitExpressionFormalParameter: _2("'await' is not allowed in async function parameters."),
  AwaitNotInAsyncContext: _2("'await' is only allowed within async functions and at the top levels of modules."),
  AwaitNotInAsyncFunction: _2("'await' is only allowed within async functions."),
  BadGetterArity: _2("A 'get' accesor must not have any formal parameters."),
  BadSetterArity: _2("A 'set' accesor must have exactly one formal parameter."),
  BadSetterRestParameter: _2("A 'set' accesor function argument must not be a rest parameter."),
  ConstructorClassField: _2("Classes may not have a field named 'constructor'."),
  ConstructorClassPrivateField: _2("Classes may not have a private field named '#constructor'."),
  ConstructorIsAccessor: _2('Class constructor may not be an accessor.'),
  ConstructorIsAsync: _2("Constructor can't be an async function."),
  ConstructorIsGenerator: _2("Constructor can't be a generator."),
  DeclarationMissingInitializer: _2(({ kind }) => `Missing initializer in ${kind} declaration.`),
  DecoratorBeforeExport: _2(
    "Decorators must be placed *before* the 'export' keyword. You can set the 'decoratorsBeforeExport' option to false to use the 'export @decorator class {}' syntax."
  ),
  DecoratorConstructor: _2("Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?"),
  DecoratorExportClass: _2(
    'Using the export keyword between a decorator and a class is not allowed. Please use `export @dec class` instead.'
  ),
  DecoratorSemicolon: _2('Decorators must not be followed by a semicolon.'),
  DecoratorStaticBlock: _2("Decorators can't be used with a static block."),
  DeletePrivateField: _2('Deleting a private field is not allowed.'),
  DestructureNamedImport: _2(
    'ES2015 named imports do not destructure. Use another statement for destructuring after the import.'
  ),
  DuplicateConstructor: _2('Duplicate constructor in the same class.'),
  DuplicateDefaultExport: _2('Only one default export allowed per module.'),
  DuplicateExport: _2(
    ({ exportName }) => `\`${exportName}\` has already been exported. Exported identifiers must be unique.`
  ),
  DuplicateProto: _2('Redefinition of __proto__ property.'),
  DuplicateRegExpFlags: _2('Duplicate regular expression flag.'),
  ElementAfterRest: _2('Rest element must be last element.'),
  EscapedCharNotAnIdentifier: _2('Invalid Unicode escape.'),
  ExportBindingIsString: _2(
    ({ localName, exportName }) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${localName}' as '${exportName}' } from 'some-module'\`?`
  ),
  ExportDefaultFromAsIdentifier: _2("'from' is not allowed as an identifier after 'export default'."),
  ForInOfLoopInitializer: _2(
    ({ type }) =>
      `'${type === 'ForInStatement' ? 'for-in' : 'for-of'}' loop variable declaration may not have an initializer.`
  ),
  ForOfAsync: _2("The left-hand side of a for-of loop may not be 'async'."),
  ForOfLet: _2("The left-hand side of a for-of loop may not start with 'let'."),
  GeneratorInSingleStatementContext: _2('Generators can only be declared at the top level or inside a block.'),
  IllegalBreakContinue: _2(({ type }) => `Unsyntactic ${type === 'BreakStatement' ? 'break' : 'continue'}.`),
  IllegalLanguageModeDirective: _2("Illegal 'use strict' directive in function with non-simple parameter list."),
  IllegalReturn: _2("'return' outside of function."),
  ImportBindingIsString: _2(
    ({ importName }) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${importName}" as foo }\`?`
  ),
  ImportCallArgumentTrailingComma: _2('Trailing comma is disallowed inside import(...) arguments.'),
  ImportCallArity: _2(
    ({ maxArgumentCount }) =>
      `\`import()\` requires exactly ${maxArgumentCount === 1 ? 'one argument' : 'one or two arguments'}.`
  ),
  ImportCallNotNewExpression: _2('Cannot use new with import(...).'),
  ImportCallSpreadArgument: _2('`...` is not allowed in `import()`.'),
  IncompatibleRegExpUVFlags: _2("The 'u' and 'v' regular expression flags cannot be enabled at the same time."),
  InvalidBigIntLiteral: _2('Invalid BigIntLiteral.'),
  InvalidCodePoint: _2('Code point out of bounds.'),
  InvalidCoverInitializedName: _2('Invalid shorthand property initializer.'),
  InvalidDecimal: _2('Invalid decimal.'),
  InvalidDigit: _2(({ radix }) => `Expected number in radix ${radix}.`),
  InvalidEscapeSequence: _2('Bad character escape sequence.'),
  InvalidEscapeSequenceTemplate: _2('Invalid escape sequence in template.'),
  InvalidEscapedReservedWord: _2(({ reservedWord }) => `Escape sequence in keyword ${reservedWord}.`),
  InvalidIdentifier: _2(({ identifierName }) => `Invalid identifier ${identifierName}.`),
  InvalidLhs: _2(({ ancestor }) => `Invalid left-hand side in ${toNodeDescription(ancestor)}.`),
  InvalidLhsBinding: _2(({ ancestor }) => `Binding invalid left-hand side in ${toNodeDescription(ancestor)}.`),
  InvalidNumber: _2('Invalid number.'),
  InvalidOrMissingExponent: _2("Floating-point numbers require a valid exponent after the 'e'."),
  InvalidOrUnexpectedToken: _2(({ unexpected }) => `Unexpected character '${unexpected}'.`),
  InvalidParenthesizedAssignment: _2('Invalid parenthesized assignment pattern.'),
  InvalidPrivateFieldResolution: _2(({ identifierName }) => `Private name #${identifierName} is not defined.`),
  InvalidPropertyBindingPattern: _2('Binding member expression.'),
  InvalidRecordProperty: _2('Only properties and spread elements are allowed in record definitions.'),
  InvalidRestAssignmentPattern: _2("Invalid rest operator's argument."),
  LabelRedeclaration: _2(({ labelName }) => `Label '${labelName}' is already declared.`),
  LetInLexicalBinding: _2("'let' is not allowed to be used as a name in 'let' or 'const' declarations."),
  LineTerminatorBeforeArrow: _2("No line break is allowed before '=>'."),
  MalformedRegExpFlags: _2('Invalid regular expression flag.'),
  MissingClassName: _2('A class name is required.'),
  MissingEqInAssignment: _2("Only '=' operator can be used for specifying default value."),
  MissingSemicolon: _2('Missing semicolon.'),
  MissingPlugin: _2(
    ({ missingPlugin }) =>
      `This experimental syntax requires enabling the parser plugin: ${missingPlugin
        .map((name) => JSON.stringify(name))
        .join(', ')}.`
  ),
  MissingOneOfPlugins: _2(
    ({ missingPlugin }) =>
      `This experimental syntax requires enabling one of the following parser plugin(s): ${missingPlugin
        .map((name) => JSON.stringify(name))
        .join(', ')}.`
  ),
  MissingUnicodeEscape: _2('Expecting Unicode escape sequence \\uXXXX.'),
  MixingCoalesceWithLogical: _2('Nullish coalescing operator(??) requires parens when mixing with logical operators.'),
  ModuleAttributeDifferentFromType: _2('The only accepted module attribute is `type`.'),
  ModuleAttributeInvalidValue: _2('Only string literals are allowed as module attribute values.'),
  ModuleAttributesWithDuplicateKeys: _2(({ key }) => `Duplicate key "${key}" is not allowed in module attributes.`),
  ModuleExportNameHasLoneSurrogate: _2(
    ({ surrogateCharCode }) =>
      `An export name cannot include a lone surrogate, found '\\u${surrogateCharCode.toString(16)}'.`
  ),
  ModuleExportUndefined: _2(({ localName }) => `Export '${localName}' is not defined.`),
  MultipleDefaultsInSwitch: _2('Multiple default clauses.'),
  NewlineAfterThrow: _2('Illegal newline after throw.'),
  NoCatchOrFinally: _2('Missing catch or finally clause.'),
  NumberIdentifier: _2('Identifier directly after number.'),
  NumericSeparatorInEscapeSequence: _2(
    'Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.'
  ),
  ObsoleteAwaitStar: _2("'await*' has been removed from the async functions proposal. Use Promise.all() instead."),
  OptionalChainingNoNew: _2('Constructors in/after an Optional Chain are not allowed.'),
  OptionalChainingNoTemplate: _2('Tagged Template Literals are not allowed in optionalChain.'),
  OverrideOnConstructor: _2("'override' modifier cannot appear on a constructor declaration."),
  ParamDupe: _2('Argument name clash.'),
  PatternHasAccessor: _2("Object pattern can't contain getter or setter."),
  PatternHasMethod: _2("Object pattern can't contain methods."),
  PrivateInExpectedIn: _2(
    ({ identifierName }) =>
      `Private names are only allowed in property accesses (\`obj.#${identifierName}\`) or in \`in\` expressions (\`#${identifierName} in obj\`).`
  ),
  PrivateNameRedeclaration: _2(({ identifierName }) => `Duplicate private name #${identifierName}.`),
  RecordExpressionBarIncorrectEndSyntaxType: _2(
    "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'."
  ),
  RecordExpressionBarIncorrectStartSyntaxType: _2(
    "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'."
  ),
  RecordExpressionHashIncorrectStartSyntaxType: _2(
    "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'."
  ),
  RecordNoProto: _2("'__proto__' is not allowed in Record expressions."),
  RestTrailingComma: _2('Unexpected trailing comma after rest element.'),
  SloppyFunction: _2(
    'In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.'
  ),
  StaticPrototype: _2('Classes may not have static property named prototype.'),
  SuperNotAllowed: _2(
    "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?"
  ),
  SuperPrivateField: _2("Private fields can't be accessed on super."),
  TrailingDecorator: _2('Decorators must be attached to a class element.'),
  TupleExpressionBarIncorrectEndSyntaxType: _2(
    "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'."
  ),
  TupleExpressionBarIncorrectStartSyntaxType: _2(
    "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'."
  ),
  TupleExpressionHashIncorrectStartSyntaxType: _2(
    "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'."
  ),
  UnexpectedArgumentPlaceholder: _2('Unexpected argument placeholder.'),
  UnexpectedAwaitAfterPipelineBody: _2(
    'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.'
  ),
  UnexpectedDigitAfterHash: _2('Unexpected digit after hash token.'),
  UnexpectedImportExport: _2("'import' and 'export' may only appear at the top level."),
  UnexpectedKeyword: _2(({ keyword: keyword2 }) => `Unexpected keyword '${keyword2}'.`),
  UnexpectedLeadingDecorator: _2('Leading decorators must be attached to a class declaration.'),
  UnexpectedLexicalDeclaration: _2('Lexical declaration cannot appear in a single-statement context.'),
  UnexpectedNewTarget: _2('`new.target` can only be used in functions or class properties.'),
  UnexpectedNumericSeparator: _2('A numeric separator is only allowed between two digits.'),
  UnexpectedPrivateField: _2('Unexpected private name.'),
  UnexpectedReservedWord: _2(({ reservedWord }) => `Unexpected reserved word '${reservedWord}'.`),
  UnexpectedSuper: _2("'super' is only allowed in object methods and classes."),
  UnexpectedToken: _2(
    ({ expected, unexpected }) =>
      `Unexpected token${unexpected ? ` '${unexpected}'.` : ''}${expected ? `, expected "${expected}"` : ''}`
  ),
  UnexpectedTokenUnaryExponentiation: _2(
    'Illegal expression. Wrap left hand side or entire exponentiation in parentheses.'
  ),
  UnsupportedBind: _2('Binding should be performed on object property.'),
  UnsupportedDecoratorExport: _2('A decorated export must export a class declaration.'),
  UnsupportedDefaultExport: _2('Only expressions, functions or classes are allowed as the `default` export.'),
  UnsupportedImport: _2('`import` can only be used in `import()` or `import.meta`.'),
  UnsupportedMetaProperty: _2(
    ({ target, onlyValidPropertyName }) =>
      `The only valid meta property for ${target} is ${target}.${onlyValidPropertyName}.`
  ),
  UnsupportedParameterDecorator: _2('Decorators cannot be used to decorate parameters.'),
  UnsupportedPropertyDecorator: _2('Decorators cannot be used to decorate object literal properties.'),
  UnsupportedSuper: _2(
    "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop])."
  ),
  UnterminatedComment: _2('Unterminated comment.'),
  UnterminatedRegExp: _2('Unterminated regular expression.'),
  UnterminatedString: _2('Unterminated string constant.'),
  UnterminatedTemplate: _2('Unterminated template.'),
  VarRedeclaration: _2(({ identifierName }) => `Identifier '${identifierName}' has already been declared.`),
  YieldBindingIdentifier: _2("Can not use 'yield' as identifier inside a generator."),
  YieldInParameter: _2('Yield expression is not allowed in formal parameters.'),
  ZeroDigitNumericSeparator: _2('Numeric separator can not be used after leading 0.'),
})
var StrictModeErrors = (_2) => ({
  StrictDelete: _2('Deleting local variable in strict mode.'),
  StrictEvalArguments: _2(({ referenceName }) => `Assigning to '${referenceName}' in strict mode.`),
  StrictEvalArgumentsBinding: _2(({ bindingName }) => `Binding '${bindingName}' in strict mode.`),
  StrictFunction: _2('In strict mode code, functions can only be declared at top level or inside a block.'),
  StrictNumericEscape: _2("The only valid numeric escape in strict mode is '\\0'."),
  StrictOctalLiteral: _2('Legacy octal literals are not allowed in strict mode.'),
  StrictWith: _2("'with' in strict mode."),
})
const UnparenthesizedPipeBodyDescriptions = /* @__PURE__ */ new Set([
  'ArrowFunctionExpression',
  'AssignmentExpression',
  'ConditionalExpression',
  'YieldExpression',
])
var PipelineOperatorErrors = (_2) => ({
  PipeBodyIsTighter: _2(
    'Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.'
  ),
  PipeTopicRequiresHackPipes: _2(
    'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.'
  ),
  PipeTopicUnbound: _2('Topic reference is unbound; it must be inside a pipe body.'),
  PipeTopicUnconfiguredToken: _2(
    ({ token }) =>
      `Invalid topic token ${token}. In order to use ${token} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${token}" }.`
  ),
  PipeTopicUnused: _2(
    'Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.'
  ),
  PipeUnparenthesizedBody: _2(
    ({ type }) =>
      `Hack-style pipe body cannot be an unparenthesized ${toNodeDescription({
        type,
      })}; please wrap it in parentheses.`
  ),
  PipelineBodyNoArrow: _2(
    'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.'
  ),
  PipelineBodySequenceExpression: _2('Pipeline body may not be a comma-separated sequence expression.'),
  PipelineHeadSequenceExpression: _2('Pipeline head should not be a comma-separated sequence expression.'),
  PipelineTopicUnused: _2('Pipeline is in topic style but does not use topic reference.'),
  PrimaryTopicNotAllowed: _2('Topic reference was used in a lexical context without topic binding.'),
  PrimaryTopicRequiresSmartPipeline: _2(
    'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.'
  ),
})
const _excluded$1 = ['toMessage']
function toParseErrorConstructor(_ref) {
  let { toMessage } = _ref,
    properties = _objectWithoutPropertiesLoose$1(_ref, _excluded$1)
  return function constructor({ loc, details }) {
    return instantiate(
      SyntaxError,
      Object.assign({}, properties, {
        loc,
      }),
      {
        clone(overrides = {}) {
          const loc2 = overrides.loc || {}
          return constructor({
            loc: new Position(
              'line' in loc2 ? loc2.line : this.loc.line,
              'column' in loc2 ? loc2.column : this.loc.column,
              'index' in loc2 ? loc2.index : this.loc.index
            ),
            details: Object.assign({}, this.details, overrides.details),
          })
        },
        details: {
          value: details,
          enumerable: false,
        },
        message: {
          get() {
            return `${toMessage(this.details)} (${this.loc.line}:${this.loc.column})`
          },
          set(value) {
            Object.defineProperty(this, 'message', {
              value,
            })
          },
        },
        pos: {
          reflect: 'loc.index',
          enumerable: true,
        },
        missingPlugin: 'missingPlugin' in details && {
          reflect: 'details.missingPlugin',
          enumerable: true,
        },
      }
    )
  }
}
function toParseErrorCredentials(toMessageOrMessage, credentials) {
  return Object.assign(
    {
      toMessage: typeof toMessageOrMessage === 'string' ? () => toMessageOrMessage : toMessageOrMessage,
    },
    credentials
  )
}
function ParseErrorEnum(argument, syntaxPlugin) {
  if (Array.isArray(argument)) {
    return (toParseErrorCredentialsMap) => ParseErrorEnum(toParseErrorCredentialsMap, argument[0])
  }
  const partialCredentials = argument(toParseErrorCredentials)
  const ParseErrorConstructors = {}
  for (const reasonCode of Object.keys(partialCredentials)) {
    ParseErrorConstructors[reasonCode] = toParseErrorConstructor(
      Object.assign(
        {
          code: ParseErrorCodes.SyntaxError,
          reasonCode,
        },
        syntaxPlugin
          ? {
              syntaxPlugin,
            }
          : {},
        partialCredentials[reasonCode]
      )
    )
  }
  return ParseErrorConstructors
}
const Errors = Object.assign(
  {},
  ParseErrorEnum(ModuleErrors),
  ParseErrorEnum(StandardErrors),
  ParseErrorEnum(StrictModeErrors),
  ParseErrorEnum`pipelineOperator`(PipelineOperatorErrors)
)
const { defineProperty } = Object
const toUnenumerable = (object2, key) =>
  defineProperty(object2, key, {
    enumerable: false,
    value: object2[key],
  })
function toESTreeLocation(node2) {
  node2.loc.start && toUnenumerable(node2.loc.start, 'index')
  node2.loc.end && toUnenumerable(node2.loc.end, 'index')
  return node2
}
var estree = (superClass) =>
  class extends superClass {
    parse() {
      const file2 = toESTreeLocation(super.parse())
      if (this.options.tokens) {
        file2.tokens = file2.tokens.map(toESTreeLocation)
      }
      return file2
    }
    parseRegExpLiteral({ pattern, flags }) {
      let regex = null
      try {
        regex = new RegExp(pattern, flags)
      } catch (e) {}
      const node2 = this.estreeParseLiteral(regex)
      node2.regex = {
        pattern,
        flags,
      }
      return node2
    }
    parseBigIntLiteral(value) {
      let bigInt
      try {
        bigInt = BigInt(value)
      } catch (_unused) {
        bigInt = null
      }
      const node2 = this.estreeParseLiteral(bigInt)
      node2.bigint = String(node2.value || value)
      return node2
    }
    parseDecimalLiteral(value) {
      const decimal = null
      const node2 = this.estreeParseLiteral(decimal)
      node2.decimal = String(node2.value || value)
      return node2
    }
    estreeParseLiteral(value) {
      return this.parseLiteral(value, 'Literal')
    }
    parseStringLiteral(value) {
      return this.estreeParseLiteral(value)
    }
    parseNumericLiteral(value) {
      return this.estreeParseLiteral(value)
    }
    parseNullLiteral() {
      return this.estreeParseLiteral(null)
    }
    parseBooleanLiteral(value) {
      return this.estreeParseLiteral(value)
    }
    directiveToStmt(directive2) {
      const directiveLiteral2 = directive2.value
      const stmt = this.startNodeAt(directive2.start, directive2.loc.start)
      const expression2 = this.startNodeAt(directiveLiteral2.start, directiveLiteral2.loc.start)
      expression2.value = directiveLiteral2.extra.expressionValue
      expression2.raw = directiveLiteral2.extra.raw
      stmt.expression = this.finishNodeAt(expression2, 'Literal', directiveLiteral2.loc.end)
      stmt.directive = directiveLiteral2.extra.raw.slice(1, -1)
      return this.finishNodeAt(stmt, 'ExpressionStatement', directive2.loc.end)
    }
    initFunction(node2, isAsync) {
      super.initFunction(node2, isAsync)
      node2.expression = false
    }
    checkDeclaration(node2) {
      if (node2 != null && this.isObjectProperty(node2)) {
        this.checkDeclaration(node2.value)
      } else {
        super.checkDeclaration(node2)
      }
    }
    getObjectOrClassMethodParams(method) {
      return method.value.params
    }
    isValidDirective(stmt) {
      var _stmt$expression$extr
      return (
        stmt.type === 'ExpressionStatement' &&
        stmt.expression.type === 'Literal' &&
        typeof stmt.expression.value === 'string' &&
        !((_stmt$expression$extr = stmt.expression.extra) != null && _stmt$expression$extr.parenthesized)
      )
    }
    parseBlockBody(node2, ...args) {
      super.parseBlockBody(node2, ...args)
      const directiveStatements = node2.directives.map((d2) => this.directiveToStmt(d2))
      node2.body = directiveStatements.concat(node2.body)
      delete node2.directives
    }
    pushClassMethod(classBody2, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
      this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, 'ClassMethod', true)
      if (method.typeParameters) {
        method.value.typeParameters = method.typeParameters
        delete method.typeParameters
      }
      classBody2.body.push(method)
    }
    parsePrivateName() {
      const node2 = super.parsePrivateName()
      {
        if (!this.getPluginOption('estree', 'classFeatures')) {
          return node2
        }
      }
      return this.convertPrivateNameToPrivateIdentifier(node2)
    }
    convertPrivateNameToPrivateIdentifier(node2) {
      const name = super.getPrivateNameSV(node2)
      node2 = node2
      delete node2.id
      node2.name = name
      node2.type = 'PrivateIdentifier'
      return node2
    }
    isPrivateName(node2) {
      {
        if (!this.getPluginOption('estree', 'classFeatures')) {
          return super.isPrivateName(node2)
        }
      }
      return node2.type === 'PrivateIdentifier'
    }
    getPrivateNameSV(node2) {
      {
        if (!this.getPluginOption('estree', 'classFeatures')) {
          return super.getPrivateNameSV(node2)
        }
      }
      return node2.name
    }
    parseLiteral(value, type) {
      const node2 = super.parseLiteral(value, type)
      node2.raw = node2.extra.raw
      delete node2.extra
      return node2
    }
    parseFunctionBody(node2, allowExpression, isMethod2 = false) {
      super.parseFunctionBody(node2, allowExpression, isMethod2)
      node2.expression = node2.body.type !== 'BlockStatement'
    }
    parseMethod(node2, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {
      let funcNode = this.startNode()
      funcNode.kind = node2.kind
      funcNode = super.parseMethod(funcNode, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope)
      funcNode.type = 'FunctionExpression'
      delete funcNode.kind
      node2.value = funcNode
      if (type === 'ClassPrivateMethod') {
        node2.computed = false
      }
      type = 'MethodDefinition'
      return this.finishNode(node2, type)
    }
    parseClassProperty(...args) {
      const propertyNode = super.parseClassProperty(...args)
      {
        if (!this.getPluginOption('estree', 'classFeatures')) {
          return propertyNode
        }
      }
      propertyNode.type = 'PropertyDefinition'
      return propertyNode
    }
    parseClassPrivateProperty(...args) {
      const propertyNode = super.parseClassPrivateProperty(...args)
      {
        if (!this.getPluginOption('estree', 'classFeatures')) {
          return propertyNode
        }
      }
      propertyNode.type = 'PropertyDefinition'
      propertyNode.computed = false
      return propertyNode
    }
    parseObjectMethod(prop, isGenerator, isAsync, isPattern2, isAccessor2) {
      const node2 = super.parseObjectMethod(prop, isGenerator, isAsync, isPattern2, isAccessor2)
      if (node2) {
        node2.type = 'Property'
        if (node2.kind === 'method') node2.kind = 'init'
        node2.shorthand = false
      }
      return node2
    }
    parseObjectProperty(prop, startPos, startLoc, isPattern2, refExpressionErrors) {
      const node2 = super.parseObjectProperty(prop, startPos, startLoc, isPattern2, refExpressionErrors)
      if (node2) {
        node2.kind = 'init'
        node2.type = 'Property'
      }
      return node2
    }
    isValidLVal(type, ...rest) {
      return type === 'Property' ? 'value' : super.isValidLVal(type, ...rest)
    }
    isAssignable(node2, isBinding2) {
      if (node2 != null && this.isObjectProperty(node2)) {
        return this.isAssignable(node2.value, isBinding2)
      }
      return super.isAssignable(node2, isBinding2)
    }
    toAssignable(node2, isLHS = false) {
      if (node2 != null && this.isObjectProperty(node2)) {
        const { key, value } = node2
        if (this.isPrivateName(key)) {
          this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start)
        }
        this.toAssignable(value, isLHS)
      } else {
        super.toAssignable(node2, isLHS)
      }
    }
    toAssignableObjectExpressionProp(prop) {
      if (prop.kind === 'get' || prop.kind === 'set') {
        this.raise(Errors.PatternHasAccessor, {
          at: prop.key,
        })
      } else if (prop.method) {
        this.raise(Errors.PatternHasMethod, {
          at: prop.key,
        })
      } else {
        super.toAssignableObjectExpressionProp(...arguments)
      }
    }
    finishCallExpression(node2, optional) {
      super.finishCallExpression(node2, optional)
      if (node2.callee.type === 'Import') {
        node2.type = 'ImportExpression'
        node2.source = node2.arguments[0]
        if (this.hasPlugin('importAssertions')) {
          var _node$arguments$
          node2.attributes = (_node$arguments$ = node2.arguments[1]) != null ? _node$arguments$ : null
        }
        delete node2.arguments
        delete node2.callee
      }
      return node2
    }
    toReferencedArguments(node2) {
      if (node2.type === 'ImportExpression') {
        return
      }
      super.toReferencedArguments(node2)
    }
    parseExport(node2) {
      super.parseExport(node2)
      switch (node2.type) {
        case 'ExportAllDeclaration':
          node2.exported = null
          break
        case 'ExportNamedDeclaration':
          if (node2.specifiers.length === 1 && node2.specifiers[0].type === 'ExportNamespaceSpecifier') {
            node2.type = 'ExportAllDeclaration'
            node2.exported = node2.specifiers[0].exported
            delete node2.specifiers
          }
          break
      }
      return node2
    }
    parseSubscript(base2, startPos, startLoc, noCalls, state) {
      const node2 = super.parseSubscript(base2, startPos, startLoc, noCalls, state)
      if (state.optionalChainMember) {
        if (node2.type === 'OptionalMemberExpression' || node2.type === 'OptionalCallExpression') {
          node2.type = node2.type.substring(8)
        }
        if (state.stop) {
          const chain2 = this.startNodeAtNode(node2)
          chain2.expression = node2
          return this.finishNode(chain2, 'ChainExpression')
        }
      } else if (node2.type === 'MemberExpression' || node2.type === 'CallExpression') {
        node2.optional = false
      }
      return node2
    }
    hasPropertyAsPrivateName(node2) {
      if (node2.type === 'ChainExpression') {
        node2 = node2.expression
      }
      return super.hasPropertyAsPrivateName(node2)
    }
    isOptionalChain(node2) {
      return node2.type === 'ChainExpression'
    }
    isObjectProperty(node2) {
      return node2.type === 'Property' && node2.kind === 'init' && !node2.method
    }
    isObjectMethod(node2) {
      return node2.method || node2.kind === 'get' || node2.kind === 'set'
    }
    finishNodeAt(node2, type, endLoc) {
      return toESTreeLocation(super.finishNodeAt(node2, type, endLoc))
    }
    resetStartLocation(node2, start, startLoc) {
      super.resetStartLocation(node2, start, startLoc)
      toESTreeLocation(node2)
    }
    resetEndLocation(node2, endLoc = this.state.lastTokEndLoc) {
      super.resetEndLocation(node2, endLoc)
      toESTreeLocation(node2)
    }
  }
class TokContext {
  constructor(token, preserveSpace) {
    this.token = void 0
    this.preserveSpace = void 0
    this.token = token
    this.preserveSpace = !!preserveSpace
  }
}
const types = {
  brace: new TokContext('{'),
  j_oTag: new TokContext('<tag'),
  j_cTag: new TokContext('</tag'),
  j_expr: new TokContext('<tag>...</tag>', true),
}
{
  types.template = new TokContext('`', true)
}
const beforeExpr = true
const startsExpr = true
const isLoop = true
const isAssign = true
const prefix = true
const postfix = true
class ExportedTokenType {
  constructor(label, conf = {}) {
    this.label = void 0
    this.keyword = void 0
    this.beforeExpr = void 0
    this.startsExpr = void 0
    this.rightAssociative = void 0
    this.isLoop = void 0
    this.isAssign = void 0
    this.prefix = void 0
    this.postfix = void 0
    this.binop = void 0
    this.label = label
    this.keyword = conf.keyword
    this.beforeExpr = !!conf.beforeExpr
    this.startsExpr = !!conf.startsExpr
    this.rightAssociative = !!conf.rightAssociative
    this.isLoop = !!conf.isLoop
    this.isAssign = !!conf.isAssign
    this.prefix = !!conf.prefix
    this.postfix = !!conf.postfix
    this.binop = conf.binop != null ? conf.binop : null
    {
      this.updateContext = null
    }
  }
}
const keywords$1 = /* @__PURE__ */ new Map()
function createKeyword(name, options2 = {}) {
  options2.keyword = name
  const token = createToken(name, options2)
  keywords$1.set(name, token)
  return token
}
function createBinop(name, binop) {
  return createToken(name, {
    beforeExpr,
    binop,
  })
}
let tokenTypeCounter = -1
const tokenTypes = []
const tokenLabels = []
const tokenBinops = []
const tokenBeforeExprs = []
const tokenStartsExprs = []
const tokenPrefixes = []
function createToken(name, options2 = {}) {
  var _options$binop, _options$beforeExpr, _options$startsExpr, _options$prefix
  ++tokenTypeCounter
  tokenLabels.push(name)
  tokenBinops.push((_options$binop = options2.binop) != null ? _options$binop : -1)
  tokenBeforeExprs.push((_options$beforeExpr = options2.beforeExpr) != null ? _options$beforeExpr : false)
  tokenStartsExprs.push((_options$startsExpr = options2.startsExpr) != null ? _options$startsExpr : false)
  tokenPrefixes.push((_options$prefix = options2.prefix) != null ? _options$prefix : false)
  tokenTypes.push(new ExportedTokenType(name, options2))
  return tokenTypeCounter
}
function createKeywordLike(name, options2) {
  var _options$binop2, _options$beforeExpr2, _options$startsExpr2, _options$prefix2
  ++tokenTypeCounter
  keywords$1.set(name, tokenTypeCounter)
  tokenLabels.push(name)
  tokenBinops.push((_options$binop2 = options2.binop) != null ? _options$binop2 : -1)
  tokenBeforeExprs.push((_options$beforeExpr2 = options2.beforeExpr) != null ? _options$beforeExpr2 : false)
  tokenStartsExprs.push((_options$startsExpr2 = options2.startsExpr) != null ? _options$startsExpr2 : false)
  tokenPrefixes.push((_options$prefix2 = options2.prefix) != null ? _options$prefix2 : false)
  tokenTypes.push(new ExportedTokenType('name', options2))
  return tokenTypeCounter
}
const tt = {
  bracketL: createToken('[', {
    beforeExpr,
    startsExpr,
  }),
  bracketHashL: createToken('#[', {
    beforeExpr,
    startsExpr,
  }),
  bracketBarL: createToken('[|', {
    beforeExpr,
    startsExpr,
  }),
  bracketR: createToken(']'),
  bracketBarR: createToken('|]'),
  braceL: createToken('{', {
    beforeExpr,
    startsExpr,
  }),
  braceBarL: createToken('{|', {
    beforeExpr,
    startsExpr,
  }),
  braceHashL: createToken('#{', {
    beforeExpr,
    startsExpr,
  }),
  braceR: createToken('}'),
  braceBarR: createToken('|}'),
  parenL: createToken('(', {
    beforeExpr,
    startsExpr,
  }),
  parenR: createToken(')'),
  comma: createToken(',', {
    beforeExpr,
  }),
  semi: createToken(';', {
    beforeExpr,
  }),
  colon: createToken(':', {
    beforeExpr,
  }),
  doubleColon: createToken('::', {
    beforeExpr,
  }),
  dot: createToken('.'),
  question: createToken('?', {
    beforeExpr,
  }),
  questionDot: createToken('?.'),
  arrow: createToken('=>', {
    beforeExpr,
  }),
  template: createToken('template'),
  ellipsis: createToken('...', {
    beforeExpr,
  }),
  backQuote: createToken('`', {
    startsExpr,
  }),
  dollarBraceL: createToken('${', {
    beforeExpr,
    startsExpr,
  }),
  templateTail: createToken('...`', {
    startsExpr,
  }),
  templateNonTail: createToken('...${', {
    beforeExpr,
    startsExpr,
  }),
  at: createToken('@'),
  hash: createToken('#', {
    startsExpr,
  }),
  interpreterDirective: createToken('#!...'),
  eq: createToken('=', {
    beforeExpr,
    isAssign,
  }),
  assign: createToken('_=', {
    beforeExpr,
    isAssign,
  }),
  slashAssign: createToken('_=', {
    beforeExpr,
    isAssign,
  }),
  xorAssign: createToken('_=', {
    beforeExpr,
    isAssign,
  }),
  moduloAssign: createToken('_=', {
    beforeExpr,
    isAssign,
  }),
  incDec: createToken('++/--', {
    prefix,
    postfix,
    startsExpr,
  }),
  bang: createToken('!', {
    beforeExpr,
    prefix,
    startsExpr,
  }),
  tilde: createToken('~', {
    beforeExpr,
    prefix,
    startsExpr,
  }),
  doubleCaret: createToken('^^', {
    startsExpr,
  }),
  doubleAt: createToken('@@', {
    startsExpr,
  }),
  pipeline: createBinop('|>', 0),
  nullishCoalescing: createBinop('??', 1),
  logicalOR: createBinop('||', 1),
  logicalAND: createBinop('&&', 2),
  bitwiseOR: createBinop('|', 3),
  bitwiseXOR: createBinop('^', 4),
  bitwiseAND: createBinop('&', 5),
  equality: createBinop('==/!=/===/!==', 6),
  lt: createBinop('</>/<=/>=', 7),
  gt: createBinop('</>/<=/>=', 7),
  relational: createBinop('</>/<=/>=', 7),
  bitShift: createBinop('<</>>/>>>', 8),
  bitShiftL: createBinop('<</>>/>>>', 8),
  bitShiftR: createBinop('<</>>/>>>', 8),
  plusMin: createToken('+/-', {
    beforeExpr,
    binop: 9,
    prefix,
    startsExpr,
  }),
  modulo: createToken('%', {
    binop: 10,
    startsExpr,
  }),
  star: createToken('*', {
    binop: 10,
  }),
  slash: createBinop('/', 10),
  exponent: createToken('**', {
    beforeExpr,
    binop: 11,
    rightAssociative: true,
  }),
  _in: createKeyword('in', {
    beforeExpr,
    binop: 7,
  }),
  _instanceof: createKeyword('instanceof', {
    beforeExpr,
    binop: 7,
  }),
  _break: createKeyword('break'),
  _case: createKeyword('case', {
    beforeExpr,
  }),
  _catch: createKeyword('catch'),
  _continue: createKeyword('continue'),
  _debugger: createKeyword('debugger'),
  _default: createKeyword('default', {
    beforeExpr,
  }),
  _else: createKeyword('else', {
    beforeExpr,
  }),
  _finally: createKeyword('finally'),
  _function: createKeyword('function', {
    startsExpr,
  }),
  _if: createKeyword('if'),
  _return: createKeyword('return', {
    beforeExpr,
  }),
  _switch: createKeyword('switch'),
  _throw: createKeyword('throw', {
    beforeExpr,
    prefix,
    startsExpr,
  }),
  _try: createKeyword('try'),
  _var: createKeyword('var'),
  _const: createKeyword('const'),
  _with: createKeyword('with'),
  _new: createKeyword('new', {
    beforeExpr,
    startsExpr,
  }),
  _this: createKeyword('this', {
    startsExpr,
  }),
  _super: createKeyword('super', {
    startsExpr,
  }),
  _class: createKeyword('class', {
    startsExpr,
  }),
  _extends: createKeyword('extends', {
    beforeExpr,
  }),
  _export: createKeyword('export'),
  _import: createKeyword('import', {
    startsExpr,
  }),
  _null: createKeyword('null', {
    startsExpr,
  }),
  _true: createKeyword('true', {
    startsExpr,
  }),
  _false: createKeyword('false', {
    startsExpr,
  }),
  _typeof: createKeyword('typeof', {
    beforeExpr,
    prefix,
    startsExpr,
  }),
  _void: createKeyword('void', {
    beforeExpr,
    prefix,
    startsExpr,
  }),
  _delete: createKeyword('delete', {
    beforeExpr,
    prefix,
    startsExpr,
  }),
  _do: createKeyword('do', {
    isLoop,
    beforeExpr,
  }),
  _for: createKeyword('for', {
    isLoop,
  }),
  _while: createKeyword('while', {
    isLoop,
  }),
  _as: createKeywordLike('as', {
    startsExpr,
  }),
  _assert: createKeywordLike('assert', {
    startsExpr,
  }),
  _async: createKeywordLike('async', {
    startsExpr,
  }),
  _await: createKeywordLike('await', {
    startsExpr,
  }),
  _from: createKeywordLike('from', {
    startsExpr,
  }),
  _get: createKeywordLike('get', {
    startsExpr,
  }),
  _let: createKeywordLike('let', {
    startsExpr,
  }),
  _meta: createKeywordLike('meta', {
    startsExpr,
  }),
  _of: createKeywordLike('of', {
    startsExpr,
  }),
  _sent: createKeywordLike('sent', {
    startsExpr,
  }),
  _set: createKeywordLike('set', {
    startsExpr,
  }),
  _static: createKeywordLike('static', {
    startsExpr,
  }),
  _yield: createKeywordLike('yield', {
    startsExpr,
  }),
  _asserts: createKeywordLike('asserts', {
    startsExpr,
  }),
  _checks: createKeywordLike('checks', {
    startsExpr,
  }),
  _exports: createKeywordLike('exports', {
    startsExpr,
  }),
  _global: createKeywordLike('global', {
    startsExpr,
  }),
  _implements: createKeywordLike('implements', {
    startsExpr,
  }),
  _intrinsic: createKeywordLike('intrinsic', {
    startsExpr,
  }),
  _infer: createKeywordLike('infer', {
    startsExpr,
  }),
  _is: createKeywordLike('is', {
    startsExpr,
  }),
  _mixins: createKeywordLike('mixins', {
    startsExpr,
  }),
  _proto: createKeywordLike('proto', {
    startsExpr,
  }),
  _require: createKeywordLike('require', {
    startsExpr,
  }),
  _keyof: createKeywordLike('keyof', {
    startsExpr,
  }),
  _readonly: createKeywordLike('readonly', {
    startsExpr,
  }),
  _unique: createKeywordLike('unique', {
    startsExpr,
  }),
  _abstract: createKeywordLike('abstract', {
    startsExpr,
  }),
  _declare: createKeywordLike('declare', {
    startsExpr,
  }),
  _enum: createKeywordLike('enum', {
    startsExpr,
  }),
  _module: createKeywordLike('module', {
    startsExpr,
  }),
  _namespace: createKeywordLike('namespace', {
    startsExpr,
  }),
  _interface: createKeywordLike('interface', {
    startsExpr,
  }),
  _type: createKeywordLike('type', {
    startsExpr,
  }),
  _opaque: createKeywordLike('opaque', {
    startsExpr,
  }),
  name: createToken('name', {
    startsExpr,
  }),
  string: createToken('string', {
    startsExpr,
  }),
  num: createToken('num', {
    startsExpr,
  }),
  bigint: createToken('bigint', {
    startsExpr,
  }),
  decimal: createToken('decimal', {
    startsExpr,
  }),
  regexp: createToken('regexp', {
    startsExpr,
  }),
  privateName: createToken('#name', {
    startsExpr,
  }),
  eof: createToken('eof'),
  jsxName: createToken('jsxName'),
  jsxText: createToken('jsxText', {
    beforeExpr: true,
  }),
  jsxTagStart: createToken('jsxTagStart', {
    startsExpr: true,
  }),
  jsxTagEnd: createToken('jsxTagEnd'),
  placeholder: createToken('%%', {
    startsExpr: true,
  }),
}
function tokenIsIdentifier(token) {
  return token >= 93 && token <= 128
}
function tokenKeywordOrIdentifierIsKeyword(token) {
  return token <= 92
}
function tokenIsKeywordOrIdentifier(token) {
  return token >= 58 && token <= 128
}
function tokenIsLiteralPropertyName(token) {
  return token >= 58 && token <= 132
}
function tokenComesBeforeExpression(token) {
  return tokenBeforeExprs[token]
}
function tokenCanStartExpression(token) {
  return tokenStartsExprs[token]
}
function tokenIsAssignment(token) {
  return token >= 29 && token <= 33
}
function tokenIsFlowInterfaceOrTypeOrOpaque(token) {
  return token >= 125 && token <= 127
}
function tokenIsLoop(token) {
  return token >= 90 && token <= 92
}
function tokenIsKeyword(token) {
  return token >= 58 && token <= 92
}
function tokenIsOperator(token) {
  return token >= 39 && token <= 59
}
function tokenIsPostfix(token) {
  return token === 34
}
function tokenIsPrefix(token) {
  return tokenPrefixes[token]
}
function tokenIsTSTypeOperator(token) {
  return token >= 117 && token <= 119
}
function tokenIsTSDeclarationStart(token) {
  return token >= 120 && token <= 126
}
function tokenLabelName(token) {
  return tokenLabels[token]
}
function tokenOperatorPrecedence(token) {
  return tokenBinops[token]
}
function tokenIsBinaryOperator(token) {
  return tokenBinops[token] !== -1
}
function tokenIsRightAssociative(token) {
  return token === 57
}
function tokenIsTemplate(token) {
  return token >= 24 && token <= 25
}
function getExportedToken(token) {
  return tokenTypes[token]
}
{
  tokenTypes[8].updateContext = (context2) => {
    context2.pop()
  }
  tokenTypes[5].updateContext =
    tokenTypes[7].updateContext =
    tokenTypes[23].updateContext =
      (context2) => {
        context2.push(types.brace)
      }
  tokenTypes[22].updateContext = (context2) => {
    if (context2[context2.length - 1] === types.template) {
      context2.pop()
    } else {
      context2.push(types.template)
    }
  }
  tokenTypes[138].updateContext = (context2) => {
    context2.push(types.j_expr, types.j_oTag)
  }
}
let nonASCIIidentifierStartChars =
  '\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC'
let nonASCIIidentifierChars =
  '\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F'
const nonASCIIidentifierStart = new RegExp('[' + nonASCIIidentifierStartChars + ']')
const nonASCIIidentifier = new RegExp('[' + nonASCIIidentifierStartChars + nonASCIIidentifierChars + ']')
nonASCIIidentifierStartChars = nonASCIIidentifierChars = null
const astralIdentifierStartCodes = [
  0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7,
  2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11,
  7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7,
  1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50,
  14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30,
  0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1,
  3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21,
  0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0,
  2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26,
  5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1070, 4050, 582, 8634, 568, 8, 30,
  18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8,
  8936, 3, 2, 6, 2, 1, 2, 290, 46, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3,
  3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2,
  30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 482, 44, 11, 6, 17, 0, 322, 29, 19, 43, 1269, 6, 2, 3, 2, 1, 2,
  14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2,
  1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421,
  42719, 33, 4152, 8, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938,
]
const astralIdentifierCodes = [
  509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 50, 3, 123,
  2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83,
  11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9,
  214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9,
  120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1,
  2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0,
  12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23,
  4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 357, 0, 62, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719,
  239,
]
function isInAstralSet(code2, set) {
  let pos = 65536
  for (let i = 0, length = set.length; i < length; i += 2) {
    pos += set[i]
    if (pos > code2) return false
    pos += set[i + 1]
    if (pos >= code2) return true
  }
  return false
}
function isIdentifierStart(code2) {
  if (code2 < 65) return code2 === 36
  if (code2 <= 90) return true
  if (code2 < 97) return code2 === 95
  if (code2 <= 122) return true
  if (code2 <= 65535) {
    return code2 >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code2))
  }
  return isInAstralSet(code2, astralIdentifierStartCodes)
}
function isIdentifierChar(code2) {
  if (code2 < 48) return code2 === 36
  if (code2 < 58) return true
  if (code2 < 65) return false
  if (code2 <= 90) return true
  if (code2 < 97) return code2 === 95
  if (code2 <= 122) return true
  if (code2 <= 65535) {
    return code2 >= 170 && nonASCIIidentifier.test(String.fromCharCode(code2))
  }
  return isInAstralSet(code2, astralIdentifierStartCodes) || isInAstralSet(code2, astralIdentifierCodes)
}
const reservedWords = {
  keyword: [
    'break',
    'case',
    'catch',
    'continue',
    'debugger',
    'default',
    'do',
    'else',
    'finally',
    'for',
    'function',
    'if',
    'return',
    'switch',
    'throw',
    'try',
    'var',
    'const',
    'while',
    'with',
    'new',
    'this',
    'super',
    'class',
    'extends',
    'export',
    'import',
    'null',
    'true',
    'false',
    'in',
    'instanceof',
    'typeof',
    'void',
    'delete',
  ],
  strict: ['implements', 'interface', 'let', 'package', 'private', 'protected', 'public', 'static', 'yield'],
  strictBind: ['eval', 'arguments'],
}
const keywords = new Set(reservedWords.keyword)
const reservedWordsStrictSet = new Set(reservedWords.strict)
const reservedWordsStrictBindSet = new Set(reservedWords.strictBind)
function isReservedWord(word, inModule) {
  return (inModule && word === 'await') || word === 'enum'
}
function isStrictReservedWord(word, inModule) {
  return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word)
}
function isStrictBindOnlyReservedWord(word) {
  return reservedWordsStrictBindSet.has(word)
}
function isStrictBindReservedWord(word, inModule) {
  return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word)
}
function isKeyword(word) {
  return keywords.has(word)
}
function isIteratorStart(current, next, next2) {
  return current === 64 && next === 64 && isIdentifierStart(next2)
}
const reservedWordLikeSet = /* @__PURE__ */ new Set([
  'break',
  'case',
  'catch',
  'continue',
  'debugger',
  'default',
  'do',
  'else',
  'finally',
  'for',
  'function',
  'if',
  'return',
  'switch',
  'throw',
  'try',
  'var',
  'const',
  'while',
  'with',
  'new',
  'this',
  'super',
  'class',
  'extends',
  'export',
  'import',
  'null',
  'true',
  'false',
  'in',
  'instanceof',
  'typeof',
  'void',
  'delete',
  'implements',
  'interface',
  'let',
  'package',
  'private',
  'protected',
  'public',
  'static',
  'yield',
  'eval',
  'arguments',
  'enum',
  'await',
])
function canBeReservedWord(word) {
  return reservedWordLikeSet.has(word)
}
const SCOPE_OTHER = 0,
  SCOPE_PROGRAM = 1,
  SCOPE_FUNCTION = 2,
  SCOPE_ARROW = 4,
  SCOPE_SIMPLE_CATCH = 8,
  SCOPE_SUPER = 16,
  SCOPE_DIRECT_SUPER = 32,
  SCOPE_CLASS = 64,
  SCOPE_STATIC_BLOCK = 128,
  SCOPE_TS_MODULE = 256,
  SCOPE_VAR = SCOPE_PROGRAM | SCOPE_FUNCTION | SCOPE_TS_MODULE
const BIND_KIND_VALUE = 1,
  BIND_KIND_TYPE = 2,
  BIND_SCOPE_VAR = 4,
  BIND_SCOPE_LEXICAL = 8,
  BIND_SCOPE_FUNCTION = 16,
  BIND_FLAGS_NONE = 64,
  BIND_FLAGS_CLASS = 128,
  BIND_FLAGS_TS_ENUM = 256,
  BIND_FLAGS_TS_CONST_ENUM = 512,
  BIND_FLAGS_TS_EXPORT_ONLY = 1024,
  BIND_FLAGS_FLOW_DECLARE_FN = 2048
const BIND_CLASS = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_CLASS,
  BIND_LEXICAL = BIND_KIND_VALUE | 0 | BIND_SCOPE_LEXICAL | 0,
  BIND_VAR = BIND_KIND_VALUE | 0 | BIND_SCOPE_VAR | 0,
  BIND_FUNCTION = BIND_KIND_VALUE | 0 | BIND_SCOPE_FUNCTION | 0,
  BIND_TS_INTERFACE = 0 | BIND_KIND_TYPE | 0 | BIND_FLAGS_CLASS,
  BIND_TS_TYPE = 0 | BIND_KIND_TYPE | 0 | 0,
  BIND_TS_ENUM = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_TS_ENUM,
  BIND_TS_AMBIENT = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY,
  BIND_NONE = 0 | 0 | 0 | BIND_FLAGS_NONE,
  BIND_OUTSIDE = BIND_KIND_VALUE | 0 | 0 | BIND_FLAGS_NONE,
  BIND_TS_CONST_ENUM = BIND_TS_ENUM | BIND_FLAGS_TS_CONST_ENUM,
  BIND_TS_NAMESPACE = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY,
  BIND_FLOW_DECLARE_FN = BIND_FLAGS_FLOW_DECLARE_FN
const CLASS_ELEMENT_FLAG_STATIC = 4,
  CLASS_ELEMENT_KIND_GETTER = 2,
  CLASS_ELEMENT_KIND_SETTER = 1,
  CLASS_ELEMENT_KIND_ACCESSOR = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_KIND_SETTER
const CLASS_ELEMENT_STATIC_GETTER = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_FLAG_STATIC,
  CLASS_ELEMENT_STATIC_SETTER = CLASS_ELEMENT_KIND_SETTER | CLASS_ELEMENT_FLAG_STATIC,
  CLASS_ELEMENT_INSTANCE_GETTER = CLASS_ELEMENT_KIND_GETTER,
  CLASS_ELEMENT_INSTANCE_SETTER = CLASS_ELEMENT_KIND_SETTER,
  CLASS_ELEMENT_OTHER = 0
class BaseParser {
  constructor() {
    this.sawUnambiguousESM = false
    this.ambiguousScriptDifferentAst = false
  }
  hasPlugin(pluginConfig) {
    if (typeof pluginConfig === 'string') {
      return this.plugins.has(pluginConfig)
    } else {
      const [pluginName, pluginOptions] = pluginConfig
      if (!this.hasPlugin(pluginName)) {
        return false
      }
      const actualOptions = this.plugins.get(pluginName)
      for (const key of Object.keys(pluginOptions)) {
        if ((actualOptions == null ? void 0 : actualOptions[key]) !== pluginOptions[key]) {
          return false
        }
      }
      return true
    }
  }
  getPluginOption(plugin, name) {
    var _this$plugins$get
    return (_this$plugins$get = this.plugins.get(plugin)) == null ? void 0 : _this$plugins$get[name]
  }
}
function setTrailingComments(node2, comments2) {
  if (node2.trailingComments === void 0) {
    node2.trailingComments = comments2
  } else {
    node2.trailingComments.unshift(...comments2)
  }
}
function setLeadingComments(node2, comments2) {
  if (node2.leadingComments === void 0) {
    node2.leadingComments = comments2
  } else {
    node2.leadingComments.unshift(...comments2)
  }
}
function setInnerComments(node2, comments2) {
  if (node2.innerComments === void 0) {
    node2.innerComments = comments2
  } else {
    node2.innerComments.unshift(...comments2)
  }
}
function adjustInnerComments(node2, elements, commentWS) {
  let lastElement = null
  let i = elements.length
  while (lastElement === null && i > 0) {
    lastElement = elements[--i]
  }
  if (lastElement === null || lastElement.start > commentWS.start) {
    setInnerComments(node2, commentWS.comments)
  } else {
    setTrailingComments(lastElement, commentWS.comments)
  }
}
class CommentsParser extends BaseParser {
  addComment(comment) {
    if (this.filename) comment.loc.filename = this.filename
    this.state.comments.push(comment)
  }
  processComment(node2) {
    const { commentStack } = this.state
    const commentStackLength = commentStack.length
    if (commentStackLength === 0) return
    let i = commentStackLength - 1
    const lastCommentWS = commentStack[i]
    if (lastCommentWS.start === node2.end) {
      lastCommentWS.leadingNode = node2
      i--
    }
    const { start: nodeStart } = node2
    for (; i >= 0; i--) {
      const commentWS = commentStack[i]
      const commentEnd = commentWS.end
      if (commentEnd > nodeStart) {
        commentWS.containingNode = node2
        this.finalizeComment(commentWS)
        commentStack.splice(i, 1)
      } else {
        if (commentEnd === nodeStart) {
          commentWS.trailingNode = node2
        }
        break
      }
    }
  }
  finalizeComment(commentWS) {
    const { comments: comments2 } = commentWS
    if (commentWS.leadingNode !== null || commentWS.trailingNode !== null) {
      if (commentWS.leadingNode !== null) {
        setTrailingComments(commentWS.leadingNode, comments2)
      }
      if (commentWS.trailingNode !== null) {
        setLeadingComments(commentWS.trailingNode, comments2)
      }
    } else {
      const { containingNode: node2, start: commentStart } = commentWS
      if (this.input.charCodeAt(commentStart - 1) === 44) {
        switch (node2.type) {
          case 'ObjectExpression':
          case 'ObjectPattern':
          case 'RecordExpression':
            adjustInnerComments(node2, node2.properties, commentWS)
            break
          case 'CallExpression':
          case 'OptionalCallExpression':
            adjustInnerComments(node2, node2.arguments, commentWS)
            break
          case 'FunctionDeclaration':
          case 'FunctionExpression':
          case 'ArrowFunctionExpression':
          case 'ObjectMethod':
          case 'ClassMethod':
          case 'ClassPrivateMethod':
            adjustInnerComments(node2, node2.params, commentWS)
            break
          case 'ArrayExpression':
          case 'ArrayPattern':
          case 'TupleExpression':
            adjustInnerComments(node2, node2.elements, commentWS)
            break
          case 'ExportNamedDeclaration':
          case 'ImportDeclaration':
            adjustInnerComments(node2, node2.specifiers, commentWS)
            break
          default: {
            setInnerComments(node2, comments2)
          }
        }
      } else {
        setInnerComments(node2, comments2)
      }
    }
  }
  finalizeRemainingComments() {
    const { commentStack } = this.state
    for (let i = commentStack.length - 1; i >= 0; i--) {
      this.finalizeComment(commentStack[i])
    }
    this.state.commentStack = []
  }
  resetPreviousNodeTrailingComments(node2) {
    const { commentStack } = this.state
    const { length } = commentStack
    if (length === 0) return
    const commentWS = commentStack[length - 1]
    if (commentWS.leadingNode === node2) {
      commentWS.leadingNode = null
    }
  }
  takeSurroundingComments(node2, start, end) {
    const { commentStack } = this.state
    const commentStackLength = commentStack.length
    if (commentStackLength === 0) return
    let i = commentStackLength - 1
    for (; i >= 0; i--) {
      const commentWS = commentStack[i]
      const commentEnd = commentWS.end
      const commentStart = commentWS.start
      if (commentStart === end) {
        commentWS.leadingNode = node2
      } else if (commentEnd === start) {
        commentWS.trailingNode = node2
      } else if (commentEnd < start) {
        break
      }
    }
  }
}
const lineBreak = /\r\n?|[\n\u2028\u2029]/
const lineBreakG = new RegExp(lineBreak.source, 'g')
function isNewLine(code2) {
  switch (code2) {
    case 10:
    case 13:
    case 8232:
    case 8233:
      return true
    default:
      return false
  }
}
const skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g
const skipWhiteSpaceInLine = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/y
const skipWhiteSpaceToLineBreak = new RegExp(
  '(?=(' + skipWhiteSpaceInLine.source + '))\\1' + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source,
  'y'
)
function isWhitespace(code2) {
  switch (code2) {
    case 9:
    case 11:
    case 12:
    case 32:
    case 160:
    case 5760:
    case 8192:
    case 8193:
    case 8194:
    case 8195:
    case 8196:
    case 8197:
    case 8198:
    case 8199:
    case 8200:
    case 8201:
    case 8202:
    case 8239:
    case 8287:
    case 12288:
    case 65279:
      return true
    default:
      return false
  }
}
class State {
  constructor() {
    this.strict = void 0
    this.curLine = void 0
    this.lineStart = void 0
    this.startLoc = void 0
    this.endLoc = void 0
    this.errors = []
    this.potentialArrowAt = -1
    this.noArrowAt = []
    this.noArrowParamsConversionAt = []
    this.maybeInArrowParameters = false
    this.inType = false
    this.noAnonFunctionType = false
    this.hasFlowComment = false
    this.isAmbientContext = false
    this.inAbstractClass = false
    this.inDisallowConditionalTypesContext = false
    this.topicContext = {
      maxNumOfResolvableTopics: 0,
      maxTopicIndex: null,
    }
    this.soloAwait = false
    this.inFSharpPipelineDirectBody = false
    this.labels = []
    this.decoratorStack = [[]]
    this.comments = []
    this.commentStack = []
    this.pos = 0
    this.type = 135
    this.value = null
    this.start = 0
    this.end = 0
    this.lastTokEndLoc = null
    this.lastTokStartLoc = null
    this.lastTokStart = 0
    this.context = [types.brace]
    this.canStartJSXElement = true
    this.containsEsc = false
    this.strictErrors = /* @__PURE__ */ new Map()
    this.tokensLength = 0
  }
  init({ strictMode, sourceType, startLine, startColumn }) {
    this.strict = strictMode === false ? false : strictMode === true ? true : sourceType === 'module'
    this.curLine = startLine
    this.lineStart = -startColumn
    this.startLoc = this.endLoc = new Position(startLine, startColumn, 0)
  }
  curPosition() {
    return new Position(this.curLine, this.pos - this.lineStart, this.pos)
  }
  clone(skipArrays) {
    const state = new State()
    const keys = Object.keys(this)
    for (let i = 0, length = keys.length; i < length; i++) {
      const key = keys[i]
      let val = this[key]
      if (!skipArrays && Array.isArray(val)) {
        val = val.slice()
      }
      state[key] = val
    }
    return state
  }
}
const _excluded$2 = ['at'],
  _excluded2 = ['at']
var _isDigit = function isDigit2(code2) {
  return code2 >= 48 && code2 <= 57
}
const VALID_REGEX_FLAGS = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118])
const forbiddenNumericSeparatorSiblings = {
  decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
  hex: /* @__PURE__ */ new Set([46, 88, 95, 120]),
}
const isAllowedNumericSeparatorSibling = {
  bin: (ch) => ch === 48 || ch === 49,
  oct: (ch) => ch >= 48 && ch <= 55,
  dec: (ch) => ch >= 48 && ch <= 57,
  hex: (ch) => (ch >= 48 && ch <= 57) || (ch >= 65 && ch <= 70) || (ch >= 97 && ch <= 102),
}
class Token {
  constructor(state) {
    this.type = state.type
    this.value = state.value
    this.start = state.start
    this.end = state.end
    this.loc = new SourceLocation(state.startLoc, state.endLoc)
  }
}
class Tokenizer extends CommentsParser {
  constructor(options2, input) {
    super()
    this.isLookahead = void 0
    this.tokens = []
    this.state = new State()
    this.state.init(options2)
    this.input = input
    this.length = input.length
    this.isLookahead = false
  }
  pushToken(token) {
    this.tokens.length = this.state.tokensLength
    this.tokens.push(token)
    ++this.state.tokensLength
  }
  next() {
    this.checkKeywordEscapes()
    if (this.options.tokens) {
      this.pushToken(new Token(this.state))
    }
    this.state.lastTokStart = this.state.start
    this.state.lastTokEndLoc = this.state.endLoc
    this.state.lastTokStartLoc = this.state.startLoc
    this.nextToken()
  }
  eat(type) {
    if (this.match(type)) {
      this.next()
      return true
    } else {
      return false
    }
  }
  match(type) {
    return this.state.type === type
  }
  createLookaheadState(state) {
    return {
      pos: state.pos,
      value: null,
      type: state.type,
      start: state.start,
      end: state.end,
      context: [this.curContext()],
      inType: state.inType,
      startLoc: state.startLoc,
      lastTokEndLoc: state.lastTokEndLoc,
      curLine: state.curLine,
      lineStart: state.lineStart,
      curPosition: state.curPosition,
    }
  }
  lookahead() {
    const old = this.state
    this.state = this.createLookaheadState(old)
    this.isLookahead = true
    this.nextToken()
    this.isLookahead = false
    const curr = this.state
    this.state = old
    return curr
  }
  nextTokenStart() {
    return this.nextTokenStartSince(this.state.pos)
  }
  nextTokenStartSince(pos) {
    skipWhiteSpace.lastIndex = pos
    return skipWhiteSpace.test(this.input) ? skipWhiteSpace.lastIndex : pos
  }
  lookaheadCharCode() {
    return this.input.charCodeAt(this.nextTokenStart())
  }
  codePointAtPos(pos) {
    let cp = this.input.charCodeAt(pos)
    if ((cp & 64512) === 55296 && ++pos < this.input.length) {
      const trail = this.input.charCodeAt(pos)
      if ((trail & 64512) === 56320) {
        cp = 65536 + ((cp & 1023) << 10) + (trail & 1023)
      }
    }
    return cp
  }
  setStrict(strict) {
    this.state.strict = strict
    if (strict) {
      this.state.strictErrors.forEach(([toParseError, at]) =>
        this.raise(toParseError, {
          at,
        })
      )
      this.state.strictErrors.clear()
    }
  }
  curContext() {
    return this.state.context[this.state.context.length - 1]
  }
  nextToken() {
    this.skipSpace()
    this.state.start = this.state.pos
    if (!this.isLookahead) this.state.startLoc = this.state.curPosition()
    if (this.state.pos >= this.length) {
      this.finishToken(135)
      return
    }
    this.getTokenFromCode(this.codePointAtPos(this.state.pos))
  }
  skipBlockComment() {
    let startLoc
    if (!this.isLookahead) startLoc = this.state.curPosition()
    const start = this.state.pos
    const end = this.input.indexOf('*/', start + 2)
    if (end === -1) {
      throw this.raise(Errors.UnterminatedComment, {
        at: this.state.curPosition(),
      })
    }
    this.state.pos = end + 2
    lineBreakG.lastIndex = start + 2
    while (lineBreakG.test(this.input) && lineBreakG.lastIndex <= end) {
      ++this.state.curLine
      this.state.lineStart = lineBreakG.lastIndex
    }
    if (this.isLookahead) return
    const comment = {
      type: 'CommentBlock',
      value: this.input.slice(start + 2, end),
      start,
      end: end + 2,
      loc: new SourceLocation(startLoc, this.state.curPosition()),
    }
    if (this.options.tokens) this.pushToken(comment)
    return comment
  }
  skipLineComment(startSkip) {
    const start = this.state.pos
    let startLoc
    if (!this.isLookahead) startLoc = this.state.curPosition()
    let ch = this.input.charCodeAt((this.state.pos += startSkip))
    if (this.state.pos < this.length) {
      while (!isNewLine(ch) && ++this.state.pos < this.length) {
        ch = this.input.charCodeAt(this.state.pos)
      }
    }
    if (this.isLookahead) return
    const end = this.state.pos
    const value = this.input.slice(start + startSkip, end)
    const comment = {
      type: 'CommentLine',
      value,
      start,
      end,
      loc: new SourceLocation(startLoc, this.state.curPosition()),
    }
    if (this.options.tokens) this.pushToken(comment)
    return comment
  }
  skipSpace() {
    const spaceStart = this.state.pos
    const comments2 = []
    loop: while (this.state.pos < this.length) {
      const ch = this.input.charCodeAt(this.state.pos)
      switch (ch) {
        case 32:
        case 160:
        case 9:
          ++this.state.pos
          break
        case 13:
          if (this.input.charCodeAt(this.state.pos + 1) === 10) {
            ++this.state.pos
          }
        case 10:
        case 8232:
        case 8233:
          ++this.state.pos
          ++this.state.curLine
          this.state.lineStart = this.state.pos
          break
        case 47:
          switch (this.input.charCodeAt(this.state.pos + 1)) {
            case 42: {
              const comment = this.skipBlockComment()
              if (comment !== void 0) {
                this.addComment(comment)
                if (this.options.attachComment) comments2.push(comment)
              }
              break
            }
            case 47: {
              const comment = this.skipLineComment(2)
              if (comment !== void 0) {
                this.addComment(comment)
                if (this.options.attachComment) comments2.push(comment)
              }
              break
            }
            default:
              break loop
          }
          break
        default:
          if (isWhitespace(ch)) {
            ++this.state.pos
          } else if (ch === 45 && !this.inModule) {
            const pos = this.state.pos
            if (
              this.input.charCodeAt(pos + 1) === 45 &&
              this.input.charCodeAt(pos + 2) === 62 &&
              (spaceStart === 0 || this.state.lineStart > spaceStart)
            ) {
              const comment = this.skipLineComment(3)
              if (comment !== void 0) {
                this.addComment(comment)
                if (this.options.attachComment) comments2.push(comment)
              }
            } else {
              break loop
            }
          } else if (ch === 60 && !this.inModule) {
            const pos = this.state.pos
            if (
              this.input.charCodeAt(pos + 1) === 33 &&
              this.input.charCodeAt(pos + 2) === 45 &&
              this.input.charCodeAt(pos + 3) === 45
            ) {
              const comment = this.skipLineComment(4)
              if (comment !== void 0) {
                this.addComment(comment)
                if (this.options.attachComment) comments2.push(comment)
              }
            } else {
              break loop
            }
          } else {
            break loop
          }
      }
    }
    if (comments2.length > 0) {
      const end = this.state.pos
      const CommentWhitespace = {
        start: spaceStart,
        end,
        comments: comments2,
        leadingNode: null,
        trailingNode: null,
        containingNode: null,
      }
      this.state.commentStack.push(CommentWhitespace)
    }
  }
  finishToken(type, val) {
    this.state.end = this.state.pos
    this.state.endLoc = this.state.curPosition()
    const prevType = this.state.type
    this.state.type = type
    this.state.value = val
    if (!this.isLookahead) {
      this.updateContext(prevType)
    }
  }
  replaceToken(type) {
    this.state.type = type
    this.updateContext()
  }
  readToken_numberSign() {
    if (this.state.pos === 0 && this.readToken_interpreter()) {
      return
    }
    const nextPos = this.state.pos + 1
    const next = this.codePointAtPos(nextPos)
    if (next >= 48 && next <= 57) {
      throw this.raise(Errors.UnexpectedDigitAfterHash, {
        at: this.state.curPosition(),
      })
    }
    if (next === 123 || (next === 91 && this.hasPlugin('recordAndTuple'))) {
      this.expectPlugin('recordAndTuple')
      if (this.getPluginOption('recordAndTuple', 'syntaxType') !== 'hash') {
        throw this.raise(
          next === 123
            ? Errors.RecordExpressionHashIncorrectStartSyntaxType
            : Errors.TupleExpressionHashIncorrectStartSyntaxType,
          {
            at: this.state.curPosition(),
          }
        )
      }
      this.state.pos += 2
      if (next === 123) {
        this.finishToken(7)
      } else {
        this.finishToken(1)
      }
    } else if (isIdentifierStart(next)) {
      ++this.state.pos
      this.finishToken(134, this.readWord1(next))
    } else if (next === 92) {
      ++this.state.pos
      this.finishToken(134, this.readWord1())
    } else {
      this.finishOp(27, 1)
    }
  }
  readToken_dot() {
    const next = this.input.charCodeAt(this.state.pos + 1)
    if (next >= 48 && next <= 57) {
      this.readNumber(true)
      return
    }
    if (next === 46 && this.input.charCodeAt(this.state.pos + 2) === 46) {
      this.state.pos += 3
      this.finishToken(21)
    } else {
      ++this.state.pos
      this.finishToken(16)
    }
  }
  readToken_slash() {
    const next = this.input.charCodeAt(this.state.pos + 1)
    if (next === 61) {
      this.finishOp(31, 2)
    } else {
      this.finishOp(56, 1)
    }
  }
  readToken_interpreter() {
    if (this.state.pos !== 0 || this.length < 2) return false
    let ch = this.input.charCodeAt(this.state.pos + 1)
    if (ch !== 33) return false
    const start = this.state.pos
    this.state.pos += 1
    while (!isNewLine(ch) && ++this.state.pos < this.length) {
      ch = this.input.charCodeAt(this.state.pos)
    }
    const value = this.input.slice(start + 2, this.state.pos)
    this.finishToken(28, value)
    return true
  }
  readToken_mult_modulo(code2) {
    let type = code2 === 42 ? 55 : 54
    let width = 1
    let next = this.input.charCodeAt(this.state.pos + 1)
    if (code2 === 42 && next === 42) {
      width++
      next = this.input.charCodeAt(this.state.pos + 2)
      type = 57
    }
    if (next === 61 && !this.state.inType) {
      width++
      type = code2 === 37 ? 33 : 30
    }
    this.finishOp(type, width)
  }
  readToken_pipe_amp(code2) {
    const next = this.input.charCodeAt(this.state.pos + 1)
    if (next === code2) {
      if (this.input.charCodeAt(this.state.pos + 2) === 61) {
        this.finishOp(30, 3)
      } else {
        this.finishOp(code2 === 124 ? 41 : 42, 2)
      }
      return
    }
    if (code2 === 124) {
      if (next === 62) {
        this.finishOp(39, 2)
        return
      }
      if (this.hasPlugin('recordAndTuple') && next === 125) {
        if (this.getPluginOption('recordAndTuple', 'syntaxType') !== 'bar') {
          throw this.raise(Errors.RecordExpressionBarIncorrectEndSyntaxType, {
            at: this.state.curPosition(),
          })
        }
        this.state.pos += 2
        this.finishToken(9)
        return
      }
      if (this.hasPlugin('recordAndTuple') && next === 93) {
        if (this.getPluginOption('recordAndTuple', 'syntaxType') !== 'bar') {
          throw this.raise(Errors.TupleExpressionBarIncorrectEndSyntaxType, {
            at: this.state.curPosition(),
          })
        }
        this.state.pos += 2
        this.finishToken(4)
        return
      }
    }
    if (next === 61) {
      this.finishOp(30, 2)
      return
    }
    this.finishOp(code2 === 124 ? 43 : 45, 1)
  }
  readToken_caret() {
    const next = this.input.charCodeAt(this.state.pos + 1)
    if (next === 61 && !this.state.inType) {
      this.finishOp(32, 2)
    } else if (
      next === 94 &&
      this.hasPlugin([
        'pipelineOperator',
        {
          proposal: 'hack',
          topicToken: '^^',
        },
      ])
    ) {
      this.finishOp(37, 2)
      const lookaheadCh = this.input.codePointAt(this.state.pos)
      if (lookaheadCh === 94) {
        throw this.unexpected()
      }
    } else {
      this.finishOp(44, 1)
    }
  }
  readToken_atSign() {
    const next = this.input.charCodeAt(this.state.pos + 1)
    if (
      next === 64 &&
      this.hasPlugin([
        'pipelineOperator',
        {
          proposal: 'hack',
          topicToken: '@@',
        },
      ])
    ) {
      this.finishOp(38, 2)
    } else {
      this.finishOp(26, 1)
    }
  }
  readToken_plus_min(code2) {
    const next = this.input.charCodeAt(this.state.pos + 1)
    if (next === code2) {
      this.finishOp(34, 2)
      return
    }
    if (next === 61) {
      this.finishOp(30, 2)
    } else {
      this.finishOp(53, 1)
    }
  }
  readToken_lt() {
    const { pos } = this.state
    const next = this.input.charCodeAt(pos + 1)
    if (next === 60) {
      if (this.input.charCodeAt(pos + 2) === 61) {
        this.finishOp(30, 3)
        return
      }
      this.finishOp(51, 2)
      return
    }
    if (next === 61) {
      this.finishOp(49, 2)
      return
    }
    this.finishOp(47, 1)
  }
  readToken_gt() {
    const { pos } = this.state
    const next = this.input.charCodeAt(pos + 1)
    if (next === 62) {
      const size = this.input.charCodeAt(pos + 2) === 62 ? 3 : 2
      if (this.input.charCodeAt(pos + size) === 61) {
        this.finishOp(30, size + 1)
        return
      }
      this.finishOp(52, size)
      return
    }
    if (next === 61) {
      this.finishOp(49, 2)
      return
    }
    this.finishOp(48, 1)
  }
  readToken_eq_excl(code2) {
    const next = this.input.charCodeAt(this.state.pos + 1)
    if (next === 61) {
      this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2)
      return
    }
    if (code2 === 61 && next === 62) {
      this.state.pos += 2
      this.finishToken(19)
      return
    }
    this.finishOp(code2 === 61 ? 29 : 35, 1)
  }
  readToken_question() {
    const next = this.input.charCodeAt(this.state.pos + 1)
    const next2 = this.input.charCodeAt(this.state.pos + 2)
    if (next === 63) {
      if (next2 === 61) {
        this.finishOp(30, 3)
      } else {
        this.finishOp(40, 2)
      }
    } else if (next === 46 && !(next2 >= 48 && next2 <= 57)) {
      this.state.pos += 2
      this.finishToken(18)
    } else {
      ++this.state.pos
      this.finishToken(17)
    }
  }
  getTokenFromCode(code2) {
    switch (code2) {
      case 46:
        this.readToken_dot()
        return
      case 40:
        ++this.state.pos
        this.finishToken(10)
        return
      case 41:
        ++this.state.pos
        this.finishToken(11)
        return
      case 59:
        ++this.state.pos
        this.finishToken(13)
        return
      case 44:
        ++this.state.pos
        this.finishToken(12)
        return
      case 91:
        if (this.hasPlugin('recordAndTuple') && this.input.charCodeAt(this.state.pos + 1) === 124) {
          if (this.getPluginOption('recordAndTuple', 'syntaxType') !== 'bar') {
            throw this.raise(Errors.TupleExpressionBarIncorrectStartSyntaxType, {
              at: this.state.curPosition(),
            })
          }
          this.state.pos += 2
          this.finishToken(2)
        } else {
          ++this.state.pos
          this.finishToken(0)
        }
        return
      case 93:
        ++this.state.pos
        this.finishToken(3)
        return
      case 123:
        if (this.hasPlugin('recordAndTuple') && this.input.charCodeAt(this.state.pos + 1) === 124) {
          if (this.getPluginOption('recordAndTuple', 'syntaxType') !== 'bar') {
            throw this.raise(Errors.RecordExpressionBarIncorrectStartSyntaxType, {
              at: this.state.curPosition(),
            })
          }
          this.state.pos += 2
          this.finishToken(6)
        } else {
          ++this.state.pos
          this.finishToken(5)
        }
        return
      case 125:
        ++this.state.pos
        this.finishToken(8)
        return
      case 58:
        if (this.hasPlugin('functionBind') && this.input.charCodeAt(this.state.pos + 1) === 58) {
          this.finishOp(15, 2)
        } else {
          ++this.state.pos
          this.finishToken(14)
        }
        return
      case 63:
        this.readToken_question()
        return
      case 96:
        this.readTemplateToken()
        return
      case 48: {
        const next = this.input.charCodeAt(this.state.pos + 1)
        if (next === 120 || next === 88) {
          this.readRadixNumber(16)
          return
        }
        if (next === 111 || next === 79) {
          this.readRadixNumber(8)
          return
        }
        if (next === 98 || next === 66) {
          this.readRadixNumber(2)
          return
        }
      }
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
        this.readNumber(false)
        return
      case 34:
      case 39:
        this.readString(code2)
        return
      case 47:
        this.readToken_slash()
        return
      case 37:
      case 42:
        this.readToken_mult_modulo(code2)
        return
      case 124:
      case 38:
        this.readToken_pipe_amp(code2)
        return
      case 94:
        this.readToken_caret()
        return
      case 43:
      case 45:
        this.readToken_plus_min(code2)
        return
      case 60:
        this.readToken_lt()
        return
      case 62:
        this.readToken_gt()
        return
      case 61:
      case 33:
        this.readToken_eq_excl(code2)
        return
      case 126:
        this.finishOp(36, 1)
        return
      case 64:
        this.readToken_atSign()
        return
      case 35:
        this.readToken_numberSign()
        return
      case 92:
        this.readWord()
        return
      default:
        if (isIdentifierStart(code2)) {
          this.readWord(code2)
          return
        }
    }
    throw this.raise(Errors.InvalidOrUnexpectedToken, {
      at: this.state.curPosition(),
      unexpected: String.fromCodePoint(code2),
    })
  }
  finishOp(type, size) {
    const str = this.input.slice(this.state.pos, this.state.pos + size)
    this.state.pos += size
    this.finishToken(type, str)
  }
  readRegexp() {
    const startLoc = this.state.startLoc
    const start = this.state.start + 1
    let escaped, inClass
    let { pos } = this.state
    for (; ; ++pos) {
      if (pos >= this.length) {
        throw this.raise(Errors.UnterminatedRegExp, {
          at: createPositionWithColumnOffset(startLoc, 1),
        })
      }
      const ch = this.input.charCodeAt(pos)
      if (isNewLine(ch)) {
        throw this.raise(Errors.UnterminatedRegExp, {
          at: createPositionWithColumnOffset(startLoc, 1),
        })
      }
      if (escaped) {
        escaped = false
      } else {
        if (ch === 91) {
          inClass = true
        } else if (ch === 93 && inClass) {
          inClass = false
        } else if (ch === 47 && !inClass) {
          break
        }
        escaped = ch === 92
      }
    }
    const content = this.input.slice(start, pos)
    ++pos
    let mods = ''
    const nextPos = () => createPositionWithColumnOffset(startLoc, pos + 2 - start)
    while (pos < this.length) {
      const cp = this.codePointAtPos(pos)
      const char = String.fromCharCode(cp)
      if (VALID_REGEX_FLAGS.has(cp)) {
        if (cp === 118) {
          this.expectPlugin('regexpUnicodeSets', nextPos())
          if (mods.includes('u')) {
            this.raise(Errors.IncompatibleRegExpUVFlags, {
              at: nextPos(),
            })
          }
        } else if (cp === 117) {
          if (mods.includes('v')) {
            this.raise(Errors.IncompatibleRegExpUVFlags, {
              at: nextPos(),
            })
          }
        }
        if (mods.includes(char)) {
          this.raise(Errors.DuplicateRegExpFlags, {
            at: nextPos(),
          })
        }
      } else if (isIdentifierChar(cp) || cp === 92) {
        this.raise(Errors.MalformedRegExpFlags, {
          at: nextPos(),
        })
      } else {
        break
      }
      ++pos
      mods += char
    }
    this.state.pos = pos
    this.finishToken(133, {
      pattern: content,
      flags: mods,
    })
  }
  readInt(radix, len, forceLen, allowNumSeparator = true) {
    const start = this.state.pos
    const forbiddenSiblings =
      radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct
    const isAllowedSibling =
      radix === 16
        ? isAllowedNumericSeparatorSibling.hex
        : radix === 10
        ? isAllowedNumericSeparatorSibling.dec
        : radix === 8
        ? isAllowedNumericSeparatorSibling.oct
        : isAllowedNumericSeparatorSibling.bin
    let invalid = false
    let total = 0
    for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) {
      const code2 = this.input.charCodeAt(this.state.pos)
      let val
      if (code2 === 95 && allowNumSeparator !== 'bail') {
        const prev = this.input.charCodeAt(this.state.pos - 1)
        const next = this.input.charCodeAt(this.state.pos + 1)
        if (!allowNumSeparator) {
          this.raise(Errors.NumericSeparatorInEscapeSequence, {
            at: this.state.curPosition(),
          })
        } else if (
          Number.isNaN(next) ||
          !isAllowedSibling(next) ||
          forbiddenSiblings.has(prev) ||
          forbiddenSiblings.has(next)
        ) {
          this.raise(Errors.UnexpectedNumericSeparator, {
            at: this.state.curPosition(),
          })
        }
        ++this.state.pos
        continue
      }
      if (code2 >= 97) {
        val = code2 - 97 + 10
      } else if (code2 >= 65) {
        val = code2 - 65 + 10
      } else if (_isDigit(code2)) {
        val = code2 - 48
      } else {
        val = Infinity
      }
      if (val >= radix) {
        if (this.options.errorRecovery && val <= 9) {
          val = 0
          this.raise(Errors.InvalidDigit, {
            at: this.state.curPosition(),
            radix,
          })
        } else if (forceLen) {
          val = 0
          invalid = true
        } else {
          break
        }
      }
      ++this.state.pos
      total = total * radix + val
    }
    if (this.state.pos === start || (len != null && this.state.pos - start !== len) || invalid) {
      return null
    }
    return total
  }
  readRadixNumber(radix) {
    const startLoc = this.state.curPosition()
    let isBigInt = false
    this.state.pos += 2
    const val = this.readInt(radix)
    if (val == null) {
      this.raise(Errors.InvalidDigit, {
        at: createPositionWithColumnOffset(startLoc, 2),
        radix,
      })
    }
    const next = this.input.charCodeAt(this.state.pos)
    if (next === 110) {
      ++this.state.pos
      isBigInt = true
    } else if (next === 109) {
      throw this.raise(Errors.InvalidDecimal, {
        at: startLoc,
      })
    }
    if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {
      throw this.raise(Errors.NumberIdentifier, {
        at: this.state.curPosition(),
      })
    }
    if (isBigInt) {
      const str = this.input.slice(startLoc.index, this.state.pos).replace(/[_n]/g, '')
      this.finishToken(131, str)
      return
    }
    this.finishToken(130, val)
  }
  readNumber(startsWithDot) {
    const start = this.state.pos
    const startLoc = this.state.curPosition()
    let isFloat = false
    let isBigInt = false
    let isDecimal2 = false
    let hasExponent = false
    let isOctal2 = false
    if (!startsWithDot && this.readInt(10) === null) {
      this.raise(Errors.InvalidNumber, {
        at: this.state.curPosition(),
      })
    }
    const hasLeadingZero = this.state.pos - start >= 2 && this.input.charCodeAt(start) === 48
    if (hasLeadingZero) {
      const integer = this.input.slice(start, this.state.pos)
      this.recordStrictModeErrors(Errors.StrictOctalLiteral, {
        at: startLoc,
      })
      if (!this.state.strict) {
        const underscorePos = integer.indexOf('_')
        if (underscorePos > 0) {
          this.raise(Errors.ZeroDigitNumericSeparator, {
            at: createPositionWithColumnOffset(startLoc, underscorePos),
          })
        }
      }
      isOctal2 = hasLeadingZero && !/[89]/.test(integer)
    }
    let next = this.input.charCodeAt(this.state.pos)
    if (next === 46 && !isOctal2) {
      ++this.state.pos
      this.readInt(10)
      isFloat = true
      next = this.input.charCodeAt(this.state.pos)
    }
    if ((next === 69 || next === 101) && !isOctal2) {
      next = this.input.charCodeAt(++this.state.pos)
      if (next === 43 || next === 45) {
        ++this.state.pos
      }
      if (this.readInt(10) === null) {
        this.raise(Errors.InvalidOrMissingExponent, {
          at: startLoc,
        })
      }
      isFloat = true
      hasExponent = true
      next = this.input.charCodeAt(this.state.pos)
    }
    if (next === 110) {
      if (isFloat || hasLeadingZero) {
        this.raise(Errors.InvalidBigIntLiteral, {
          at: startLoc,
        })
      }
      ++this.state.pos
      isBigInt = true
    }
    if (next === 109) {
      this.expectPlugin('decimal', this.state.curPosition())
      if (hasExponent || hasLeadingZero) {
        this.raise(Errors.InvalidDecimal, {
          at: startLoc,
        })
      }
      ++this.state.pos
      isDecimal2 = true
    }
    if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {
      throw this.raise(Errors.NumberIdentifier, {
        at: this.state.curPosition(),
      })
    }
    const str = this.input.slice(start, this.state.pos).replace(/[_mn]/g, '')
    if (isBigInt) {
      this.finishToken(131, str)
      return
    }
    if (isDecimal2) {
      this.finishToken(132, str)
      return
    }
    const val = isOctal2 ? parseInt(str, 8) : parseFloat(str)
    this.finishToken(130, val)
  }
  readCodePoint(throwOnInvalid) {
    const ch = this.input.charCodeAt(this.state.pos)
    let code2
    if (ch === 123) {
      ++this.state.pos
      code2 = this.readHexChar(this.input.indexOf('}', this.state.pos) - this.state.pos, true, throwOnInvalid)
      ++this.state.pos
      if (code2 !== null && code2 > 1114111) {
        if (throwOnInvalid) {
          this.raise(Errors.InvalidCodePoint, {
            at: this.state.curPosition(),
          })
        } else {
          return null
        }
      }
    } else {
      code2 = this.readHexChar(4, false, throwOnInvalid)
    }
    return code2
  }
  readString(quote) {
    let out = '',
      chunkStart = ++this.state.pos
    for (;;) {
      if (this.state.pos >= this.length) {
        throw this.raise(Errors.UnterminatedString, {
          at: this.state.startLoc,
        })
      }
      const ch = this.input.charCodeAt(this.state.pos)
      if (ch === quote) break
      if (ch === 92) {
        out += this.input.slice(chunkStart, this.state.pos)
        out += this.readEscapedChar(false)
        chunkStart = this.state.pos
      } else if (ch === 8232 || ch === 8233) {
        ++this.state.pos
        ++this.state.curLine
        this.state.lineStart = this.state.pos
      } else if (isNewLine(ch)) {
        throw this.raise(Errors.UnterminatedString, {
          at: this.state.startLoc,
        })
      } else {
        ++this.state.pos
      }
    }
    out += this.input.slice(chunkStart, this.state.pos++)
    this.finishToken(129, out)
  }
  readTemplateContinuation() {
    if (!this.match(8)) {
      this.unexpected(null, 8)
    }
    this.state.pos--
    this.readTemplateToken()
  }
  readTemplateToken() {
    let out = '',
      chunkStart = this.state.pos,
      containsInvalid = false
    ++this.state.pos
    for (;;) {
      if (this.state.pos >= this.length) {
        throw this.raise(Errors.UnterminatedTemplate, {
          at: createPositionWithColumnOffset(this.state.startLoc, 1),
        })
      }
      const ch = this.input.charCodeAt(this.state.pos)
      if (ch === 96) {
        ++this.state.pos
        out += this.input.slice(chunkStart, this.state.pos)
        this.finishToken(24, containsInvalid ? null : out)
        return
      }
      if (ch === 36 && this.input.charCodeAt(this.state.pos + 1) === 123) {
        this.state.pos += 2
        out += this.input.slice(chunkStart, this.state.pos)
        this.finishToken(25, containsInvalid ? null : out)
        return
      }
      if (ch === 92) {
        out += this.input.slice(chunkStart, this.state.pos)
        const escaped = this.readEscapedChar(true)
        if (escaped === null) {
          containsInvalid = true
        } else {
          out += escaped
        }
        chunkStart = this.state.pos
      } else if (isNewLine(ch)) {
        out += this.input.slice(chunkStart, this.state.pos)
        ++this.state.pos
        switch (ch) {
          case 13:
            if (this.input.charCodeAt(this.state.pos) === 10) {
              ++this.state.pos
            }
          case 10:
            out += '\n'
            break
          default:
            out += String.fromCharCode(ch)
            break
        }
        ++this.state.curLine
        this.state.lineStart = this.state.pos
        chunkStart = this.state.pos
      } else {
        ++this.state.pos
      }
    }
  }
  recordStrictModeErrors(toParseError, { at }) {
    const index2 = at.index
    if (this.state.strict && !this.state.strictErrors.has(index2)) {
      this.raise(toParseError, {
        at,
      })
    } else {
      this.state.strictErrors.set(index2, [toParseError, at])
    }
  }
  readEscapedChar(inTemplate) {
    const throwOnInvalid = !inTemplate
    const ch = this.input.charCodeAt(++this.state.pos)
    ++this.state.pos
    switch (ch) {
      case 110:
        return '\n'
      case 114:
        return '\r'
      case 120: {
        const code2 = this.readHexChar(2, false, throwOnInvalid)
        return code2 === null ? null : String.fromCharCode(code2)
      }
      case 117: {
        const code2 = this.readCodePoint(throwOnInvalid)
        return code2 === null ? null : String.fromCodePoint(code2)
      }
      case 116:
        return '	'
      case 98:
        return '\b'
      case 118:
        return '\v'
      case 102:
        return '\f'
      case 13:
        if (this.input.charCodeAt(this.state.pos) === 10) {
          ++this.state.pos
        }
      case 10:
        this.state.lineStart = this.state.pos
        ++this.state.curLine
      case 8232:
      case 8233:
        return ''
      case 56:
      case 57:
        if (inTemplate) {
          return null
        } else {
          this.recordStrictModeErrors(Errors.StrictNumericEscape, {
            at: createPositionWithColumnOffset(this.state.curPosition(), -1),
          })
        }
      default:
        if (ch >= 48 && ch <= 55) {
          const codePos = createPositionWithColumnOffset(this.state.curPosition(), -1)
          const match = this.input.slice(this.state.pos - 1, this.state.pos + 2).match(/^[0-7]+/)
          let octalStr = match[0]
          let octal = parseInt(octalStr, 8)
          if (octal > 255) {
            octalStr = octalStr.slice(0, -1)
            octal = parseInt(octalStr, 8)
          }
          this.state.pos += octalStr.length - 1
          const next = this.input.charCodeAt(this.state.pos)
          if (octalStr !== '0' || next === 56 || next === 57) {
            if (inTemplate) {
              return null
            } else {
              this.recordStrictModeErrors(Errors.StrictNumericEscape, {
                at: codePos,
              })
            }
          }
          return String.fromCharCode(octal)
        }
        return String.fromCharCode(ch)
    }
  }
  readHexChar(len, forceLen, throwOnInvalid) {
    const codeLoc = this.state.curPosition()
    const n2 = this.readInt(16, len, forceLen, false)
    if (n2 === null) {
      if (throwOnInvalid) {
        this.raise(Errors.InvalidEscapeSequence, {
          at: codeLoc,
        })
      } else {
        this.state.pos = codeLoc.index - 1
      }
    }
    return n2
  }
  readWord1(firstCode) {
    this.state.containsEsc = false
    let word = ''
    const start = this.state.pos
    let chunkStart = this.state.pos
    if (firstCode !== void 0) {
      this.state.pos += firstCode <= 65535 ? 1 : 2
    }
    while (this.state.pos < this.length) {
      const ch = this.codePointAtPos(this.state.pos)
      if (isIdentifierChar(ch)) {
        this.state.pos += ch <= 65535 ? 1 : 2
      } else if (ch === 92) {
        this.state.containsEsc = true
        word += this.input.slice(chunkStart, this.state.pos)
        const escStart = this.state.curPosition()
        const identifierCheck = this.state.pos === start ? isIdentifierStart : isIdentifierChar
        if (this.input.charCodeAt(++this.state.pos) !== 117) {
          this.raise(Errors.MissingUnicodeEscape, {
            at: this.state.curPosition(),
          })
          chunkStart = this.state.pos - 1
          continue
        }
        ++this.state.pos
        const esc = this.readCodePoint(true)
        if (esc !== null) {
          if (!identifierCheck(esc)) {
            this.raise(Errors.EscapedCharNotAnIdentifier, {
              at: escStart,
            })
          }
          word += String.fromCodePoint(esc)
        }
        chunkStart = this.state.pos
      } else {
        break
      }
    }
    return word + this.input.slice(chunkStart, this.state.pos)
  }
  readWord(firstCode) {
    const word = this.readWord1(firstCode)
    const type = keywords$1.get(word)
    if (type !== void 0) {
      this.finishToken(type, tokenLabelName(type))
    } else {
      this.finishToken(128, word)
    }
  }
  checkKeywordEscapes() {
    const { type } = this.state
    if (tokenIsKeyword(type) && this.state.containsEsc) {
      this.raise(Errors.InvalidEscapedReservedWord, {
        at: this.state.startLoc,
        reservedWord: tokenLabelName(type),
      })
    }
  }
  raise(toParseError, raiseProperties) {
    const { at } = raiseProperties,
      details = _objectWithoutPropertiesLoose$1(raiseProperties, _excluded$2)
    const loc = at instanceof Position ? at : at.loc.start
    const error = toParseError({
      loc,
      details,
    })
    if (!this.options.errorRecovery) throw error
    if (!this.isLookahead) this.state.errors.push(error)
    return error
  }
  raiseOverwrite(toParseError, raiseProperties) {
    const { at } = raiseProperties,
      details = _objectWithoutPropertiesLoose$1(raiseProperties, _excluded2)
    const loc = at instanceof Position ? at : at.loc.start
    const pos = loc.index
    const errors = this.state.errors
    for (let i = errors.length - 1; i >= 0; i--) {
      const error = errors[i]
      if (error.loc.index === pos) {
        return (errors[i] = toParseError({
          loc,
          details,
        }))
      }
      if (error.loc.index < pos) break
    }
    return this.raise(toParseError, raiseProperties)
  }
  updateContext(prevType) {}
  unexpected(loc, type) {
    throw this.raise(Errors.UnexpectedToken, {
      expected: type ? tokenLabelName(type) : null,
      at: loc != null ? loc : this.state.startLoc,
    })
  }
  expectPlugin(pluginName, loc) {
    if (this.hasPlugin(pluginName)) {
      return true
    }
    throw this.raise(Errors.MissingPlugin, {
      at: loc != null ? loc : this.state.startLoc,
      missingPlugin: [pluginName],
    })
  }
  expectOnePlugin(pluginNames) {
    if (!pluginNames.some((name) => this.hasPlugin(name))) {
      throw this.raise(Errors.MissingOneOfPlugins, {
        at: this.state.startLoc,
        missingPlugin: pluginNames,
      })
    }
  }
}
class Scope {
  constructor(flags) {
    this.var = /* @__PURE__ */ new Set()
    this.lexical = /* @__PURE__ */ new Set()
    this.functions = /* @__PURE__ */ new Set()
    this.flags = flags
  }
}
class ScopeHandler {
  constructor(parser, inModule) {
    this.parser = void 0
    this.scopeStack = []
    this.inModule = void 0
    this.undefinedExports = /* @__PURE__ */ new Map()
    this.parser = parser
    this.inModule = inModule
  }
  get inFunction() {
    return (this.currentVarScopeFlags() & SCOPE_FUNCTION) > 0
  }
  get allowSuper() {
    return (this.currentThisScopeFlags() & SCOPE_SUPER) > 0
  }
  get allowDirectSuper() {
    return (this.currentThisScopeFlags() & SCOPE_DIRECT_SUPER) > 0
  }
  get inClass() {
    return (this.currentThisScopeFlags() & SCOPE_CLASS) > 0
  }
  get inClassAndNotInNonArrowFunction() {
    const flags = this.currentThisScopeFlags()
    return (flags & SCOPE_CLASS) > 0 && (flags & SCOPE_FUNCTION) === 0
  }
  get inStaticBlock() {
    for (let i = this.scopeStack.length - 1; ; i--) {
      const { flags } = this.scopeStack[i]
      if (flags & SCOPE_STATIC_BLOCK) {
        return true
      }
      if (flags & (SCOPE_VAR | SCOPE_CLASS)) {
        return false
      }
    }
  }
  get inNonArrowFunction() {
    return (this.currentThisScopeFlags() & SCOPE_FUNCTION) > 0
  }
  get treatFunctionsAsVar() {
    return this.treatFunctionsAsVarInScope(this.currentScope())
  }
  createScope(flags) {
    return new Scope(flags)
  }
  enter(flags) {
    this.scopeStack.push(this.createScope(flags))
  }
  exit() {
    this.scopeStack.pop()
  }
  treatFunctionsAsVarInScope(scope2) {
    return !!(
      scope2.flags & (SCOPE_FUNCTION | SCOPE_STATIC_BLOCK) ||
      (!this.parser.inModule && scope2.flags & SCOPE_PROGRAM)
    )
  }
  declareName(name, bindingType, loc) {
    let scope2 = this.currentScope()
    if (bindingType & BIND_SCOPE_LEXICAL || bindingType & BIND_SCOPE_FUNCTION) {
      this.checkRedeclarationInScope(scope2, name, bindingType, loc)
      if (bindingType & BIND_SCOPE_FUNCTION) {
        scope2.functions.add(name)
      } else {
        scope2.lexical.add(name)
      }
      if (bindingType & BIND_SCOPE_LEXICAL) {
        this.maybeExportDefined(scope2, name)
      }
    } else if (bindingType & BIND_SCOPE_VAR) {
      for (let i = this.scopeStack.length - 1; i >= 0; --i) {
        scope2 = this.scopeStack[i]
        this.checkRedeclarationInScope(scope2, name, bindingType, loc)
        scope2.var.add(name)
        this.maybeExportDefined(scope2, name)
        if (scope2.flags & SCOPE_VAR) break
      }
    }
    if (this.parser.inModule && scope2.flags & SCOPE_PROGRAM) {
      this.undefinedExports.delete(name)
    }
  }
  maybeExportDefined(scope2, name) {
    if (this.parser.inModule && scope2.flags & SCOPE_PROGRAM) {
      this.undefinedExports.delete(name)
    }
  }
  checkRedeclarationInScope(scope2, name, bindingType, loc) {
    if (this.isRedeclaredInScope(scope2, name, bindingType)) {
      this.parser.raise(Errors.VarRedeclaration, {
        at: loc,
        identifierName: name,
      })
    }
  }
  isRedeclaredInScope(scope2, name, bindingType) {
    if (!(bindingType & BIND_KIND_VALUE)) return false
    if (bindingType & BIND_SCOPE_LEXICAL) {
      return scope2.lexical.has(name) || scope2.functions.has(name) || scope2.var.has(name)
    }
    if (bindingType & BIND_SCOPE_FUNCTION) {
      return scope2.lexical.has(name) || (!this.treatFunctionsAsVarInScope(scope2) && scope2.var.has(name))
    }
    return (
      (scope2.lexical.has(name) &&
        !(scope2.flags & SCOPE_SIMPLE_CATCH && scope2.lexical.values().next().value === name)) ||
      (!this.treatFunctionsAsVarInScope(scope2) && scope2.functions.has(name))
    )
  }
  checkLocalExport(id) {
    const { name } = id
    const topLevelScope = this.scopeStack[0]
    if (!topLevelScope.lexical.has(name) && !topLevelScope.var.has(name) && !topLevelScope.functions.has(name)) {
      this.undefinedExports.set(name, id.loc.start)
    }
  }
  currentScope() {
    return this.scopeStack[this.scopeStack.length - 1]
  }
  currentVarScopeFlags() {
    for (let i = this.scopeStack.length - 1; ; i--) {
      const { flags } = this.scopeStack[i]
      if (flags & SCOPE_VAR) {
        return flags
      }
    }
  }
  currentThisScopeFlags() {
    for (let i = this.scopeStack.length - 1; ; i--) {
      const { flags } = this.scopeStack[i]
      if (flags & (SCOPE_VAR | SCOPE_CLASS) && !(flags & SCOPE_ARROW)) {
        return flags
      }
    }
  }
}
class FlowScope extends Scope {
  constructor(...args) {
    super(...args)
    this.declareFunctions = /* @__PURE__ */ new Set()
  }
}
class FlowScopeHandler extends ScopeHandler {
  createScope(flags) {
    return new FlowScope(flags)
  }
  declareName(name, bindingType, loc) {
    const scope2 = this.currentScope()
    if (bindingType & BIND_FLAGS_FLOW_DECLARE_FN) {
      this.checkRedeclarationInScope(scope2, name, bindingType, loc)
      this.maybeExportDefined(scope2, name)
      scope2.declareFunctions.add(name)
      return
    }
    super.declareName(...arguments)
  }
  isRedeclaredInScope(scope2, name, bindingType) {
    if (super.isRedeclaredInScope(...arguments)) return true
    if (bindingType & BIND_FLAGS_FLOW_DECLARE_FN) {
      return !scope2.declareFunctions.has(name) && (scope2.lexical.has(name) || scope2.functions.has(name))
    }
    return false
  }
  checkLocalExport(id) {
    if (!this.scopeStack[0].declareFunctions.has(id.name)) {
      super.checkLocalExport(id)
    }
  }
}
class ClassScope {
  constructor() {
    this.privateNames = /* @__PURE__ */ new Set()
    this.loneAccessors = /* @__PURE__ */ new Map()
    this.undefinedPrivateNames = /* @__PURE__ */ new Map()
  }
}
class ClassScopeHandler {
  constructor(parser) {
    this.parser = void 0
    this.stack = []
    this.undefinedPrivateNames = /* @__PURE__ */ new Map()
    this.parser = parser
  }
  current() {
    return this.stack[this.stack.length - 1]
  }
  enter() {
    this.stack.push(new ClassScope())
  }
  exit() {
    const oldClassScope = this.stack.pop()
    const current = this.current()
    for (const [name, loc] of Array.from(oldClassScope.undefinedPrivateNames)) {
      if (current) {
        if (!current.undefinedPrivateNames.has(name)) {
          current.undefinedPrivateNames.set(name, loc)
        }
      } else {
        this.parser.raise(Errors.InvalidPrivateFieldResolution, {
          at: loc,
          identifierName: name,
        })
      }
    }
  }
  declarePrivateName(name, elementType, loc) {
    const { privateNames, loneAccessors, undefinedPrivateNames } = this.current()
    let redefined = privateNames.has(name)
    if (elementType & CLASS_ELEMENT_KIND_ACCESSOR) {
      const accessor = redefined && loneAccessors.get(name)
      if (accessor) {
        const oldStatic = accessor & CLASS_ELEMENT_FLAG_STATIC
        const newStatic = elementType & CLASS_ELEMENT_FLAG_STATIC
        const oldKind = accessor & CLASS_ELEMENT_KIND_ACCESSOR
        const newKind = elementType & CLASS_ELEMENT_KIND_ACCESSOR
        redefined = oldKind === newKind || oldStatic !== newStatic
        if (!redefined) loneAccessors.delete(name)
      } else if (!redefined) {
        loneAccessors.set(name, elementType)
      }
    }
    if (redefined) {
      this.parser.raise(Errors.PrivateNameRedeclaration, {
        at: loc,
        identifierName: name,
      })
    }
    privateNames.add(name)
    undefinedPrivateNames.delete(name)
  }
  usePrivateName(name, loc) {
    let classScope
    for (classScope of this.stack) {
      if (classScope.privateNames.has(name)) return
    }
    if (classScope) {
      classScope.undefinedPrivateNames.set(name, loc)
    } else {
      this.parser.raise(Errors.InvalidPrivateFieldResolution, {
        at: loc,
        identifierName: name,
      })
    }
  }
}
const kExpression = 0,
  kMaybeArrowParameterDeclaration = 1,
  kMaybeAsyncArrowParameterDeclaration = 2,
  kParameterDeclaration = 3
class ExpressionScope {
  constructor(type = kExpression) {
    this.type = void 0
    this.type = type
  }
  canBeArrowParameterDeclaration() {
    return this.type === kMaybeAsyncArrowParameterDeclaration || this.type === kMaybeArrowParameterDeclaration
  }
  isCertainlyParameterDeclaration() {
    return this.type === kParameterDeclaration
  }
}
class ArrowHeadParsingScope extends ExpressionScope {
  constructor(type) {
    super(type)
    this.declarationErrors = /* @__PURE__ */ new Map()
  }
  recordDeclarationError(ParsingErrorClass, { at }) {
    const index2 = at.index
    this.declarationErrors.set(index2, [ParsingErrorClass, at])
  }
  clearDeclarationError(index2) {
    this.declarationErrors.delete(index2)
  }
  iterateErrors(iterator) {
    this.declarationErrors.forEach(iterator)
  }
}
class ExpressionScopeHandler {
  constructor(parser) {
    this.parser = void 0
    this.stack = [new ExpressionScope()]
    this.parser = parser
  }
  enter(scope2) {
    this.stack.push(scope2)
  }
  exit() {
    this.stack.pop()
  }
  recordParameterInitializerError(toParseError, { at: node2 }) {
    const origin = {
      at: node2.loc.start,
    }
    const { stack } = this
    let i = stack.length - 1
    let scope2 = stack[i]
    while (!scope2.isCertainlyParameterDeclaration()) {
      if (scope2.canBeArrowParameterDeclaration()) {
        scope2.recordDeclarationError(toParseError, origin)
      } else {
        return
      }
      scope2 = stack[--i]
    }
    this.parser.raise(toParseError, origin)
  }
  recordArrowParemeterBindingError(error, { at: node2 }) {
    const { stack } = this
    const scope2 = stack[stack.length - 1]
    const origin = {
      at: node2.loc.start,
    }
    if (scope2.isCertainlyParameterDeclaration()) {
      this.parser.raise(error, origin)
    } else if (scope2.canBeArrowParameterDeclaration()) {
      scope2.recordDeclarationError(error, origin)
    } else {
      return
    }
  }
  recordAsyncArrowParametersError({ at }) {
    const { stack } = this
    let i = stack.length - 1
    let scope2 = stack[i]
    while (scope2.canBeArrowParameterDeclaration()) {
      if (scope2.type === kMaybeAsyncArrowParameterDeclaration) {
        scope2.recordDeclarationError(Errors.AwaitBindingIdentifier, {
          at,
        })
      }
      scope2 = stack[--i]
    }
  }
  validateAsPattern() {
    const { stack } = this
    const currentScope = stack[stack.length - 1]
    if (!currentScope.canBeArrowParameterDeclaration()) return
    currentScope.iterateErrors(([toParseError, loc]) => {
      this.parser.raise(toParseError, {
        at: loc,
      })
      let i = stack.length - 2
      let scope2 = stack[i]
      while (scope2.canBeArrowParameterDeclaration()) {
        scope2.clearDeclarationError(loc.index)
        scope2 = stack[--i]
      }
    })
  }
}
function newParameterDeclarationScope() {
  return new ExpressionScope(kParameterDeclaration)
}
function newArrowHeadScope() {
  return new ArrowHeadParsingScope(kMaybeArrowParameterDeclaration)
}
function newAsyncArrowScope() {
  return new ArrowHeadParsingScope(kMaybeAsyncArrowParameterDeclaration)
}
function newExpressionScope() {
  return new ExpressionScope()
}
const PARAM = 0,
  PARAM_YIELD = 1,
  PARAM_AWAIT = 2,
  PARAM_RETURN = 4,
  PARAM_IN = 8
class ProductionParameterHandler {
  constructor() {
    this.stacks = []
  }
  enter(flags) {
    this.stacks.push(flags)
  }
  exit() {
    this.stacks.pop()
  }
  currentFlags() {
    return this.stacks[this.stacks.length - 1]
  }
  get hasAwait() {
    return (this.currentFlags() & PARAM_AWAIT) > 0
  }
  get hasYield() {
    return (this.currentFlags() & PARAM_YIELD) > 0
  }
  get hasReturn() {
    return (this.currentFlags() & PARAM_RETURN) > 0
  }
  get hasIn() {
    return (this.currentFlags() & PARAM_IN) > 0
  }
}
function functionFlags(isAsync, isGenerator) {
  return (isAsync ? PARAM_AWAIT : 0) | (isGenerator ? PARAM_YIELD : 0)
}
class UtilParser extends Tokenizer {
  addExtra(node2, key, value, enumerable = true) {
    if (!node2) return
    const extra = (node2.extra = node2.extra || {})
    if (enumerable) {
      extra[key] = value
    } else {
      Object.defineProperty(extra, key, {
        enumerable,
        value,
      })
    }
  }
  isContextual(token) {
    return this.state.type === token && !this.state.containsEsc
  }
  isUnparsedContextual(nameStart, name) {
    const nameEnd = nameStart + name.length
    if (this.input.slice(nameStart, nameEnd) === name) {
      const nextCh = this.input.charCodeAt(nameEnd)
      return !(isIdentifierChar(nextCh) || (nextCh & 64512) === 55296)
    }
    return false
  }
  isLookaheadContextual(name) {
    const next = this.nextTokenStart()
    return this.isUnparsedContextual(next, name)
  }
  eatContextual(token) {
    if (this.isContextual(token)) {
      this.next()
      return true
    }
    return false
  }
  expectContextual(token, toParseError) {
    if (!this.eatContextual(token)) {
      if (toParseError != null) {
        throw this.raise(toParseError, {
          at: this.state.startLoc,
        })
      }
      throw this.unexpected(null, token)
    }
  }
  canInsertSemicolon() {
    return this.match(135) || this.match(8) || this.hasPrecedingLineBreak()
  }
  hasPrecedingLineBreak() {
    return lineBreak.test(this.input.slice(this.state.lastTokEndLoc.index, this.state.start))
  }
  hasFollowingLineBreak() {
    skipWhiteSpaceToLineBreak.lastIndex = this.state.end
    return skipWhiteSpaceToLineBreak.test(this.input)
  }
  isLineTerminator() {
    return this.eat(13) || this.canInsertSemicolon()
  }
  semicolon(allowAsi = true) {
    if (allowAsi ? this.isLineTerminator() : this.eat(13)) return
    this.raise(Errors.MissingSemicolon, {
      at: this.state.lastTokEndLoc,
    })
  }
  expect(type, loc) {
    this.eat(type) || this.unexpected(loc, type)
  }
  tryParse(fn, oldState = this.state.clone()) {
    const abortSignal = {
      node: null,
    }
    try {
      const node2 = fn((node3 = null) => {
        abortSignal.node = node3
        throw abortSignal
      })
      if (this.state.errors.length > oldState.errors.length) {
        const failState = this.state
        this.state = oldState
        this.state.tokensLength = failState.tokensLength
        return {
          node: node2,
          error: failState.errors[oldState.errors.length],
          thrown: false,
          aborted: false,
          failState,
        }
      }
      return {
        node: node2,
        error: null,
        thrown: false,
        aborted: false,
        failState: null,
      }
    } catch (error) {
      const failState = this.state
      this.state = oldState
      if (error instanceof SyntaxError) {
        return {
          node: null,
          error,
          thrown: true,
          aborted: false,
          failState,
        }
      }
      if (error === abortSignal) {
        return {
          node: abortSignal.node,
          error: null,
          thrown: false,
          aborted: true,
          failState,
        }
      }
      throw error
    }
  }
  checkExpressionErrors(refExpressionErrors, andThrow) {
    if (!refExpressionErrors) return false
    const { shorthandAssignLoc, doubleProtoLoc, privateKeyLoc, optionalParametersLoc } = refExpressionErrors
    const hasErrors = !!shorthandAssignLoc || !!doubleProtoLoc || !!optionalParametersLoc || !!privateKeyLoc
    if (!andThrow) {
      return hasErrors
    }
    if (shorthandAssignLoc != null) {
      this.raise(Errors.InvalidCoverInitializedName, {
        at: shorthandAssignLoc,
      })
    }
    if (doubleProtoLoc != null) {
      this.raise(Errors.DuplicateProto, {
        at: doubleProtoLoc,
      })
    }
    if (privateKeyLoc != null) {
      this.raise(Errors.UnexpectedPrivateField, {
        at: privateKeyLoc,
      })
    }
    if (optionalParametersLoc != null) {
      this.unexpected(optionalParametersLoc)
    }
  }
  isLiteralPropertyName() {
    return tokenIsLiteralPropertyName(this.state.type)
  }
  isPrivateName(node2) {
    return node2.type === 'PrivateName'
  }
  getPrivateNameSV(node2) {
    return node2.id.name
  }
  hasPropertyAsPrivateName(node2) {
    return (
      (node2.type === 'MemberExpression' || node2.type === 'OptionalMemberExpression') &&
      this.isPrivateName(node2.property)
    )
  }
  isOptionalChain(node2) {
    return node2.type === 'OptionalMemberExpression' || node2.type === 'OptionalCallExpression'
  }
  isObjectProperty(node2) {
    return node2.type === 'ObjectProperty'
  }
  isObjectMethod(node2) {
    return node2.type === 'ObjectMethod'
  }
  initializeScopes(inModule = this.options.sourceType === 'module') {
    const oldLabels = this.state.labels
    this.state.labels = []
    const oldExportedIdentifiers = this.exportedIdentifiers
    this.exportedIdentifiers = /* @__PURE__ */ new Set()
    const oldInModule = this.inModule
    this.inModule = inModule
    const oldScope = this.scope
    const ScopeHandler2 = this.getScopeHandler()
    this.scope = new ScopeHandler2(this, inModule)
    const oldProdParam = this.prodParam
    this.prodParam = new ProductionParameterHandler()
    const oldClassScope = this.classScope
    this.classScope = new ClassScopeHandler(this)
    const oldExpressionScope = this.expressionScope
    this.expressionScope = new ExpressionScopeHandler(this)
    return () => {
      this.state.labels = oldLabels
      this.exportedIdentifiers = oldExportedIdentifiers
      this.inModule = oldInModule
      this.scope = oldScope
      this.prodParam = oldProdParam
      this.classScope = oldClassScope
      this.expressionScope = oldExpressionScope
    }
  }
  enterInitialScopes() {
    let paramFlags = PARAM
    if (this.inModule) {
      paramFlags |= PARAM_AWAIT
    }
    this.scope.enter(SCOPE_PROGRAM)
    this.prodParam.enter(paramFlags)
  }
  checkDestructuringPrivate(refExpressionErrors) {
    const { privateKeyLoc } = refExpressionErrors
    if (privateKeyLoc !== null) {
      this.expectPlugin('destructuringPrivate', privateKeyLoc)
    }
  }
}
class ExpressionErrors {
  constructor() {
    this.shorthandAssignLoc = null
    this.doubleProtoLoc = null
    this.privateKeyLoc = null
    this.optionalParametersLoc = null
  }
}
class Node {
  constructor(parser, pos, loc) {
    this.type = ''
    this.start = pos
    this.end = 0
    this.loc = new SourceLocation(loc)
    if (parser != null && parser.options.ranges) this.range = [pos, 0]
    if (parser != null && parser.filename) this.loc.filename = parser.filename
  }
}
const NodePrototype = Node.prototype
{
  NodePrototype.__clone = function () {
    const newNode = new Node()
    const keys = Object.keys(this)
    for (let i = 0, length = keys.length; i < length; i++) {
      const key = keys[i]
      if (key !== 'leadingComments' && key !== 'trailingComments' && key !== 'innerComments') {
        newNode[key] = this[key]
      }
    }
    return newNode
  }
}
function clonePlaceholder(node2) {
  return cloneIdentifier(node2)
}
function cloneIdentifier(node2) {
  const { type, start, end, loc, range, extra, name } = node2
  const cloned = Object.create(NodePrototype)
  cloned.type = type
  cloned.start = start
  cloned.end = end
  cloned.loc = loc
  cloned.range = range
  cloned.extra = extra
  cloned.name = name
  if (type === 'Placeholder') {
    cloned.expectedNode = node2.expectedNode
  }
  return cloned
}
function cloneStringLiteral(node2) {
  const { type, start, end, loc, range, extra } = node2
  if (type === 'Placeholder') {
    return clonePlaceholder(node2)
  }
  const cloned = Object.create(NodePrototype)
  cloned.type = type
  cloned.start = start
  cloned.end = end
  cloned.loc = loc
  cloned.range = range
  if (node2.raw !== void 0) {
    cloned.raw = node2.raw
  } else {
    cloned.extra = extra
  }
  cloned.value = node2.value
  return cloned
}
class NodeUtils extends UtilParser {
  startNode() {
    return new Node(this, this.state.start, this.state.startLoc)
  }
  startNodeAt(pos, loc) {
    return new Node(this, pos, loc)
  }
  startNodeAtNode(type) {
    return this.startNodeAt(type.start, type.loc.start)
  }
  finishNode(node2, type) {
    return this.finishNodeAt(node2, type, this.state.lastTokEndLoc)
  }
  finishNodeAt(node2, type, endLoc) {
    node2.type = type
    node2.end = endLoc.index
    node2.loc.end = endLoc
    if (this.options.ranges) node2.range[1] = endLoc.index
    if (this.options.attachComment) this.processComment(node2)
    return node2
  }
  resetStartLocation(node2, start, startLoc) {
    node2.start = start
    node2.loc.start = startLoc
    if (this.options.ranges) node2.range[0] = start
  }
  resetEndLocation(node2, endLoc = this.state.lastTokEndLoc) {
    node2.end = endLoc.index
    node2.loc.end = endLoc
    if (this.options.ranges) node2.range[1] = endLoc.index
  }
  resetStartLocationFromNode(node2, locationNode) {
    this.resetStartLocation(node2, locationNode.start, locationNode.loc.start)
  }
}
const reservedTypes = /* @__PURE__ */ new Set([
  '_',
  'any',
  'bool',
  'boolean',
  'empty',
  'extends',
  'false',
  'interface',
  'mixed',
  'null',
  'number',
  'static',
  'string',
  'true',
  'typeof',
  'void',
])
const FlowErrors = ParseErrorEnum`flow`((_2) => ({
  AmbiguousConditionalArrow: _2('Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.'),
  AmbiguousDeclareModuleKind: _2(
    'Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.'
  ),
  AssignReservedType: _2(({ reservedType }) => `Cannot overwrite reserved type ${reservedType}.`),
  DeclareClassElement: _2('The `declare` modifier can only appear on class fields.'),
  DeclareClassFieldInitializer: _2('Initializers are not allowed in fields with the `declare` modifier.'),
  DuplicateDeclareModuleExports: _2('Duplicate `declare module.exports` statement.'),
  EnumBooleanMemberNotInitialized: _2(
    ({ memberName, enumName }) =>
      `Boolean enum members need to be initialized. Use either \`${memberName} = true,\` or \`${memberName} = false,\` in enum \`${enumName}\`.`
  ),
  EnumDuplicateMemberName: _2(
    ({ memberName, enumName }) =>
      `Enum member names need to be unique, but the name \`${memberName}\` has already been used before in enum \`${enumName}\`.`
  ),
  EnumInconsistentMemberValues: _2(
    ({ enumName }) =>
      `Enum \`${enumName}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`
  ),
  EnumInvalidExplicitType: _2(
    ({ invalidEnumType, enumName }) =>
      `Enum type \`${invalidEnumType}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${enumName}\`.`
  ),
  EnumInvalidExplicitTypeUnknownSupplied: _2(
    ({ enumName }) =>
      `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${enumName}\`.`
  ),
  EnumInvalidMemberInitializerPrimaryType: _2(
    ({ enumName, memberName, explicitType }) =>
      `Enum \`${enumName}\` has type \`${explicitType}\`, so the initializer of \`${memberName}\` needs to be a ${explicitType} literal.`
  ),
  EnumInvalidMemberInitializerSymbolType: _2(
    ({ enumName, memberName }) =>
      `Symbol enum members cannot be initialized. Use \`${memberName},\` in enum \`${enumName}\`.`
  ),
  EnumInvalidMemberInitializerUnknownType: _2(
    ({ enumName, memberName }) =>
      `The enum member initializer for \`${memberName}\` needs to be a literal (either a boolean, number, or string) in enum \`${enumName}\`.`
  ),
  EnumInvalidMemberName: _2(
    ({ enumName, memberName, suggestion }) =>
      `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${memberName}\`, consider using \`${suggestion}\`, in enum \`${enumName}\`.`
  ),
  EnumNumberMemberNotInitialized: _2(
    ({ enumName, memberName }) =>
      `Number enum members need to be initialized, e.g. \`${memberName} = 1\` in enum \`${enumName}\`.`
  ),
  EnumStringMemberInconsistentlyInitailized: _2(
    ({ enumName }) =>
      `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${enumName}\`.`
  ),
  GetterMayNotHaveThisParam: _2('A getter cannot have a `this` parameter.'),
  ImportTypeShorthandOnlyInPureImport: _2(
    'The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.'
  ),
  InexactInsideExact: _2('Explicit inexact syntax cannot appear inside an explicit exact object type.'),
  InexactInsideNonObject: _2('Explicit inexact syntax cannot appear in class or interface definitions.'),
  InexactVariance: _2('Explicit inexact syntax cannot have variance.'),
  InvalidNonTypeImportInDeclareModule: _2(
    'Imports within a `declare module` body must always be `import type` or `import typeof`.'
  ),
  MissingTypeParamDefault: _2(
    'Type parameter declaration needs a default, since a preceding type parameter declaration has a default.'
  ),
  NestedDeclareModule: _2('`declare module` cannot be used inside another `declare module`.'),
  NestedFlowComment: _2('Cannot have a flow comment inside another flow comment.'),
  PatternIsOptional: _2('A binding pattern parameter cannot be optional in an implementation signature.', {
    reasonCode: 'OptionalBindingPattern',
  }),
  SetterMayNotHaveThisParam: _2('A setter cannot have a `this` parameter.'),
  SpreadVariance: _2('Spread properties cannot have variance.'),
  ThisParamAnnotationRequired: _2('A type annotation is required for the `this` parameter.'),
  ThisParamBannedInConstructor: _2(
    "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions."
  ),
  ThisParamMayNotBeOptional: _2('The `this` parameter cannot be optional.'),
  ThisParamMustBeFirst: _2('The `this` parameter must be the first function parameter.'),
  ThisParamNoDefault: _2('The `this` parameter may not have a default value.'),
  TypeBeforeInitializer: _2(
    'Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.'
  ),
  TypeCastInPattern: _2('The type cast expression is expected to be wrapped with parenthesis.'),
  UnexpectedExplicitInexactInObject: _2('Explicit inexact syntax must appear at the end of an inexact object.'),
  UnexpectedReservedType: _2(({ reservedType }) => `Unexpected reserved type ${reservedType}.`),
  UnexpectedReservedUnderscore: _2('`_` is only allowed as a type argument to call or new.'),
  UnexpectedSpaceBetweenModuloChecks: _2('Spaces between `%` and `checks` are not allowed here.'),
  UnexpectedSpreadType: _2('Spread operator cannot appear in class or interface definitions.'),
  UnexpectedSubtractionOperand: _2('Unexpected token, expected "number" or "bigint".'),
  UnexpectedTokenAfterTypeParameter: _2('Expected an arrow function after this type parameter declaration.'),
  UnexpectedTypeParameterBeforeAsyncArrowFunction: _2(
    'Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.'
  ),
  UnsupportedDeclareExportKind: _2(
    ({ unsupportedExportKind, suggestion }) =>
      `\`declare export ${unsupportedExportKind}\` is not supported. Use \`${suggestion}\` instead.`
  ),
  UnsupportedStatementInDeclareModule: _2('Only declares and type imports are allowed inside declare module.'),
  UnterminatedFlowComment: _2('Unterminated flow-comment.'),
}))
function isEsModuleType(bodyElement) {
  return (
    bodyElement.type === 'DeclareExportAllDeclaration' ||
    (bodyElement.type === 'DeclareExportDeclaration' &&
      (!bodyElement.declaration ||
        (bodyElement.declaration.type !== 'TypeAlias' && bodyElement.declaration.type !== 'InterfaceDeclaration')))
  )
}
function hasTypeImportKind(node2) {
  return node2.importKind === 'type' || node2.importKind === 'typeof'
}
function isMaybeDefaultImport(type) {
  return tokenIsKeywordOrIdentifier(type) && type !== 97
}
const exportSuggestions = {
  const: 'declare export var',
  let: 'declare export var',
  type: 'export type',
  interface: 'export interface',
}
function partition(list2, test) {
  const list1 = []
  const list22 = []
  for (let i = 0; i < list2.length; i++) {
    ;(test(list2[i], i, list2) ? list1 : list22).push(list2[i])
  }
  return [list1, list22]
}
const FLOW_PRAGMA_REGEX = /\*?\s*@((?:no)?flow)\b/
var flow = (superClass) =>
  class extends superClass {
    constructor(...args) {
      super(...args)
      this.flowPragma = void 0
    }
    getScopeHandler() {
      return FlowScopeHandler
    }
    shouldParseTypes() {
      return this.getPluginOption('flow', 'all') || this.flowPragma === 'flow'
    }
    shouldParseEnums() {
      return !!this.getPluginOption('flow', 'enums')
    }
    finishToken(type, val) {
      if (type !== 129 && type !== 13 && type !== 28) {
        if (this.flowPragma === void 0) {
          this.flowPragma = null
        }
      }
      return super.finishToken(type, val)
    }
    addComment(comment) {
      if (this.flowPragma === void 0) {
        const matches = FLOW_PRAGMA_REGEX.exec(comment.value)
        if (!matches);
        else if (matches[1] === 'flow') {
          this.flowPragma = 'flow'
        } else if (matches[1] === 'noflow') {
          this.flowPragma = 'noflow'
        } else {
          throw new Error('Unexpected flow pragma')
        }
      }
      return super.addComment(comment)
    }
    flowParseTypeInitialiser(tok) {
      const oldInType = this.state.inType
      this.state.inType = true
      this.expect(tok || 14)
      const type = this.flowParseType()
      this.state.inType = oldInType
      return type
    }
    flowParsePredicate() {
      const node2 = this.startNode()
      const moduloLoc = this.state.startLoc
      this.next()
      this.expectContextual(107)
      if (this.state.lastTokStart > moduloLoc.index + 1) {
        this.raise(FlowErrors.UnexpectedSpaceBetweenModuloChecks, {
          at: moduloLoc,
        })
      }
      if (this.eat(10)) {
        node2.value = this.parseExpression()
        this.expect(11)
        return this.finishNode(node2, 'DeclaredPredicate')
      } else {
        return this.finishNode(node2, 'InferredPredicate')
      }
    }
    flowParseTypeAndPredicateInitialiser() {
      const oldInType = this.state.inType
      this.state.inType = true
      this.expect(14)
      let type = null
      let predicate = null
      if (this.match(54)) {
        this.state.inType = oldInType
        predicate = this.flowParsePredicate()
      } else {
        type = this.flowParseType()
        this.state.inType = oldInType
        if (this.match(54)) {
          predicate = this.flowParsePredicate()
        }
      }
      return [type, predicate]
    }
    flowParseDeclareClass(node2) {
      this.next()
      this.flowParseInterfaceish(node2, true)
      return this.finishNode(node2, 'DeclareClass')
    }
    flowParseDeclareFunction(node2) {
      this.next()
      const id = (node2.id = this.parseIdentifier())
      const typeNode = this.startNode()
      const typeContainer = this.startNode()
      if (this.match(47)) {
        typeNode.typeParameters = this.flowParseTypeParameterDeclaration()
      } else {
        typeNode.typeParameters = null
      }
      this.expect(10)
      const tmp = this.flowParseFunctionTypeParams()
      typeNode.params = tmp.params
      typeNode.rest = tmp.rest
      typeNode.this = tmp._this
      this.expect(11)
      ;[typeNode.returnType, node2.predicate] = this.flowParseTypeAndPredicateInitialiser()
      typeContainer.typeAnnotation = this.finishNode(typeNode, 'FunctionTypeAnnotation')
      id.typeAnnotation = this.finishNode(typeContainer, 'TypeAnnotation')
      this.resetEndLocation(id)
      this.semicolon()
      this.scope.declareName(node2.id.name, BIND_FLOW_DECLARE_FN, node2.id.loc.start)
      return this.finishNode(node2, 'DeclareFunction')
    }
    flowParseDeclare(node2, insideModule) {
      if (this.match(80)) {
        return this.flowParseDeclareClass(node2)
      } else if (this.match(68)) {
        return this.flowParseDeclareFunction(node2)
      } else if (this.match(74)) {
        return this.flowParseDeclareVariable(node2)
      } else if (this.eatContextual(123)) {
        if (this.match(16)) {
          return this.flowParseDeclareModuleExports(node2)
        } else {
          if (insideModule) {
            this.raise(FlowErrors.NestedDeclareModule, {
              at: this.state.lastTokStartLoc,
            })
          }
          return this.flowParseDeclareModule(node2)
        }
      } else if (this.isContextual(126)) {
        return this.flowParseDeclareTypeAlias(node2)
      } else if (this.isContextual(127)) {
        return this.flowParseDeclareOpaqueType(node2)
      } else if (this.isContextual(125)) {
        return this.flowParseDeclareInterface(node2)
      } else if (this.match(82)) {
        return this.flowParseDeclareExportDeclaration(node2, insideModule)
      } else {
        throw this.unexpected()
      }
    }
    flowParseDeclareVariable(node2) {
      this.next()
      node2.id = this.flowParseTypeAnnotatableIdentifier(true)
      this.scope.declareName(node2.id.name, BIND_VAR, node2.id.loc.start)
      this.semicolon()
      return this.finishNode(node2, 'DeclareVariable')
    }
    flowParseDeclareModule(node2) {
      this.scope.enter(SCOPE_OTHER)
      if (this.match(129)) {
        node2.id = this.parseExprAtom()
      } else {
        node2.id = this.parseIdentifier()
      }
      const bodyNode = (node2.body = this.startNode())
      const body = (bodyNode.body = [])
      this.expect(5)
      while (!this.match(8)) {
        let bodyNode2 = this.startNode()
        if (this.match(83)) {
          this.next()
          if (!this.isContextual(126) && !this.match(87)) {
            this.raise(FlowErrors.InvalidNonTypeImportInDeclareModule, {
              at: this.state.lastTokStartLoc,
            })
          }
          this.parseImport(bodyNode2)
        } else {
          this.expectContextual(121, FlowErrors.UnsupportedStatementInDeclareModule)
          bodyNode2 = this.flowParseDeclare(bodyNode2, true)
        }
        body.push(bodyNode2)
      }
      this.scope.exit()
      this.expect(8)
      this.finishNode(bodyNode, 'BlockStatement')
      let kind = null
      let hasModuleExport = false
      body.forEach((bodyElement) => {
        if (isEsModuleType(bodyElement)) {
          if (kind === 'CommonJS') {
            this.raise(FlowErrors.AmbiguousDeclareModuleKind, {
              at: bodyElement,
            })
          }
          kind = 'ES'
        } else if (bodyElement.type === 'DeclareModuleExports') {
          if (hasModuleExport) {
            this.raise(FlowErrors.DuplicateDeclareModuleExports, {
              at: bodyElement,
            })
          }
          if (kind === 'ES') {
            this.raise(FlowErrors.AmbiguousDeclareModuleKind, {
              at: bodyElement,
            })
          }
          kind = 'CommonJS'
          hasModuleExport = true
        }
      })
      node2.kind = kind || 'CommonJS'
      return this.finishNode(node2, 'DeclareModule')
    }
    flowParseDeclareExportDeclaration(node2, insideModule) {
      this.expect(82)
      if (this.eat(65)) {
        if (this.match(68) || this.match(80)) {
          node2.declaration = this.flowParseDeclare(this.startNode())
        } else {
          node2.declaration = this.flowParseType()
          this.semicolon()
        }
        node2.default = true
        return this.finishNode(node2, 'DeclareExportDeclaration')
      } else {
        if (this.match(75) || this.isLet() || ((this.isContextual(126) || this.isContextual(125)) && !insideModule)) {
          const label = this.state.value
          throw this.raise(FlowErrors.UnsupportedDeclareExportKind, {
            at: this.state.startLoc,
            unsupportedExportKind: label,
            suggestion: exportSuggestions[label],
          })
        }
        if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(127)) {
          node2.declaration = this.flowParseDeclare(this.startNode())
          node2.default = false
          return this.finishNode(node2, 'DeclareExportDeclaration')
        } else if (
          this.match(55) ||
          this.match(5) ||
          this.isContextual(125) ||
          this.isContextual(126) ||
          this.isContextual(127)
        ) {
          node2 = this.parseExport(node2)
          if (node2.type === 'ExportNamedDeclaration') {
            node2.type = 'ExportDeclaration'
            node2.default = false
            delete node2.exportKind
          }
          node2.type = 'Declare' + node2.type
          return node2
        }
      }
      throw this.unexpected()
    }
    flowParseDeclareModuleExports(node2) {
      this.next()
      this.expectContextual(108)
      node2.typeAnnotation = this.flowParseTypeAnnotation()
      this.semicolon()
      return this.finishNode(node2, 'DeclareModuleExports')
    }
    flowParseDeclareTypeAlias(node2) {
      this.next()
      this.flowParseTypeAlias(node2)
      node2.type = 'DeclareTypeAlias'
      return node2
    }
    flowParseDeclareOpaqueType(node2) {
      this.next()
      this.flowParseOpaqueType(node2, true)
      node2.type = 'DeclareOpaqueType'
      return node2
    }
    flowParseDeclareInterface(node2) {
      this.next()
      this.flowParseInterfaceish(node2)
      return this.finishNode(node2, 'DeclareInterface')
    }
    flowParseInterfaceish(node2, isClass2 = false) {
      node2.id = this.flowParseRestrictedIdentifier(!isClass2, true)
      this.scope.declareName(node2.id.name, isClass2 ? BIND_FUNCTION : BIND_LEXICAL, node2.id.loc.start)
      if (this.match(47)) {
        node2.typeParameters = this.flowParseTypeParameterDeclaration()
      } else {
        node2.typeParameters = null
      }
      node2.extends = []
      node2.implements = []
      node2.mixins = []
      if (this.eat(81)) {
        do {
          node2.extends.push(this.flowParseInterfaceExtends())
        } while (!isClass2 && this.eat(12))
      }
      if (this.isContextual(114)) {
        this.next()
        do {
          node2.mixins.push(this.flowParseInterfaceExtends())
        } while (this.eat(12))
      }
      if (this.isContextual(110)) {
        this.next()
        do {
          node2.implements.push(this.flowParseInterfaceExtends())
        } while (this.eat(12))
      }
      node2.body = this.flowParseObjectType({
        allowStatic: isClass2,
        allowExact: false,
        allowSpread: false,
        allowProto: isClass2,
        allowInexact: false,
      })
    }
    flowParseInterfaceExtends() {
      const node2 = this.startNode()
      node2.id = this.flowParseQualifiedTypeIdentifier()
      if (this.match(47)) {
        node2.typeParameters = this.flowParseTypeParameterInstantiation()
      } else {
        node2.typeParameters = null
      }
      return this.finishNode(node2, 'InterfaceExtends')
    }
    flowParseInterface(node2) {
      this.flowParseInterfaceish(node2)
      return this.finishNode(node2, 'InterfaceDeclaration')
    }
    checkNotUnderscore(word) {
      if (word === '_') {
        this.raise(FlowErrors.UnexpectedReservedUnderscore, {
          at: this.state.startLoc,
        })
      }
    }
    checkReservedType(word, startLoc, declaration) {
      if (!reservedTypes.has(word)) return
      this.raise(declaration ? FlowErrors.AssignReservedType : FlowErrors.UnexpectedReservedType, {
        at: startLoc,
        reservedType: word,
      })
    }
    flowParseRestrictedIdentifier(liberal, declaration) {
      this.checkReservedType(this.state.value, this.state.startLoc, declaration)
      return this.parseIdentifier(liberal)
    }
    flowParseTypeAlias(node2) {
      node2.id = this.flowParseRestrictedIdentifier(false, true)
      this.scope.declareName(node2.id.name, BIND_LEXICAL, node2.id.loc.start)
      if (this.match(47)) {
        node2.typeParameters = this.flowParseTypeParameterDeclaration()
      } else {
        node2.typeParameters = null
      }
      node2.right = this.flowParseTypeInitialiser(29)
      this.semicolon()
      return this.finishNode(node2, 'TypeAlias')
    }
    flowParseOpaqueType(node2, declare) {
      this.expectContextual(126)
      node2.id = this.flowParseRestrictedIdentifier(true, true)
      this.scope.declareName(node2.id.name, BIND_LEXICAL, node2.id.loc.start)
      if (this.match(47)) {
        node2.typeParameters = this.flowParseTypeParameterDeclaration()
      } else {
        node2.typeParameters = null
      }
      node2.supertype = null
      if (this.match(14)) {
        node2.supertype = this.flowParseTypeInitialiser(14)
      }
      node2.impltype = null
      if (!declare) {
        node2.impltype = this.flowParseTypeInitialiser(29)
      }
      this.semicolon()
      return this.finishNode(node2, 'OpaqueType')
    }
    flowParseTypeParameter(requireDefault = false) {
      const nodeStartLoc = this.state.startLoc
      const node2 = this.startNode()
      const variance2 = this.flowParseVariance()
      const ident = this.flowParseTypeAnnotatableIdentifier()
      node2.name = ident.name
      node2.variance = variance2
      node2.bound = ident.typeAnnotation
      if (this.match(29)) {
        this.eat(29)
        node2.default = this.flowParseType()
      } else {
        if (requireDefault) {
          this.raise(FlowErrors.MissingTypeParamDefault, {
            at: nodeStartLoc,
          })
        }
      }
      return this.finishNode(node2, 'TypeParameter')
    }
    flowParseTypeParameterDeclaration() {
      const oldInType = this.state.inType
      const node2 = this.startNode()
      node2.params = []
      this.state.inType = true
      if (this.match(47) || this.match(138)) {
        this.next()
      } else {
        this.unexpected()
      }
      let defaultRequired = false
      do {
        const typeParameter2 = this.flowParseTypeParameter(defaultRequired)
        node2.params.push(typeParameter2)
        if (typeParameter2.default) {
          defaultRequired = true
        }
        if (!this.match(48)) {
          this.expect(12)
        }
      } while (!this.match(48))
      this.expect(48)
      this.state.inType = oldInType
      return this.finishNode(node2, 'TypeParameterDeclaration')
    }
    flowParseTypeParameterInstantiation() {
      const node2 = this.startNode()
      const oldInType = this.state.inType
      node2.params = []
      this.state.inType = true
      this.expect(47)
      const oldNoAnonFunctionType = this.state.noAnonFunctionType
      this.state.noAnonFunctionType = false
      while (!this.match(48)) {
        node2.params.push(this.flowParseType())
        if (!this.match(48)) {
          this.expect(12)
        }
      }
      this.state.noAnonFunctionType = oldNoAnonFunctionType
      this.expect(48)
      this.state.inType = oldInType
      return this.finishNode(node2, 'TypeParameterInstantiation')
    }
    flowParseTypeParameterInstantiationCallOrNew() {
      const node2 = this.startNode()
      const oldInType = this.state.inType
      node2.params = []
      this.state.inType = true
      this.expect(47)
      while (!this.match(48)) {
        node2.params.push(this.flowParseTypeOrImplicitInstantiation())
        if (!this.match(48)) {
          this.expect(12)
        }
      }
      this.expect(48)
      this.state.inType = oldInType
      return this.finishNode(node2, 'TypeParameterInstantiation')
    }
    flowParseInterfaceType() {
      const node2 = this.startNode()
      this.expectContextual(125)
      node2.extends = []
      if (this.eat(81)) {
        do {
          node2.extends.push(this.flowParseInterfaceExtends())
        } while (this.eat(12))
      }
      node2.body = this.flowParseObjectType({
        allowStatic: false,
        allowExact: false,
        allowSpread: false,
        allowProto: false,
        allowInexact: false,
      })
      return this.finishNode(node2, 'InterfaceTypeAnnotation')
    }
    flowParseObjectPropertyKey() {
      return this.match(130) || this.match(129) ? this.parseExprAtom() : this.parseIdentifier(true)
    }
    flowParseObjectTypeIndexer(node2, isStatic2, variance2) {
      node2.static = isStatic2
      if (this.lookahead().type === 14) {
        node2.id = this.flowParseObjectPropertyKey()
        node2.key = this.flowParseTypeInitialiser()
      } else {
        node2.id = null
        node2.key = this.flowParseType()
      }
      this.expect(3)
      node2.value = this.flowParseTypeInitialiser()
      node2.variance = variance2
      return this.finishNode(node2, 'ObjectTypeIndexer')
    }
    flowParseObjectTypeInternalSlot(node2, isStatic2) {
      node2.static = isStatic2
      node2.id = this.flowParseObjectPropertyKey()
      this.expect(3)
      this.expect(3)
      if (this.match(47) || this.match(10)) {
        node2.method = true
        node2.optional = false
        node2.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node2.start, node2.loc.start))
      } else {
        node2.method = false
        if (this.eat(17)) {
          node2.optional = true
        }
        node2.value = this.flowParseTypeInitialiser()
      }
      return this.finishNode(node2, 'ObjectTypeInternalSlot')
    }
    flowParseObjectTypeMethodish(node2) {
      node2.params = []
      node2.rest = null
      node2.typeParameters = null
      node2.this = null
      if (this.match(47)) {
        node2.typeParameters = this.flowParseTypeParameterDeclaration()
      }
      this.expect(10)
      if (this.match(78)) {
        node2.this = this.flowParseFunctionTypeParam(true)
        node2.this.name = null
        if (!this.match(11)) {
          this.expect(12)
        }
      }
      while (!this.match(11) && !this.match(21)) {
        node2.params.push(this.flowParseFunctionTypeParam(false))
        if (!this.match(11)) {
          this.expect(12)
        }
      }
      if (this.eat(21)) {
        node2.rest = this.flowParseFunctionTypeParam(false)
      }
      this.expect(11)
      node2.returnType = this.flowParseTypeInitialiser()
      return this.finishNode(node2, 'FunctionTypeAnnotation')
    }
    flowParseObjectTypeCallProperty(node2, isStatic2) {
      const valueNode = this.startNode()
      node2.static = isStatic2
      node2.value = this.flowParseObjectTypeMethodish(valueNode)
      return this.finishNode(node2, 'ObjectTypeCallProperty')
    }
    flowParseObjectType({ allowStatic, allowExact, allowSpread, allowProto, allowInexact }) {
      const oldInType = this.state.inType
      this.state.inType = true
      const nodeStart = this.startNode()
      nodeStart.callProperties = []
      nodeStart.properties = []
      nodeStart.indexers = []
      nodeStart.internalSlots = []
      let endDelim
      let exact
      let inexact2 = false
      if (allowExact && this.match(6)) {
        this.expect(6)
        endDelim = 9
        exact = true
      } else {
        this.expect(5)
        endDelim = 8
        exact = false
      }
      nodeStart.exact = exact
      while (!this.match(endDelim)) {
        let isStatic2 = false
        let protoStartLoc = null
        let inexactStartLoc = null
        const node2 = this.startNode()
        if (allowProto && this.isContextual(115)) {
          const lookahead = this.lookahead()
          if (lookahead.type !== 14 && lookahead.type !== 17) {
            this.next()
            protoStartLoc = this.state.startLoc
            allowStatic = false
          }
        }
        if (allowStatic && this.isContextual(104)) {
          const lookahead = this.lookahead()
          if (lookahead.type !== 14 && lookahead.type !== 17) {
            this.next()
            isStatic2 = true
          }
        }
        const variance2 = this.flowParseVariance()
        if (this.eat(0)) {
          if (protoStartLoc != null) {
            this.unexpected(protoStartLoc)
          }
          if (this.eat(0)) {
            if (variance2) {
              this.unexpected(variance2.loc.start)
            }
            nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node2, isStatic2))
          } else {
            nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node2, isStatic2, variance2))
          }
        } else if (this.match(10) || this.match(47)) {
          if (protoStartLoc != null) {
            this.unexpected(protoStartLoc)
          }
          if (variance2) {
            this.unexpected(variance2.loc.start)
          }
          nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node2, isStatic2))
        } else {
          let kind = 'init'
          if (this.isContextual(98) || this.isContextual(103)) {
            const lookahead = this.lookahead()
            if (tokenIsLiteralPropertyName(lookahead.type)) {
              kind = this.state.value
              this.next()
            }
          }
          const propOrInexact = this.flowParseObjectTypeProperty(
            node2,
            isStatic2,
            protoStartLoc,
            variance2,
            kind,
            allowSpread,
            allowInexact != null ? allowInexact : !exact
          )
          if (propOrInexact === null) {
            inexact2 = true
            inexactStartLoc = this.state.lastTokStartLoc
          } else {
            nodeStart.properties.push(propOrInexact)
          }
        }
        this.flowObjectTypeSemicolon()
        if (inexactStartLoc && !this.match(8) && !this.match(9)) {
          this.raise(FlowErrors.UnexpectedExplicitInexactInObject, {
            at: inexactStartLoc,
          })
        }
      }
      this.expect(endDelim)
      if (allowSpread) {
        nodeStart.inexact = inexact2
      }
      const out = this.finishNode(nodeStart, 'ObjectTypeAnnotation')
      this.state.inType = oldInType
      return out
    }
    flowParseObjectTypeProperty(node2, isStatic2, protoStartLoc, variance2, kind, allowSpread, allowInexact) {
      if (this.eat(21)) {
        const isInexactToken = this.match(12) || this.match(13) || this.match(8) || this.match(9)
        if (isInexactToken) {
          if (!allowSpread) {
            this.raise(FlowErrors.InexactInsideNonObject, {
              at: this.state.lastTokStartLoc,
            })
          } else if (!allowInexact) {
            this.raise(FlowErrors.InexactInsideExact, {
              at: this.state.lastTokStartLoc,
            })
          }
          if (variance2) {
            this.raise(FlowErrors.InexactVariance, {
              at: variance2,
            })
          }
          return null
        }
        if (!allowSpread) {
          this.raise(FlowErrors.UnexpectedSpreadType, {
            at: this.state.lastTokStartLoc,
          })
        }
        if (protoStartLoc != null) {
          this.unexpected(protoStartLoc)
        }
        if (variance2) {
          this.raise(FlowErrors.SpreadVariance, {
            at: variance2,
          })
        }
        node2.argument = this.flowParseType()
        return this.finishNode(node2, 'ObjectTypeSpreadProperty')
      } else {
        node2.key = this.flowParseObjectPropertyKey()
        node2.static = isStatic2
        node2.proto = protoStartLoc != null
        node2.kind = kind
        let optional = false
        if (this.match(47) || this.match(10)) {
          node2.method = true
          if (protoStartLoc != null) {
            this.unexpected(protoStartLoc)
          }
          if (variance2) {
            this.unexpected(variance2.loc.start)
          }
          node2.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node2.start, node2.loc.start))
          if (kind === 'get' || kind === 'set') {
            this.flowCheckGetterSetterParams(node2)
          }
          if (!allowSpread && node2.key.name === 'constructor' && node2.value.this) {
            this.raise(FlowErrors.ThisParamBannedInConstructor, {
              at: node2.value.this,
            })
          }
        } else {
          if (kind !== 'init') this.unexpected()
          node2.method = false
          if (this.eat(17)) {
            optional = true
          }
          node2.value = this.flowParseTypeInitialiser()
          node2.variance = variance2
        }
        node2.optional = optional
        return this.finishNode(node2, 'ObjectTypeProperty')
      }
    }
    flowCheckGetterSetterParams(property) {
      const paramCount = property.kind === 'get' ? 0 : 1
      const length = property.value.params.length + (property.value.rest ? 1 : 0)
      if (property.value.this) {
        this.raise(
          property.kind === 'get' ? FlowErrors.GetterMayNotHaveThisParam : FlowErrors.SetterMayNotHaveThisParam,
          {
            at: property.value.this,
          }
        )
      }
      if (length !== paramCount) {
        this.raise(property.kind === 'get' ? Errors.BadGetterArity : Errors.BadSetterArity, {
          at: property,
        })
      }
      if (property.kind === 'set' && property.value.rest) {
        this.raise(Errors.BadSetterRestParameter, {
          at: property,
        })
      }
    }
    flowObjectTypeSemicolon() {
      if (!this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9)) {
        this.unexpected()
      }
    }
    flowParseQualifiedTypeIdentifier(startPos, startLoc, id) {
      startPos = startPos || this.state.start
      startLoc = startLoc || this.state.startLoc
      let node2 = id || this.flowParseRestrictedIdentifier(true)
      while (this.eat(16)) {
        const node22 = this.startNodeAt(startPos, startLoc)
        node22.qualification = node2
        node22.id = this.flowParseRestrictedIdentifier(true)
        node2 = this.finishNode(node22, 'QualifiedTypeIdentifier')
      }
      return node2
    }
    flowParseGenericType(startPos, startLoc, id) {
      const node2 = this.startNodeAt(startPos, startLoc)
      node2.typeParameters = null
      node2.id = this.flowParseQualifiedTypeIdentifier(startPos, startLoc, id)
      if (this.match(47)) {
        node2.typeParameters = this.flowParseTypeParameterInstantiation()
      }
      return this.finishNode(node2, 'GenericTypeAnnotation')
    }
    flowParseTypeofType() {
      const node2 = this.startNode()
      this.expect(87)
      node2.argument = this.flowParsePrimaryType()
      return this.finishNode(node2, 'TypeofTypeAnnotation')
    }
    flowParseTupleType() {
      const node2 = this.startNode()
      node2.types = []
      this.expect(0)
      while (this.state.pos < this.length && !this.match(3)) {
        node2.types.push(this.flowParseType())
        if (this.match(3)) break
        this.expect(12)
      }
      this.expect(3)
      return this.finishNode(node2, 'TupleTypeAnnotation')
    }
    flowParseFunctionTypeParam(first) {
      let name = null
      let optional = false
      let typeAnnotation2 = null
      const node2 = this.startNode()
      const lh = this.lookahead()
      const isThis = this.state.type === 78
      if (lh.type === 14 || lh.type === 17) {
        if (isThis && !first) {
          this.raise(FlowErrors.ThisParamMustBeFirst, {
            at: node2,
          })
        }
        name = this.parseIdentifier(isThis)
        if (this.eat(17)) {
          optional = true
          if (isThis) {
            this.raise(FlowErrors.ThisParamMayNotBeOptional, {
              at: node2,
            })
          }
        }
        typeAnnotation2 = this.flowParseTypeInitialiser()
      } else {
        typeAnnotation2 = this.flowParseType()
      }
      node2.name = name
      node2.optional = optional
      node2.typeAnnotation = typeAnnotation2
      return this.finishNode(node2, 'FunctionTypeParam')
    }
    reinterpretTypeAsFunctionTypeParam(type) {
      const node2 = this.startNodeAt(type.start, type.loc.start)
      node2.name = null
      node2.optional = false
      node2.typeAnnotation = type
      return this.finishNode(node2, 'FunctionTypeParam')
    }
    flowParseFunctionTypeParams(params = []) {
      let rest = null
      let _this = null
      if (this.match(78)) {
        _this = this.flowParseFunctionTypeParam(true)
        _this.name = null
        if (!this.match(11)) {
          this.expect(12)
        }
      }
      while (!this.match(11) && !this.match(21)) {
        params.push(this.flowParseFunctionTypeParam(false))
        if (!this.match(11)) {
          this.expect(12)
        }
      }
      if (this.eat(21)) {
        rest = this.flowParseFunctionTypeParam(false)
      }
      return {
        params,
        rest,
        _this,
      }
    }
    flowIdentToTypeAnnotation(startPos, startLoc, node2, id) {
      switch (id.name) {
        case 'any':
          return this.finishNode(node2, 'AnyTypeAnnotation')
        case 'bool':
        case 'boolean':
          return this.finishNode(node2, 'BooleanTypeAnnotation')
        case 'mixed':
          return this.finishNode(node2, 'MixedTypeAnnotation')
        case 'empty':
          return this.finishNode(node2, 'EmptyTypeAnnotation')
        case 'number':
          return this.finishNode(node2, 'NumberTypeAnnotation')
        case 'string':
          return this.finishNode(node2, 'StringTypeAnnotation')
        case 'symbol':
          return this.finishNode(node2, 'SymbolTypeAnnotation')
        default:
          this.checkNotUnderscore(id.name)
          return this.flowParseGenericType(startPos, startLoc, id)
      }
    }
    flowParsePrimaryType() {
      const startPos = this.state.start
      const startLoc = this.state.startLoc
      const node2 = this.startNode()
      let tmp
      let type
      let isGroupedType = false
      const oldNoAnonFunctionType = this.state.noAnonFunctionType
      switch (this.state.type) {
        case 5:
          return this.flowParseObjectType({
            allowStatic: false,
            allowExact: false,
            allowSpread: true,
            allowProto: false,
            allowInexact: true,
          })
        case 6:
          return this.flowParseObjectType({
            allowStatic: false,
            allowExact: true,
            allowSpread: true,
            allowProto: false,
            allowInexact: false,
          })
        case 0:
          this.state.noAnonFunctionType = false
          type = this.flowParseTupleType()
          this.state.noAnonFunctionType = oldNoAnonFunctionType
          return type
        case 47:
          node2.typeParameters = this.flowParseTypeParameterDeclaration()
          this.expect(10)
          tmp = this.flowParseFunctionTypeParams()
          node2.params = tmp.params
          node2.rest = tmp.rest
          node2.this = tmp._this
          this.expect(11)
          this.expect(19)
          node2.returnType = this.flowParseType()
          return this.finishNode(node2, 'FunctionTypeAnnotation')
        case 10:
          this.next()
          if (!this.match(11) && !this.match(21)) {
            if (tokenIsIdentifier(this.state.type) || this.match(78)) {
              const token = this.lookahead().type
              isGroupedType = token !== 17 && token !== 14
            } else {
              isGroupedType = true
            }
          }
          if (isGroupedType) {
            this.state.noAnonFunctionType = false
            type = this.flowParseType()
            this.state.noAnonFunctionType = oldNoAnonFunctionType
            if (
              this.state.noAnonFunctionType ||
              !(this.match(12) || (this.match(11) && this.lookahead().type === 19))
            ) {
              this.expect(11)
              return type
            } else {
              this.eat(12)
            }
          }
          if (type) {
            tmp = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type)])
          } else {
            tmp = this.flowParseFunctionTypeParams()
          }
          node2.params = tmp.params
          node2.rest = tmp.rest
          node2.this = tmp._this
          this.expect(11)
          this.expect(19)
          node2.returnType = this.flowParseType()
          node2.typeParameters = null
          return this.finishNode(node2, 'FunctionTypeAnnotation')
        case 129:
          return this.parseLiteral(this.state.value, 'StringLiteralTypeAnnotation')
        case 85:
        case 86:
          node2.value = this.match(85)
          this.next()
          return this.finishNode(node2, 'BooleanLiteralTypeAnnotation')
        case 53:
          if (this.state.value === '-') {
            this.next()
            if (this.match(130)) {
              return this.parseLiteralAtNode(-this.state.value, 'NumberLiteralTypeAnnotation', node2)
            }
            if (this.match(131)) {
              return this.parseLiteralAtNode(-this.state.value, 'BigIntLiteralTypeAnnotation', node2)
            }
            throw this.raise(FlowErrors.UnexpectedSubtractionOperand, {
              at: this.state.startLoc,
            })
          }
          throw this.unexpected()
        case 130:
          return this.parseLiteral(this.state.value, 'NumberLiteralTypeAnnotation')
        case 131:
          return this.parseLiteral(this.state.value, 'BigIntLiteralTypeAnnotation')
        case 88:
          this.next()
          return this.finishNode(node2, 'VoidTypeAnnotation')
        case 84:
          this.next()
          return this.finishNode(node2, 'NullLiteralTypeAnnotation')
        case 78:
          this.next()
          return this.finishNode(node2, 'ThisTypeAnnotation')
        case 55:
          this.next()
          return this.finishNode(node2, 'ExistsTypeAnnotation')
        case 87:
          return this.flowParseTypeofType()
        default:
          if (tokenIsKeyword(this.state.type)) {
            const label = tokenLabelName(this.state.type)
            this.next()
            return super.createIdentifier(node2, label)
          } else if (tokenIsIdentifier(this.state.type)) {
            if (this.isContextual(125)) {
              return this.flowParseInterfaceType()
            }
            return this.flowIdentToTypeAnnotation(startPos, startLoc, node2, this.parseIdentifier())
          }
      }
      throw this.unexpected()
    }
    flowParsePostfixType() {
      const startPos = this.state.start
      const startLoc = this.state.startLoc
      let type = this.flowParsePrimaryType()
      let seenOptionalIndexedAccess = false
      while ((this.match(0) || this.match(18)) && !this.canInsertSemicolon()) {
        const node2 = this.startNodeAt(startPos, startLoc)
        const optional = this.eat(18)
        seenOptionalIndexedAccess = seenOptionalIndexedAccess || optional
        this.expect(0)
        if (!optional && this.match(3)) {
          node2.elementType = type
          this.next()
          type = this.finishNode(node2, 'ArrayTypeAnnotation')
        } else {
          node2.objectType = type
          node2.indexType = this.flowParseType()
          this.expect(3)
          if (seenOptionalIndexedAccess) {
            node2.optional = optional
            type = this.finishNode(node2, 'OptionalIndexedAccessType')
          } else {
            type = this.finishNode(node2, 'IndexedAccessType')
          }
        }
      }
      return type
    }
    flowParsePrefixType() {
      const node2 = this.startNode()
      if (this.eat(17)) {
        node2.typeAnnotation = this.flowParsePrefixType()
        return this.finishNode(node2, 'NullableTypeAnnotation')
      } else {
        return this.flowParsePostfixType()
      }
    }
    flowParseAnonFunctionWithoutParens() {
      const param = this.flowParsePrefixType()
      if (!this.state.noAnonFunctionType && this.eat(19)) {
        const node2 = this.startNodeAt(param.start, param.loc.start)
        node2.params = [this.reinterpretTypeAsFunctionTypeParam(param)]
        node2.rest = null
        node2.this = null
        node2.returnType = this.flowParseType()
        node2.typeParameters = null
        return this.finishNode(node2, 'FunctionTypeAnnotation')
      }
      return param
    }
    flowParseIntersectionType() {
      const node2 = this.startNode()
      this.eat(45)
      const type = this.flowParseAnonFunctionWithoutParens()
      node2.types = [type]
      while (this.eat(45)) {
        node2.types.push(this.flowParseAnonFunctionWithoutParens())
      }
      return node2.types.length === 1 ? type : this.finishNode(node2, 'IntersectionTypeAnnotation')
    }
    flowParseUnionType() {
      const node2 = this.startNode()
      this.eat(43)
      const type = this.flowParseIntersectionType()
      node2.types = [type]
      while (this.eat(43)) {
        node2.types.push(this.flowParseIntersectionType())
      }
      return node2.types.length === 1 ? type : this.finishNode(node2, 'UnionTypeAnnotation')
    }
    flowParseType() {
      const oldInType = this.state.inType
      this.state.inType = true
      const type = this.flowParseUnionType()
      this.state.inType = oldInType
      return type
    }
    flowParseTypeOrImplicitInstantiation() {
      if (this.state.type === 128 && this.state.value === '_') {
        const startPos = this.state.start
        const startLoc = this.state.startLoc
        const node2 = this.parseIdentifier()
        return this.flowParseGenericType(startPos, startLoc, node2)
      } else {
        return this.flowParseType()
      }
    }
    flowParseTypeAnnotation() {
      const node2 = this.startNode()
      node2.typeAnnotation = this.flowParseTypeInitialiser()
      return this.finishNode(node2, 'TypeAnnotation')
    }
    flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {
      const ident = allowPrimitiveOverride ? this.parseIdentifier() : this.flowParseRestrictedIdentifier()
      if (this.match(14)) {
        ident.typeAnnotation = this.flowParseTypeAnnotation()
        this.resetEndLocation(ident)
      }
      return ident
    }
    typeCastToParameter(node2) {
      node2.expression.typeAnnotation = node2.typeAnnotation
      this.resetEndLocation(node2.expression, node2.typeAnnotation.loc.end)
      return node2.expression
    }
    flowParseVariance() {
      let variance2 = null
      if (this.match(53)) {
        variance2 = this.startNode()
        if (this.state.value === '+') {
          variance2.kind = 'plus'
        } else {
          variance2.kind = 'minus'
        }
        this.next()
        this.finishNode(variance2, 'Variance')
      }
      return variance2
    }
    parseFunctionBody(node2, allowExpressionBody, isMethod2 = false) {
      if (allowExpressionBody) {
        return this.forwardNoArrowParamsConversionAt(node2, () => super.parseFunctionBody(node2, true, isMethod2))
      }
      return super.parseFunctionBody(node2, false, isMethod2)
    }
    parseFunctionBodyAndFinish(node2, type, isMethod2 = false) {
      if (this.match(14)) {
        const typeNode = this.startNode()
        ;[typeNode.typeAnnotation, node2.predicate] = this.flowParseTypeAndPredicateInitialiser()
        node2.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, 'TypeAnnotation') : null
      }
      super.parseFunctionBodyAndFinish(node2, type, isMethod2)
    }
    parseStatement(context2, topLevel) {
      if (this.state.strict && this.isContextual(125)) {
        const lookahead = this.lookahead()
        if (tokenIsKeywordOrIdentifier(lookahead.type)) {
          const node2 = this.startNode()
          this.next()
          return this.flowParseInterface(node2)
        }
      } else if (this.shouldParseEnums() && this.isContextual(122)) {
        const node2 = this.startNode()
        this.next()
        return this.flowParseEnumDeclaration(node2)
      }
      const stmt = super.parseStatement(context2, topLevel)
      if (this.flowPragma === void 0 && !this.isValidDirective(stmt)) {
        this.flowPragma = null
      }
      return stmt
    }
    parseExpressionStatement(node2, expr) {
      if (expr.type === 'Identifier') {
        if (expr.name === 'declare') {
          if (
            this.match(80) ||
            tokenIsIdentifier(this.state.type) ||
            this.match(68) ||
            this.match(74) ||
            this.match(82)
          ) {
            return this.flowParseDeclare(node2)
          }
        } else if (tokenIsIdentifier(this.state.type)) {
          if (expr.name === 'interface') {
            return this.flowParseInterface(node2)
          } else if (expr.name === 'type') {
            return this.flowParseTypeAlias(node2)
          } else if (expr.name === 'opaque') {
            return this.flowParseOpaqueType(node2, false)
          }
        }
      }
      return super.parseExpressionStatement(node2, expr)
    }
    shouldParseExportDeclaration() {
      const { type } = this.state
      if (tokenIsFlowInterfaceOrTypeOrOpaque(type) || (this.shouldParseEnums() && type === 122)) {
        return !this.state.containsEsc
      }
      return super.shouldParseExportDeclaration()
    }
    isExportDefaultSpecifier() {
      const { type } = this.state
      if (tokenIsFlowInterfaceOrTypeOrOpaque(type) || (this.shouldParseEnums() && type === 122)) {
        return this.state.containsEsc
      }
      return super.isExportDefaultSpecifier()
    }
    parseExportDefaultExpression() {
      if (this.shouldParseEnums() && this.isContextual(122)) {
        const node2 = this.startNode()
        this.next()
        return this.flowParseEnumDeclaration(node2)
      }
      return super.parseExportDefaultExpression()
    }
    parseConditional(expr, startPos, startLoc, refExpressionErrors) {
      if (!this.match(17)) return expr
      if (this.state.maybeInArrowParameters) {
        const nextCh = this.lookaheadCharCode()
        if (nextCh === 44 || nextCh === 61 || nextCh === 58 || nextCh === 41) {
          this.setOptionalParametersError(refExpressionErrors)
          return expr
        }
      }
      this.expect(17)
      const state = this.state.clone()
      const originalNoArrowAt = this.state.noArrowAt
      const node2 = this.startNodeAt(startPos, startLoc)
      let { consequent, failed } = this.tryParseConditionalConsequent()
      let [valid, invalid] = this.getArrowLikeExpressions(consequent)
      if (failed || invalid.length > 0) {
        const noArrowAt = [...originalNoArrowAt]
        if (invalid.length > 0) {
          this.state = state
          this.state.noArrowAt = noArrowAt
          for (let i = 0; i < invalid.length; i++) {
            noArrowAt.push(invalid[i].start)
          }
          ;({ consequent, failed } = this.tryParseConditionalConsequent())
          ;[valid, invalid] = this.getArrowLikeExpressions(consequent)
        }
        if (failed && valid.length > 1) {
          this.raise(FlowErrors.AmbiguousConditionalArrow, {
            at: state.startLoc,
          })
        }
        if (failed && valid.length === 1) {
          this.state = state
          noArrowAt.push(valid[0].start)
          this.state.noArrowAt = noArrowAt
          ;({ consequent, failed } = this.tryParseConditionalConsequent())
        }
      }
      this.getArrowLikeExpressions(consequent, true)
      this.state.noArrowAt = originalNoArrowAt
      this.expect(14)
      node2.test = expr
      node2.consequent = consequent
      node2.alternate = this.forwardNoArrowParamsConversionAt(node2, () => this.parseMaybeAssign(void 0, void 0))
      return this.finishNode(node2, 'ConditionalExpression')
    }
    tryParseConditionalConsequent() {
      this.state.noArrowParamsConversionAt.push(this.state.start)
      const consequent = this.parseMaybeAssignAllowIn()
      const failed = !this.match(14)
      this.state.noArrowParamsConversionAt.pop()
      return {
        consequent,
        failed,
      }
    }
    getArrowLikeExpressions(node2, disallowInvalid) {
      const stack = [node2]
      const arrows = []
      while (stack.length !== 0) {
        const node3 = stack.pop()
        if (node3.type === 'ArrowFunctionExpression') {
          if (node3.typeParameters || !node3.returnType) {
            this.finishArrowValidation(node3)
          } else {
            arrows.push(node3)
          }
          stack.push(node3.body)
        } else if (node3.type === 'ConditionalExpression') {
          stack.push(node3.consequent)
          stack.push(node3.alternate)
        }
      }
      if (disallowInvalid) {
        arrows.forEach((node3) => this.finishArrowValidation(node3))
        return [arrows, []]
      }
      return partition(arrows, (node3) => node3.params.every((param) => this.isAssignable(param, true)))
    }
    finishArrowValidation(node2) {
      var _node$extra
      this.toAssignableList(
        node2.params,
        (_node$extra = node2.extra) == null ? void 0 : _node$extra.trailingCommaLoc,
        false
      )
      this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW)
      super.checkParams(node2, false, true)
      this.scope.exit()
    }
    forwardNoArrowParamsConversionAt(node2, parse2) {
      let result
      if (this.state.noArrowParamsConversionAt.indexOf(node2.start) !== -1) {
        this.state.noArrowParamsConversionAt.push(this.state.start)
        result = parse2()
        this.state.noArrowParamsConversionAt.pop()
      } else {
        result = parse2()
      }
      return result
    }
    parseParenItem(node2, startPos, startLoc) {
      node2 = super.parseParenItem(node2, startPos, startLoc)
      if (this.eat(17)) {
        node2.optional = true
        this.resetEndLocation(node2)
      }
      if (this.match(14)) {
        const typeCastNode = this.startNodeAt(startPos, startLoc)
        typeCastNode.expression = node2
        typeCastNode.typeAnnotation = this.flowParseTypeAnnotation()
        return this.finishNode(typeCastNode, 'TypeCastExpression')
      }
      return node2
    }
    assertModuleNodeAllowed(node2) {
      if (
        (node2.type === 'ImportDeclaration' && (node2.importKind === 'type' || node2.importKind === 'typeof')) ||
        (node2.type === 'ExportNamedDeclaration' && node2.exportKind === 'type') ||
        (node2.type === 'ExportAllDeclaration' && node2.exportKind === 'type')
      ) {
        return
      }
      super.assertModuleNodeAllowed(node2)
    }
    parseExport(node2) {
      const decl = super.parseExport(node2)
      if (decl.type === 'ExportNamedDeclaration' || decl.type === 'ExportAllDeclaration') {
        decl.exportKind = decl.exportKind || 'value'
      }
      return decl
    }
    parseExportDeclaration(node2) {
      if (this.isContextual(126)) {
        node2.exportKind = 'type'
        const declarationNode = this.startNode()
        this.next()
        if (this.match(5)) {
          node2.specifiers = this.parseExportSpecifiers(true)
          this.parseExportFrom(node2)
          return null
        } else {
          return this.flowParseTypeAlias(declarationNode)
        }
      } else if (this.isContextual(127)) {
        node2.exportKind = 'type'
        const declarationNode = this.startNode()
        this.next()
        return this.flowParseOpaqueType(declarationNode, false)
      } else if (this.isContextual(125)) {
        node2.exportKind = 'type'
        const declarationNode = this.startNode()
        this.next()
        return this.flowParseInterface(declarationNode)
      } else if (this.shouldParseEnums() && this.isContextual(122)) {
        node2.exportKind = 'value'
        const declarationNode = this.startNode()
        this.next()
        return this.flowParseEnumDeclaration(declarationNode)
      } else {
        return super.parseExportDeclaration(node2)
      }
    }
    eatExportStar(node2) {
      if (super.eatExportStar(...arguments)) return true
      if (this.isContextual(126) && this.lookahead().type === 55) {
        node2.exportKind = 'type'
        this.next()
        this.next()
        return true
      }
      return false
    }
    maybeParseExportNamespaceSpecifier(node2) {
      const { startLoc } = this.state
      const hasNamespace = super.maybeParseExportNamespaceSpecifier(node2)
      if (hasNamespace && node2.exportKind === 'type') {
        this.unexpected(startLoc)
      }
      return hasNamespace
    }
    parseClassId(node2, isStatement2, optionalId) {
      super.parseClassId(node2, isStatement2, optionalId)
      if (this.match(47)) {
        node2.typeParameters = this.flowParseTypeParameterDeclaration()
      }
    }
    parseClassMember(classBody2, member, state) {
      const { startLoc } = this.state
      if (this.isContextual(121)) {
        if (this.parseClassMemberFromModifier(classBody2, member)) {
          return
        }
        member.declare = true
      }
      super.parseClassMember(classBody2, member, state)
      if (member.declare) {
        if (
          member.type !== 'ClassProperty' &&
          member.type !== 'ClassPrivateProperty' &&
          member.type !== 'PropertyDefinition'
        ) {
          this.raise(FlowErrors.DeclareClassElement, {
            at: startLoc,
          })
        } else if (member.value) {
          this.raise(FlowErrors.DeclareClassFieldInitializer, {
            at: member.value,
          })
        }
      }
    }
    isIterator(word) {
      return word === 'iterator' || word === 'asyncIterator'
    }
    readIterator() {
      const word = super.readWord1()
      const fullWord = '@@' + word
      if (!this.isIterator(word) || !this.state.inType) {
        this.raise(Errors.InvalidIdentifier, {
          at: this.state.curPosition(),
          identifierName: fullWord,
        })
      }
      this.finishToken(128, fullWord)
    }
    getTokenFromCode(code2) {
      const next = this.input.charCodeAt(this.state.pos + 1)
      if (code2 === 123 && next === 124) {
        return this.finishOp(6, 2)
      } else if (this.state.inType && (code2 === 62 || code2 === 60)) {
        return this.finishOp(code2 === 62 ? 48 : 47, 1)
      } else if (this.state.inType && code2 === 63) {
        if (next === 46) {
          return this.finishOp(18, 2)
        }
        return this.finishOp(17, 1)
      } else if (isIteratorStart(code2, next, this.input.charCodeAt(this.state.pos + 2))) {
        this.state.pos += 2
        return this.readIterator()
      } else {
        return super.getTokenFromCode(code2)
      }
    }
    isAssignable(node2, isBinding2) {
      if (node2.type === 'TypeCastExpression') {
        return this.isAssignable(node2.expression, isBinding2)
      } else {
        return super.isAssignable(node2, isBinding2)
      }
    }
    toAssignable(node2, isLHS = false) {
      if (!isLHS && node2.type === 'AssignmentExpression' && node2.left.type === 'TypeCastExpression') {
        node2.left = this.typeCastToParameter(node2.left)
      }
      super.toAssignable(...arguments)
    }
    toAssignableList(exprList, trailingCommaLoc, isLHS) {
      for (let i = 0; i < exprList.length; i++) {
        const expr = exprList[i]
        if ((expr == null ? void 0 : expr.type) === 'TypeCastExpression') {
          exprList[i] = this.typeCastToParameter(expr)
        }
      }
      super.toAssignableList(exprList, trailingCommaLoc, isLHS)
    }
    toReferencedList(exprList, isParenthesizedExpr) {
      for (let i = 0; i < exprList.length; i++) {
        var _expr$extra
        const expr = exprList[i]
        if (
          expr &&
          expr.type === 'TypeCastExpression' &&
          !((_expr$extra = expr.extra) != null && _expr$extra.parenthesized) &&
          (exprList.length > 1 || !isParenthesizedExpr)
        ) {
          this.raise(FlowErrors.TypeCastInPattern, {
            at: expr.typeAnnotation,
          })
        }
      }
      return exprList
    }
    parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
      const node2 = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors)
      if (canBePattern && !this.state.maybeInArrowParameters) {
        this.toReferencedList(node2.elements)
      }
      return node2
    }
    isValidLVal(type, ...rest) {
      return type === 'TypeCastExpression' || super.isValidLVal(type, ...rest)
    }
    parseClassProperty(node2) {
      if (this.match(14)) {
        node2.typeAnnotation = this.flowParseTypeAnnotation()
      }
      return super.parseClassProperty(node2)
    }
    parseClassPrivateProperty(node2) {
      if (this.match(14)) {
        node2.typeAnnotation = this.flowParseTypeAnnotation()
      }
      return super.parseClassPrivateProperty(node2)
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod()
    }
    isClassProperty() {
      return this.match(14) || super.isClassProperty()
    }
    isNonstaticConstructor(method) {
      return !this.match(14) && super.isNonstaticConstructor(method)
    }
    pushClassMethod(classBody2, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
      if (method.variance) {
        this.unexpected(method.variance.loc.start)
      }
      delete method.variance
      if (this.match(47)) {
        method.typeParameters = this.flowParseTypeParameterDeclaration()
      }
      super.pushClassMethod(classBody2, method, isGenerator, isAsync, isConstructor, allowsDirectSuper)
      if (method.params && isConstructor) {
        const params = method.params
        if (params.length > 0 && this.isThisParam(params[0])) {
          this.raise(FlowErrors.ThisParamBannedInConstructor, {
            at: method,
          })
        }
      } else if (method.type === 'MethodDefinition' && isConstructor && method.value.params) {
        const params = method.value.params
        if (params.length > 0 && this.isThisParam(params[0])) {
          this.raise(FlowErrors.ThisParamBannedInConstructor, {
            at: method,
          })
        }
      }
    }
    pushClassPrivateMethod(classBody2, method, isGenerator, isAsync) {
      if (method.variance) {
        this.unexpected(method.variance.loc.start)
      }
      delete method.variance
      if (this.match(47)) {
        method.typeParameters = this.flowParseTypeParameterDeclaration()
      }
      super.pushClassPrivateMethod(classBody2, method, isGenerator, isAsync)
    }
    parseClassSuper(node2) {
      super.parseClassSuper(node2)
      if (node2.superClass && this.match(47)) {
        node2.superTypeParameters = this.flowParseTypeParameterInstantiation()
      }
      if (this.isContextual(110)) {
        this.next()
        const implemented = (node2.implements = [])
        do {
          const node3 = this.startNode()
          node3.id = this.flowParseRestrictedIdentifier(true)
          if (this.match(47)) {
            node3.typeParameters = this.flowParseTypeParameterInstantiation()
          } else {
            node3.typeParameters = null
          }
          implemented.push(this.finishNode(node3, 'ClassImplements'))
        } while (this.eat(12))
      }
    }
    checkGetterSetterParams(method) {
      super.checkGetterSetterParams(method)
      const params = this.getObjectOrClassMethodParams(method)
      if (params.length > 0) {
        const param = params[0]
        if (this.isThisParam(param) && method.kind === 'get') {
          this.raise(FlowErrors.GetterMayNotHaveThisParam, {
            at: param,
          })
        } else if (this.isThisParam(param)) {
          this.raise(FlowErrors.SetterMayNotHaveThisParam, {
            at: param,
          })
        }
      }
    }
    parsePropertyNamePrefixOperator(node2) {
      node2.variance = this.flowParseVariance()
    }
    parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern2, isAccessor2, refExpressionErrors) {
      if (prop.variance) {
        this.unexpected(prop.variance.loc.start)
      }
      delete prop.variance
      let typeParameters
      if (this.match(47) && !isAccessor2) {
        typeParameters = this.flowParseTypeParameterDeclaration()
        if (!this.match(10)) this.unexpected()
      }
      super.parseObjPropValue(
        prop,
        startPos,
        startLoc,
        isGenerator,
        isAsync,
        isPattern2,
        isAccessor2,
        refExpressionErrors
      )
      if (typeParameters) {
        ;(prop.value || prop).typeParameters = typeParameters
      }
    }
    parseAssignableListItemTypes(param) {
      if (this.eat(17)) {
        if (param.type !== 'Identifier') {
          this.raise(FlowErrors.PatternIsOptional, {
            at: param,
          })
        }
        if (this.isThisParam(param)) {
          this.raise(FlowErrors.ThisParamMayNotBeOptional, {
            at: param,
          })
        }
        param.optional = true
      }
      if (this.match(14)) {
        param.typeAnnotation = this.flowParseTypeAnnotation()
      } else if (this.isThisParam(param)) {
        this.raise(FlowErrors.ThisParamAnnotationRequired, {
          at: param,
        })
      }
      if (this.match(29) && this.isThisParam(param)) {
        this.raise(FlowErrors.ThisParamNoDefault, {
          at: param,
        })
      }
      this.resetEndLocation(param)
      return param
    }
    parseMaybeDefault(startPos, startLoc, left) {
      const node2 = super.parseMaybeDefault(startPos, startLoc, left)
      if (
        node2.type === 'AssignmentPattern' &&
        node2.typeAnnotation &&
        node2.right.start < node2.typeAnnotation.start
      ) {
        this.raise(FlowErrors.TypeBeforeInitializer, {
          at: node2.typeAnnotation,
        })
      }
      return node2
    }
    shouldParseDefaultImport(node2) {
      if (!hasTypeImportKind(node2)) {
        return super.shouldParseDefaultImport(node2)
      }
      return isMaybeDefaultImport(this.state.type)
    }
    parseImportSpecifierLocal(node2, specifier, type) {
      specifier.local = hasTypeImportKind(node2)
        ? this.flowParseRestrictedIdentifier(true, true)
        : this.parseIdentifier()
      node2.specifiers.push(this.finishImportSpecifier(specifier, type))
    }
    maybeParseDefaultImportSpecifier(node2) {
      node2.importKind = 'value'
      let kind = null
      if (this.match(87)) {
        kind = 'typeof'
      } else if (this.isContextual(126)) {
        kind = 'type'
      }
      if (kind) {
        const lh = this.lookahead()
        const { type } = lh
        if (kind === 'type' && type === 55) {
          this.unexpected(null, lh.type)
        }
        if (isMaybeDefaultImport(type) || type === 5 || type === 55) {
          this.next()
          node2.importKind = kind
        }
      }
      return super.maybeParseDefaultImportSpecifier(node2)
    }
    parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly) {
      const firstIdent = specifier.imported
      let specifierTypeKind = null
      if (firstIdent.type === 'Identifier') {
        if (firstIdent.name === 'type') {
          specifierTypeKind = 'type'
        } else if (firstIdent.name === 'typeof') {
          specifierTypeKind = 'typeof'
        }
      }
      let isBinding2 = false
      if (this.isContextual(93) && !this.isLookaheadContextual('as')) {
        const as_ident = this.parseIdentifier(true)
        if (specifierTypeKind !== null && !tokenIsKeywordOrIdentifier(this.state.type)) {
          specifier.imported = as_ident
          specifier.importKind = specifierTypeKind
          specifier.local = cloneIdentifier(as_ident)
        } else {
          specifier.imported = firstIdent
          specifier.importKind = null
          specifier.local = this.parseIdentifier()
        }
      } else {
        if (specifierTypeKind !== null && tokenIsKeywordOrIdentifier(this.state.type)) {
          specifier.imported = this.parseIdentifier(true)
          specifier.importKind = specifierTypeKind
        } else {
          if (importedIsString) {
            throw this.raise(Errors.ImportBindingIsString, {
              at: specifier,
              importName: firstIdent.value,
            })
          }
          specifier.imported = firstIdent
          specifier.importKind = null
        }
        if (this.eatContextual(93)) {
          specifier.local = this.parseIdentifier()
        } else {
          isBinding2 = true
          specifier.local = cloneIdentifier(specifier.imported)
        }
      }
      const specifierIsTypeImport = hasTypeImportKind(specifier)
      if (isInTypeOnlyImport && specifierIsTypeImport) {
        this.raise(FlowErrors.ImportTypeShorthandOnlyInPureImport, {
          at: specifier,
        })
      }
      if (isInTypeOnlyImport || specifierIsTypeImport) {
        this.checkReservedType(specifier.local.name, specifier.local.loc.start, true)
      }
      if (isBinding2 && !isInTypeOnlyImport && !specifierIsTypeImport) {
        this.checkReservedWord(specifier.local.name, specifier.loc.start, true, true)
      }
      return this.finishImportSpecifier(specifier, 'ImportSpecifier')
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 78:
          return this.parseIdentifier(true)
        default:
          return super.parseBindingAtom()
      }
    }
    parseFunctionParams(node2, allowModifiers) {
      const kind = node2.kind
      if (kind !== 'get' && kind !== 'set' && this.match(47)) {
        node2.typeParameters = this.flowParseTypeParameterDeclaration()
      }
      super.parseFunctionParams(node2, allowModifiers)
    }
    parseVarId(decl, kind) {
      super.parseVarId(decl, kind)
      if (this.match(14)) {
        decl.id.typeAnnotation = this.flowParseTypeAnnotation()
        this.resetEndLocation(decl.id)
      }
    }
    parseAsyncArrowFromCallExpression(node2, call2) {
      if (this.match(14)) {
        const oldNoAnonFunctionType = this.state.noAnonFunctionType
        this.state.noAnonFunctionType = true
        node2.returnType = this.flowParseTypeAnnotation()
        this.state.noAnonFunctionType = oldNoAnonFunctionType
      }
      return super.parseAsyncArrowFromCallExpression(node2, call2)
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow()
    }
    parseMaybeAssign(refExpressionErrors, afterLeftParse) {
      var _jsx
      let state = null
      let jsx2
      if (this.hasPlugin('jsx') && (this.match(138) || this.match(47))) {
        state = this.state.clone()
        jsx2 = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state)
        if (!jsx2.error) return jsx2.node
        const { context: context2 } = this.state
        const currentContext = context2[context2.length - 1]
        if (currentContext === types.j_oTag || currentContext === types.j_expr) {
          context2.pop()
        }
      }
      if (((_jsx = jsx2) != null && _jsx.error) || this.match(47)) {
        var _jsx2, _jsx3
        state = state || this.state.clone()
        let typeParameters
        const arrow = this.tryParse((abort) => {
          var _arrowExpression$extr
          typeParameters = this.flowParseTypeParameterDeclaration()
          const arrowExpression2 = this.forwardNoArrowParamsConversionAt(typeParameters, () => {
            const result = super.parseMaybeAssign(refExpressionErrors, afterLeftParse)
            this.resetStartLocationFromNode(result, typeParameters)
            return result
          })
          if ((_arrowExpression$extr = arrowExpression2.extra) != null && _arrowExpression$extr.parenthesized) abort()
          const expr = this.maybeUnwrapTypeCastExpression(arrowExpression2)
          if (expr.type !== 'ArrowFunctionExpression') abort()
          expr.typeParameters = typeParameters
          this.resetStartLocationFromNode(expr, typeParameters)
          return arrowExpression2
        }, state)
        let arrowExpression = null
        if (arrow.node && this.maybeUnwrapTypeCastExpression(arrow.node).type === 'ArrowFunctionExpression') {
          if (!arrow.error && !arrow.aborted) {
            if (arrow.node.async) {
              this.raise(FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction, {
                at: typeParameters,
              })
            }
            return arrow.node
          }
          arrowExpression = arrow.node
        }
        if ((_jsx2 = jsx2) != null && _jsx2.node) {
          this.state = jsx2.failState
          return jsx2.node
        }
        if (arrowExpression) {
          this.state = arrow.failState
          return arrowExpression
        }
        if ((_jsx3 = jsx2) != null && _jsx3.thrown) throw jsx2.error
        if (arrow.thrown) throw arrow.error
        throw this.raise(FlowErrors.UnexpectedTokenAfterTypeParameter, {
          at: typeParameters,
        })
      }
      return super.parseMaybeAssign(refExpressionErrors, afterLeftParse)
    }
    parseArrow(node2) {
      if (this.match(14)) {
        const result = this.tryParse(() => {
          const oldNoAnonFunctionType = this.state.noAnonFunctionType
          this.state.noAnonFunctionType = true
          const typeNode = this.startNode()
          ;[typeNode.typeAnnotation, node2.predicate] = this.flowParseTypeAndPredicateInitialiser()
          this.state.noAnonFunctionType = oldNoAnonFunctionType
          if (this.canInsertSemicolon()) this.unexpected()
          if (!this.match(19)) this.unexpected()
          return typeNode
        })
        if (result.thrown) return null
        if (result.error) this.state = result.failState
        node2.returnType = result.node.typeAnnotation ? this.finishNode(result.node, 'TypeAnnotation') : null
      }
      return super.parseArrow(node2)
    }
    shouldParseArrow(params) {
      return this.match(14) || super.shouldParseArrow(params)
    }
    setArrowFunctionParameters(node2, params) {
      if (this.state.noArrowParamsConversionAt.indexOf(node2.start) !== -1) {
        node2.params = params
      } else {
        super.setArrowFunctionParameters(node2, params)
      }
    }
    checkParams(node2, allowDuplicates, isArrowFunction) {
      if (isArrowFunction && this.state.noArrowParamsConversionAt.indexOf(node2.start) !== -1) {
        return
      }
      for (let i = 0; i < node2.params.length; i++) {
        if (this.isThisParam(node2.params[i]) && i > 0) {
          this.raise(FlowErrors.ThisParamMustBeFirst, {
            at: node2.params[i],
          })
        }
      }
      return super.checkParams(...arguments)
    }
    parseParenAndDistinguishExpression(canBeArrow) {
      return super.parseParenAndDistinguishExpression(
        canBeArrow && this.state.noArrowAt.indexOf(this.state.start) === -1
      )
    }
    parseSubscripts(base2, startPos, startLoc, noCalls) {
      if (base2.type === 'Identifier' && base2.name === 'async' && this.state.noArrowAt.indexOf(startPos) !== -1) {
        this.next()
        const node2 = this.startNodeAt(startPos, startLoc)
        node2.callee = base2
        node2.arguments = this.parseCallExpressionArguments(11, false)
        base2 = this.finishNode(node2, 'CallExpression')
      } else if (base2.type === 'Identifier' && base2.name === 'async' && this.match(47)) {
        const state = this.state.clone()
        const arrow = this.tryParse(
          (abort) => this.parseAsyncArrowWithTypeParameters(startPos, startLoc) || abort(),
          state
        )
        if (!arrow.error && !arrow.aborted) return arrow.node
        const result = this.tryParse(() => super.parseSubscripts(base2, startPos, startLoc, noCalls), state)
        if (result.node && !result.error) return result.node
        if (arrow.node) {
          this.state = arrow.failState
          return arrow.node
        }
        if (result.node) {
          this.state = result.failState
          return result.node
        }
        throw arrow.error || result.error
      }
      return super.parseSubscripts(base2, startPos, startLoc, noCalls)
    }
    parseSubscript(base2, startPos, startLoc, noCalls, subscriptState) {
      if (this.match(18) && this.isLookaheadToken_lt()) {
        subscriptState.optionalChainMember = true
        if (noCalls) {
          subscriptState.stop = true
          return base2
        }
        this.next()
        const node2 = this.startNodeAt(startPos, startLoc)
        node2.callee = base2
        node2.typeArguments = this.flowParseTypeParameterInstantiation()
        this.expect(10)
        node2.arguments = this.parseCallExpressionArguments(11, false)
        node2.optional = true
        return this.finishCallExpression(node2, true)
      } else if (!noCalls && this.shouldParseTypes() && this.match(47)) {
        const node2 = this.startNodeAt(startPos, startLoc)
        node2.callee = base2
        const result = this.tryParse(() => {
          node2.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew()
          this.expect(10)
          node2.arguments = this.parseCallExpressionArguments(11, false)
          if (subscriptState.optionalChainMember) node2.optional = false
          return this.finishCallExpression(node2, subscriptState.optionalChainMember)
        })
        if (result.node) {
          if (result.error) this.state = result.failState
          return result.node
        }
      }
      return super.parseSubscript(base2, startPos, startLoc, noCalls, subscriptState)
    }
    parseNewCallee(node2) {
      super.parseNewCallee(node2)
      let targs = null
      if (this.shouldParseTypes() && this.match(47)) {
        targs = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node
      }
      node2.typeArguments = targs
    }
    parseAsyncArrowWithTypeParameters(startPos, startLoc) {
      const node2 = this.startNodeAt(startPos, startLoc)
      this.parseFunctionParams(node2)
      if (!this.parseArrow(node2)) return
      return this.parseArrowExpression(node2, void 0, true)
    }
    readToken_mult_modulo(code2) {
      const next = this.input.charCodeAt(this.state.pos + 1)
      if (code2 === 42 && next === 47 && this.state.hasFlowComment) {
        this.state.hasFlowComment = false
        this.state.pos += 2
        this.nextToken()
        return
      }
      super.readToken_mult_modulo(code2)
    }
    readToken_pipe_amp(code2) {
      const next = this.input.charCodeAt(this.state.pos + 1)
      if (code2 === 124 && next === 125) {
        this.finishOp(9, 2)
        return
      }
      super.readToken_pipe_amp(code2)
    }
    parseTopLevel(file2, program2) {
      const fileNode = super.parseTopLevel(file2, program2)
      if (this.state.hasFlowComment) {
        this.raise(FlowErrors.UnterminatedFlowComment, {
          at: this.state.curPosition(),
        })
      }
      return fileNode
    }
    skipBlockComment() {
      if (this.hasPlugin('flowComments') && this.skipFlowComment()) {
        if (this.state.hasFlowComment) {
          throw this.raise(FlowErrors.NestedFlowComment, {
            at: this.state.startLoc,
          })
        }
        this.hasFlowCommentCompletion()
        this.state.pos += this.skipFlowComment()
        this.state.hasFlowComment = true
        return
      }
      if (this.state.hasFlowComment) {
        const end = this.input.indexOf('*-/', this.state.pos + 2)
        if (end === -1) {
          throw this.raise(Errors.UnterminatedComment, {
            at: this.state.curPosition(),
          })
        }
        this.state.pos = end + 2 + 3
        return
      }
      return super.skipBlockComment()
    }
    skipFlowComment() {
      const { pos } = this.state
      let shiftToFirstNonWhiteSpace = 2
      while ([32, 9].includes(this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace))) {
        shiftToFirstNonWhiteSpace++
      }
      const ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos)
      const ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1)
      if (ch2 === 58 && ch3 === 58) {
        return shiftToFirstNonWhiteSpace + 2
      }
      if (this.input.slice(shiftToFirstNonWhiteSpace + pos, shiftToFirstNonWhiteSpace + pos + 12) === 'flow-include') {
        return shiftToFirstNonWhiteSpace + 12
      }
      if (ch2 === 58 && ch3 !== 58) {
        return shiftToFirstNonWhiteSpace
      }
      return false
    }
    hasFlowCommentCompletion() {
      const end = this.input.indexOf('*/', this.state.pos)
      if (end === -1) {
        throw this.raise(Errors.UnterminatedComment, {
          at: this.state.curPosition(),
        })
      }
    }
    flowEnumErrorBooleanMemberNotInitialized(loc, { enumName, memberName }) {
      this.raise(FlowErrors.EnumBooleanMemberNotInitialized, {
        at: loc,
        memberName,
        enumName,
      })
    }
    flowEnumErrorInvalidMemberInitializer(loc, enumContext) {
      return this.raise(
        !enumContext.explicitType
          ? FlowErrors.EnumInvalidMemberInitializerUnknownType
          : enumContext.explicitType === 'symbol'
          ? FlowErrors.EnumInvalidMemberInitializerSymbolType
          : FlowErrors.EnumInvalidMemberInitializerPrimaryType,
        Object.assign(
          {
            at: loc,
          },
          enumContext
        )
      )
    }
    flowEnumErrorNumberMemberNotInitialized(loc, { enumName, memberName }) {
      this.raise(FlowErrors.EnumNumberMemberNotInitialized, {
        at: loc,
        enumName,
        memberName,
      })
    }
    flowEnumErrorStringMemberInconsistentlyInitailized(node2, { enumName }) {
      this.raise(FlowErrors.EnumStringMemberInconsistentlyInitailized, {
        at: node2,
        enumName,
      })
    }
    flowEnumMemberInit() {
      const startLoc = this.state.startLoc
      const endOfInit = () => this.match(12) || this.match(8)
      switch (this.state.type) {
        case 130: {
          const literal2 = this.parseNumericLiteral(this.state.value)
          if (endOfInit()) {
            return {
              type: 'number',
              loc: literal2.loc.start,
              value: literal2,
            }
          }
          return {
            type: 'invalid',
            loc: startLoc,
          }
        }
        case 129: {
          const literal2 = this.parseStringLiteral(this.state.value)
          if (endOfInit()) {
            return {
              type: 'string',
              loc: literal2.loc.start,
              value: literal2,
            }
          }
          return {
            type: 'invalid',
            loc: startLoc,
          }
        }
        case 85:
        case 86: {
          const literal2 = this.parseBooleanLiteral(this.match(85))
          if (endOfInit()) {
            return {
              type: 'boolean',
              loc: literal2.loc.start,
              value: literal2,
            }
          }
          return {
            type: 'invalid',
            loc: startLoc,
          }
        }
        default:
          return {
            type: 'invalid',
            loc: startLoc,
          }
      }
    }
    flowEnumMemberRaw() {
      const loc = this.state.startLoc
      const id = this.parseIdentifier(true)
      const init = this.eat(29)
        ? this.flowEnumMemberInit()
        : {
            type: 'none',
            loc,
          }
      return {
        id,
        init,
      }
    }
    flowEnumCheckExplicitTypeMismatch(loc, context2, expectedType) {
      const { explicitType } = context2
      if (explicitType === null) {
        return
      }
      if (explicitType !== expectedType) {
        this.flowEnumErrorInvalidMemberInitializer(loc, context2)
      }
    }
    flowEnumMembers({ enumName, explicitType }) {
      const seenNames = /* @__PURE__ */ new Set()
      const members = {
        booleanMembers: [],
        numberMembers: [],
        stringMembers: [],
        defaultedMembers: [],
      }
      let hasUnknownMembers = false
      while (!this.match(8)) {
        if (this.eat(21)) {
          hasUnknownMembers = true
          break
        }
        const memberNode = this.startNode()
        const { id, init } = this.flowEnumMemberRaw()
        const memberName = id.name
        if (memberName === '') {
          continue
        }
        if (/^[a-z]/.test(memberName)) {
          this.raise(FlowErrors.EnumInvalidMemberName, {
            at: id,
            memberName,
            suggestion: memberName[0].toUpperCase() + memberName.slice(1),
            enumName,
          })
        }
        if (seenNames.has(memberName)) {
          this.raise(FlowErrors.EnumDuplicateMemberName, {
            at: id,
            memberName,
            enumName,
          })
        }
        seenNames.add(memberName)
        const context2 = {
          enumName,
          explicitType,
          memberName,
        }
        memberNode.id = id
        switch (init.type) {
          case 'boolean': {
            this.flowEnumCheckExplicitTypeMismatch(init.loc, context2, 'boolean')
            memberNode.init = init.value
            members.booleanMembers.push(this.finishNode(memberNode, 'EnumBooleanMember'))
            break
          }
          case 'number': {
            this.flowEnumCheckExplicitTypeMismatch(init.loc, context2, 'number')
            memberNode.init = init.value
            members.numberMembers.push(this.finishNode(memberNode, 'EnumNumberMember'))
            break
          }
          case 'string': {
            this.flowEnumCheckExplicitTypeMismatch(init.loc, context2, 'string')
            memberNode.init = init.value
            members.stringMembers.push(this.finishNode(memberNode, 'EnumStringMember'))
            break
          }
          case 'invalid': {
            throw this.flowEnumErrorInvalidMemberInitializer(init.loc, context2)
          }
          case 'none': {
            switch (explicitType) {
              case 'boolean':
                this.flowEnumErrorBooleanMemberNotInitialized(init.loc, context2)
                break
              case 'number':
                this.flowEnumErrorNumberMemberNotInitialized(init.loc, context2)
                break
              default:
                members.defaultedMembers.push(this.finishNode(memberNode, 'EnumDefaultedMember'))
            }
          }
        }
        if (!this.match(8)) {
          this.expect(12)
        }
      }
      return {
        members,
        hasUnknownMembers,
      }
    }
    flowEnumStringMembers(initializedMembers, defaultedMembers, { enumName }) {
      if (initializedMembers.length === 0) {
        return defaultedMembers
      } else if (defaultedMembers.length === 0) {
        return initializedMembers
      } else if (defaultedMembers.length > initializedMembers.length) {
        for (const member of initializedMembers) {
          this.flowEnumErrorStringMemberInconsistentlyInitailized(member, {
            enumName,
          })
        }
        return defaultedMembers
      } else {
        for (const member of defaultedMembers) {
          this.flowEnumErrorStringMemberInconsistentlyInitailized(member, {
            enumName,
          })
        }
        return initializedMembers
      }
    }
    flowEnumParseExplicitType({ enumName }) {
      if (!this.eatContextual(101)) return null
      if (!tokenIsIdentifier(this.state.type)) {
        throw this.raise(FlowErrors.EnumInvalidExplicitTypeUnknownSupplied, {
          at: this.state.startLoc,
          enumName,
        })
      }
      const { value } = this.state
      this.next()
      if (value !== 'boolean' && value !== 'number' && value !== 'string' && value !== 'symbol') {
        this.raise(FlowErrors.EnumInvalidExplicitType, {
          at: this.state.startLoc,
          enumName,
          invalidEnumType: value,
        })
      }
      return value
    }
    flowEnumBody(node2, id) {
      const enumName = id.name
      const nameLoc = id.loc.start
      const explicitType = this.flowEnumParseExplicitType({
        enumName,
      })
      this.expect(5)
      const { members, hasUnknownMembers } = this.flowEnumMembers({
        enumName,
        explicitType,
      })
      node2.hasUnknownMembers = hasUnknownMembers
      switch (explicitType) {
        case 'boolean':
          node2.explicitType = true
          node2.members = members.booleanMembers
          this.expect(8)
          return this.finishNode(node2, 'EnumBooleanBody')
        case 'number':
          node2.explicitType = true
          node2.members = members.numberMembers
          this.expect(8)
          return this.finishNode(node2, 'EnumNumberBody')
        case 'string':
          node2.explicitType = true
          node2.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
            enumName,
          })
          this.expect(8)
          return this.finishNode(node2, 'EnumStringBody')
        case 'symbol':
          node2.members = members.defaultedMembers
          this.expect(8)
          return this.finishNode(node2, 'EnumSymbolBody')
        default: {
          const empty = () => {
            node2.members = []
            this.expect(8)
            return this.finishNode(node2, 'EnumStringBody')
          }
          node2.explicitType = false
          const boolsLen = members.booleanMembers.length
          const numsLen = members.numberMembers.length
          const strsLen = members.stringMembers.length
          const defaultedLen = members.defaultedMembers.length
          if (!boolsLen && !numsLen && !strsLen && !defaultedLen) {
            return empty()
          } else if (!boolsLen && !numsLen) {
            node2.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
              enumName,
            })
            this.expect(8)
            return this.finishNode(node2, 'EnumStringBody')
          } else if (!numsLen && !strsLen && boolsLen >= defaultedLen) {
            for (const member of members.defaultedMembers) {
              this.flowEnumErrorBooleanMemberNotInitialized(member.loc.start, {
                enumName,
                memberName: member.id.name,
              })
            }
            node2.members = members.booleanMembers
            this.expect(8)
            return this.finishNode(node2, 'EnumBooleanBody')
          } else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {
            for (const member of members.defaultedMembers) {
              this.flowEnumErrorNumberMemberNotInitialized(member.loc.start, {
                enumName,
                memberName: member.id.name,
              })
            }
            node2.members = members.numberMembers
            this.expect(8)
            return this.finishNode(node2, 'EnumNumberBody')
          } else {
            this.raise(FlowErrors.EnumInconsistentMemberValues, {
              at: nameLoc,
              enumName,
            })
            return empty()
          }
        }
      }
    }
    flowParseEnumDeclaration(node2) {
      const id = this.parseIdentifier()
      node2.id = id
      node2.body = this.flowEnumBody(this.startNode(), id)
      return this.finishNode(node2, 'EnumDeclaration')
    }
    isLookaheadToken_lt() {
      const next = this.nextTokenStart()
      if (this.input.charCodeAt(next) === 60) {
        const afterNext = this.input.charCodeAt(next + 1)
        return afterNext !== 60 && afterNext !== 61
      }
      return false
    }
    maybeUnwrapTypeCastExpression(node2) {
      return node2.type === 'TypeCastExpression' ? node2.expression : node2
    }
  }
const entities = {
  __proto__: null,
  quot: '"',
  amp: '&',
  apos: "'",
  lt: '<',
  gt: '>',
  nbsp: '\xA0',
  iexcl: '\xA1',
  cent: '\xA2',
  pound: '\xA3',
  curren: '\xA4',
  yen: '\xA5',
  brvbar: '\xA6',
  sect: '\xA7',
  uml: '\xA8',
  copy: '\xA9',
  ordf: '\xAA',
  laquo: '\xAB',
  not: '\xAC',
  shy: '\xAD',
  reg: '\xAE',
  macr: '\xAF',
  deg: '\xB0',
  plusmn: '\xB1',
  sup2: '\xB2',
  sup3: '\xB3',
  acute: '\xB4',
  micro: '\xB5',
  para: '\xB6',
  middot: '\xB7',
  cedil: '\xB8',
  sup1: '\xB9',
  ordm: '\xBA',
  raquo: '\xBB',
  frac14: '\xBC',
  frac12: '\xBD',
  frac34: '\xBE',
  iquest: '\xBF',
  Agrave: '\xC0',
  Aacute: '\xC1',
  Acirc: '\xC2',
  Atilde: '\xC3',
  Auml: '\xC4',
  Aring: '\xC5',
  AElig: '\xC6',
  Ccedil: '\xC7',
  Egrave: '\xC8',
  Eacute: '\xC9',
  Ecirc: '\xCA',
  Euml: '\xCB',
  Igrave: '\xCC',
  Iacute: '\xCD',
  Icirc: '\xCE',
  Iuml: '\xCF',
  ETH: '\xD0',
  Ntilde: '\xD1',
  Ograve: '\xD2',
  Oacute: '\xD3',
  Ocirc: '\xD4',
  Otilde: '\xD5',
  Ouml: '\xD6',
  times: '\xD7',
  Oslash: '\xD8',
  Ugrave: '\xD9',
  Uacute: '\xDA',
  Ucirc: '\xDB',
  Uuml: '\xDC',
  Yacute: '\xDD',
  THORN: '\xDE',
  szlig: '\xDF',
  agrave: '\xE0',
  aacute: '\xE1',
  acirc: '\xE2',
  atilde: '\xE3',
  auml: '\xE4',
  aring: '\xE5',
  aelig: '\xE6',
  ccedil: '\xE7',
  egrave: '\xE8',
  eacute: '\xE9',
  ecirc: '\xEA',
  euml: '\xEB',
  igrave: '\xEC',
  iacute: '\xED',
  icirc: '\xEE',
  iuml: '\xEF',
  eth: '\xF0',
  ntilde: '\xF1',
  ograve: '\xF2',
  oacute: '\xF3',
  ocirc: '\xF4',
  otilde: '\xF5',
  ouml: '\xF6',
  divide: '\xF7',
  oslash: '\xF8',
  ugrave: '\xF9',
  uacute: '\xFA',
  ucirc: '\xFB',
  uuml: '\xFC',
  yacute: '\xFD',
  thorn: '\xFE',
  yuml: '\xFF',
  OElig: '\u0152',
  oelig: '\u0153',
  Scaron: '\u0160',
  scaron: '\u0161',
  Yuml: '\u0178',
  fnof: '\u0192',
  circ: '\u02C6',
  tilde: '\u02DC',
  Alpha: '\u0391',
  Beta: '\u0392',
  Gamma: '\u0393',
  Delta: '\u0394',
  Epsilon: '\u0395',
  Zeta: '\u0396',
  Eta: '\u0397',
  Theta: '\u0398',
  Iota: '\u0399',
  Kappa: '\u039A',
  Lambda: '\u039B',
  Mu: '\u039C',
  Nu: '\u039D',
  Xi: '\u039E',
  Omicron: '\u039F',
  Pi: '\u03A0',
  Rho: '\u03A1',
  Sigma: '\u03A3',
  Tau: '\u03A4',
  Upsilon: '\u03A5',
  Phi: '\u03A6',
  Chi: '\u03A7',
  Psi: '\u03A8',
  Omega: '\u03A9',
  alpha: '\u03B1',
  beta: '\u03B2',
  gamma: '\u03B3',
  delta: '\u03B4',
  epsilon: '\u03B5',
  zeta: '\u03B6',
  eta: '\u03B7',
  theta: '\u03B8',
  iota: '\u03B9',
  kappa: '\u03BA',
  lambda: '\u03BB',
  mu: '\u03BC',
  nu: '\u03BD',
  xi: '\u03BE',
  omicron: '\u03BF',
  pi: '\u03C0',
  rho: '\u03C1',
  sigmaf: '\u03C2',
  sigma: '\u03C3',
  tau: '\u03C4',
  upsilon: '\u03C5',
  phi: '\u03C6',
  chi: '\u03C7',
  psi: '\u03C8',
  omega: '\u03C9',
  thetasym: '\u03D1',
  upsih: '\u03D2',
  piv: '\u03D6',
  ensp: '\u2002',
  emsp: '\u2003',
  thinsp: '\u2009',
  zwnj: '\u200C',
  zwj: '\u200D',
  lrm: '\u200E',
  rlm: '\u200F',
  ndash: '\u2013',
  mdash: '\u2014',
  lsquo: '\u2018',
  rsquo: '\u2019',
  sbquo: '\u201A',
  ldquo: '\u201C',
  rdquo: '\u201D',
  bdquo: '\u201E',
  dagger: '\u2020',
  Dagger: '\u2021',
  bull: '\u2022',
  hellip: '\u2026',
  permil: '\u2030',
  prime: '\u2032',
  Prime: '\u2033',
  lsaquo: '\u2039',
  rsaquo: '\u203A',
  oline: '\u203E',
  frasl: '\u2044',
  euro: '\u20AC',
  image: '\u2111',
  weierp: '\u2118',
  real: '\u211C',
  trade: '\u2122',
  alefsym: '\u2135',
  larr: '\u2190',
  uarr: '\u2191',
  rarr: '\u2192',
  darr: '\u2193',
  harr: '\u2194',
  crarr: '\u21B5',
  lArr: '\u21D0',
  uArr: '\u21D1',
  rArr: '\u21D2',
  dArr: '\u21D3',
  hArr: '\u21D4',
  forall: '\u2200',
  part: '\u2202',
  exist: '\u2203',
  empty: '\u2205',
  nabla: '\u2207',
  isin: '\u2208',
  notin: '\u2209',
  ni: '\u220B',
  prod: '\u220F',
  sum: '\u2211',
  minus: '\u2212',
  lowast: '\u2217',
  radic: '\u221A',
  prop: '\u221D',
  infin: '\u221E',
  ang: '\u2220',
  and: '\u2227',
  or: '\u2228',
  cap: '\u2229',
  cup: '\u222A',
  int: '\u222B',
  there4: '\u2234',
  sim: '\u223C',
  cong: '\u2245',
  asymp: '\u2248',
  ne: '\u2260',
  equiv: '\u2261',
  le: '\u2264',
  ge: '\u2265',
  sub: '\u2282',
  sup: '\u2283',
  nsub: '\u2284',
  sube: '\u2286',
  supe: '\u2287',
  oplus: '\u2295',
  otimes: '\u2297',
  perp: '\u22A5',
  sdot: '\u22C5',
  lceil: '\u2308',
  rceil: '\u2309',
  lfloor: '\u230A',
  rfloor: '\u230B',
  lang: '\u2329',
  rang: '\u232A',
  loz: '\u25CA',
  spades: '\u2660',
  clubs: '\u2663',
  hearts: '\u2665',
  diams: '\u2666',
}
const JsxErrors = ParseErrorEnum`jsx`((_2) => ({
  AttributeIsEmpty: _2('JSX attributes must only be assigned a non-empty expression.'),
  MissingClosingTagElement: _2(
    ({ openingTagName }) => `Expected corresponding JSX closing tag for <${openingTagName}>.`
  ),
  MissingClosingTagFragment: _2('Expected corresponding JSX closing tag for <>.'),
  UnexpectedSequenceExpression: _2(
    'Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?'
  ),
  UnexpectedToken: _2(
    ({ unexpected, HTMLEntity }) =>
      `Unexpected token \`${unexpected}\`. Did you mean \`${HTMLEntity}\` or \`{'${unexpected}'}\`?`
  ),
  UnsupportedJsxValue: _2('JSX value should be either an expression or a quoted JSX text.'),
  UnterminatedJsxContent: _2('Unterminated JSX contents.'),
  UnwrappedAdjacentJSXElements: _2(
    'Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?'
  ),
}))
function isFragment(object2) {
  return object2 ? object2.type === 'JSXOpeningFragment' || object2.type === 'JSXClosingFragment' : false
}
function getQualifiedJSXName(object2) {
  if (object2.type === 'JSXIdentifier') {
    return object2.name
  }
  if (object2.type === 'JSXNamespacedName') {
    return object2.namespace.name + ':' + object2.name.name
  }
  if (object2.type === 'JSXMemberExpression') {
    return getQualifiedJSXName(object2.object) + '.' + getQualifiedJSXName(object2.property)
  }
  throw new Error('Node had unexpected type: ' + object2.type)
}
var jsx = (superClass) =>
  class extends superClass {
    jsxReadToken() {
      let out = ''
      let chunkStart = this.state.pos
      for (;;) {
        if (this.state.pos >= this.length) {
          throw this.raise(JsxErrors.UnterminatedJsxContent, {
            at: this.state.startLoc,
          })
        }
        const ch = this.input.charCodeAt(this.state.pos)
        switch (ch) {
          case 60:
          case 123:
            if (this.state.pos === this.state.start) {
              if (ch === 60 && this.state.canStartJSXElement) {
                ++this.state.pos
                return this.finishToken(138)
              }
              return super.getTokenFromCode(ch)
            }
            out += this.input.slice(chunkStart, this.state.pos)
            return this.finishToken(137, out)
          case 38:
            out += this.input.slice(chunkStart, this.state.pos)
            out += this.jsxReadEntity()
            chunkStart = this.state.pos
            break
          case 62:
          case 125:
          default:
            if (isNewLine(ch)) {
              out += this.input.slice(chunkStart, this.state.pos)
              out += this.jsxReadNewLine(true)
              chunkStart = this.state.pos
            } else {
              ++this.state.pos
            }
        }
      }
    }
    jsxReadNewLine(normalizeCRLF) {
      const ch = this.input.charCodeAt(this.state.pos)
      let out
      ++this.state.pos
      if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {
        ++this.state.pos
        out = normalizeCRLF ? '\n' : '\r\n'
      } else {
        out = String.fromCharCode(ch)
      }
      ++this.state.curLine
      this.state.lineStart = this.state.pos
      return out
    }
    jsxReadString(quote) {
      let out = ''
      let chunkStart = ++this.state.pos
      for (;;) {
        if (this.state.pos >= this.length) {
          throw this.raise(Errors.UnterminatedString, {
            at: this.state.startLoc,
          })
        }
        const ch = this.input.charCodeAt(this.state.pos)
        if (ch === quote) break
        if (ch === 38) {
          out += this.input.slice(chunkStart, this.state.pos)
          out += this.jsxReadEntity()
          chunkStart = this.state.pos
        } else if (isNewLine(ch)) {
          out += this.input.slice(chunkStart, this.state.pos)
          out += this.jsxReadNewLine(false)
          chunkStart = this.state.pos
        } else {
          ++this.state.pos
        }
      }
      out += this.input.slice(chunkStart, this.state.pos++)
      return this.finishToken(129, out)
    }
    jsxReadEntity() {
      const startPos = ++this.state.pos
      if (this.codePointAtPos(this.state.pos) === 35) {
        ++this.state.pos
        let radix = 10
        if (this.codePointAtPos(this.state.pos) === 120) {
          radix = 16
          ++this.state.pos
        }
        const codePoint = this.readInt(radix, void 0, false, 'bail')
        if (codePoint !== null && this.codePointAtPos(this.state.pos) === 59) {
          ++this.state.pos
          return String.fromCodePoint(codePoint)
        }
      } else {
        let count = 0
        let semi = false
        while (count++ < 10 && this.state.pos < this.length && !(semi = this.codePointAtPos(this.state.pos) == 59)) {
          ++this.state.pos
        }
        if (semi) {
          const desc = this.input.slice(startPos, this.state.pos)
          const entity = entities[desc]
          ++this.state.pos
          if (entity) {
            return entity
          }
        }
      }
      this.state.pos = startPos
      return '&'
    }
    jsxReadWord() {
      let ch
      const start = this.state.pos
      do {
        ch = this.input.charCodeAt(++this.state.pos)
      } while (isIdentifierChar(ch) || ch === 45)
      return this.finishToken(136, this.input.slice(start, this.state.pos))
    }
    jsxParseIdentifier() {
      const node2 = this.startNode()
      if (this.match(136)) {
        node2.name = this.state.value
      } else if (tokenIsKeyword(this.state.type)) {
        node2.name = tokenLabelName(this.state.type)
      } else {
        this.unexpected()
      }
      this.next()
      return this.finishNode(node2, 'JSXIdentifier')
    }
    jsxParseNamespacedName() {
      const startPos = this.state.start
      const startLoc = this.state.startLoc
      const name = this.jsxParseIdentifier()
      if (!this.eat(14)) return name
      const node2 = this.startNodeAt(startPos, startLoc)
      node2.namespace = name
      node2.name = this.jsxParseIdentifier()
      return this.finishNode(node2, 'JSXNamespacedName')
    }
    jsxParseElementName() {
      const startPos = this.state.start
      const startLoc = this.state.startLoc
      let node2 = this.jsxParseNamespacedName()
      if (node2.type === 'JSXNamespacedName') {
        return node2
      }
      while (this.eat(16)) {
        const newNode = this.startNodeAt(startPos, startLoc)
        newNode.object = node2
        newNode.property = this.jsxParseIdentifier()
        node2 = this.finishNode(newNode, 'JSXMemberExpression')
      }
      return node2
    }
    jsxParseAttributeValue() {
      let node2
      switch (this.state.type) {
        case 5:
          node2 = this.startNode()
          this.setContext(types.brace)
          this.next()
          node2 = this.jsxParseExpressionContainer(node2, types.j_oTag)
          if (node2.expression.type === 'JSXEmptyExpression') {
            this.raise(JsxErrors.AttributeIsEmpty, {
              at: node2,
            })
          }
          return node2
        case 138:
        case 129:
          return this.parseExprAtom()
        default:
          throw this.raise(JsxErrors.UnsupportedJsxValue, {
            at: this.state.startLoc,
          })
      }
    }
    jsxParseEmptyExpression() {
      const node2 = this.startNodeAt(this.state.lastTokEndLoc.index, this.state.lastTokEndLoc)
      return this.finishNodeAt(node2, 'JSXEmptyExpression', this.state.startLoc)
    }
    jsxParseSpreadChild(node2) {
      this.next()
      node2.expression = this.parseExpression()
      this.setContext(types.j_oTag)
      this.state.canStartJSXElement = true
      this.expect(8)
      return this.finishNode(node2, 'JSXSpreadChild')
    }
    jsxParseExpressionContainer(node2, previousContext) {
      if (this.match(8)) {
        node2.expression = this.jsxParseEmptyExpression()
      } else {
        const expression2 = this.parseExpression()
        node2.expression = expression2
      }
      this.setContext(previousContext)
      this.state.canStartJSXElement = true
      this.expect(8)
      return this.finishNode(node2, 'JSXExpressionContainer')
    }
    jsxParseAttribute() {
      const node2 = this.startNode()
      if (this.match(5)) {
        this.setContext(types.brace)
        this.next()
        this.expect(21)
        node2.argument = this.parseMaybeAssignAllowIn()
        this.setContext(types.j_oTag)
        this.state.canStartJSXElement = true
        this.expect(8)
        return this.finishNode(node2, 'JSXSpreadAttribute')
      }
      node2.name = this.jsxParseNamespacedName()
      node2.value = this.eat(29) ? this.jsxParseAttributeValue() : null
      return this.finishNode(node2, 'JSXAttribute')
    }
    jsxParseOpeningElementAt(startPos, startLoc) {
      const node2 = this.startNodeAt(startPos, startLoc)
      if (this.eat(139)) {
        return this.finishNode(node2, 'JSXOpeningFragment')
      }
      node2.name = this.jsxParseElementName()
      return this.jsxParseOpeningElementAfterName(node2)
    }
    jsxParseOpeningElementAfterName(node2) {
      const attributes = []
      while (!this.match(56) && !this.match(139)) {
        attributes.push(this.jsxParseAttribute())
      }
      node2.attributes = attributes
      node2.selfClosing = this.eat(56)
      this.expect(139)
      return this.finishNode(node2, 'JSXOpeningElement')
    }
    jsxParseClosingElementAt(startPos, startLoc) {
      const node2 = this.startNodeAt(startPos, startLoc)
      if (this.eat(139)) {
        return this.finishNode(node2, 'JSXClosingFragment')
      }
      node2.name = this.jsxParseElementName()
      this.expect(139)
      return this.finishNode(node2, 'JSXClosingElement')
    }
    jsxParseElementAt(startPos, startLoc) {
      const node2 = this.startNodeAt(startPos, startLoc)
      const children = []
      const openingElement = this.jsxParseOpeningElementAt(startPos, startLoc)
      let closingElement = null
      if (!openingElement.selfClosing) {
        contents: for (;;) {
          switch (this.state.type) {
            case 138:
              startPos = this.state.start
              startLoc = this.state.startLoc
              this.next()
              if (this.eat(56)) {
                closingElement = this.jsxParseClosingElementAt(startPos, startLoc)
                break contents
              }
              children.push(this.jsxParseElementAt(startPos, startLoc))
              break
            case 137:
              children.push(this.parseExprAtom())
              break
            case 5: {
              const node3 = this.startNode()
              this.setContext(types.brace)
              this.next()
              if (this.match(21)) {
                children.push(this.jsxParseSpreadChild(node3))
              } else {
                children.push(this.jsxParseExpressionContainer(node3, types.j_expr))
              }
              break
            }
            default:
              throw this.unexpected()
          }
        }
        if (isFragment(openingElement) && !isFragment(closingElement) && closingElement !== null) {
          this.raise(JsxErrors.MissingClosingTagFragment, {
            at: closingElement,
          })
        } else if (!isFragment(openingElement) && isFragment(closingElement)) {
          this.raise(JsxErrors.MissingClosingTagElement, {
            at: closingElement,
            openingTagName: getQualifiedJSXName(openingElement.name),
          })
        } else if (!isFragment(openingElement) && !isFragment(closingElement)) {
          if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
            this.raise(JsxErrors.MissingClosingTagElement, {
              at: closingElement,
              openingTagName: getQualifiedJSXName(openingElement.name),
            })
          }
        }
      }
      if (isFragment(openingElement)) {
        node2.openingFragment = openingElement
        node2.closingFragment = closingElement
      } else {
        node2.openingElement = openingElement
        node2.closingElement = closingElement
      }
      node2.children = children
      if (this.match(47)) {
        throw this.raise(JsxErrors.UnwrappedAdjacentJSXElements, {
          at: this.state.startLoc,
        })
      }
      return isFragment(openingElement) ? this.finishNode(node2, 'JSXFragment') : this.finishNode(node2, 'JSXElement')
    }
    jsxParseElement() {
      const startPos = this.state.start
      const startLoc = this.state.startLoc
      this.next()
      return this.jsxParseElementAt(startPos, startLoc)
    }
    setContext(newContext) {
      const { context: context2 } = this.state
      context2[context2.length - 1] = newContext
    }
    parseExprAtom(refExpressionErrors) {
      if (this.match(137)) {
        return this.parseLiteral(this.state.value, 'JSXText')
      } else if (this.match(138)) {
        return this.jsxParseElement()
      } else if (this.match(47) && this.input.charCodeAt(this.state.pos) !== 33) {
        this.replaceToken(138)
        return this.jsxParseElement()
      } else {
        return super.parseExprAtom(refExpressionErrors)
      }
    }
    skipSpace() {
      const curContext = this.curContext()
      if (!curContext.preserveSpace) super.skipSpace()
    }
    getTokenFromCode(code2) {
      const context2 = this.curContext()
      if (context2 === types.j_expr) {
        return this.jsxReadToken()
      }
      if (context2 === types.j_oTag || context2 === types.j_cTag) {
        if (isIdentifierStart(code2)) {
          return this.jsxReadWord()
        }
        if (code2 === 62) {
          ++this.state.pos
          return this.finishToken(139)
        }
        if ((code2 === 34 || code2 === 39) && context2 === types.j_oTag) {
          return this.jsxReadString(code2)
        }
      }
      if (code2 === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
        ++this.state.pos
        return this.finishToken(138)
      }
      return super.getTokenFromCode(code2)
    }
    updateContext(prevType) {
      const { context: context2, type } = this.state
      if (type === 56 && prevType === 138) {
        context2.splice(-2, 2, types.j_cTag)
        this.state.canStartJSXElement = false
      } else if (type === 138) {
        context2.push(types.j_oTag)
      } else if (type === 139) {
        const out = context2[context2.length - 1]
        if ((out === types.j_oTag && prevType === 56) || out === types.j_cTag) {
          context2.pop()
          this.state.canStartJSXElement = context2[context2.length - 1] === types.j_expr
        } else {
          this.setContext(types.j_expr)
          this.state.canStartJSXElement = true
        }
      } else {
        this.state.canStartJSXElement = tokenComesBeforeExpression(type)
      }
    }
  }
class TypeScriptScope extends Scope {
  constructor(...args) {
    super(...args)
    this.types = /* @__PURE__ */ new Set()
    this.enums = /* @__PURE__ */ new Set()
    this.constEnums = /* @__PURE__ */ new Set()
    this.classes = /* @__PURE__ */ new Set()
    this.exportOnlyBindings = /* @__PURE__ */ new Set()
  }
}
class TypeScriptScopeHandler extends ScopeHandler {
  createScope(flags) {
    return new TypeScriptScope(flags)
  }
  declareName(name, bindingType, loc) {
    const scope2 = this.currentScope()
    if (bindingType & BIND_FLAGS_TS_EXPORT_ONLY) {
      this.maybeExportDefined(scope2, name)
      scope2.exportOnlyBindings.add(name)
      return
    }
    super.declareName(...arguments)
    if (bindingType & BIND_KIND_TYPE) {
      if (!(bindingType & BIND_KIND_VALUE)) {
        this.checkRedeclarationInScope(scope2, name, bindingType, loc)
        this.maybeExportDefined(scope2, name)
      }
      scope2.types.add(name)
    }
    if (bindingType & BIND_FLAGS_TS_ENUM) scope2.enums.add(name)
    if (bindingType & BIND_FLAGS_TS_CONST_ENUM) scope2.constEnums.add(name)
    if (bindingType & BIND_FLAGS_CLASS) scope2.classes.add(name)
  }
  isRedeclaredInScope(scope2, name, bindingType) {
    if (scope2.enums.has(name)) {
      if (bindingType & BIND_FLAGS_TS_ENUM) {
        const isConst = !!(bindingType & BIND_FLAGS_TS_CONST_ENUM)
        const wasConst = scope2.constEnums.has(name)
        return isConst !== wasConst
      }
      return true
    }
    if (bindingType & BIND_FLAGS_CLASS && scope2.classes.has(name)) {
      if (scope2.lexical.has(name)) {
        return !!(bindingType & BIND_KIND_VALUE)
      } else {
        return false
      }
    }
    if (bindingType & BIND_KIND_TYPE && scope2.types.has(name)) {
      return true
    }
    return super.isRedeclaredInScope(...arguments)
  }
  checkLocalExport(id) {
    const topLevelScope = this.scopeStack[0]
    const { name } = id
    if (!topLevelScope.types.has(name) && !topLevelScope.exportOnlyBindings.has(name)) {
      super.checkLocalExport(id)
    }
  }
}
const getOwn$1 = (object2, key) => Object.hasOwnProperty.call(object2, key) && object2[key]
function nonNull(x) {
  if (x == null) {
    throw new Error(`Unexpected ${x} value.`)
  }
  return x
}
function assert(x) {
  if (!x) {
    throw new Error('Assert fail')
  }
}
function tsTokenCanStartExpression(token) {
  return tokenCanStartExpression(token) || tokenIsBinaryOperator(token)
}
const TSErrors = ParseErrorEnum`typescript`((_2) => ({
  AbstractMethodHasImplementation: _2(
    ({ methodName }) => `Method '${methodName}' cannot have an implementation because it is marked abstract.`
  ),
  AbstractPropertyHasInitializer: _2(
    ({ propertyName }) => `Property '${propertyName}' cannot have an initializer because it is marked abstract.`
  ),
  AccesorCannotDeclareThisParameter: _2("'get' and 'set' accessors cannot declare 'this' parameters."),
  AccesorCannotHaveTypeParameters: _2('An accessor cannot have type parameters.'),
  CannotFindName: _2(({ name }) => `Cannot find name '${name}'.`),
  ClassMethodHasDeclare: _2("Class methods cannot have the 'declare' modifier."),
  ClassMethodHasReadonly: _2("Class methods cannot have the 'readonly' modifier."),
  ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: _2(
    "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference."
  ),
  ConstructorHasTypeParameters: _2('Type parameters cannot appear on a constructor declaration.'),
  DeclareAccessor: _2(({ kind }) => `'declare' is not allowed in ${kind}ters.`),
  DeclareClassFieldHasInitializer: _2('Initializers are not allowed in ambient contexts.'),
  DeclareFunctionHasImplementation: _2('An implementation cannot be declared in ambient contexts.'),
  DuplicateAccessibilityModifier: _2(({ modifier }) => `Accessibility modifier already seen.`),
  DuplicateModifier: _2(({ modifier }) => `Duplicate modifier: '${modifier}'.`),
  EmptyHeritageClauseType: _2(({ token }) => `'${token}' list cannot be empty.`),
  EmptyTypeArguments: _2('Type argument list cannot be empty.'),
  EmptyTypeParameters: _2('Type parameter list cannot be empty.'),
  ExpectedAmbientAfterExportDeclare: _2("'export declare' must be followed by an ambient declaration."),
  ImportAliasHasImportType: _2("An import alias can not use 'import type'."),
  IncompatibleModifiers: _2(
    ({ modifiers }) => `'${modifiers[0]}' modifier cannot be used with '${modifiers[1]}' modifier.`
  ),
  IndexSignatureHasAbstract: _2("Index signatures cannot have the 'abstract' modifier."),
  IndexSignatureHasAccessibility: _2(
    ({ modifier }) => `Index signatures cannot have an accessibility modifier ('${modifier}').`
  ),
  IndexSignatureHasDeclare: _2("Index signatures cannot have the 'declare' modifier."),
  IndexSignatureHasOverride: _2("'override' modifier cannot appear on an index signature."),
  IndexSignatureHasStatic: _2("Index signatures cannot have the 'static' modifier."),
  InitializerNotAllowedInAmbientContext: _2('Initializers are not allowed in ambient contexts.'),
  InvalidModifierOnTypeMember: _2(({ modifier }) => `'${modifier}' modifier cannot appear on a type member.`),
  InvalidModifierOnTypeParameter: _2(({ modifier }) => `'${modifier}' modifier cannot appear on a type parameter.`),
  InvalidModifierOnTypeParameterPositions: _2(
    ({ modifier }) => `'${modifier}' modifier can only appear on a type parameter of a class, interface or type alias.`
  ),
  InvalidModifiersOrder: _2(
    ({ orderedModifiers }) => `'${orderedModifiers[0]}' modifier must precede '${orderedModifiers[1]}' modifier.`
  ),
  InvalidTupleMemberLabel: _2('Tuple members must be labeled with a simple identifier.'),
  MissingInterfaceName: _2("'interface' declarations must be followed by an identifier."),
  MixedLabeledAndUnlabeledElements: _2('Tuple members must all have names or all not have names.'),
  NonAbstractClassHasAbstractMethod: _2('Abstract methods can only appear within an abstract class.'),
  NonClassMethodPropertyHasAbstractModifer: _2(
    "'abstract' modifier can only appear on a class, method, or property declaration."
  ),
  OptionalTypeBeforeRequired: _2('A required element cannot follow an optional element.'),
  OverrideNotInSubClass: _2(
    "This member cannot have an 'override' modifier because its containing class does not extend another class."
  ),
  PatternIsOptional: _2('A binding pattern parameter cannot be optional in an implementation signature.'),
  PrivateElementHasAbstract: _2("Private elements cannot have the 'abstract' modifier."),
  PrivateElementHasAccessibility: _2(
    ({ modifier }) => `Private elements cannot have an accessibility modifier ('${modifier}').`
  ),
  ReadonlyForMethodSignature: _2("'readonly' modifier can only appear on a property declaration or index signature."),
  ReservedArrowTypeParam: _2(
    'This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.'
  ),
  ReservedTypeAssertion: _2(
    'This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.'
  ),
  SetAccesorCannotHaveOptionalParameter: _2("A 'set' accessor cannot have an optional parameter."),
  SetAccesorCannotHaveRestParameter: _2("A 'set' accessor cannot have rest parameter."),
  SetAccesorCannotHaveReturnType: _2("A 'set' accessor cannot have a return type annotation."),
  SingleTypeParameterWithoutTrailingComma: _2(
    ({ typeParameterName }) =>
      `Single type parameter ${typeParameterName} should have a trailing comma. Example usage: <${typeParameterName},>.`
  ),
  StaticBlockCannotHaveModifier: _2('Static class blocks cannot have any modifier.'),
  TypeAnnotationAfterAssign: _2(
    'Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.'
  ),
  TypeImportCannotSpecifyDefaultAndNamed: _2(
    'A type-only import can specify a default import or named bindings, but not both.'
  ),
  TypeModifierIsUsedInTypeExports: _2(
    "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement."
  ),
  TypeModifierIsUsedInTypeImports: _2(
    "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement."
  ),
  UnexpectedParameterModifier: _2('A parameter property is only allowed in a constructor implementation.'),
  UnexpectedReadonly: _2("'readonly' type modifier is only permitted on array and tuple literal types."),
  UnexpectedTypeAnnotation: _2('Did not expect a type annotation here.'),
  UnexpectedTypeCastInParameter: _2('Unexpected type cast in parameter position.'),
  UnsupportedImportTypeArgument: _2('Argument in a type import must be a string literal.'),
  UnsupportedParameterPropertyKind: _2('A parameter property may not be declared using a binding pattern.'),
  UnsupportedSignatureParameterKind: _2(
    ({ type }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${type}.`
  ),
}))
function keywordTypeFromName(value) {
  switch (value) {
    case 'any':
      return 'TSAnyKeyword'
    case 'boolean':
      return 'TSBooleanKeyword'
    case 'bigint':
      return 'TSBigIntKeyword'
    case 'never':
      return 'TSNeverKeyword'
    case 'number':
      return 'TSNumberKeyword'
    case 'object':
      return 'TSObjectKeyword'
    case 'string':
      return 'TSStringKeyword'
    case 'symbol':
      return 'TSSymbolKeyword'
    case 'undefined':
      return 'TSUndefinedKeyword'
    case 'unknown':
      return 'TSUnknownKeyword'
    default:
      return void 0
  }
}
function tsIsAccessModifier(modifier) {
  return modifier === 'private' || modifier === 'public' || modifier === 'protected'
}
function tsIsVarianceAnnotations(modifier) {
  return modifier === 'in' || modifier === 'out'
}
var typescript = (superClass) =>
  class extends superClass {
    getScopeHandler() {
      return TypeScriptScopeHandler
    }
    tsIsIdentifier() {
      return tokenIsIdentifier(this.state.type)
    }
    tsTokenCanFollowModifier() {
      return (
        (this.match(0) ||
          this.match(5) ||
          this.match(55) ||
          this.match(21) ||
          this.match(134) ||
          this.isLiteralPropertyName()) &&
        !this.hasPrecedingLineBreak()
      )
    }
    tsNextTokenCanFollowModifier() {
      this.next()
      return this.tsTokenCanFollowModifier()
    }
    tsParseModifier(allowedModifiers, stopOnStartOfClassStaticBlock) {
      if (!tokenIsIdentifier(this.state.type) && this.state.type !== 58) {
        return void 0
      }
      const modifier = this.state.value
      if (allowedModifiers.indexOf(modifier) !== -1) {
        if (stopOnStartOfClassStaticBlock && this.tsIsStartOfStaticBlocks()) {
          return void 0
        }
        if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {
          return modifier
        }
      }
      return void 0
    }
    tsParseModifiers({
      modified,
      allowedModifiers,
      disallowedModifiers,
      stopOnStartOfClassStaticBlock,
      errorTemplate = TSErrors.InvalidModifierOnTypeMember,
    }) {
      const enforceOrder = (loc, modifier, before, after) => {
        if (modifier === before && modified[after]) {
          this.raise(TSErrors.InvalidModifiersOrder, {
            at: loc,
            orderedModifiers: [before, after],
          })
        }
      }
      const incompatible = (loc, modifier, mod1, mod2) => {
        if ((modified[mod1] && modifier === mod2) || (modified[mod2] && modifier === mod1)) {
          this.raise(TSErrors.IncompatibleModifiers, {
            at: loc,
            modifiers: [mod1, mod2],
          })
        }
      }
      for (;;) {
        const { startLoc } = this.state
        const modifier = this.tsParseModifier(
          allowedModifiers.concat(disallowedModifiers != null ? disallowedModifiers : []),
          stopOnStartOfClassStaticBlock
        )
        if (!modifier) break
        if (tsIsAccessModifier(modifier)) {
          if (modified.accessibility) {
            this.raise(TSErrors.DuplicateAccessibilityModifier, {
              at: startLoc,
              modifier,
            })
          } else {
            enforceOrder(startLoc, modifier, modifier, 'override')
            enforceOrder(startLoc, modifier, modifier, 'static')
            enforceOrder(startLoc, modifier, modifier, 'readonly')
            modified.accessibility = modifier
          }
        } else if (tsIsVarianceAnnotations(modifier)) {
          if (modified[modifier]) {
            this.raise(TSErrors.DuplicateModifier, {
              at: startLoc,
              modifier,
            })
          }
          modified[modifier] = true
          enforceOrder(startLoc, modifier, 'in', 'out')
        } else {
          if (Object.hasOwnProperty.call(modified, modifier)) {
            this.raise(TSErrors.DuplicateModifier, {
              at: startLoc,
              modifier,
            })
          } else {
            enforceOrder(startLoc, modifier, 'static', 'readonly')
            enforceOrder(startLoc, modifier, 'static', 'override')
            enforceOrder(startLoc, modifier, 'override', 'readonly')
            enforceOrder(startLoc, modifier, 'abstract', 'override')
            incompatible(startLoc, modifier, 'declare', 'override')
            incompatible(startLoc, modifier, 'static', 'abstract')
          }
          modified[modifier] = true
        }
        if (disallowedModifiers != null && disallowedModifiers.includes(modifier)) {
          this.raise(errorTemplate, {
            at: startLoc,
            modifier,
          })
        }
      }
    }
    tsIsListTerminator(kind) {
      switch (kind) {
        case 'EnumMembers':
        case 'TypeMembers':
          return this.match(8)
        case 'HeritageClauseElement':
          return this.match(5)
        case 'TupleElementTypes':
          return this.match(3)
        case 'TypeParametersOrArguments':
          return this.match(48)
      }
      throw new Error('Unreachable')
    }
    tsParseList(kind, parseElement) {
      const result = []
      while (!this.tsIsListTerminator(kind)) {
        result.push(parseElement())
      }
      return result
    }
    tsParseDelimitedList(kind, parseElement, refTrailingCommaPos) {
      return nonNull(this.tsParseDelimitedListWorker(kind, parseElement, true, refTrailingCommaPos))
    }
    tsParseDelimitedListWorker(kind, parseElement, expectSuccess, refTrailingCommaPos) {
      const result = []
      let trailingCommaPos = -1
      for (;;) {
        if (this.tsIsListTerminator(kind)) {
          break
        }
        trailingCommaPos = -1
        const element = parseElement()
        if (element == null) {
          return void 0
        }
        result.push(element)
        if (this.eat(12)) {
          trailingCommaPos = this.state.lastTokStart
          continue
        }
        if (this.tsIsListTerminator(kind)) {
          break
        }
        if (expectSuccess) {
          this.expect(12)
        }
        return void 0
      }
      if (refTrailingCommaPos) {
        refTrailingCommaPos.value = trailingCommaPos
      }
      return result
    }
    tsParseBracketedList(kind, parseElement, bracket, skipFirstToken, refTrailingCommaPos) {
      if (!skipFirstToken) {
        if (bracket) {
          this.expect(0)
        } else {
          this.expect(47)
        }
      }
      const result = this.tsParseDelimitedList(kind, parseElement, refTrailingCommaPos)
      if (bracket) {
        this.expect(3)
      } else {
        this.expect(48)
      }
      return result
    }
    tsParseImportType() {
      const node2 = this.startNode()
      this.expect(83)
      this.expect(10)
      if (!this.match(129)) {
        this.raise(TSErrors.UnsupportedImportTypeArgument, {
          at: this.state.startLoc,
        })
      }
      node2.argument = this.parseExprAtom()
      this.expect(11)
      if (this.eat(16)) {
        node2.qualifier = this.tsParseEntityName()
      }
      if (this.match(47)) {
        node2.typeParameters = this.tsParseTypeArguments()
      }
      return this.finishNode(node2, 'TSImportType')
    }
    tsParseEntityName(allowReservedWords = true) {
      let entity = this.parseIdentifier(allowReservedWords)
      while (this.eat(16)) {
        const node2 = this.startNodeAtNode(entity)
        node2.left = entity
        node2.right = this.parseIdentifier(allowReservedWords)
        entity = this.finishNode(node2, 'TSQualifiedName')
      }
      return entity
    }
    tsParseTypeReference() {
      const node2 = this.startNode()
      node2.typeName = this.tsParseEntityName()
      if (!this.hasPrecedingLineBreak() && this.match(47)) {
        node2.typeParameters = this.tsParseTypeArguments()
      }
      return this.finishNode(node2, 'TSTypeReference')
    }
    tsParseThisTypePredicate(lhs) {
      this.next()
      const node2 = this.startNodeAtNode(lhs)
      node2.parameterName = lhs
      node2.typeAnnotation = this.tsParseTypeAnnotation(false)
      node2.asserts = false
      return this.finishNode(node2, 'TSTypePredicate')
    }
    tsParseThisTypeNode() {
      const node2 = this.startNode()
      this.next()
      return this.finishNode(node2, 'TSThisType')
    }
    tsParseTypeQuery() {
      const node2 = this.startNode()
      this.expect(87)
      if (this.match(83)) {
        node2.exprName = this.tsParseImportType()
      } else {
        node2.exprName = this.tsParseEntityName()
      }
      if (!this.hasPrecedingLineBreak() && this.match(47)) {
        node2.typeParameters = this.tsParseTypeArguments()
      }
      return this.finishNode(node2, 'TSTypeQuery')
    }
    tsParseInOutModifiers(node2) {
      this.tsParseModifiers({
        modified: node2,
        allowedModifiers: ['in', 'out'],
        disallowedModifiers: ['public', 'private', 'protected', 'readonly', 'declare', 'abstract', 'override'],
        errorTemplate: TSErrors.InvalidModifierOnTypeParameter,
      })
    }
    tsParseNoneModifiers(node2) {
      this.tsParseModifiers({
        modified: node2,
        allowedModifiers: [],
        disallowedModifiers: ['in', 'out'],
        errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions,
      })
    }
    tsParseTypeParameter(parseModifiers = this.tsParseNoneModifiers.bind(this)) {
      const node2 = this.startNode()
      parseModifiers(node2)
      node2.name = this.tsParseTypeParameterName()
      node2.constraint = this.tsEatThenParseType(81)
      node2.default = this.tsEatThenParseType(29)
      return this.finishNode(node2, 'TSTypeParameter')
    }
    tsTryParseTypeParameters(parseModifiers) {
      if (this.match(47)) {
        return this.tsParseTypeParameters(parseModifiers)
      }
    }
    tsParseTypeParameters(parseModifiers) {
      const node2 = this.startNode()
      if (this.match(47) || this.match(138)) {
        this.next()
      } else {
        this.unexpected()
      }
      const refTrailingCommaPos = {
        value: -1,
      }
      node2.params = this.tsParseBracketedList(
        'TypeParametersOrArguments',
        this.tsParseTypeParameter.bind(this, parseModifiers),
        false,
        true,
        refTrailingCommaPos
      )
      if (node2.params.length === 0) {
        this.raise(TSErrors.EmptyTypeParameters, {
          at: node2,
        })
      }
      if (refTrailingCommaPos.value !== -1) {
        this.addExtra(node2, 'trailingComma', refTrailingCommaPos.value)
      }
      return this.finishNode(node2, 'TSTypeParameterDeclaration')
    }
    tsTryNextParseConstantContext() {
      if (this.lookahead().type !== 75) return null
      this.next()
      const typeReference = this.tsParseTypeReference()
      if (typeReference.typeParameters) {
        this.raise(TSErrors.CannotFindName, {
          at: typeReference.typeName,
          name: 'const',
        })
      }
      return typeReference
    }
    tsFillSignature(returnToken, signature) {
      const returnTokenRequired = returnToken === 19
      const paramsKey = 'parameters'
      const returnTypeKey = 'typeAnnotation'
      signature.typeParameters = this.tsTryParseTypeParameters()
      this.expect(10)
      signature[paramsKey] = this.tsParseBindingListForSignature()
      if (returnTokenRequired) {
        signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken)
      } else if (this.match(returnToken)) {
        signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken)
      }
    }
    tsParseBindingListForSignature() {
      return this.parseBindingList(11, 41).map((pattern) => {
        if (
          pattern.type !== 'Identifier' &&
          pattern.type !== 'RestElement' &&
          pattern.type !== 'ObjectPattern' &&
          pattern.type !== 'ArrayPattern'
        ) {
          this.raise(TSErrors.UnsupportedSignatureParameterKind, {
            at: pattern,
            type: pattern.type,
          })
        }
        return pattern
      })
    }
    tsParseTypeMemberSemicolon() {
      if (!this.eat(12) && !this.isLineTerminator()) {
        this.expect(13)
      }
    }
    tsParseSignatureMember(kind, node2) {
      this.tsFillSignature(14, node2)
      this.tsParseTypeMemberSemicolon()
      return this.finishNode(node2, kind)
    }
    tsIsUnambiguouslyIndexSignature() {
      this.next()
      if (tokenIsIdentifier(this.state.type)) {
        this.next()
        return this.match(14)
      }
      return false
    }
    tsTryParseIndexSignature(node2) {
      if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) {
        return void 0
      }
      this.expect(0)
      const id = this.parseIdentifier()
      id.typeAnnotation = this.tsParseTypeAnnotation()
      this.resetEndLocation(id)
      this.expect(3)
      node2.parameters = [id]
      const type = this.tsTryParseTypeAnnotation()
      if (type) node2.typeAnnotation = type
      this.tsParseTypeMemberSemicolon()
      return this.finishNode(node2, 'TSIndexSignature')
    }
    tsParsePropertyOrMethodSignature(node2, readonly) {
      if (this.eat(17)) node2.optional = true
      const nodeAny = node2
      if (this.match(10) || this.match(47)) {
        if (readonly) {
          this.raise(TSErrors.ReadonlyForMethodSignature, {
            at: node2,
          })
        }
        const method = nodeAny
        if (method.kind && this.match(47)) {
          this.raise(TSErrors.AccesorCannotHaveTypeParameters, {
            at: this.state.curPosition(),
          })
        }
        this.tsFillSignature(14, method)
        this.tsParseTypeMemberSemicolon()
        const paramsKey = 'parameters'
        const returnTypeKey = 'typeAnnotation'
        if (method.kind === 'get') {
          if (method[paramsKey].length > 0) {
            this.raise(Errors.BadGetterArity, {
              at: this.state.curPosition(),
            })
            if (this.isThisParam(method[paramsKey][0])) {
              this.raise(TSErrors.AccesorCannotDeclareThisParameter, {
                at: this.state.curPosition(),
              })
            }
          }
        } else if (method.kind === 'set') {
          if (method[paramsKey].length !== 1) {
            this.raise(Errors.BadSetterArity, {
              at: this.state.curPosition(),
            })
          } else {
            const firstParameter = method[paramsKey][0]
            if (this.isThisParam(firstParameter)) {
              this.raise(TSErrors.AccesorCannotDeclareThisParameter, {
                at: this.state.curPosition(),
              })
            }
            if (firstParameter.type === 'Identifier' && firstParameter.optional) {
              this.raise(TSErrors.SetAccesorCannotHaveOptionalParameter, {
                at: this.state.curPosition(),
              })
            }
            if (firstParameter.type === 'RestElement') {
              this.raise(TSErrors.SetAccesorCannotHaveRestParameter, {
                at: this.state.curPosition(),
              })
            }
          }
          if (method[returnTypeKey]) {
            this.raise(TSErrors.SetAccesorCannotHaveReturnType, {
              at: method[returnTypeKey],
            })
          }
        } else {
          method.kind = 'method'
        }
        return this.finishNode(method, 'TSMethodSignature')
      } else {
        const property = nodeAny
        if (readonly) property.readonly = true
        const type = this.tsTryParseTypeAnnotation()
        if (type) property.typeAnnotation = type
        this.tsParseTypeMemberSemicolon()
        return this.finishNode(property, 'TSPropertySignature')
      }
    }
    tsParseTypeMember() {
      const node2 = this.startNode()
      if (this.match(10) || this.match(47)) {
        return this.tsParseSignatureMember('TSCallSignatureDeclaration', node2)
      }
      if (this.match(77)) {
        const id = this.startNode()
        this.next()
        if (this.match(10) || this.match(47)) {
          return this.tsParseSignatureMember('TSConstructSignatureDeclaration', node2)
        } else {
          node2.key = this.createIdentifier(id, 'new')
          return this.tsParsePropertyOrMethodSignature(node2, false)
        }
      }
      this.tsParseModifiers({
        modified: node2,
        allowedModifiers: ['readonly'],
        disallowedModifiers: ['declare', 'abstract', 'private', 'protected', 'public', 'static', 'override'],
      })
      const idx = this.tsTryParseIndexSignature(node2)
      if (idx) {
        return idx
      }
      this.parsePropertyName(node2)
      if (
        !node2.computed &&
        node2.key.type === 'Identifier' &&
        (node2.key.name === 'get' || node2.key.name === 'set') &&
        this.tsTokenCanFollowModifier()
      ) {
        node2.kind = node2.key.name
        this.parsePropertyName(node2)
      }
      return this.tsParsePropertyOrMethodSignature(node2, !!node2.readonly)
    }
    tsParseTypeLiteral() {
      const node2 = this.startNode()
      node2.members = this.tsParseObjectTypeMembers()
      return this.finishNode(node2, 'TSTypeLiteral')
    }
    tsParseObjectTypeMembers() {
      this.expect(5)
      const members = this.tsParseList('TypeMembers', this.tsParseTypeMember.bind(this))
      this.expect(8)
      return members
    }
    tsIsStartOfMappedType() {
      this.next()
      if (this.eat(53)) {
        return this.isContextual(118)
      }
      if (this.isContextual(118)) {
        this.next()
      }
      if (!this.match(0)) {
        return false
      }
      this.next()
      if (!this.tsIsIdentifier()) {
        return false
      }
      this.next()
      return this.match(58)
    }
    tsParseMappedTypeParameter() {
      const node2 = this.startNode()
      node2.name = this.tsParseTypeParameterName()
      node2.constraint = this.tsExpectThenParseType(58)
      return this.finishNode(node2, 'TSTypeParameter')
    }
    tsParseMappedType() {
      const node2 = this.startNode()
      this.expect(5)
      if (this.match(53)) {
        node2.readonly = this.state.value
        this.next()
        this.expectContextual(118)
      } else if (this.eatContextual(118)) {
        node2.readonly = true
      }
      this.expect(0)
      node2.typeParameter = this.tsParseMappedTypeParameter()
      node2.nameType = this.eatContextual(93) ? this.tsParseType() : null
      this.expect(3)
      if (this.match(53)) {
        node2.optional = this.state.value
        this.next()
        this.expect(17)
      } else if (this.eat(17)) {
        node2.optional = true
      }
      node2.typeAnnotation = this.tsTryParseType()
      this.semicolon()
      this.expect(8)
      return this.finishNode(node2, 'TSMappedType')
    }
    tsParseTupleType() {
      const node2 = this.startNode()
      node2.elementTypes = this.tsParseBracketedList(
        'TupleElementTypes',
        this.tsParseTupleElementType.bind(this),
        true,
        false
      )
      let seenOptionalElement = false
      let labeledElements = null
      node2.elementTypes.forEach((elementNode) => {
        var _labeledElements
        let { type } = elementNode
        if (
          seenOptionalElement &&
          type !== 'TSRestType' &&
          type !== 'TSOptionalType' &&
          !(type === 'TSNamedTupleMember' && elementNode.optional)
        ) {
          this.raise(TSErrors.OptionalTypeBeforeRequired, {
            at: elementNode,
          })
        }
        seenOptionalElement =
          seenOptionalElement || (type === 'TSNamedTupleMember' && elementNode.optional) || type === 'TSOptionalType'
        if (type === 'TSRestType') {
          elementNode = elementNode.typeAnnotation
          type = elementNode.type
        }
        const isLabeled = type === 'TSNamedTupleMember'
        labeledElements = (_labeledElements = labeledElements) != null ? _labeledElements : isLabeled
        if (labeledElements !== isLabeled) {
          this.raise(TSErrors.MixedLabeledAndUnlabeledElements, {
            at: elementNode,
          })
        }
      })
      return this.finishNode(node2, 'TSTupleType')
    }
    tsParseTupleElementType() {
      const { start: startPos, startLoc } = this.state
      const rest = this.eat(21)
      let type = this.tsParseType()
      const optional = this.eat(17)
      const labeled = this.eat(14)
      if (labeled) {
        const labeledNode = this.startNodeAtNode(type)
        labeledNode.optional = optional
        if (type.type === 'TSTypeReference' && !type.typeParameters && type.typeName.type === 'Identifier') {
          labeledNode.label = type.typeName
        } else {
          this.raise(TSErrors.InvalidTupleMemberLabel, {
            at: type,
          })
          labeledNode.label = type
        }
        labeledNode.elementType = this.tsParseType()
        type = this.finishNode(labeledNode, 'TSNamedTupleMember')
      } else if (optional) {
        const optionalTypeNode = this.startNodeAtNode(type)
        optionalTypeNode.typeAnnotation = type
        type = this.finishNode(optionalTypeNode, 'TSOptionalType')
      }
      if (rest) {
        const restNode = this.startNodeAt(startPos, startLoc)
        restNode.typeAnnotation = type
        type = this.finishNode(restNode, 'TSRestType')
      }
      return type
    }
    tsParseParenthesizedType() {
      const node2 = this.startNode()
      this.expect(10)
      node2.typeAnnotation = this.tsParseType()
      this.expect(11)
      return this.finishNode(node2, 'TSParenthesizedType')
    }
    tsParseFunctionOrConstructorType(type, abstract) {
      const node2 = this.startNode()
      if (type === 'TSConstructorType') {
        node2.abstract = !!abstract
        if (abstract) this.next()
        this.next()
      }
      this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, node2))
      return this.finishNode(node2, type)
    }
    tsParseLiteralTypeNode() {
      const node2 = this.startNode()
      node2.literal = (() => {
        switch (this.state.type) {
          case 130:
          case 131:
          case 129:
          case 85:
          case 86:
            return this.parseExprAtom()
          default:
            throw this.unexpected()
        }
      })()
      return this.finishNode(node2, 'TSLiteralType')
    }
    tsParseTemplateLiteralType() {
      const node2 = this.startNode()
      node2.literal = this.parseTemplate(false)
      return this.finishNode(node2, 'TSLiteralType')
    }
    parseTemplateSubstitution() {
      if (this.state.inType) return this.tsParseType()
      return super.parseTemplateSubstitution()
    }
    tsParseThisTypeOrThisTypePredicate() {
      const thisKeyword = this.tsParseThisTypeNode()
      if (this.isContextual(113) && !this.hasPrecedingLineBreak()) {
        return this.tsParseThisTypePredicate(thisKeyword)
      } else {
        return thisKeyword
      }
    }
    tsParseNonArrayType() {
      switch (this.state.type) {
        case 129:
        case 130:
        case 131:
        case 85:
        case 86:
          return this.tsParseLiteralTypeNode()
        case 53:
          if (this.state.value === '-') {
            const node2 = this.startNode()
            const nextToken = this.lookahead()
            if (nextToken.type !== 130 && nextToken.type !== 131) {
              throw this.unexpected()
            }
            node2.literal = this.parseMaybeUnary()
            return this.finishNode(node2, 'TSLiteralType')
          }
          break
        case 78:
          return this.tsParseThisTypeOrThisTypePredicate()
        case 87:
          return this.tsParseTypeQuery()
        case 83:
          return this.tsParseImportType()
        case 5:
          return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this))
            ? this.tsParseMappedType()
            : this.tsParseTypeLiteral()
        case 0:
          return this.tsParseTupleType()
        case 10:
          return this.tsParseParenthesizedType()
        case 25:
        case 24:
          return this.tsParseTemplateLiteralType()
        default: {
          const { type } = this.state
          if (tokenIsIdentifier(type) || type === 88 || type === 84) {
            const nodeType =
              type === 88 ? 'TSVoidKeyword' : type === 84 ? 'TSNullKeyword' : keywordTypeFromName(this.state.value)
            if (nodeType !== void 0 && this.lookaheadCharCode() !== 46) {
              const node2 = this.startNode()
              this.next()
              return this.finishNode(node2, nodeType)
            }
            return this.tsParseTypeReference()
          }
        }
      }
      throw this.unexpected()
    }
    tsParseArrayTypeOrHigher() {
      let type = this.tsParseNonArrayType()
      while (!this.hasPrecedingLineBreak() && this.eat(0)) {
        if (this.match(3)) {
          const node2 = this.startNodeAtNode(type)
          node2.elementType = type
          this.expect(3)
          type = this.finishNode(node2, 'TSArrayType')
        } else {
          const node2 = this.startNodeAtNode(type)
          node2.objectType = type
          node2.indexType = this.tsParseType()
          this.expect(3)
          type = this.finishNode(node2, 'TSIndexedAccessType')
        }
      }
      return type
    }
    tsParseTypeOperator() {
      const node2 = this.startNode()
      const operator = this.state.value
      this.next()
      node2.operator = operator
      node2.typeAnnotation = this.tsParseTypeOperatorOrHigher()
      if (operator === 'readonly') {
        this.tsCheckTypeAnnotationForReadOnly(node2)
      }
      return this.finishNode(node2, 'TSTypeOperator')
    }
    tsCheckTypeAnnotationForReadOnly(node2) {
      switch (node2.typeAnnotation.type) {
        case 'TSTupleType':
        case 'TSArrayType':
          return
        default:
          this.raise(TSErrors.UnexpectedReadonly, {
            at: node2,
          })
      }
    }
    tsParseInferType() {
      const node2 = this.startNode()
      this.expectContextual(112)
      const typeParameter2 = this.startNode()
      typeParameter2.name = this.tsParseTypeParameterName()
      typeParameter2.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType())
      node2.typeParameter = this.finishNode(typeParameter2, 'TSTypeParameter')
      return this.finishNode(node2, 'TSInferType')
    }
    tsParseConstraintForInferType() {
      if (this.eat(81)) {
        const constraint = this.tsInDisallowConditionalTypesContext(() => this.tsParseType())
        if (this.state.inDisallowConditionalTypesContext || !this.match(17)) {
          return constraint
        }
      }
    }
    tsParseTypeOperatorOrHigher() {
      const isTypeOperator = tokenIsTSTypeOperator(this.state.type) && !this.state.containsEsc
      return isTypeOperator
        ? this.tsParseTypeOperator()
        : this.isContextual(112)
        ? this.tsParseInferType()
        : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher())
    }
    tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {
      const node2 = this.startNode()
      const hasLeadingOperator = this.eat(operator)
      const types2 = []
      do {
        types2.push(parseConstituentType())
      } while (this.eat(operator))
      if (types2.length === 1 && !hasLeadingOperator) {
        return types2[0]
      }
      node2.types = types2
      return this.finishNode(node2, kind)
    }
    tsParseIntersectionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType('TSIntersectionType', this.tsParseTypeOperatorOrHigher.bind(this), 45)
    }
    tsParseUnionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType('TSUnionType', this.tsParseIntersectionTypeOrHigher.bind(this), 43)
    }
    tsIsStartOfFunctionType() {
      if (this.match(47)) {
        return true
      }
      return this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this))
    }
    tsSkipParameterStart() {
      if (tokenIsIdentifier(this.state.type) || this.match(78)) {
        this.next()
        return true
      }
      if (this.match(5)) {
        const { errors } = this.state
        const previousErrorCount = errors.length
        try {
          this.parseObjectLike(8, true)
          return errors.length === previousErrorCount
        } catch (_unused) {
          return false
        }
      }
      if (this.match(0)) {
        this.next()
        const { errors } = this.state
        const previousErrorCount = errors.length
        try {
          this.parseBindingList(3, 93, true)
          return errors.length === previousErrorCount
        } catch (_unused2) {
          return false
        }
      }
      return false
    }
    tsIsUnambiguouslyStartOfFunctionType() {
      this.next()
      if (this.match(11) || this.match(21)) {
        return true
      }
      if (this.tsSkipParameterStart()) {
        if (this.match(14) || this.match(12) || this.match(17) || this.match(29)) {
          return true
        }
        if (this.match(11)) {
          this.next()
          if (this.match(19)) {
            return true
          }
        }
      }
      return false
    }
    tsParseTypeOrTypePredicateAnnotation(returnToken) {
      return this.tsInType(() => {
        const t2 = this.startNode()
        this.expect(returnToken)
        const node2 = this.startNode()
        const asserts = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this))
        if (asserts && this.match(78)) {
          let thisTypePredicate = this.tsParseThisTypeOrThisTypePredicate()
          if (thisTypePredicate.type === 'TSThisType') {
            node2.parameterName = thisTypePredicate
            node2.asserts = true
            node2.typeAnnotation = null
            thisTypePredicate = this.finishNode(node2, 'TSTypePredicate')
          } else {
            this.resetStartLocationFromNode(thisTypePredicate, node2)
            thisTypePredicate.asserts = true
          }
          t2.typeAnnotation = thisTypePredicate
          return this.finishNode(t2, 'TSTypeAnnotation')
        }
        const typePredicateVariable =
          this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this))
        if (!typePredicateVariable) {
          if (!asserts) {
            return this.tsParseTypeAnnotation(false, t2)
          }
          node2.parameterName = this.parseIdentifier()
          node2.asserts = asserts
          node2.typeAnnotation = null
          t2.typeAnnotation = this.finishNode(node2, 'TSTypePredicate')
          return this.finishNode(t2, 'TSTypeAnnotation')
        }
        const type = this.tsParseTypeAnnotation(false)
        node2.parameterName = typePredicateVariable
        node2.typeAnnotation = type
        node2.asserts = asserts
        t2.typeAnnotation = this.finishNode(node2, 'TSTypePredicate')
        return this.finishNode(t2, 'TSTypeAnnotation')
      })
    }
    tsTryParseTypeOrTypePredicateAnnotation() {
      return this.match(14) ? this.tsParseTypeOrTypePredicateAnnotation(14) : void 0
    }
    tsTryParseTypeAnnotation() {
      return this.match(14) ? this.tsParseTypeAnnotation() : void 0
    }
    tsTryParseType() {
      return this.tsEatThenParseType(14)
    }
    tsParseTypePredicatePrefix() {
      const id = this.parseIdentifier()
      if (this.isContextual(113) && !this.hasPrecedingLineBreak()) {
        this.next()
        return id
      }
    }
    tsParseTypePredicateAsserts() {
      if (this.state.type !== 106) {
        return false
      }
      const containsEsc = this.state.containsEsc
      this.next()
      if (!tokenIsIdentifier(this.state.type) && !this.match(78)) {
        return false
      }
      if (containsEsc) {
        this.raise(Errors.InvalidEscapedReservedWord, {
          at: this.state.lastTokStartLoc,
          reservedWord: 'asserts',
        })
      }
      return true
    }
    tsParseTypeAnnotation(eatColon = true, t2 = this.startNode()) {
      this.tsInType(() => {
        if (eatColon) this.expect(14)
        t2.typeAnnotation = this.tsParseType()
      })
      return this.finishNode(t2, 'TSTypeAnnotation')
    }
    tsParseType() {
      assert(this.state.inType)
      const type = this.tsParseNonConditionalType()
      if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81)) {
        return type
      }
      const node2 = this.startNodeAtNode(type)
      node2.checkType = type
      node2.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType())
      this.expect(17)
      node2.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType())
      this.expect(14)
      node2.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType())
      return this.finishNode(node2, 'TSConditionalType')
    }
    isAbstractConstructorSignature() {
      return this.isContextual(120) && this.lookahead().type === 77
    }
    tsParseNonConditionalType() {
      if (this.tsIsStartOfFunctionType()) {
        return this.tsParseFunctionOrConstructorType('TSFunctionType')
      }
      if (this.match(77)) {
        return this.tsParseFunctionOrConstructorType('TSConstructorType')
      } else if (this.isAbstractConstructorSignature()) {
        return this.tsParseFunctionOrConstructorType('TSConstructorType', true)
      }
      return this.tsParseUnionTypeOrHigher()
    }
    tsParseTypeAssertion() {
      if (this.getPluginOption('typescript', 'disallowAmbiguousJSXLike')) {
        this.raise(TSErrors.ReservedTypeAssertion, {
          at: this.state.startLoc,
        })
      }
      const node2 = this.startNode()
      const _const = this.tsTryNextParseConstantContext()
      node2.typeAnnotation = _const || this.tsNextThenParseType()
      this.expect(48)
      node2.expression = this.parseMaybeUnary()
      return this.finishNode(node2, 'TSTypeAssertion')
    }
    tsParseHeritageClause(token) {
      const originalStartLoc = this.state.startLoc
      const delimitedList = this.tsParseDelimitedList('HeritageClauseElement', () => {
        const node2 = this.startNode()
        node2.expression = this.tsParseEntityName()
        if (this.match(47)) {
          node2.typeParameters = this.tsParseTypeArguments()
        }
        return this.finishNode(node2, 'TSExpressionWithTypeArguments')
      })
      if (!delimitedList.length) {
        this.raise(TSErrors.EmptyHeritageClauseType, {
          at: originalStartLoc,
          token,
        })
      }
      return delimitedList
    }
    tsParseInterfaceDeclaration(node2, properties = {}) {
      if (this.hasFollowingLineBreak()) return null
      this.expectContextual(125)
      if (properties.declare) node2.declare = true
      if (tokenIsIdentifier(this.state.type)) {
        node2.id = this.parseIdentifier()
        this.checkIdentifier(node2.id, BIND_TS_INTERFACE)
      } else {
        node2.id = null
        this.raise(TSErrors.MissingInterfaceName, {
          at: this.state.startLoc,
        })
      }
      node2.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this))
      if (this.eat(81)) {
        node2.extends = this.tsParseHeritageClause('extends')
      }
      const body = this.startNode()
      body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this))
      node2.body = this.finishNode(body, 'TSInterfaceBody')
      return this.finishNode(node2, 'TSInterfaceDeclaration')
    }
    tsParseTypeAliasDeclaration(node2) {
      node2.id = this.parseIdentifier()
      this.checkIdentifier(node2.id, BIND_TS_TYPE)
      node2.typeAnnotation = this.tsInType(() => {
        node2.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this))
        this.expect(29)
        if (this.isContextual(111) && this.lookahead().type !== 16) {
          const node3 = this.startNode()
          this.next()
          return this.finishNode(node3, 'TSIntrinsicKeyword')
        }
        return this.tsParseType()
      })
      this.semicolon()
      return this.finishNode(node2, 'TSTypeAliasDeclaration')
    }
    tsInNoContext(cb) {
      const oldContext = this.state.context
      this.state.context = [oldContext[0]]
      try {
        return cb()
      } finally {
        this.state.context = oldContext
      }
    }
    tsInType(cb) {
      const oldInType = this.state.inType
      this.state.inType = true
      try {
        return cb()
      } finally {
        this.state.inType = oldInType
      }
    }
    tsInDisallowConditionalTypesContext(cb) {
      const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext
      this.state.inDisallowConditionalTypesContext = true
      try {
        return cb()
      } finally {
        this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext
      }
    }
    tsInAllowConditionalTypesContext(cb) {
      const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext
      this.state.inDisallowConditionalTypesContext = false
      try {
        return cb()
      } finally {
        this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext
      }
    }
    tsEatThenParseType(token) {
      return !this.match(token) ? void 0 : this.tsNextThenParseType()
    }
    tsExpectThenParseType(token) {
      return this.tsDoThenParseType(() => this.expect(token))
    }
    tsNextThenParseType() {
      return this.tsDoThenParseType(() => this.next())
    }
    tsDoThenParseType(cb) {
      return this.tsInType(() => {
        cb()
        return this.tsParseType()
      })
    }
    tsParseEnumMember() {
      const node2 = this.startNode()
      node2.id = this.match(129) ? this.parseExprAtom() : this.parseIdentifier(true)
      if (this.eat(29)) {
        node2.initializer = this.parseMaybeAssignAllowIn()
      }
      return this.finishNode(node2, 'TSEnumMember')
    }
    tsParseEnumDeclaration(node2, properties = {}) {
      if (properties.const) node2.const = true
      if (properties.declare) node2.declare = true
      this.expectContextual(122)
      node2.id = this.parseIdentifier()
      this.checkIdentifier(node2.id, node2.const ? BIND_TS_CONST_ENUM : BIND_TS_ENUM)
      this.expect(5)
      node2.members = this.tsParseDelimitedList('EnumMembers', this.tsParseEnumMember.bind(this))
      this.expect(8)
      return this.finishNode(node2, 'TSEnumDeclaration')
    }
    tsParseModuleBlock() {
      const node2 = this.startNode()
      this.scope.enter(SCOPE_OTHER)
      this.expect(5)
      this.parseBlockOrModuleBlockBody((node2.body = []), void 0, true, 8)
      this.scope.exit()
      return this.finishNode(node2, 'TSModuleBlock')
    }
    tsParseModuleOrNamespaceDeclaration(node2, nested = false) {
      node2.id = this.parseIdentifier()
      if (!nested) {
        this.checkIdentifier(node2.id, BIND_TS_NAMESPACE)
      }
      if (this.eat(16)) {
        const inner = this.startNode()
        this.tsParseModuleOrNamespaceDeclaration(inner, true)
        node2.body = inner
      } else {
        this.scope.enter(SCOPE_TS_MODULE)
        this.prodParam.enter(PARAM)
        node2.body = this.tsParseModuleBlock()
        this.prodParam.exit()
        this.scope.exit()
      }
      return this.finishNode(node2, 'TSModuleDeclaration')
    }
    tsParseAmbientExternalModuleDeclaration(node2) {
      if (this.isContextual(109)) {
        node2.global = true
        node2.id = this.parseIdentifier()
      } else if (this.match(129)) {
        node2.id = this.parseExprAtom()
      } else {
        this.unexpected()
      }
      if (this.match(5)) {
        this.scope.enter(SCOPE_TS_MODULE)
        this.prodParam.enter(PARAM)
        node2.body = this.tsParseModuleBlock()
        this.prodParam.exit()
        this.scope.exit()
      } else {
        this.semicolon()
      }
      return this.finishNode(node2, 'TSModuleDeclaration')
    }
    tsParseImportEqualsDeclaration(node2, isExport) {
      node2.isExport = isExport || false
      node2.id = this.parseIdentifier()
      this.checkIdentifier(node2.id, BIND_LEXICAL)
      this.expect(29)
      const moduleReference = this.tsParseModuleReference()
      if (node2.importKind === 'type' && moduleReference.type !== 'TSExternalModuleReference') {
        this.raise(TSErrors.ImportAliasHasImportType, {
          at: moduleReference,
        })
      }
      node2.moduleReference = moduleReference
      this.semicolon()
      return this.finishNode(node2, 'TSImportEqualsDeclaration')
    }
    tsIsExternalModuleReference() {
      return this.isContextual(116) && this.lookaheadCharCode() === 40
    }
    tsParseModuleReference() {
      return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false)
    }
    tsParseExternalModuleReference() {
      const node2 = this.startNode()
      this.expectContextual(116)
      this.expect(10)
      if (!this.match(129)) {
        throw this.unexpected()
      }
      node2.expression = this.parseExprAtom()
      this.expect(11)
      return this.finishNode(node2, 'TSExternalModuleReference')
    }
    tsLookAhead(f) {
      const state = this.state.clone()
      const res = f()
      this.state = state
      return res
    }
    tsTryParseAndCatch(f) {
      const result = this.tryParse((abort) => f() || abort())
      if (result.aborted || !result.node) return void 0
      if (result.error) this.state = result.failState
      return result.node
    }
    tsTryParse(f) {
      const state = this.state.clone()
      const result = f()
      if (result !== void 0 && result !== false) {
        return result
      } else {
        this.state = state
        return void 0
      }
    }
    tsTryParseDeclare(nany) {
      if (this.isLineTerminator()) {
        return
      }
      let starttype = this.state.type
      let kind
      if (this.isContextual(99)) {
        starttype = 74
        kind = 'let'
      }
      return this.tsInAmbientContext(() => {
        if (starttype === 68) {
          nany.declare = true
          return this.parseFunctionStatement(nany, false, true)
        }
        if (starttype === 80) {
          nany.declare = true
          return this.parseClass(nany, true, false)
        }
        if (starttype === 122) {
          return this.tsParseEnumDeclaration(nany, {
            declare: true,
          })
        }
        if (starttype === 109) {
          return this.tsParseAmbientExternalModuleDeclaration(nany)
        }
        if (starttype === 75 || starttype === 74) {
          if (!this.match(75) || !this.isLookaheadContextual('enum')) {
            nany.declare = true
            return this.parseVarStatement(nany, kind || this.state.value, true)
          }
          this.expect(75)
          return this.tsParseEnumDeclaration(nany, {
            const: true,
            declare: true,
          })
        }
        if (starttype === 125) {
          const result = this.tsParseInterfaceDeclaration(nany, {
            declare: true,
          })
          if (result) return result
        }
        if (tokenIsIdentifier(starttype)) {
          return this.tsParseDeclaration(nany, this.state.value, true)
        }
      })
    }
    tsTryParseExportDeclaration() {
      return this.tsParseDeclaration(this.startNode(), this.state.value, true)
    }
    tsParseExpressionStatement(node2, expr) {
      switch (expr.name) {
        case 'declare': {
          const declaration = this.tsTryParseDeclare(node2)
          if (declaration) {
            declaration.declare = true
            return declaration
          }
          break
        }
        case 'global':
          if (this.match(5)) {
            this.scope.enter(SCOPE_TS_MODULE)
            this.prodParam.enter(PARAM)
            const mod2 = node2
            mod2.global = true
            mod2.id = expr
            mod2.body = this.tsParseModuleBlock()
            this.scope.exit()
            this.prodParam.exit()
            return this.finishNode(mod2, 'TSModuleDeclaration')
          }
          break
        default:
          return this.tsParseDeclaration(node2, expr.name, false)
      }
    }
    tsParseDeclaration(node2, value, next) {
      switch (value) {
        case 'abstract':
          if (this.tsCheckLineTerminator(next) && (this.match(80) || tokenIsIdentifier(this.state.type))) {
            return this.tsParseAbstractDeclaration(node2)
          }
          break
        case 'module':
          if (this.tsCheckLineTerminator(next)) {
            if (this.match(129)) {
              return this.tsParseAmbientExternalModuleDeclaration(node2)
            } else if (tokenIsIdentifier(this.state.type)) {
              return this.tsParseModuleOrNamespaceDeclaration(node2)
            }
          }
          break
        case 'namespace':
          if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {
            return this.tsParseModuleOrNamespaceDeclaration(node2)
          }
          break
        case 'type':
          if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {
            return this.tsParseTypeAliasDeclaration(node2)
          }
          break
      }
    }
    tsCheckLineTerminator(next) {
      if (next) {
        if (this.hasFollowingLineBreak()) return false
        this.next()
        return true
      }
      return !this.isLineTerminator()
    }
    tsTryParseGenericAsyncArrowFunction(startPos, startLoc) {
      if (!this.match(47)) {
        return void 0
      }
      const oldMaybeInArrowParameters = this.state.maybeInArrowParameters
      this.state.maybeInArrowParameters = true
      const res = this.tsTryParseAndCatch(() => {
        const node2 = this.startNodeAt(startPos, startLoc)
        node2.typeParameters = this.tsParseTypeParameters()
        super.parseFunctionParams(node2)
        node2.returnType = this.tsTryParseTypeOrTypePredicateAnnotation()
        this.expect(19)
        return node2
      })
      this.state.maybeInArrowParameters = oldMaybeInArrowParameters
      if (!res) {
        return void 0
      }
      return this.parseArrowExpression(res, null, true)
    }
    tsParseTypeArgumentsInExpression() {
      if (this.reScan_lt() !== 47) {
        return void 0
      }
      return this.tsParseTypeArguments()
    }
    tsParseTypeArguments() {
      const node2 = this.startNode()
      node2.params = this.tsInType(() =>
        this.tsInNoContext(() => {
          this.expect(47)
          return this.tsParseDelimitedList('TypeParametersOrArguments', this.tsParseType.bind(this))
        })
      )
      if (node2.params.length === 0) {
        this.raise(TSErrors.EmptyTypeArguments, {
          at: node2,
        })
      }
      this.expect(48)
      return this.finishNode(node2, 'TSTypeParameterInstantiation')
    }
    tsIsDeclarationStart() {
      return tokenIsTSDeclarationStart(this.state.type)
    }
    isExportDefaultSpecifier() {
      if (this.tsIsDeclarationStart()) return false
      return super.isExportDefaultSpecifier()
    }
    parseAssignableListItem(allowModifiers, decorators) {
      const startPos = this.state.start
      const startLoc = this.state.startLoc
      let accessibility
      let readonly = false
      let override = false
      if (allowModifiers !== void 0) {
        const modified = {}
        this.tsParseModifiers({
          modified,
          allowedModifiers: ['public', 'private', 'protected', 'override', 'readonly'],
        })
        accessibility = modified.accessibility
        override = modified.override
        readonly = modified.readonly
        if (allowModifiers === false && (accessibility || readonly || override)) {
          this.raise(TSErrors.UnexpectedParameterModifier, {
            at: startLoc,
          })
        }
      }
      const left = this.parseMaybeDefault()
      this.parseAssignableListItemTypes(left)
      const elt = this.parseMaybeDefault(left.start, left.loc.start, left)
      if (accessibility || readonly || override) {
        const pp = this.startNodeAt(startPos, startLoc)
        if (decorators.length) {
          pp.decorators = decorators
        }
        if (accessibility) pp.accessibility = accessibility
        if (readonly) pp.readonly = readonly
        if (override) pp.override = override
        if (elt.type !== 'Identifier' && elt.type !== 'AssignmentPattern') {
          this.raise(TSErrors.UnsupportedParameterPropertyKind, {
            at: pp,
          })
        }
        pp.parameter = elt
        return this.finishNode(pp, 'TSParameterProperty')
      }
      if (decorators.length) {
        left.decorators = decorators
      }
      return elt
    }
    isSimpleParameter(node2) {
      return (
        (node2.type === 'TSParameterProperty' && super.isSimpleParameter(node2.parameter)) ||
        super.isSimpleParameter(node2)
      )
    }
    parseFunctionBodyAndFinish(node2, type, isMethod2 = false) {
      if (this.match(14)) {
        node2.returnType = this.tsParseTypeOrTypePredicateAnnotation(14)
      }
      const bodilessType =
        type === 'FunctionDeclaration'
          ? 'TSDeclareFunction'
          : type === 'ClassMethod' || type === 'ClassPrivateMethod'
          ? 'TSDeclareMethod'
          : void 0
      if (bodilessType && !this.match(5) && this.isLineTerminator()) {
        this.finishNode(node2, bodilessType)
        return
      }
      if (bodilessType === 'TSDeclareFunction' && this.state.isAmbientContext) {
        this.raise(TSErrors.DeclareFunctionHasImplementation, {
          at: node2,
        })
        if (node2.declare) {
          super.parseFunctionBodyAndFinish(node2, bodilessType, isMethod2)
          return
        }
      }
      super.parseFunctionBodyAndFinish(node2, type, isMethod2)
    }
    registerFunctionStatementId(node2) {
      if (!node2.body && node2.id) {
        this.checkIdentifier(node2.id, BIND_TS_AMBIENT)
      } else {
        super.registerFunctionStatementId(...arguments)
      }
    }
    tsCheckForInvalidTypeCasts(items) {
      items.forEach((node2) => {
        if ((node2 == null ? void 0 : node2.type) === 'TSTypeCastExpression') {
          this.raise(TSErrors.UnexpectedTypeAnnotation, {
            at: node2.typeAnnotation,
          })
        }
      })
    }
    toReferencedList(exprList, isInParens) {
      this.tsCheckForInvalidTypeCasts(exprList)
      return exprList
    }
    parseArrayLike(...args) {
      const node2 = super.parseArrayLike(...args)
      if (node2.type === 'ArrayExpression') {
        this.tsCheckForInvalidTypeCasts(node2.elements)
      }
      return node2
    }
    parseSubscript(base2, startPos, startLoc, noCalls, state) {
      if (!this.hasPrecedingLineBreak() && this.match(35)) {
        this.state.canStartJSXElement = false
        this.next()
        const nonNullExpression = this.startNodeAt(startPos, startLoc)
        nonNullExpression.expression = base2
        return this.finishNode(nonNullExpression, 'TSNonNullExpression')
      }
      let isOptionalCall = false
      if (this.match(18) && this.lookaheadCharCode() === 60) {
        if (noCalls) {
          state.stop = true
          return base2
        }
        state.optionalChainMember = isOptionalCall = true
        this.next()
      }
      if (this.match(47) || this.match(51)) {
        let missingParenErrorLoc
        const result = this.tsTryParseAndCatch(() => {
          if (!noCalls && this.atPossibleAsyncArrow(base2)) {
            const asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(startPos, startLoc)
            if (asyncArrowFn) {
              return asyncArrowFn
            }
          }
          const typeArguments = this.tsParseTypeArgumentsInExpression()
          if (!typeArguments) throw this.unexpected()
          if (isOptionalCall && !this.match(10)) {
            missingParenErrorLoc = this.state.curPosition()
            throw this.unexpected()
          }
          if (tokenIsTemplate(this.state.type)) {
            const result2 = this.parseTaggedTemplateExpression(base2, startPos, startLoc, state)
            result2.typeParameters = typeArguments
            return result2
          }
          if (!noCalls && this.eat(10)) {
            const node3 = this.startNodeAt(startPos, startLoc)
            node3.callee = base2
            node3.arguments = this.parseCallExpressionArguments(11, false)
            this.tsCheckForInvalidTypeCasts(node3.arguments)
            node3.typeParameters = typeArguments
            if (state.optionalChainMember) {
              node3.optional = isOptionalCall
            }
            return this.finishCallExpression(node3, state.optionalChainMember)
          }
          if (tsTokenCanStartExpression(this.state.type) && this.state.type !== 10) {
            throw this.unexpected()
          }
          const node2 = this.startNodeAt(startPos, startLoc)
          node2.expression = base2
          node2.typeParameters = typeArguments
          return this.finishNode(node2, 'TSInstantiationExpression')
        })
        if (missingParenErrorLoc) {
          this.unexpected(missingParenErrorLoc, 10)
        }
        if (result) return result
      }
      return super.parseSubscript(base2, startPos, startLoc, noCalls, state)
    }
    parseNewCallee(node2) {
      var _callee$extra
      super.parseNewCallee(node2)
      const { callee } = node2
      if (
        callee.type === 'TSInstantiationExpression' &&
        !((_callee$extra = callee.extra) != null && _callee$extra.parenthesized)
      ) {
        node2.typeParameters = callee.typeParameters
        node2.callee = callee.expression
      }
    }
    parseExprOp(left, leftStartPos, leftStartLoc, minPrec) {
      if (tokenOperatorPrecedence(58) > minPrec && !this.hasPrecedingLineBreak() && this.isContextual(93)) {
        const node2 = this.startNodeAt(leftStartPos, leftStartLoc)
        node2.expression = left
        const _const = this.tsTryNextParseConstantContext()
        if (_const) {
          node2.typeAnnotation = _const
        } else {
          node2.typeAnnotation = this.tsNextThenParseType()
        }
        this.finishNode(node2, 'TSAsExpression')
        this.reScan_lt_gt()
        return this.parseExprOp(node2, leftStartPos, leftStartLoc, minPrec)
      }
      return super.parseExprOp(left, leftStartPos, leftStartLoc, minPrec)
    }
    checkReservedWord(word, startLoc, checkKeywords, isBinding2) {
      if (!this.state.isAmbientContext) {
        super.checkReservedWord(word, startLoc, checkKeywords, isBinding2)
      }
    }
    checkDuplicateExports() {}
    parseImport(node2) {
      node2.importKind = 'value'
      if (tokenIsIdentifier(this.state.type) || this.match(55) || this.match(5)) {
        let ahead = this.lookahead()
        if (this.isContextual(126) && ahead.type !== 12 && ahead.type !== 97 && ahead.type !== 29) {
          node2.importKind = 'type'
          this.next()
          ahead = this.lookahead()
        }
        if (tokenIsIdentifier(this.state.type) && ahead.type === 29) {
          return this.tsParseImportEqualsDeclaration(node2)
        }
      }
      const importNode = super.parseImport(node2)
      if (
        importNode.importKind === 'type' &&
        importNode.specifiers.length > 1 &&
        importNode.specifiers[0].type === 'ImportDefaultSpecifier'
      ) {
        this.raise(TSErrors.TypeImportCannotSpecifyDefaultAndNamed, {
          at: importNode,
        })
      }
      return importNode
    }
    parseExport(node2) {
      if (this.match(83)) {
        this.next()
        if (this.isContextual(126) && this.lookaheadCharCode() !== 61) {
          node2.importKind = 'type'
          this.next()
        } else {
          node2.importKind = 'value'
        }
        return this.tsParseImportEqualsDeclaration(node2, true)
      } else if (this.eat(29)) {
        const assign = node2
        assign.expression = this.parseExpression()
        this.semicolon()
        return this.finishNode(assign, 'TSExportAssignment')
      } else if (this.eatContextual(93)) {
        const decl = node2
        this.expectContextual(124)
        decl.id = this.parseIdentifier()
        this.semicolon()
        return this.finishNode(decl, 'TSNamespaceExportDeclaration')
      } else {
        if (this.isContextual(126) && this.lookahead().type === 5) {
          this.next()
          node2.exportKind = 'type'
        } else {
          node2.exportKind = 'value'
        }
        return super.parseExport(node2)
      }
    }
    isAbstractClass() {
      return this.isContextual(120) && this.lookahead().type === 80
    }
    parseExportDefaultExpression() {
      if (this.isAbstractClass()) {
        const cls = this.startNode()
        this.next()
        cls.abstract = true
        this.parseClass(cls, true, true)
        return cls
      }
      if (this.match(125)) {
        const result = this.tsParseInterfaceDeclaration(this.startNode())
        if (result) return result
      }
      return super.parseExportDefaultExpression()
    }
    parseVarStatement(node2, kind, allowMissingInitializer = false) {
      const { isAmbientContext } = this.state
      const declaration = super.parseVarStatement(node2, kind, allowMissingInitializer || isAmbientContext)
      if (!isAmbientContext) return declaration
      for (const { id, init } of declaration.declarations) {
        if (!init) continue
        if (kind !== 'const' || !!id.typeAnnotation) {
          this.raise(TSErrors.InitializerNotAllowedInAmbientContext, {
            at: init,
          })
        } else if (
          init.type !== 'StringLiteral' &&
          init.type !== 'BooleanLiteral' &&
          init.type !== 'NumericLiteral' &&
          init.type !== 'BigIntLiteral' &&
          (init.type !== 'TemplateLiteral' || init.expressions.length > 0) &&
          !isPossiblyLiteralEnum(init)
        ) {
          this.raise(TSErrors.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference, {
            at: init,
          })
        }
      }
      return declaration
    }
    parseStatementContent(context2, topLevel) {
      if (this.match(75) && this.isLookaheadContextual('enum')) {
        const node2 = this.startNode()
        this.expect(75)
        return this.tsParseEnumDeclaration(node2, {
          const: true,
        })
      }
      if (this.isContextual(122)) {
        return this.tsParseEnumDeclaration(this.startNode())
      }
      if (this.isContextual(125)) {
        const result = this.tsParseInterfaceDeclaration(this.startNode())
        if (result) return result
      }
      return super.parseStatementContent(context2, topLevel)
    }
    parseAccessModifier() {
      return this.tsParseModifier(['public', 'protected', 'private'])
    }
    tsHasSomeModifiers(member, modifiers) {
      return modifiers.some((modifier) => {
        if (tsIsAccessModifier(modifier)) {
          return member.accessibility === modifier
        }
        return !!member[modifier]
      })
    }
    tsIsStartOfStaticBlocks() {
      return this.isContextual(104) && this.lookaheadCharCode() === 123
    }
    parseClassMember(classBody2, member, state) {
      const modifiers = ['declare', 'private', 'public', 'protected', 'override', 'abstract', 'readonly', 'static']
      this.tsParseModifiers({
        modified: member,
        allowedModifiers: modifiers,
        disallowedModifiers: ['in', 'out'],
        stopOnStartOfClassStaticBlock: true,
        errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions,
      })
      const callParseClassMemberWithIsStatic = () => {
        if (this.tsIsStartOfStaticBlocks()) {
          this.next()
          this.next()
          if (this.tsHasSomeModifiers(member, modifiers)) {
            this.raise(TSErrors.StaticBlockCannotHaveModifier, {
              at: this.state.curPosition(),
            })
          }
          this.parseClassStaticBlock(classBody2, member)
        } else {
          this.parseClassMemberWithIsStatic(classBody2, member, state, !!member.static)
        }
      }
      if (member.declare) {
        this.tsInAmbientContext(callParseClassMemberWithIsStatic)
      } else {
        callParseClassMemberWithIsStatic()
      }
    }
    parseClassMemberWithIsStatic(classBody2, member, state, isStatic2) {
      const idx = this.tsTryParseIndexSignature(member)
      if (idx) {
        classBody2.body.push(idx)
        if (member.abstract) {
          this.raise(TSErrors.IndexSignatureHasAbstract, {
            at: member,
          })
        }
        if (member.accessibility) {
          this.raise(TSErrors.IndexSignatureHasAccessibility, {
            at: member,
            modifier: member.accessibility,
          })
        }
        if (member.declare) {
          this.raise(TSErrors.IndexSignatureHasDeclare, {
            at: member,
          })
        }
        if (member.override) {
          this.raise(TSErrors.IndexSignatureHasOverride, {
            at: member,
          })
        }
        return
      }
      if (!this.state.inAbstractClass && member.abstract) {
        this.raise(TSErrors.NonAbstractClassHasAbstractMethod, {
          at: member,
        })
      }
      if (member.override) {
        if (!state.hadSuperClass) {
          this.raise(TSErrors.OverrideNotInSubClass, {
            at: member,
          })
        }
      }
      super.parseClassMemberWithIsStatic(classBody2, member, state, isStatic2)
    }
    parsePostMemberNameModifiers(methodOrProp) {
      const optional = this.eat(17)
      if (optional) methodOrProp.optional = true
      if (methodOrProp.readonly && this.match(10)) {
        this.raise(TSErrors.ClassMethodHasReadonly, {
          at: methodOrProp,
        })
      }
      if (methodOrProp.declare && this.match(10)) {
        this.raise(TSErrors.ClassMethodHasDeclare, {
          at: methodOrProp,
        })
      }
    }
    parseExpressionStatement(node2, expr) {
      const decl = expr.type === 'Identifier' ? this.tsParseExpressionStatement(node2, expr) : void 0
      return decl || super.parseExpressionStatement(node2, expr)
    }
    shouldParseExportDeclaration() {
      if (this.tsIsDeclarationStart()) return true
      return super.shouldParseExportDeclaration()
    }
    parseConditional(expr, startPos, startLoc, refExpressionErrors) {
      if (!this.state.maybeInArrowParameters || !this.match(17)) {
        return super.parseConditional(expr, startPos, startLoc, refExpressionErrors)
      }
      const result = this.tryParse(() => super.parseConditional(expr, startPos, startLoc))
      if (!result.node) {
        if (result.error) {
          super.setOptionalParametersError(refExpressionErrors, result.error)
        }
        return expr
      }
      if (result.error) this.state = result.failState
      return result.node
    }
    parseParenItem(node2, startPos, startLoc) {
      node2 = super.parseParenItem(node2, startPos, startLoc)
      if (this.eat(17)) {
        node2.optional = true
        this.resetEndLocation(node2)
      }
      if (this.match(14)) {
        const typeCastNode = this.startNodeAt(startPos, startLoc)
        typeCastNode.expression = node2
        typeCastNode.typeAnnotation = this.tsParseTypeAnnotation()
        return this.finishNode(typeCastNode, 'TSTypeCastExpression')
      }
      return node2
    }
    parseExportDeclaration(node2) {
      if (!this.state.isAmbientContext && this.isContextual(121)) {
        return this.tsInAmbientContext(() => this.parseExportDeclaration(node2))
      }
      const startPos = this.state.start
      const startLoc = this.state.startLoc
      const isDeclare = this.eatContextual(121)
      if (isDeclare && (this.isContextual(121) || !this.shouldParseExportDeclaration())) {
        throw this.raise(TSErrors.ExpectedAmbientAfterExportDeclare, {
          at: this.state.startLoc,
        })
      }
      const isIdentifier2 = tokenIsIdentifier(this.state.type)
      const declaration = (isIdentifier2 && this.tsTryParseExportDeclaration()) || super.parseExportDeclaration(node2)
      if (!declaration) return null
      if (declaration.type === 'TSInterfaceDeclaration' || declaration.type === 'TSTypeAliasDeclaration' || isDeclare) {
        node2.exportKind = 'type'
      }
      if (isDeclare) {
        this.resetStartLocation(declaration, startPos, startLoc)
        declaration.declare = true
      }
      return declaration
    }
    parseClassId(node2, isStatement2, optionalId) {
      if ((!isStatement2 || optionalId) && this.isContextual(110)) {
        return
      }
      super.parseClassId(node2, isStatement2, optionalId, node2.declare ? BIND_TS_AMBIENT : BIND_CLASS)
      const typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this))
      if (typeParameters) node2.typeParameters = typeParameters
    }
    parseClassPropertyAnnotation(node2) {
      if (!node2.optional && this.eat(35)) {
        node2.definite = true
      }
      const type = this.tsTryParseTypeAnnotation()
      if (type) node2.typeAnnotation = type
    }
    parseClassProperty(node2) {
      this.parseClassPropertyAnnotation(node2)
      if (this.state.isAmbientContext && this.match(29)) {
        this.raise(TSErrors.DeclareClassFieldHasInitializer, {
          at: this.state.startLoc,
        })
      }
      if (node2.abstract && this.match(29)) {
        const { key } = node2
        this.raise(TSErrors.AbstractPropertyHasInitializer, {
          at: this.state.startLoc,
          propertyName:
            key.type === 'Identifier' && !node2.computed ? key.name : `[${this.input.slice(key.start, key.end)}]`,
        })
      }
      return super.parseClassProperty(node2)
    }
    parseClassPrivateProperty(node2) {
      if (node2.abstract) {
        this.raise(TSErrors.PrivateElementHasAbstract, {
          at: node2,
        })
      }
      if (node2.accessibility) {
        this.raise(TSErrors.PrivateElementHasAccessibility, {
          at: node2,
          modifier: node2.accessibility,
        })
      }
      this.parseClassPropertyAnnotation(node2)
      return super.parseClassPrivateProperty(node2)
    }
    pushClassMethod(classBody2, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
      const typeParameters = this.tsTryParseTypeParameters()
      if (typeParameters && isConstructor) {
        this.raise(TSErrors.ConstructorHasTypeParameters, {
          at: typeParameters,
        })
      }
      const { declare = false, kind } = method
      if (declare && (kind === 'get' || kind === 'set')) {
        this.raise(TSErrors.DeclareAccessor, {
          at: method,
          kind,
        })
      }
      if (typeParameters) method.typeParameters = typeParameters
      super.pushClassMethod(classBody2, method, isGenerator, isAsync, isConstructor, allowsDirectSuper)
    }
    pushClassPrivateMethod(classBody2, method, isGenerator, isAsync) {
      const typeParameters = this.tsTryParseTypeParameters()
      if (typeParameters) method.typeParameters = typeParameters
      super.pushClassPrivateMethod(classBody2, method, isGenerator, isAsync)
    }
    declareClassPrivateMethodInScope(node2, kind) {
      if (node2.type === 'TSDeclareMethod') return
      if (node2.type === 'MethodDefinition' && !node2.value.body) return
      super.declareClassPrivateMethodInScope(node2, kind)
    }
    parseClassSuper(node2) {
      super.parseClassSuper(node2)
      if (node2.superClass && (this.match(47) || this.match(51))) {
        node2.superTypeParameters = this.tsParseTypeArgumentsInExpression()
      }
      if (this.eatContextual(110)) {
        node2.implements = this.tsParseHeritageClause('implements')
      }
    }
    parseObjPropValue(prop, ...args) {
      const typeParameters = this.tsTryParseTypeParameters()
      if (typeParameters) prop.typeParameters = typeParameters
      super.parseObjPropValue(prop, ...args)
    }
    parseFunctionParams(node2, allowModifiers) {
      const typeParameters = this.tsTryParseTypeParameters()
      if (typeParameters) node2.typeParameters = typeParameters
      super.parseFunctionParams(node2, allowModifiers)
    }
    parseVarId(decl, kind) {
      super.parseVarId(decl, kind)
      if (decl.id.type === 'Identifier' && !this.hasPrecedingLineBreak() && this.eat(35)) {
        decl.definite = true
      }
      const type = this.tsTryParseTypeAnnotation()
      if (type) {
        decl.id.typeAnnotation = type
        this.resetEndLocation(decl.id)
      }
    }
    parseAsyncArrowFromCallExpression(node2, call2) {
      if (this.match(14)) {
        node2.returnType = this.tsParseTypeAnnotation()
      }
      return super.parseAsyncArrowFromCallExpression(node2, call2)
    }
    parseMaybeAssign(...args) {
      var _jsx, _jsx2, _typeCast, _jsx3, _typeCast2, _jsx4, _typeCast3
      let state
      let jsx2
      let typeCast
      if (this.hasPlugin('jsx') && (this.match(138) || this.match(47))) {
        state = this.state.clone()
        jsx2 = this.tryParse(() => super.parseMaybeAssign(...args), state)
        if (!jsx2.error) return jsx2.node
        const { context: context2 } = this.state
        const currentContext = context2[context2.length - 1]
        if (currentContext === types.j_oTag || currentContext === types.j_expr) {
          context2.pop()
        }
      }
      if (!((_jsx = jsx2) != null && _jsx.error) && !this.match(47)) {
        return super.parseMaybeAssign(...args)
      }
      let typeParameters
      state = state || this.state.clone()
      const arrow = this.tryParse((abort) => {
        var _expr$extra, _typeParameters, _expr$typeParameters$
        typeParameters = this.tsParseTypeParameters()
        const expr = super.parseMaybeAssign(...args)
        if (
          expr.type !== 'ArrowFunctionExpression' ||
          ((_expr$extra = expr.extra) != null && _expr$extra.parenthesized)
        ) {
          abort()
        }
        if (((_typeParameters = typeParameters) == null ? void 0 : _typeParameters.params.length) !== 0) {
          this.resetStartLocationFromNode(expr, typeParameters)
        }
        expr.typeParameters = typeParameters
        if (
          this.hasPlugin('jsx') &&
          expr.typeParameters.params.length === 1 &&
          !((_expr$typeParameters$ = expr.typeParameters.extra) != null && _expr$typeParameters$.trailingComma)
        ) {
          const parameter = expr.typeParameters.params[0]
          if (!parameter.constraint);
        }
        return expr
      }, state)
      if (!arrow.error && !arrow.aborted) {
        if (typeParameters) this.reportReservedArrowTypeParam(typeParameters)
        return arrow.node
      }
      if (!jsx2) {
        assert(!this.hasPlugin('jsx'))
        typeCast = this.tryParse(() => super.parseMaybeAssign(...args), state)
        if (!typeCast.error) return typeCast.node
      }
      if ((_jsx2 = jsx2) != null && _jsx2.node) {
        this.state = jsx2.failState
        return jsx2.node
      }
      if (arrow.node) {
        this.state = arrow.failState
        if (typeParameters) this.reportReservedArrowTypeParam(typeParameters)
        return arrow.node
      }
      if ((_typeCast = typeCast) != null && _typeCast.node) {
        this.state = typeCast.failState
        return typeCast.node
      }
      if ((_jsx3 = jsx2) != null && _jsx3.thrown) throw jsx2.error
      if (arrow.thrown) throw arrow.error
      if ((_typeCast2 = typeCast) != null && _typeCast2.thrown) throw typeCast.error
      throw (
        ((_jsx4 = jsx2) == null ? void 0 : _jsx4.error) ||
        arrow.error ||
        ((_typeCast3 = typeCast) == null ? void 0 : _typeCast3.error)
      )
    }
    reportReservedArrowTypeParam(node2) {
      var _node$extra
      if (
        node2.params.length === 1 &&
        !((_node$extra = node2.extra) != null && _node$extra.trailingComma) &&
        this.getPluginOption('typescript', 'disallowAmbiguousJSXLike')
      ) {
        this.raise(TSErrors.ReservedArrowTypeParam, {
          at: node2,
        })
      }
    }
    parseMaybeUnary(refExpressionErrors) {
      if (!this.hasPlugin('jsx') && this.match(47)) {
        return this.tsParseTypeAssertion()
      } else {
        return super.parseMaybeUnary(refExpressionErrors)
      }
    }
    parseArrow(node2) {
      if (this.match(14)) {
        const result = this.tryParse((abort) => {
          const returnType = this.tsParseTypeOrTypePredicateAnnotation(14)
          if (this.canInsertSemicolon() || !this.match(19)) abort()
          return returnType
        })
        if (result.aborted) return
        if (!result.thrown) {
          if (result.error) this.state = result.failState
          node2.returnType = result.node
        }
      }
      return super.parseArrow(node2)
    }
    parseAssignableListItemTypes(param) {
      if (this.eat(17)) {
        if (param.type !== 'Identifier' && !this.state.isAmbientContext && !this.state.inType) {
          this.raise(TSErrors.PatternIsOptional, {
            at: param,
          })
        }
        param.optional = true
      }
      const type = this.tsTryParseTypeAnnotation()
      if (type) param.typeAnnotation = type
      this.resetEndLocation(param)
      return param
    }
    isAssignable(node2, isBinding2) {
      switch (node2.type) {
        case 'TSTypeCastExpression':
          return this.isAssignable(node2.expression, isBinding2)
        case 'TSParameterProperty':
          return true
        default:
          return super.isAssignable(node2, isBinding2)
      }
    }
    toAssignable(node2, isLHS = false) {
      switch (node2.type) {
        case 'ParenthesizedExpression':
          this.toAssignableParenthesizedExpression(node2, isLHS)
          break
        case 'TSAsExpression':
        case 'TSNonNullExpression':
        case 'TSTypeAssertion':
          if (isLHS) {
            this.expressionScope.recordArrowParemeterBindingError(TSErrors.UnexpectedTypeCastInParameter, {
              at: node2,
            })
          } else {
            this.raise(TSErrors.UnexpectedTypeCastInParameter, {
              at: node2,
            })
          }
          this.toAssignable(node2.expression, isLHS)
          break
        case 'AssignmentExpression':
          if (!isLHS && node2.left.type === 'TSTypeCastExpression') {
            node2.left = this.typeCastToParameter(node2.left)
          }
        default:
          super.toAssignable(node2, isLHS)
      }
    }
    toAssignableParenthesizedExpression(node2, isLHS) {
      switch (node2.expression.type) {
        case 'TSAsExpression':
        case 'TSNonNullExpression':
        case 'TSTypeAssertion':
        case 'ParenthesizedExpression':
          this.toAssignable(node2.expression, isLHS)
          break
        default:
          super.toAssignable(node2, isLHS)
      }
    }
    checkToRestConversion(node2, allowPattern) {
      switch (node2.type) {
        case 'TSAsExpression':
        case 'TSTypeAssertion':
        case 'TSNonNullExpression':
          this.checkToRestConversion(node2.expression, false)
          break
        default:
          super.checkToRestConversion(node2, allowPattern)
      }
    }
    isValidLVal(type, isUnparenthesizedInAssign, binding2) {
      return (
        getOwn$1(
          {
            TSTypeCastExpression: true,
            TSParameterProperty: 'parameter',
            TSNonNullExpression: 'expression',
            TSAsExpression: (binding2 !== BIND_NONE || !isUnparenthesizedInAssign) && ['expression', true],
            TSTypeAssertion: (binding2 !== BIND_NONE || !isUnparenthesizedInAssign) && ['expression', true],
          },
          type
        ) || super.isValidLVal(type, isUnparenthesizedInAssign, binding2)
      )
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 78:
          return this.parseIdentifier(true)
        default:
          return super.parseBindingAtom()
      }
    }
    parseMaybeDecoratorArguments(expr) {
      if (this.match(47) || this.match(51)) {
        const typeArguments = this.tsParseTypeArgumentsInExpression()
        if (this.match(10)) {
          const call2 = super.parseMaybeDecoratorArguments(expr)
          call2.typeParameters = typeArguments
          return call2
        }
        this.unexpected(null, 10)
      }
      return super.parseMaybeDecoratorArguments(expr)
    }
    checkCommaAfterRest(close) {
      if (this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === close) {
        this.next()
        return false
      } else {
        return super.checkCommaAfterRest(close)
      }
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod()
    }
    isClassProperty() {
      return this.match(35) || this.match(14) || super.isClassProperty()
    }
    parseMaybeDefault(...args) {
      const node2 = super.parseMaybeDefault(...args)
      if (
        node2.type === 'AssignmentPattern' &&
        node2.typeAnnotation &&
        node2.right.start < node2.typeAnnotation.start
      ) {
        this.raise(TSErrors.TypeAnnotationAfterAssign, {
          at: node2.typeAnnotation,
        })
      }
      return node2
    }
    getTokenFromCode(code2) {
      if (this.state.inType) {
        if (code2 === 62) {
          return this.finishOp(48, 1)
        }
        if (code2 === 60) {
          return this.finishOp(47, 1)
        }
      }
      return super.getTokenFromCode(code2)
    }
    reScan_lt_gt() {
      const { type } = this.state
      if (type === 47) {
        this.state.pos -= 1
        this.readToken_lt()
      } else if (type === 48) {
        this.state.pos -= 1
        this.readToken_gt()
      }
    }
    reScan_lt() {
      const { type } = this.state
      if (type === 51) {
        this.state.pos -= 2
        this.finishOp(47, 1)
        return 47
      }
      return type
    }
    toAssignableList(exprList) {
      for (let i = 0; i < exprList.length; i++) {
        const expr = exprList[i]
        if ((expr == null ? void 0 : expr.type) === 'TSTypeCastExpression') {
          exprList[i] = this.typeCastToParameter(expr)
        }
      }
      super.toAssignableList(...arguments)
    }
    typeCastToParameter(node2) {
      node2.expression.typeAnnotation = node2.typeAnnotation
      this.resetEndLocation(node2.expression, node2.typeAnnotation.loc.end)
      return node2.expression
    }
    shouldParseArrow(params) {
      if (this.match(14)) {
        return params.every((expr) => this.isAssignable(expr, true))
      }
      return super.shouldParseArrow(params)
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow()
    }
    canHaveLeadingDecorator() {
      return super.canHaveLeadingDecorator() || this.isAbstractClass()
    }
    jsxParseOpeningElementAfterName(node2) {
      if (this.match(47) || this.match(51)) {
        const typeArguments = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression())
        if (typeArguments) node2.typeParameters = typeArguments
      }
      return super.jsxParseOpeningElementAfterName(node2)
    }
    getGetterSetterExpectedParamCount(method) {
      const baseCount = super.getGetterSetterExpectedParamCount(method)
      const params = this.getObjectOrClassMethodParams(method)
      const firstParam = params[0]
      const hasContextParam = firstParam && this.isThisParam(firstParam)
      return hasContextParam ? baseCount + 1 : baseCount
    }
    parseCatchClauseParam() {
      const param = super.parseCatchClauseParam()
      const type = this.tsTryParseTypeAnnotation()
      if (type) {
        param.typeAnnotation = type
        this.resetEndLocation(param)
      }
      return param
    }
    tsInAmbientContext(cb) {
      const oldIsAmbientContext = this.state.isAmbientContext
      this.state.isAmbientContext = true
      try {
        return cb()
      } finally {
        this.state.isAmbientContext = oldIsAmbientContext
      }
    }
    parseClass(node2, ...args) {
      const oldInAbstractClass = this.state.inAbstractClass
      this.state.inAbstractClass = !!node2.abstract
      try {
        return super.parseClass(node2, ...args)
      } finally {
        this.state.inAbstractClass = oldInAbstractClass
      }
    }
    tsParseAbstractDeclaration(node2) {
      if (this.match(80)) {
        node2.abstract = true
        return this.parseClass(node2, true, false)
      } else if (this.isContextual(125)) {
        if (!this.hasFollowingLineBreak()) {
          node2.abstract = true
          this.raise(TSErrors.NonClassMethodPropertyHasAbstractModifer, {
            at: node2,
          })
          return this.tsParseInterfaceDeclaration(node2)
        }
      } else {
        this.unexpected(null, 80)
      }
    }
    parseMethod(...args) {
      const method = super.parseMethod(...args)
      if (method.abstract) {
        const hasBody = this.hasPlugin('estree') ? !!method.value.body : !!method.body
        if (hasBody) {
          const { key } = method
          this.raise(TSErrors.AbstractMethodHasImplementation, {
            at: method,
            methodName:
              key.type === 'Identifier' && !method.computed ? key.name : `[${this.input.slice(key.start, key.end)}]`,
          })
        }
      }
      return method
    }
    tsParseTypeParameterName() {
      const typeName = this.parseIdentifier()
      return typeName.name
    }
    shouldParseAsAmbientContext() {
      return !!this.getPluginOption('typescript', 'dts')
    }
    parse() {
      if (this.shouldParseAsAmbientContext()) {
        this.state.isAmbientContext = true
      }
      return super.parse()
    }
    getExpression() {
      if (this.shouldParseAsAmbientContext()) {
        this.state.isAmbientContext = true
      }
      return super.getExpression()
    }
    parseExportSpecifier(node2, isString2, isInTypeExport, isMaybeTypeOnly) {
      if (!isString2 && isMaybeTypeOnly) {
        this.parseTypeOnlyImportExportSpecifier(node2, false, isInTypeExport)
        return this.finishNode(node2, 'ExportSpecifier')
      }
      node2.exportKind = 'value'
      return super.parseExportSpecifier(node2, isString2, isInTypeExport, isMaybeTypeOnly)
    }
    parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly) {
      if (!importedIsString && isMaybeTypeOnly) {
        this.parseTypeOnlyImportExportSpecifier(specifier, true, isInTypeOnlyImport)
        return this.finishNode(specifier, 'ImportSpecifier')
      }
      specifier.importKind = 'value'
      return super.parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly)
    }
    parseTypeOnlyImportExportSpecifier(node2, isImport2, isInTypeOnlyImportExport) {
      const leftOfAsKey = isImport2 ? 'imported' : 'local'
      const rightOfAsKey = isImport2 ? 'local' : 'exported'
      let leftOfAs = node2[leftOfAsKey]
      let rightOfAs
      let hasTypeSpecifier = false
      let canParseAsKeyword = true
      const loc = leftOfAs.loc.start
      if (this.isContextual(93)) {
        const firstAs = this.parseIdentifier()
        if (this.isContextual(93)) {
          const secondAs = this.parseIdentifier()
          if (tokenIsKeywordOrIdentifier(this.state.type)) {
            hasTypeSpecifier = true
            leftOfAs = firstAs
            rightOfAs = isImport2 ? this.parseIdentifier() : this.parseModuleExportName()
            canParseAsKeyword = false
          } else {
            rightOfAs = secondAs
            canParseAsKeyword = false
          }
        } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
          canParseAsKeyword = false
          rightOfAs = isImport2 ? this.parseIdentifier() : this.parseModuleExportName()
        } else {
          hasTypeSpecifier = true
          leftOfAs = firstAs
        }
      } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
        hasTypeSpecifier = true
        if (isImport2) {
          leftOfAs = this.parseIdentifier(true)
          if (!this.isContextual(93)) {
            this.checkReservedWord(leftOfAs.name, leftOfAs.loc.start, true, true)
          }
        } else {
          leftOfAs = this.parseModuleExportName()
        }
      }
      if (hasTypeSpecifier && isInTypeOnlyImportExport) {
        this.raise(isImport2 ? TSErrors.TypeModifierIsUsedInTypeImports : TSErrors.TypeModifierIsUsedInTypeExports, {
          at: loc,
        })
      }
      node2[leftOfAsKey] = leftOfAs
      node2[rightOfAsKey] = rightOfAs
      const kindKey = isImport2 ? 'importKind' : 'exportKind'
      node2[kindKey] = hasTypeSpecifier ? 'type' : 'value'
      if (canParseAsKeyword && this.eatContextual(93)) {
        node2[rightOfAsKey] = isImport2 ? this.parseIdentifier() : this.parseModuleExportName()
      }
      if (!node2[rightOfAsKey]) {
        node2[rightOfAsKey] = cloneIdentifier(node2[leftOfAsKey])
      }
      if (isImport2) {
        this.checkIdentifier(node2[rightOfAsKey], BIND_LEXICAL)
      }
    }
  }
function isPossiblyLiteralEnum(expression2) {
  if (expression2.type !== 'MemberExpression') return false
  const { computed: computed2, property } = expression2
  if (
    computed2 &&
    property.type !== 'StringLiteral' &&
    (property.type !== 'TemplateLiteral' || property.expressions.length > 0)
  ) {
    return false
  }
  return isUncomputedMemberExpressionChain(expression2.object)
}
function isUncomputedMemberExpressionChain(expression2) {
  if (expression2.type === 'Identifier') return true
  if (expression2.type !== 'MemberExpression') return false
  if (expression2.computed) return false
  return isUncomputedMemberExpressionChain(expression2.object)
}
const PlaceholderErrors = ParseErrorEnum`placeholders`((_2) => ({
  ClassNameIsRequired: _2('A class name is required.'),
  UnexpectedSpace: _2('Unexpected space in placeholder.'),
}))
var placeholders = (superClass) =>
  class extends superClass {
    parsePlaceholder(expectedNode) {
      if (this.match(140)) {
        const node2 = this.startNode()
        this.next()
        this.assertNoSpace()
        node2.name = super.parseIdentifier(true)
        this.assertNoSpace()
        this.expect(140)
        return this.finishPlaceholder(node2, expectedNode)
      }
    }
    finishPlaceholder(node2, expectedNode) {
      const isFinished = !!(node2.expectedNode && node2.type === 'Placeholder')
      node2.expectedNode = expectedNode
      return isFinished ? node2 : this.finishNode(node2, 'Placeholder')
    }
    getTokenFromCode(code2) {
      if (code2 === 37 && this.input.charCodeAt(this.state.pos + 1) === 37) {
        return this.finishOp(140, 2)
      }
      return super.getTokenFromCode(...arguments)
    }
    parseExprAtom() {
      return this.parsePlaceholder('Expression') || super.parseExprAtom(...arguments)
    }
    parseIdentifier() {
      return this.parsePlaceholder('Identifier') || super.parseIdentifier(...arguments)
    }
    checkReservedWord(word) {
      if (word !== void 0) super.checkReservedWord(...arguments)
    }
    parseBindingAtom() {
      return this.parsePlaceholder('Pattern') || super.parseBindingAtom(...arguments)
    }
    isValidLVal(type, ...rest) {
      return type === 'Placeholder' || super.isValidLVal(type, ...rest)
    }
    toAssignable(node2) {
      if (node2 && node2.type === 'Placeholder' && node2.expectedNode === 'Expression') {
        node2.expectedNode = 'Pattern'
      } else {
        super.toAssignable(...arguments)
      }
    }
    isLet(context2) {
      if (super.isLet(context2)) {
        return true
      }
      if (!this.isContextual(99)) {
        return false
      }
      if (context2) return false
      const nextToken = this.lookahead()
      if (nextToken.type === 140) {
        return true
      }
      return false
    }
    verifyBreakContinue(node2) {
      if (node2.label && node2.label.type === 'Placeholder') return
      super.verifyBreakContinue(...arguments)
    }
    parseExpressionStatement(node2, expr) {
      if (expr.type !== 'Placeholder' || (expr.extra && expr.extra.parenthesized)) {
        return super.parseExpressionStatement(...arguments)
      }
      if (this.match(14)) {
        const stmt = node2
        stmt.label = this.finishPlaceholder(expr, 'Identifier')
        this.next()
        stmt.body = this.parseStatement('label')
        return this.finishNode(stmt, 'LabeledStatement')
      }
      this.semicolon()
      node2.name = expr.name
      return this.finishPlaceholder(node2, 'Statement')
    }
    parseBlock() {
      return this.parsePlaceholder('BlockStatement') || super.parseBlock(...arguments)
    }
    parseFunctionId() {
      return this.parsePlaceholder('Identifier') || super.parseFunctionId(...arguments)
    }
    parseClass(node2, isStatement2, optionalId) {
      const type = isStatement2 ? 'ClassDeclaration' : 'ClassExpression'
      this.next()
      this.takeDecorators(node2)
      const oldStrict = this.state.strict
      const placeholder2 = this.parsePlaceholder('Identifier')
      if (placeholder2) {
        if (this.match(81) || this.match(140) || this.match(5)) {
          node2.id = placeholder2
        } else if (optionalId || !isStatement2) {
          node2.id = null
          node2.body = this.finishPlaceholder(placeholder2, 'ClassBody')
          return this.finishNode(node2, type)
        } else {
          throw this.raise(PlaceholderErrors.ClassNameIsRequired, {
            at: this.state.startLoc,
          })
        }
      } else {
        this.parseClassId(node2, isStatement2, optionalId)
      }
      this.parseClassSuper(node2)
      node2.body = this.parsePlaceholder('ClassBody') || this.parseClassBody(!!node2.superClass, oldStrict)
      return this.finishNode(node2, type)
    }
    parseExport(node2) {
      const placeholder2 = this.parsePlaceholder('Identifier')
      if (!placeholder2) return super.parseExport(...arguments)
      if (!this.isContextual(97) && !this.match(12)) {
        node2.specifiers = []
        node2.source = null
        node2.declaration = this.finishPlaceholder(placeholder2, 'Declaration')
        return this.finishNode(node2, 'ExportNamedDeclaration')
      }
      this.expectPlugin('exportDefaultFrom')
      const specifier = this.startNode()
      specifier.exported = placeholder2
      node2.specifiers = [this.finishNode(specifier, 'ExportDefaultSpecifier')]
      return super.parseExport(node2)
    }
    isExportDefaultSpecifier() {
      if (this.match(65)) {
        const next = this.nextTokenStart()
        if (this.isUnparsedContextual(next, 'from')) {
          if (this.input.startsWith(tokenLabelName(140), this.nextTokenStartSince(next + 4))) {
            return true
          }
        }
      }
      return super.isExportDefaultSpecifier()
    }
    maybeParseExportDefaultSpecifier(node2) {
      if (node2.specifiers && node2.specifiers.length > 0) {
        return true
      }
      return super.maybeParseExportDefaultSpecifier(...arguments)
    }
    checkExport(node2) {
      const { specifiers } = node2
      if (specifiers != null && specifiers.length) {
        node2.specifiers = specifiers.filter((node3) => node3.exported.type === 'Placeholder')
      }
      super.checkExport(node2)
      node2.specifiers = specifiers
    }
    parseImport(node2) {
      const placeholder2 = this.parsePlaceholder('Identifier')
      if (!placeholder2) return super.parseImport(...arguments)
      node2.specifiers = []
      if (!this.isContextual(97) && !this.match(12)) {
        node2.source = this.finishPlaceholder(placeholder2, 'StringLiteral')
        this.semicolon()
        return this.finishNode(node2, 'ImportDeclaration')
      }
      const specifier = this.startNodeAtNode(placeholder2)
      specifier.local = placeholder2
      this.finishNode(specifier, 'ImportDefaultSpecifier')
      node2.specifiers.push(specifier)
      if (this.eat(12)) {
        const hasStarImport = this.maybeParseStarImportSpecifier(node2)
        if (!hasStarImport) this.parseNamedImportSpecifiers(node2)
      }
      this.expectContextual(97)
      node2.source = this.parseImportSource()
      this.semicolon()
      return this.finishNode(node2, 'ImportDeclaration')
    }
    parseImportSource() {
      return this.parsePlaceholder('StringLiteral') || super.parseImportSource(...arguments)
    }
    assertNoSpace() {
      if (this.state.start > this.state.lastTokEndLoc.index) {
        this.raise(PlaceholderErrors.UnexpectedSpace, {
          at: this.state.lastTokEndLoc,
        })
      }
    }
  }
var v8intrinsic = (superClass) =>
  class extends superClass {
    parseV8Intrinsic() {
      if (this.match(54)) {
        const v8IntrinsicStartLoc = this.state.startLoc
        const node2 = this.startNode()
        this.next()
        if (tokenIsIdentifier(this.state.type)) {
          const name = this.parseIdentifierName(this.state.start)
          const identifier2 = this.createIdentifier(node2, name)
          identifier2.type = 'V8IntrinsicIdentifier'
          if (this.match(10)) {
            return identifier2
          }
        }
        this.unexpected(v8IntrinsicStartLoc)
      }
    }
    parseExprAtom() {
      return this.parseV8Intrinsic() || super.parseExprAtom(...arguments)
    }
  }
function hasPlugin(plugins, expectedConfig) {
  const [expectedName, expectedOptions] = typeof expectedConfig === 'string' ? [expectedConfig, {}] : expectedConfig
  const expectedKeys = Object.keys(expectedOptions)
  const expectedOptionsIsEmpty = expectedKeys.length === 0
  return plugins.some((p) => {
    if (typeof p === 'string') {
      return expectedOptionsIsEmpty && p === expectedName
    } else {
      const [pluginName, pluginOptions] = p
      if (pluginName !== expectedName) {
        return false
      }
      for (const key of expectedKeys) {
        if (pluginOptions[key] !== expectedOptions[key]) {
          return false
        }
      }
      return true
    }
  })
}
function getPluginOption(plugins, name, option) {
  const plugin = plugins.find((plugin2) => {
    if (Array.isArray(plugin2)) {
      return plugin2[0] === name
    } else {
      return plugin2 === name
    }
  })
  if (plugin && Array.isArray(plugin)) {
    return plugin[1][option]
  }
  return null
}
const PIPELINE_PROPOSALS = ['minimal', 'fsharp', 'hack', 'smart']
const TOPIC_TOKENS = ['^^', '@@', '^', '%', '#']
const RECORD_AND_TUPLE_SYNTAX_TYPES = ['hash', 'bar']
function validatePlugins(plugins) {
  if (hasPlugin(plugins, 'decorators')) {
    if (hasPlugin(plugins, 'decorators-legacy')) {
      throw new Error('Cannot use the decorators and decorators-legacy plugin together')
    }
    const decoratorsBeforeExport = getPluginOption(plugins, 'decorators', 'decoratorsBeforeExport')
    if (decoratorsBeforeExport == null) {
      throw new Error(
        "The 'decorators' plugin requires a 'decoratorsBeforeExport' option, whose value must be a boolean. If you are migrating from Babylon/Babel 6 or want to use the old decorators proposal, you should use the 'decorators-legacy' plugin instead of 'decorators'."
      )
    } else if (typeof decoratorsBeforeExport !== 'boolean') {
      throw new Error("'decoratorsBeforeExport' must be a boolean.")
    }
  }
  if (hasPlugin(plugins, 'flow') && hasPlugin(plugins, 'typescript')) {
    throw new Error('Cannot combine flow and typescript plugins.')
  }
  if (hasPlugin(plugins, 'placeholders') && hasPlugin(plugins, 'v8intrinsic')) {
    throw new Error('Cannot combine placeholders and v8intrinsic plugins.')
  }
  if (hasPlugin(plugins, 'pipelineOperator')) {
    const proposal = getPluginOption(plugins, 'pipelineOperator', 'proposal')
    if (!PIPELINE_PROPOSALS.includes(proposal)) {
      const proposalList = PIPELINE_PROPOSALS.map((p) => `"${p}"`).join(', ')
      throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${proposalList}.`)
    }
    const tupleSyntaxIsHash = hasPlugin(plugins, [
      'recordAndTuple',
      {
        syntaxType: 'hash',
      },
    ])
    if (proposal === 'hack') {
      if (hasPlugin(plugins, 'placeholders')) {
        throw new Error('Cannot combine placeholders plugin and Hack-style pipes.')
      }
      if (hasPlugin(plugins, 'v8intrinsic')) {
        throw new Error('Cannot combine v8intrinsic plugin and Hack-style pipes.')
      }
      const topicToken = getPluginOption(plugins, 'pipelineOperator', 'topicToken')
      if (!TOPIC_TOKENS.includes(topicToken)) {
        const tokenList = TOPIC_TOKENS.map((t2) => `"${t2}"`).join(', ')
        throw new Error(
          `"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${tokenList}.`
        )
      }
      if (topicToken === '#' && tupleSyntaxIsHash) {
        throw new Error(
          'Plugin conflict between `["pipelineOperator", { proposal: "hack", topicToken: "#" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.'
        )
      }
    } else if (proposal === 'smart' && tupleSyntaxIsHash) {
      throw new Error(
        'Plugin conflict between `["pipelineOperator", { proposal: "smart" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.'
      )
    }
  }
  if (hasPlugin(plugins, 'moduleAttributes')) {
    {
      if (hasPlugin(plugins, 'importAssertions')) {
        throw new Error('Cannot combine importAssertions and moduleAttributes plugins.')
      }
      const moduleAttributesVersionPluginOption = getPluginOption(plugins, 'moduleAttributes', 'version')
      if (moduleAttributesVersionPluginOption !== 'may-2020') {
        throw new Error(
          "The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'."
        )
      }
    }
  }
  if (
    hasPlugin(plugins, 'recordAndTuple') &&
    !RECORD_AND_TUPLE_SYNTAX_TYPES.includes(getPluginOption(plugins, 'recordAndTuple', 'syntaxType'))
  ) {
    throw new Error(
      "'recordAndTuple' requires 'syntaxType' option whose value should be one of: " +
        RECORD_AND_TUPLE_SYNTAX_TYPES.map((p) => `'${p}'`).join(', ')
    )
  }
  if (hasPlugin(plugins, 'asyncDoExpressions') && !hasPlugin(plugins, 'doExpressions')) {
    const error = new Error(
      "'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins."
    )
    error.missingPlugins = 'doExpressions'
    throw error
  }
}
const mixinPlugins = {
  estree,
  jsx,
  flow,
  typescript,
  v8intrinsic,
  placeholders,
}
const mixinPluginNames = Object.keys(mixinPlugins)
const defaultOptions = {
  sourceType: 'script',
  sourceFilename: void 0,
  startColumn: 0,
  startLine: 1,
  allowAwaitOutsideFunction: false,
  allowReturnOutsideFunction: false,
  allowImportExportEverywhere: false,
  allowSuperOutsideMethod: false,
  allowUndeclaredExports: false,
  plugins: [],
  strictMode: null,
  ranges: false,
  tokens: false,
  createParenthesizedExpressions: false,
  errorRecovery: false,
  attachComment: true,
}
function getOptions(opts) {
  const options2 = {}
  for (const key of Object.keys(defaultOptions)) {
    options2[key] = opts && opts[key] != null ? opts[key] : defaultOptions[key]
  }
  return options2
}
const getOwn = (object2, key) => Object.hasOwnProperty.call(object2, key) && object2[key]
const unwrapParenthesizedExpression = (node2) => {
  return node2.type === 'ParenthesizedExpression' ? unwrapParenthesizedExpression(node2.expression) : node2
}
class LValParser extends NodeUtils {
  toAssignable(node2, isLHS = false) {
    var _node$extra, _node$extra3
    let parenthesized = void 0
    if (
      node2.type === 'ParenthesizedExpression' ||
      ((_node$extra = node2.extra) != null && _node$extra.parenthesized)
    ) {
      parenthesized = unwrapParenthesizedExpression(node2)
      if (isLHS) {
        if (parenthesized.type === 'Identifier') {
          this.expressionScope.recordArrowParemeterBindingError(Errors.InvalidParenthesizedAssignment, {
            at: node2,
          })
        } else if (parenthesized.type !== 'MemberExpression') {
          this.raise(Errors.InvalidParenthesizedAssignment, {
            at: node2,
          })
        }
      } else {
        this.raise(Errors.InvalidParenthesizedAssignment, {
          at: node2,
        })
      }
    }
    switch (node2.type) {
      case 'Identifier':
      case 'ObjectPattern':
      case 'ArrayPattern':
      case 'AssignmentPattern':
      case 'RestElement':
        break
      case 'ObjectExpression':
        node2.type = 'ObjectPattern'
        for (let i = 0, length = node2.properties.length, last2 = length - 1; i < length; i++) {
          var _node$extra2
          const prop = node2.properties[i]
          const isLast = i === last2
          this.toAssignableObjectExpressionProp(prop, isLast, isLHS)
          if (
            isLast &&
            prop.type === 'RestElement' &&
            (_node$extra2 = node2.extra) != null &&
            _node$extra2.trailingCommaLoc
          ) {
            this.raise(Errors.RestTrailingComma, {
              at: node2.extra.trailingCommaLoc,
            })
          }
        }
        break
      case 'ObjectProperty': {
        const { key, value } = node2
        if (this.isPrivateName(key)) {
          this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start)
        }
        this.toAssignable(value, isLHS)
        break
      }
      case 'SpreadElement': {
        throw new Error(
          "Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller."
        )
      }
      case 'ArrayExpression':
        node2.type = 'ArrayPattern'
        this.toAssignableList(
          node2.elements,
          (_node$extra3 = node2.extra) == null ? void 0 : _node$extra3.trailingCommaLoc,
          isLHS
        )
        break
      case 'AssignmentExpression':
        if (node2.operator !== '=') {
          this.raise(Errors.MissingEqInAssignment, {
            at: node2.left.loc.end,
          })
        }
        node2.type = 'AssignmentPattern'
        delete node2.operator
        this.toAssignable(node2.left, isLHS)
        break
      case 'ParenthesizedExpression':
        this.toAssignable(parenthesized, isLHS)
        break
    }
  }
  toAssignableObjectExpressionProp(prop, isLast, isLHS) {
    if (prop.type === 'ObjectMethod') {
      this.raise(prop.kind === 'get' || prop.kind === 'set' ? Errors.PatternHasAccessor : Errors.PatternHasMethod, {
        at: prop.key,
      })
    } else if (prop.type === 'SpreadElement') {
      prop.type = 'RestElement'
      const arg = prop.argument
      this.checkToRestConversion(arg, false)
      this.toAssignable(arg, isLHS)
      if (!isLast) {
        this.raise(Errors.RestTrailingComma, {
          at: prop,
        })
      }
    } else {
      this.toAssignable(prop, isLHS)
    }
  }
  toAssignableList(exprList, trailingCommaLoc, isLHS) {
    const end = exprList.length - 1
    for (let i = 0; i <= end; i++) {
      const elt = exprList[i]
      if (!elt) continue
      if (elt.type === 'SpreadElement') {
        elt.type = 'RestElement'
        const arg = elt.argument
        this.checkToRestConversion(arg, true)
        this.toAssignable(arg, isLHS)
      } else {
        this.toAssignable(elt, isLHS)
      }
      if (elt.type === 'RestElement') {
        if (i < end) {
          this.raise(Errors.RestTrailingComma, {
            at: elt,
          })
        } else if (trailingCommaLoc) {
          this.raise(Errors.RestTrailingComma, {
            at: trailingCommaLoc,
          })
        }
      }
    }
  }
  isAssignable(node2, isBinding2) {
    switch (node2.type) {
      case 'Identifier':
      case 'ObjectPattern':
      case 'ArrayPattern':
      case 'AssignmentPattern':
      case 'RestElement':
        return true
      case 'ObjectExpression': {
        const last2 = node2.properties.length - 1
        return node2.properties.every((prop, i) => {
          return (
            prop.type !== 'ObjectMethod' && (i === last2 || prop.type !== 'SpreadElement') && this.isAssignable(prop)
          )
        })
      }
      case 'ObjectProperty':
        return this.isAssignable(node2.value)
      case 'SpreadElement':
        return this.isAssignable(node2.argument)
      case 'ArrayExpression':
        return node2.elements.every((element) => element === null || this.isAssignable(element))
      case 'AssignmentExpression':
        return node2.operator === '='
      case 'ParenthesizedExpression':
        return this.isAssignable(node2.expression)
      case 'MemberExpression':
      case 'OptionalMemberExpression':
        return !isBinding2
      default:
        return false
    }
  }
  toReferencedList(exprList, isParenthesizedExpr) {
    return exprList
  }
  toReferencedListDeep(exprList, isParenthesizedExpr) {
    this.toReferencedList(exprList, isParenthesizedExpr)
    for (const expr of exprList) {
      if ((expr == null ? void 0 : expr.type) === 'ArrayExpression') {
        this.toReferencedListDeep(expr.elements)
      }
    }
  }
  parseSpread(refExpressionErrors, refNeedsArrowPos) {
    const node2 = this.startNode()
    this.next()
    node2.argument = this.parseMaybeAssignAllowIn(refExpressionErrors, void 0, refNeedsArrowPos)
    return this.finishNode(node2, 'SpreadElement')
  }
  parseRestBinding() {
    const node2 = this.startNode()
    this.next()
    node2.argument = this.parseBindingAtom()
    return this.finishNode(node2, 'RestElement')
  }
  parseBindingAtom() {
    switch (this.state.type) {
      case 0: {
        const node2 = this.startNode()
        this.next()
        node2.elements = this.parseBindingList(3, 93, true)
        return this.finishNode(node2, 'ArrayPattern')
      }
      case 5:
        return this.parseObjectLike(8, true)
    }
    return this.parseIdentifier()
  }
  parseBindingList(close, closeCharCode, allowEmpty, allowModifiers) {
    const elts = []
    let first = true
    while (!this.eat(close)) {
      if (first) {
        first = false
      } else {
        this.expect(12)
      }
      if (allowEmpty && this.match(12)) {
        elts.push(null)
      } else if (this.eat(close)) {
        break
      } else if (this.match(21)) {
        elts.push(this.parseAssignableListItemTypes(this.parseRestBinding()))
        if (!this.checkCommaAfterRest(closeCharCode)) {
          this.expect(close)
          break
        }
      } else {
        const decorators = []
        if (this.match(26) && this.hasPlugin('decorators')) {
          this.raise(Errors.UnsupportedParameterDecorator, {
            at: this.state.startLoc,
          })
        }
        while (this.match(26)) {
          decorators.push(this.parseDecorator())
        }
        elts.push(this.parseAssignableListItem(allowModifiers, decorators))
      }
    }
    return elts
  }
  parseBindingRestProperty(prop) {
    this.next()
    prop.argument = this.parseIdentifier()
    this.checkCommaAfterRest(125)
    return this.finishNode(prop, 'RestElement')
  }
  parseBindingProperty() {
    const prop = this.startNode()
    const { type, start: startPos, startLoc } = this.state
    if (type === 21) {
      return this.parseBindingRestProperty(prop)
    } else if (type === 134) {
      this.expectPlugin('destructuringPrivate', startLoc)
      this.classScope.usePrivateName(this.state.value, startLoc)
      prop.key = this.parsePrivateName()
    } else {
      this.parsePropertyName(prop)
    }
    prop.method = false
    this.parseObjPropValue(prop, startPos, startLoc, false, false, true, false)
    return prop
  }
  parseAssignableListItem(allowModifiers, decorators) {
    const left = this.parseMaybeDefault()
    this.parseAssignableListItemTypes(left)
    const elt = this.parseMaybeDefault(left.start, left.loc.start, left)
    if (decorators.length) {
      left.decorators = decorators
    }
    return elt
  }
  parseAssignableListItemTypes(param) {
    return param
  }
  parseMaybeDefault(startPos, startLoc, left) {
    var _startLoc, _startPos, _left
    startLoc = (_startLoc = startLoc) != null ? _startLoc : this.state.startLoc
    startPos = (_startPos = startPos) != null ? _startPos : this.state.start
    left = (_left = left) != null ? _left : this.parseBindingAtom()
    if (!this.eat(29)) return left
    const node2 = this.startNodeAt(startPos, startLoc)
    node2.left = left
    node2.right = this.parseMaybeAssignAllowIn()
    return this.finishNode(node2, 'AssignmentPattern')
  }
  isValidLVal(type, isUnparenthesizedInAssign, binding2) {
    return getOwn(
      {
        AssignmentPattern: 'left',
        RestElement: 'argument',
        ObjectProperty: 'value',
        ParenthesizedExpression: 'expression',
        ArrayPattern: 'elements',
        ObjectPattern: 'properties',
      },
      type
    )
  }
  checkLVal(
    expression2,
    {
      in: ancestor,
      binding: binding2 = BIND_NONE,
      checkClashes = false,
      strictModeChanged = false,
      allowingSloppyLetBinding = !(binding2 & BIND_SCOPE_LEXICAL),
      hasParenthesizedAncestor = false,
    }
  ) {
    var _expression$extra
    const type = expression2.type
    if (this.isObjectMethod(expression2)) return
    if (type === 'MemberExpression') {
      if (binding2 !== BIND_NONE) {
        this.raise(Errors.InvalidPropertyBindingPattern, {
          at: expression2,
        })
      }
      return
    }
    if (expression2.type === 'Identifier') {
      this.checkIdentifier(expression2, binding2, strictModeChanged, allowingSloppyLetBinding)
      const { name } = expression2
      if (checkClashes) {
        if (checkClashes.has(name)) {
          this.raise(Errors.ParamDupe, {
            at: expression2,
          })
        } else {
          checkClashes.add(name)
        }
      }
      return
    }
    const validity = this.isValidLVal(
      expression2.type,
      !(
        hasParenthesizedAncestor ||
        ((_expression$extra = expression2.extra) != null && _expression$extra.parenthesized)
      ) && ancestor.type === 'AssignmentExpression',
      binding2
    )
    if (validity === true) return
    if (validity === false) {
      const ParseErrorClass = binding2 === BIND_NONE ? Errors.InvalidLhs : Errors.InvalidLhsBinding
      this.raise(ParseErrorClass, {
        at: expression2,
        ancestor:
          ancestor.type === 'UpdateExpression'
            ? {
                type: 'UpdateExpression',
                prefix: ancestor.prefix,
              }
            : {
                type: ancestor.type,
              },
      })
      return
    }
    const [key, isParenthesizedExpression2] = Array.isArray(validity)
      ? validity
      : [validity, type === 'ParenthesizedExpression']
    const nextAncestor =
      expression2.type === 'ArrayPattern' ||
      expression2.type === 'ObjectPattern' ||
      expression2.type === 'ParenthesizedExpression'
        ? expression2
        : ancestor
    for (const child of [].concat(expression2[key])) {
      if (child) {
        this.checkLVal(child, {
          in: nextAncestor,
          binding: binding2,
          checkClashes,
          allowingSloppyLetBinding,
          strictModeChanged,
          hasParenthesizedAncestor: isParenthesizedExpression2,
        })
      }
    }
  }
  checkIdentifier(at, bindingType, strictModeChanged = false, allowLetBinding = !(bindingType & BIND_SCOPE_LEXICAL)) {
    if (
      this.state.strict &&
      (strictModeChanged ? isStrictBindReservedWord(at.name, this.inModule) : isStrictBindOnlyReservedWord(at.name))
    ) {
      if (bindingType === BIND_NONE) {
        this.raise(Errors.StrictEvalArguments, {
          at,
          referenceName: at.name,
        })
      } else {
        this.raise(Errors.StrictEvalArgumentsBinding, {
          at,
          bindingName: at.name,
        })
      }
    }
    if (!allowLetBinding && at.name === 'let') {
      this.raise(Errors.LetInLexicalBinding, {
        at,
      })
    }
    if (!(bindingType & BIND_NONE)) {
      this.declareNameFromIdentifier(at, bindingType)
    }
  }
  declareNameFromIdentifier(identifier2, binding2) {
    this.scope.declareName(identifier2.name, binding2, identifier2.loc.start)
  }
  checkToRestConversion(node2, allowPattern) {
    switch (node2.type) {
      case 'ParenthesizedExpression':
        this.checkToRestConversion(node2.expression, allowPattern)
        break
      case 'Identifier':
      case 'MemberExpression':
        break
      case 'ArrayExpression':
      case 'ObjectExpression':
        if (allowPattern) break
      default:
        this.raise(Errors.InvalidRestAssignmentPattern, {
          at: node2,
        })
    }
  }
  checkCommaAfterRest(close) {
    if (!this.match(12)) {
      return false
    }
    this.raise(this.lookaheadCharCode() === close ? Errors.RestTrailingComma : Errors.ElementAfterRest, {
      at: this.state.startLoc,
    })
    return true
  }
}
class ExpressionParser extends LValParser {
  checkProto(prop, isRecord, protoRef, refExpressionErrors) {
    if (prop.type === 'SpreadElement' || this.isObjectMethod(prop) || prop.computed || prop.shorthand) {
      return
    }
    const key = prop.key
    const name = key.type === 'Identifier' ? key.name : key.value
    if (name === '__proto__') {
      if (isRecord) {
        this.raise(Errors.RecordNoProto, {
          at: key,
        })
        return
      }
      if (protoRef.used) {
        if (refExpressionErrors) {
          if (refExpressionErrors.doubleProtoLoc === null) {
            refExpressionErrors.doubleProtoLoc = key.loc.start
          }
        } else {
          this.raise(Errors.DuplicateProto, {
            at: key,
          })
        }
      }
      protoRef.used = true
    }
  }
  shouldExitDescending(expr, potentialArrowAt) {
    return expr.type === 'ArrowFunctionExpression' && expr.start === potentialArrowAt
  }
  getExpression() {
    this.enterInitialScopes()
    this.nextToken()
    const expr = this.parseExpression()
    if (!this.match(135)) {
      this.unexpected()
    }
    this.finalizeRemainingComments()
    expr.comments = this.state.comments
    expr.errors = this.state.errors
    if (this.options.tokens) {
      expr.tokens = this.tokens
    }
    return expr
  }
  parseExpression(disallowIn, refExpressionErrors) {
    if (disallowIn) {
      return this.disallowInAnd(() => this.parseExpressionBase(refExpressionErrors))
    }
    return this.allowInAnd(() => this.parseExpressionBase(refExpressionErrors))
  }
  parseExpressionBase(refExpressionErrors) {
    const startPos = this.state.start
    const startLoc = this.state.startLoc
    const expr = this.parseMaybeAssign(refExpressionErrors)
    if (this.match(12)) {
      const node2 = this.startNodeAt(startPos, startLoc)
      node2.expressions = [expr]
      while (this.eat(12)) {
        node2.expressions.push(this.parseMaybeAssign(refExpressionErrors))
      }
      this.toReferencedList(node2.expressions)
      return this.finishNode(node2, 'SequenceExpression')
    }
    return expr
  }
  parseMaybeAssignDisallowIn(refExpressionErrors, afterLeftParse) {
    return this.disallowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse))
  }
  parseMaybeAssignAllowIn(refExpressionErrors, afterLeftParse) {
    return this.allowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse))
  }
  setOptionalParametersError(refExpressionErrors, resultError) {
    var _resultError$loc
    refExpressionErrors.optionalParametersLoc =
      (_resultError$loc = resultError == null ? void 0 : resultError.loc) != null
        ? _resultError$loc
        : this.state.startLoc
  }
  parseMaybeAssign(refExpressionErrors, afterLeftParse) {
    const startPos = this.state.start
    const startLoc = this.state.startLoc
    if (this.isContextual(105)) {
      if (this.prodParam.hasYield) {
        let left2 = this.parseYield()
        if (afterLeftParse) {
          left2 = afterLeftParse.call(this, left2, startPos, startLoc)
        }
        return left2
      }
    }
    let ownExpressionErrors
    if (refExpressionErrors) {
      ownExpressionErrors = false
    } else {
      refExpressionErrors = new ExpressionErrors()
      ownExpressionErrors = true
    }
    const { type } = this.state
    if (type === 10 || tokenIsIdentifier(type)) {
      this.state.potentialArrowAt = this.state.start
    }
    let left = this.parseMaybeConditional(refExpressionErrors)
    if (afterLeftParse) {
      left = afterLeftParse.call(this, left, startPos, startLoc)
    }
    if (tokenIsAssignment(this.state.type)) {
      const node2 = this.startNodeAt(startPos, startLoc)
      const operator = this.state.value
      node2.operator = operator
      if (this.match(29)) {
        this.toAssignable(left, true)
        node2.left = left
        if (refExpressionErrors.doubleProtoLoc != null && refExpressionErrors.doubleProtoLoc.index >= startPos) {
          refExpressionErrors.doubleProtoLoc = null
        }
        if (
          refExpressionErrors.shorthandAssignLoc != null &&
          refExpressionErrors.shorthandAssignLoc.index >= startPos
        ) {
          refExpressionErrors.shorthandAssignLoc = null
        }
        if (refExpressionErrors.privateKeyLoc != null && refExpressionErrors.privateKeyLoc.index >= startPos) {
          this.checkDestructuringPrivate(refExpressionErrors)
          refExpressionErrors.privateKeyLoc = null
        }
      } else {
        node2.left = left
      }
      this.next()
      node2.right = this.parseMaybeAssign()
      this.checkLVal(left, {
        in: this.finishNode(node2, 'AssignmentExpression'),
      })
      return node2
    } else if (ownExpressionErrors) {
      this.checkExpressionErrors(refExpressionErrors, true)
    }
    return left
  }
  parseMaybeConditional(refExpressionErrors) {
    const startPos = this.state.start
    const startLoc = this.state.startLoc
    const potentialArrowAt = this.state.potentialArrowAt
    const expr = this.parseExprOps(refExpressionErrors)
    if (this.shouldExitDescending(expr, potentialArrowAt)) {
      return expr
    }
    return this.parseConditional(expr, startPos, startLoc, refExpressionErrors)
  }
  parseConditional(expr, startPos, startLoc, refExpressionErrors) {
    if (this.eat(17)) {
      const node2 = this.startNodeAt(startPos, startLoc)
      node2.test = expr
      node2.consequent = this.parseMaybeAssignAllowIn()
      this.expect(14)
      node2.alternate = this.parseMaybeAssign()
      return this.finishNode(node2, 'ConditionalExpression')
    }
    return expr
  }
  parseMaybeUnaryOrPrivate(refExpressionErrors) {
    return this.match(134) ? this.parsePrivateName() : this.parseMaybeUnary(refExpressionErrors)
  }
  parseExprOps(refExpressionErrors) {
    const startPos = this.state.start
    const startLoc = this.state.startLoc
    const potentialArrowAt = this.state.potentialArrowAt
    const expr = this.parseMaybeUnaryOrPrivate(refExpressionErrors)
    if (this.shouldExitDescending(expr, potentialArrowAt)) {
      return expr
    }
    return this.parseExprOp(expr, startPos, startLoc, -1)
  }
  parseExprOp(left, leftStartPos, leftStartLoc, minPrec) {
    if (this.isPrivateName(left)) {
      const value = this.getPrivateNameSV(left)
      if (minPrec >= tokenOperatorPrecedence(58) || !this.prodParam.hasIn || !this.match(58)) {
        this.raise(Errors.PrivateInExpectedIn, {
          at: left,
          identifierName: value,
        })
      }
      this.classScope.usePrivateName(value, left.loc.start)
    }
    const op = this.state.type
    if (tokenIsOperator(op) && (this.prodParam.hasIn || !this.match(58))) {
      let prec = tokenOperatorPrecedence(op)
      if (prec > minPrec) {
        if (op === 39) {
          this.expectPlugin('pipelineOperator')
          if (this.state.inFSharpPipelineDirectBody) {
            return left
          }
          this.checkPipelineAtInfixOperator(left, leftStartLoc)
        }
        const node2 = this.startNodeAt(leftStartPos, leftStartLoc)
        node2.left = left
        node2.operator = this.state.value
        const logical = op === 41 || op === 42
        const coalesce = op === 40
        if (coalesce) {
          prec = tokenOperatorPrecedence(42)
        }
        this.next()
        if (
          op === 39 &&
          this.hasPlugin([
            'pipelineOperator',
            {
              proposal: 'minimal',
            },
          ])
        ) {
          if (this.state.type === 96 && this.prodParam.hasAwait) {
            throw this.raise(Errors.UnexpectedAwaitAfterPipelineBody, {
              at: this.state.startLoc,
            })
          }
        }
        node2.right = this.parseExprOpRightExpr(op, prec)
        this.finishNode(node2, logical || coalesce ? 'LogicalExpression' : 'BinaryExpression')
        const nextOp = this.state.type
        if ((coalesce && (nextOp === 41 || nextOp === 42)) || (logical && nextOp === 40)) {
          throw this.raise(Errors.MixingCoalesceWithLogical, {
            at: this.state.startLoc,
          })
        }
        return this.parseExprOp(node2, leftStartPos, leftStartLoc, minPrec)
      }
    }
    return left
  }
  parseExprOpRightExpr(op, prec) {
    const startPos = this.state.start
    const startLoc = this.state.startLoc
    switch (op) {
      case 39:
        switch (this.getPluginOption('pipelineOperator', 'proposal')) {
          case 'hack':
            return this.withTopicBindingContext(() => {
              return this.parseHackPipeBody()
            })
          case 'smart':
            return this.withTopicBindingContext(() => {
              if (this.prodParam.hasYield && this.isContextual(105)) {
                throw this.raise(Errors.PipeBodyIsTighter, {
                  at: this.state.startLoc,
                })
              }
              return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(op, prec), startPos, startLoc)
            })
          case 'fsharp':
            return this.withSoloAwaitPermittingContext(() => {
              return this.parseFSharpPipelineBody(prec)
            })
        }
      default:
        return this.parseExprOpBaseRightExpr(op, prec)
    }
  }
  parseExprOpBaseRightExpr(op, prec) {
    const startPos = this.state.start
    const startLoc = this.state.startLoc
    return this.parseExprOp(
      this.parseMaybeUnaryOrPrivate(),
      startPos,
      startLoc,
      tokenIsRightAssociative(op) ? prec - 1 : prec
    )
  }
  parseHackPipeBody() {
    var _body$extra
    const { startLoc } = this.state
    const body = this.parseMaybeAssign()
    const requiredParentheses = UnparenthesizedPipeBodyDescriptions.has(body.type)
    if (requiredParentheses && !((_body$extra = body.extra) != null && _body$extra.parenthesized)) {
      this.raise(Errors.PipeUnparenthesizedBody, {
        at: startLoc,
        type: body.type,
      })
    }
    if (!this.topicReferenceWasUsedInCurrentContext()) {
      this.raise(Errors.PipeTopicUnused, {
        at: startLoc,
      })
    }
    return body
  }
  checkExponentialAfterUnary(node2) {
    if (this.match(57)) {
      this.raise(Errors.UnexpectedTokenUnaryExponentiation, {
        at: node2.argument,
      })
    }
  }
  parseMaybeUnary(refExpressionErrors, sawUnary) {
    const startPos = this.state.start
    const startLoc = this.state.startLoc
    const isAwait = this.isContextual(96)
    if (isAwait && this.isAwaitAllowed()) {
      this.next()
      const expr2 = this.parseAwait(startPos, startLoc)
      if (!sawUnary) this.checkExponentialAfterUnary(expr2)
      return expr2
    }
    const update = this.match(34)
    const node2 = this.startNode()
    if (tokenIsPrefix(this.state.type)) {
      node2.operator = this.state.value
      node2.prefix = true
      if (this.match(72)) {
        this.expectPlugin('throwExpressions')
      }
      const isDelete = this.match(89)
      this.next()
      node2.argument = this.parseMaybeUnary(null, true)
      this.checkExpressionErrors(refExpressionErrors, true)
      if (this.state.strict && isDelete) {
        const arg = node2.argument
        if (arg.type === 'Identifier') {
          this.raise(Errors.StrictDelete, {
            at: node2,
          })
        } else if (this.hasPropertyAsPrivateName(arg)) {
          this.raise(Errors.DeletePrivateField, {
            at: node2,
          })
        }
      }
      if (!update) {
        if (!sawUnary) this.checkExponentialAfterUnary(node2)
        return this.finishNode(node2, 'UnaryExpression')
      }
    }
    const expr = this.parseUpdate(node2, update, refExpressionErrors)
    if (isAwait) {
      const { type } = this.state
      const startsExpr2 = this.hasPlugin('v8intrinsic')
        ? tokenCanStartExpression(type)
        : tokenCanStartExpression(type) && !this.match(54)
      if (startsExpr2 && !this.isAmbiguousAwait()) {
        this.raiseOverwrite(Errors.AwaitNotInAsyncContext, {
          at: startLoc,
        })
        return this.parseAwait(startPos, startLoc)
      }
    }
    return expr
  }
  parseUpdate(node2, update, refExpressionErrors) {
    if (update) {
      this.checkLVal(node2.argument, {
        in: this.finishNode(node2, 'UpdateExpression'),
      })
      return node2
    }
    const startPos = this.state.start
    const startLoc = this.state.startLoc
    let expr = this.parseExprSubscripts(refExpressionErrors)
    if (this.checkExpressionErrors(refExpressionErrors, false)) return expr
    while (tokenIsPostfix(this.state.type) && !this.canInsertSemicolon()) {
      const node3 = this.startNodeAt(startPos, startLoc)
      node3.operator = this.state.value
      node3.prefix = false
      node3.argument = expr
      this.next()
      this.checkLVal(expr, {
        in: (expr = this.finishNode(node3, 'UpdateExpression')),
      })
    }
    return expr
  }
  parseExprSubscripts(refExpressionErrors) {
    const startPos = this.state.start
    const startLoc = this.state.startLoc
    const potentialArrowAt = this.state.potentialArrowAt
    const expr = this.parseExprAtom(refExpressionErrors)
    if (this.shouldExitDescending(expr, potentialArrowAt)) {
      return expr
    }
    return this.parseSubscripts(expr, startPos, startLoc)
  }
  parseSubscripts(base2, startPos, startLoc, noCalls) {
    const state = {
      optionalChainMember: false,
      maybeAsyncArrow: this.atPossibleAsyncArrow(base2),
      stop: false,
    }
    do {
      base2 = this.parseSubscript(base2, startPos, startLoc, noCalls, state)
      state.maybeAsyncArrow = false
    } while (!state.stop)
    return base2
  }
  parseSubscript(base2, startPos, startLoc, noCalls, state) {
    const { type } = this.state
    if (!noCalls && type === 15) {
      return this.parseBind(base2, startPos, startLoc, noCalls, state)
    } else if (tokenIsTemplate(type)) {
      return this.parseTaggedTemplateExpression(base2, startPos, startLoc, state)
    }
    let optional = false
    if (type === 18) {
      if (noCalls && this.lookaheadCharCode() === 40) {
        state.stop = true
        return base2
      }
      state.optionalChainMember = optional = true
      this.next()
    }
    if (!noCalls && this.match(10)) {
      return this.parseCoverCallAndAsyncArrowHead(base2, startPos, startLoc, state, optional)
    } else {
      const computed2 = this.eat(0)
      if (computed2 || optional || this.eat(16)) {
        return this.parseMember(base2, startPos, startLoc, state, computed2, optional)
      } else {
        state.stop = true
        return base2
      }
    }
  }
  parseMember(base2, startPos, startLoc, state, computed2, optional) {
    const node2 = this.startNodeAt(startPos, startLoc)
    node2.object = base2
    node2.computed = computed2
    if (computed2) {
      node2.property = this.parseExpression()
      this.expect(3)
    } else if (this.match(134)) {
      if (base2.type === 'Super') {
        this.raise(Errors.SuperPrivateField, {
          at: startLoc,
        })
      }
      this.classScope.usePrivateName(this.state.value, this.state.startLoc)
      node2.property = this.parsePrivateName()
    } else {
      node2.property = this.parseIdentifier(true)
    }
    if (state.optionalChainMember) {
      node2.optional = optional
      return this.finishNode(node2, 'OptionalMemberExpression')
    } else {
      return this.finishNode(node2, 'MemberExpression')
    }
  }
  parseBind(base2, startPos, startLoc, noCalls, state) {
    const node2 = this.startNodeAt(startPos, startLoc)
    node2.object = base2
    this.next()
    node2.callee = this.parseNoCallExpr()
    state.stop = true
    return this.parseSubscripts(this.finishNode(node2, 'BindExpression'), startPos, startLoc, noCalls)
  }
  parseCoverCallAndAsyncArrowHead(base2, startPos, startLoc, state, optional) {
    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters
    let refExpressionErrors = null
    this.state.maybeInArrowParameters = true
    this.next()
    let node2 = this.startNodeAt(startPos, startLoc)
    node2.callee = base2
    const { maybeAsyncArrow, optionalChainMember } = state
    if (maybeAsyncArrow) {
      this.expressionScope.enter(newAsyncArrowScope())
      refExpressionErrors = new ExpressionErrors()
    }
    if (optionalChainMember) {
      node2.optional = optional
    }
    if (optional) {
      node2.arguments = this.parseCallExpressionArguments(11)
    } else {
      node2.arguments = this.parseCallExpressionArguments(
        11,
        base2.type === 'Import',
        base2.type !== 'Super',
        node2,
        refExpressionErrors
      )
    }
    this.finishCallExpression(node2, optionalChainMember)
    if (maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional) {
      state.stop = true
      this.checkDestructuringPrivate(refExpressionErrors)
      this.expressionScope.validateAsPattern()
      this.expressionScope.exit()
      node2 = this.parseAsyncArrowFromCallExpression(this.startNodeAt(startPos, startLoc), node2)
    } else {
      if (maybeAsyncArrow) {
        this.checkExpressionErrors(refExpressionErrors, true)
        this.expressionScope.exit()
      }
      this.toReferencedArguments(node2)
    }
    this.state.maybeInArrowParameters = oldMaybeInArrowParameters
    return node2
  }
  toReferencedArguments(node2, isParenthesizedExpr) {
    this.toReferencedListDeep(node2.arguments, isParenthesizedExpr)
  }
  parseTaggedTemplateExpression(base2, startPos, startLoc, state) {
    const node2 = this.startNodeAt(startPos, startLoc)
    node2.tag = base2
    node2.quasi = this.parseTemplate(true)
    if (state.optionalChainMember) {
      this.raise(Errors.OptionalChainingNoTemplate, {
        at: startLoc,
      })
    }
    return this.finishNode(node2, 'TaggedTemplateExpression')
  }
  atPossibleAsyncArrow(base2) {
    return (
      base2.type === 'Identifier' &&
      base2.name === 'async' &&
      this.state.lastTokEndLoc.index === base2.end &&
      !this.canInsertSemicolon() &&
      base2.end - base2.start === 5 &&
      base2.start === this.state.potentialArrowAt
    )
  }
  finishCallExpression(node2, optional) {
    if (node2.callee.type === 'Import') {
      if (node2.arguments.length === 2) {
        {
          if (!this.hasPlugin('moduleAttributes')) {
            this.expectPlugin('importAssertions')
          }
        }
      }
      if (node2.arguments.length === 0 || node2.arguments.length > 2) {
        this.raise(Errors.ImportCallArity, {
          at: node2,
          maxArgumentCount: this.hasPlugin('importAssertions') || this.hasPlugin('moduleAttributes') ? 2 : 1,
        })
      } else {
        for (const arg of node2.arguments) {
          if (arg.type === 'SpreadElement') {
            this.raise(Errors.ImportCallSpreadArgument, {
              at: arg,
            })
          }
        }
      }
    }
    return this.finishNode(node2, optional ? 'OptionalCallExpression' : 'CallExpression')
  }
  parseCallExpressionArguments(close, dynamicImport, allowPlaceholder, nodeForExtra, refExpressionErrors) {
    const elts = []
    let first = true
    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody
    this.state.inFSharpPipelineDirectBody = false
    while (!this.eat(close)) {
      if (first) {
        first = false
      } else {
        this.expect(12)
        if (this.match(close)) {
          if (dynamicImport && !this.hasPlugin('importAssertions') && !this.hasPlugin('moduleAttributes')) {
            this.raise(Errors.ImportCallArgumentTrailingComma, {
              at: this.state.lastTokStartLoc,
            })
          }
          if (nodeForExtra) {
            this.addTrailingCommaExtraToNode(nodeForExtra)
          }
          this.next()
          break
        }
      }
      elts.push(this.parseExprListItem(false, refExpressionErrors, allowPlaceholder))
    }
    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody
    return elts
  }
  shouldParseAsyncArrow() {
    return this.match(19) && !this.canInsertSemicolon()
  }
  parseAsyncArrowFromCallExpression(node2, call2) {
    var _call$extra
    this.resetPreviousNodeTrailingComments(call2)
    this.expect(19)
    this.parseArrowExpression(
      node2,
      call2.arguments,
      true,
      (_call$extra = call2.extra) == null ? void 0 : _call$extra.trailingCommaLoc
    )
    if (call2.innerComments) {
      setInnerComments(node2, call2.innerComments)
    }
    if (call2.callee.trailingComments) {
      setInnerComments(node2, call2.callee.trailingComments)
    }
    return node2
  }
  parseNoCallExpr() {
    const startPos = this.state.start
    const startLoc = this.state.startLoc
    return this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true)
  }
  parseExprAtom(refExpressionErrors) {
    let node2
    const { type } = this.state
    switch (type) {
      case 79:
        return this.parseSuper()
      case 83:
        node2 = this.startNode()
        this.next()
        if (this.match(16)) {
          return this.parseImportMetaProperty(node2)
        }
        if (!this.match(10)) {
          this.raise(Errors.UnsupportedImport, {
            at: this.state.lastTokStartLoc,
          })
        }
        return this.finishNode(node2, 'Import')
      case 78:
        node2 = this.startNode()
        this.next()
        return this.finishNode(node2, 'ThisExpression')
      case 90: {
        return this.parseDo(this.startNode(), false)
      }
      case 56:
      case 31: {
        this.readRegexp()
        return this.parseRegExpLiteral(this.state.value)
      }
      case 130:
        return this.parseNumericLiteral(this.state.value)
      case 131:
        return this.parseBigIntLiteral(this.state.value)
      case 132:
        return this.parseDecimalLiteral(this.state.value)
      case 129:
        return this.parseStringLiteral(this.state.value)
      case 84:
        return this.parseNullLiteral()
      case 85:
        return this.parseBooleanLiteral(true)
      case 86:
        return this.parseBooleanLiteral(false)
      case 10: {
        const canBeArrow = this.state.potentialArrowAt === this.state.start
        return this.parseParenAndDistinguishExpression(canBeArrow)
      }
      case 2:
      case 1: {
        return this.parseArrayLike(this.state.type === 2 ? 4 : 3, false, true)
      }
      case 0: {
        return this.parseArrayLike(3, true, false, refExpressionErrors)
      }
      case 6:
      case 7: {
        return this.parseObjectLike(this.state.type === 6 ? 9 : 8, false, true)
      }
      case 5: {
        return this.parseObjectLike(8, false, false, refExpressionErrors)
      }
      case 68:
        return this.parseFunctionOrFunctionSent()
      case 26:
        this.parseDecorators()
      case 80:
        node2 = this.startNode()
        this.takeDecorators(node2)
        return this.parseClass(node2, false)
      case 77:
        return this.parseNewOrNewTarget()
      case 25:
      case 24:
        return this.parseTemplate(false)
      case 15: {
        node2 = this.startNode()
        this.next()
        node2.object = null
        const callee = (node2.callee = this.parseNoCallExpr())
        if (callee.type === 'MemberExpression') {
          return this.finishNode(node2, 'BindExpression')
        } else {
          throw this.raise(Errors.UnsupportedBind, {
            at: callee,
          })
        }
      }
      case 134: {
        this.raise(Errors.PrivateInExpectedIn, {
          at: this.state.startLoc,
          identifierName: this.state.value,
        })
        return this.parsePrivateName()
      }
      case 33: {
        return this.parseTopicReferenceThenEqualsSign(54, '%')
      }
      case 32: {
        return this.parseTopicReferenceThenEqualsSign(44, '^')
      }
      case 37:
      case 38: {
        return this.parseTopicReference('hack')
      }
      case 44:
      case 54:
      case 27: {
        const pipeProposal = this.getPluginOption('pipelineOperator', 'proposal')
        if (pipeProposal) {
          return this.parseTopicReference(pipeProposal)
        } else {
          throw this.unexpected()
        }
      }
      case 47: {
        const lookaheadCh = this.input.codePointAt(this.nextTokenStart())
        if (isIdentifierStart(lookaheadCh) || lookaheadCh === 62) {
          this.expectOnePlugin(['jsx', 'flow', 'typescript'])
          break
        } else {
          throw this.unexpected()
        }
      }
      default:
        if (tokenIsIdentifier(type)) {
          if (this.isContextual(123) && this.lookaheadCharCode() === 123 && !this.hasFollowingLineBreak()) {
            return this.parseModuleExpression()
          }
          const canBeArrow = this.state.potentialArrowAt === this.state.start
          const containsEsc = this.state.containsEsc
          const id = this.parseIdentifier()
          if (!containsEsc && id.name === 'async' && !this.canInsertSemicolon()) {
            const { type: type2 } = this.state
            if (type2 === 68) {
              this.resetPreviousNodeTrailingComments(id)
              this.next()
              return this.parseFunction(this.startNodeAtNode(id), void 0, true)
            } else if (tokenIsIdentifier(type2)) {
              if (this.lookaheadCharCode() === 61) {
                return this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(id))
              } else {
                return id
              }
            } else if (type2 === 90) {
              this.resetPreviousNodeTrailingComments(id)
              return this.parseDo(this.startNodeAtNode(id), true)
            }
          }
          if (canBeArrow && this.match(19) && !this.canInsertSemicolon()) {
            this.next()
            return this.parseArrowExpression(this.startNodeAtNode(id), [id], false)
          }
          return id
        } else {
          throw this.unexpected()
        }
    }
  }
  parseTopicReferenceThenEqualsSign(topicTokenType, topicTokenValue) {
    const pipeProposal = this.getPluginOption('pipelineOperator', 'proposal')
    if (pipeProposal) {
      this.state.type = topicTokenType
      this.state.value = topicTokenValue
      this.state.pos--
      this.state.end--
      this.state.endLoc = createPositionWithColumnOffset(this.state.endLoc, -1)
      return this.parseTopicReference(pipeProposal)
    } else {
      throw this.unexpected()
    }
  }
  parseTopicReference(pipeProposal) {
    const node2 = this.startNode()
    const startLoc = this.state.startLoc
    const tokenType = this.state.type
    this.next()
    return this.finishTopicReference(node2, startLoc, pipeProposal, tokenType)
  }
  finishTopicReference(node2, startLoc, pipeProposal, tokenType) {
    if (this.testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType)) {
      const nodeType = pipeProposal === 'smart' ? 'PipelinePrimaryTopicReference' : 'TopicReference'
      if (!this.topicReferenceIsAllowedInCurrentContext()) {
        this.raise(pipeProposal === 'smart' ? Errors.PrimaryTopicNotAllowed : Errors.PipeTopicUnbound, {
          at: startLoc,
        })
      }
      this.registerTopicReference()
      return this.finishNode(node2, nodeType)
    } else {
      throw this.raise(Errors.PipeTopicUnconfiguredToken, {
        at: startLoc,
        token: tokenLabelName(tokenType),
      })
    }
  }
  testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType) {
    switch (pipeProposal) {
      case 'hack': {
        return this.hasPlugin([
          'pipelineOperator',
          {
            topicToken: tokenLabelName(tokenType),
          },
        ])
      }
      case 'smart':
        return tokenType === 27
      default:
        throw this.raise(Errors.PipeTopicRequiresHackPipes, {
          at: startLoc,
        })
    }
  }
  parseAsyncArrowUnaryFunction(node2) {
    this.prodParam.enter(functionFlags(true, this.prodParam.hasYield))
    const params = [this.parseIdentifier()]
    this.prodParam.exit()
    if (this.hasPrecedingLineBreak()) {
      this.raise(Errors.LineTerminatorBeforeArrow, {
        at: this.state.curPosition(),
      })
    }
    this.expect(19)
    this.parseArrowExpression(node2, params, true)
    return node2
  }
  parseDo(node2, isAsync) {
    this.expectPlugin('doExpressions')
    if (isAsync) {
      this.expectPlugin('asyncDoExpressions')
    }
    node2.async = isAsync
    this.next()
    const oldLabels = this.state.labels
    this.state.labels = []
    if (isAsync) {
      this.prodParam.enter(PARAM_AWAIT)
      node2.body = this.parseBlock()
      this.prodParam.exit()
    } else {
      node2.body = this.parseBlock()
    }
    this.state.labels = oldLabels
    return this.finishNode(node2, 'DoExpression')
  }
  parseSuper() {
    const node2 = this.startNode()
    this.next()
    if (this.match(10) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod) {
      this.raise(Errors.SuperNotAllowed, {
        at: node2,
      })
    } else if (!this.scope.allowSuper && !this.options.allowSuperOutsideMethod) {
      this.raise(Errors.UnexpectedSuper, {
        at: node2,
      })
    }
    if (!this.match(10) && !this.match(0) && !this.match(16)) {
      this.raise(Errors.UnsupportedSuper, {
        at: node2,
      })
    }
    return this.finishNode(node2, 'Super')
  }
  parsePrivateName() {
    const node2 = this.startNode()
    const id = this.startNodeAt(
      this.state.start + 1,
      new Position(this.state.curLine, this.state.start + 1 - this.state.lineStart, this.state.start + 1)
    )
    const name = this.state.value
    this.next()
    node2.id = this.createIdentifier(id, name)
    return this.finishNode(node2, 'PrivateName')
  }
  parseFunctionOrFunctionSent() {
    const node2 = this.startNode()
    this.next()
    if (this.prodParam.hasYield && this.match(16)) {
      const meta = this.createIdentifier(this.startNodeAtNode(node2), 'function')
      this.next()
      if (this.match(102)) {
        this.expectPlugin('functionSent')
      } else if (!this.hasPlugin('functionSent')) {
        this.unexpected()
      }
      return this.parseMetaProperty(node2, meta, 'sent')
    }
    return this.parseFunction(node2)
  }
  parseMetaProperty(node2, meta, propertyName) {
    node2.meta = meta
    const containsEsc = this.state.containsEsc
    node2.property = this.parseIdentifier(true)
    if (node2.property.name !== propertyName || containsEsc) {
      this.raise(Errors.UnsupportedMetaProperty, {
        at: node2.property,
        target: meta.name,
        onlyValidPropertyName: propertyName,
      })
    }
    return this.finishNode(node2, 'MetaProperty')
  }
  parseImportMetaProperty(node2) {
    const id = this.createIdentifier(this.startNodeAtNode(node2), 'import')
    this.next()
    if (this.isContextual(100)) {
      if (!this.inModule) {
        this.raise(Errors.ImportMetaOutsideModule, {
          at: id,
        })
      }
      this.sawUnambiguousESM = true
    }
    return this.parseMetaProperty(node2, id, 'meta')
  }
  parseLiteralAtNode(value, type, node2) {
    this.addExtra(node2, 'rawValue', value)
    this.addExtra(node2, 'raw', this.input.slice(node2.start, this.state.end))
    node2.value = value
    this.next()
    return this.finishNode(node2, type)
  }
  parseLiteral(value, type) {
    const node2 = this.startNode()
    return this.parseLiteralAtNode(value, type, node2)
  }
  parseStringLiteral(value) {
    return this.parseLiteral(value, 'StringLiteral')
  }
  parseNumericLiteral(value) {
    return this.parseLiteral(value, 'NumericLiteral')
  }
  parseBigIntLiteral(value) {
    return this.parseLiteral(value, 'BigIntLiteral')
  }
  parseDecimalLiteral(value) {
    return this.parseLiteral(value, 'DecimalLiteral')
  }
  parseRegExpLiteral(value) {
    const node2 = this.parseLiteral(value.value, 'RegExpLiteral')
    node2.pattern = value.pattern
    node2.flags = value.flags
    return node2
  }
  parseBooleanLiteral(value) {
    const node2 = this.startNode()
    node2.value = value
    this.next()
    return this.finishNode(node2, 'BooleanLiteral')
  }
  parseNullLiteral() {
    const node2 = this.startNode()
    this.next()
    return this.finishNode(node2, 'NullLiteral')
  }
  parseParenAndDistinguishExpression(canBeArrow) {
    const startPos = this.state.start
    const startLoc = this.state.startLoc
    let val
    this.next()
    this.expressionScope.enter(newArrowHeadScope())
    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters
    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody
    this.state.maybeInArrowParameters = true
    this.state.inFSharpPipelineDirectBody = false
    const innerStartPos = this.state.start
    const innerStartLoc = this.state.startLoc
    const exprList = []
    const refExpressionErrors = new ExpressionErrors()
    let first = true
    let spreadStartLoc
    let optionalCommaStartLoc
    while (!this.match(11)) {
      if (first) {
        first = false
      } else {
        this.expect(
          12,
          refExpressionErrors.optionalParametersLoc === null ? null : refExpressionErrors.optionalParametersLoc
        )
        if (this.match(11)) {
          optionalCommaStartLoc = this.state.startLoc
          break
        }
      }
      if (this.match(21)) {
        const spreadNodeStartPos = this.state.start
        const spreadNodeStartLoc = this.state.startLoc
        spreadStartLoc = this.state.startLoc
        exprList.push(this.parseParenItem(this.parseRestBinding(), spreadNodeStartPos, spreadNodeStartLoc))
        if (!this.checkCommaAfterRest(41)) {
          break
        }
      } else {
        exprList.push(this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem))
      }
    }
    const innerEndLoc = this.state.lastTokEndLoc
    this.expect(11)
    this.state.maybeInArrowParameters = oldMaybeInArrowParameters
    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody
    let arrowNode = this.startNodeAt(startPos, startLoc)
    if (canBeArrow && this.shouldParseArrow(exprList) && (arrowNode = this.parseArrow(arrowNode))) {
      this.checkDestructuringPrivate(refExpressionErrors)
      this.expressionScope.validateAsPattern()
      this.expressionScope.exit()
      this.parseArrowExpression(arrowNode, exprList, false)
      return arrowNode
    }
    this.expressionScope.exit()
    if (!exprList.length) {
      this.unexpected(this.state.lastTokStartLoc)
    }
    if (optionalCommaStartLoc) this.unexpected(optionalCommaStartLoc)
    if (spreadStartLoc) this.unexpected(spreadStartLoc)
    this.checkExpressionErrors(refExpressionErrors, true)
    this.toReferencedListDeep(exprList, true)
    if (exprList.length > 1) {
      val = this.startNodeAt(innerStartPos, innerStartLoc)
      val.expressions = exprList
      this.finishNode(val, 'SequenceExpression')
      this.resetEndLocation(val, innerEndLoc)
    } else {
      val = exprList[0]
    }
    return this.wrapParenthesis(startPos, startLoc, val)
  }
  wrapParenthesis(startPos, startLoc, expression2) {
    if (!this.options.createParenthesizedExpressions) {
      this.addExtra(expression2, 'parenthesized', true)
      this.addExtra(expression2, 'parenStart', startPos)
      this.takeSurroundingComments(expression2, startPos, this.state.lastTokEndLoc.index)
      return expression2
    }
    const parenExpression = this.startNodeAt(startPos, startLoc)
    parenExpression.expression = expression2
    this.finishNode(parenExpression, 'ParenthesizedExpression')
    return parenExpression
  }
  shouldParseArrow(params) {
    return !this.canInsertSemicolon()
  }
  parseArrow(node2) {
    if (this.eat(19)) {
      return node2
    }
  }
  parseParenItem(node2, startPos, startLoc) {
    return node2
  }
  parseNewOrNewTarget() {
    const node2 = this.startNode()
    this.next()
    if (this.match(16)) {
      const meta = this.createIdentifier(this.startNodeAtNode(node2), 'new')
      this.next()
      const metaProp = this.parseMetaProperty(node2, meta, 'target')
      if (!this.scope.inNonArrowFunction && !this.scope.inClass) {
        this.raise(Errors.UnexpectedNewTarget, {
          at: metaProp,
        })
      }
      return metaProp
    }
    return this.parseNew(node2)
  }
  parseNew(node2) {
    this.parseNewCallee(node2)
    if (this.eat(10)) {
      const args = this.parseExprList(11)
      this.toReferencedList(args)
      node2.arguments = args
    } else {
      node2.arguments = []
    }
    return this.finishNode(node2, 'NewExpression')
  }
  parseNewCallee(node2) {
    node2.callee = this.parseNoCallExpr()
    if (node2.callee.type === 'Import') {
      this.raise(Errors.ImportCallNotNewExpression, {
        at: node2.callee,
      })
    } else if (this.isOptionalChain(node2.callee)) {
      this.raise(Errors.OptionalChainingNoNew, {
        at: this.state.lastTokEndLoc,
      })
    } else if (this.eat(18)) {
      this.raise(Errors.OptionalChainingNoNew, {
        at: this.state.startLoc,
      })
    }
  }
  parseTemplateElement(isTagged) {
    const { start, startLoc, end, value } = this.state
    const elemStart = start + 1
    const elem = this.startNodeAt(elemStart, createPositionWithColumnOffset(startLoc, 1))
    if (value === null) {
      if (!isTagged) {
        this.raise(Errors.InvalidEscapeSequenceTemplate, {
          at: createPositionWithColumnOffset(startLoc, 2),
        })
      }
    }
    const isTail = this.match(24)
    const endOffset = isTail ? -1 : -2
    const elemEnd = end + endOffset
    elem.value = {
      raw: this.input.slice(elemStart, elemEnd).replace(/\r\n?/g, '\n'),
      cooked: value === null ? null : value.slice(1, endOffset),
    }
    elem.tail = isTail
    this.next()
    this.finishNode(elem, 'TemplateElement')
    this.resetEndLocation(elem, createPositionWithColumnOffset(this.state.lastTokEndLoc, endOffset))
    return elem
  }
  parseTemplate(isTagged) {
    const node2 = this.startNode()
    node2.expressions = []
    let curElt = this.parseTemplateElement(isTagged)
    node2.quasis = [curElt]
    while (!curElt.tail) {
      node2.expressions.push(this.parseTemplateSubstitution())
      this.readTemplateContinuation()
      node2.quasis.push((curElt = this.parseTemplateElement(isTagged)))
    }
    return this.finishNode(node2, 'TemplateLiteral')
  }
  parseTemplateSubstitution() {
    return this.parseExpression()
  }
  parseObjectLike(close, isPattern2, isRecord, refExpressionErrors) {
    if (isRecord) {
      this.expectPlugin('recordAndTuple')
    }
    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody
    this.state.inFSharpPipelineDirectBody = false
    const propHash = /* @__PURE__ */ Object.create(null)
    let first = true
    const node2 = this.startNode()
    node2.properties = []
    this.next()
    while (!this.match(close)) {
      if (first) {
        first = false
      } else {
        this.expect(12)
        if (this.match(close)) {
          this.addTrailingCommaExtraToNode(node2)
          break
        }
      }
      let prop
      if (isPattern2) {
        prop = this.parseBindingProperty()
      } else {
        prop = this.parsePropertyDefinition(refExpressionErrors)
        this.checkProto(prop, isRecord, propHash, refExpressionErrors)
      }
      if (isRecord && !this.isObjectProperty(prop) && prop.type !== 'SpreadElement') {
        this.raise(Errors.InvalidRecordProperty, {
          at: prop,
        })
      }
      if (prop.shorthand) {
        this.addExtra(prop, 'shorthand', true)
      }
      node2.properties.push(prop)
    }
    this.next()
    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody
    let type = 'ObjectExpression'
    if (isPattern2) {
      type = 'ObjectPattern'
    } else if (isRecord) {
      type = 'RecordExpression'
    }
    return this.finishNode(node2, type)
  }
  addTrailingCommaExtraToNode(node2) {
    this.addExtra(node2, 'trailingComma', this.state.lastTokStart)
    this.addExtra(node2, 'trailingCommaLoc', this.state.lastTokStartLoc, false)
  }
  maybeAsyncOrAccessorProp(prop) {
    return (
      !prop.computed &&
      prop.key.type === 'Identifier' &&
      (this.isLiteralPropertyName() || this.match(0) || this.match(55))
    )
  }
  parsePropertyDefinition(refExpressionErrors) {
    let decorators = []
    if (this.match(26)) {
      if (this.hasPlugin('decorators')) {
        this.raise(Errors.UnsupportedPropertyDecorator, {
          at: this.state.startLoc,
        })
      }
      while (this.match(26)) {
        decorators.push(this.parseDecorator())
      }
    }
    const prop = this.startNode()
    let isAsync = false
    let isAccessor2 = false
    let startPos
    let startLoc
    if (this.match(21)) {
      if (decorators.length) this.unexpected()
      return this.parseSpread()
    }
    if (decorators.length) {
      prop.decorators = decorators
      decorators = []
    }
    prop.method = false
    if (refExpressionErrors) {
      startPos = this.state.start
      startLoc = this.state.startLoc
    }
    let isGenerator = this.eat(55)
    this.parsePropertyNamePrefixOperator(prop)
    const containsEsc = this.state.containsEsc
    const key = this.parsePropertyName(prop, refExpressionErrors)
    if (!isGenerator && !containsEsc && this.maybeAsyncOrAccessorProp(prop)) {
      const keyName = key.name
      if (keyName === 'async' && !this.hasPrecedingLineBreak()) {
        isAsync = true
        this.resetPreviousNodeTrailingComments(key)
        isGenerator = this.eat(55)
        this.parsePropertyName(prop)
      }
      if (keyName === 'get' || keyName === 'set') {
        isAccessor2 = true
        this.resetPreviousNodeTrailingComments(key)
        prop.kind = keyName
        if (this.match(55)) {
          isGenerator = true
          this.raise(Errors.AccessorIsGenerator, {
            at: this.state.curPosition(),
            kind: keyName,
          })
          this.next()
        }
        this.parsePropertyName(prop)
      }
    }
    this.parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, false, isAccessor2, refExpressionErrors)
    return prop
  }
  getGetterSetterExpectedParamCount(method) {
    return method.kind === 'get' ? 0 : 1
  }
  getObjectOrClassMethodParams(method) {
    return method.params
  }
  checkGetterSetterParams(method) {
    var _params2
    const paramCount = this.getGetterSetterExpectedParamCount(method)
    const params = this.getObjectOrClassMethodParams(method)
    if (params.length !== paramCount) {
      this.raise(method.kind === 'get' ? Errors.BadGetterArity : Errors.BadSetterArity, {
        at: method,
      })
    }
    if (
      method.kind === 'set' &&
      ((_params2 = params[params.length - 1]) == null ? void 0 : _params2.type) === 'RestElement'
    ) {
      this.raise(Errors.BadSetterRestParameter, {
        at: method,
      })
    }
  }
  parseObjectMethod(prop, isGenerator, isAsync, isPattern2, isAccessor2) {
    if (isAccessor2) {
      this.parseMethod(prop, isGenerator, false, false, false, 'ObjectMethod')
      this.checkGetterSetterParams(prop)
      return prop
    }
    if (isAsync || isGenerator || this.match(10)) {
      if (isPattern2) this.unexpected()
      prop.kind = 'method'
      prop.method = true
      return this.parseMethod(prop, isGenerator, isAsync, false, false, 'ObjectMethod')
    }
  }
  parseObjectProperty(prop, startPos, startLoc, isPattern2, refExpressionErrors) {
    prop.shorthand = false
    if (this.eat(14)) {
      prop.value = isPattern2
        ? this.parseMaybeDefault(this.state.start, this.state.startLoc)
        : this.parseMaybeAssignAllowIn(refExpressionErrors)
      return this.finishNode(prop, 'ObjectProperty')
    }
    if (!prop.computed && prop.key.type === 'Identifier') {
      this.checkReservedWord(prop.key.name, prop.key.loc.start, true, false)
      if (isPattern2) {
        prop.value = this.parseMaybeDefault(startPos, startLoc, cloneIdentifier(prop.key))
      } else if (this.match(29)) {
        const shorthandAssignLoc = this.state.startLoc
        if (refExpressionErrors != null) {
          if (refExpressionErrors.shorthandAssignLoc === null) {
            refExpressionErrors.shorthandAssignLoc = shorthandAssignLoc
          }
        } else {
          this.raise(Errors.InvalidCoverInitializedName, {
            at: shorthandAssignLoc,
          })
        }
        prop.value = this.parseMaybeDefault(startPos, startLoc, cloneIdentifier(prop.key))
      } else {
        prop.value = cloneIdentifier(prop.key)
      }
      prop.shorthand = true
      return this.finishNode(prop, 'ObjectProperty')
    }
  }
  parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern2, isAccessor2, refExpressionErrors) {
    const node2 =
      this.parseObjectMethod(prop, isGenerator, isAsync, isPattern2, isAccessor2) ||
      this.parseObjectProperty(prop, startPos, startLoc, isPattern2, refExpressionErrors)
    if (!node2) this.unexpected()
    return node2
  }
  parsePropertyName(prop, refExpressionErrors) {
    if (this.eat(0)) {
      prop.computed = true
      prop.key = this.parseMaybeAssignAllowIn()
      this.expect(3)
    } else {
      const { type, value } = this.state
      let key
      if (tokenIsKeywordOrIdentifier(type)) {
        key = this.parseIdentifier(true)
      } else {
        switch (type) {
          case 130:
            key = this.parseNumericLiteral(value)
            break
          case 129:
            key = this.parseStringLiteral(value)
            break
          case 131:
            key = this.parseBigIntLiteral(value)
            break
          case 132:
            key = this.parseDecimalLiteral(value)
            break
          case 134: {
            const privateKeyLoc = this.state.startLoc
            if (refExpressionErrors != null) {
              if (refExpressionErrors.privateKeyLoc === null) {
                refExpressionErrors.privateKeyLoc = privateKeyLoc
              }
            } else {
              this.raise(Errors.UnexpectedPrivateField, {
                at: privateKeyLoc,
              })
            }
            key = this.parsePrivateName()
            break
          }
          default:
            throw this.unexpected()
        }
      }
      prop.key = key
      if (type !== 134) {
        prop.computed = false
      }
    }
    return prop.key
  }
  initFunction(node2, isAsync) {
    node2.id = null
    node2.generator = false
    node2.async = !!isAsync
  }
  parseMethod(node2, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {
    this.initFunction(node2, isAsync)
    node2.generator = !!isGenerator
    const allowModifiers = isConstructor
    this.scope.enter(
      SCOPE_FUNCTION | SCOPE_SUPER | (inClassScope ? SCOPE_CLASS : 0) | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0)
    )
    this.prodParam.enter(functionFlags(isAsync, node2.generator))
    this.parseFunctionParams(node2, allowModifiers)
    this.parseFunctionBodyAndFinish(node2, type, true)
    this.prodParam.exit()
    this.scope.exit()
    return node2
  }
  parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
    if (isTuple) {
      this.expectPlugin('recordAndTuple')
    }
    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody
    this.state.inFSharpPipelineDirectBody = false
    const node2 = this.startNode()
    this.next()
    node2.elements = this.parseExprList(close, !isTuple, refExpressionErrors, node2)
    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody
    return this.finishNode(node2, isTuple ? 'TupleExpression' : 'ArrayExpression')
  }
  parseArrowExpression(node2, params, isAsync, trailingCommaLoc) {
    this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW)
    let flags = functionFlags(isAsync, false)
    if (!this.match(5) && this.prodParam.hasIn) {
      flags |= PARAM_IN
    }
    this.prodParam.enter(flags)
    this.initFunction(node2, isAsync)
    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters
    if (params) {
      this.state.maybeInArrowParameters = true
      this.setArrowFunctionParameters(node2, params, trailingCommaLoc)
    }
    this.state.maybeInArrowParameters = false
    this.parseFunctionBody(node2, true)
    this.prodParam.exit()
    this.scope.exit()
    this.state.maybeInArrowParameters = oldMaybeInArrowParameters
    return this.finishNode(node2, 'ArrowFunctionExpression')
  }
  setArrowFunctionParameters(node2, params, trailingCommaLoc) {
    this.toAssignableList(params, trailingCommaLoc, false)
    node2.params = params
  }
  parseFunctionBodyAndFinish(node2, type, isMethod2 = false) {
    this.parseFunctionBody(node2, false, isMethod2)
    this.finishNode(node2, type)
  }
  parseFunctionBody(node2, allowExpression, isMethod2 = false) {
    const isExpression2 = allowExpression && !this.match(5)
    this.expressionScope.enter(newExpressionScope())
    if (isExpression2) {
      node2.body = this.parseMaybeAssign()
      this.checkParams(node2, false, allowExpression, false)
    } else {
      const oldStrict = this.state.strict
      const oldLabels = this.state.labels
      this.state.labels = []
      this.prodParam.enter(this.prodParam.currentFlags() | PARAM_RETURN)
      node2.body = this.parseBlock(true, false, (hasStrictModeDirective) => {
        const nonSimple = !this.isSimpleParamList(node2.params)
        if (hasStrictModeDirective && nonSimple) {
          this.raise(Errors.IllegalLanguageModeDirective, {
            at: (node2.kind === 'method' || node2.kind === 'constructor') && !!node2.key ? node2.key.loc.end : node2,
          })
        }
        const strictModeChanged = !oldStrict && this.state.strict
        this.checkParams(
          node2,
          !this.state.strict && !allowExpression && !isMethod2 && !nonSimple,
          allowExpression,
          strictModeChanged
        )
        if (this.state.strict && node2.id) {
          this.checkIdentifier(node2.id, BIND_OUTSIDE, strictModeChanged)
        }
      })
      this.prodParam.exit()
      this.state.labels = oldLabels
    }
    this.expressionScope.exit()
  }
  isSimpleParameter(node2) {
    return node2.type === 'Identifier'
  }
  isSimpleParamList(params) {
    for (let i = 0, len = params.length; i < len; i++) {
      if (!this.isSimpleParameter(params[i])) return false
    }
    return true
  }
  checkParams(node2, allowDuplicates, isArrowFunction, strictModeChanged = true) {
    const checkClashes = !allowDuplicates && /* @__PURE__ */ new Set()
    const formalParameters = {
      type: 'FormalParameters',
    }
    for (const param of node2.params) {
      this.checkLVal(param, {
        in: formalParameters,
        binding: BIND_VAR,
        checkClashes,
        strictModeChanged,
      })
    }
  }
  parseExprList(close, allowEmpty, refExpressionErrors, nodeForExtra) {
    const elts = []
    let first = true
    while (!this.eat(close)) {
      if (first) {
        first = false
      } else {
        this.expect(12)
        if (this.match(close)) {
          if (nodeForExtra) {
            this.addTrailingCommaExtraToNode(nodeForExtra)
          }
          this.next()
          break
        }
      }
      elts.push(this.parseExprListItem(allowEmpty, refExpressionErrors))
    }
    return elts
  }
  parseExprListItem(allowEmpty, refExpressionErrors, allowPlaceholder) {
    let elt
    if (this.match(12)) {
      if (!allowEmpty) {
        this.raise(Errors.UnexpectedToken, {
          at: this.state.curPosition(),
          unexpected: ',',
        })
      }
      elt = null
    } else if (this.match(21)) {
      const spreadNodeStartPos = this.state.start
      const spreadNodeStartLoc = this.state.startLoc
      elt = this.parseParenItem(this.parseSpread(refExpressionErrors), spreadNodeStartPos, spreadNodeStartLoc)
    } else if (this.match(17)) {
      this.expectPlugin('partialApplication')
      if (!allowPlaceholder) {
        this.raise(Errors.UnexpectedArgumentPlaceholder, {
          at: this.state.startLoc,
        })
      }
      const node2 = this.startNode()
      this.next()
      elt = this.finishNode(node2, 'ArgumentPlaceholder')
    } else {
      elt = this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem)
    }
    return elt
  }
  parseIdentifier(liberal) {
    const node2 = this.startNode()
    const name = this.parseIdentifierName(node2.start, liberal)
    return this.createIdentifier(node2, name)
  }
  createIdentifier(node2, name) {
    node2.name = name
    node2.loc.identifierName = name
    return this.finishNode(node2, 'Identifier')
  }
  parseIdentifierName(pos, liberal) {
    let name
    const { startLoc, type } = this.state
    if (tokenIsKeywordOrIdentifier(type)) {
      name = this.state.value
    } else {
      throw this.unexpected()
    }
    const tokenIsKeyword2 = tokenKeywordOrIdentifierIsKeyword(type)
    if (liberal) {
      if (tokenIsKeyword2) {
        this.replaceToken(128)
      }
    } else {
      this.checkReservedWord(name, startLoc, tokenIsKeyword2, false)
    }
    this.next()
    return name
  }
  checkReservedWord(word, startLoc, checkKeywords, isBinding2) {
    if (word.length > 10) {
      return
    }
    if (!canBeReservedWord(word)) {
      return
    }
    if (word === 'yield') {
      if (this.prodParam.hasYield) {
        this.raise(Errors.YieldBindingIdentifier, {
          at: startLoc,
        })
        return
      }
    } else if (word === 'await') {
      if (this.prodParam.hasAwait) {
        this.raise(Errors.AwaitBindingIdentifier, {
          at: startLoc,
        })
        return
      }
      if (this.scope.inStaticBlock) {
        this.raise(Errors.AwaitBindingIdentifierInStaticBlock, {
          at: startLoc,
        })
        return
      }
      this.expressionScope.recordAsyncArrowParametersError({
        at: startLoc,
      })
    } else if (word === 'arguments') {
      if (this.scope.inClassAndNotInNonArrowFunction) {
        this.raise(Errors.ArgumentsInClass, {
          at: startLoc,
        })
        return
      }
    }
    if (checkKeywords && isKeyword(word)) {
      this.raise(Errors.UnexpectedKeyword, {
        at: startLoc,
        keyword: word,
      })
      return
    }
    const reservedTest = !this.state.strict
      ? isReservedWord
      : isBinding2
      ? isStrictBindReservedWord
      : isStrictReservedWord
    if (reservedTest(word, this.inModule)) {
      this.raise(Errors.UnexpectedReservedWord, {
        at: startLoc,
        reservedWord: word,
      })
    }
  }
  isAwaitAllowed() {
    if (this.prodParam.hasAwait) return true
    if (this.options.allowAwaitOutsideFunction && !this.scope.inFunction) {
      return true
    }
    return false
  }
  parseAwait(startPos, startLoc) {
    const node2 = this.startNodeAt(startPos, startLoc)
    this.expressionScope.recordParameterInitializerError(Errors.AwaitExpressionFormalParameter, {
      at: node2,
    })
    if (this.eat(55)) {
      this.raise(Errors.ObsoleteAwaitStar, {
        at: node2,
      })
    }
    if (!this.scope.inFunction && !this.options.allowAwaitOutsideFunction) {
      if (this.isAmbiguousAwait()) {
        this.ambiguousScriptDifferentAst = true
      } else {
        this.sawUnambiguousESM = true
      }
    }
    if (!this.state.soloAwait) {
      node2.argument = this.parseMaybeUnary(null, true)
    }
    return this.finishNode(node2, 'AwaitExpression')
  }
  isAmbiguousAwait() {
    if (this.hasPrecedingLineBreak()) return true
    const { type } = this.state
    return (
      type === 53 ||
      type === 10 ||
      type === 0 ||
      tokenIsTemplate(type) ||
      type === 133 ||
      type === 56 ||
      (this.hasPlugin('v8intrinsic') && type === 54)
    )
  }
  parseYield() {
    const node2 = this.startNode()
    this.expressionScope.recordParameterInitializerError(Errors.YieldInParameter, {
      at: node2,
    })
    this.next()
    let delegating = false
    let argument = null
    if (!this.hasPrecedingLineBreak()) {
      delegating = this.eat(55)
      switch (this.state.type) {
        case 13:
        case 135:
        case 8:
        case 11:
        case 3:
        case 9:
        case 14:
        case 12:
          if (!delegating) break
        default:
          argument = this.parseMaybeAssign()
      }
    }
    node2.delegate = delegating
    node2.argument = argument
    return this.finishNode(node2, 'YieldExpression')
  }
  checkPipelineAtInfixOperator(left, leftStartLoc) {
    if (
      this.hasPlugin([
        'pipelineOperator',
        {
          proposal: 'smart',
        },
      ])
    ) {
      if (left.type === 'SequenceExpression') {
        this.raise(Errors.PipelineHeadSequenceExpression, {
          at: leftStartLoc,
        })
      }
    }
  }
  parseSmartPipelineBodyInStyle(childExpr, startPos, startLoc) {
    const bodyNode = this.startNodeAt(startPos, startLoc)
    if (this.isSimpleReference(childExpr)) {
      bodyNode.callee = childExpr
      return this.finishNode(bodyNode, 'PipelineBareFunction')
    } else {
      this.checkSmartPipeTopicBodyEarlyErrors(startLoc)
      bodyNode.expression = childExpr
      return this.finishNode(bodyNode, 'PipelineTopicExpression')
    }
  }
  isSimpleReference(expression2) {
    switch (expression2.type) {
      case 'MemberExpression':
        return !expression2.computed && this.isSimpleReference(expression2.object)
      case 'Identifier':
        return true
      default:
        return false
    }
  }
  checkSmartPipeTopicBodyEarlyErrors(startLoc) {
    if (this.match(19)) {
      throw this.raise(Errors.PipelineBodyNoArrow, {
        at: this.state.startLoc,
      })
    }
    if (!this.topicReferenceWasUsedInCurrentContext()) {
      this.raise(Errors.PipelineTopicUnused, {
        at: startLoc,
      })
    }
  }
  withTopicBindingContext(callback) {
    const outerContextTopicState = this.state.topicContext
    this.state.topicContext = {
      maxNumOfResolvableTopics: 1,
      maxTopicIndex: null,
    }
    try {
      return callback()
    } finally {
      this.state.topicContext = outerContextTopicState
    }
  }
  withSmartMixTopicForbiddingContext(callback) {
    if (
      this.hasPlugin([
        'pipelineOperator',
        {
          proposal: 'smart',
        },
      ])
    ) {
      const outerContextTopicState = this.state.topicContext
      this.state.topicContext = {
        maxNumOfResolvableTopics: 0,
        maxTopicIndex: null,
      }
      try {
        return callback()
      } finally {
        this.state.topicContext = outerContextTopicState
      }
    } else {
      return callback()
    }
  }
  withSoloAwaitPermittingContext(callback) {
    const outerContextSoloAwaitState = this.state.soloAwait
    this.state.soloAwait = true
    try {
      return callback()
    } finally {
      this.state.soloAwait = outerContextSoloAwaitState
    }
  }
  allowInAnd(callback) {
    const flags = this.prodParam.currentFlags()
    const prodParamToSet = PARAM_IN & ~flags
    if (prodParamToSet) {
      this.prodParam.enter(flags | PARAM_IN)
      try {
        return callback()
      } finally {
        this.prodParam.exit()
      }
    }
    return callback()
  }
  disallowInAnd(callback) {
    const flags = this.prodParam.currentFlags()
    const prodParamToClear = PARAM_IN & flags
    if (prodParamToClear) {
      this.prodParam.enter(flags & ~PARAM_IN)
      try {
        return callback()
      } finally {
        this.prodParam.exit()
      }
    }
    return callback()
  }
  registerTopicReference() {
    this.state.topicContext.maxTopicIndex = 0
  }
  topicReferenceIsAllowedInCurrentContext() {
    return this.state.topicContext.maxNumOfResolvableTopics >= 1
  }
  topicReferenceWasUsedInCurrentContext() {
    return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0
  }
  parseFSharpPipelineBody(prec) {
    const startPos = this.state.start
    const startLoc = this.state.startLoc
    this.state.potentialArrowAt = this.state.start
    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody
    this.state.inFSharpPipelineDirectBody = true
    const ret = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startPos, startLoc, prec)
    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody
    return ret
  }
  parseModuleExpression() {
    this.expectPlugin('moduleBlocks')
    const node2 = this.startNode()
    this.next()
    this.eat(5)
    const revertScopes = this.initializeScopes(true)
    this.enterInitialScopes()
    const program2 = this.startNode()
    try {
      node2.body = this.parseProgram(program2, 8, 'module')
    } finally {
      revertScopes()
    }
    this.eat(8)
    return this.finishNode(node2, 'ModuleExpression')
  }
  parsePropertyNamePrefixOperator(prop) {}
}
const loopLabel = {
    kind: 'loop',
  },
  switchLabel = {
    kind: 'switch',
  }
const FUNC_NO_FLAGS = 0,
  FUNC_STATEMENT = 1,
  FUNC_HANGING_STATEMENT = 2,
  FUNC_NULLABLE_ID = 4
const loneSurrogate = /[\uD800-\uDFFF]/u
const keywordRelationalOperator = /in(?:stanceof)?/y
function babel7CompatTokens(tokens, input) {
  for (let i = 0; i < tokens.length; i++) {
    const token = tokens[i]
    const { type } = token
    if (typeof type === 'number') {
      {
        if (type === 134) {
          const { loc, start, value, end } = token
          const hashEndPos = start + 1
          const hashEndLoc = createPositionWithColumnOffset(loc.start, 1)
          tokens.splice(
            i,
            1,
            new Token({
              type: getExportedToken(27),
              value: '#',
              start,
              end: hashEndPos,
              startLoc: loc.start,
              endLoc: hashEndLoc,
            }),
            new Token({
              type: getExportedToken(128),
              value,
              start: hashEndPos,
              end,
              startLoc: hashEndLoc,
              endLoc: loc.end,
            })
          )
          i++
          continue
        }
        if (tokenIsTemplate(type)) {
          const { loc, start, value, end } = token
          const backquoteEnd = start + 1
          const backquoteEndLoc = createPositionWithColumnOffset(loc.start, 1)
          let startToken
          if (input.charCodeAt(start) === 96) {
            startToken = new Token({
              type: getExportedToken(22),
              value: '`',
              start,
              end: backquoteEnd,
              startLoc: loc.start,
              endLoc: backquoteEndLoc,
            })
          } else {
            startToken = new Token({
              type: getExportedToken(8),
              value: '}',
              start,
              end: backquoteEnd,
              startLoc: loc.start,
              endLoc: backquoteEndLoc,
            })
          }
          let templateValue, templateElementEnd, templateElementEndLoc, endToken
          if (type === 24) {
            templateElementEnd = end - 1
            templateElementEndLoc = createPositionWithColumnOffset(loc.end, -1)
            templateValue = value === null ? null : value.slice(1, -1)
            endToken = new Token({
              type: getExportedToken(22),
              value: '`',
              start: templateElementEnd,
              end,
              startLoc: templateElementEndLoc,
              endLoc: loc.end,
            })
          } else {
            templateElementEnd = end - 2
            templateElementEndLoc = createPositionWithColumnOffset(loc.end, -2)
            templateValue = value === null ? null : value.slice(1, -2)
            endToken = new Token({
              type: getExportedToken(23),
              value: '${',
              start: templateElementEnd,
              end,
              startLoc: templateElementEndLoc,
              endLoc: loc.end,
            })
          }
          tokens.splice(
            i,
            1,
            startToken,
            new Token({
              type: getExportedToken(20),
              value: templateValue,
              start: backquoteEnd,
              end: templateElementEnd,
              startLoc: backquoteEndLoc,
              endLoc: templateElementEndLoc,
            }),
            endToken
          )
          i += 2
          continue
        }
      }
      token.type = getExportedToken(type)
    }
  }
  return tokens
}
class StatementParser extends ExpressionParser {
  parseTopLevel(file2, program2) {
    file2.program = this.parseProgram(program2)
    file2.comments = this.state.comments
    if (this.options.tokens) {
      file2.tokens = babel7CompatTokens(this.tokens, this.input)
    }
    return this.finishNode(file2, 'File')
  }
  parseProgram(program2, end = 135, sourceType = this.options.sourceType) {
    program2.sourceType = sourceType
    program2.interpreter = this.parseInterpreterDirective()
    this.parseBlockBody(program2, true, true, end)
    if (this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0) {
      for (const [localName, at] of Array.from(this.scope.undefinedExports)) {
        this.raise(Errors.ModuleExportUndefined, {
          at,
          localName,
        })
      }
    }
    return this.finishNode(program2, 'Program')
  }
  stmtToDirective(stmt) {
    const directive2 = stmt
    directive2.type = 'Directive'
    directive2.value = directive2.expression
    delete directive2.expression
    const directiveLiteral2 = directive2.value
    const expressionValue = directiveLiteral2.value
    const raw = this.input.slice(directiveLiteral2.start, directiveLiteral2.end)
    const val = (directiveLiteral2.value = raw.slice(1, -1))
    this.addExtra(directiveLiteral2, 'raw', raw)
    this.addExtra(directiveLiteral2, 'rawValue', val)
    this.addExtra(directiveLiteral2, 'expressionValue', expressionValue)
    directiveLiteral2.type = 'DirectiveLiteral'
    return directive2
  }
  parseInterpreterDirective() {
    if (!this.match(28)) {
      return null
    }
    const node2 = this.startNode()
    node2.value = this.state.value
    this.next()
    return this.finishNode(node2, 'InterpreterDirective')
  }
  isLet(context2) {
    if (!this.isContextual(99)) {
      return false
    }
    return this.isLetKeyword(context2)
  }
  isLetKeyword(context2) {
    const next = this.nextTokenStart()
    const nextCh = this.codePointAtPos(next)
    if (nextCh === 92 || nextCh === 91) {
      return true
    }
    if (context2) return false
    if (nextCh === 123) return true
    if (isIdentifierStart(nextCh)) {
      keywordRelationalOperator.lastIndex = next
      if (keywordRelationalOperator.test(this.input)) {
        const endCh = this.codePointAtPos(keywordRelationalOperator.lastIndex)
        if (!isIdentifierChar(endCh) && endCh !== 92) {
          return false
        }
      }
      return true
    }
    return false
  }
  parseStatement(context2, topLevel) {
    if (this.match(26)) {
      this.parseDecorators(true)
    }
    return this.parseStatementContent(context2, topLevel)
  }
  parseStatementContent(context2, topLevel) {
    let starttype = this.state.type
    const node2 = this.startNode()
    let kind
    if (this.isLet(context2)) {
      starttype = 74
      kind = 'let'
    }
    switch (starttype) {
      case 60:
        return this.parseBreakContinueStatement(node2, true)
      case 63:
        return this.parseBreakContinueStatement(node2, false)
      case 64:
        return this.parseDebuggerStatement(node2)
      case 90:
        return this.parseDoStatement(node2)
      case 91:
        return this.parseForStatement(node2)
      case 68:
        if (this.lookaheadCharCode() === 46) break
        if (context2) {
          if (this.state.strict) {
            this.raise(Errors.StrictFunction, {
              at: this.state.startLoc,
            })
          } else if (context2 !== 'if' && context2 !== 'label') {
            this.raise(Errors.SloppyFunction, {
              at: this.state.startLoc,
            })
          }
        }
        return this.parseFunctionStatement(node2, false, !context2)
      case 80:
        if (context2) this.unexpected()
        return this.parseClass(node2, true)
      case 69:
        return this.parseIfStatement(node2)
      case 70:
        return this.parseReturnStatement(node2)
      case 71:
        return this.parseSwitchStatement(node2)
      case 72:
        return this.parseThrowStatement(node2)
      case 73:
        return this.parseTryStatement(node2)
      case 75:
      case 74:
        kind = kind || this.state.value
        if (context2 && kind !== 'var') {
          this.raise(Errors.UnexpectedLexicalDeclaration, {
            at: this.state.startLoc,
          })
        }
        return this.parseVarStatement(node2, kind)
      case 92:
        return this.parseWhileStatement(node2)
      case 76:
        return this.parseWithStatement(node2)
      case 5:
        return this.parseBlock()
      case 13:
        return this.parseEmptyStatement(node2)
      case 83: {
        const nextTokenCharCode = this.lookaheadCharCode()
        if (nextTokenCharCode === 40 || nextTokenCharCode === 46) {
          break
        }
      }
      case 82: {
        if (!this.options.allowImportExportEverywhere && !topLevel) {
          this.raise(Errors.UnexpectedImportExport, {
            at: this.state.startLoc,
          })
        }
        this.next()
        let result
        if (starttype === 83) {
          result = this.parseImport(node2)
          if (result.type === 'ImportDeclaration' && (!result.importKind || result.importKind === 'value')) {
            this.sawUnambiguousESM = true
          }
        } else {
          result = this.parseExport(node2)
          if (
            (result.type === 'ExportNamedDeclaration' && (!result.exportKind || result.exportKind === 'value')) ||
            (result.type === 'ExportAllDeclaration' && (!result.exportKind || result.exportKind === 'value')) ||
            result.type === 'ExportDefaultDeclaration'
          ) {
            this.sawUnambiguousESM = true
          }
        }
        this.assertModuleNodeAllowed(node2)
        return result
      }
      default: {
        if (this.isAsyncFunction()) {
          if (context2) {
            this.raise(Errors.AsyncFunctionInSingleStatementContext, {
              at: this.state.startLoc,
            })
          }
          this.next()
          return this.parseFunctionStatement(node2, true, !context2)
        }
      }
    }
    const maybeName = this.state.value
    const expr = this.parseExpression()
    if (tokenIsIdentifier(starttype) && expr.type === 'Identifier' && this.eat(14)) {
      return this.parseLabeledStatement(node2, maybeName, expr, context2)
    } else {
      return this.parseExpressionStatement(node2, expr)
    }
  }
  assertModuleNodeAllowed(node2) {
    if (!this.options.allowImportExportEverywhere && !this.inModule) {
      this.raise(Errors.ImportOutsideModule, {
        at: node2,
      })
    }
  }
  takeDecorators(node2) {
    const decorators = this.state.decoratorStack[this.state.decoratorStack.length - 1]
    if (decorators.length) {
      node2.decorators = decorators
      this.resetStartLocationFromNode(node2, decorators[0])
      this.state.decoratorStack[this.state.decoratorStack.length - 1] = []
    }
  }
  canHaveLeadingDecorator() {
    return this.match(80)
  }
  parseDecorators(allowExport) {
    const currentContextDecorators = this.state.decoratorStack[this.state.decoratorStack.length - 1]
    while (this.match(26)) {
      const decorator2 = this.parseDecorator()
      currentContextDecorators.push(decorator2)
    }
    if (this.match(82)) {
      if (!allowExport) {
        this.unexpected()
      }
      if (this.hasPlugin('decorators') && !this.getPluginOption('decorators', 'decoratorsBeforeExport')) {
        this.raise(Errors.DecoratorExportClass, {
          at: this.state.startLoc,
        })
      }
    } else if (!this.canHaveLeadingDecorator()) {
      throw this.raise(Errors.UnexpectedLeadingDecorator, {
        at: this.state.startLoc,
      })
    }
  }
  parseDecorator() {
    this.expectOnePlugin(['decorators-legacy', 'decorators'])
    const node2 = this.startNode()
    this.next()
    if (this.hasPlugin('decorators')) {
      this.state.decoratorStack.push([])
      const startPos = this.state.start
      const startLoc = this.state.startLoc
      let expr
      if (this.match(10)) {
        const startPos2 = this.state.start
        const startLoc2 = this.state.startLoc
        this.next()
        expr = this.parseExpression()
        this.expect(11)
        expr = this.wrapParenthesis(startPos2, startLoc2, expr)
      } else {
        expr = this.parseIdentifier(false)
        while (this.eat(16)) {
          const node3 = this.startNodeAt(startPos, startLoc)
          node3.object = expr
          node3.property = this.parseIdentifier(true)
          node3.computed = false
          expr = this.finishNode(node3, 'MemberExpression')
        }
      }
      node2.expression = this.parseMaybeDecoratorArguments(expr)
      this.state.decoratorStack.pop()
    } else {
      node2.expression = this.parseExprSubscripts()
    }
    return this.finishNode(node2, 'Decorator')
  }
  parseMaybeDecoratorArguments(expr) {
    if (this.eat(10)) {
      const node2 = this.startNodeAtNode(expr)
      node2.callee = expr
      node2.arguments = this.parseCallExpressionArguments(11, false)
      this.toReferencedList(node2.arguments)
      return this.finishNode(node2, 'CallExpression')
    }
    return expr
  }
  parseBreakContinueStatement(node2, isBreak) {
    this.next()
    if (this.isLineTerminator()) {
      node2.label = null
    } else {
      node2.label = this.parseIdentifier()
      this.semicolon()
    }
    this.verifyBreakContinue(node2, isBreak)
    return this.finishNode(node2, isBreak ? 'BreakStatement' : 'ContinueStatement')
  }
  verifyBreakContinue(node2, isBreak) {
    let i
    for (i = 0; i < this.state.labels.length; ++i) {
      const lab = this.state.labels[i]
      if (node2.label == null || lab.name === node2.label.name) {
        if (lab.kind != null && (isBreak || lab.kind === 'loop')) break
        if (node2.label && isBreak) break
      }
    }
    if (i === this.state.labels.length) {
      const type = isBreak ? 'BreakStatement' : 'ContinueStatement'
      this.raise(Errors.IllegalBreakContinue, {
        at: node2,
        type,
      })
    }
  }
  parseDebuggerStatement(node2) {
    this.next()
    this.semicolon()
    return this.finishNode(node2, 'DebuggerStatement')
  }
  parseHeaderExpression() {
    this.expect(10)
    const val = this.parseExpression()
    this.expect(11)
    return val
  }
  parseDoStatement(node2) {
    this.next()
    this.state.labels.push(loopLabel)
    node2.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement('do'))
    this.state.labels.pop()
    this.expect(92)
    node2.test = this.parseHeaderExpression()
    this.eat(13)
    return this.finishNode(node2, 'DoWhileStatement')
  }
  parseForStatement(node2) {
    this.next()
    this.state.labels.push(loopLabel)
    let awaitAt = null
    if (this.isAwaitAllowed() && this.eatContextual(96)) {
      awaitAt = this.state.lastTokStartLoc
    }
    this.scope.enter(SCOPE_OTHER)
    this.expect(10)
    if (this.match(13)) {
      if (awaitAt !== null) {
        this.unexpected(awaitAt)
      }
      return this.parseFor(node2, null)
    }
    const startsWithLet = this.isContextual(99)
    const isLet2 = startsWithLet && this.isLetKeyword()
    if (this.match(74) || this.match(75) || isLet2) {
      const init2 = this.startNode()
      const kind = isLet2 ? 'let' : this.state.value
      this.next()
      this.parseVar(init2, true, kind)
      this.finishNode(init2, 'VariableDeclaration')
      if ((this.match(58) || this.isContextual(101)) && init2.declarations.length === 1) {
        return this.parseForIn(node2, init2, awaitAt)
      }
      if (awaitAt !== null) {
        this.unexpected(awaitAt)
      }
      return this.parseFor(node2, init2)
    }
    const startsWithAsync = this.isContextual(95)
    const refExpressionErrors = new ExpressionErrors()
    const init = this.parseExpression(true, refExpressionErrors)
    const isForOf = this.isContextual(101)
    if (isForOf) {
      if (startsWithLet) {
        this.raise(Errors.ForOfLet, {
          at: init,
        })
      }
      if (awaitAt === null && startsWithAsync && init.type === 'Identifier') {
        this.raise(Errors.ForOfAsync, {
          at: init,
        })
      }
    }
    if (isForOf || this.match(58)) {
      this.checkDestructuringPrivate(refExpressionErrors)
      this.toAssignable(init, true)
      const type = isForOf ? 'ForOfStatement' : 'ForInStatement'
      this.checkLVal(init, {
        in: {
          type,
        },
      })
      return this.parseForIn(node2, init, awaitAt)
    } else {
      this.checkExpressionErrors(refExpressionErrors, true)
    }
    if (awaitAt !== null) {
      this.unexpected(awaitAt)
    }
    return this.parseFor(node2, init)
  }
  parseFunctionStatement(node2, isAsync, declarationPosition) {
    this.next()
    return this.parseFunction(node2, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), isAsync)
  }
  parseIfStatement(node2) {
    this.next()
    node2.test = this.parseHeaderExpression()
    node2.consequent = this.parseStatement('if')
    node2.alternate = this.eat(66) ? this.parseStatement('if') : null
    return this.finishNode(node2, 'IfStatement')
  }
  parseReturnStatement(node2) {
    if (!this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction) {
      this.raise(Errors.IllegalReturn, {
        at: this.state.startLoc,
      })
    }
    this.next()
    if (this.isLineTerminator()) {
      node2.argument = null
    } else {
      node2.argument = this.parseExpression()
      this.semicolon()
    }
    return this.finishNode(node2, 'ReturnStatement')
  }
  parseSwitchStatement(node2) {
    this.next()
    node2.discriminant = this.parseHeaderExpression()
    const cases = (node2.cases = [])
    this.expect(5)
    this.state.labels.push(switchLabel)
    this.scope.enter(SCOPE_OTHER)
    let cur
    for (let sawDefault; !this.match(8); ) {
      if (this.match(61) || this.match(65)) {
        const isCase = this.match(61)
        if (cur) this.finishNode(cur, 'SwitchCase')
        cases.push((cur = this.startNode()))
        cur.consequent = []
        this.next()
        if (isCase) {
          cur.test = this.parseExpression()
        } else {
          if (sawDefault) {
            this.raise(Errors.MultipleDefaultsInSwitch, {
              at: this.state.lastTokStartLoc,
            })
          }
          sawDefault = true
          cur.test = null
        }
        this.expect(14)
      } else {
        if (cur) {
          cur.consequent.push(this.parseStatement(null))
        } else {
          this.unexpected()
        }
      }
    }
    this.scope.exit()
    if (cur) this.finishNode(cur, 'SwitchCase')
    this.next()
    this.state.labels.pop()
    return this.finishNode(node2, 'SwitchStatement')
  }
  parseThrowStatement(node2) {
    this.next()
    if (this.hasPrecedingLineBreak()) {
      this.raise(Errors.NewlineAfterThrow, {
        at: this.state.lastTokEndLoc,
      })
    }
    node2.argument = this.parseExpression()
    this.semicolon()
    return this.finishNode(node2, 'ThrowStatement')
  }
  parseCatchClauseParam() {
    const param = this.parseBindingAtom()
    const simple = param.type === 'Identifier'
    this.scope.enter(simple ? SCOPE_SIMPLE_CATCH : 0)
    this.checkLVal(param, {
      in: {
        type: 'CatchClause',
      },
      binding: BIND_LEXICAL,
      allowingSloppyLetBinding: true,
    })
    return param
  }
  parseTryStatement(node2) {
    this.next()
    node2.block = this.parseBlock()
    node2.handler = null
    if (this.match(62)) {
      const clause = this.startNode()
      this.next()
      if (this.match(10)) {
        this.expect(10)
        clause.param = this.parseCatchClauseParam()
        this.expect(11)
      } else {
        clause.param = null
        this.scope.enter(SCOPE_OTHER)
      }
      clause.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(false, false))
      this.scope.exit()
      node2.handler = this.finishNode(clause, 'CatchClause')
    }
    node2.finalizer = this.eat(67) ? this.parseBlock() : null
    if (!node2.handler && !node2.finalizer) {
      this.raise(Errors.NoCatchOrFinally, {
        at: node2,
      })
    }
    return this.finishNode(node2, 'TryStatement')
  }
  parseVarStatement(node2, kind, allowMissingInitializer = false) {
    this.next()
    this.parseVar(node2, false, kind, allowMissingInitializer)
    this.semicolon()
    return this.finishNode(node2, 'VariableDeclaration')
  }
  parseWhileStatement(node2) {
    this.next()
    node2.test = this.parseHeaderExpression()
    this.state.labels.push(loopLabel)
    node2.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement('while'))
    this.state.labels.pop()
    return this.finishNode(node2, 'WhileStatement')
  }
  parseWithStatement(node2) {
    if (this.state.strict) {
      this.raise(Errors.StrictWith, {
        at: this.state.startLoc,
      })
    }
    this.next()
    node2.object = this.parseHeaderExpression()
    node2.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement('with'))
    return this.finishNode(node2, 'WithStatement')
  }
  parseEmptyStatement(node2) {
    this.next()
    return this.finishNode(node2, 'EmptyStatement')
  }
  parseLabeledStatement(node2, maybeName, expr, context2) {
    for (const label of this.state.labels) {
      if (label.name === maybeName) {
        this.raise(Errors.LabelRedeclaration, {
          at: expr,
          labelName: maybeName,
        })
      }
    }
    const kind = tokenIsLoop(this.state.type) ? 'loop' : this.match(71) ? 'switch' : null
    for (let i = this.state.labels.length - 1; i >= 0; i--) {
      const label = this.state.labels[i]
      if (label.statementStart === node2.start) {
        label.statementStart = this.state.start
        label.kind = kind
      } else {
        break
      }
    }
    this.state.labels.push({
      name: maybeName,
      kind,
      statementStart: this.state.start,
    })
    node2.body = this.parseStatement(
      context2 ? (context2.indexOf('label') === -1 ? context2 + 'label' : context2) : 'label'
    )
    this.state.labels.pop()
    node2.label = expr
    return this.finishNode(node2, 'LabeledStatement')
  }
  parseExpressionStatement(node2, expr) {
    node2.expression = expr
    this.semicolon()
    return this.finishNode(node2, 'ExpressionStatement')
  }
  parseBlock(allowDirectives = false, createNewLexicalScope = true, afterBlockParse) {
    const node2 = this.startNode()
    if (allowDirectives) {
      this.state.strictErrors.clear()
    }
    this.expect(5)
    if (createNewLexicalScope) {
      this.scope.enter(SCOPE_OTHER)
    }
    this.parseBlockBody(node2, allowDirectives, false, 8, afterBlockParse)
    if (createNewLexicalScope) {
      this.scope.exit()
    }
    return this.finishNode(node2, 'BlockStatement')
  }
  isValidDirective(stmt) {
    return (
      stmt.type === 'ExpressionStatement' &&
      stmt.expression.type === 'StringLiteral' &&
      !stmt.expression.extra.parenthesized
    )
  }
  parseBlockBody(node2, allowDirectives, topLevel, end, afterBlockParse) {
    const body = (node2.body = [])
    const directives = (node2.directives = [])
    this.parseBlockOrModuleBlockBody(body, allowDirectives ? directives : void 0, topLevel, end, afterBlockParse)
  }
  parseBlockOrModuleBlockBody(body, directives, topLevel, end, afterBlockParse) {
    const oldStrict = this.state.strict
    let hasStrictModeDirective = false
    let parsedNonDirective = false
    while (!this.match(end)) {
      const stmt = this.parseStatement(null, topLevel)
      if (directives && !parsedNonDirective) {
        if (this.isValidDirective(stmt)) {
          const directive2 = this.stmtToDirective(stmt)
          directives.push(directive2)
          if (!hasStrictModeDirective && directive2.value.value === 'use strict') {
            hasStrictModeDirective = true
            this.setStrict(true)
          }
          continue
        }
        parsedNonDirective = true
        this.state.strictErrors.clear()
      }
      body.push(stmt)
    }
    if (afterBlockParse) {
      afterBlockParse.call(this, hasStrictModeDirective)
    }
    if (!oldStrict) {
      this.setStrict(false)
    }
    this.next()
  }
  parseFor(node2, init) {
    node2.init = init
    this.semicolon(false)
    node2.test = this.match(13) ? null : this.parseExpression()
    this.semicolon(false)
    node2.update = this.match(11) ? null : this.parseExpression()
    this.expect(11)
    node2.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement('for'))
    this.scope.exit()
    this.state.labels.pop()
    return this.finishNode(node2, 'ForStatement')
  }
  parseForIn(node2, init, awaitAt) {
    const isForIn = this.match(58)
    this.next()
    if (isForIn) {
      if (awaitAt !== null) this.unexpected(awaitAt)
    } else {
      node2.await = awaitAt !== null
    }
    if (
      init.type === 'VariableDeclaration' &&
      init.declarations[0].init != null &&
      (!isForIn || this.state.strict || init.kind !== 'var' || init.declarations[0].id.type !== 'Identifier')
    ) {
      this.raise(Errors.ForInOfLoopInitializer, {
        at: init,
        type: isForIn ? 'ForInStatement' : 'ForOfStatement',
      })
    }
    if (init.type === 'AssignmentPattern') {
      this.raise(Errors.InvalidLhs, {
        at: init,
        ancestor: {
          type: 'ForStatement',
        },
      })
    }
    node2.left = init
    node2.right = isForIn ? this.parseExpression() : this.parseMaybeAssignAllowIn()
    this.expect(11)
    node2.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement('for'))
    this.scope.exit()
    this.state.labels.pop()
    return this.finishNode(node2, isForIn ? 'ForInStatement' : 'ForOfStatement')
  }
  parseVar(node2, isFor2, kind, allowMissingInitializer = false) {
    const declarations = (node2.declarations = [])
    node2.kind = kind
    for (;;) {
      const decl = this.startNode()
      this.parseVarId(decl, kind)
      decl.init = !this.eat(29) ? null : isFor2 ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn()
      if (decl.init === null && !allowMissingInitializer) {
        if (decl.id.type !== 'Identifier' && !(isFor2 && (this.match(58) || this.isContextual(101)))) {
          this.raise(Errors.DeclarationMissingInitializer, {
            at: this.state.lastTokEndLoc,
            kind: 'destructuring',
          })
        } else if (kind === 'const' && !(this.match(58) || this.isContextual(101))) {
          this.raise(Errors.DeclarationMissingInitializer, {
            at: this.state.lastTokEndLoc,
            kind: 'const',
          })
        }
      }
      declarations.push(this.finishNode(decl, 'VariableDeclarator'))
      if (!this.eat(12)) break
    }
    return node2
  }
  parseVarId(decl, kind) {
    decl.id = this.parseBindingAtom()
    this.checkLVal(decl.id, {
      in: {
        type: 'VariableDeclarator',
      },
      binding: kind === 'var' ? BIND_VAR : BIND_LEXICAL,
    })
  }
  parseFunction(node2, statement2 = FUNC_NO_FLAGS, isAsync = false) {
    const isStatement2 = statement2 & FUNC_STATEMENT
    const isHangingStatement = statement2 & FUNC_HANGING_STATEMENT
    const requireId = !!isStatement2 && !(statement2 & FUNC_NULLABLE_ID)
    this.initFunction(node2, isAsync)
    if (this.match(55) && isHangingStatement) {
      this.raise(Errors.GeneratorInSingleStatementContext, {
        at: this.state.startLoc,
      })
    }
    node2.generator = this.eat(55)
    if (isStatement2) {
      node2.id = this.parseFunctionId(requireId)
    }
    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters
    this.state.maybeInArrowParameters = false
    this.scope.enter(SCOPE_FUNCTION)
    this.prodParam.enter(functionFlags(isAsync, node2.generator))
    if (!isStatement2) {
      node2.id = this.parseFunctionId()
    }
    this.parseFunctionParams(node2, false)
    this.withSmartMixTopicForbiddingContext(() => {
      this.parseFunctionBodyAndFinish(node2, isStatement2 ? 'FunctionDeclaration' : 'FunctionExpression')
    })
    this.prodParam.exit()
    this.scope.exit()
    if (isStatement2 && !isHangingStatement) {
      this.registerFunctionStatementId(node2)
    }
    this.state.maybeInArrowParameters = oldMaybeInArrowParameters
    return node2
  }
  parseFunctionId(requireId) {
    return requireId || tokenIsIdentifier(this.state.type) ? this.parseIdentifier() : null
  }
  parseFunctionParams(node2, allowModifiers) {
    this.expect(10)
    this.expressionScope.enter(newParameterDeclarationScope())
    node2.params = this.parseBindingList(11, 41, false, allowModifiers)
    this.expressionScope.exit()
  }
  registerFunctionStatementId(node2) {
    if (!node2.id) return
    this.scope.declareName(
      node2.id.name,
      this.state.strict || node2.generator || node2.async
        ? this.scope.treatFunctionsAsVar
          ? BIND_VAR
          : BIND_LEXICAL
        : BIND_FUNCTION,
      node2.id.loc.start
    )
  }
  parseClass(node2, isStatement2, optionalId) {
    this.next()
    this.takeDecorators(node2)
    const oldStrict = this.state.strict
    this.state.strict = true
    this.parseClassId(node2, isStatement2, optionalId)
    this.parseClassSuper(node2)
    node2.body = this.parseClassBody(!!node2.superClass, oldStrict)
    return this.finishNode(node2, isStatement2 ? 'ClassDeclaration' : 'ClassExpression')
  }
  isClassProperty() {
    return this.match(29) || this.match(13) || this.match(8)
  }
  isClassMethod() {
    return this.match(10)
  }
  isNonstaticConstructor(method) {
    return (
      !method.computed && !method.static && (method.key.name === 'constructor' || method.key.value === 'constructor')
    )
  }
  parseClassBody(hadSuperClass, oldStrict) {
    this.classScope.enter()
    const state = {
      hadConstructor: false,
      hadSuperClass,
    }
    let decorators = []
    const classBody2 = this.startNode()
    classBody2.body = []
    this.expect(5)
    this.withSmartMixTopicForbiddingContext(() => {
      while (!this.match(8)) {
        if (this.eat(13)) {
          if (decorators.length > 0) {
            throw this.raise(Errors.DecoratorSemicolon, {
              at: this.state.lastTokEndLoc,
            })
          }
          continue
        }
        if (this.match(26)) {
          decorators.push(this.parseDecorator())
          continue
        }
        const member = this.startNode()
        if (decorators.length) {
          member.decorators = decorators
          this.resetStartLocationFromNode(member, decorators[0])
          decorators = []
        }
        this.parseClassMember(classBody2, member, state)
        if (member.kind === 'constructor' && member.decorators && member.decorators.length > 0) {
          this.raise(Errors.DecoratorConstructor, {
            at: member,
          })
        }
      }
    })
    this.state.strict = oldStrict
    this.next()
    if (decorators.length) {
      throw this.raise(Errors.TrailingDecorator, {
        at: this.state.startLoc,
      })
    }
    this.classScope.exit()
    return this.finishNode(classBody2, 'ClassBody')
  }
  parseClassMemberFromModifier(classBody2, member) {
    const key = this.parseIdentifier(true)
    if (this.isClassMethod()) {
      const method = member
      method.kind = 'method'
      method.computed = false
      method.key = key
      method.static = false
      this.pushClassMethod(classBody2, method, false, false, false, false)
      return true
    } else if (this.isClassProperty()) {
      const prop = member
      prop.computed = false
      prop.key = key
      prop.static = false
      classBody2.body.push(this.parseClassProperty(prop))
      return true
    }
    this.resetPreviousNodeTrailingComments(key)
    return false
  }
  parseClassMember(classBody2, member, state) {
    const isStatic2 = this.isContextual(104)
    if (isStatic2) {
      if (this.parseClassMemberFromModifier(classBody2, member)) {
        return
      }
      if (this.eat(5)) {
        this.parseClassStaticBlock(classBody2, member)
        return
      }
    }
    this.parseClassMemberWithIsStatic(classBody2, member, state, isStatic2)
  }
  parseClassMemberWithIsStatic(classBody2, member, state, isStatic2) {
    const publicMethod = member
    const privateMethod = member
    const publicProp = member
    const privateProp = member
    const accessorProp = member
    const method = publicMethod
    const publicMember = publicMethod
    member.static = isStatic2
    this.parsePropertyNamePrefixOperator(member)
    if (this.eat(55)) {
      method.kind = 'method'
      const isPrivateName2 = this.match(134)
      this.parseClassElementName(method)
      if (isPrivateName2) {
        this.pushClassPrivateMethod(classBody2, privateMethod, true, false)
        return
      }
      if (this.isNonstaticConstructor(publicMethod)) {
        this.raise(Errors.ConstructorIsGenerator, {
          at: publicMethod.key,
        })
      }
      this.pushClassMethod(classBody2, publicMethod, true, false, false, false)
      return
    }
    const isContextual = tokenIsIdentifier(this.state.type) && !this.state.containsEsc
    const isPrivate2 = this.match(134)
    const key = this.parseClassElementName(member)
    const maybeQuestionTokenStartLoc = this.state.startLoc
    this.parsePostMemberNameModifiers(publicMember)
    if (this.isClassMethod()) {
      method.kind = 'method'
      if (isPrivate2) {
        this.pushClassPrivateMethod(classBody2, privateMethod, false, false)
        return
      }
      const isConstructor = this.isNonstaticConstructor(publicMethod)
      let allowsDirectSuper = false
      if (isConstructor) {
        publicMethod.kind = 'constructor'
        if (state.hadConstructor && !this.hasPlugin('typescript')) {
          this.raise(Errors.DuplicateConstructor, {
            at: key,
          })
        }
        if (isConstructor && this.hasPlugin('typescript') && member.override) {
          this.raise(Errors.OverrideOnConstructor, {
            at: key,
          })
        }
        state.hadConstructor = true
        allowsDirectSuper = state.hadSuperClass
      }
      this.pushClassMethod(classBody2, publicMethod, false, false, isConstructor, allowsDirectSuper)
    } else if (this.isClassProperty()) {
      if (isPrivate2) {
        this.pushClassPrivateProperty(classBody2, privateProp)
      } else {
        this.pushClassProperty(classBody2, publicProp)
      }
    } else if (isContextual && key.name === 'async' && !this.isLineTerminator()) {
      this.resetPreviousNodeTrailingComments(key)
      const isGenerator = this.eat(55)
      if (publicMember.optional) {
        this.unexpected(maybeQuestionTokenStartLoc)
      }
      method.kind = 'method'
      const isPrivate3 = this.match(134)
      this.parseClassElementName(method)
      this.parsePostMemberNameModifiers(publicMember)
      if (isPrivate3) {
        this.pushClassPrivateMethod(classBody2, privateMethod, isGenerator, true)
      } else {
        if (this.isNonstaticConstructor(publicMethod)) {
          this.raise(Errors.ConstructorIsAsync, {
            at: publicMethod.key,
          })
        }
        this.pushClassMethod(classBody2, publicMethod, isGenerator, true, false, false)
      }
    } else if (
      isContextual &&
      (key.name === 'get' || key.name === 'set') &&
      !(this.match(55) && this.isLineTerminator())
    ) {
      this.resetPreviousNodeTrailingComments(key)
      method.kind = key.name
      const isPrivate3 = this.match(134)
      this.parseClassElementName(publicMethod)
      if (isPrivate3) {
        this.pushClassPrivateMethod(classBody2, privateMethod, false, false)
      } else {
        if (this.isNonstaticConstructor(publicMethod)) {
          this.raise(Errors.ConstructorIsAccessor, {
            at: publicMethod.key,
          })
        }
        this.pushClassMethod(classBody2, publicMethod, false, false, false, false)
      }
      this.checkGetterSetterParams(publicMethod)
    } else if (isContextual && key.name === 'accessor' && !this.isLineTerminator()) {
      this.expectPlugin('decoratorAutoAccessors')
      this.resetPreviousNodeTrailingComments(key)
      const isPrivate3 = this.match(134)
      this.parseClassElementName(publicProp)
      this.pushClassAccessorProperty(classBody2, accessorProp, isPrivate3)
    } else if (this.isLineTerminator()) {
      if (isPrivate2) {
        this.pushClassPrivateProperty(classBody2, privateProp)
      } else {
        this.pushClassProperty(classBody2, publicProp)
      }
    } else {
      this.unexpected()
    }
  }
  parseClassElementName(member) {
    const { type, value } = this.state
    if ((type === 128 || type === 129) && member.static && value === 'prototype') {
      this.raise(Errors.StaticPrototype, {
        at: this.state.startLoc,
      })
    }
    if (type === 134) {
      if (value === 'constructor') {
        this.raise(Errors.ConstructorClassPrivateField, {
          at: this.state.startLoc,
        })
      }
      const key = this.parsePrivateName()
      member.key = key
      return key
    }
    return this.parsePropertyName(member)
  }
  parseClassStaticBlock(classBody2, member) {
    var _member$decorators
    this.scope.enter(SCOPE_CLASS | SCOPE_STATIC_BLOCK | SCOPE_SUPER)
    const oldLabels = this.state.labels
    this.state.labels = []
    this.prodParam.enter(PARAM)
    const body = (member.body = [])
    this.parseBlockOrModuleBlockBody(body, void 0, false, 8)
    this.prodParam.exit()
    this.scope.exit()
    this.state.labels = oldLabels
    classBody2.body.push(this.finishNode(member, 'StaticBlock'))
    if ((_member$decorators = member.decorators) != null && _member$decorators.length) {
      this.raise(Errors.DecoratorStaticBlock, {
        at: member,
      })
    }
  }
  pushClassProperty(classBody2, prop) {
    if (!prop.computed && (prop.key.name === 'constructor' || prop.key.value === 'constructor')) {
      this.raise(Errors.ConstructorClassField, {
        at: prop.key,
      })
    }
    classBody2.body.push(this.parseClassProperty(prop))
  }
  pushClassPrivateProperty(classBody2, prop) {
    const node2 = this.parseClassPrivateProperty(prop)
    classBody2.body.push(node2)
    this.classScope.declarePrivateName(this.getPrivateNameSV(node2.key), CLASS_ELEMENT_OTHER, node2.key.loc.start)
  }
  pushClassAccessorProperty(classBody2, prop, isPrivate2) {
    if (!isPrivate2 && !prop.computed) {
      const key = prop.key
      if (key.name === 'constructor' || key.value === 'constructor') {
        this.raise(Errors.ConstructorClassField, {
          at: key,
        })
      }
    }
    const node2 = this.parseClassAccessorProperty(prop)
    classBody2.body.push(node2)
    if (isPrivate2) {
      this.classScope.declarePrivateName(this.getPrivateNameSV(node2.key), CLASS_ELEMENT_OTHER, node2.key.loc.start)
    }
  }
  pushClassMethod(classBody2, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
    classBody2.body.push(
      this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, 'ClassMethod', true)
    )
  }
  pushClassPrivateMethod(classBody2, method, isGenerator, isAsync) {
    const node2 = this.parseMethod(method, isGenerator, isAsync, false, false, 'ClassPrivateMethod', true)
    classBody2.body.push(node2)
    const kind =
      node2.kind === 'get'
        ? node2.static
          ? CLASS_ELEMENT_STATIC_GETTER
          : CLASS_ELEMENT_INSTANCE_GETTER
        : node2.kind === 'set'
        ? node2.static
          ? CLASS_ELEMENT_STATIC_SETTER
          : CLASS_ELEMENT_INSTANCE_SETTER
        : CLASS_ELEMENT_OTHER
    this.declareClassPrivateMethodInScope(node2, kind)
  }
  declareClassPrivateMethodInScope(node2, kind) {
    this.classScope.declarePrivateName(this.getPrivateNameSV(node2.key), kind, node2.key.loc.start)
  }
  parsePostMemberNameModifiers(methodOrProp) {}
  parseClassPrivateProperty(node2) {
    this.parseInitializer(node2)
    this.semicolon()
    return this.finishNode(node2, 'ClassPrivateProperty')
  }
  parseClassProperty(node2) {
    this.parseInitializer(node2)
    this.semicolon()
    return this.finishNode(node2, 'ClassProperty')
  }
  parseClassAccessorProperty(node2) {
    this.parseInitializer(node2)
    this.semicolon()
    return this.finishNode(node2, 'ClassAccessorProperty')
  }
  parseInitializer(node2) {
    this.scope.enter(SCOPE_CLASS | SCOPE_SUPER)
    this.expressionScope.enter(newExpressionScope())
    this.prodParam.enter(PARAM)
    node2.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null
    this.expressionScope.exit()
    this.prodParam.exit()
    this.scope.exit()
  }
  parseClassId(node2, isStatement2, optionalId, bindingType = BIND_CLASS) {
    if (tokenIsIdentifier(this.state.type)) {
      node2.id = this.parseIdentifier()
      if (isStatement2) {
        this.declareNameFromIdentifier(node2.id, bindingType)
      }
    } else {
      if (optionalId || !isStatement2) {
        node2.id = null
      } else {
        throw this.raise(Errors.MissingClassName, {
          at: this.state.startLoc,
        })
      }
    }
  }
  parseClassSuper(node2) {
    node2.superClass = this.eat(81) ? this.parseExprSubscripts() : null
  }
  parseExport(node2) {
    const hasDefault = this.maybeParseExportDefaultSpecifier(node2)
    const parseAfterDefault = !hasDefault || this.eat(12)
    const hasStar = parseAfterDefault && this.eatExportStar(node2)
    const hasNamespace = hasStar && this.maybeParseExportNamespaceSpecifier(node2)
    const parseAfterNamespace = parseAfterDefault && (!hasNamespace || this.eat(12))
    const isFromRequired = hasDefault || hasStar
    if (hasStar && !hasNamespace) {
      if (hasDefault) this.unexpected()
      this.parseExportFrom(node2, true)
      return this.finishNode(node2, 'ExportAllDeclaration')
    }
    const hasSpecifiers = this.maybeParseExportNamedSpecifiers(node2)
    if (
      (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers) ||
      (hasNamespace && parseAfterNamespace && !hasSpecifiers)
    ) {
      throw this.unexpected(null, 5)
    }
    let hasDeclaration
    if (isFromRequired || hasSpecifiers) {
      hasDeclaration = false
      this.parseExportFrom(node2, isFromRequired)
    } else {
      hasDeclaration = this.maybeParseExportDeclaration(node2)
    }
    if (isFromRequired || hasSpecifiers || hasDeclaration) {
      this.checkExport(node2, true, false, !!node2.source)
      return this.finishNode(node2, 'ExportNamedDeclaration')
    }
    if (this.eat(65)) {
      node2.declaration = this.parseExportDefaultExpression()
      this.checkExport(node2, true, true)
      return this.finishNode(node2, 'ExportDefaultDeclaration')
    }
    throw this.unexpected(null, 5)
  }
  eatExportStar(node2) {
    return this.eat(55)
  }
  maybeParseExportDefaultSpecifier(node2) {
    if (this.isExportDefaultSpecifier()) {
      this.expectPlugin('exportDefaultFrom')
      const specifier = this.startNode()
      specifier.exported = this.parseIdentifier(true)
      node2.specifiers = [this.finishNode(specifier, 'ExportDefaultSpecifier')]
      return true
    }
    return false
  }
  maybeParseExportNamespaceSpecifier(node2) {
    if (this.isContextual(93)) {
      if (!node2.specifiers) node2.specifiers = []
      const specifier = this.startNodeAt(this.state.lastTokStart, this.state.lastTokStartLoc)
      this.next()
      specifier.exported = this.parseModuleExportName()
      node2.specifiers.push(this.finishNode(specifier, 'ExportNamespaceSpecifier'))
      return true
    }
    return false
  }
  maybeParseExportNamedSpecifiers(node2) {
    if (this.match(5)) {
      if (!node2.specifiers) node2.specifiers = []
      const isTypeExport = node2.exportKind === 'type'
      node2.specifiers.push(...this.parseExportSpecifiers(isTypeExport))
      node2.source = null
      node2.declaration = null
      if (this.hasPlugin('importAssertions')) {
        node2.assertions = []
      }
      return true
    }
    return false
  }
  maybeParseExportDeclaration(node2) {
    if (this.shouldParseExportDeclaration()) {
      node2.specifiers = []
      node2.source = null
      if (this.hasPlugin('importAssertions')) {
        node2.assertions = []
      }
      node2.declaration = this.parseExportDeclaration(node2)
      return true
    }
    return false
  }
  isAsyncFunction() {
    if (!this.isContextual(95)) return false
    const next = this.nextTokenStart()
    return !lineBreak.test(this.input.slice(this.state.pos, next)) && this.isUnparsedContextual(next, 'function')
  }
  parseExportDefaultExpression() {
    const expr = this.startNode()
    const isAsync = this.isAsyncFunction()
    if (this.match(68) || isAsync) {
      this.next()
      if (isAsync) {
        this.next()
      }
      return this.parseFunction(expr, FUNC_STATEMENT | FUNC_NULLABLE_ID, isAsync)
    }
    if (this.match(80)) {
      return this.parseClass(expr, true, true)
    }
    if (this.match(26)) {
      if (this.hasPlugin('decorators') && this.getPluginOption('decorators', 'decoratorsBeforeExport')) {
        this.raise(Errors.DecoratorBeforeExport, {
          at: this.state.startLoc,
        })
      }
      this.parseDecorators(false)
      return this.parseClass(expr, true, true)
    }
    if (this.match(75) || this.match(74) || this.isLet()) {
      throw this.raise(Errors.UnsupportedDefaultExport, {
        at: this.state.startLoc,
      })
    }
    const res = this.parseMaybeAssignAllowIn()
    this.semicolon()
    return res
  }
  parseExportDeclaration(node2) {
    return this.parseStatement(null)
  }
  isExportDefaultSpecifier() {
    const { type } = this.state
    if (tokenIsIdentifier(type)) {
      if ((type === 95 && !this.state.containsEsc) || type === 99) {
        return false
      }
      if ((type === 126 || type === 125) && !this.state.containsEsc) {
        const { type: nextType } = this.lookahead()
        if ((tokenIsIdentifier(nextType) && nextType !== 97) || nextType === 5) {
          this.expectOnePlugin(['flow', 'typescript'])
          return false
        }
      }
    } else if (!this.match(65)) {
      return false
    }
    const next = this.nextTokenStart()
    const hasFrom = this.isUnparsedContextual(next, 'from')
    if (this.input.charCodeAt(next) === 44 || (tokenIsIdentifier(this.state.type) && hasFrom)) {
      return true
    }
    if (this.match(65) && hasFrom) {
      const nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next + 4))
      return nextAfterFrom === 34 || nextAfterFrom === 39
    }
    return false
  }
  parseExportFrom(node2, expect) {
    if (this.eatContextual(97)) {
      node2.source = this.parseImportSource()
      this.checkExport(node2)
      const assertions = this.maybeParseImportAssertions()
      if (assertions) {
        node2.assertions = assertions
      }
    } else if (expect) {
      this.unexpected()
    }
    this.semicolon()
  }
  shouldParseExportDeclaration() {
    const { type } = this.state
    if (type === 26) {
      this.expectOnePlugin(['decorators', 'decorators-legacy'])
      if (this.hasPlugin('decorators')) {
        if (this.getPluginOption('decorators', 'decoratorsBeforeExport')) {
          throw this.raise(Errors.DecoratorBeforeExport, {
            at: this.state.startLoc,
          })
        }
        return true
      }
    }
    return type === 74 || type === 75 || type === 68 || type === 80 || this.isLet() || this.isAsyncFunction()
  }
  checkExport(node2, checkNames, isDefault, isFrom) {
    if (checkNames) {
      if (isDefault) {
        this.checkDuplicateExports(node2, 'default')
        if (this.hasPlugin('exportDefaultFrom')) {
          var _declaration$extra
          const declaration = node2.declaration
          if (
            declaration.type === 'Identifier' &&
            declaration.name === 'from' &&
            declaration.end - declaration.start === 4 &&
            !((_declaration$extra = declaration.extra) != null && _declaration$extra.parenthesized)
          ) {
            this.raise(Errors.ExportDefaultFromAsIdentifier, {
              at: declaration,
            })
          }
        }
      } else if (node2.specifiers && node2.specifiers.length) {
        for (const specifier of node2.specifiers) {
          const { exported } = specifier
          const exportName = exported.type === 'Identifier' ? exported.name : exported.value
          this.checkDuplicateExports(specifier, exportName)
          if (!isFrom && specifier.local) {
            const { local } = specifier
            if (local.type !== 'Identifier') {
              this.raise(Errors.ExportBindingIsString, {
                at: specifier,
                localName: local.value,
                exportName,
              })
            } else {
              this.checkReservedWord(local.name, local.loc.start, true, false)
              this.scope.checkLocalExport(local)
            }
          }
        }
      } else if (node2.declaration) {
        if (node2.declaration.type === 'FunctionDeclaration' || node2.declaration.type === 'ClassDeclaration') {
          const id = node2.declaration.id
          if (!id) throw new Error('Assertion failure')
          this.checkDuplicateExports(node2, id.name)
        } else if (node2.declaration.type === 'VariableDeclaration') {
          for (const declaration of node2.declaration.declarations) {
            this.checkDeclaration(declaration.id)
          }
        }
      }
    }
    const currentContextDecorators = this.state.decoratorStack[this.state.decoratorStack.length - 1]
    if (currentContextDecorators.length) {
      throw this.raise(Errors.UnsupportedDecoratorExport, {
        at: node2,
      })
    }
  }
  checkDeclaration(node2) {
    if (node2.type === 'Identifier') {
      this.checkDuplicateExports(node2, node2.name)
    } else if (node2.type === 'ObjectPattern') {
      for (const prop of node2.properties) {
        this.checkDeclaration(prop)
      }
    } else if (node2.type === 'ArrayPattern') {
      for (const elem of node2.elements) {
        if (elem) {
          this.checkDeclaration(elem)
        }
      }
    } else if (node2.type === 'ObjectProperty') {
      this.checkDeclaration(node2.value)
    } else if (node2.type === 'RestElement') {
      this.checkDeclaration(node2.argument)
    } else if (node2.type === 'AssignmentPattern') {
      this.checkDeclaration(node2.left)
    }
  }
  checkDuplicateExports(node2, exportName) {
    if (this.exportedIdentifiers.has(exportName)) {
      if (exportName === 'default') {
        this.raise(Errors.DuplicateDefaultExport, {
          at: node2,
        })
      } else {
        this.raise(Errors.DuplicateExport, {
          at: node2,
          exportName,
        })
      }
    }
    this.exportedIdentifiers.add(exportName)
  }
  parseExportSpecifiers(isInTypeExport) {
    const nodes2 = []
    let first = true
    this.expect(5)
    while (!this.eat(8)) {
      if (first) {
        first = false
      } else {
        this.expect(12)
        if (this.eat(8)) break
      }
      const isMaybeTypeOnly = this.isContextual(126)
      const isString2 = this.match(129)
      const node2 = this.startNode()
      node2.local = this.parseModuleExportName()
      nodes2.push(this.parseExportSpecifier(node2, isString2, isInTypeExport, isMaybeTypeOnly))
    }
    return nodes2
  }
  parseExportSpecifier(node2, isString2, isInTypeExport, isMaybeTypeOnly) {
    if (this.eatContextual(93)) {
      node2.exported = this.parseModuleExportName()
    } else if (isString2) {
      node2.exported = cloneStringLiteral(node2.local)
    } else if (!node2.exported) {
      node2.exported = cloneIdentifier(node2.local)
    }
    return this.finishNode(node2, 'ExportSpecifier')
  }
  parseModuleExportName() {
    if (this.match(129)) {
      const result = this.parseStringLiteral(this.state.value)
      const surrogate = result.value.match(loneSurrogate)
      if (surrogate) {
        this.raise(Errors.ModuleExportNameHasLoneSurrogate, {
          at: result,
          surrogateCharCode: surrogate[0].charCodeAt(0),
        })
      }
      return result
    }
    return this.parseIdentifier(true)
  }
  parseImport(node2) {
    node2.specifiers = []
    if (!this.match(129)) {
      const hasDefault = this.maybeParseDefaultImportSpecifier(node2)
      const parseNext = !hasDefault || this.eat(12)
      const hasStar = parseNext && this.maybeParseStarImportSpecifier(node2)
      if (parseNext && !hasStar) this.parseNamedImportSpecifiers(node2)
      this.expectContextual(97)
    }
    node2.source = this.parseImportSource()
    const assertions = this.maybeParseImportAssertions()
    if (assertions) {
      node2.assertions = assertions
    } else {
      const attributes = this.maybeParseModuleAttributes()
      if (attributes) {
        node2.attributes = attributes
      }
    }
    this.semicolon()
    return this.finishNode(node2, 'ImportDeclaration')
  }
  parseImportSource() {
    if (!this.match(129)) this.unexpected()
    return this.parseExprAtom()
  }
  shouldParseDefaultImport(node2) {
    return tokenIsIdentifier(this.state.type)
  }
  parseImportSpecifierLocal(node2, specifier, type) {
    specifier.local = this.parseIdentifier()
    node2.specifiers.push(this.finishImportSpecifier(specifier, type))
  }
  finishImportSpecifier(specifier, type) {
    this.checkLVal(specifier.local, {
      in: specifier,
      binding: BIND_LEXICAL,
    })
    return this.finishNode(specifier, type)
  }
  parseAssertEntries() {
    const attrs = []
    const attrNames = /* @__PURE__ */ new Set()
    do {
      if (this.match(8)) {
        break
      }
      const node2 = this.startNode()
      const keyName = this.state.value
      if (attrNames.has(keyName)) {
        this.raise(Errors.ModuleAttributesWithDuplicateKeys, {
          at: this.state.startLoc,
          key: keyName,
        })
      }
      attrNames.add(keyName)
      if (this.match(129)) {
        node2.key = this.parseStringLiteral(keyName)
      } else {
        node2.key = this.parseIdentifier(true)
      }
      this.expect(14)
      if (!this.match(129)) {
        throw this.raise(Errors.ModuleAttributeInvalidValue, {
          at: this.state.startLoc,
        })
      }
      node2.value = this.parseStringLiteral(this.state.value)
      this.finishNode(node2, 'ImportAttribute')
      attrs.push(node2)
    } while (this.eat(12))
    return attrs
  }
  maybeParseModuleAttributes() {
    if (this.match(76) && !this.hasPrecedingLineBreak()) {
      this.expectPlugin('moduleAttributes')
      this.next()
    } else {
      if (this.hasPlugin('moduleAttributes')) return []
      return null
    }
    const attrs = []
    const attributes = /* @__PURE__ */ new Set()
    do {
      const node2 = this.startNode()
      node2.key = this.parseIdentifier(true)
      if (node2.key.name !== 'type') {
        this.raise(Errors.ModuleAttributeDifferentFromType, {
          at: node2.key,
        })
      }
      if (attributes.has(node2.key.name)) {
        this.raise(Errors.ModuleAttributesWithDuplicateKeys, {
          at: node2.key,
          key: node2.key.name,
        })
      }
      attributes.add(node2.key.name)
      this.expect(14)
      if (!this.match(129)) {
        throw this.raise(Errors.ModuleAttributeInvalidValue, {
          at: this.state.startLoc,
        })
      }
      node2.value = this.parseStringLiteral(this.state.value)
      this.finishNode(node2, 'ImportAttribute')
      attrs.push(node2)
    } while (this.eat(12))
    return attrs
  }
  maybeParseImportAssertions() {
    if (this.isContextual(94) && !this.hasPrecedingLineBreak()) {
      this.expectPlugin('importAssertions')
      this.next()
    } else {
      if (this.hasPlugin('importAssertions')) return []
      return null
    }
    this.eat(5)
    const attrs = this.parseAssertEntries()
    this.eat(8)
    return attrs
  }
  maybeParseDefaultImportSpecifier(node2) {
    if (this.shouldParseDefaultImport(node2)) {
      this.parseImportSpecifierLocal(node2, this.startNode(), 'ImportDefaultSpecifier')
      return true
    }
    return false
  }
  maybeParseStarImportSpecifier(node2) {
    if (this.match(55)) {
      const specifier = this.startNode()
      this.next()
      this.expectContextual(93)
      this.parseImportSpecifierLocal(node2, specifier, 'ImportNamespaceSpecifier')
      return true
    }
    return false
  }
  parseNamedImportSpecifiers(node2) {
    let first = true
    this.expect(5)
    while (!this.eat(8)) {
      if (first) {
        first = false
      } else {
        if (this.eat(14)) {
          throw this.raise(Errors.DestructureNamedImport, {
            at: this.state.startLoc,
          })
        }
        this.expect(12)
        if (this.eat(8)) break
      }
      const specifier = this.startNode()
      const importedIsString = this.match(129)
      const isMaybeTypeOnly = this.isContextual(126)
      specifier.imported = this.parseModuleExportName()
      const importSpecifier2 = this.parseImportSpecifier(
        specifier,
        importedIsString,
        node2.importKind === 'type' || node2.importKind === 'typeof',
        isMaybeTypeOnly
      )
      node2.specifiers.push(importSpecifier2)
    }
  }
  parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly) {
    if (this.eatContextual(93)) {
      specifier.local = this.parseIdentifier()
    } else {
      const { imported } = specifier
      if (importedIsString) {
        throw this.raise(Errors.ImportBindingIsString, {
          at: specifier,
          importName: imported.value,
        })
      }
      this.checkReservedWord(imported.name, specifier.loc.start, true, true)
      if (!specifier.local) {
        specifier.local = cloneIdentifier(imported)
      }
    }
    return this.finishImportSpecifier(specifier, 'ImportSpecifier')
  }
  isThisParam(param) {
    return param.type === 'Identifier' && param.name === 'this'
  }
}
class Parser extends StatementParser {
  constructor(options2, input) {
    options2 = getOptions(options2)
    super(options2, input)
    this.options = options2
    this.initializeScopes()
    this.plugins = pluginsMap(this.options.plugins)
    this.filename = options2.sourceFilename
  }
  getScopeHandler() {
    return ScopeHandler
  }
  parse() {
    this.enterInitialScopes()
    const file2 = this.startNode()
    const program2 = this.startNode()
    this.nextToken()
    file2.errors = null
    this.parseTopLevel(file2, program2)
    file2.errors = this.state.errors
    return file2
  }
}
function pluginsMap(plugins) {
  const pluginMap = /* @__PURE__ */ new Map()
  for (const plugin of plugins) {
    const [name, options2] = Array.isArray(plugin) ? plugin : [plugin, {}]
    if (!pluginMap.has(name)) pluginMap.set(name, options2 || {})
  }
  return pluginMap
}
function parse(input, options2) {
  var _options2
  if (((_options2 = options2) == null ? void 0 : _options2.sourceType) === 'unambiguous') {
    options2 = Object.assign({}, options2)
    try {
      options2.sourceType = 'module'
      const parser = getParser(options2, input)
      const ast = parser.parse()
      if (parser.sawUnambiguousESM) {
        return ast
      }
      if (parser.ambiguousScriptDifferentAst) {
        try {
          options2.sourceType = 'script'
          return getParser(options2, input).parse()
        } catch (_unused) {}
      } else {
        ast.program.sourceType = 'script'
      }
      return ast
    } catch (moduleError) {
      try {
        options2.sourceType = 'script'
        return getParser(options2, input).parse()
      } catch (_unused2) {}
      throw moduleError
    }
  } else {
    return getParser(options2, input).parse()
  }
}
function parseExpression(input, options2) {
  const parser = getParser(options2, input)
  if (parser.options.strictMode) {
    parser.state.strict = true
  }
  return parser.getExpression()
}
function generateExportedTokenTypes(internalTokenTypes) {
  const tokenTypes2 = {}
  for (const typeName of Object.keys(internalTokenTypes)) {
    tokenTypes2[typeName] = getExportedToken(internalTokenTypes[typeName])
  }
  return tokenTypes2
}
const tokTypes = generateExportedTokenTypes(tt)
function getParser(options2, input) {
  let cls = Parser
  if (options2 != null && options2.plugins) {
    validatePlugins(options2.plugins)
    cls = getParserClass(options2.plugins)
  }
  return new cls(options2, input)
}
const parserClassCache = {}
function getParserClass(pluginsFromOptions) {
  const pluginList = mixinPluginNames.filter((name) => hasPlugin(pluginsFromOptions, name))
  const key = pluginList.join('/')
  let cls = parserClassCache[key]
  if (!cls) {
    cls = Parser
    for (const plugin of pluginList) {
      cls = mixinPlugins[plugin](cls)
    }
    parserClassCache[key] = cls
  }
  return cls
}
lib.parse = parse
lib.parseExpression = parseExpression
lib.tokTypes = tokTypes
Object.defineProperty(parse$1, '__esModule', {
  value: true,
})
parse$1.default = parseAndBuildMetadata
var _t$b = lib$b
var _parser = lib
var _codeFrame = lib$6
const {
  isCallExpression: isCallExpression$1,
  isExpressionStatement,
  isFunction: isFunction$1,
  isIdentifier: isIdentifier$4,
  isJSXIdentifier,
  isNewExpression,
  isPlaceholder,
  isStatement: isStatement$1,
  isStringLiteral: isStringLiteral$2,
  removePropertiesDeep,
  traverse: traverse$1,
} = _t$b
const PATTERN = /^[_$A-Z0-9]+$/
function parseAndBuildMetadata(formatter, code2, opts) {
  const { placeholderWhitelist, placeholderPattern, preserveComments, syntacticPlaceholders } = opts
  const ast = parseWithCodeFrame(code2, opts.parser, syntacticPlaceholders)
  removePropertiesDeep(ast, {
    preserveComments,
  })
  formatter.validate(ast)
  const syntactic = {
    placeholders: [],
    placeholderNames: /* @__PURE__ */ new Set(),
  }
  const legacy = {
    placeholders: [],
    placeholderNames: /* @__PURE__ */ new Set(),
  }
  const isLegacyRef = {
    value: void 0,
  }
  traverse$1(ast, placeholderVisitorHandler, {
    syntactic,
    legacy,
    isLegacyRef,
    placeholderWhitelist,
    placeholderPattern,
    syntacticPlaceholders,
  })
  return Object.assign(
    {
      ast,
    },
    isLegacyRef.value ? legacy : syntactic
  )
}
function placeholderVisitorHandler(node2, ancestors, state) {
  var _state$placeholderWhi
  let name
  if (isPlaceholder(node2)) {
    if (state.syntacticPlaceholders === false) {
      throw new Error("%%foo%%-style placeholders can't be used when '.syntacticPlaceholders' is false.")
    } else {
      name = node2.name.name
      state.isLegacyRef.value = false
    }
  } else if (state.isLegacyRef.value === false || state.syntacticPlaceholders) {
    return
  } else if (isIdentifier$4(node2) || isJSXIdentifier(node2)) {
    name = node2.name
    state.isLegacyRef.value = true
  } else if (isStringLiteral$2(node2)) {
    name = node2.value
    state.isLegacyRef.value = true
  } else {
    return
  }
  if (!state.isLegacyRef.value && (state.placeholderPattern != null || state.placeholderWhitelist != null)) {
    throw new Error(
      "'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'"
    )
  }
  if (
    state.isLegacyRef.value &&
    (state.placeholderPattern === false || !(state.placeholderPattern || PATTERN).test(name)) &&
    !((_state$placeholderWhi = state.placeholderWhitelist) != null && _state$placeholderWhi.has(name))
  ) {
    return
  }
  ancestors = ancestors.slice()
  const { node: parent, key } = ancestors[ancestors.length - 1]
  let type
  if (
    isStringLiteral$2(node2) ||
    isPlaceholder(node2, {
      expectedNode: 'StringLiteral',
    })
  ) {
    type = 'string'
  } else if (
    (isNewExpression(parent) && key === 'arguments') ||
    (isCallExpression$1(parent) && key === 'arguments') ||
    (isFunction$1(parent) && key === 'params')
  ) {
    type = 'param'
  } else if (isExpressionStatement(parent) && !isPlaceholder(node2)) {
    type = 'statement'
    ancestors = ancestors.slice(0, -1)
  } else if (isStatement$1(node2) && isPlaceholder(node2)) {
    type = 'statement'
  } else {
    type = 'other'
  }
  const { placeholders: placeholders2, placeholderNames } = state.isLegacyRef.value ? state.legacy : state.syntactic
  placeholders2.push({
    name,
    type,
    resolve: (ast) => resolveAncestors(ast, ancestors),
    isDuplicate: placeholderNames.has(name),
  })
  placeholderNames.add(name)
}
function resolveAncestors(ast, ancestors) {
  let parent = ast
  for (let i = 0; i < ancestors.length - 1; i++) {
    const { key: key2, index: index3 } = ancestors[i]
    if (index3 === void 0) {
      parent = parent[key2]
    } else {
      parent = parent[key2][index3]
    }
  }
  const { key, index: index2 } = ancestors[ancestors.length - 1]
  return {
    parent,
    key,
    index: index2,
  }
}
function parseWithCodeFrame(code2, parserOpts, syntacticPlaceholders) {
  const plugins = (parserOpts.plugins || []).slice()
  if (syntacticPlaceholders !== false) {
    plugins.push('placeholders')
  }
  parserOpts = Object.assign(
    {
      allowReturnOutsideFunction: true,
      allowSuperOutsideMethod: true,
      sourceType: 'module',
    },
    parserOpts,
    {
      plugins,
    }
  )
  try {
    return (0, _parser.parse)(code2, parserOpts)
  } catch (err) {
    const loc = err.loc
    if (loc) {
      err.message +=
        '\n' +
        (0, _codeFrame.codeFrameColumns)(code2, {
          start: loc,
        })
      err.code = 'BABEL_TEMPLATE_PARSE_ERROR'
    }
    throw err
  }
}
var populate = {}
Object.defineProperty(populate, '__esModule', {
  value: true,
})
populate.default = populatePlaceholders
var _t$a = lib$b
const {
  blockStatement: blockStatement$2,
  cloneNode: cloneNode$3,
  emptyStatement,
  expressionStatement: expressionStatement$2,
  identifier: identifier$2,
  isStatement,
  isStringLiteral: isStringLiteral$1,
  stringLiteral: stringLiteral$1,
  validate: validate$1,
} = _t$a
function populatePlaceholders(metadata, replacements) {
  const ast = cloneNode$3(metadata.ast)
  if (replacements) {
    metadata.placeholders.forEach((placeholder2) => {
      if (!Object.prototype.hasOwnProperty.call(replacements, placeholder2.name)) {
        const placeholderName = placeholder2.name
        throw new Error(`Error: No substitution given for "${placeholderName}". If this is not meant to be a
            placeholder you may want to consider passing one of the following options to @babel/template:
            - { placeholderPattern: false, placeholderWhitelist: new Set(['${placeholderName}'])}
            - { placeholderPattern: /^${placeholderName}$/ }`)
      }
    })
    Object.keys(replacements).forEach((key) => {
      if (!metadata.placeholderNames.has(key)) {
        throw new Error(`Unknown substitution "${key}" given`)
      }
    })
  }
  metadata.placeholders
    .slice()
    .reverse()
    .forEach((placeholder2) => {
      try {
        applyReplacement(placeholder2, ast, (replacements && replacements[placeholder2.name]) || null)
      } catch (e) {
        e.message = `@babel/template placeholder "${placeholder2.name}": ${e.message}`
        throw e
      }
    })
  return ast
}
function applyReplacement(placeholder2, ast, replacement2) {
  if (placeholder2.isDuplicate) {
    if (Array.isArray(replacement2)) {
      replacement2 = replacement2.map((node2) => cloneNode$3(node2))
    } else if (typeof replacement2 === 'object') {
      replacement2 = cloneNode$3(replacement2)
    }
  }
  const { parent, key, index: index2 } = placeholder2.resolve(ast)
  if (placeholder2.type === 'string') {
    if (typeof replacement2 === 'string') {
      replacement2 = stringLiteral$1(replacement2)
    }
    if (!replacement2 || !isStringLiteral$1(replacement2)) {
      throw new Error('Expected string substitution')
    }
  } else if (placeholder2.type === 'statement') {
    if (index2 === void 0) {
      if (!replacement2) {
        replacement2 = emptyStatement()
      } else if (Array.isArray(replacement2)) {
        replacement2 = blockStatement$2(replacement2)
      } else if (typeof replacement2 === 'string') {
        replacement2 = expressionStatement$2(identifier$2(replacement2))
      } else if (!isStatement(replacement2)) {
        replacement2 = expressionStatement$2(replacement2)
      }
    } else {
      if (replacement2 && !Array.isArray(replacement2)) {
        if (typeof replacement2 === 'string') {
          replacement2 = identifier$2(replacement2)
        }
        if (!isStatement(replacement2)) {
          replacement2 = expressionStatement$2(replacement2)
        }
      }
    }
  } else if (placeholder2.type === 'param') {
    if (typeof replacement2 === 'string') {
      replacement2 = identifier$2(replacement2)
    }
    if (index2 === void 0) throw new Error('Assertion failure.')
  } else {
    if (typeof replacement2 === 'string') {
      replacement2 = identifier$2(replacement2)
    }
    if (Array.isArray(replacement2)) {
      throw new Error('Cannot replace single expression with an array.')
    }
  }
  if (index2 === void 0) {
    validate$1(parent, key, replacement2)
    parent[key] = replacement2
  } else {
    const items = parent[key].slice()
    if (placeholder2.type === 'statement' || placeholder2.type === 'param') {
      if (replacement2 == null) {
        items.splice(index2, 1)
      } else if (Array.isArray(replacement2)) {
        items.splice(index2, 1, ...replacement2)
      } else {
        items[index2] = replacement2
      }
    } else {
      items[index2] = replacement2
    }
    validate$1(parent, key, items)
    parent[key] = items
  }
}
Object.defineProperty(string, '__esModule', {
  value: true,
})
string.default = stringTemplate
var _options$2 = options
var _parse$1 = parse$1
var _populate$1 = populate
function stringTemplate(formatter, code2, opts) {
  code2 = formatter.code(code2)
  let metadata
  return (arg) => {
    const replacements = (0, _options$2.normalizeReplacements)(arg)
    if (!metadata) metadata = (0, _parse$1.default)(formatter, code2, opts)
    return formatter.unwrap((0, _populate$1.default)(metadata, replacements))
  }
}
var literal = {}
Object.defineProperty(literal, '__esModule', {
  value: true,
})
literal.default = literalTemplate
var _options$1 = options
var _parse = parse$1
var _populate = populate
function literalTemplate(formatter, tpl, opts) {
  const { metadata, names } = buildLiteralData(formatter, tpl, opts)
  return (arg) => {
    const defaultReplacements = {}
    arg.forEach((replacement2, i) => {
      defaultReplacements[names[i]] = replacement2
    })
    return (arg2) => {
      const replacements = (0, _options$1.normalizeReplacements)(arg2)
      if (replacements) {
        Object.keys(replacements).forEach((key) => {
          if (Object.prototype.hasOwnProperty.call(defaultReplacements, key)) {
            throw new Error('Unexpected replacement overlap.')
          }
        })
      }
      return formatter.unwrap(
        (0, _populate.default)(
          metadata,
          replacements ? Object.assign(replacements, defaultReplacements) : defaultReplacements
        )
      )
    }
  }
}
function buildLiteralData(formatter, tpl, opts) {
  let names
  let nameSet
  let metadata
  let prefix2 = ''
  do {
    prefix2 += '$'
    const result = buildTemplateCode(tpl, prefix2)
    names = result.names
    nameSet = new Set(names)
    metadata = (0, _parse.default)(formatter, formatter.code(result.code), {
      parser: opts.parser,
      placeholderWhitelist: new Set(
        result.names.concat(opts.placeholderWhitelist ? Array.from(opts.placeholderWhitelist) : [])
      ),
      placeholderPattern: opts.placeholderPattern,
      preserveComments: opts.preserveComments,
      syntacticPlaceholders: opts.syntacticPlaceholders,
    })
  } while (metadata.placeholders.some((placeholder2) => placeholder2.isDuplicate && nameSet.has(placeholder2.name)))
  return {
    metadata,
    names,
  }
}
function buildTemplateCode(tpl, prefix2) {
  const names = []
  let code2 = tpl[0]
  for (let i = 1; i < tpl.length; i++) {
    const value = `${prefix2}${i - 1}`
    names.push(value)
    code2 += value + tpl[i]
  }
  return {
    names,
    code: code2,
  }
}
Object.defineProperty(builder, '__esModule', {
  value: true,
})
builder.default = createTemplateBuilder
var _options = options
var _string = string
var _literal = literal
const NO_PLACEHOLDER = (0, _options.validate)({
  placeholderPattern: false,
})
function createTemplateBuilder(formatter, defaultOpts) {
  const templateFnCache = /* @__PURE__ */ new WeakMap()
  const templateAstCache = /* @__PURE__ */ new WeakMap()
  const cachedOpts = defaultOpts || (0, _options.validate)(null)
  return Object.assign(
    (tpl, ...args) => {
      if (typeof tpl === 'string') {
        if (args.length > 1) throw new Error('Unexpected extra params.')
        return extendedTrace(
          (0, _string.default)(formatter, tpl, (0, _options.merge)(cachedOpts, (0, _options.validate)(args[0])))
        )
      } else if (Array.isArray(tpl)) {
        let builder2 = templateFnCache.get(tpl)
        if (!builder2) {
          builder2 = (0, _literal.default)(formatter, tpl, cachedOpts)
          templateFnCache.set(tpl, builder2)
        }
        return extendedTrace(builder2(args))
      } else if (typeof tpl === 'object' && tpl) {
        if (args.length > 0) throw new Error('Unexpected extra params.')
        return createTemplateBuilder(formatter, (0, _options.merge)(cachedOpts, (0, _options.validate)(tpl)))
      }
      throw new Error(`Unexpected template param ${typeof tpl}`)
    },
    {
      ast: (tpl, ...args) => {
        if (typeof tpl === 'string') {
          if (args.length > 1) throw new Error('Unexpected extra params.')
          return (0, _string.default)(
            formatter,
            tpl,
            (0, _options.merge)((0, _options.merge)(cachedOpts, (0, _options.validate)(args[0])), NO_PLACEHOLDER)
          )()
        } else if (Array.isArray(tpl)) {
          let builder2 = templateAstCache.get(tpl)
          if (!builder2) {
            builder2 = (0, _literal.default)(formatter, tpl, (0, _options.merge)(cachedOpts, NO_PLACEHOLDER))
            templateAstCache.set(tpl, builder2)
          }
          return builder2(args)()
        }
        throw new Error(`Unexpected template param ${typeof tpl}`)
      },
    }
  )
}
function extendedTrace(fn) {
  let rootStack = ''
  try {
    throw new Error()
  } catch (error) {
    if (error.stack) {
      rootStack = error.stack.split('\n').slice(3).join('\n')
    }
  }
  return (arg) => {
    try {
      return fn(arg)
    } catch (err) {
      err.stack += `
    =============
${rootStack}`
      throw err
    }
  }
}
Object.defineProperty(lib$1, '__esModule', {
  value: true,
})
lib$1.statements = lib$1.statement = lib$1.smart = lib$1.program = lib$1.expression = lib$1.default = void 0
var formatters = formatters$1
var _builder = builder
const smart = (0, _builder.default)(formatters.smart)
lib$1.smart = smart
const statement = (0, _builder.default)(formatters.statement)
lib$1.statement = statement
const statements = (0, _builder.default)(formatters.statements)
lib$1.statements = statements
const expression = (0, _builder.default)(formatters.expression)
lib$1.expression = expression
const program = (0, _builder.default)(formatters.program)
lib$1.program = program
var _default$2 = Object.assign(smart.bind(void 0), {
  smart,
  statement,
  statements,
  expression,
  program,
  ast: smart.ast,
})
lib$1.default = _default$2
Object.defineProperty(lib$2, '__esModule', {
  value: true,
})
lib$2.default = _default$1
var _template = lib$1
var _t$9 = lib$b
const {
  NOT_LOCAL_BINDING,
  cloneNode: cloneNode$2,
  identifier: identifier$1,
  isAssignmentExpression: isAssignmentExpression$1,
  isAssignmentPattern,
  isFunction,
  isIdentifier: isIdentifier$3,
  isLiteral: isLiteral$1,
  isNullLiteral,
  isObjectMethod,
  isObjectProperty,
  isRegExpLiteral,
  isRestElement,
  isTemplateLiteral,
  isVariableDeclarator,
  toBindingIdentifierName,
} = _t$9
function getFunctionArity(node2) {
  const count = node2.params.findIndex((param) => isAssignmentPattern(param) || isRestElement(param))
  return count === -1 ? node2.params.length : count
}
const buildPropertyMethodAssignmentWrapper = (0, _template.default)(`
  (function (FUNCTION_KEY) {
    function FUNCTION_ID() {
      return FUNCTION_KEY.apply(this, arguments);
    }

    FUNCTION_ID.toString = function () {
      return FUNCTION_KEY.toString();
    }

    return FUNCTION_ID;
  })(FUNCTION)
`)
const buildGeneratorPropertyMethodAssignmentWrapper = (0, _template.default)(`
  (function (FUNCTION_KEY) {
    function* FUNCTION_ID() {
      return yield* FUNCTION_KEY.apply(this, arguments);
    }

    FUNCTION_ID.toString = function () {
      return FUNCTION_KEY.toString();
    };

    return FUNCTION_ID;
  })(FUNCTION)
`)
const visitor = {
  'ReferencedIdentifier|BindingIdentifier'(path2, state) {
    if (path2.node.name !== state.name) return
    const localDeclar = path2.scope.getBindingIdentifier(state.name)
    if (localDeclar !== state.outerDeclar) return
    state.selfReference = true
    path2.stop()
  },
}
function getNameFromLiteralId(id) {
  if (isNullLiteral(id)) {
    return 'null'
  }
  if (isRegExpLiteral(id)) {
    return `_${id.pattern}_${id.flags}`
  }
  if (isTemplateLiteral(id)) {
    return id.quasis.map((quasi) => quasi.value.raw).join('')
  }
  if (id.value !== void 0) {
    return id.value + ''
  }
  return ''
}
function wrap(state, method, id, scope2) {
  if (state.selfReference) {
    if (scope2.hasBinding(id.name) && !scope2.hasGlobal(id.name)) {
      scope2.rename(id.name)
    } else {
      if (!isFunction(method)) return
      let build = buildPropertyMethodAssignmentWrapper
      if (method.generator) {
        build = buildGeneratorPropertyMethodAssignmentWrapper
      }
      const template = build({
        FUNCTION: method,
        FUNCTION_ID: id,
        FUNCTION_KEY: scope2.generateUidIdentifier(id.name),
      }).expression
      const params = template.callee.body.body[0].params
      for (let i = 0, len = getFunctionArity(method); i < len; i++) {
        params.push(scope2.generateUidIdentifier('x'))
      }
      return template
    }
  }
  method.id = id
  scope2.getProgramParent().references[id.name] = true
}
function visit$1(node2, name, scope2) {
  const state = {
    selfAssignment: false,
    selfReference: false,
    outerDeclar: scope2.getBindingIdentifier(name),
    references: [],
    name,
  }
  const binding2 = scope2.getOwnBinding(name)
  if (binding2) {
    if (binding2.kind === 'param') {
      state.selfReference = true
    }
  } else if (state.outerDeclar || scope2.hasGlobal(name)) {
    scope2.traverse(node2, visitor, state)
  }
  return state
}
function _default$1({ node: node2, parent, scope: scope2, id }, localBinding = false, supportUnicodeId = false) {
  if (node2.id) return
  if (
    (isObjectProperty(parent) ||
      isObjectMethod(parent, {
        kind: 'method',
      })) &&
    (!parent.computed || isLiteral$1(parent.key))
  ) {
    id = parent.key
  } else if (isVariableDeclarator(parent)) {
    id = parent.id
    if (isIdentifier$3(id) && !localBinding) {
      const binding2 = scope2.parent.getBinding(id.name)
      if (binding2 && binding2.constant && scope2.getBinding(id.name) === binding2) {
        node2.id = cloneNode$2(id)
        node2.id[NOT_LOCAL_BINDING] = true
        return
      }
    }
  } else if (
    isAssignmentExpression$1(parent, {
      operator: '=',
    })
  ) {
    id = parent.left
  } else if (!id) {
    return
  }
  let name
  if (id && isLiteral$1(id)) {
    name = getNameFromLiteralId(id)
  } else if (id && isIdentifier$3(id)) {
    name = id.name
  }
  if (name === void 0) {
    return
  }
  if (!supportUnicodeId && isFunction(node2) && /[\uD800-\uDFFF]/.test(name)) {
    return
  }
  name = toBindingIdentifierName(name)
  id = identifier$1(name)
  id[NOT_LOCAL_BINDING] = true
  const state = visit$1(node2, name, scope2)
  return wrap(state, node2, id, scope2) || node2
}
Object.defineProperty(conversion, '__esModule', {
  value: true,
})
conversion.arrowFunctionToExpression = arrowFunctionToExpression
conversion.arrowFunctionToShadowed = arrowFunctionToShadowed
conversion.ensureBlock = ensureBlock
conversion.toComputedKey = toComputedKey
conversion.unwrapFunctionEnvironment = unwrapFunctionEnvironment
var _t$8 = lib$b
var _helperEnvironmentVisitor = lib$8
var _helperFunctionName = lib$2
var _visitors = visitors
const {
  arrowFunctionExpression: arrowFunctionExpression$1,
  assignmentExpression: assignmentExpression$1,
  binaryExpression,
  blockStatement: blockStatement$1,
  callExpression: callExpression$1,
  conditionalExpression,
  expressionStatement: expressionStatement$1,
  identifier,
  isIdentifier: isIdentifier$2,
  jsxIdentifier,
  logicalExpression,
  LOGICAL_OPERATORS,
  memberExpression,
  metaProperty,
  numericLiteral: numericLiteral$1,
  objectExpression,
  restElement,
  returnStatement,
  sequenceExpression,
  spreadElement,
  stringLiteral,
  super: _super,
  thisExpression: thisExpression$1,
  toExpression,
  unaryExpression: unaryExpression$1,
} = _t$8
function toComputedKey() {
  let key
  if (this.isMemberExpression()) {
    key = this.node.property
  } else if (this.isProperty() || this.isMethod()) {
    key = this.node.key
  } else {
    throw new ReferenceError('todo')
  }
  if (!this.node.computed) {
    if (isIdentifier$2(key)) key = stringLiteral(key.name)
  }
  return key
}
function ensureBlock() {
  const body = this.get('body')
  const bodyNode = body.node
  if (Array.isArray(body)) {
    throw new Error("Can't convert array path to a block statement")
  }
  if (!bodyNode) {
    throw new Error("Can't convert node without a body")
  }
  if (body.isBlockStatement()) {
    return bodyNode
  }
  const statements2 = []
  let stringPath = 'body'
  let key
  let listKey
  if (body.isStatement()) {
    listKey = 'body'
    key = 0
    statements2.push(body.node)
  } else {
    stringPath += '.body.0'
    if (this.isFunction()) {
      key = 'argument'
      statements2.push(returnStatement(body.node))
    } else {
      key = 'expression'
      statements2.push(expressionStatement$1(body.node))
    }
  }
  this.node.body = blockStatement$1(statements2)
  const parentPath = this.get(stringPath)
  body.setup(parentPath, listKey ? parentPath.node[listKey] : parentPath.node, listKey, key)
  return this.node
}
function arrowFunctionToShadowed() {
  if (!this.isArrowFunctionExpression()) return
  this.arrowFunctionToExpression()
}
function unwrapFunctionEnvironment() {
  if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration()) {
    throw this.buildCodeFrameError('Can only unwrap the environment of a function.')
  }
  hoistFunctionEnvironment(this)
}
function arrowFunctionToExpression({
  allowInsertArrow = true,
  specCompliant = false,
  noNewArrows = !specCompliant,
} = {}) {
  if (!this.isArrowFunctionExpression()) {
    throw this.buildCodeFrameError('Cannot convert non-arrow function to a function expression.')
  }
  const { thisBinding, fnPath: fn } = hoistFunctionEnvironment(this, noNewArrows, allowInsertArrow)
  fn.ensureBlock()
  fn.node.type = 'FunctionExpression'
  if (!noNewArrows) {
    const checkBinding = thisBinding ? null : fn.scope.generateUidIdentifier('arrowCheckId')
    if (checkBinding) {
      fn.parentPath.scope.push({
        id: checkBinding,
        init: objectExpression([]),
      })
    }
    fn.get('body').unshiftContainer(
      'body',
      expressionStatement$1(
        callExpression$1(this.hub.addHelper('newArrowCheck'), [
          thisExpression$1(),
          checkBinding ? identifier(checkBinding.name) : identifier(thisBinding),
        ])
      )
    )
    fn.replaceWith(
      callExpression$1(memberExpression((0, _helperFunctionName.default)(this, true) || fn.node, identifier('bind')), [
        checkBinding ? identifier(checkBinding.name) : thisExpression$1(),
      ])
    )
  }
}
const getSuperCallsVisitor = (0, _visitors.merge)([
  {
    CallExpression(child, { allSuperCalls }) {
      if (!child.get('callee').isSuper()) return
      allSuperCalls.push(child)
    },
  },
  _helperEnvironmentVisitor.default,
])
function hoistFunctionEnvironment(fnPath, noNewArrows = true, allowInsertArrow = true) {
  let arrowParent
  let thisEnvFn = fnPath.findParent((p) => {
    if (p.isArrowFunctionExpression()) {
      var _arrowParent
      ;(_arrowParent = arrowParent) != null ? _arrowParent : (arrowParent = p)
      return false
    }
    return (
      p.isFunction() ||
      p.isProgram() ||
      p.isClassProperty({
        static: false,
      }) ||
      p.isClassPrivateProperty({
        static: false,
      })
    )
  })
  const inConstructor = thisEnvFn.isClassMethod({
    kind: 'constructor',
  })
  if (thisEnvFn.isClassProperty() || thisEnvFn.isClassPrivateProperty()) {
    if (arrowParent) {
      thisEnvFn = arrowParent
    } else if (allowInsertArrow) {
      fnPath.replaceWith(callExpression$1(arrowFunctionExpression$1([], toExpression(fnPath.node)), []))
      thisEnvFn = fnPath.get('callee')
      fnPath = thisEnvFn.get('body')
    } else {
      throw fnPath.buildCodeFrameError('Unable to transform arrow inside class property')
    }
  }
  const { thisPaths, argumentsPaths, newTargetPaths, superProps, superCalls } = getScopeInformation(fnPath)
  if (inConstructor && superCalls.length > 0) {
    if (!allowInsertArrow) {
      throw superCalls[0].buildCodeFrameError('Unable to handle nested super() usage in arrow')
    }
    const allSuperCalls = []
    thisEnvFn.traverse(getSuperCallsVisitor, {
      allSuperCalls,
    })
    const superBinding = getSuperBinding(thisEnvFn)
    allSuperCalls.forEach((superCall) => {
      const callee = identifier(superBinding)
      callee.loc = superCall.node.callee.loc
      superCall.get('callee').replaceWith(callee)
    })
  }
  if (argumentsPaths.length > 0) {
    const argumentsBinding = getBinding(thisEnvFn, 'arguments', () => {
      const args = () => identifier('arguments')
      if (thisEnvFn.scope.path.isProgram()) {
        return conditionalExpression(
          binaryExpression('===', unaryExpression$1('typeof', args()), stringLiteral('undefined')),
          thisEnvFn.scope.buildUndefinedNode(),
          args()
        )
      } else {
        return args()
      }
    })
    argumentsPaths.forEach((argumentsChild) => {
      const argsRef = identifier(argumentsBinding)
      argsRef.loc = argumentsChild.node.loc
      argumentsChild.replaceWith(argsRef)
    })
  }
  if (newTargetPaths.length > 0) {
    const newTargetBinding = getBinding(thisEnvFn, 'newtarget', () =>
      metaProperty(identifier('new'), identifier('target'))
    )
    newTargetPaths.forEach((targetChild) => {
      const targetRef = identifier(newTargetBinding)
      targetRef.loc = targetChild.node.loc
      targetChild.replaceWith(targetRef)
    })
  }
  if (superProps.length > 0) {
    if (!allowInsertArrow) {
      throw superProps[0].buildCodeFrameError('Unable to handle nested super.prop usage')
    }
    const flatSuperProps = superProps.reduce((acc, superProp) => acc.concat(standardizeSuperProperty(superProp)), [])
    flatSuperProps.forEach((superProp) => {
      const key = superProp.node.computed ? '' : superProp.get('property').node.name
      const isAssignment = superProp.parentPath.isAssignmentExpression({
        left: superProp.node,
      })
      const isCall = superProp.parentPath.isCallExpression({
        callee: superProp.node,
      })
      const superBinding = getSuperPropBinding(thisEnvFn, isAssignment, key)
      const args = []
      if (superProp.node.computed) {
        args.push(superProp.get('property').node)
      }
      if (isAssignment) {
        const value = superProp.parentPath.node.right
        args.push(value)
      }
      const call2 = callExpression$1(identifier(superBinding), args)
      if (isCall) {
        superProp.parentPath.unshiftContainer('arguments', thisExpression$1())
        superProp.replaceWith(memberExpression(call2, identifier('call')))
        thisPaths.push(superProp.parentPath.get('arguments.0'))
      } else if (isAssignment) {
        superProp.parentPath.replaceWith(call2)
      } else {
        superProp.replaceWith(call2)
      }
    })
  }
  let thisBinding
  if (thisPaths.length > 0 || !noNewArrows) {
    thisBinding = getThisBinding(thisEnvFn, inConstructor)
    if (noNewArrows || (inConstructor && hasSuperClass(thisEnvFn))) {
      thisPaths.forEach((thisChild) => {
        const thisRef = thisChild.isJSX() ? jsxIdentifier(thisBinding) : identifier(thisBinding)
        thisRef.loc = thisChild.node.loc
        thisChild.replaceWith(thisRef)
      })
      if (!noNewArrows) thisBinding = null
    }
  }
  return {
    thisBinding,
    fnPath,
  }
}
function isLogicalOp(op) {
  return LOGICAL_OPERATORS.includes(op)
}
function standardizeSuperProperty(superProp) {
  if (superProp.parentPath.isAssignmentExpression() && superProp.parentPath.node.operator !== '=') {
    const assignmentPath = superProp.parentPath
    const op = assignmentPath.node.operator.slice(0, -1)
    const value = assignmentPath.node.right
    const isLogicalAssignment = isLogicalOp(op)
    if (superProp.node.computed) {
      const tmp = superProp.scope.generateDeclaredUidIdentifier('tmp')
      const object2 = superProp.node.object
      const property = superProp.node.property
      assignmentPath
        .get('left')
        .replaceWith(memberExpression(object2, assignmentExpression$1('=', tmp, property), true))
      assignmentPath
        .get('right')
        .replaceWith(
          rightExpression(isLogicalAssignment ? '=' : op, memberExpression(object2, identifier(tmp.name), true), value)
        )
    } else {
      const object2 = superProp.node.object
      const property = superProp.node.property
      assignmentPath.get('left').replaceWith(memberExpression(object2, property))
      assignmentPath
        .get('right')
        .replaceWith(
          rightExpression(isLogicalAssignment ? '=' : op, memberExpression(object2, identifier(property.name)), value)
        )
    }
    if (isLogicalAssignment) {
      assignmentPath.replaceWith(logicalExpression(op, assignmentPath.node.left, assignmentPath.node.right))
    } else {
      assignmentPath.node.operator = '='
    }
    return [assignmentPath.get('left'), assignmentPath.get('right').get('left')]
  } else if (superProp.parentPath.isUpdateExpression()) {
    const updateExpr = superProp.parentPath
    const tmp = superProp.scope.generateDeclaredUidIdentifier('tmp')
    const computedKey = superProp.node.computed ? superProp.scope.generateDeclaredUidIdentifier('prop') : null
    const parts = [
      assignmentExpression$1(
        '=',
        tmp,
        memberExpression(
          superProp.node.object,
          computedKey ? assignmentExpression$1('=', computedKey, superProp.node.property) : superProp.node.property,
          superProp.node.computed
        )
      ),
      assignmentExpression$1(
        '=',
        memberExpression(
          superProp.node.object,
          computedKey ? identifier(computedKey.name) : superProp.node.property,
          superProp.node.computed
        ),
        binaryExpression(superProp.parentPath.node.operator[0], identifier(tmp.name), numericLiteral$1(1))
      ),
    ]
    if (!superProp.parentPath.node.prefix) {
      parts.push(identifier(tmp.name))
    }
    updateExpr.replaceWith(sequenceExpression(parts))
    const left = updateExpr.get('expressions.0.right')
    const right = updateExpr.get('expressions.1.left')
    return [left, right]
  }
  return [superProp]
  function rightExpression(op, left, right) {
    if (op === '=') {
      return assignmentExpression$1('=', left, right)
    } else {
      return binaryExpression(op, left, right)
    }
  }
}
function hasSuperClass(thisEnvFn) {
  return thisEnvFn.isClassMethod() && !!thisEnvFn.parentPath.parentPath.node.superClass
}
const assignSuperThisVisitor = (0, _visitors.merge)([
  {
    CallExpression(child, { supers, thisBinding }) {
      if (!child.get('callee').isSuper()) return
      if (supers.has(child.node)) return
      supers.add(child.node)
      child.replaceWithMultiple([child.node, assignmentExpression$1('=', identifier(thisBinding), identifier('this'))])
    },
  },
  _helperEnvironmentVisitor.default,
])
function getThisBinding(thisEnvFn, inConstructor) {
  return getBinding(thisEnvFn, 'this', (thisBinding) => {
    if (!inConstructor || !hasSuperClass(thisEnvFn)) return thisExpression$1()
    thisEnvFn.traverse(assignSuperThisVisitor, {
      supers: /* @__PURE__ */ new WeakSet(),
      thisBinding,
    })
  })
}
function getSuperBinding(thisEnvFn) {
  return getBinding(thisEnvFn, 'supercall', () => {
    const argsBinding = thisEnvFn.scope.generateUidIdentifier('args')
    return arrowFunctionExpression$1(
      [restElement(argsBinding)],
      callExpression$1(_super(), [spreadElement(identifier(argsBinding.name))])
    )
  })
}
function getSuperPropBinding(thisEnvFn, isAssignment, propName) {
  const op = isAssignment ? 'set' : 'get'
  return getBinding(thisEnvFn, `superprop_${op}:${propName || ''}`, () => {
    const argsList = []
    let fnBody
    if (propName) {
      fnBody = memberExpression(_super(), identifier(propName))
    } else {
      const method = thisEnvFn.scope.generateUidIdentifier('prop')
      argsList.unshift(method)
      fnBody = memberExpression(_super(), identifier(method.name), true)
    }
    if (isAssignment) {
      const valueIdent = thisEnvFn.scope.generateUidIdentifier('value')
      argsList.push(valueIdent)
      fnBody = assignmentExpression$1('=', fnBody, identifier(valueIdent.name))
    }
    return arrowFunctionExpression$1(argsList, fnBody)
  })
}
function getBinding(thisEnvFn, key, init) {
  const cacheKey = 'binding:' + key
  let data = thisEnvFn.getData(cacheKey)
  if (!data) {
    const id = thisEnvFn.scope.generateUidIdentifier(key)
    data = id.name
    thisEnvFn.setData(cacheKey, data)
    thisEnvFn.scope.push({
      id,
      init: init(data),
    })
  }
  return data
}
const getScopeInformationVisitor = (0, _visitors.merge)([
  {
    ThisExpression(child, { thisPaths }) {
      thisPaths.push(child)
    },
    JSXIdentifier(child, { thisPaths }) {
      if (child.node.name !== 'this') return
      if (
        !child.parentPath.isJSXMemberExpression({
          object: child.node,
        }) &&
        !child.parentPath.isJSXOpeningElement({
          name: child.node,
        })
      ) {
        return
      }
      thisPaths.push(child)
    },
    CallExpression(child, { superCalls }) {
      if (child.get('callee').isSuper()) superCalls.push(child)
    },
    MemberExpression(child, { superProps }) {
      if (child.get('object').isSuper()) superProps.push(child)
    },
    Identifier(child, { argumentsPaths }) {
      if (
        !child.isReferencedIdentifier({
          name: 'arguments',
        })
      )
        return
      let curr = child.scope
      do {
        if (curr.hasOwnBinding('arguments')) {
          curr.rename('arguments')
          return
        }
        if (curr.path.isFunction() && !curr.path.isArrowFunctionExpression()) {
          break
        }
      } while ((curr = curr.parent))
      argumentsPaths.push(child)
    },
    MetaProperty(child, { newTargetPaths }) {
      if (
        !child.get('meta').isIdentifier({
          name: 'new',
        })
      )
        return
      if (
        !child.get('property').isIdentifier({
          name: 'target',
        })
      )
        return
      newTargetPaths.push(child)
    },
  },
  _helperEnvironmentVisitor.default,
])
function getScopeInformation(fnPath) {
  const thisPaths = []
  const argumentsPaths = []
  const newTargetPaths = []
  const superProps = []
  const superCalls = []
  fnPath.traverse(getScopeInformationVisitor, {
    thisPaths,
    argumentsPaths,
    newTargetPaths,
    superProps,
    superCalls,
  })
  return {
    thisPaths,
    argumentsPaths,
    newTargetPaths,
    superProps,
    superCalls,
  }
}
var introspection = {}
Object.defineProperty(introspection, '__esModule', {
  value: true,
})
introspection._guessExecutionStatusRelativeTo = _guessExecutionStatusRelativeTo
introspection._resolve = _resolve
introspection.canHaveVariableDeclarationOrExpression = canHaveVariableDeclarationOrExpression
introspection.canSwapBetweenExpressionAndStatement = canSwapBetweenExpressionAndStatement
introspection.equals = equals
introspection.getSource = getSource
introspection.has = has
introspection.is = void 0
introspection.isCompletionRecord = isCompletionRecord
introspection.isConstantExpression = isConstantExpression
introspection.isInStrictMode = isInStrictMode
introspection.isNodeType = isNodeType
introspection.isStatementOrBlock = isStatementOrBlock
introspection.isStatic = isStatic
introspection.isnt = isnt
introspection.matchesPattern = matchesPattern
introspection.referencesImport = referencesImport
introspection.resolve = resolve
introspection.willIMaybeExecuteBefore = willIMaybeExecuteBefore
var _t$7 = lib$b
const {
  STATEMENT_OR_BLOCK_KEYS,
  VISITOR_KEYS: VISITOR_KEYS$2,
  isBlockStatement,
  isExpression: isExpression$1,
  isIdentifier: isIdentifier$1,
  isLiteral,
  isStringLiteral,
  isType,
  matchesPattern: _matchesPattern,
} = _t$7
function matchesPattern(pattern, allowPartial) {
  return _matchesPattern(this.node, pattern, allowPartial)
}
function has(key) {
  const val = this.node && this.node[key]
  if (val && Array.isArray(val)) {
    return !!val.length
  } else {
    return !!val
  }
}
function isStatic() {
  return this.scope.isStatic(this.node)
}
const is = has
introspection.is = is
function isnt(key) {
  return !this.has(key)
}
function equals(key, value) {
  return this.node[key] === value
}
function isNodeType(type) {
  return isType(this.type, type)
}
function canHaveVariableDeclarationOrExpression() {
  return (this.key === 'init' || this.key === 'left') && this.parentPath.isFor()
}
function canSwapBetweenExpressionAndStatement(replacement2) {
  if (this.key !== 'body' || !this.parentPath.isArrowFunctionExpression()) {
    return false
  }
  if (this.isExpression()) {
    return isBlockStatement(replacement2)
  } else if (this.isBlockStatement()) {
    return isExpression$1(replacement2)
  }
  return false
}
function isCompletionRecord(allowInsideFunction) {
  let path2 = this
  let first = true
  do {
    const { type, container } = path2
    if (!first && (path2.isFunction() || type === 'StaticBlock')) {
      return !!allowInsideFunction
    }
    first = false
    if (Array.isArray(container) && path2.key !== container.length - 1) {
      return false
    }
  } while ((path2 = path2.parentPath) && !path2.isProgram() && !path2.isDoExpression())
  return true
}
function isStatementOrBlock() {
  if (this.parentPath.isLabeledStatement() || isBlockStatement(this.container)) {
    return false
  } else {
    return STATEMENT_OR_BLOCK_KEYS.includes(this.key)
  }
}
function referencesImport(moduleSource, importName) {
  if (!this.isReferencedIdentifier()) {
    if (
      (this.isJSXMemberExpression() && this.node.property.name === importName) ||
      ((this.isMemberExpression() || this.isOptionalMemberExpression()) &&
        (this.node.computed
          ? isStringLiteral(this.node.property, {
              value: importName,
            })
          : this.node.property.name === importName))
    ) {
      const object2 = this.get('object')
      return object2.isReferencedIdentifier() && object2.referencesImport(moduleSource, '*')
    }
    return false
  }
  const binding2 = this.scope.getBinding(this.node.name)
  if (!binding2 || binding2.kind !== 'module') return false
  const path2 = binding2.path
  const parent = path2.parentPath
  if (!parent.isImportDeclaration()) return false
  if (parent.node.source.value === moduleSource) {
    if (!importName) return true
  } else {
    return false
  }
  if (path2.isImportDefaultSpecifier() && importName === 'default') {
    return true
  }
  if (path2.isImportNamespaceSpecifier() && importName === '*') {
    return true
  }
  if (
    path2.isImportSpecifier() &&
    isIdentifier$1(path2.node.imported, {
      name: importName,
    })
  ) {
    return true
  }
  return false
}
function getSource() {
  const node2 = this.node
  if (node2.end) {
    const code2 = this.hub.getCode()
    if (code2) return code2.slice(node2.start, node2.end)
  }
  return ''
}
function willIMaybeExecuteBefore(target) {
  return this._guessExecutionStatusRelativeTo(target) !== 'after'
}
function getOuterFunction(path2) {
  return (path2.scope.getFunctionParent() || path2.scope.getProgramParent()).path
}
function isExecutionUncertain(type, key) {
  switch (type) {
    case 'LogicalExpression':
      return key === 'right'
    case 'ConditionalExpression':
    case 'IfStatement':
      return key === 'consequent' || key === 'alternate'
    case 'WhileStatement':
    case 'DoWhileStatement':
    case 'ForInStatement':
    case 'ForOfStatement':
      return key === 'body'
    case 'ForStatement':
      return key === 'body' || key === 'update'
    case 'SwitchStatement':
      return key === 'cases'
    case 'TryStatement':
      return key === 'handler'
    case 'AssignmentPattern':
      return key === 'right'
    case 'OptionalMemberExpression':
      return key === 'property'
    case 'OptionalCallExpression':
      return key === 'arguments'
    default:
      return false
  }
}
function isExecutionUncertainInList(paths, maxIndex) {
  for (let i = 0; i < maxIndex; i++) {
    const path2 = paths[i]
    if (isExecutionUncertain(path2.parent.type, path2.parentKey)) {
      return true
    }
  }
  return false
}
function _guessExecutionStatusRelativeTo(target) {
  return _guessExecutionStatusRelativeToCached(this, target, /* @__PURE__ */ new Map())
}
function _guessExecutionStatusRelativeToCached(base2, target, cache2) {
  const funcParent = {
    this: getOuterFunction(base2),
    target: getOuterFunction(target),
  }
  if (funcParent.target.node !== funcParent.this.node) {
    return _guessExecutionStatusRelativeToDifferentFunctionsCached(base2, funcParent.target, cache2)
  }
  const paths = {
    target: target.getAncestry(),
    this: base2.getAncestry(),
  }
  if (paths.target.indexOf(base2) >= 0) return 'after'
  if (paths.this.indexOf(target) >= 0) return 'before'
  let commonPath
  const commonIndex = {
    target: 0,
    this: 0,
  }
  while (!commonPath && commonIndex.this < paths.this.length) {
    const path2 = paths.this[commonIndex.this]
    commonIndex.target = paths.target.indexOf(path2)
    if (commonIndex.target >= 0) {
      commonPath = path2
    } else {
      commonIndex.this++
    }
  }
  if (!commonPath) {
    throw new Error("Internal Babel error - The two compared nodes don't appear to belong to the same program.")
  }
  if (
    isExecutionUncertainInList(paths.this, commonIndex.this - 1) ||
    isExecutionUncertainInList(paths.target, commonIndex.target - 1)
  ) {
    return 'unknown'
  }
  const divergence = {
    this: paths.this[commonIndex.this - 1],
    target: paths.target[commonIndex.target - 1],
  }
  if (
    divergence.target.listKey &&
    divergence.this.listKey &&
    divergence.target.container === divergence.this.container
  ) {
    return divergence.target.key > divergence.this.key ? 'before' : 'after'
  }
  const keys = VISITOR_KEYS$2[commonPath.type]
  const keyPosition = {
    this: keys.indexOf(divergence.this.parentKey),
    target: keys.indexOf(divergence.target.parentKey),
  }
  return keyPosition.target > keyPosition.this ? 'before' : 'after'
}
const executionOrderCheckedNodes = /* @__PURE__ */ new Set()
function _guessExecutionStatusRelativeToDifferentFunctionsInternal(base2, target, cache2) {
  if (!target.isFunctionDeclaration() || target.parentPath.isExportDeclaration()) {
    return 'unknown'
  }
  const binding2 = target.scope.getBinding(target.node.id.name)
  if (!binding2.references) return 'before'
  const referencePaths = binding2.referencePaths
  let allStatus
  for (const path2 of referencePaths) {
    const childOfFunction = !!path2.find((path3) => path3.node === target.node)
    if (childOfFunction) continue
    if (path2.key !== 'callee' || !path2.parentPath.isCallExpression()) {
      return 'unknown'
    }
    if (executionOrderCheckedNodes.has(path2.node)) continue
    executionOrderCheckedNodes.add(path2.node)
    try {
      const status = _guessExecutionStatusRelativeToCached(base2, path2, cache2)
      if (allStatus && allStatus !== status) {
        return 'unknown'
      } else {
        allStatus = status
      }
    } finally {
      executionOrderCheckedNodes.delete(path2.node)
    }
  }
  return allStatus
}
function _guessExecutionStatusRelativeToDifferentFunctionsCached(base2, target, cache2) {
  let nodeMap = cache2.get(base2.node)
  if (!nodeMap) {
    cache2.set(base2.node, (nodeMap = /* @__PURE__ */ new Map()))
  } else if (nodeMap.has(target.node)) {
    return nodeMap.get(target.node)
  }
  const result = _guessExecutionStatusRelativeToDifferentFunctionsInternal(base2, target, cache2)
  nodeMap.set(target.node, result)
  return result
}
function resolve(dangerous, resolved) {
  return this._resolve(dangerous, resolved) || this
}
function _resolve(dangerous, resolved) {
  if (resolved && resolved.indexOf(this) >= 0) return
  resolved = resolved || []
  resolved.push(this)
  if (this.isVariableDeclarator()) {
    if (this.get('id').isIdentifier()) {
      return this.get('init').resolve(dangerous, resolved)
    }
  } else if (this.isReferencedIdentifier()) {
    const binding2 = this.scope.getBinding(this.node.name)
    if (!binding2) return
    if (!binding2.constant) return
    if (binding2.kind === 'module') return
    if (binding2.path !== this) {
      const ret = binding2.path.resolve(dangerous, resolved)
      if (this.find((parent) => parent.node === ret.node)) return
      return ret
    }
  } else if (this.isTypeCastExpression()) {
    return this.get('expression').resolve(dangerous, resolved)
  } else if (dangerous && this.isMemberExpression()) {
    const targetKey = this.toComputedKey()
    if (!isLiteral(targetKey)) return
    const targetName = targetKey.value
    const target = this.get('object').resolve(dangerous, resolved)
    if (target.isObjectExpression()) {
      const props2 = target.get('properties')
      for (const prop of props2) {
        if (!prop.isProperty()) continue
        const key = prop.get('key')
        let match =
          prop.isnt('computed') &&
          key.isIdentifier({
            name: targetName,
          })
        match =
          match ||
          key.isLiteral({
            value: targetName,
          })
        if (match) return prop.get('value').resolve(dangerous, resolved)
      }
    } else if (target.isArrayExpression() && !isNaN(+targetName)) {
      const elems = target.get('elements')
      const elem = elems[targetName]
      if (elem) return elem.resolve(dangerous, resolved)
    }
  }
}
function isConstantExpression() {
  if (this.isIdentifier()) {
    const binding2 = this.scope.getBinding(this.node.name)
    if (!binding2) return false
    return binding2.constant
  }
  if (this.isLiteral()) {
    if (this.isRegExpLiteral()) {
      return false
    }
    if (this.isTemplateLiteral()) {
      return this.get('expressions').every((expression2) => expression2.isConstantExpression())
    }
    return true
  }
  if (this.isUnaryExpression()) {
    if (this.node.operator !== 'void') {
      return false
    }
    return this.get('argument').isConstantExpression()
  }
  if (this.isBinaryExpression()) {
    return this.get('left').isConstantExpression() && this.get('right').isConstantExpression()
  }
  return false
}
function isInStrictMode() {
  const start = this.isProgram() ? this : this.parentPath
  const strictParent = start.find((path2) => {
    if (
      path2.isProgram({
        sourceType: 'module',
      })
    )
      return true
    if (path2.isClass()) return true
    if (!path2.isProgram() && !path2.isFunction()) return false
    if (path2.isArrowFunctionExpression() && !path2.get('body').isBlockStatement()) {
      return false
    }
    const body = path2.isFunction() ? path2.node.body : path2.node
    for (const directive2 of body.directives) {
      if (directive2.value.value === 'use strict') {
        return true
      }
    }
  })
  return !!strictParent
}
var context$1 = {}
Object.defineProperty(context$1, '__esModule', {
  value: true,
})
context$1._call = _call
context$1._getQueueContexts = _getQueueContexts
context$1._resyncKey = _resyncKey
context$1._resyncList = _resyncList
context$1._resyncParent = _resyncParent
context$1._resyncRemoved = _resyncRemoved
context$1.call = call$1
context$1.isBlacklisted = context$1.isDenylisted = isDenylisted
context$1.popContext = popContext
context$1.pushContext = pushContext
context$1.requeue = requeue
context$1.resync = resync
context$1.setContext = setContext
context$1.setKey = setKey
context$1.setScope = setScope
context$1.setup = setup
context$1.skip = skip
context$1.skipKey = skipKey
context$1.stop = stop
context$1.visit = visit
var _traverseNode = traverseNode$1
var _index$4 = path
function call$1(key) {
  const opts = this.opts
  this.debug(key)
  if (this.node) {
    if (this._call(opts[key])) return true
  }
  if (this.node) {
    return this._call(opts[this.node.type] && opts[this.node.type][key])
  }
  return false
}
function _call(fns) {
  if (!fns) return false
  for (const fn of fns) {
    if (!fn) continue
    const node2 = this.node
    if (!node2) return true
    const ret = fn.call(this.state, this, this.state)
    if (ret && typeof ret === 'object' && typeof ret.then === 'function') {
      throw new Error(
        `You appear to be using a plugin with an async traversal visitor, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.`
      )
    }
    if (ret) {
      throw new Error(`Unexpected return value from visitor method ${fn}`)
    }
    if (this.node !== node2) return true
    if (this._traverseFlags > 0) return true
  }
  return false
}
function isDenylisted() {
  var _this$opts$denylist
  const denylist = (_this$opts$denylist = this.opts.denylist) != null ? _this$opts$denylist : this.opts.blacklist
  return denylist && denylist.indexOf(this.node.type) > -1
}
function restoreContext(path2, context2) {
  if (path2.context !== context2) {
    path2.context = context2
    path2.state = context2.state
    path2.opts = context2.opts
  }
}
function visit() {
  if (!this.node) {
    return false
  }
  if (this.isDenylisted()) {
    return false
  }
  if (this.opts.shouldSkip && this.opts.shouldSkip(this)) {
    return false
  }
  const currentContext = this.context
  if (this.shouldSkip || this.call('enter')) {
    this.debug('Skip...')
    return this.shouldStop
  }
  restoreContext(this, currentContext)
  this.debug('Recursing into...')
  this.shouldStop = (0, _traverseNode.traverseNode)(this.node, this.opts, this.scope, this.state, this, this.skipKeys)
  restoreContext(this, currentContext)
  this.call('exit')
  return this.shouldStop
}
function skip() {
  this.shouldSkip = true
}
function skipKey(key) {
  if (this.skipKeys == null) {
    this.skipKeys = {}
  }
  this.skipKeys[key] = true
}
function stop() {
  this._traverseFlags |= _index$4.SHOULD_SKIP | _index$4.SHOULD_STOP
}
function setScope() {
  if (this.opts && this.opts.noScope) return
  let path2 = this.parentPath
  if ((this.key === 'key' || this.listKey === 'decorators') && path2.isMethod()) {
    path2 = path2.parentPath
  }
  let target
  while (path2 && !target) {
    if (path2.opts && path2.opts.noScope) return
    target = path2.scope
    path2 = path2.parentPath
  }
  this.scope = this.getScope(target)
  if (this.scope) this.scope.init()
}
function setContext(context2) {
  if (this.skipKeys != null) {
    this.skipKeys = {}
  }
  this._traverseFlags = 0
  if (context2) {
    this.context = context2
    this.state = context2.state
    this.opts = context2.opts
  }
  this.setScope()
  return this
}
function resync() {
  if (this.removed) return
  this._resyncParent()
  this._resyncList()
  this._resyncKey()
}
function _resyncParent() {
  if (this.parentPath) {
    this.parent = this.parentPath.node
  }
}
function _resyncKey() {
  if (!this.container) return
  if (this.node === this.container[this.key]) return
  if (Array.isArray(this.container)) {
    for (let i = 0; i < this.container.length; i++) {
      if (this.container[i] === this.node) {
        return this.setKey(i)
      }
    }
  } else {
    for (const key of Object.keys(this.container)) {
      if (this.container[key] === this.node) {
        return this.setKey(key)
      }
    }
  }
  this.key = null
}
function _resyncList() {
  if (!this.parent || !this.inList) return
  const newContainer = this.parent[this.listKey]
  if (this.container === newContainer) return
  this.container = newContainer || null
}
function _resyncRemoved() {
  if (this.key == null || !this.container || this.container[this.key] !== this.node) {
    this._markRemoved()
  }
}
function popContext() {
  this.contexts.pop()
  if (this.contexts.length > 0) {
    this.setContext(this.contexts[this.contexts.length - 1])
  } else {
    this.setContext(void 0)
  }
}
function pushContext(context2) {
  this.contexts.push(context2)
  this.setContext(context2)
}
function setup(parentPath, container, listKey, key) {
  this.listKey = listKey
  this.container = container
  this.parentPath = parentPath || this.parentPath
  this.setKey(key)
}
function setKey(key) {
  var _this$node
  this.key = key
  this.node = this.container[this.key]
  this.type = (_this$node = this.node) == null ? void 0 : _this$node.type
}
function requeue(pathToQueue = this) {
  if (pathToQueue.removed) return
  const contexts = this.contexts
  for (const context2 of contexts) {
    context2.maybeQueue(pathToQueue)
  }
}
function _getQueueContexts() {
  let path2 = this
  let contexts = this.contexts
  while (!contexts.length) {
    path2 = path2.parentPath
    if (!path2) break
    contexts = path2.contexts
  }
  return contexts
}
var removal = {}
var removalHooks = {}
Object.defineProperty(removalHooks, '__esModule', {
  value: true,
})
removalHooks.hooks = void 0
const hooks = [
  function (self2, parent) {
    const removeParent =
      (self2.key === 'test' && (parent.isWhile() || parent.isSwitchCase())) ||
      (self2.key === 'declaration' && parent.isExportDeclaration()) ||
      (self2.key === 'body' && parent.isLabeledStatement()) ||
      (self2.listKey === 'declarations' && parent.isVariableDeclaration() && parent.node.declarations.length === 1) ||
      (self2.key === 'expression' && parent.isExpressionStatement())
    if (removeParent) {
      parent.remove()
      return true
    }
  },
  function (self2, parent) {
    if (parent.isSequenceExpression() && parent.node.expressions.length === 1) {
      parent.replaceWith(parent.node.expressions[0])
      return true
    }
  },
  function (self2, parent) {
    if (parent.isBinary()) {
      if (self2.key === 'left') {
        parent.replaceWith(parent.node.right)
      } else {
        parent.replaceWith(parent.node.left)
      }
      return true
    }
  },
  function (self2, parent) {
    if (
      (parent.isIfStatement() && (self2.key === 'consequent' || self2.key === 'alternate')) ||
      (self2.key === 'body' && (parent.isLoop() || parent.isArrowFunctionExpression()))
    ) {
      self2.replaceWith({
        type: 'BlockStatement',
        body: [],
      })
      return true
    }
  },
]
removalHooks.hooks = hooks
Object.defineProperty(removal, '__esModule', {
  value: true,
})
removal._assertUnremoved = _assertUnremoved
removal._callRemovalHooks = _callRemovalHooks
removal._markRemoved = _markRemoved
removal._remove = _remove
removal._removeFromScope = _removeFromScope
removal.remove = remove
var _removalHooks = removalHooks
var _cache$2 = cache
var _index$3 = path
function remove() {
  var _this$opts
  this._assertUnremoved()
  this.resync()
  if (!((_this$opts = this.opts) != null && _this$opts.noScope)) {
    this._removeFromScope()
  }
  if (this._callRemovalHooks()) {
    this._markRemoved()
    return
  }
  this.shareCommentsWithSiblings()
  this._remove()
  this._markRemoved()
}
function _removeFromScope() {
  const bindings = this.getBindingIdentifiers()
  Object.keys(bindings).forEach((name) => this.scope.removeBinding(name))
}
function _callRemovalHooks() {
  for (const fn of _removalHooks.hooks) {
    if (fn(this, this.parentPath)) return true
  }
}
function _remove() {
  if (Array.isArray(this.container)) {
    this.container.splice(this.key, 1)
    this.updateSiblingKeys(this.key, -1)
  } else {
    this._replaceWith(null)
  }
}
function _markRemoved() {
  this._traverseFlags |= _index$3.SHOULD_SKIP | _index$3.REMOVED
  if (this.parent) _cache$2.path.get(this.parent).delete(this.node)
  this.node = null
}
function _assertUnremoved() {
  if (this.removed) {
    throw this.buildCodeFrameError('NodePath has been removed so is read-only.')
  }
}
var modification = {}
var hoister = {}
Object.defineProperty(hoister, '__esModule', {
  value: true,
})
hoister.default = void 0
var _t$6 = lib$b
var _t2 = _t$6
const { react } = _t$6
const { cloneNode: cloneNode$1, jsxExpressionContainer, variableDeclaration, variableDeclarator } = _t2
const referenceVisitor = {
  ReferencedIdentifier(path2, state) {
    if (path2.isJSXIdentifier() && react.isCompatTag(path2.node.name) && !path2.parentPath.isJSXMemberExpression()) {
      return
    }
    if (path2.node.name === 'this') {
      let scope2 = path2.scope
      do {
        if (scope2.path.isFunction() && !scope2.path.isArrowFunctionExpression()) {
          break
        }
      } while ((scope2 = scope2.parent))
      if (scope2) state.breakOnScopePaths.push(scope2.path)
    }
    const binding2 = path2.scope.getBinding(path2.node.name)
    if (!binding2) return
    for (const violation of binding2.constantViolations) {
      if (violation.scope !== binding2.path.scope) {
        state.mutableBinding = true
        path2.stop()
        return
      }
    }
    if (binding2 !== state.scope.getBinding(path2.node.name)) return
    state.bindings[path2.node.name] = binding2
  },
}
class PathHoister {
  constructor(path2, scope2) {
    this.breakOnScopePaths = void 0
    this.bindings = void 0
    this.mutableBinding = void 0
    this.scopes = void 0
    this.scope = void 0
    this.path = void 0
    this.attachAfter = void 0
    this.breakOnScopePaths = []
    this.bindings = {}
    this.mutableBinding = false
    this.scopes = []
    this.scope = scope2
    this.path = path2
    this.attachAfter = false
  }
  isCompatibleScope(scope2) {
    for (const key of Object.keys(this.bindings)) {
      const binding2 = this.bindings[key]
      if (!scope2.bindingIdentifierEquals(key, binding2.identifier)) {
        return false
      }
    }
    return true
  }
  getCompatibleScopes() {
    let scope2 = this.path.scope
    do {
      if (this.isCompatibleScope(scope2)) {
        this.scopes.push(scope2)
      } else {
        break
      }
      if (this.breakOnScopePaths.indexOf(scope2.path) >= 0) {
        break
      }
    } while ((scope2 = scope2.parent))
  }
  getAttachmentPath() {
    let path2 = this._getAttachmentPath()
    if (!path2) return
    let targetScope = path2.scope
    if (targetScope.path === path2) {
      targetScope = path2.scope.parent
    }
    if (targetScope.path.isProgram() || targetScope.path.isFunction()) {
      for (const name of Object.keys(this.bindings)) {
        if (!targetScope.hasOwnBinding(name)) continue
        const binding2 = this.bindings[name]
        if (binding2.kind === 'param' || binding2.path.parentKey === 'params') {
          continue
        }
        const bindingParentPath = this.getAttachmentParentForPath(binding2.path)
        if (bindingParentPath.key >= path2.key) {
          this.attachAfter = true
          path2 = binding2.path
          for (const violationPath of binding2.constantViolations) {
            if (this.getAttachmentParentForPath(violationPath).key > path2.key) {
              path2 = violationPath
            }
          }
        }
      }
    }
    return path2
  }
  _getAttachmentPath() {
    const scopes = this.scopes
    const scope2 = scopes.pop()
    if (!scope2) return
    if (scope2.path.isFunction()) {
      if (this.hasOwnParamBindings(scope2)) {
        if (this.scope === scope2) return
        const bodies = scope2.path.get('body').get('body')
        for (let i = 0; i < bodies.length; i++) {
          if (bodies[i].node._blockHoist) continue
          return bodies[i]
        }
      } else {
        return this.getNextScopeAttachmentParent()
      }
    } else if (scope2.path.isProgram()) {
      return this.getNextScopeAttachmentParent()
    }
  }
  getNextScopeAttachmentParent() {
    const scope2 = this.scopes.pop()
    if (scope2) return this.getAttachmentParentForPath(scope2.path)
  }
  getAttachmentParentForPath(path2) {
    do {
      if (!path2.parentPath || (Array.isArray(path2.container) && path2.isStatement())) {
        return path2
      }
    } while ((path2 = path2.parentPath))
  }
  hasOwnParamBindings(scope2) {
    for (const name of Object.keys(this.bindings)) {
      if (!scope2.hasOwnBinding(name)) continue
      const binding2 = this.bindings[name]
      if (binding2.kind === 'param' && binding2.constant) return true
    }
    return false
  }
  run() {
    this.path.traverse(referenceVisitor, this)
    if (this.mutableBinding) return
    this.getCompatibleScopes()
    const attachTo = this.getAttachmentPath()
    if (!attachTo) return
    if (attachTo.getFunctionParent() === this.path.getFunctionParent()) return
    let uid2 = attachTo.scope.generateUidIdentifier('ref')
    const declarator = variableDeclarator(uid2, this.path.node)
    const insertFn = this.attachAfter ? 'insertAfter' : 'insertBefore'
    const [attached] = attachTo[insertFn]([
      attachTo.isVariableDeclarator() ? declarator : variableDeclaration('var', [declarator]),
    ])
    const parent = this.path.parentPath
    if (parent.isJSXElement() && this.path.container === parent.node.children) {
      uid2 = jsxExpressionContainer(uid2)
    }
    this.path.replaceWith(cloneNode$1(uid2))
    return attachTo.isVariableDeclarator() ? attached.get('init') : attached.get('declarations.0.init')
  }
}
hoister.default = PathHoister
Object.defineProperty(modification, '__esModule', {
  value: true,
})
modification._containerInsert = _containerInsert
modification._containerInsertAfter = _containerInsertAfter
modification._containerInsertBefore = _containerInsertBefore
modification._verifyNodeList = _verifyNodeList
modification.hoist = hoist
modification.insertAfter = insertAfter
modification.insertBefore = insertBefore
modification.pushContainer = pushContainer
modification.unshiftContainer = unshiftContainer
modification.updateSiblingKeys = updateSiblingKeys
var _cache$1 = cache
var _hoister = hoister
var _index$2 = path
var _t$5 = lib$b
const {
  arrowFunctionExpression,
  assertExpression,
  assignmentExpression,
  blockStatement,
  callExpression,
  cloneNode,
  expressionStatement,
  isAssignmentExpression,
  isCallExpression,
  isExpression,
  isIdentifier,
  isSequenceExpression,
  isSuper,
  thisExpression,
} = _t$5
function insertBefore(nodes_) {
  this._assertUnremoved()
  const nodes2 = this._verifyNodeList(nodes_)
  const { parentPath } = this
  if (
    parentPath.isExpressionStatement() ||
    parentPath.isLabeledStatement() ||
    parentPath.isExportNamedDeclaration() ||
    (parentPath.isExportDefaultDeclaration() && this.isDeclaration())
  ) {
    return parentPath.insertBefore(nodes2)
  } else if (
    (this.isNodeType('Expression') && !this.isJSXElement()) ||
    (parentPath.isForStatement() && this.key === 'init')
  ) {
    if (this.node) nodes2.push(this.node)
    return this.replaceExpressionWithStatements(nodes2)
  } else if (Array.isArray(this.container)) {
    return this._containerInsertBefore(nodes2)
  } else if (this.isStatementOrBlock()) {
    const node2 = this.node
    const shouldInsertCurrentNode = node2 && (!this.isExpressionStatement() || node2.expression != null)
    this.replaceWith(blockStatement(shouldInsertCurrentNode ? [node2] : []))
    return this.unshiftContainer('body', nodes2)
  } else {
    throw new Error(
      "We don't know what to do with this node type. We were previously a Statement but we can't fit in here?"
    )
  }
}
function _containerInsert(from, nodes2) {
  this.updateSiblingKeys(from, nodes2.length)
  const paths = []
  this.container.splice(from, 0, ...nodes2)
  for (let i = 0; i < nodes2.length; i++) {
    const to = from + i
    const path2 = this.getSibling(to)
    paths.push(path2)
    if (this.context && this.context.queue) {
      path2.pushContext(this.context)
    }
  }
  const contexts = this._getQueueContexts()
  for (const path2 of paths) {
    path2.setScope()
    path2.debug('Inserted.')
    for (const context2 of contexts) {
      context2.maybeQueue(path2, true)
    }
  }
  return paths
}
function _containerInsertBefore(nodes2) {
  return this._containerInsert(this.key, nodes2)
}
function _containerInsertAfter(nodes2) {
  return this._containerInsert(this.key + 1, nodes2)
}
const last = (arr) => arr[arr.length - 1]
function isHiddenInSequenceExpression(path2) {
  return (
    isSequenceExpression(path2.parent) &&
    (last(path2.parent.expressions) !== path2.node || isHiddenInSequenceExpression(path2.parentPath))
  )
}
function isAlmostConstantAssignment(node2, scope2) {
  if (!isAssignmentExpression(node2) || !isIdentifier(node2.left)) {
    return false
  }
  const blockScope = scope2.getBlockParent()
  return (
    blockScope.hasOwnBinding(node2.left.name) &&
    blockScope.getOwnBinding(node2.left.name).constantViolations.length <= 1
  )
}
function insertAfter(nodes_) {
  this._assertUnremoved()
  if (this.isSequenceExpression()) {
    return last(this.get('expressions')).insertAfter(nodes_)
  }
  const nodes2 = this._verifyNodeList(nodes_)
  const { parentPath } = this
  if (
    parentPath.isExpressionStatement() ||
    parentPath.isLabeledStatement() ||
    parentPath.isExportNamedDeclaration() ||
    (parentPath.isExportDefaultDeclaration() && this.isDeclaration())
  ) {
    return parentPath.insertAfter(
      nodes2.map((node2) => {
        return isExpression(node2) ? expressionStatement(node2) : node2
      })
    )
  } else if (
    (this.isNodeType('Expression') && !this.isJSXElement() && !parentPath.isJSXElement()) ||
    (parentPath.isForStatement() && this.key === 'init')
  ) {
    if (this.node) {
      const node2 = this.node
      let { scope: scope2 } = this
      if (scope2.path.isPattern()) {
        assertExpression(node2)
        this.replaceWith(callExpression(arrowFunctionExpression([], node2), []))
        this.get('callee.body').insertAfter(nodes2)
        return [this]
      }
      if (isHiddenInSequenceExpression(this)) {
        nodes2.unshift(node2)
      } else if (isCallExpression(node2) && isSuper(node2.callee)) {
        nodes2.unshift(node2)
        nodes2.push(thisExpression())
      } else if (isAlmostConstantAssignment(node2, scope2)) {
        nodes2.unshift(node2)
        nodes2.push(cloneNode(node2.left))
      } else if (scope2.isPure(node2, true)) {
        nodes2.push(node2)
      } else {
        if (
          parentPath.isMethod({
            computed: true,
            key: node2,
          })
        ) {
          scope2 = scope2.parent
        }
        const temp = scope2.generateDeclaredUidIdentifier()
        nodes2.unshift(expressionStatement(assignmentExpression('=', cloneNode(temp), node2)))
        nodes2.push(expressionStatement(cloneNode(temp)))
      }
    }
    return this.replaceExpressionWithStatements(nodes2)
  } else if (Array.isArray(this.container)) {
    return this._containerInsertAfter(nodes2)
  } else if (this.isStatementOrBlock()) {
    const node2 = this.node
    const shouldInsertCurrentNode = node2 && (!this.isExpressionStatement() || node2.expression != null)
    this.replaceWith(blockStatement(shouldInsertCurrentNode ? [node2] : []))
    return this.pushContainer('body', nodes2)
  } else {
    throw new Error(
      "We don't know what to do with this node type. We were previously a Statement but we can't fit in here?"
    )
  }
}
function updateSiblingKeys(fromIndex, incrementBy) {
  if (!this.parent) return
  const paths = _cache$1.path.get(this.parent)
  for (const [, path2] of paths) {
    if (path2.key >= fromIndex) {
      path2.key += incrementBy
    }
  }
}
function _verifyNodeList(nodes2) {
  if (!nodes2) {
    return []
  }
  if (!Array.isArray(nodes2)) {
    nodes2 = [nodes2]
  }
  for (let i = 0; i < nodes2.length; i++) {
    const node2 = nodes2[i]
    let msg
    if (!node2) {
      msg = 'has falsy node'
    } else if (typeof node2 !== 'object') {
      msg = 'contains a non-object node'
    } else if (!node2.type) {
      msg = 'without a type'
    } else if (node2 instanceof _index$2.default) {
      msg = 'has a NodePath when it expected a raw object'
    }
    if (msg) {
      const type = Array.isArray(node2) ? 'array' : typeof node2
      throw new Error(`Node list ${msg} with the index of ${i} and type of ${type}`)
    }
  }
  return nodes2
}
function unshiftContainer(listKey, nodes2) {
  this._assertUnremoved()
  nodes2 = this._verifyNodeList(nodes2)
  const path2 = _index$2.default
    .get({
      parentPath: this,
      parent: this.node,
      container: this.node[listKey],
      listKey,
      key: 0,
    })
    .setContext(this.context)
  return path2._containerInsertBefore(nodes2)
}
function pushContainer(listKey, nodes2) {
  this._assertUnremoved()
  const verifiedNodes = this._verifyNodeList(nodes2)
  const container = this.node[listKey]
  const path2 = _index$2.default
    .get({
      parentPath: this,
      parent: this.node,
      container,
      listKey,
      key: container.length,
    })
    .setContext(this.context)
  return path2.replaceWithMultiple(verifiedNodes)
}
function hoist(scope2 = this.scope) {
  const hoister2 = new _hoister.default(this, scope2)
  return hoister2.run()
}
var family = {}
Object.defineProperty(family, '__esModule', {
  value: true,
})
family._getKey = _getKey
family._getPattern = _getPattern
family.get = get
family.getAllNextSiblings = getAllNextSiblings
family.getAllPrevSiblings = getAllPrevSiblings
family.getBindingIdentifierPaths = getBindingIdentifierPaths
family.getBindingIdentifiers = getBindingIdentifiers
family.getCompletionRecords = getCompletionRecords
family.getNextSibling = getNextSibling
family.getOpposite = getOpposite
family.getOuterBindingIdentifierPaths = getOuterBindingIdentifierPaths
family.getOuterBindingIdentifiers = getOuterBindingIdentifiers
family.getPrevSibling = getPrevSibling
family.getSibling = getSibling
var _index$1 = path
var _t$4 = lib$b
const {
  getBindingIdentifiers: _getBindingIdentifiers,
  getOuterBindingIdentifiers: _getOuterBindingIdentifiers,
  isDeclaration,
  numericLiteral,
  unaryExpression,
} = _t$4
const NORMAL_COMPLETION = 0
const BREAK_COMPLETION = 1
function NormalCompletion(path2) {
  return {
    type: NORMAL_COMPLETION,
    path: path2,
  }
}
function BreakCompletion(path2) {
  return {
    type: BREAK_COMPLETION,
    path: path2,
  }
}
function getOpposite() {
  if (this.key === 'left') {
    return this.getSibling('right')
  } else if (this.key === 'right') {
    return this.getSibling('left')
  }
  return null
}
function addCompletionRecords(path2, records, context2) {
  if (path2) {
    records.push(..._getCompletionRecords(path2, context2))
  }
  return records
}
function completionRecordForSwitch(cases, records, context2) {
  let lastNormalCompletions = []
  for (let i = 0; i < cases.length; i++) {
    const casePath = cases[i]
    const caseCompletions = _getCompletionRecords(casePath, context2)
    const normalCompletions = []
    const breakCompletions = []
    for (const c of caseCompletions) {
      if (c.type === NORMAL_COMPLETION) {
        normalCompletions.push(c)
      }
      if (c.type === BREAK_COMPLETION) {
        breakCompletions.push(c)
      }
    }
    if (normalCompletions.length) {
      lastNormalCompletions = normalCompletions
    }
    records.push(...breakCompletions)
  }
  records.push(...lastNormalCompletions)
  return records
}
function normalCompletionToBreak(completions) {
  completions.forEach((c) => {
    c.type = BREAK_COMPLETION
  })
}
function replaceBreakStatementInBreakCompletion(completions, reachable) {
  completions.forEach((c) => {
    if (
      c.path.isBreakStatement({
        label: null,
      })
    ) {
      if (reachable) {
        c.path.replaceWith(unaryExpression('void', numericLiteral(0)))
      } else {
        c.path.remove()
      }
    }
  })
}
function getStatementListCompletion(paths, context2) {
  const completions = []
  if (context2.canHaveBreak) {
    let lastNormalCompletions = []
    for (let i = 0; i < paths.length; i++) {
      const path2 = paths[i]
      const newContext = Object.assign({}, context2, {
        inCaseClause: false,
      })
      if (path2.isBlockStatement() && (context2.inCaseClause || context2.shouldPopulateBreak)) {
        newContext.shouldPopulateBreak = true
      } else {
        newContext.shouldPopulateBreak = false
      }
      const statementCompletions = _getCompletionRecords(path2, newContext)
      if (statementCompletions.length > 0 && statementCompletions.every((c) => c.type === BREAK_COMPLETION)) {
        if (
          lastNormalCompletions.length > 0 &&
          statementCompletions.every((c) =>
            c.path.isBreakStatement({
              label: null,
            })
          )
        ) {
          normalCompletionToBreak(lastNormalCompletions)
          completions.push(...lastNormalCompletions)
          if (lastNormalCompletions.some((c) => c.path.isDeclaration())) {
            completions.push(...statementCompletions)
            replaceBreakStatementInBreakCompletion(statementCompletions, true)
          }
          replaceBreakStatementInBreakCompletion(statementCompletions, false)
        } else {
          completions.push(...statementCompletions)
          if (!context2.shouldPopulateBreak) {
            replaceBreakStatementInBreakCompletion(statementCompletions, true)
          }
        }
        break
      }
      if (i === paths.length - 1) {
        completions.push(...statementCompletions)
      } else {
        lastNormalCompletions = []
        for (let i2 = 0; i2 < statementCompletions.length; i2++) {
          const c = statementCompletions[i2]
          if (c.type === BREAK_COMPLETION) {
            completions.push(c)
          }
          if (c.type === NORMAL_COMPLETION) {
            lastNormalCompletions.push(c)
          }
        }
      }
    }
  } else if (paths.length) {
    for (let i = paths.length - 1; i >= 0; i--) {
      const pathCompletions = _getCompletionRecords(paths[i], context2)
      if (
        pathCompletions.length > 1 ||
        (pathCompletions.length === 1 && !pathCompletions[0].path.isVariableDeclaration())
      ) {
        completions.push(...pathCompletions)
        break
      }
    }
  }
  return completions
}
function _getCompletionRecords(path2, context2) {
  let records = []
  if (path2.isIfStatement()) {
    records = addCompletionRecords(path2.get('consequent'), records, context2)
    records = addCompletionRecords(path2.get('alternate'), records, context2)
  } else if (path2.isDoExpression() || path2.isFor() || path2.isWhile() || path2.isLabeledStatement()) {
    return addCompletionRecords(path2.get('body'), records, context2)
  } else if (path2.isProgram() || path2.isBlockStatement()) {
    return getStatementListCompletion(path2.get('body'), context2)
  } else if (path2.isFunction()) {
    return _getCompletionRecords(path2.get('body'), context2)
  } else if (path2.isTryStatement()) {
    records = addCompletionRecords(path2.get('block'), records, context2)
    records = addCompletionRecords(path2.get('handler'), records, context2)
  } else if (path2.isCatchClause()) {
    return addCompletionRecords(path2.get('body'), records, context2)
  } else if (path2.isSwitchStatement()) {
    return completionRecordForSwitch(path2.get('cases'), records, context2)
  } else if (path2.isSwitchCase()) {
    return getStatementListCompletion(path2.get('consequent'), {
      canHaveBreak: true,
      shouldPopulateBreak: false,
      inCaseClause: true,
    })
  } else if (path2.isBreakStatement()) {
    records.push(BreakCompletion(path2))
  } else {
    records.push(NormalCompletion(path2))
  }
  return records
}
function getCompletionRecords() {
  const records = _getCompletionRecords(this, {
    canHaveBreak: false,
    shouldPopulateBreak: false,
    inCaseClause: false,
  })
  return records.map((r) => r.path)
}
function getSibling(key) {
  return _index$1.default
    .get({
      parentPath: this.parentPath,
      parent: this.parent,
      container: this.container,
      listKey: this.listKey,
      key,
    })
    .setContext(this.context)
}
function getPrevSibling() {
  return this.getSibling(this.key - 1)
}
function getNextSibling() {
  return this.getSibling(this.key + 1)
}
function getAllNextSiblings() {
  let _key = this.key
  let sibling = this.getSibling(++_key)
  const siblings = []
  while (sibling.node) {
    siblings.push(sibling)
    sibling = this.getSibling(++_key)
  }
  return siblings
}
function getAllPrevSiblings() {
  let _key = this.key
  let sibling = this.getSibling(--_key)
  const siblings = []
  while (sibling.node) {
    siblings.push(sibling)
    sibling = this.getSibling(--_key)
  }
  return siblings
}
function get(key, context2 = true) {
  if (context2 === true) context2 = this.context
  const parts = key.split('.')
  if (parts.length === 1) {
    return this._getKey(key, context2)
  } else {
    return this._getPattern(parts, context2)
  }
}
function _getKey(key, context2) {
  const node2 = this.node
  const container = node2[key]
  if (Array.isArray(container)) {
    return container.map((_2, i) => {
      return _index$1.default
        .get({
          listKey: key,
          parentPath: this,
          parent: node2,
          container,
          key: i,
        })
        .setContext(context2)
    })
  } else {
    return _index$1.default
      .get({
        parentPath: this,
        parent: node2,
        container: node2,
        key,
      })
      .setContext(context2)
  }
}
function _getPattern(parts, context2) {
  let path2 = this
  for (const part of parts) {
    if (part === '.') {
      path2 = path2.parentPath
    } else {
      if (Array.isArray(path2)) {
        path2 = path2[part]
      } else {
        path2 = path2.get(part, context2)
      }
    }
  }
  return path2
}
function getBindingIdentifiers(duplicates) {
  return _getBindingIdentifiers(this.node, duplicates)
}
function getOuterBindingIdentifiers(duplicates) {
  return _getOuterBindingIdentifiers(this.node, duplicates)
}
function getBindingIdentifierPaths(duplicates = false, outerOnly = false) {
  const path2 = this
  const search = [path2]
  const ids = /* @__PURE__ */ Object.create(null)
  while (search.length) {
    const id = search.shift()
    if (!id) continue
    if (!id.node) continue
    const keys = _getBindingIdentifiers.keys[id.node.type]
    if (id.isIdentifier()) {
      if (duplicates) {
        const _ids = (ids[id.node.name] = ids[id.node.name] || [])
        _ids.push(id)
      } else {
        ids[id.node.name] = id
      }
      continue
    }
    if (id.isExportDeclaration()) {
      const declaration = id.get('declaration')
      if (isDeclaration(declaration)) {
        search.push(declaration)
      }
      continue
    }
    if (outerOnly) {
      if (id.isFunctionDeclaration()) {
        search.push(id.get('id'))
        continue
      }
      if (id.isFunctionExpression()) {
        continue
      }
    }
    if (keys) {
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i]
        const child = id.get(key)
        if (Array.isArray(child)) {
          search.push(...child)
        } else if (child.node) {
          search.push(child)
        }
      }
    }
  }
  return ids
}
function getOuterBindingIdentifierPaths(duplicates) {
  return this.getBindingIdentifierPaths(duplicates, true)
}
var comments = {}
Object.defineProperty(comments, '__esModule', {
  value: true,
})
comments.addComment = addComment
comments.addComments = addComments
comments.shareCommentsWithSiblings = shareCommentsWithSiblings
var _t$3 = lib$b
const { addComment: _addComment, addComments: _addComments } = _t$3
function shareCommentsWithSiblings() {
  if (typeof this.key === 'string') return
  const node2 = this.node
  if (!node2) return
  const trailing = node2.trailingComments
  const leading = node2.leadingComments
  if (!trailing && !leading) return
  const prev = this.getSibling(this.key - 1)
  const next = this.getSibling(this.key + 1)
  const hasPrev = Boolean(prev.node)
  const hasNext = Boolean(next.node)
  if (hasPrev && !hasNext) {
    prev.addComments('trailing', trailing)
  } else if (hasNext && !hasPrev) {
    next.addComments('leading', leading)
  }
}
function addComment(type, content, line) {
  _addComment(this.node, type, content, line)
}
function addComments(type, comments2) {
  _addComments(this.node, type, comments2)
}
Object.defineProperty(path, '__esModule', {
  value: true,
})
path.default = path.SHOULD_STOP = path.SHOULD_SKIP = path.REMOVED = void 0
var virtualTypes = virtualTypes$2
var _debug = browser$2.exports
var _index = lib$c
var _scope = scope
var _t$2 = lib$b
var t = _t$2
var _cache = cache
var _generator = lib$7
var NodePath_ancestry = ancestry
var NodePath_inference = inference
var NodePath_replacement = replacement
var NodePath_evaluation = evaluation
var NodePath_conversion = conversion
var NodePath_introspection = introspection
var NodePath_context = context$1
var NodePath_removal = removal
var NodePath_modification = modification
var NodePath_family = family
var NodePath_comments = comments
const { validate } = _t$2
const debug = _debug('babel')
const REMOVED = 1 << 0
path.REMOVED = REMOVED
const SHOULD_STOP = 1 << 1
path.SHOULD_STOP = SHOULD_STOP
const SHOULD_SKIP = 1 << 2
path.SHOULD_SKIP = SHOULD_SKIP
class NodePath {
  constructor(hub2, parent) {
    this.contexts = []
    this.state = null
    this.opts = null
    this._traverseFlags = 0
    this.skipKeys = null
    this.parentPath = null
    this.container = null
    this.listKey = null
    this.key = null
    this.node = null
    this.type = null
    this.parent = parent
    this.hub = hub2
    this.data = null
    this.context = null
    this.scope = null
  }
  static get({ hub: hub2, parentPath, parent, container, listKey, key }) {
    if (!hub2 && parentPath) {
      hub2 = parentPath.hub
    }
    if (!parent) {
      throw new Error('To get a node path the parent needs to exist')
    }
    const targetNode = container[key]
    let paths = _cache.path.get(parent)
    if (!paths) {
      paths = /* @__PURE__ */ new Map()
      _cache.path.set(parent, paths)
    }
    let path2 = paths.get(targetNode)
    if (!path2) {
      path2 = new NodePath(hub2, parent)
      if (targetNode) paths.set(targetNode, path2)
    }
    path2.setup(parentPath, container, listKey, key)
    return path2
  }
  getScope(scope2) {
    return this.isScope() ? new _scope.default(this) : scope2
  }
  setData(key, val) {
    if (this.data == null) {
      this.data = /* @__PURE__ */ Object.create(null)
    }
    return (this.data[key] = val)
  }
  getData(key, def) {
    if (this.data == null) {
      this.data = /* @__PURE__ */ Object.create(null)
    }
    let val = this.data[key]
    if (val === void 0 && def !== void 0) val = this.data[key] = def
    return val
  }
  hasNode() {
    return this.node != null
  }
  buildCodeFrameError(msg, Error2 = SyntaxError) {
    return this.hub.buildError(this.node, msg, Error2)
  }
  traverse(visitor2, state) {
    ;(0, _index.default)(this.node, visitor2, this.scope, state, this)
  }
  set(key, node2) {
    validate(this.node, key, node2)
    this.node[key] = node2
  }
  getPathLocation() {
    const parts = []
    let path2 = this
    do {
      let key = path2.key
      if (path2.inList) key = `${path2.listKey}[${key}]`
      parts.unshift(key)
    } while ((path2 = path2.parentPath))
    return parts.join('.')
  }
  debug(message) {
    if (!debug.enabled) return
    debug(`${this.getPathLocation()} ${this.type}: ${message}`)
  }
  toString() {
    return (0, _generator.default)(this.node).code
  }
  get inList() {
    return !!this.listKey
  }
  set inList(inList) {
    if (!inList) {
      this.listKey = null
    }
  }
  get parentKey() {
    return this.listKey || this.key
  }
  get shouldSkip() {
    return !!(this._traverseFlags & SHOULD_SKIP)
  }
  set shouldSkip(v) {
    if (v) {
      this._traverseFlags |= SHOULD_SKIP
    } else {
      this._traverseFlags &= ~SHOULD_SKIP
    }
  }
  get shouldStop() {
    return !!(this._traverseFlags & SHOULD_STOP)
  }
  set shouldStop(v) {
    if (v) {
      this._traverseFlags |= SHOULD_STOP
    } else {
      this._traverseFlags &= ~SHOULD_STOP
    }
  }
  get removed() {
    return !!(this._traverseFlags & REMOVED)
  }
  set removed(v) {
    if (v) {
      this._traverseFlags |= REMOVED
    } else {
      this._traverseFlags &= ~REMOVED
    }
  }
}
Object.assign(
  NodePath.prototype,
  NodePath_ancestry,
  NodePath_inference,
  NodePath_replacement,
  NodePath_evaluation,
  NodePath_conversion,
  NodePath_introspection,
  NodePath_context,
  NodePath_removal,
  NodePath_modification,
  NodePath_family,
  NodePath_comments
)
{
  NodePath.prototype._guessExecutionStatusRelativeToDifferentFunctions =
    NodePath_introspection._guessExecutionStatusRelativeTo
}
for (const type of t.TYPES) {
  const typeKey = `is${type}`
  const fn = t[typeKey]
  NodePath.prototype[typeKey] = function (opts) {
    return fn(this.node, opts)
  }
  NodePath.prototype[`assert${type}`] = function (opts) {
    if (!fn(this.node, opts)) {
      throw new TypeError(`Expected node path of type ${type}`)
    }
  }
}
for (const type of Object.keys(virtualTypes)) {
  if (type[0] === '_') continue
  if (t.TYPES.indexOf(type) < 0) t.TYPES.push(type)
  const virtualType = virtualTypes[type]
  NodePath.prototype[`is${type}`] = function (opts) {
    return virtualType.checkPath(this, opts)
  }
}
var _default = NodePath
path.default = _default
Object.defineProperty(context$2, '__esModule', {
  value: true,
})
context$2.default = void 0
var _path = path
var _t$1 = lib$b
const { VISITOR_KEYS: VISITOR_KEYS$1 } = _t$1
class TraversalContext {
  constructor(scope2, opts, state, parentPath) {
    this.queue = null
    this.priorityQueue = null
    this.parentPath = parentPath
    this.scope = scope2
    this.state = state
    this.opts = opts
  }
  shouldVisit(node2) {
    const opts = this.opts
    if (opts.enter || opts.exit) return true
    if (opts[node2.type]) return true
    const keys = VISITOR_KEYS$1[node2.type]
    if (!(keys != null && keys.length)) return false
    for (const key of keys) {
      if (node2[key]) return true
    }
    return false
  }
  create(node2, obj, key, listKey) {
    return _path.default.get({
      parentPath: this.parentPath,
      parent: node2,
      container: obj,
      key,
      listKey,
    })
  }
  maybeQueue(path2, notPriority) {
    if (this.queue) {
      if (notPriority) {
        this.queue.push(path2)
      } else {
        this.priorityQueue.push(path2)
      }
    }
  }
  visitMultiple(container, parent, listKey) {
    if (container.length === 0) return false
    const queue = []
    for (let key = 0; key < container.length; key++) {
      const node2 = container[key]
      if (node2 && this.shouldVisit(node2)) {
        queue.push(this.create(parent, container, key, listKey))
      }
    }
    return this.visitQueue(queue)
  }
  visitSingle(node2, key) {
    if (this.shouldVisit(node2[key])) {
      return this.visitQueue([this.create(node2, node2, key)])
    } else {
      return false
    }
  }
  visitQueue(queue) {
    this.queue = queue
    this.priorityQueue = []
    const visited = /* @__PURE__ */ new WeakSet()
    let stop2 = false
    for (const path2 of queue) {
      path2.resync()
      if (path2.contexts.length === 0 || path2.contexts[path2.contexts.length - 1] !== this) {
        path2.pushContext(this)
      }
      if (path2.key === null) continue
      const { node: node2 } = path2
      if (visited.has(node2)) continue
      if (node2) visited.add(node2)
      if (path2.visit()) {
        stop2 = true
        break
      }
      if (this.priorityQueue.length) {
        stop2 = this.visitQueue(this.priorityQueue)
        this.priorityQueue = []
        this.queue = queue
        if (stop2) break
      }
    }
    for (const path2 of queue) {
      path2.popContext()
    }
    this.queue = null
    return stop2
  }
  visit(node2, key) {
    const nodes2 = node2[key]
    if (!nodes2) return false
    if (Array.isArray(nodes2)) {
      return this.visitMultiple(nodes2, node2, key)
    } else {
      return this.visitSingle(node2, key)
    }
  }
}
context$2.default = TraversalContext
Object.defineProperty(traverseNode$1, '__esModule', {
  value: true,
})
traverseNode$1.traverseNode = traverseNode
var _context = context$2
var _t = lib$b
const { VISITOR_KEYS } = _t
function traverseNode(node2, opts, scope2, state, path2, skipKeys) {
  const keys = VISITOR_KEYS[node2.type]
  if (!keys) return false
  const context2 = new _context.default(scope2, opts, state, path2)
  for (const key of keys) {
    if (skipKeys && skipKeys[key]) continue
    if (context2.visit(node2, key)) {
      return true
    }
  }
  return false
}
var hub = {}
Object.defineProperty(hub, '__esModule', {
  value: true,
})
hub.default = void 0
class Hub {
  getCode() {}
  getScope() {}
  addHelper() {
    throw new Error('Helpers are not supported by the default hub.')
  }
  buildError(node2, msg, Error2 = TypeError) {
    return new Error2(msg)
  }
}
hub.default = Hub
;(function (exports) {
  Object.defineProperty(exports, '__esModule', {
    value: true,
  })
  Object.defineProperty(exports, 'Hub', {
    enumerable: true,
    get: function () {
      return _hub.default
    },
  })
  Object.defineProperty(exports, 'NodePath', {
    enumerable: true,
    get: function () {
      return _path2.default
    },
  })
  Object.defineProperty(exports, 'Scope', {
    enumerable: true,
    get: function () {
      return _scope2.default
    },
  })
  exports.visitors = exports.default = void 0
  var visitors$1 = visitors
  exports.visitors = visitors$1
  var _t3 = lib$b
  var cache$1 = cache
  var _traverseNode2 = traverseNode$1
  var _path2 = path
  var _scope2 = scope
  var _hub = hub
  const { VISITOR_KEYS: VISITOR_KEYS2, removeProperties: removeProperties2, traverseFast: traverseFast2 } = _t3
  function traverse2(parent, opts = {}, scope2, state, parentPath) {
    if (!parent) return
    if (!opts.noScope && !scope2) {
      if (parent.type !== 'Program' && parent.type !== 'File') {
        throw new Error(
          `You must pass a scope and parentPath unless traversing a Program/File. Instead of that you tried to traverse a ${parent.type} node without passing scope and parentPath.`
        )
      }
    }
    if (!VISITOR_KEYS2[parent.type]) {
      return
    }
    visitors$1.explode(opts)
    ;(0, _traverseNode2.traverseNode)(parent, opts, scope2, state, parentPath)
  }
  var _default2 = traverse2
  exports.default = _default2
  traverse2.visitors = visitors$1
  traverse2.verify = visitors$1.verify
  traverse2.explode = visitors$1.explode
  traverse2.cheap = function (node2, enter) {
    return traverseFast2(node2, enter)
  }
  traverse2.node = function (node2, opts, scope2, state, path2, skipKeys) {
    ;(0, _traverseNode2.traverseNode)(node2, opts, scope2, state, path2, skipKeys)
  }
  traverse2.clearNode = function (node2, opts) {
    removeProperties2(node2, opts)
    cache$1.path.delete(node2)
  }
  traverse2.removeProperties = function (tree, opts) {
    traverseFast2(tree, traverse2.clearNode, opts)
    return tree
  }
  function hasDenylistedType(path2, state) {
    if (path2.node.type === state.type) {
      state.has = true
      path2.stop()
    }
  }
  traverse2.hasType = function (tree, type, denylistTypes) {
    if (denylistTypes != null && denylistTypes.includes(tree.type)) return false
    if (tree.type === type) return true
    const state = {
      has: false,
      type,
    }
    traverse2(
      tree,
      {
        noScope: true,
        denylist: denylistTypes,
        enter: hasDenylistedType,
      },
      null,
      state
    )
    return state.has
  }
  traverse2.cache = cache$1
})(lib$c)
var traverse = /* @__PURE__ */ getDefaultExportFromCjs(lib$c)
var jszip_min = { exports: {} }
/*!

JSZip v3.10.0 - A JavaScript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/main/LICENSE
*/
;(function (module, exports) {
  !(function (e) {
    module.exports = e()
  })(function () {
    return (function s2(a, o, h2) {
      function u(r, e2) {
        if (!o[r]) {
          if (!a[r]) {
            var t2 = typeof commonjsRequire == 'function' && commonjsRequire
            if (!e2 && t2) return t2(r, true)
            if (l) return l(r, true)
            var n2 = new Error("Cannot find module '" + r + "'")
            throw ((n2.code = 'MODULE_NOT_FOUND'), n2)
          }
          var i = (o[r] = { exports: {} })
          a[r][0].call(
            i.exports,
            function (e3) {
              var t3 = a[r][1][e3]
              return u(t3 || e3)
            },
            i,
            i.exports,
            s2,
            a,
            o,
            h2
          )
        }
        return o[r].exports
      }
      for (var l = typeof commonjsRequire == 'function' && commonjsRequire, e = 0; e < h2.length; e++) u(h2[e])
      return u
    })(
      {
        1: [
          function (e, t2, r) {
            var d2 = e('./utils'),
              c = e('./support'),
              p = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='
            ;(r.encode = function (e2) {
              for (
                var t3, r2, n2, i, s2, a, o, h2 = [], u = 0, l = e2.length, f = l, c2 = d2.getTypeOf(e2) !== 'string';
                u < e2.length;

              )
                (f = l - u),
                  (n2 = c2
                    ? ((t3 = e2[u++]), (r2 = u < l ? e2[u++] : 0), u < l ? e2[u++] : 0)
                    : ((t3 = e2.charCodeAt(u++)),
                      (r2 = u < l ? e2.charCodeAt(u++) : 0),
                      u < l ? e2.charCodeAt(u++) : 0)),
                  (i = t3 >> 2),
                  (s2 = ((3 & t3) << 4) | (r2 >> 4)),
                  (a = 1 < f ? ((15 & r2) << 2) | (n2 >> 6) : 64),
                  (o = 2 < f ? 63 & n2 : 64),
                  h2.push(p.charAt(i) + p.charAt(s2) + p.charAt(a) + p.charAt(o))
              return h2.join('')
            }),
              (r.decode = function (e2) {
                var t3,
                  r2,
                  n2,
                  i,
                  s2,
                  a,
                  o = 0,
                  h2 = 0,
                  u = 'data:'
                if (e2.substr(0, u.length) === u) throw new Error('Invalid base64 input, it looks like a data url.')
                var l,
                  f = (3 * (e2 = e2.replace(/[^A-Za-z0-9\+\/\=]/g, '')).length) / 4
                if (
                  (e2.charAt(e2.length - 1) === p.charAt(64) && f--,
                  e2.charAt(e2.length - 2) === p.charAt(64) && f--,
                  f % 1 != 0)
                )
                  throw new Error('Invalid base64 input, bad content length.')
                for (l = c.uint8array ? new Uint8Array(0 | f) : new Array(0 | f); o < e2.length; )
                  (t3 = (p.indexOf(e2.charAt(o++)) << 2) | ((i = p.indexOf(e2.charAt(o++))) >> 4)),
                    (r2 = ((15 & i) << 4) | ((s2 = p.indexOf(e2.charAt(o++))) >> 2)),
                    (n2 = ((3 & s2) << 6) | (a = p.indexOf(e2.charAt(o++)))),
                    (l[h2++] = t3),
                    s2 !== 64 && (l[h2++] = r2),
                    a !== 64 && (l[h2++] = n2)
                return l
              })
          },
          { './support': 30, './utils': 32 },
        ],
        2: [
          function (e, t2, r) {
            var n2 = e('./external'),
              i = e('./stream/DataWorker'),
              s2 = e('./stream/Crc32Probe'),
              a = e('./stream/DataLengthProbe')
            function o(e2, t3, r2, n3, i2) {
              ;(this.compressedSize = e2),
                (this.uncompressedSize = t3),
                (this.crc32 = r2),
                (this.compression = n3),
                (this.compressedContent = i2)
            }
            ;(o.prototype = {
              getContentWorker: function () {
                var e2 = new i(n2.Promise.resolve(this.compressedContent))
                    .pipe(this.compression.uncompressWorker())
                    .pipe(new a('data_length')),
                  t3 = this
                return (
                  e2.on('end', function () {
                    if (this.streamInfo.data_length !== t3.uncompressedSize)
                      throw new Error('Bug : uncompressed data size mismatch')
                  }),
                  e2
                )
              },
              getCompressedWorker: function () {
                return new i(n2.Promise.resolve(this.compressedContent))
                  .withStreamInfo('compressedSize', this.compressedSize)
                  .withStreamInfo('uncompressedSize', this.uncompressedSize)
                  .withStreamInfo('crc32', this.crc32)
                  .withStreamInfo('compression', this.compression)
              },
            }),
              (o.createWorkerFrom = function (e2, t3, r2) {
                return e2
                  .pipe(new s2())
                  .pipe(new a('uncompressedSize'))
                  .pipe(t3.compressWorker(r2))
                  .pipe(new a('compressedSize'))
                  .withStreamInfo('compression', t3)
              }),
              (t2.exports = o)
          },
          { './external': 6, './stream/Crc32Probe': 25, './stream/DataLengthProbe': 26, './stream/DataWorker': 27 },
        ],
        3: [
          function (e, t2, r) {
            var n2 = e('./stream/GenericWorker')
            ;(r.STORE = {
              magic: '\0\0',
              compressWorker: function (e2) {
                return new n2('STORE compression')
              },
              uncompressWorker: function () {
                return new n2('STORE decompression')
              },
            }),
              (r.DEFLATE = e('./flate'))
          },
          { './flate': 7, './stream/GenericWorker': 28 },
        ],
        4: [
          function (e, t2, r) {
            var n2 = e('./utils')
            var o = (function () {
              for (var e2, t3 = [], r2 = 0; r2 < 256; r2++) {
                e2 = r2
                for (var n3 = 0; n3 < 8; n3++) e2 = 1 & e2 ? 3988292384 ^ (e2 >>> 1) : e2 >>> 1
                t3[r2] = e2
              }
              return t3
            })()
            t2.exports = function (e2, t3) {
              return e2 !== void 0 && e2.length
                ? n2.getTypeOf(e2) !== 'string'
                  ? (function (e3, t4, r2, n3) {
                      var i = o,
                        s2 = n3 + r2
                      e3 ^= -1
                      for (var a = n3; a < s2; a++) e3 = (e3 >>> 8) ^ i[255 & (e3 ^ t4[a])]
                      return -1 ^ e3
                    })(0 | t3, e2, e2.length, 0)
                  : (function (e3, t4, r2, n3) {
                      var i = o,
                        s2 = n3 + r2
                      e3 ^= -1
                      for (var a = n3; a < s2; a++) e3 = (e3 >>> 8) ^ i[255 & (e3 ^ t4.charCodeAt(a))]
                      return -1 ^ e3
                    })(0 | t3, e2, e2.length, 0)
                : 0
            }
          },
          { './utils': 32 },
        ],
        5: [
          function (e, t2, r) {
            ;(r.base64 = false),
              (r.binary = false),
              (r.dir = false),
              (r.createFolders = true),
              (r.date = null),
              (r.compression = null),
              (r.compressionOptions = null),
              (r.comment = null),
              (r.unixPermissions = null),
              (r.dosPermissions = null)
          },
          {},
        ],
        6: [
          function (e, t2, r) {
            var n2 = null
            ;(n2 = typeof Promise != 'undefined' ? Promise : e('lie')), (t2.exports = { Promise: n2 })
          },
          { lie: 37 },
        ],
        7: [
          function (e, t2, r) {
            var n2 =
                typeof Uint8Array != 'undefined' &&
                typeof Uint16Array != 'undefined' &&
                typeof Uint32Array != 'undefined',
              i = e('pako'),
              s2 = e('./utils'),
              a = e('./stream/GenericWorker'),
              o = n2 ? 'uint8array' : 'array'
            function h2(e2, t3) {
              a.call(this, 'FlateWorker/' + e2),
                (this._pako = null),
                (this._pakoAction = e2),
                (this._pakoOptions = t3),
                (this.meta = {})
            }
            ;(r.magic = '\b\0'),
              s2.inherits(h2, a),
              (h2.prototype.processChunk = function (e2) {
                ;(this.meta = e2.meta),
                  this._pako === null && this._createPako(),
                  this._pako.push(s2.transformTo(o, e2.data), false)
              }),
              (h2.prototype.flush = function () {
                a.prototype.flush.call(this), this._pako === null && this._createPako(), this._pako.push([], true)
              }),
              (h2.prototype.cleanUp = function () {
                a.prototype.cleanUp.call(this), (this._pako = null)
              }),
              (h2.prototype._createPako = function () {
                this._pako = new i[this._pakoAction]({ raw: true, level: this._pakoOptions.level || -1 })
                var t3 = this
                this._pako.onData = function (e2) {
                  t3.push({ data: e2, meta: t3.meta })
                }
              }),
              (r.compressWorker = function (e2) {
                return new h2('Deflate', e2)
              }),
              (r.uncompressWorker = function () {
                return new h2('Inflate', {})
              })
          },
          { './stream/GenericWorker': 28, './utils': 32, pako: 38 },
        ],
        8: [
          function (e, t2, r) {
            function A(e2, t3) {
              var r2,
                n3 = ''
              for (r2 = 0; r2 < t3; r2++) (n3 += String.fromCharCode(255 & e2)), (e2 >>>= 8)
              return n3
            }
            function n2(e2, t3, r2, n3, i2, s3) {
              var a,
                o,
                h2 = e2.file,
                u = e2.compression,
                l = s3 !== O.utf8encode,
                f = I.transformTo('string', s3(h2.name)),
                c = I.transformTo('string', O.utf8encode(h2.name)),
                d2 = h2.comment,
                p = I.transformTo('string', s3(d2)),
                m2 = I.transformTo('string', O.utf8encode(d2)),
                _2 = c.length !== h2.name.length,
                g = m2.length !== d2.length,
                b = '',
                v = '',
                y2 = '',
                w2 = h2.dir,
                k = h2.date,
                x = { crc32: 0, compressedSize: 0, uncompressedSize: 0 }
              ;(t3 && !r2) ||
                ((x.crc32 = e2.crc32),
                (x.compressedSize = e2.compressedSize),
                (x.uncompressedSize = e2.uncompressedSize))
              var S2 = 0
              t3 && (S2 |= 8), l || (!_2 && !g) || (S2 |= 2048)
              var z = 0,
                C = 0
              w2 && (z |= 16),
                i2 === 'UNIX'
                  ? ((C = 798),
                    (z |= (function (e3, t4) {
                      var r3 = e3
                      return e3 || (r3 = t4 ? 16893 : 33204), (65535 & r3) << 16
                    })(h2.unixPermissions, w2)))
                  : ((C = 20),
                    (z |= (function (e3) {
                      return 63 & (e3 || 0)
                    })(h2.dosPermissions))),
                (a = k.getUTCHours()),
                (a <<= 6),
                (a |= k.getUTCMinutes()),
                (a <<= 5),
                (a |= k.getUTCSeconds() / 2),
                (o = k.getUTCFullYear() - 1980),
                (o <<= 4),
                (o |= k.getUTCMonth() + 1),
                (o <<= 5),
                (o |= k.getUTCDate()),
                _2 && ((v = A(1, 1) + A(B(f), 4) + c), (b += 'up' + A(v.length, 2) + v)),
                g && ((y2 = A(1, 1) + A(B(p), 4) + m2), (b += 'uc' + A(y2.length, 2) + y2))
              var E = ''
              return (
                (E += '\n\0'),
                (E += A(S2, 2)),
                (E += u.magic),
                (E += A(a, 2)),
                (E += A(o, 2)),
                (E += A(x.crc32, 4)),
                (E += A(x.compressedSize, 4)),
                (E += A(x.uncompressedSize, 4)),
                (E += A(f.length, 2)),
                (E += A(b.length, 2)),
                {
                  fileRecord: R.LOCAL_FILE_HEADER + E + f + b,
                  dirRecord:
                    R.CENTRAL_FILE_HEADER + A(C, 2) + E + A(p.length, 2) + '\0\0\0\0' + A(z, 4) + A(n3, 4) + f + b + p,
                }
              )
            }
            var I = e('../utils'),
              i = e('../stream/GenericWorker'),
              O = e('../utf8'),
              B = e('../crc32'),
              R = e('../signature')
            function s2(e2, t3, r2, n3) {
              i.call(this, 'ZipFileWorker'),
                (this.bytesWritten = 0),
                (this.zipComment = t3),
                (this.zipPlatform = r2),
                (this.encodeFileName = n3),
                (this.streamFiles = e2),
                (this.accumulate = false),
                (this.contentBuffer = []),
                (this.dirRecords = []),
                (this.currentSourceOffset = 0),
                (this.entriesCount = 0),
                (this.currentFile = null),
                (this._sources = [])
            }
            I.inherits(s2, i),
              (s2.prototype.push = function (e2) {
                var t3 = e2.meta.percent || 0,
                  r2 = this.entriesCount,
                  n3 = this._sources.length
                this.accumulate
                  ? this.contentBuffer.push(e2)
                  : ((this.bytesWritten += e2.data.length),
                    i.prototype.push.call(this, {
                      data: e2.data,
                      meta: { currentFile: this.currentFile, percent: r2 ? (t3 + 100 * (r2 - n3 - 1)) / r2 : 100 },
                    }))
              }),
              (s2.prototype.openedSource = function (e2) {
                ;(this.currentSourceOffset = this.bytesWritten), (this.currentFile = e2.file.name)
                var t3 = this.streamFiles && !e2.file.dir
                if (t3) {
                  var r2 = n2(e2, t3, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName)
                  this.push({ data: r2.fileRecord, meta: { percent: 0 } })
                } else this.accumulate = true
              }),
              (s2.prototype.closedSource = function (e2) {
                this.accumulate = false
                var t3 = this.streamFiles && !e2.file.dir,
                  r2 = n2(e2, t3, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName)
                if ((this.dirRecords.push(r2.dirRecord), t3))
                  this.push({
                    data: (function (e3) {
                      return R.DATA_DESCRIPTOR + A(e3.crc32, 4) + A(e3.compressedSize, 4) + A(e3.uncompressedSize, 4)
                    })(e2),
                    meta: { percent: 100 },
                  })
                else
                  for (this.push({ data: r2.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; )
                    this.push(this.contentBuffer.shift())
                this.currentFile = null
              }),
              (s2.prototype.flush = function () {
                for (var e2 = this.bytesWritten, t3 = 0; t3 < this.dirRecords.length; t3++)
                  this.push({ data: this.dirRecords[t3], meta: { percent: 100 } })
                var r2 = this.bytesWritten - e2,
                  n3 = (function (e3, t4, r3, n4, i2) {
                    var s3 = I.transformTo('string', i2(n4))
                    return (
                      R.CENTRAL_DIRECTORY_END +
                      '\0\0\0\0' +
                      A(e3, 2) +
                      A(e3, 2) +
                      A(t4, 4) +
                      A(r3, 4) +
                      A(s3.length, 2) +
                      s3
                    )
                  })(this.dirRecords.length, r2, e2, this.zipComment, this.encodeFileName)
                this.push({ data: n3, meta: { percent: 100 } })
              }),
              (s2.prototype.prepareNextSource = function () {
                ;(this.previous = this._sources.shift()),
                  this.openedSource(this.previous.streamInfo),
                  this.isPaused ? this.previous.pause() : this.previous.resume()
              }),
              (s2.prototype.registerPrevious = function (e2) {
                this._sources.push(e2)
                var t3 = this
                return (
                  e2.on('data', function (e3) {
                    t3.processChunk(e3)
                  }),
                  e2.on('end', function () {
                    t3.closedSource(t3.previous.streamInfo), t3._sources.length ? t3.prepareNextSource() : t3.end()
                  }),
                  e2.on('error', function (e3) {
                    t3.error(e3)
                  }),
                  this
                )
              }),
              (s2.prototype.resume = function () {
                return (
                  !!i.prototype.resume.call(this) &&
                  (!this.previous && this._sources.length
                    ? (this.prepareNextSource(), true)
                    : this.previous || this._sources.length || this.generatedError
                    ? void 0
                    : (this.end(), true))
                )
              }),
              (s2.prototype.error = function (e2) {
                var t3 = this._sources
                if (!i.prototype.error.call(this, e2)) return false
                for (var r2 = 0; r2 < t3.length; r2++)
                  try {
                    t3[r2].error(e2)
                  } catch (e3) {}
                return true
              }),
              (s2.prototype.lock = function () {
                i.prototype.lock.call(this)
                for (var e2 = this._sources, t3 = 0; t3 < e2.length; t3++) e2[t3].lock()
              }),
              (t2.exports = s2)
          },
          { '../crc32': 4, '../signature': 23, '../stream/GenericWorker': 28, '../utf8': 31, '../utils': 32 },
        ],
        9: [
          function (e, t2, r) {
            var u = e('../compressions'),
              n2 = e('./ZipFileWorker')
            r.generateWorker = function (e2, a, t3) {
              var o = new n2(a.streamFiles, t3, a.platform, a.encodeFileName),
                h2 = 0
              try {
                e2.forEach(function (e3, t4) {
                  h2++
                  var r2 = (function (e4, t5) {
                      var r3 = e4 || t5,
                        n4 = u[r3]
                      if (!n4) throw new Error(r3 + ' is not a valid compression method !')
                      return n4
                    })(t4.options.compression, a.compression),
                    n3 = t4.options.compressionOptions || a.compressionOptions || {},
                    i = t4.dir,
                    s2 = t4.date
                  t4._compressWorker(r2, n3)
                    .withStreamInfo('file', {
                      name: e3,
                      dir: i,
                      date: s2,
                      comment: t4.comment || '',
                      unixPermissions: t4.unixPermissions,
                      dosPermissions: t4.dosPermissions,
                    })
                    .pipe(o)
                }),
                  (o.entriesCount = h2)
              } catch (e3) {
                o.error(e3)
              }
              return o
            }
          },
          { '../compressions': 3, './ZipFileWorker': 8 },
        ],
        10: [
          function (e, t2, r) {
            function n2() {
              if (!(this instanceof n2)) return new n2()
              if (arguments.length)
                throw new Error(
                  'The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.'
                )
              ;(this.files = /* @__PURE__ */ Object.create(null)),
                (this.comment = null),
                (this.root = ''),
                (this.clone = function () {
                  var e2 = new n2()
                  for (var t3 in this) typeof this[t3] != 'function' && (e2[t3] = this[t3])
                  return e2
                })
            }
            ;((n2.prototype = e('./object')).loadAsync = e('./load')),
              (n2.support = e('./support')),
              (n2.defaults = e('./defaults')),
              (n2.version = '3.10.0'),
              (n2.loadAsync = function (e2, t3) {
                return new n2().loadAsync(e2, t3)
              }),
              (n2.external = e('./external')),
              (t2.exports = n2)
          },
          { './defaults': 5, './external': 6, './load': 11, './object': 15, './support': 30 },
        ],
        11: [
          function (e, t2, r) {
            var u = e('./utils'),
              i = e('./external'),
              n2 = e('./utf8'),
              s2 = e('./zipEntries'),
              a = e('./stream/Crc32Probe'),
              l = e('./nodejsUtils')
            function f(n3) {
              return new i.Promise(function (e2, t3) {
                var r2 = n3.decompressed.getContentWorker().pipe(new a())
                r2.on('error', function (e3) {
                  t3(e3)
                })
                  .on('end', function () {
                    r2.streamInfo.crc32 !== n3.decompressed.crc32
                      ? t3(new Error('Corrupted zip : CRC32 mismatch'))
                      : e2()
                  })
                  .resume()
              })
            }
            t2.exports = function (e2, o) {
              var h2 = this
              return (
                (o = u.extend(o || {}, {
                  base64: false,
                  checkCRC32: false,
                  optimizedBinaryString: false,
                  createFolders: false,
                  decodeFileName: n2.utf8decode,
                })),
                l.isNode && l.isStream(e2)
                  ? i.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file."))
                  : u
                      .prepareContent('the loaded zip file', e2, true, o.optimizedBinaryString, o.base64)
                      .then(function (e3) {
                        var t3 = new s2(o)
                        return t3.load(e3), t3
                      })
                      .then(function (e3) {
                        var t3 = [i.Promise.resolve(e3)],
                          r2 = e3.files
                        if (o.checkCRC32) for (var n3 = 0; n3 < r2.length; n3++) t3.push(f(r2[n3]))
                        return i.Promise.all(t3)
                      })
                      .then(function (e3) {
                        for (var t3 = e3.shift(), r2 = t3.files, n3 = 0; n3 < r2.length; n3++) {
                          var i2 = r2[n3],
                            s3 = i2.fileNameStr,
                            a2 = u.resolve(i2.fileNameStr)
                          h2.file(a2, i2.decompressed, {
                            binary: true,
                            optimizedBinaryString: true,
                            date: i2.date,
                            dir: i2.dir,
                            comment: i2.fileCommentStr.length ? i2.fileCommentStr : null,
                            unixPermissions: i2.unixPermissions,
                            dosPermissions: i2.dosPermissions,
                            createFolders: o.createFolders,
                          }),
                            i2.dir || (h2.file(a2).unsafeOriginalName = s3)
                        }
                        return t3.zipComment.length && (h2.comment = t3.zipComment), h2
                      })
              )
            }
          },
          {
            './external': 6,
            './nodejsUtils': 14,
            './stream/Crc32Probe': 25,
            './utf8': 31,
            './utils': 32,
            './zipEntries': 33,
          },
        ],
        12: [
          function (e, t2, r) {
            var n2 = e('../utils'),
              i = e('../stream/GenericWorker')
            function s2(e2, t3) {
              i.call(this, 'Nodejs stream input adapter for ' + e2), (this._upstreamEnded = false), this._bindStream(t3)
            }
            n2.inherits(s2, i),
              (s2.prototype._bindStream = function (e2) {
                var t3 = this
                ;(this._stream = e2).pause(),
                  e2
                    .on('data', function (e3) {
                      t3.push({ data: e3, meta: { percent: 0 } })
                    })
                    .on('error', function (e3) {
                      t3.isPaused ? (this.generatedError = e3) : t3.error(e3)
                    })
                    .on('end', function () {
                      t3.isPaused ? (t3._upstreamEnded = true) : t3.end()
                    })
              }),
              (s2.prototype.pause = function () {
                return !!i.prototype.pause.call(this) && (this._stream.pause(), true)
              }),
              (s2.prototype.resume = function () {
                return (
                  !!i.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), true)
                )
              }),
              (t2.exports = s2)
          },
          { '../stream/GenericWorker': 28, '../utils': 32 },
        ],
        13: [
          function (e, t2, r) {
            var i = e('readable-stream').Readable
            function n2(e2, t3, r2) {
              i.call(this, t3), (this._helper = e2)
              var n3 = this
              e2.on('data', function (e3, t4) {
                n3.push(e3) || n3._helper.pause(), r2 && r2(t4)
              })
                .on('error', function (e3) {
                  n3.emit('error', e3)
                })
                .on('end', function () {
                  n3.push(null)
                })
            }
            e('../utils').inherits(n2, i),
              (n2.prototype._read = function () {
                this._helper.resume()
              }),
              (t2.exports = n2)
          },
          { '../utils': 32, 'readable-stream': 16 },
        ],
        14: [
          function (e, t2, r) {
            t2.exports = {
              isNode: typeof Buffer != 'undefined',
              newBufferFrom: function (e2, t3) {
                if (Buffer.from && Buffer.from !== Uint8Array.from) return Buffer.from(e2, t3)
                if (typeof e2 == 'number') throw new Error('The "data" argument must not be a number')
                return new Buffer(e2, t3)
              },
              allocBuffer: function (e2) {
                if (Buffer.alloc) return Buffer.alloc(e2)
                var t3 = new Buffer(e2)
                return t3.fill(0), t3
              },
              isBuffer: function (e2) {
                return Buffer.isBuffer(e2)
              },
              isStream: function (e2) {
                return (
                  e2 && typeof e2.on == 'function' && typeof e2.pause == 'function' && typeof e2.resume == 'function'
                )
              },
            }
          },
          {},
        ],
        15: [
          function (e, t2, r) {
            function s2(e2, t3, r2) {
              var n3,
                i2 = u.getTypeOf(t3),
                s3 = u.extend(r2 || {}, f)
              ;(s3.date = s3.date || new Date()),
                s3.compression !== null && (s3.compression = s3.compression.toUpperCase()),
                typeof s3.unixPermissions == 'string' && (s3.unixPermissions = parseInt(s3.unixPermissions, 8)),
                s3.unixPermissions && 16384 & s3.unixPermissions && (s3.dir = true),
                s3.dosPermissions && 16 & s3.dosPermissions && (s3.dir = true),
                s3.dir && (e2 = g(e2)),
                s3.createFolders && (n3 = _2(e2)) && b.call(this, n3, true)
              var a2 = i2 === 'string' && s3.binary === false && s3.base64 === false
              ;(r2 && r2.binary !== void 0) || (s3.binary = !a2),
                ((t3 instanceof c && t3.uncompressedSize === 0) || s3.dir || !t3 || t3.length === 0) &&
                  ((s3.base64 = false), (s3.binary = true), (t3 = ''), (s3.compression = 'STORE'), (i2 = 'string'))
              var o2 = null
              o2 =
                t3 instanceof c || t3 instanceof l
                  ? t3
                  : p.isNode && p.isStream(t3)
                  ? new m2(e2, t3)
                  : u.prepareContent(e2, t3, s3.binary, s3.optimizedBinaryString, s3.base64)
              var h3 = new d2(e2, o2, s3)
              this.files[e2] = h3
            }
            var i = e('./utf8'),
              u = e('./utils'),
              l = e('./stream/GenericWorker'),
              a = e('./stream/StreamHelper'),
              f = e('./defaults'),
              c = e('./compressedObject'),
              d2 = e('./zipObject'),
              o = e('./generate'),
              p = e('./nodejsUtils'),
              m2 = e('./nodejs/NodejsStreamInputAdapter'),
              _2 = function (e2) {
                e2.slice(-1) === '/' && (e2 = e2.substring(0, e2.length - 1))
                var t3 = e2.lastIndexOf('/')
                return 0 < t3 ? e2.substring(0, t3) : ''
              },
              g = function (e2) {
                return e2.slice(-1) !== '/' && (e2 += '/'), e2
              },
              b = function (e2, t3) {
                return (
                  (t3 = t3 !== void 0 ? t3 : f.createFolders),
                  (e2 = g(e2)),
                  this.files[e2] || s2.call(this, e2, null, { dir: true, createFolders: t3 }),
                  this.files[e2]
                )
              }
            function h2(e2) {
              return Object.prototype.toString.call(e2) === '[object RegExp]'
            }
            var n2 = {
              load: function () {
                throw new Error('This method has been removed in JSZip 3.0, please check the upgrade guide.')
              },
              forEach: function (e2) {
                var t3, r2, n3
                for (t3 in this.files)
                  (n3 = this.files[t3]),
                    (r2 = t3.slice(this.root.length, t3.length)) &&
                      t3.slice(0, this.root.length) === this.root &&
                      e2(r2, n3)
              },
              filter: function (r2) {
                var n3 = []
                return (
                  this.forEach(function (e2, t3) {
                    r2(e2, t3) && n3.push(t3)
                  }),
                  n3
                )
              },
              file: function (e2, t3, r2) {
                if (arguments.length !== 1) return (e2 = this.root + e2), s2.call(this, e2, t3, r2), this
                if (h2(e2)) {
                  var n3 = e2
                  return this.filter(function (e3, t4) {
                    return !t4.dir && n3.test(e3)
                  })
                }
                var i2 = this.files[this.root + e2]
                return i2 && !i2.dir ? i2 : null
              },
              folder: function (r2) {
                if (!r2) return this
                if (h2(r2))
                  return this.filter(function (e3, t4) {
                    return t4.dir && r2.test(e3)
                  })
                var e2 = this.root + r2,
                  t3 = b.call(this, e2),
                  n3 = this.clone()
                return (n3.root = t3.name), n3
              },
              remove: function (r2) {
                r2 = this.root + r2
                var e2 = this.files[r2]
                if ((e2 || (r2.slice(-1) !== '/' && (r2 += '/'), (e2 = this.files[r2])), e2 && !e2.dir))
                  delete this.files[r2]
                else
                  for (
                    var t3 = this.filter(function (e3, t4) {
                        return t4.name.slice(0, r2.length) === r2
                      }),
                      n3 = 0;
                    n3 < t3.length;
                    n3++
                  )
                    delete this.files[t3[n3].name]
                return this
              },
              generate: function (e2) {
                throw new Error('This method has been removed in JSZip 3.0, please check the upgrade guide.')
              },
              generateInternalStream: function (e2) {
                var t3,
                  r2 = {}
                try {
                  if (
                    (((r2 = u.extend(e2 || {}, {
                      streamFiles: false,
                      compression: 'STORE',
                      compressionOptions: null,
                      type: '',
                      platform: 'DOS',
                      comment: null,
                      mimeType: 'application/zip',
                      encodeFileName: i.utf8encode,
                    })).type = r2.type.toLowerCase()),
                    (r2.compression = r2.compression.toUpperCase()),
                    r2.type === 'binarystring' && (r2.type = 'string'),
                    !r2.type)
                  )
                    throw new Error('No output type specified.')
                  u.checkSupport(r2.type),
                    (r2.platform !== 'darwin' &&
                      r2.platform !== 'freebsd' &&
                      r2.platform !== 'linux' &&
                      r2.platform !== 'sunos') ||
                      (r2.platform = 'UNIX'),
                    r2.platform === 'win32' && (r2.platform = 'DOS')
                  var n3 = r2.comment || this.comment || ''
                  t3 = o.generateWorker(this, r2, n3)
                } catch (e3) {
                  ;(t3 = new l('error')).error(e3)
                }
                return new a(t3, r2.type || 'string', r2.mimeType)
              },
              generateAsync: function (e2, t3) {
                return this.generateInternalStream(e2).accumulate(t3)
              },
              generateNodeStream: function (e2, t3) {
                return (
                  (e2 = e2 || {}).type || (e2.type = 'nodebuffer'), this.generateInternalStream(e2).toNodejsStream(t3)
                )
              },
            }
            t2.exports = n2
          },
          {
            './compressedObject': 2,
            './defaults': 5,
            './generate': 9,
            './nodejs/NodejsStreamInputAdapter': 12,
            './nodejsUtils': 14,
            './stream/GenericWorker': 28,
            './stream/StreamHelper': 29,
            './utf8': 31,
            './utils': 32,
            './zipObject': 35,
          },
        ],
        16: [
          function (e, t2, r) {
            t2.exports = e('stream')
          },
          { stream: void 0 },
        ],
        17: [
          function (e, t2, r) {
            var n2 = e('./DataReader')
            function i(e2) {
              n2.call(this, e2)
              for (var t3 = 0; t3 < this.data.length; t3++) e2[t3] = 255 & e2[t3]
            }
            e('../utils').inherits(i, n2),
              (i.prototype.byteAt = function (e2) {
                return this.data[this.zero + e2]
              }),
              (i.prototype.lastIndexOfSignature = function (e2) {
                for (
                  var t3 = e2.charCodeAt(0),
                    r2 = e2.charCodeAt(1),
                    n3 = e2.charCodeAt(2),
                    i2 = e2.charCodeAt(3),
                    s2 = this.length - 4;
                  0 <= s2;
                  --s2
                )
                  if (
                    this.data[s2] === t3 &&
                    this.data[s2 + 1] === r2 &&
                    this.data[s2 + 2] === n3 &&
                    this.data[s2 + 3] === i2
                  )
                    return s2 - this.zero
                return -1
              }),
              (i.prototype.readAndCheckSignature = function (e2) {
                var t3 = e2.charCodeAt(0),
                  r2 = e2.charCodeAt(1),
                  n3 = e2.charCodeAt(2),
                  i2 = e2.charCodeAt(3),
                  s2 = this.readData(4)
                return t3 === s2[0] && r2 === s2[1] && n3 === s2[2] && i2 === s2[3]
              }),
              (i.prototype.readData = function (e2) {
                if ((this.checkOffset(e2), e2 === 0)) return []
                var t3 = this.data.slice(this.zero + this.index, this.zero + this.index + e2)
                return (this.index += e2), t3
              }),
              (t2.exports = i)
          },
          { '../utils': 32, './DataReader': 18 },
        ],
        18: [
          function (e, t2, r) {
            var n2 = e('../utils')
            function i(e2) {
              ;(this.data = e2), (this.length = e2.length), (this.index = 0), (this.zero = 0)
            }
            ;(i.prototype = {
              checkOffset: function (e2) {
                this.checkIndex(this.index + e2)
              },
              checkIndex: function (e2) {
                if (this.length < this.zero + e2 || e2 < 0)
                  throw new Error(
                    'End of data reached (data length = ' + this.length + ', asked index = ' + e2 + '). Corrupted zip ?'
                  )
              },
              setIndex: function (e2) {
                this.checkIndex(e2), (this.index = e2)
              },
              skip: function (e2) {
                this.setIndex(this.index + e2)
              },
              byteAt: function (e2) {},
              readInt: function (e2) {
                var t3,
                  r2 = 0
                for (this.checkOffset(e2), t3 = this.index + e2 - 1; t3 >= this.index; t3--)
                  r2 = (r2 << 8) + this.byteAt(t3)
                return (this.index += e2), r2
              },
              readString: function (e2) {
                return n2.transformTo('string', this.readData(e2))
              },
              readData: function (e2) {},
              lastIndexOfSignature: function (e2) {},
              readAndCheckSignature: function (e2) {},
              readDate: function () {
                var e2 = this.readInt(4)
                return new Date(
                  Date.UTC(
                    1980 + ((e2 >> 25) & 127),
                    ((e2 >> 21) & 15) - 1,
                    (e2 >> 16) & 31,
                    (e2 >> 11) & 31,
                    (e2 >> 5) & 63,
                    (31 & e2) << 1
                  )
                )
              },
            }),
              (t2.exports = i)
          },
          { '../utils': 32 },
        ],
        19: [
          function (e, t2, r) {
            var n2 = e('./Uint8ArrayReader')
            function i(e2) {
              n2.call(this, e2)
            }
            e('../utils').inherits(i, n2),
              (i.prototype.readData = function (e2) {
                this.checkOffset(e2)
                var t3 = this.data.slice(this.zero + this.index, this.zero + this.index + e2)
                return (this.index += e2), t3
              }),
              (t2.exports = i)
          },
          { '../utils': 32, './Uint8ArrayReader': 21 },
        ],
        20: [
          function (e, t2, r) {
            var n2 = e('./DataReader')
            function i(e2) {
              n2.call(this, e2)
            }
            e('../utils').inherits(i, n2),
              (i.prototype.byteAt = function (e2) {
                return this.data.charCodeAt(this.zero + e2)
              }),
              (i.prototype.lastIndexOfSignature = function (e2) {
                return this.data.lastIndexOf(e2) - this.zero
              }),
              (i.prototype.readAndCheckSignature = function (e2) {
                return e2 === this.readData(4)
              }),
              (i.prototype.readData = function (e2) {
                this.checkOffset(e2)
                var t3 = this.data.slice(this.zero + this.index, this.zero + this.index + e2)
                return (this.index += e2), t3
              }),
              (t2.exports = i)
          },
          { '../utils': 32, './DataReader': 18 },
        ],
        21: [
          function (e, t2, r) {
            var n2 = e('./ArrayReader')
            function i(e2) {
              n2.call(this, e2)
            }
            e('../utils').inherits(i, n2),
              (i.prototype.readData = function (e2) {
                if ((this.checkOffset(e2), e2 === 0)) return new Uint8Array(0)
                var t3 = this.data.subarray(this.zero + this.index, this.zero + this.index + e2)
                return (this.index += e2), t3
              }),
              (t2.exports = i)
          },
          { '../utils': 32, './ArrayReader': 17 },
        ],
        22: [
          function (e, t2, r) {
            var n2 = e('../utils'),
              i = e('../support'),
              s2 = e('./ArrayReader'),
              a = e('./StringReader'),
              o = e('./NodeBufferReader'),
              h2 = e('./Uint8ArrayReader')
            t2.exports = function (e2) {
              var t3 = n2.getTypeOf(e2)
              return (
                n2.checkSupport(t3),
                t3 !== 'string' || i.uint8array
                  ? t3 === 'nodebuffer'
                    ? new o(e2)
                    : i.uint8array
                    ? new h2(n2.transformTo('uint8array', e2))
                    : new s2(n2.transformTo('array', e2))
                  : new a(e2)
              )
            }
          },
          {
            '../support': 30,
            '../utils': 32,
            './ArrayReader': 17,
            './NodeBufferReader': 19,
            './StringReader': 20,
            './Uint8ArrayReader': 21,
          },
        ],
        23: [
          function (e, t2, r) {
            ;(r.LOCAL_FILE_HEADER = 'PK'),
              (r.CENTRAL_FILE_HEADER = 'PK'),
              (r.CENTRAL_DIRECTORY_END = 'PK'),
              (r.ZIP64_CENTRAL_DIRECTORY_LOCATOR = 'PK\x07'),
              (r.ZIP64_CENTRAL_DIRECTORY_END = 'PK'),
              (r.DATA_DESCRIPTOR = 'PK\x07\b')
          },
          {},
        ],
        24: [
          function (e, t2, r) {
            var n2 = e('./GenericWorker'),
              i = e('../utils')
            function s2(e2) {
              n2.call(this, 'ConvertWorker to ' + e2), (this.destType = e2)
            }
            i.inherits(s2, n2),
              (s2.prototype.processChunk = function (e2) {
                this.push({ data: i.transformTo(this.destType, e2.data), meta: e2.meta })
              }),
              (t2.exports = s2)
          },
          { '../utils': 32, './GenericWorker': 28 },
        ],
        25: [
          function (e, t2, r) {
            var n2 = e('./GenericWorker'),
              i = e('../crc32')
            function s2() {
              n2.call(this, 'Crc32Probe'), this.withStreamInfo('crc32', 0)
            }
            e('../utils').inherits(s2, n2),
              (s2.prototype.processChunk = function (e2) {
                ;(this.streamInfo.crc32 = i(e2.data, this.streamInfo.crc32 || 0)), this.push(e2)
              }),
              (t2.exports = s2)
          },
          { '../crc32': 4, '../utils': 32, './GenericWorker': 28 },
        ],
        26: [
          function (e, t2, r) {
            var n2 = e('../utils'),
              i = e('./GenericWorker')
            function s2(e2) {
              i.call(this, 'DataLengthProbe for ' + e2), (this.propName = e2), this.withStreamInfo(e2, 0)
            }
            n2.inherits(s2, i),
              (s2.prototype.processChunk = function (e2) {
                if (e2) {
                  var t3 = this.streamInfo[this.propName] || 0
                  this.streamInfo[this.propName] = t3 + e2.data.length
                }
                i.prototype.processChunk.call(this, e2)
              }),
              (t2.exports = s2)
          },
          { '../utils': 32, './GenericWorker': 28 },
        ],
        27: [
          function (e, t2, r) {
            var n2 = e('../utils'),
              i = e('./GenericWorker')
            function s2(e2) {
              i.call(this, 'DataWorker')
              var t3 = this
              ;(this.dataIsReady = false),
                (this.index = 0),
                (this.max = 0),
                (this.data = null),
                (this.type = ''),
                (this._tickScheduled = false),
                e2.then(
                  function (e3) {
                    ;(t3.dataIsReady = true),
                      (t3.data = e3),
                      (t3.max = (e3 && e3.length) || 0),
                      (t3.type = n2.getTypeOf(e3)),
                      t3.isPaused || t3._tickAndRepeat()
                  },
                  function (e3) {
                    t3.error(e3)
                  }
                )
            }
            n2.inherits(s2, i),
              (s2.prototype.cleanUp = function () {
                i.prototype.cleanUp.call(this), (this.data = null)
              }),
              (s2.prototype.resume = function () {
                return (
                  !!i.prototype.resume.call(this) &&
                  (!this._tickScheduled &&
                    this.dataIsReady &&
                    ((this._tickScheduled = true), n2.delay(this._tickAndRepeat, [], this)),
                  true)
                )
              }),
              (s2.prototype._tickAndRepeat = function () {
                ;(this._tickScheduled = false),
                  this.isPaused ||
                    this.isFinished ||
                    (this._tick(),
                    this.isFinished || (n2.delay(this._tickAndRepeat, [], this), (this._tickScheduled = true)))
              }),
              (s2.prototype._tick = function () {
                if (this.isPaused || this.isFinished) return false
                var e2 = null,
                  t3 = Math.min(this.max, this.index + 16384)
                if (this.index >= this.max) return this.end()
                switch (this.type) {
                  case 'string':
                    e2 = this.data.substring(this.index, t3)
                    break
                  case 'uint8array':
                    e2 = this.data.subarray(this.index, t3)
                    break
                  case 'array':
                  case 'nodebuffer':
                    e2 = this.data.slice(this.index, t3)
                }
                return (
                  (this.index = t3),
                  this.push({ data: e2, meta: { percent: this.max ? (this.index / this.max) * 100 : 0 } })
                )
              }),
              (t2.exports = s2)
          },
          { '../utils': 32, './GenericWorker': 28 },
        ],
        28: [
          function (e, t2, r) {
            function n2(e2) {
              ;(this.name = e2 || 'default'),
                (this.streamInfo = {}),
                (this.generatedError = null),
                (this.extraStreamInfo = {}),
                (this.isPaused = true),
                (this.isFinished = false),
                (this.isLocked = false),
                (this._listeners = { data: [], end: [], error: [] }),
                (this.previous = null)
            }
            ;(n2.prototype = {
              push: function (e2) {
                this.emit('data', e2)
              },
              end: function () {
                if (this.isFinished) return false
                this.flush()
                try {
                  this.emit('end'), this.cleanUp(), (this.isFinished = true)
                } catch (e2) {
                  this.emit('error', e2)
                }
                return true
              },
              error: function (e2) {
                return (
                  !this.isFinished &&
                  (this.isPaused
                    ? (this.generatedError = e2)
                    : ((this.isFinished = true),
                      this.emit('error', e2),
                      this.previous && this.previous.error(e2),
                      this.cleanUp()),
                  true)
                )
              },
              on: function (e2, t3) {
                return this._listeners[e2].push(t3), this
              },
              cleanUp: function () {
                ;(this.streamInfo = this.generatedError = this.extraStreamInfo = null), (this._listeners = [])
              },
              emit: function (e2, t3) {
                if (this._listeners[e2])
                  for (var r2 = 0; r2 < this._listeners[e2].length; r2++) this._listeners[e2][r2].call(this, t3)
              },
              pipe: function (e2) {
                return e2.registerPrevious(this)
              },
              registerPrevious: function (e2) {
                if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.")
                ;(this.streamInfo = e2.streamInfo), this.mergeStreamInfo(), (this.previous = e2)
                var t3 = this
                return (
                  e2.on('data', function (e3) {
                    t3.processChunk(e3)
                  }),
                  e2.on('end', function () {
                    t3.end()
                  }),
                  e2.on('error', function (e3) {
                    t3.error(e3)
                  }),
                  this
                )
              },
              pause: function () {
                return (
                  !this.isPaused &&
                  !this.isFinished &&
                  ((this.isPaused = true), this.previous && this.previous.pause(), true)
                )
              },
              resume: function () {
                if (!this.isPaused || this.isFinished) return false
                var e2 = (this.isPaused = false)
                return (
                  this.generatedError && (this.error(this.generatedError), (e2 = true)),
                  this.previous && this.previous.resume(),
                  !e2
                )
              },
              flush: function () {},
              processChunk: function (e2) {
                this.push(e2)
              },
              withStreamInfo: function (e2, t3) {
                return (this.extraStreamInfo[e2] = t3), this.mergeStreamInfo(), this
              },
              mergeStreamInfo: function () {
                for (var e2 in this.extraStreamInfo)
                  this.extraStreamInfo.hasOwnProperty(e2) && (this.streamInfo[e2] = this.extraStreamInfo[e2])
              },
              lock: function () {
                if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.")
                ;(this.isLocked = true), this.previous && this.previous.lock()
              },
              toString: function () {
                var e2 = 'Worker ' + this.name
                return this.previous ? this.previous + ' -> ' + e2 : e2
              },
            }),
              (t2.exports = n2)
          },
          {},
        ],
        29: [
          function (e, t2, r) {
            var h2 = e('../utils'),
              i = e('./ConvertWorker'),
              s2 = e('./GenericWorker'),
              u = e('../base64'),
              n2 = e('../support'),
              a = e('../external'),
              o = null
            if (n2.nodestream)
              try {
                o = e('../nodejs/NodejsStreamOutputAdapter')
              } catch (e2) {}
            function l(e2, o2) {
              return new a.Promise(function (t3, r2) {
                var n3 = [],
                  i2 = e2._internalType,
                  s3 = e2._outputType,
                  a2 = e2._mimeType
                e2.on('data', function (e3, t4) {
                  n3.push(e3), o2 && o2(t4)
                })
                  .on('error', function (e3) {
                    ;(n3 = []), r2(e3)
                  })
                  .on('end', function () {
                    try {
                      var e3 = (function (e4, t4, r3) {
                        switch (e4) {
                          case 'blob':
                            return h2.newBlob(h2.transformTo('arraybuffer', t4), r3)
                          case 'base64':
                            return u.encode(t4)
                          default:
                            return h2.transformTo(e4, t4)
                        }
                      })(
                        s3,
                        (function (e4, t4) {
                          var r3,
                            n4 = 0,
                            i3 = null,
                            s4 = 0
                          for (r3 = 0; r3 < t4.length; r3++) s4 += t4[r3].length
                          switch (e4) {
                            case 'string':
                              return t4.join('')
                            case 'array':
                              return Array.prototype.concat.apply([], t4)
                            case 'uint8array':
                              for (i3 = new Uint8Array(s4), r3 = 0; r3 < t4.length; r3++)
                                i3.set(t4[r3], n4), (n4 += t4[r3].length)
                              return i3
                            case 'nodebuffer':
                              return Buffer.concat(t4)
                            default:
                              throw new Error("concat : unsupported type '" + e4 + "'")
                          }
                        })(i2, n3),
                        a2
                      )
                      t3(e3)
                    } catch (e4) {
                      r2(e4)
                    }
                    n3 = []
                  })
                  .resume()
              })
            }
            function f(e2, t3, r2) {
              var n3 = t3
              switch (t3) {
                case 'blob':
                case 'arraybuffer':
                  n3 = 'uint8array'
                  break
                case 'base64':
                  n3 = 'string'
              }
              try {
                ;(this._internalType = n3),
                  (this._outputType = t3),
                  (this._mimeType = r2),
                  h2.checkSupport(n3),
                  (this._worker = e2.pipe(new i(n3))),
                  e2.lock()
              } catch (e3) {
                ;(this._worker = new s2('error')), this._worker.error(e3)
              }
            }
            ;(f.prototype = {
              accumulate: function (e2) {
                return l(this, e2)
              },
              on: function (e2, t3) {
                var r2 = this
                return (
                  e2 === 'data'
                    ? this._worker.on(e2, function (e3) {
                        t3.call(r2, e3.data, e3.meta)
                      })
                    : this._worker.on(e2, function () {
                        h2.delay(t3, arguments, r2)
                      }),
                  this
                )
              },
              resume: function () {
                return h2.delay(this._worker.resume, [], this._worker), this
              },
              pause: function () {
                return this._worker.pause(), this
              },
              toNodejsStream: function (e2) {
                if ((h2.checkSupport('nodestream'), this._outputType !== 'nodebuffer'))
                  throw new Error(this._outputType + ' is not supported by this method')
                return new o(this, { objectMode: this._outputType !== 'nodebuffer' }, e2)
              },
            }),
              (t2.exports = f)
          },
          {
            '../base64': 1,
            '../external': 6,
            '../nodejs/NodejsStreamOutputAdapter': 13,
            '../support': 30,
            '../utils': 32,
            './ConvertWorker': 24,
            './GenericWorker': 28,
          },
        ],
        30: [
          function (e, t2, r) {
            if (
              ((r.base64 = true),
              (r.array = true),
              (r.string = true),
              (r.arraybuffer = typeof ArrayBuffer != 'undefined' && typeof Uint8Array != 'undefined'),
              (r.nodebuffer = typeof Buffer != 'undefined'),
              (r.uint8array = typeof Uint8Array != 'undefined'),
              typeof ArrayBuffer == 'undefined')
            )
              r.blob = false
            else {
              var n2 = new ArrayBuffer(0)
              try {
                r.blob = new Blob([n2], { type: 'application/zip' }).size === 0
              } catch (e2) {
                try {
                  var i = new (self.BlobBuilder ||
                    self.WebKitBlobBuilder ||
                    self.MozBlobBuilder ||
                    self.MSBlobBuilder)()
                  i.append(n2), (r.blob = i.getBlob('application/zip').size === 0)
                } catch (e3) {
                  r.blob = false
                }
              }
            }
            try {
              r.nodestream = !!e('readable-stream').Readable
            } catch (e2) {
              r.nodestream = false
            }
          },
          { 'readable-stream': 16 },
        ],
        31: [
          function (e, t2, s2) {
            for (
              var o = e('./utils'),
                h2 = e('./support'),
                r = e('./nodejsUtils'),
                n2 = e('./stream/GenericWorker'),
                u = new Array(256),
                i = 0;
              i < 256;
              i++
            )
              u[i] = 252 <= i ? 6 : 248 <= i ? 5 : 240 <= i ? 4 : 224 <= i ? 3 : 192 <= i ? 2 : 1
            u[254] = u[254] = 1
            function a() {
              n2.call(this, 'utf-8 decode'), (this.leftOver = null)
            }
            function l() {
              n2.call(this, 'utf-8 encode')
            }
            ;(s2.utf8encode = function (e2) {
              return h2.nodebuffer
                ? r.newBufferFrom(e2, 'utf-8')
                : (function (e3) {
                    var t3,
                      r2,
                      n3,
                      i2,
                      s3,
                      a2 = e3.length,
                      o2 = 0
                    for (i2 = 0; i2 < a2; i2++)
                      (64512 & (r2 = e3.charCodeAt(i2))) == 55296 &&
                        i2 + 1 < a2 &&
                        (64512 & (n3 = e3.charCodeAt(i2 + 1))) == 56320 &&
                        ((r2 = 65536 + ((r2 - 55296) << 10) + (n3 - 56320)), i2++),
                        (o2 += r2 < 128 ? 1 : r2 < 2048 ? 2 : r2 < 65536 ? 3 : 4)
                    for (t3 = h2.uint8array ? new Uint8Array(o2) : new Array(o2), i2 = s3 = 0; s3 < o2; i2++)
                      (64512 & (r2 = e3.charCodeAt(i2))) == 55296 &&
                        i2 + 1 < a2 &&
                        (64512 & (n3 = e3.charCodeAt(i2 + 1))) == 56320 &&
                        ((r2 = 65536 + ((r2 - 55296) << 10) + (n3 - 56320)), i2++),
                        r2 < 128
                          ? (t3[s3++] = r2)
                          : (r2 < 2048
                              ? (t3[s3++] = 192 | (r2 >>> 6))
                              : (r2 < 65536
                                  ? (t3[s3++] = 224 | (r2 >>> 12))
                                  : ((t3[s3++] = 240 | (r2 >>> 18)), (t3[s3++] = 128 | ((r2 >>> 12) & 63))),
                                (t3[s3++] = 128 | ((r2 >>> 6) & 63))),
                            (t3[s3++] = 128 | (63 & r2)))
                    return t3
                  })(e2)
            }),
              (s2.utf8decode = function (e2) {
                return h2.nodebuffer
                  ? o.transformTo('nodebuffer', e2).toString('utf-8')
                  : (function (e3) {
                      var t3,
                        r2,
                        n3,
                        i2,
                        s3 = e3.length,
                        a2 = new Array(2 * s3)
                      for (t3 = r2 = 0; t3 < s3; )
                        if ((n3 = e3[t3++]) < 128) a2[r2++] = n3
                        else if (4 < (i2 = u[n3])) (a2[r2++] = 65533), (t3 += i2 - 1)
                        else {
                          for (n3 &= i2 === 2 ? 31 : i2 === 3 ? 15 : 7; 1 < i2 && t3 < s3; )
                            (n3 = (n3 << 6) | (63 & e3[t3++])), i2--
                          1 < i2
                            ? (a2[r2++] = 65533)
                            : n3 < 65536
                            ? (a2[r2++] = n3)
                            : ((n3 -= 65536),
                              (a2[r2++] = 55296 | ((n3 >> 10) & 1023)),
                              (a2[r2++] = 56320 | (1023 & n3)))
                        }
                      return (
                        a2.length !== r2 && (a2.subarray ? (a2 = a2.subarray(0, r2)) : (a2.length = r2)),
                        o.applyFromCharCode(a2)
                      )
                    })((e2 = o.transformTo(h2.uint8array ? 'uint8array' : 'array', e2)))
              }),
              o.inherits(a, n2),
              (a.prototype.processChunk = function (e2) {
                var t3 = o.transformTo(h2.uint8array ? 'uint8array' : 'array', e2.data)
                if (this.leftOver && this.leftOver.length) {
                  if (h2.uint8array) {
                    var r2 = t3
                    ;(t3 = new Uint8Array(r2.length + this.leftOver.length)).set(this.leftOver, 0),
                      t3.set(r2, this.leftOver.length)
                  } else t3 = this.leftOver.concat(t3)
                  this.leftOver = null
                }
                var n3 = (function (e3, t4) {
                    var r3
                    for (
                      (t4 = t4 || e3.length) > e3.length && (t4 = e3.length), r3 = t4 - 1;
                      0 <= r3 && (192 & e3[r3]) == 128;

                    )
                      r3--
                    return r3 < 0 ? t4 : r3 === 0 ? t4 : r3 + u[e3[r3]] > t4 ? r3 : t4
                  })(t3),
                  i2 = t3
                n3 !== t3.length &&
                  (h2.uint8array
                    ? ((i2 = t3.subarray(0, n3)), (this.leftOver = t3.subarray(n3, t3.length)))
                    : ((i2 = t3.slice(0, n3)), (this.leftOver = t3.slice(n3, t3.length)))),
                  this.push({ data: s2.utf8decode(i2), meta: e2.meta })
              }),
              (a.prototype.flush = function () {
                this.leftOver &&
                  this.leftOver.length &&
                  (this.push({ data: s2.utf8decode(this.leftOver), meta: {} }), (this.leftOver = null))
              }),
              (s2.Utf8DecodeWorker = a),
              o.inherits(l, n2),
              (l.prototype.processChunk = function (e2) {
                this.push({ data: s2.utf8encode(e2.data), meta: e2.meta })
              }),
              (s2.Utf8EncodeWorker = l)
          },
          { './nodejsUtils': 14, './stream/GenericWorker': 28, './support': 30, './utils': 32 },
        ],
        32: [
          function (e, t2, a) {
            var o = e('./support'),
              h2 = e('./base64'),
              r = e('./nodejsUtils'),
              u = e('./external')
            function n2(e2) {
              return e2
            }
            function l(e2, t3) {
              for (var r2 = 0; r2 < e2.length; ++r2) t3[r2] = 255 & e2.charCodeAt(r2)
              return t3
            }
            e('setimmediate'),
              (a.newBlob = function (t3, r2) {
                a.checkSupport('blob')
                try {
                  return new Blob([t3], { type: r2 })
                } catch (e2) {
                  try {
                    var n3 = new (self.BlobBuilder ||
                      self.WebKitBlobBuilder ||
                      self.MozBlobBuilder ||
                      self.MSBlobBuilder)()
                    return n3.append(t3), n3.getBlob(r2)
                  } catch (e3) {
                    throw new Error("Bug : can't construct the Blob.")
                  }
                }
              })
            var i = {
              stringifyByChunk: function (e2, t3, r2) {
                var n3 = [],
                  i2 = 0,
                  s3 = e2.length
                if (s3 <= r2) return String.fromCharCode.apply(null, e2)
                for (; i2 < s3; )
                  t3 === 'array' || t3 === 'nodebuffer'
                    ? n3.push(String.fromCharCode.apply(null, e2.slice(i2, Math.min(i2 + r2, s3))))
                    : n3.push(String.fromCharCode.apply(null, e2.subarray(i2, Math.min(i2 + r2, s3)))),
                    (i2 += r2)
                return n3.join('')
              },
              stringifyByChar: function (e2) {
                for (var t3 = '', r2 = 0; r2 < e2.length; r2++) t3 += String.fromCharCode(e2[r2])
                return t3
              },
              applyCanBeUsed: {
                uint8array: (function () {
                  try {
                    return o.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1
                  } catch (e2) {
                    return false
                  }
                })(),
                nodebuffer: (function () {
                  try {
                    return o.nodebuffer && String.fromCharCode.apply(null, r.allocBuffer(1)).length === 1
                  } catch (e2) {
                    return false
                  }
                })(),
              },
            }
            function s2(e2) {
              var t3 = 65536,
                r2 = a.getTypeOf(e2),
                n3 = true
              if (
                (r2 === 'uint8array'
                  ? (n3 = i.applyCanBeUsed.uint8array)
                  : r2 === 'nodebuffer' && (n3 = i.applyCanBeUsed.nodebuffer),
                n3)
              )
                for (; 1 < t3; )
                  try {
                    return i.stringifyByChunk(e2, r2, t3)
                  } catch (e3) {
                    t3 = Math.floor(t3 / 2)
                  }
              return i.stringifyByChar(e2)
            }
            function f(e2, t3) {
              for (var r2 = 0; r2 < e2.length; r2++) t3[r2] = e2[r2]
              return t3
            }
            a.applyFromCharCode = s2
            var c = {}
            ;(c.string = {
              string: n2,
              array: function (e2) {
                return l(e2, new Array(e2.length))
              },
              arraybuffer: function (e2) {
                return c.string.uint8array(e2).buffer
              },
              uint8array: function (e2) {
                return l(e2, new Uint8Array(e2.length))
              },
              nodebuffer: function (e2) {
                return l(e2, r.allocBuffer(e2.length))
              },
            }),
              (c.array = {
                string: s2,
                array: n2,
                arraybuffer: function (e2) {
                  return new Uint8Array(e2).buffer
                },
                uint8array: function (e2) {
                  return new Uint8Array(e2)
                },
                nodebuffer: function (e2) {
                  return r.newBufferFrom(e2)
                },
              }),
              (c.arraybuffer = {
                string: function (e2) {
                  return s2(new Uint8Array(e2))
                },
                array: function (e2) {
                  return f(new Uint8Array(e2), new Array(e2.byteLength))
                },
                arraybuffer: n2,
                uint8array: function (e2) {
                  return new Uint8Array(e2)
                },
                nodebuffer: function (e2) {
                  return r.newBufferFrom(new Uint8Array(e2))
                },
              }),
              (c.uint8array = {
                string: s2,
                array: function (e2) {
                  return f(e2, new Array(e2.length))
                },
                arraybuffer: function (e2) {
                  return e2.buffer
                },
                uint8array: n2,
                nodebuffer: function (e2) {
                  return r.newBufferFrom(e2)
                },
              }),
              (c.nodebuffer = {
                string: s2,
                array: function (e2) {
                  return f(e2, new Array(e2.length))
                },
                arraybuffer: function (e2) {
                  return c.nodebuffer.uint8array(e2).buffer
                },
                uint8array: function (e2) {
                  return f(e2, new Uint8Array(e2.length))
                },
                nodebuffer: n2,
              }),
              (a.transformTo = function (e2, t3) {
                if (((t3 = t3 || ''), !e2)) return t3
                a.checkSupport(e2)
                var r2 = a.getTypeOf(t3)
                return c[r2][e2](t3)
              }),
              (a.resolve = function (e2) {
                for (var t3 = e2.split('/'), r2 = [], n3 = 0; n3 < t3.length; n3++) {
                  var i2 = t3[n3]
                  i2 === '.' ||
                    (i2 === '' && n3 !== 0 && n3 !== t3.length - 1) ||
                    (i2 === '..' ? r2.pop() : r2.push(i2))
                }
                return r2.join('/')
              }),
              (a.getTypeOf = function (e2) {
                return typeof e2 == 'string'
                  ? 'string'
                  : Object.prototype.toString.call(e2) === '[object Array]'
                  ? 'array'
                  : o.nodebuffer && r.isBuffer(e2)
                  ? 'nodebuffer'
                  : o.uint8array && e2 instanceof Uint8Array
                  ? 'uint8array'
                  : o.arraybuffer && e2 instanceof ArrayBuffer
                  ? 'arraybuffer'
                  : void 0
              }),
              (a.checkSupport = function (e2) {
                if (!o[e2.toLowerCase()]) throw new Error(e2 + ' is not supported by this platform')
              }),
              (a.MAX_VALUE_16BITS = 65535),
              (a.MAX_VALUE_32BITS = -1),
              (a.pretty = function (e2) {
                var t3,
                  r2,
                  n3 = ''
                for (r2 = 0; r2 < (e2 || '').length; r2++)
                  n3 += '\\x' + ((t3 = e2.charCodeAt(r2)) < 16 ? '0' : '') + t3.toString(16).toUpperCase()
                return n3
              }),
              (a.delay = function (e2, t3, r2) {
                setImmediate(function () {
                  e2.apply(r2 || null, t3 || [])
                })
              }),
              (a.inherits = function (e2, t3) {
                function r2() {}
                ;(r2.prototype = t3.prototype), (e2.prototype = new r2())
              }),
              (a.extend = function () {
                var e2,
                  t3,
                  r2 = {}
                for (e2 = 0; e2 < arguments.length; e2++)
                  for (t3 in arguments[e2])
                    arguments[e2].hasOwnProperty(t3) && r2[t3] === void 0 && (r2[t3] = arguments[e2][t3])
                return r2
              }),
              (a.prepareContent = function (r2, e2, n3, i2, s3) {
                return u.Promise.resolve(e2)
                  .then(function (n4) {
                    return o.blob &&
                      (n4 instanceof Blob ||
                        ['[object File]', '[object Blob]'].indexOf(Object.prototype.toString.call(n4)) !== -1) &&
                      typeof FileReader != 'undefined'
                      ? new u.Promise(function (t3, r3) {
                          var e3 = new FileReader()
                          ;(e3.onload = function (e4) {
                            t3(e4.target.result)
                          }),
                            (e3.onerror = function (e4) {
                              r3(e4.target.error)
                            }),
                            e3.readAsArrayBuffer(n4)
                        })
                      : n4
                  })
                  .then(function (e3) {
                    var t3 = a.getTypeOf(e3)
                    return t3
                      ? (t3 === 'arraybuffer'
                          ? (e3 = a.transformTo('uint8array', e3))
                          : t3 === 'string' &&
                            (s3
                              ? (e3 = h2.decode(e3))
                              : n3 &&
                                i2 !== true &&
                                (e3 = (function (e4) {
                                  return l(e4, o.uint8array ? new Uint8Array(e4.length) : new Array(e4.length))
                                })(e3))),
                        e3)
                      : u.Promise.reject(
                          new Error(
                            "Can't read the data of '" +
                              r2 +
                              "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"
                          )
                        )
                  })
              })
          },
          { './base64': 1, './external': 6, './nodejsUtils': 14, './support': 30, setimmediate: 54 },
        ],
        33: [
          function (e, t2, r) {
            var n2 = e('./reader/readerFor'),
              i = e('./utils'),
              s2 = e('./signature'),
              a = e('./zipEntry'),
              o = (e('./utf8'), e('./support'))
            function h2(e2) {
              ;(this.files = []), (this.loadOptions = e2)
            }
            ;(h2.prototype = {
              checkSignature: function (e2) {
                if (!this.reader.readAndCheckSignature(e2)) {
                  this.reader.index -= 4
                  var t3 = this.reader.readString(4)
                  throw new Error(
                    'Corrupted zip or bug: unexpected signature (' + i.pretty(t3) + ', expected ' + i.pretty(e2) + ')'
                  )
                }
              },
              isSignature: function (e2, t3) {
                var r2 = this.reader.index
                this.reader.setIndex(e2)
                var n3 = this.reader.readString(4) === t3
                return this.reader.setIndex(r2), n3
              },
              readBlockEndOfCentral: function () {
                ;(this.diskNumber = this.reader.readInt(2)),
                  (this.diskWithCentralDirStart = this.reader.readInt(2)),
                  (this.centralDirRecordsOnThisDisk = this.reader.readInt(2)),
                  (this.centralDirRecords = this.reader.readInt(2)),
                  (this.centralDirSize = this.reader.readInt(4)),
                  (this.centralDirOffset = this.reader.readInt(4)),
                  (this.zipCommentLength = this.reader.readInt(2))
                var e2 = this.reader.readData(this.zipCommentLength),
                  t3 = o.uint8array ? 'uint8array' : 'array',
                  r2 = i.transformTo(t3, e2)
                this.zipComment = this.loadOptions.decodeFileName(r2)
              },
              readBlockZip64EndOfCentral: function () {
                ;(this.zip64EndOfCentralSize = this.reader.readInt(8)),
                  this.reader.skip(4),
                  (this.diskNumber = this.reader.readInt(4)),
                  (this.diskWithCentralDirStart = this.reader.readInt(4)),
                  (this.centralDirRecordsOnThisDisk = this.reader.readInt(8)),
                  (this.centralDirRecords = this.reader.readInt(8)),
                  (this.centralDirSize = this.reader.readInt(8)),
                  (this.centralDirOffset = this.reader.readInt(8)),
                  (this.zip64ExtensibleData = {})
                for (var e2, t3, r2, n3 = this.zip64EndOfCentralSize - 44; 0 < n3; )
                  (e2 = this.reader.readInt(2)),
                    (t3 = this.reader.readInt(4)),
                    (r2 = this.reader.readData(t3)),
                    (this.zip64ExtensibleData[e2] = { id: e2, length: t3, value: r2 })
              },
              readBlockZip64EndOfCentralLocator: function () {
                if (
                  ((this.diskWithZip64CentralDirStart = this.reader.readInt(4)),
                  (this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8)),
                  (this.disksCount = this.reader.readInt(4)),
                  1 < this.disksCount)
                )
                  throw new Error('Multi-volumes zip are not supported')
              },
              readLocalFiles: function () {
                var e2, t3
                for (e2 = 0; e2 < this.files.length; e2++)
                  (t3 = this.files[e2]),
                    this.reader.setIndex(t3.localHeaderOffset),
                    this.checkSignature(s2.LOCAL_FILE_HEADER),
                    t3.readLocalPart(this.reader),
                    t3.handleUTF8(),
                    t3.processAttributes()
              },
              readCentralDir: function () {
                var e2
                for (
                  this.reader.setIndex(this.centralDirOffset);
                  this.reader.readAndCheckSignature(s2.CENTRAL_FILE_HEADER);

                )
                  (e2 = new a({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader),
                    this.files.push(e2)
                if (
                  this.centralDirRecords !== this.files.length &&
                  this.centralDirRecords !== 0 &&
                  this.files.length === 0
                )
                  throw new Error(
                    'Corrupted zip or bug: expected ' +
                      this.centralDirRecords +
                      ' records in central dir, got ' +
                      this.files.length
                  )
              },
              readEndOfCentral: function () {
                var e2 = this.reader.lastIndexOfSignature(s2.CENTRAL_DIRECTORY_END)
                if (e2 < 0)
                  throw !this.isSignature(0, s2.LOCAL_FILE_HEADER)
                    ? new Error(
                        "Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html"
                      )
                    : new Error("Corrupted zip: can't find end of central directory")
                this.reader.setIndex(e2)
                var t3 = e2
                if (
                  (this.checkSignature(s2.CENTRAL_DIRECTORY_END),
                  this.readBlockEndOfCentral(),
                  this.diskNumber === i.MAX_VALUE_16BITS ||
                    this.diskWithCentralDirStart === i.MAX_VALUE_16BITS ||
                    this.centralDirRecordsOnThisDisk === i.MAX_VALUE_16BITS ||
                    this.centralDirRecords === i.MAX_VALUE_16BITS ||
                    this.centralDirSize === i.MAX_VALUE_32BITS ||
                    this.centralDirOffset === i.MAX_VALUE_32BITS)
                ) {
                  if (
                    ((this.zip64 = true),
                    (e2 = this.reader.lastIndexOfSignature(s2.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0)
                  )
                    throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator")
                  if (
                    (this.reader.setIndex(e2),
                    this.checkSignature(s2.ZIP64_CENTRAL_DIRECTORY_LOCATOR),
                    this.readBlockZip64EndOfCentralLocator(),
                    !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, s2.ZIP64_CENTRAL_DIRECTORY_END) &&
                      ((this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(
                        s2.ZIP64_CENTRAL_DIRECTORY_END
                      )),
                      this.relativeOffsetEndOfZip64CentralDir < 0))
                  )
                    throw new Error("Corrupted zip: can't find the ZIP64 end of central directory")
                  this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir),
                    this.checkSignature(s2.ZIP64_CENTRAL_DIRECTORY_END),
                    this.readBlockZip64EndOfCentral()
                }
                var r2 = this.centralDirOffset + this.centralDirSize
                this.zip64 && ((r2 += 20), (r2 += 12 + this.zip64EndOfCentralSize))
                var n3 = t3 - r2
                if (0 < n3) this.isSignature(t3, s2.CENTRAL_FILE_HEADER) || (this.reader.zero = n3)
                else if (n3 < 0) throw new Error('Corrupted zip: missing ' + Math.abs(n3) + ' bytes.')
              },
              prepareReader: function (e2) {
                this.reader = n2(e2)
              },
              load: function (e2) {
                this.prepareReader(e2), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles()
              },
            }),
              (t2.exports = h2)
          },
          {
            './reader/readerFor': 22,
            './signature': 23,
            './support': 30,
            './utf8': 31,
            './utils': 32,
            './zipEntry': 34,
          },
        ],
        34: [
          function (e, t2, r) {
            var n2 = e('./reader/readerFor'),
              s2 = e('./utils'),
              i = e('./compressedObject'),
              a = e('./crc32'),
              o = e('./utf8'),
              h2 = e('./compressions'),
              u = e('./support')
            function l(e2, t3) {
              ;(this.options = e2), (this.loadOptions = t3)
            }
            ;(l.prototype = {
              isEncrypted: function () {
                return (1 & this.bitFlag) == 1
              },
              useUTF8: function () {
                return (2048 & this.bitFlag) == 2048
              },
              readLocalPart: function (e2) {
                var t3, r2
                if (
                  (e2.skip(22),
                  (this.fileNameLength = e2.readInt(2)),
                  (r2 = e2.readInt(2)),
                  (this.fileName = e2.readData(this.fileNameLength)),
                  e2.skip(r2),
                  this.compressedSize === -1 || this.uncompressedSize === -1)
                )
                  throw new Error(
                    "Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)"
                  )
                if (
                  (t3 = (function (e3) {
                    for (var t4 in h2) if (h2.hasOwnProperty(t4) && h2[t4].magic === e3) return h2[t4]
                    return null
                  })(this.compressionMethod)) === null
                )
                  throw new Error(
                    'Corrupted zip : compression ' +
                      s2.pretty(this.compressionMethod) +
                      ' unknown (inner file : ' +
                      s2.transformTo('string', this.fileName) +
                      ')'
                  )
                this.decompressed = new i(
                  this.compressedSize,
                  this.uncompressedSize,
                  this.crc32,
                  t3,
                  e2.readData(this.compressedSize)
                )
              },
              readCentralPart: function (e2) {
                ;(this.versionMadeBy = e2.readInt(2)),
                  e2.skip(2),
                  (this.bitFlag = e2.readInt(2)),
                  (this.compressionMethod = e2.readString(2)),
                  (this.date = e2.readDate()),
                  (this.crc32 = e2.readInt(4)),
                  (this.compressedSize = e2.readInt(4)),
                  (this.uncompressedSize = e2.readInt(4))
                var t3 = e2.readInt(2)
                if (
                  ((this.extraFieldsLength = e2.readInt(2)),
                  (this.fileCommentLength = e2.readInt(2)),
                  (this.diskNumberStart = e2.readInt(2)),
                  (this.internalFileAttributes = e2.readInt(2)),
                  (this.externalFileAttributes = e2.readInt(4)),
                  (this.localHeaderOffset = e2.readInt(4)),
                  this.isEncrypted())
                )
                  throw new Error('Encrypted zip are not supported')
                e2.skip(t3),
                  this.readExtraFields(e2),
                  this.parseZIP64ExtraField(e2),
                  (this.fileComment = e2.readData(this.fileCommentLength))
              },
              processAttributes: function () {
                ;(this.unixPermissions = null), (this.dosPermissions = null)
                var e2 = this.versionMadeBy >> 8
                ;(this.dir = !!(16 & this.externalFileAttributes)),
                  e2 == 0 && (this.dosPermissions = 63 & this.externalFileAttributes),
                  e2 == 3 && (this.unixPermissions = (this.externalFileAttributes >> 16) & 65535),
                  this.dir || this.fileNameStr.slice(-1) !== '/' || (this.dir = true)
              },
              parseZIP64ExtraField: function (e2) {
                if (this.extraFields[1]) {
                  var t3 = n2(this.extraFields[1].value)
                  this.uncompressedSize === s2.MAX_VALUE_32BITS && (this.uncompressedSize = t3.readInt(8)),
                    this.compressedSize === s2.MAX_VALUE_32BITS && (this.compressedSize = t3.readInt(8)),
                    this.localHeaderOffset === s2.MAX_VALUE_32BITS && (this.localHeaderOffset = t3.readInt(8)),
                    this.diskNumberStart === s2.MAX_VALUE_32BITS && (this.diskNumberStart = t3.readInt(4))
                }
              },
              readExtraFields: function (e2) {
                var t3,
                  r2,
                  n3,
                  i2 = e2.index + this.extraFieldsLength
                for (this.extraFields || (this.extraFields = {}); e2.index + 4 < i2; )
                  (t3 = e2.readInt(2)),
                    (r2 = e2.readInt(2)),
                    (n3 = e2.readData(r2)),
                    (this.extraFields[t3] = { id: t3, length: r2, value: n3 })
                e2.setIndex(i2)
              },
              handleUTF8: function () {
                var e2 = u.uint8array ? 'uint8array' : 'array'
                if (this.useUTF8())
                  (this.fileNameStr = o.utf8decode(this.fileName)),
                    (this.fileCommentStr = o.utf8decode(this.fileComment))
                else {
                  var t3 = this.findExtraFieldUnicodePath()
                  if (t3 !== null) this.fileNameStr = t3
                  else {
                    var r2 = s2.transformTo(e2, this.fileName)
                    this.fileNameStr = this.loadOptions.decodeFileName(r2)
                  }
                  var n3 = this.findExtraFieldUnicodeComment()
                  if (n3 !== null) this.fileCommentStr = n3
                  else {
                    var i2 = s2.transformTo(e2, this.fileComment)
                    this.fileCommentStr = this.loadOptions.decodeFileName(i2)
                  }
                }
              },
              findExtraFieldUnicodePath: function () {
                var e2 = this.extraFields[28789]
                if (e2) {
                  var t3 = n2(e2.value)
                  return t3.readInt(1) !== 1
                    ? null
                    : a(this.fileName) !== t3.readInt(4)
                    ? null
                    : o.utf8decode(t3.readData(e2.length - 5))
                }
                return null
              },
              findExtraFieldUnicodeComment: function () {
                var e2 = this.extraFields[25461]
                if (e2) {
                  var t3 = n2(e2.value)
                  return t3.readInt(1) !== 1
                    ? null
                    : a(this.fileComment) !== t3.readInt(4)
                    ? null
                    : o.utf8decode(t3.readData(e2.length - 5))
                }
                return null
              },
            }),
              (t2.exports = l)
          },
          {
            './compressedObject': 2,
            './compressions': 3,
            './crc32': 4,
            './reader/readerFor': 22,
            './support': 30,
            './utf8': 31,
            './utils': 32,
          },
        ],
        35: [
          function (e, t2, r) {
            function n2(e2, t3, r2) {
              ;(this.name = e2),
                (this.dir = r2.dir),
                (this.date = r2.date),
                (this.comment = r2.comment),
                (this.unixPermissions = r2.unixPermissions),
                (this.dosPermissions = r2.dosPermissions),
                (this._data = t3),
                (this._dataBinary = r2.binary),
                (this.options = { compression: r2.compression, compressionOptions: r2.compressionOptions })
            }
            var s2 = e('./stream/StreamHelper'),
              i = e('./stream/DataWorker'),
              a = e('./utf8'),
              o = e('./compressedObject'),
              h2 = e('./stream/GenericWorker')
            n2.prototype = {
              internalStream: function (e2) {
                var t3 = null,
                  r2 = 'string'
                try {
                  if (!e2) throw new Error('No output type specified.')
                  var n3 = (r2 = e2.toLowerCase()) === 'string' || r2 === 'text'
                  ;(r2 !== 'binarystring' && r2 !== 'text') || (r2 = 'string'), (t3 = this._decompressWorker())
                  var i2 = !this._dataBinary
                  i2 && !n3 && (t3 = t3.pipe(new a.Utf8EncodeWorker())),
                    !i2 && n3 && (t3 = t3.pipe(new a.Utf8DecodeWorker()))
                } catch (e3) {
                  ;(t3 = new h2('error')).error(e3)
                }
                return new s2(t3, r2, '')
              },
              async: function (e2, t3) {
                return this.internalStream(e2).accumulate(t3)
              },
              nodeStream: function (e2, t3) {
                return this.internalStream(e2 || 'nodebuffer').toNodejsStream(t3)
              },
              _compressWorker: function (e2, t3) {
                if (this._data instanceof o && this._data.compression.magic === e2.magic)
                  return this._data.getCompressedWorker()
                var r2 = this._decompressWorker()
                return this._dataBinary || (r2 = r2.pipe(new a.Utf8EncodeWorker())), o.createWorkerFrom(r2, e2, t3)
              },
              _decompressWorker: function () {
                return this._data instanceof o
                  ? this._data.getContentWorker()
                  : this._data instanceof h2
                  ? this._data
                  : new i(this._data)
              },
            }
            for (
              var u = ['asText', 'asBinary', 'asNodeBuffer', 'asUint8Array', 'asArrayBuffer'],
                l = function () {
                  throw new Error('This method has been removed in JSZip 3.0, please check the upgrade guide.')
                },
                f = 0;
              f < u.length;
              f++
            )
              n2.prototype[u[f]] = l
            t2.exports = n2
          },
          {
            './compressedObject': 2,
            './stream/DataWorker': 27,
            './stream/GenericWorker': 28,
            './stream/StreamHelper': 29,
            './utf8': 31,
          },
        ],
        36: [
          function (e, l, t2) {
            ;(function (t3) {
              var r,
                n2,
                e2 = t3.MutationObserver || t3.WebKitMutationObserver
              if (e2) {
                var i = 0,
                  s2 = new e2(u),
                  a = t3.document.createTextNode('')
                s2.observe(a, { characterData: true }),
                  (r = function () {
                    a.data = i = ++i % 2
                  })
              } else if (t3.setImmediate || t3.MessageChannel === void 0)
                r =
                  'document' in t3 && 'onreadystatechange' in t3.document.createElement('script')
                    ? function () {
                        var e3 = t3.document.createElement('script')
                        ;(e3.onreadystatechange = function () {
                          u(), (e3.onreadystatechange = null), e3.parentNode.removeChild(e3), (e3 = null)
                        }),
                          t3.document.documentElement.appendChild(e3)
                      }
                    : function () {
                        setTimeout(u, 0)
                      }
              else {
                var o = new t3.MessageChannel()
                ;(o.port1.onmessage = u),
                  (r = function () {
                    o.port2.postMessage(0)
                  })
              }
              var h2 = []
              function u() {
                var e3, t4
                n2 = true
                for (var r2 = h2.length; r2; ) {
                  for (t4 = h2, h2 = [], e3 = -1; ++e3 < r2; ) t4[e3]()
                  r2 = h2.length
                }
                n2 = false
              }
              l.exports = function (e3) {
                h2.push(e3) !== 1 || n2 || r()
              }
            }.call(
              this,
              typeof commonjsGlobal != 'undefined'
                ? commonjsGlobal
                : typeof self != 'undefined'
                ? self
                : typeof window != 'undefined'
                ? window
                : {}
            ))
          },
          {},
        ],
        37: [
          function (e, t2, r) {
            var i = e('immediate')
            function u() {}
            var l = {},
              s2 = ['REJECTED'],
              a = ['FULFILLED'],
              n2 = ['PENDING']
            function o(e2) {
              if (typeof e2 != 'function') throw new TypeError('resolver must be a function')
              ;(this.state = n2), (this.queue = []), (this.outcome = void 0), e2 !== u && d2(this, e2)
            }
            function h2(e2, t3, r2) {
              ;(this.promise = e2),
                typeof t3 == 'function' && ((this.onFulfilled = t3), (this.callFulfilled = this.otherCallFulfilled)),
                typeof r2 == 'function' && ((this.onRejected = r2), (this.callRejected = this.otherCallRejected))
            }
            function f(t3, r2, n3) {
              i(function () {
                var e2
                try {
                  e2 = r2(n3)
                } catch (e3) {
                  return l.reject(t3, e3)
                }
                e2 === t3 ? l.reject(t3, new TypeError('Cannot resolve promise with itself')) : l.resolve(t3, e2)
              })
            }
            function c(e2) {
              var t3 = e2 && e2.then
              if (e2 && (typeof e2 == 'object' || typeof e2 == 'function') && typeof t3 == 'function')
                return function () {
                  t3.apply(e2, arguments)
                }
            }
            function d2(t3, e2) {
              var r2 = false
              function n3(e3) {
                r2 || ((r2 = true), l.reject(t3, e3))
              }
              function i2(e3) {
                r2 || ((r2 = true), l.resolve(t3, e3))
              }
              var s3 = p(function () {
                e2(i2, n3)
              })
              s3.status === 'error' && n3(s3.value)
            }
            function p(e2, t3) {
              var r2 = {}
              try {
                ;(r2.value = e2(t3)), (r2.status = 'success')
              } catch (e3) {
                ;(r2.status = 'error'), (r2.value = e3)
              }
              return r2
            }
            ;((t2.exports = o).prototype.finally = function (t3) {
              if (typeof t3 != 'function') return this
              var r2 = this.constructor
              return this.then(
                function (e2) {
                  return r2.resolve(t3()).then(function () {
                    return e2
                  })
                },
                function (e2) {
                  return r2.resolve(t3()).then(function () {
                    throw e2
                  })
                }
              )
            }),
              (o.prototype.catch = function (e2) {
                return this.then(null, e2)
              }),
              (o.prototype.then = function (e2, t3) {
                if ((typeof e2 != 'function' && this.state === a) || (typeof t3 != 'function' && this.state === s2))
                  return this
                var r2 = new this.constructor(u)
                this.state !== n2
                  ? f(r2, this.state === a ? e2 : t3, this.outcome)
                  : this.queue.push(new h2(r2, e2, t3))
                return r2
              }),
              (h2.prototype.callFulfilled = function (e2) {
                l.resolve(this.promise, e2)
              }),
              (h2.prototype.otherCallFulfilled = function (e2) {
                f(this.promise, this.onFulfilled, e2)
              }),
              (h2.prototype.callRejected = function (e2) {
                l.reject(this.promise, e2)
              }),
              (h2.prototype.otherCallRejected = function (e2) {
                f(this.promise, this.onRejected, e2)
              }),
              (l.resolve = function (e2, t3) {
                var r2 = p(c, t3)
                if (r2.status === 'error') return l.reject(e2, r2.value)
                var n3 = r2.value
                if (n3) d2(e2, n3)
                else {
                  ;(e2.state = a), (e2.outcome = t3)
                  for (var i2 = -1, s3 = e2.queue.length; ++i2 < s3; ) e2.queue[i2].callFulfilled(t3)
                }
                return e2
              }),
              (l.reject = function (e2, t3) {
                ;(e2.state = s2), (e2.outcome = t3)
                for (var r2 = -1, n3 = e2.queue.length; ++r2 < n3; ) e2.queue[r2].callRejected(t3)
                return e2
              }),
              (o.resolve = function (e2) {
                if (e2 instanceof this) return e2
                return l.resolve(new this(u), e2)
              }),
              (o.reject = function (e2) {
                var t3 = new this(u)
                return l.reject(t3, e2)
              }),
              (o.all = function (e2) {
                var r2 = this
                if (Object.prototype.toString.call(e2) !== '[object Array]')
                  return this.reject(new TypeError('must be an array'))
                var n3 = e2.length,
                  i2 = false
                if (!n3) return this.resolve([])
                var s3 = new Array(n3),
                  a2 = 0,
                  t3 = -1,
                  o2 = new this(u)
                for (; ++t3 < n3; ) h3(e2[t3], t3)
                return o2
                function h3(e3, t4) {
                  r2.resolve(e3).then(
                    function (e4) {
                      ;(s3[t4] = e4), ++a2 !== n3 || i2 || ((i2 = true), l.resolve(o2, s3))
                    },
                    function (e4) {
                      i2 || ((i2 = true), l.reject(o2, e4))
                    }
                  )
                }
              }),
              (o.race = function (e2) {
                var t3 = this
                if (Object.prototype.toString.call(e2) !== '[object Array]')
                  return this.reject(new TypeError('must be an array'))
                var r2 = e2.length,
                  n3 = false
                if (!r2) return this.resolve([])
                var i2 = -1,
                  s3 = new this(u)
                for (; ++i2 < r2; )
                  (a2 = e2[i2]),
                    t3.resolve(a2).then(
                      function (e3) {
                        n3 || ((n3 = true), l.resolve(s3, e3))
                      },
                      function (e3) {
                        n3 || ((n3 = true), l.reject(s3, e3))
                      }
                    )
                var a2
                return s3
              })
          },
          { immediate: 36 },
        ],
        38: [
          function (e, t2, r) {
            var n2 = {}
            ;(0, e('./lib/utils/common').assign)(n2, e('./lib/deflate'), e('./lib/inflate'), e('./lib/zlib/constants')),
              (t2.exports = n2)
          },
          { './lib/deflate': 39, './lib/inflate': 40, './lib/utils/common': 41, './lib/zlib/constants': 44 },
        ],
        39: [
          function (e, t2, r) {
            var a = e('./zlib/deflate'),
              o = e('./utils/common'),
              h2 = e('./utils/strings'),
              i = e('./zlib/messages'),
              s2 = e('./zlib/zstream'),
              u = Object.prototype.toString,
              l = 0,
              f = -1,
              c = 0,
              d2 = 8
            function p(e2) {
              if (!(this instanceof p)) return new p(e2)
              this.options = o.assign(
                { level: f, method: d2, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: c, to: '' },
                e2 || {}
              )
              var t3 = this.options
              t3.raw && 0 < t3.windowBits
                ? (t3.windowBits = -t3.windowBits)
                : t3.gzip && 0 < t3.windowBits && t3.windowBits < 16 && (t3.windowBits += 16),
                (this.err = 0),
                (this.msg = ''),
                (this.ended = false),
                (this.chunks = []),
                (this.strm = new s2()),
                (this.strm.avail_out = 0)
              var r2 = a.deflateInit2(this.strm, t3.level, t3.method, t3.windowBits, t3.memLevel, t3.strategy)
              if (r2 !== l) throw new Error(i[r2])
              if ((t3.header && a.deflateSetHeader(this.strm, t3.header), t3.dictionary)) {
                var n3
                if (
                  ((n3 =
                    typeof t3.dictionary == 'string'
                      ? h2.string2buf(t3.dictionary)
                      : u.call(t3.dictionary) === '[object ArrayBuffer]'
                      ? new Uint8Array(t3.dictionary)
                      : t3.dictionary),
                  (r2 = a.deflateSetDictionary(this.strm, n3)) !== l)
                )
                  throw new Error(i[r2])
                this._dict_set = true
              }
            }
            function n2(e2, t3) {
              var r2 = new p(t3)
              if ((r2.push(e2, true), r2.err)) throw r2.msg || i[r2.err]
              return r2.result
            }
            ;(p.prototype.push = function (e2, t3) {
              var r2,
                n3,
                i2 = this.strm,
                s3 = this.options.chunkSize
              if (this.ended) return false
              ;(n3 = t3 === ~~t3 ? t3 : t3 === true ? 4 : 0),
                typeof e2 == 'string'
                  ? (i2.input = h2.string2buf(e2))
                  : u.call(e2) === '[object ArrayBuffer]'
                  ? (i2.input = new Uint8Array(e2))
                  : (i2.input = e2),
                (i2.next_in = 0),
                (i2.avail_in = i2.input.length)
              do {
                if (
                  (i2.avail_out === 0 && ((i2.output = new o.Buf8(s3)), (i2.next_out = 0), (i2.avail_out = s3)),
                  (r2 = a.deflate(i2, n3)) !== 1 && r2 !== l)
                )
                  return this.onEnd(r2), !(this.ended = true)
                ;(i2.avail_out !== 0 && (i2.avail_in !== 0 || (n3 !== 4 && n3 !== 2))) ||
                  (this.options.to === 'string'
                    ? this.onData(h2.buf2binstring(o.shrinkBuf(i2.output, i2.next_out)))
                    : this.onData(o.shrinkBuf(i2.output, i2.next_out)))
              } while ((0 < i2.avail_in || i2.avail_out === 0) && r2 !== 1)
              return n3 === 4
                ? ((r2 = a.deflateEnd(this.strm)), this.onEnd(r2), (this.ended = true), r2 === l)
                : n3 !== 2 || (this.onEnd(l), !(i2.avail_out = 0))
            }),
              (p.prototype.onData = function (e2) {
                this.chunks.push(e2)
              }),
              (p.prototype.onEnd = function (e2) {
                e2 === l &&
                  (this.options.to === 'string'
                    ? (this.result = this.chunks.join(''))
                    : (this.result = o.flattenChunks(this.chunks))),
                  (this.chunks = []),
                  (this.err = e2),
                  (this.msg = this.strm.msg)
              }),
              (r.Deflate = p),
              (r.deflate = n2),
              (r.deflateRaw = function (e2, t3) {
                return ((t3 = t3 || {}).raw = true), n2(e2, t3)
              }),
              (r.gzip = function (e2, t3) {
                return ((t3 = t3 || {}).gzip = true), n2(e2, t3)
              })
          },
          {
            './utils/common': 41,
            './utils/strings': 42,
            './zlib/deflate': 46,
            './zlib/messages': 51,
            './zlib/zstream': 53,
          },
        ],
        40: [
          function (e, t2, r) {
            var c = e('./zlib/inflate'),
              d2 = e('./utils/common'),
              p = e('./utils/strings'),
              m2 = e('./zlib/constants'),
              n2 = e('./zlib/messages'),
              i = e('./zlib/zstream'),
              s2 = e('./zlib/gzheader'),
              _2 = Object.prototype.toString
            function a(e2) {
              if (!(this instanceof a)) return new a(e2)
              this.options = d2.assign({ chunkSize: 16384, windowBits: 0, to: '' }, e2 || {})
              var t3 = this.options
              t3.raw &&
                0 <= t3.windowBits &&
                t3.windowBits < 16 &&
                ((t3.windowBits = -t3.windowBits), t3.windowBits === 0 && (t3.windowBits = -15)),
                !(0 <= t3.windowBits && t3.windowBits < 16) || (e2 && e2.windowBits) || (t3.windowBits += 32),
                15 < t3.windowBits && t3.windowBits < 48 && (15 & t3.windowBits) == 0 && (t3.windowBits |= 15),
                (this.err = 0),
                (this.msg = ''),
                (this.ended = false),
                (this.chunks = []),
                (this.strm = new i()),
                (this.strm.avail_out = 0)
              var r2 = c.inflateInit2(this.strm, t3.windowBits)
              if (r2 !== m2.Z_OK) throw new Error(n2[r2])
              ;(this.header = new s2()), c.inflateGetHeader(this.strm, this.header)
            }
            function o(e2, t3) {
              var r2 = new a(t3)
              if ((r2.push(e2, true), r2.err)) throw r2.msg || n2[r2.err]
              return r2.result
            }
            ;(a.prototype.push = function (e2, t3) {
              var r2,
                n3,
                i2,
                s3,
                a2,
                o2,
                h2 = this.strm,
                u = this.options.chunkSize,
                l = this.options.dictionary,
                f = false
              if (this.ended) return false
              ;(n3 = t3 === ~~t3 ? t3 : t3 === true ? m2.Z_FINISH : m2.Z_NO_FLUSH),
                typeof e2 == 'string'
                  ? (h2.input = p.binstring2buf(e2))
                  : _2.call(e2) === '[object ArrayBuffer]'
                  ? (h2.input = new Uint8Array(e2))
                  : (h2.input = e2),
                (h2.next_in = 0),
                (h2.avail_in = h2.input.length)
              do {
                if (
                  (h2.avail_out === 0 && ((h2.output = new d2.Buf8(u)), (h2.next_out = 0), (h2.avail_out = u)),
                  (r2 = c.inflate(h2, m2.Z_NO_FLUSH)) === m2.Z_NEED_DICT &&
                    l &&
                    ((o2 =
                      typeof l == 'string'
                        ? p.string2buf(l)
                        : _2.call(l) === '[object ArrayBuffer]'
                        ? new Uint8Array(l)
                        : l),
                    (r2 = c.inflateSetDictionary(this.strm, o2))),
                  r2 === m2.Z_BUF_ERROR && f === true && ((r2 = m2.Z_OK), (f = false)),
                  r2 !== m2.Z_STREAM_END && r2 !== m2.Z_OK)
                )
                  return this.onEnd(r2), !(this.ended = true)
                h2.next_out &&
                  ((h2.avail_out !== 0 &&
                    r2 !== m2.Z_STREAM_END &&
                    (h2.avail_in !== 0 || (n3 !== m2.Z_FINISH && n3 !== m2.Z_SYNC_FLUSH))) ||
                    (this.options.to === 'string'
                      ? ((i2 = p.utf8border(h2.output, h2.next_out)),
                        (s3 = h2.next_out - i2),
                        (a2 = p.buf2string(h2.output, i2)),
                        (h2.next_out = s3),
                        (h2.avail_out = u - s3),
                        s3 && d2.arraySet(h2.output, h2.output, i2, s3, 0),
                        this.onData(a2))
                      : this.onData(d2.shrinkBuf(h2.output, h2.next_out)))),
                  h2.avail_in === 0 && h2.avail_out === 0 && (f = true)
              } while ((0 < h2.avail_in || h2.avail_out === 0) && r2 !== m2.Z_STREAM_END)
              return (
                r2 === m2.Z_STREAM_END && (n3 = m2.Z_FINISH),
                n3 === m2.Z_FINISH
                  ? ((r2 = c.inflateEnd(this.strm)), this.onEnd(r2), (this.ended = true), r2 === m2.Z_OK)
                  : n3 !== m2.Z_SYNC_FLUSH || (this.onEnd(m2.Z_OK), !(h2.avail_out = 0))
              )
            }),
              (a.prototype.onData = function (e2) {
                this.chunks.push(e2)
              }),
              (a.prototype.onEnd = function (e2) {
                e2 === m2.Z_OK &&
                  (this.options.to === 'string'
                    ? (this.result = this.chunks.join(''))
                    : (this.result = d2.flattenChunks(this.chunks))),
                  (this.chunks = []),
                  (this.err = e2),
                  (this.msg = this.strm.msg)
              }),
              (r.Inflate = a),
              (r.inflate = o),
              (r.inflateRaw = function (e2, t3) {
                return ((t3 = t3 || {}).raw = true), o(e2, t3)
              }),
              (r.ungzip = o)
          },
          {
            './utils/common': 41,
            './utils/strings': 42,
            './zlib/constants': 44,
            './zlib/gzheader': 47,
            './zlib/inflate': 49,
            './zlib/messages': 51,
            './zlib/zstream': 53,
          },
        ],
        41: [
          function (e, t2, r) {
            var n2 =
              typeof Uint8Array != 'undefined' && typeof Uint16Array != 'undefined' && typeof Int32Array != 'undefined'
            ;(r.assign = function (e2) {
              for (var t3 = Array.prototype.slice.call(arguments, 1); t3.length; ) {
                var r2 = t3.shift()
                if (r2) {
                  if (typeof r2 != 'object') throw new TypeError(r2 + 'must be non-object')
                  for (var n3 in r2) r2.hasOwnProperty(n3) && (e2[n3] = r2[n3])
                }
              }
              return e2
            }),
              (r.shrinkBuf = function (e2, t3) {
                return e2.length === t3 ? e2 : e2.subarray ? e2.subarray(0, t3) : ((e2.length = t3), e2)
              })
            var i = {
                arraySet: function (e2, t3, r2, n3, i2) {
                  if (t3.subarray && e2.subarray) e2.set(t3.subarray(r2, r2 + n3), i2)
                  else for (var s3 = 0; s3 < n3; s3++) e2[i2 + s3] = t3[r2 + s3]
                },
                flattenChunks: function (e2) {
                  var t3, r2, n3, i2, s3, a
                  for (t3 = n3 = 0, r2 = e2.length; t3 < r2; t3++) n3 += e2[t3].length
                  for (a = new Uint8Array(n3), t3 = i2 = 0, r2 = e2.length; t3 < r2; t3++)
                    (s3 = e2[t3]), a.set(s3, i2), (i2 += s3.length)
                  return a
                },
              },
              s2 = {
                arraySet: function (e2, t3, r2, n3, i2) {
                  for (var s3 = 0; s3 < n3; s3++) e2[i2 + s3] = t3[r2 + s3]
                },
                flattenChunks: function (e2) {
                  return [].concat.apply([], e2)
                },
              }
            ;(r.setTyped = function (e2) {
              e2
                ? ((r.Buf8 = Uint8Array), (r.Buf16 = Uint16Array), (r.Buf32 = Int32Array), r.assign(r, i))
                : ((r.Buf8 = Array), (r.Buf16 = Array), (r.Buf32 = Array), r.assign(r, s2))
            }),
              r.setTyped(n2)
          },
          {},
        ],
        42: [
          function (e, t2, r) {
            var h2 = e('./common'),
              i = true,
              s2 = true
            try {
              String.fromCharCode.apply(null, [0])
            } catch (e2) {
              i = false
            }
            try {
              String.fromCharCode.apply(null, new Uint8Array(1))
            } catch (e2) {
              s2 = false
            }
            for (var u = new h2.Buf8(256), n2 = 0; n2 < 256; n2++)
              u[n2] = 252 <= n2 ? 6 : 248 <= n2 ? 5 : 240 <= n2 ? 4 : 224 <= n2 ? 3 : 192 <= n2 ? 2 : 1
            function l(e2, t3) {
              if (t3 < 65537 && ((e2.subarray && s2) || (!e2.subarray && i)))
                return String.fromCharCode.apply(null, h2.shrinkBuf(e2, t3))
              for (var r2 = '', n3 = 0; n3 < t3; n3++) r2 += String.fromCharCode(e2[n3])
              return r2
            }
            ;(u[254] = u[254] = 1),
              (r.string2buf = function (e2) {
                var t3,
                  r2,
                  n3,
                  i2,
                  s3,
                  a = e2.length,
                  o = 0
                for (i2 = 0; i2 < a; i2++)
                  (64512 & (r2 = e2.charCodeAt(i2))) == 55296 &&
                    i2 + 1 < a &&
                    (64512 & (n3 = e2.charCodeAt(i2 + 1))) == 56320 &&
                    ((r2 = 65536 + ((r2 - 55296) << 10) + (n3 - 56320)), i2++),
                    (o += r2 < 128 ? 1 : r2 < 2048 ? 2 : r2 < 65536 ? 3 : 4)
                for (t3 = new h2.Buf8(o), i2 = s3 = 0; s3 < o; i2++)
                  (64512 & (r2 = e2.charCodeAt(i2))) == 55296 &&
                    i2 + 1 < a &&
                    (64512 & (n3 = e2.charCodeAt(i2 + 1))) == 56320 &&
                    ((r2 = 65536 + ((r2 - 55296) << 10) + (n3 - 56320)), i2++),
                    r2 < 128
                      ? (t3[s3++] = r2)
                      : (r2 < 2048
                          ? (t3[s3++] = 192 | (r2 >>> 6))
                          : (r2 < 65536
                              ? (t3[s3++] = 224 | (r2 >>> 12))
                              : ((t3[s3++] = 240 | (r2 >>> 18)), (t3[s3++] = 128 | ((r2 >>> 12) & 63))),
                            (t3[s3++] = 128 | ((r2 >>> 6) & 63))),
                        (t3[s3++] = 128 | (63 & r2)))
                return t3
              }),
              (r.buf2binstring = function (e2) {
                return l(e2, e2.length)
              }),
              (r.binstring2buf = function (e2) {
                for (var t3 = new h2.Buf8(e2.length), r2 = 0, n3 = t3.length; r2 < n3; r2++) t3[r2] = e2.charCodeAt(r2)
                return t3
              }),
              (r.buf2string = function (e2, t3) {
                var r2,
                  n3,
                  i2,
                  s3,
                  a = t3 || e2.length,
                  o = new Array(2 * a)
                for (r2 = n3 = 0; r2 < a; )
                  if ((i2 = e2[r2++]) < 128) o[n3++] = i2
                  else if (4 < (s3 = u[i2])) (o[n3++] = 65533), (r2 += s3 - 1)
                  else {
                    for (i2 &= s3 === 2 ? 31 : s3 === 3 ? 15 : 7; 1 < s3 && r2 < a; )
                      (i2 = (i2 << 6) | (63 & e2[r2++])), s3--
                    1 < s3
                      ? (o[n3++] = 65533)
                      : i2 < 65536
                      ? (o[n3++] = i2)
                      : ((i2 -= 65536), (o[n3++] = 55296 | ((i2 >> 10) & 1023)), (o[n3++] = 56320 | (1023 & i2)))
                  }
                return l(o, n3)
              }),
              (r.utf8border = function (e2, t3) {
                var r2
                for (
                  (t3 = t3 || e2.length) > e2.length && (t3 = e2.length), r2 = t3 - 1;
                  0 <= r2 && (192 & e2[r2]) == 128;

                )
                  r2--
                return r2 < 0 ? t3 : r2 === 0 ? t3 : r2 + u[e2[r2]] > t3 ? r2 : t3
              })
          },
          { './common': 41 },
        ],
        43: [
          function (e, t2, r) {
            t2.exports = function (e2, t3, r2, n2) {
              for (var i = (65535 & e2) | 0, s2 = ((e2 >>> 16) & 65535) | 0, a = 0; r2 !== 0; ) {
                for (r2 -= a = 2e3 < r2 ? 2e3 : r2; (s2 = (s2 + (i = (i + t3[n2++]) | 0)) | 0), --a; );
                ;(i %= 65521), (s2 %= 65521)
              }
              return i | (s2 << 16) | 0
            }
          },
          {},
        ],
        44: [
          function (e, t2, r) {
            t2.exports = {
              Z_NO_FLUSH: 0,
              Z_PARTIAL_FLUSH: 1,
              Z_SYNC_FLUSH: 2,
              Z_FULL_FLUSH: 3,
              Z_FINISH: 4,
              Z_BLOCK: 5,
              Z_TREES: 6,
              Z_OK: 0,
              Z_STREAM_END: 1,
              Z_NEED_DICT: 2,
              Z_ERRNO: -1,
              Z_STREAM_ERROR: -2,
              Z_DATA_ERROR: -3,
              Z_BUF_ERROR: -5,
              Z_NO_COMPRESSION: 0,
              Z_BEST_SPEED: 1,
              Z_BEST_COMPRESSION: 9,
              Z_DEFAULT_COMPRESSION: -1,
              Z_FILTERED: 1,
              Z_HUFFMAN_ONLY: 2,
              Z_RLE: 3,
              Z_FIXED: 4,
              Z_DEFAULT_STRATEGY: 0,
              Z_BINARY: 0,
              Z_TEXT: 1,
              Z_UNKNOWN: 2,
              Z_DEFLATED: 8,
            }
          },
          {},
        ],
        45: [
          function (e, t2, r) {
            var o = (function () {
              for (var e2, t3 = [], r2 = 0; r2 < 256; r2++) {
                e2 = r2
                for (var n2 = 0; n2 < 8; n2++) e2 = 1 & e2 ? 3988292384 ^ (e2 >>> 1) : e2 >>> 1
                t3[r2] = e2
              }
              return t3
            })()
            t2.exports = function (e2, t3, r2, n2) {
              var i = o,
                s2 = n2 + r2
              e2 ^= -1
              for (var a = n2; a < s2; a++) e2 = (e2 >>> 8) ^ i[255 & (e2 ^ t3[a])]
              return -1 ^ e2
            }
          },
          {},
        ],
        46: [
          function (e, t2, r) {
            var h2,
              c = e('../utils/common'),
              u = e('./trees'),
              d2 = e('./adler32'),
              p = e('./crc32'),
              n2 = e('./messages'),
              l = 0,
              f = 4,
              m2 = 0,
              _2 = -2,
              g = -1,
              b = 4,
              i = 2,
              v = 8,
              y2 = 9,
              s2 = 286,
              a = 30,
              o = 19,
              w2 = 2 * s2 + 1,
              k = 15,
              x = 3,
              S2 = 258,
              z = S2 + x + 1,
              C = 42,
              E = 113,
              A = 1,
              I = 2,
              O = 3,
              B = 4
            function R(e2, t3) {
              return (e2.msg = n2[t3]), t3
            }
            function T(e2) {
              return (e2 << 1) - (4 < e2 ? 9 : 0)
            }
            function D2(e2) {
              for (var t3 = e2.length; 0 <= --t3; ) e2[t3] = 0
            }
            function F(e2) {
              var t3 = e2.state,
                r2 = t3.pending
              r2 > e2.avail_out && (r2 = e2.avail_out),
                r2 !== 0 &&
                  (c.arraySet(e2.output, t3.pending_buf, t3.pending_out, r2, e2.next_out),
                  (e2.next_out += r2),
                  (t3.pending_out += r2),
                  (e2.total_out += r2),
                  (e2.avail_out -= r2),
                  (t3.pending -= r2),
                  t3.pending === 0 && (t3.pending_out = 0))
            }
            function N(e2, t3) {
              u._tr_flush_block(e2, 0 <= e2.block_start ? e2.block_start : -1, e2.strstart - e2.block_start, t3),
                (e2.block_start = e2.strstart),
                F(e2.strm)
            }
            function U2(e2, t3) {
              e2.pending_buf[e2.pending++] = t3
            }
            function P2(e2, t3) {
              ;(e2.pending_buf[e2.pending++] = (t3 >>> 8) & 255), (e2.pending_buf[e2.pending++] = 255 & t3)
            }
            function L2(e2, t3) {
              var r2,
                n3,
                i2 = e2.max_chain_length,
                s3 = e2.strstart,
                a2 = e2.prev_length,
                o2 = e2.nice_match,
                h3 = e2.strstart > e2.w_size - z ? e2.strstart - (e2.w_size - z) : 0,
                u2 = e2.window,
                l2 = e2.w_mask,
                f2 = e2.prev,
                c2 = e2.strstart + S2,
                d3 = u2[s3 + a2 - 1],
                p2 = u2[s3 + a2]
              e2.prev_length >= e2.good_match && (i2 >>= 2), o2 > e2.lookahead && (o2 = e2.lookahead)
              do {
                if (
                  u2[(r2 = t3) + a2] === p2 &&
                  u2[r2 + a2 - 1] === d3 &&
                  u2[r2] === u2[s3] &&
                  u2[++r2] === u2[s3 + 1]
                ) {
                  ;(s3 += 2), r2++
                  do {} while (
                    u2[++s3] === u2[++r2] &&
                    u2[++s3] === u2[++r2] &&
                    u2[++s3] === u2[++r2] &&
                    u2[++s3] === u2[++r2] &&
                    u2[++s3] === u2[++r2] &&
                    u2[++s3] === u2[++r2] &&
                    u2[++s3] === u2[++r2] &&
                    u2[++s3] === u2[++r2] &&
                    s3 < c2
                  )
                  if (((n3 = S2 - (c2 - s3)), (s3 = c2 - S2), a2 < n3)) {
                    if (((e2.match_start = t3), o2 <= (a2 = n3))) break
                    ;(d3 = u2[s3 + a2 - 1]), (p2 = u2[s3 + a2])
                  }
                }
              } while ((t3 = f2[t3 & l2]) > h3 && --i2 != 0)
              return a2 <= e2.lookahead ? a2 : e2.lookahead
            }
            function j(e2) {
              var t3,
                r2,
                n3,
                i2,
                s3,
                a2,
                o2,
                h3,
                u2,
                l2,
                f2 = e2.w_size
              do {
                if (((i2 = e2.window_size - e2.lookahead - e2.strstart), e2.strstart >= f2 + (f2 - z))) {
                  for (
                    c.arraySet(e2.window, e2.window, f2, f2, 0),
                      e2.match_start -= f2,
                      e2.strstart -= f2,
                      e2.block_start -= f2,
                      t3 = r2 = e2.hash_size;
                    (n3 = e2.head[--t3]), (e2.head[t3] = f2 <= n3 ? n3 - f2 : 0), --r2;

                  );
                  for (t3 = r2 = f2; (n3 = e2.prev[--t3]), (e2.prev[t3] = f2 <= n3 ? n3 - f2 : 0), --r2; );
                  i2 += f2
                }
                if (e2.strm.avail_in === 0) break
                if (
                  ((a2 = e2.strm),
                  (o2 = e2.window),
                  (h3 = e2.strstart + e2.lookahead),
                  (u2 = i2),
                  (l2 = void 0),
                  (l2 = a2.avail_in),
                  u2 < l2 && (l2 = u2),
                  (r2 =
                    l2 === 0
                      ? 0
                      : ((a2.avail_in -= l2),
                        c.arraySet(o2, a2.input, a2.next_in, l2, h3),
                        a2.state.wrap === 1
                          ? (a2.adler = d2(a2.adler, o2, l2, h3))
                          : a2.state.wrap === 2 && (a2.adler = p(a2.adler, o2, l2, h3)),
                        (a2.next_in += l2),
                        (a2.total_in += l2),
                        l2)),
                  (e2.lookahead += r2),
                  e2.lookahead + e2.insert >= x)
                )
                  for (
                    s3 = e2.strstart - e2.insert,
                      e2.ins_h = e2.window[s3],
                      e2.ins_h = ((e2.ins_h << e2.hash_shift) ^ e2.window[s3 + 1]) & e2.hash_mask;
                    e2.insert &&
                    ((e2.ins_h = ((e2.ins_h << e2.hash_shift) ^ e2.window[s3 + x - 1]) & e2.hash_mask),
                    (e2.prev[s3 & e2.w_mask] = e2.head[e2.ins_h]),
                    (e2.head[e2.ins_h] = s3),
                    s3++,
                    e2.insert--,
                    !(e2.lookahead + e2.insert < x));

                  );
              } while (e2.lookahead < z && e2.strm.avail_in !== 0)
            }
            function Z(e2, t3) {
              for (var r2, n3; ; ) {
                if (e2.lookahead < z) {
                  if ((j(e2), e2.lookahead < z && t3 === l)) return A
                  if (e2.lookahead === 0) break
                }
                if (
                  ((r2 = 0),
                  e2.lookahead >= x &&
                    ((e2.ins_h = ((e2.ins_h << e2.hash_shift) ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask),
                    (r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h]),
                    (e2.head[e2.ins_h] = e2.strstart)),
                  r2 !== 0 && e2.strstart - r2 <= e2.w_size - z && (e2.match_length = L2(e2, r2)),
                  e2.match_length >= x)
                )
                  if (
                    ((n3 = u._tr_tally(e2, e2.strstart - e2.match_start, e2.match_length - x)),
                    (e2.lookahead -= e2.match_length),
                    e2.match_length <= e2.max_lazy_match && e2.lookahead >= x)
                  ) {
                    for (
                      e2.match_length--;
                      e2.strstart++,
                        (e2.ins_h = ((e2.ins_h << e2.hash_shift) ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask),
                        (r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h]),
                        (e2.head[e2.ins_h] = e2.strstart),
                        --e2.match_length != 0;

                    );
                    e2.strstart++
                  } else
                    (e2.strstart += e2.match_length),
                      (e2.match_length = 0),
                      (e2.ins_h = e2.window[e2.strstart]),
                      (e2.ins_h = ((e2.ins_h << e2.hash_shift) ^ e2.window[e2.strstart + 1]) & e2.hash_mask)
                else (n3 = u._tr_tally(e2, 0, e2.window[e2.strstart])), e2.lookahead--, e2.strstart++
                if (n3 && (N(e2, false), e2.strm.avail_out === 0)) return A
              }
              return (
                (e2.insert = e2.strstart < x - 1 ? e2.strstart : x - 1),
                t3 === f
                  ? (N(e2, true), e2.strm.avail_out === 0 ? O : B)
                  : e2.last_lit && (N(e2, false), e2.strm.avail_out === 0)
                  ? A
                  : I
              )
            }
            function W2(e2, t3) {
              for (var r2, n3, i2; ; ) {
                if (e2.lookahead < z) {
                  if ((j(e2), e2.lookahead < z && t3 === l)) return A
                  if (e2.lookahead === 0) break
                }
                if (
                  ((r2 = 0),
                  e2.lookahead >= x &&
                    ((e2.ins_h = ((e2.ins_h << e2.hash_shift) ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask),
                    (r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h]),
                    (e2.head[e2.ins_h] = e2.strstart)),
                  (e2.prev_length = e2.match_length),
                  (e2.prev_match = e2.match_start),
                  (e2.match_length = x - 1),
                  r2 !== 0 &&
                    e2.prev_length < e2.max_lazy_match &&
                    e2.strstart - r2 <= e2.w_size - z &&
                    ((e2.match_length = L2(e2, r2)),
                    e2.match_length <= 5 &&
                      (e2.strategy === 1 || (e2.match_length === x && 4096 < e2.strstart - e2.match_start)) &&
                      (e2.match_length = x - 1)),
                  e2.prev_length >= x && e2.match_length <= e2.prev_length)
                ) {
                  for (
                    i2 = e2.strstart + e2.lookahead - x,
                      n3 = u._tr_tally(e2, e2.strstart - 1 - e2.prev_match, e2.prev_length - x),
                      e2.lookahead -= e2.prev_length - 1,
                      e2.prev_length -= 2;
                    ++e2.strstart <= i2 &&
                      ((e2.ins_h = ((e2.ins_h << e2.hash_shift) ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask),
                      (r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h]),
                      (e2.head[e2.ins_h] = e2.strstart)),
                      --e2.prev_length != 0;

                  );
                  if (
                    ((e2.match_available = 0),
                    (e2.match_length = x - 1),
                    e2.strstart++,
                    n3 && (N(e2, false), e2.strm.avail_out === 0))
                  )
                    return A
                } else if (e2.match_available) {
                  if (
                    ((n3 = u._tr_tally(e2, 0, e2.window[e2.strstart - 1])) && N(e2, false),
                    e2.strstart++,
                    e2.lookahead--,
                    e2.strm.avail_out === 0)
                  )
                    return A
                } else (e2.match_available = 1), e2.strstart++, e2.lookahead--
              }
              return (
                e2.match_available && ((n3 = u._tr_tally(e2, 0, e2.window[e2.strstart - 1])), (e2.match_available = 0)),
                (e2.insert = e2.strstart < x - 1 ? e2.strstart : x - 1),
                t3 === f
                  ? (N(e2, true), e2.strm.avail_out === 0 ? O : B)
                  : e2.last_lit && (N(e2, false), e2.strm.avail_out === 0)
                  ? A
                  : I
              )
            }
            function M2(e2, t3, r2, n3, i2) {
              ;(this.good_length = e2),
                (this.max_lazy = t3),
                (this.nice_length = r2),
                (this.max_chain = n3),
                (this.func = i2)
            }
            function H2() {
              ;(this.strm = null),
                (this.status = 0),
                (this.pending_buf = null),
                (this.pending_buf_size = 0),
                (this.pending_out = 0),
                (this.pending = 0),
                (this.wrap = 0),
                (this.gzhead = null),
                (this.gzindex = 0),
                (this.method = v),
                (this.last_flush = -1),
                (this.w_size = 0),
                (this.w_bits = 0),
                (this.w_mask = 0),
                (this.window = null),
                (this.window_size = 0),
                (this.prev = null),
                (this.head = null),
                (this.ins_h = 0),
                (this.hash_size = 0),
                (this.hash_bits = 0),
                (this.hash_mask = 0),
                (this.hash_shift = 0),
                (this.block_start = 0),
                (this.match_length = 0),
                (this.prev_match = 0),
                (this.match_available = 0),
                (this.strstart = 0),
                (this.match_start = 0),
                (this.lookahead = 0),
                (this.prev_length = 0),
                (this.max_chain_length = 0),
                (this.max_lazy_match = 0),
                (this.level = 0),
                (this.strategy = 0),
                (this.good_match = 0),
                (this.nice_match = 0),
                (this.dyn_ltree = new c.Buf16(2 * w2)),
                (this.dyn_dtree = new c.Buf16(2 * (2 * a + 1))),
                (this.bl_tree = new c.Buf16(2 * (2 * o + 1))),
                D2(this.dyn_ltree),
                D2(this.dyn_dtree),
                D2(this.bl_tree),
                (this.l_desc = null),
                (this.d_desc = null),
                (this.bl_desc = null),
                (this.bl_count = new c.Buf16(k + 1)),
                (this.heap = new c.Buf16(2 * s2 + 1)),
                D2(this.heap),
                (this.heap_len = 0),
                (this.heap_max = 0),
                (this.depth = new c.Buf16(2 * s2 + 1)),
                D2(this.depth),
                (this.l_buf = 0),
                (this.lit_bufsize = 0),
                (this.last_lit = 0),
                (this.d_buf = 0),
                (this.opt_len = 0),
                (this.static_len = 0),
                (this.matches = 0),
                (this.insert = 0),
                (this.bi_buf = 0),
                (this.bi_valid = 0)
            }
            function G(e2) {
              var t3
              return e2 && e2.state
                ? ((e2.total_in = e2.total_out = 0),
                  (e2.data_type = i),
                  ((t3 = e2.state).pending = 0),
                  (t3.pending_out = 0),
                  t3.wrap < 0 && (t3.wrap = -t3.wrap),
                  (t3.status = t3.wrap ? C : E),
                  (e2.adler = t3.wrap === 2 ? 0 : 1),
                  (t3.last_flush = l),
                  u._tr_init(t3),
                  m2)
                : R(e2, _2)
            }
            function K(e2) {
              var t3 = G(e2)
              return (
                t3 === m2 &&
                  (function (e3) {
                    ;(e3.window_size = 2 * e3.w_size),
                      D2(e3.head),
                      (e3.max_lazy_match = h2[e3.level].max_lazy),
                      (e3.good_match = h2[e3.level].good_length),
                      (e3.nice_match = h2[e3.level].nice_length),
                      (e3.max_chain_length = h2[e3.level].max_chain),
                      (e3.strstart = 0),
                      (e3.block_start = 0),
                      (e3.lookahead = 0),
                      (e3.insert = 0),
                      (e3.match_length = e3.prev_length = x - 1),
                      (e3.match_available = 0),
                      (e3.ins_h = 0)
                  })(e2.state),
                t3
              )
            }
            function Y2(e2, t3, r2, n3, i2, s3) {
              if (!e2) return _2
              var a2 = 1
              if (
                (t3 === g && (t3 = 6),
                n3 < 0 ? ((a2 = 0), (n3 = -n3)) : 15 < n3 && ((a2 = 2), (n3 -= 16)),
                i2 < 1 || y2 < i2 || r2 !== v || n3 < 8 || 15 < n3 || t3 < 0 || 9 < t3 || s3 < 0 || b < s3)
              )
                return R(e2, _2)
              n3 === 8 && (n3 = 9)
              var o2 = new H2()
              return (
                ((e2.state = o2).strm = e2),
                (o2.wrap = a2),
                (o2.gzhead = null),
                (o2.w_bits = n3),
                (o2.w_size = 1 << o2.w_bits),
                (o2.w_mask = o2.w_size - 1),
                (o2.hash_bits = i2 + 7),
                (o2.hash_size = 1 << o2.hash_bits),
                (o2.hash_mask = o2.hash_size - 1),
                (o2.hash_shift = ~~((o2.hash_bits + x - 1) / x)),
                (o2.window = new c.Buf8(2 * o2.w_size)),
                (o2.head = new c.Buf16(o2.hash_size)),
                (o2.prev = new c.Buf16(o2.w_size)),
                (o2.lit_bufsize = 1 << (i2 + 6)),
                (o2.pending_buf_size = 4 * o2.lit_bufsize),
                (o2.pending_buf = new c.Buf8(o2.pending_buf_size)),
                (o2.d_buf = 1 * o2.lit_bufsize),
                (o2.l_buf = 3 * o2.lit_bufsize),
                (o2.level = t3),
                (o2.strategy = s3),
                (o2.method = r2),
                K(e2)
              )
            }
            ;(h2 = [
              new M2(0, 0, 0, 0, function (e2, t3) {
                var r2 = 65535
                for (r2 > e2.pending_buf_size - 5 && (r2 = e2.pending_buf_size - 5); ; ) {
                  if (e2.lookahead <= 1) {
                    if ((j(e2), e2.lookahead === 0 && t3 === l)) return A
                    if (e2.lookahead === 0) break
                  }
                  ;(e2.strstart += e2.lookahead), (e2.lookahead = 0)
                  var n3 = e2.block_start + r2
                  if (
                    (e2.strstart === 0 || e2.strstart >= n3) &&
                    ((e2.lookahead = e2.strstart - n3), (e2.strstart = n3), N(e2, false), e2.strm.avail_out === 0)
                  )
                    return A
                  if (e2.strstart - e2.block_start >= e2.w_size - z && (N(e2, false), e2.strm.avail_out === 0)) return A
                }
                return (
                  (e2.insert = 0),
                  t3 === f
                    ? (N(e2, true), e2.strm.avail_out === 0 ? O : B)
                    : (e2.strstart > e2.block_start && (N(e2, false), e2.strm.avail_out), A)
                )
              }),
              new M2(4, 4, 8, 4, Z),
              new M2(4, 5, 16, 8, Z),
              new M2(4, 6, 32, 32, Z),
              new M2(4, 4, 16, 16, W2),
              new M2(8, 16, 32, 32, W2),
              new M2(8, 16, 128, 128, W2),
              new M2(8, 32, 128, 256, W2),
              new M2(32, 128, 258, 1024, W2),
              new M2(32, 258, 258, 4096, W2),
            ]),
              (r.deflateInit = function (e2, t3) {
                return Y2(e2, t3, v, 15, 8, 0)
              }),
              (r.deflateInit2 = Y2),
              (r.deflateReset = K),
              (r.deflateResetKeep = G),
              (r.deflateSetHeader = function (e2, t3) {
                return e2 && e2.state ? (e2.state.wrap !== 2 ? _2 : ((e2.state.gzhead = t3), m2)) : _2
              }),
              (r.deflate = function (e2, t3) {
                var r2, n3, i2, s3
                if (!e2 || !e2.state || 5 < t3 || t3 < 0) return e2 ? R(e2, _2) : _2
                if (
                  ((n3 = e2.state), !e2.output || (!e2.input && e2.avail_in !== 0) || (n3.status === 666 && t3 !== f))
                )
                  return R(e2, e2.avail_out === 0 ? -5 : _2)
                if (((n3.strm = e2), (r2 = n3.last_flush), (n3.last_flush = t3), n3.status === C))
                  if (n3.wrap === 2)
                    (e2.adler = 0),
                      U2(n3, 31),
                      U2(n3, 139),
                      U2(n3, 8),
                      n3.gzhead
                        ? (U2(
                            n3,
                            (n3.gzhead.text ? 1 : 0) +
                              (n3.gzhead.hcrc ? 2 : 0) +
                              (n3.gzhead.extra ? 4 : 0) +
                              (n3.gzhead.name ? 8 : 0) +
                              (n3.gzhead.comment ? 16 : 0)
                          ),
                          U2(n3, 255 & n3.gzhead.time),
                          U2(n3, (n3.gzhead.time >> 8) & 255),
                          U2(n3, (n3.gzhead.time >> 16) & 255),
                          U2(n3, (n3.gzhead.time >> 24) & 255),
                          U2(n3, n3.level === 9 ? 2 : 2 <= n3.strategy || n3.level < 2 ? 4 : 0),
                          U2(n3, 255 & n3.gzhead.os),
                          n3.gzhead.extra &&
                            n3.gzhead.extra.length &&
                            (U2(n3, 255 & n3.gzhead.extra.length), U2(n3, (n3.gzhead.extra.length >> 8) & 255)),
                          n3.gzhead.hcrc && (e2.adler = p(e2.adler, n3.pending_buf, n3.pending, 0)),
                          (n3.gzindex = 0),
                          (n3.status = 69))
                        : (U2(n3, 0),
                          U2(n3, 0),
                          U2(n3, 0),
                          U2(n3, 0),
                          U2(n3, 0),
                          U2(n3, n3.level === 9 ? 2 : 2 <= n3.strategy || n3.level < 2 ? 4 : 0),
                          U2(n3, 3),
                          (n3.status = E))
                  else {
                    var a2 = (v + ((n3.w_bits - 8) << 4)) << 8
                    ;(a2 |= (2 <= n3.strategy || n3.level < 2 ? 0 : n3.level < 6 ? 1 : n3.level === 6 ? 2 : 3) << 6),
                      n3.strstart !== 0 && (a2 |= 32),
                      (a2 += 31 - (a2 % 31)),
                      (n3.status = E),
                      P2(n3, a2),
                      n3.strstart !== 0 && (P2(n3, e2.adler >>> 16), P2(n3, 65535 & e2.adler)),
                      (e2.adler = 1)
                  }
                if (n3.status === 69)
                  if (n3.gzhead.extra) {
                    for (
                      i2 = n3.pending;
                      n3.gzindex < (65535 & n3.gzhead.extra.length) &&
                      (n3.pending !== n3.pending_buf_size ||
                        (n3.gzhead.hcrc &&
                          n3.pending > i2 &&
                          (e2.adler = p(e2.adler, n3.pending_buf, n3.pending - i2, i2)),
                        F(e2),
                        (i2 = n3.pending),
                        n3.pending !== n3.pending_buf_size));

                    )
                      U2(n3, 255 & n3.gzhead.extra[n3.gzindex]), n3.gzindex++
                    n3.gzhead.hcrc && n3.pending > i2 && (e2.adler = p(e2.adler, n3.pending_buf, n3.pending - i2, i2)),
                      n3.gzindex === n3.gzhead.extra.length && ((n3.gzindex = 0), (n3.status = 73))
                  } else n3.status = 73
                if (n3.status === 73)
                  if (n3.gzhead.name) {
                    i2 = n3.pending
                    do {
                      if (
                        n3.pending === n3.pending_buf_size &&
                        (n3.gzhead.hcrc &&
                          n3.pending > i2 &&
                          (e2.adler = p(e2.adler, n3.pending_buf, n3.pending - i2, i2)),
                        F(e2),
                        (i2 = n3.pending),
                        n3.pending === n3.pending_buf_size)
                      ) {
                        s3 = 1
                        break
                      }
                      ;(s3 = n3.gzindex < n3.gzhead.name.length ? 255 & n3.gzhead.name.charCodeAt(n3.gzindex++) : 0),
                        U2(n3, s3)
                    } while (s3 !== 0)
                    n3.gzhead.hcrc && n3.pending > i2 && (e2.adler = p(e2.adler, n3.pending_buf, n3.pending - i2, i2)),
                      s3 === 0 && ((n3.gzindex = 0), (n3.status = 91))
                  } else n3.status = 91
                if (n3.status === 91)
                  if (n3.gzhead.comment) {
                    i2 = n3.pending
                    do {
                      if (
                        n3.pending === n3.pending_buf_size &&
                        (n3.gzhead.hcrc &&
                          n3.pending > i2 &&
                          (e2.adler = p(e2.adler, n3.pending_buf, n3.pending - i2, i2)),
                        F(e2),
                        (i2 = n3.pending),
                        n3.pending === n3.pending_buf_size)
                      ) {
                        s3 = 1
                        break
                      }
                      ;(s3 =
                        n3.gzindex < n3.gzhead.comment.length ? 255 & n3.gzhead.comment.charCodeAt(n3.gzindex++) : 0),
                        U2(n3, s3)
                    } while (s3 !== 0)
                    n3.gzhead.hcrc && n3.pending > i2 && (e2.adler = p(e2.adler, n3.pending_buf, n3.pending - i2, i2)),
                      s3 === 0 && (n3.status = 103)
                  } else n3.status = 103
                if (
                  (n3.status === 103 &&
                    (n3.gzhead.hcrc
                      ? (n3.pending + 2 > n3.pending_buf_size && F(e2),
                        n3.pending + 2 <= n3.pending_buf_size &&
                          (U2(n3, 255 & e2.adler), U2(n3, (e2.adler >> 8) & 255), (e2.adler = 0), (n3.status = E)))
                      : (n3.status = E)),
                  n3.pending !== 0)
                ) {
                  if ((F(e2), e2.avail_out === 0)) return (n3.last_flush = -1), m2
                } else if (e2.avail_in === 0 && T(t3) <= T(r2) && t3 !== f) return R(e2, -5)
                if (n3.status === 666 && e2.avail_in !== 0) return R(e2, -5)
                if (e2.avail_in !== 0 || n3.lookahead !== 0 || (t3 !== l && n3.status !== 666)) {
                  var o2 =
                    n3.strategy === 2
                      ? (function (e3, t4) {
                          for (var r3; ; ) {
                            if (e3.lookahead === 0 && (j(e3), e3.lookahead === 0)) {
                              if (t4 === l) return A
                              break
                            }
                            if (
                              ((e3.match_length = 0),
                              (r3 = u._tr_tally(e3, 0, e3.window[e3.strstart])),
                              e3.lookahead--,
                              e3.strstart++,
                              r3 && (N(e3, false), e3.strm.avail_out === 0))
                            )
                              return A
                          }
                          return (
                            (e3.insert = 0),
                            t4 === f
                              ? (N(e3, true), e3.strm.avail_out === 0 ? O : B)
                              : e3.last_lit && (N(e3, false), e3.strm.avail_out === 0)
                              ? A
                              : I
                          )
                        })(n3, t3)
                      : n3.strategy === 3
                      ? (function (e3, t4) {
                          for (var r3, n4, i3, s4, a3 = e3.window; ; ) {
                            if (e3.lookahead <= S2) {
                              if ((j(e3), e3.lookahead <= S2 && t4 === l)) return A
                              if (e3.lookahead === 0) break
                            }
                            if (
                              ((e3.match_length = 0),
                              e3.lookahead >= x &&
                                0 < e3.strstart &&
                                (n4 = a3[(i3 = e3.strstart - 1)]) === a3[++i3] &&
                                n4 === a3[++i3] &&
                                n4 === a3[++i3])
                            ) {
                              s4 = e3.strstart + S2
                              do {} while (
                                n4 === a3[++i3] &&
                                n4 === a3[++i3] &&
                                n4 === a3[++i3] &&
                                n4 === a3[++i3] &&
                                n4 === a3[++i3] &&
                                n4 === a3[++i3] &&
                                n4 === a3[++i3] &&
                                n4 === a3[++i3] &&
                                i3 < s4
                              )
                              ;(e3.match_length = S2 - (s4 - i3)),
                                e3.match_length > e3.lookahead && (e3.match_length = e3.lookahead)
                            }
                            if (
                              (e3.match_length >= x
                                ? ((r3 = u._tr_tally(e3, 1, e3.match_length - x)),
                                  (e3.lookahead -= e3.match_length),
                                  (e3.strstart += e3.match_length),
                                  (e3.match_length = 0))
                                : ((r3 = u._tr_tally(e3, 0, e3.window[e3.strstart])), e3.lookahead--, e3.strstart++),
                              r3 && (N(e3, false), e3.strm.avail_out === 0))
                            )
                              return A
                          }
                          return (
                            (e3.insert = 0),
                            t4 === f
                              ? (N(e3, true), e3.strm.avail_out === 0 ? O : B)
                              : e3.last_lit && (N(e3, false), e3.strm.avail_out === 0)
                              ? A
                              : I
                          )
                        })(n3, t3)
                      : h2[n3.level].func(n3, t3)
                  if (((o2 !== O && o2 !== B) || (n3.status = 666), o2 === A || o2 === O))
                    return e2.avail_out === 0 && (n3.last_flush = -1), m2
                  if (
                    o2 === I &&
                    (t3 === 1
                      ? u._tr_align(n3)
                      : t3 !== 5 &&
                        (u._tr_stored_block(n3, 0, 0, false),
                        t3 === 3 &&
                          (D2(n3.head),
                          n3.lookahead === 0 && ((n3.strstart = 0), (n3.block_start = 0), (n3.insert = 0)))),
                    F(e2),
                    e2.avail_out === 0)
                  )
                    return (n3.last_flush = -1), m2
                }
                return t3 !== f
                  ? m2
                  : n3.wrap <= 0
                  ? 1
                  : (n3.wrap === 2
                      ? (U2(n3, 255 & e2.adler),
                        U2(n3, (e2.adler >> 8) & 255),
                        U2(n3, (e2.adler >> 16) & 255),
                        U2(n3, (e2.adler >> 24) & 255),
                        U2(n3, 255 & e2.total_in),
                        U2(n3, (e2.total_in >> 8) & 255),
                        U2(n3, (e2.total_in >> 16) & 255),
                        U2(n3, (e2.total_in >> 24) & 255))
                      : (P2(n3, e2.adler >>> 16), P2(n3, 65535 & e2.adler)),
                    F(e2),
                    0 < n3.wrap && (n3.wrap = -n3.wrap),
                    n3.pending !== 0 ? m2 : 1)
              }),
              (r.deflateEnd = function (e2) {
                var t3
                return e2 && e2.state
                  ? (t3 = e2.state.status) !== C &&
                    t3 !== 69 &&
                    t3 !== 73 &&
                    t3 !== 91 &&
                    t3 !== 103 &&
                    t3 !== E &&
                    t3 !== 666
                    ? R(e2, _2)
                    : ((e2.state = null), t3 === E ? R(e2, -3) : m2)
                  : _2
              }),
              (r.deflateSetDictionary = function (e2, t3) {
                var r2,
                  n3,
                  i2,
                  s3,
                  a2,
                  o2,
                  h3,
                  u2,
                  l2 = t3.length
                if (!e2 || !e2.state) return _2
                if ((s3 = (r2 = e2.state).wrap) === 2 || (s3 === 1 && r2.status !== C) || r2.lookahead) return _2
                for (
                  s3 === 1 && (e2.adler = d2(e2.adler, t3, l2, 0)),
                    r2.wrap = 0,
                    l2 >= r2.w_size &&
                      (s3 === 0 && (D2(r2.head), (r2.strstart = 0), (r2.block_start = 0), (r2.insert = 0)),
                      (u2 = new c.Buf8(r2.w_size)),
                      c.arraySet(u2, t3, l2 - r2.w_size, r2.w_size, 0),
                      (t3 = u2),
                      (l2 = r2.w_size)),
                    a2 = e2.avail_in,
                    o2 = e2.next_in,
                    h3 = e2.input,
                    e2.avail_in = l2,
                    e2.next_in = 0,
                    e2.input = t3,
                    j(r2);
                  r2.lookahead >= x;

                ) {
                  for (
                    n3 = r2.strstart, i2 = r2.lookahead - (x - 1);
                    (r2.ins_h = ((r2.ins_h << r2.hash_shift) ^ r2.window[n3 + x - 1]) & r2.hash_mask),
                      (r2.prev[n3 & r2.w_mask] = r2.head[r2.ins_h]),
                      (r2.head[r2.ins_h] = n3),
                      n3++,
                      --i2;

                  );
                  ;(r2.strstart = n3), (r2.lookahead = x - 1), j(r2)
                }
                return (
                  (r2.strstart += r2.lookahead),
                  (r2.block_start = r2.strstart),
                  (r2.insert = r2.lookahead),
                  (r2.lookahead = 0),
                  (r2.match_length = r2.prev_length = x - 1),
                  (r2.match_available = 0),
                  (e2.next_in = o2),
                  (e2.input = h3),
                  (e2.avail_in = a2),
                  (r2.wrap = s3),
                  m2
                )
              }),
              (r.deflateInfo = 'pako deflate (from Nodeca project)')
          },
          { '../utils/common': 41, './adler32': 43, './crc32': 45, './messages': 51, './trees': 52 },
        ],
        47: [
          function (e, t2, r) {
            t2.exports = function () {
              ;(this.text = 0),
                (this.time = 0),
                (this.xflags = 0),
                (this.os = 0),
                (this.extra = null),
                (this.extra_len = 0),
                (this.name = ''),
                (this.comment = ''),
                (this.hcrc = 0),
                (this.done = false)
            }
          },
          {},
        ],
        48: [
          function (e, t2, r) {
            t2.exports = function (e2, t3) {
              var r2, n2, i, s2, a, o, h2, u, l, f, c, d2, p, m2, _2, g, b, v, y2, w2, k, x, S2, z, C
              ;(r2 = e2.state),
                (n2 = e2.next_in),
                (z = e2.input),
                (i = n2 + (e2.avail_in - 5)),
                (s2 = e2.next_out),
                (C = e2.output),
                (a = s2 - (t3 - e2.avail_out)),
                (o = s2 + (e2.avail_out - 257)),
                (h2 = r2.dmax),
                (u = r2.wsize),
                (l = r2.whave),
                (f = r2.wnext),
                (c = r2.window),
                (d2 = r2.hold),
                (p = r2.bits),
                (m2 = r2.lencode),
                (_2 = r2.distcode),
                (g = (1 << r2.lenbits) - 1),
                (b = (1 << r2.distbits) - 1)
              e: do {
                p < 15 && ((d2 += z[n2++] << p), (p += 8), (d2 += z[n2++] << p), (p += 8)), (v = m2[d2 & g])
                t: for (;;) {
                  if (((d2 >>>= y2 = v >>> 24), (p -= y2), (y2 = (v >>> 16) & 255) === 0)) C[s2++] = 65535 & v
                  else {
                    if (!(16 & y2)) {
                      if ((64 & y2) == 0) {
                        v = m2[(65535 & v) + (d2 & ((1 << y2) - 1))]
                        continue t
                      }
                      if (32 & y2) {
                        r2.mode = 12
                        break e
                      }
                      ;(e2.msg = 'invalid literal/length code'), (r2.mode = 30)
                      break e
                    }
                    ;(w2 = 65535 & v),
                      (y2 &= 15) &&
                        (p < y2 && ((d2 += z[n2++] << p), (p += 8)),
                        (w2 += d2 & ((1 << y2) - 1)),
                        (d2 >>>= y2),
                        (p -= y2)),
                      p < 15 && ((d2 += z[n2++] << p), (p += 8), (d2 += z[n2++] << p), (p += 8)),
                      (v = _2[d2 & b])
                    r: for (;;) {
                      if (((d2 >>>= y2 = v >>> 24), (p -= y2), !(16 & (y2 = (v >>> 16) & 255)))) {
                        if ((64 & y2) == 0) {
                          v = _2[(65535 & v) + (d2 & ((1 << y2) - 1))]
                          continue r
                        }
                        ;(e2.msg = 'invalid distance code'), (r2.mode = 30)
                        break e
                      }
                      if (
                        ((k = 65535 & v),
                        p < (y2 &= 15) && ((d2 += z[n2++] << p), (p += 8) < y2 && ((d2 += z[n2++] << p), (p += 8))),
                        h2 < (k += d2 & ((1 << y2) - 1)))
                      ) {
                        ;(e2.msg = 'invalid distance too far back'), (r2.mode = 30)
                        break e
                      }
                      if (((d2 >>>= y2), (p -= y2), (y2 = s2 - a) < k)) {
                        if (l < (y2 = k - y2) && r2.sane) {
                          ;(e2.msg = 'invalid distance too far back'), (r2.mode = 30)
                          break e
                        }
                        if (((S2 = c), (x = 0) === f)) {
                          if (((x += u - y2), y2 < w2)) {
                            for (w2 -= y2; (C[s2++] = c[x++]), --y2; );
                            ;(x = s2 - k), (S2 = C)
                          }
                        } else if (f < y2) {
                          if (((x += u + f - y2), (y2 -= f) < w2)) {
                            for (w2 -= y2; (C[s2++] = c[x++]), --y2; );
                            if (((x = 0), f < w2)) {
                              for (w2 -= y2 = f; (C[s2++] = c[x++]), --y2; );
                              ;(x = s2 - k), (S2 = C)
                            }
                          }
                        } else if (((x += f - y2), y2 < w2)) {
                          for (w2 -= y2; (C[s2++] = c[x++]), --y2; );
                          ;(x = s2 - k), (S2 = C)
                        }
                        for (; 2 < w2; ) (C[s2++] = S2[x++]), (C[s2++] = S2[x++]), (C[s2++] = S2[x++]), (w2 -= 3)
                        w2 && ((C[s2++] = S2[x++]), 1 < w2 && (C[s2++] = S2[x++]))
                      } else {
                        for (x = s2 - k; (C[s2++] = C[x++]), (C[s2++] = C[x++]), (C[s2++] = C[x++]), 2 < (w2 -= 3); );
                        w2 && ((C[s2++] = C[x++]), 1 < w2 && (C[s2++] = C[x++]))
                      }
                      break
                    }
                  }
                  break
                }
              } while (n2 < i && s2 < o)
              ;(n2 -= w2 = p >> 3),
                (d2 &= (1 << (p -= w2 << 3)) - 1),
                (e2.next_in = n2),
                (e2.next_out = s2),
                (e2.avail_in = n2 < i ? i - n2 + 5 : 5 - (n2 - i)),
                (e2.avail_out = s2 < o ? o - s2 + 257 : 257 - (s2 - o)),
                (r2.hold = d2),
                (r2.bits = p)
            }
          },
          {},
        ],
        49: [
          function (e, t2, r) {
            var I = e('../utils/common'),
              O = e('./adler32'),
              B = e('./crc32'),
              R = e('./inffast'),
              T = e('./inftrees'),
              D2 = 1,
              F = 2,
              N = 0,
              U2 = -2,
              P2 = 1,
              n2 = 852,
              i = 592
            function L2(e2) {
              return ((e2 >>> 24) & 255) + ((e2 >>> 8) & 65280) + ((65280 & e2) << 8) + ((255 & e2) << 24)
            }
            function s2() {
              ;(this.mode = 0),
                (this.last = false),
                (this.wrap = 0),
                (this.havedict = false),
                (this.flags = 0),
                (this.dmax = 0),
                (this.check = 0),
                (this.total = 0),
                (this.head = null),
                (this.wbits = 0),
                (this.wsize = 0),
                (this.whave = 0),
                (this.wnext = 0),
                (this.window = null),
                (this.hold = 0),
                (this.bits = 0),
                (this.length = 0),
                (this.offset = 0),
                (this.extra = 0),
                (this.lencode = null),
                (this.distcode = null),
                (this.lenbits = 0),
                (this.distbits = 0),
                (this.ncode = 0),
                (this.nlen = 0),
                (this.ndist = 0),
                (this.have = 0),
                (this.next = null),
                (this.lens = new I.Buf16(320)),
                (this.work = new I.Buf16(288)),
                (this.lendyn = null),
                (this.distdyn = null),
                (this.sane = 0),
                (this.back = 0),
                (this.was = 0)
            }
            function a(e2) {
              var t3
              return e2 && e2.state
                ? ((t3 = e2.state),
                  (e2.total_in = e2.total_out = t3.total = 0),
                  (e2.msg = ''),
                  t3.wrap && (e2.adler = 1 & t3.wrap),
                  (t3.mode = P2),
                  (t3.last = 0),
                  (t3.havedict = 0),
                  (t3.dmax = 32768),
                  (t3.head = null),
                  (t3.hold = 0),
                  (t3.bits = 0),
                  (t3.lencode = t3.lendyn = new I.Buf32(n2)),
                  (t3.distcode = t3.distdyn = new I.Buf32(i)),
                  (t3.sane = 1),
                  (t3.back = -1),
                  N)
                : U2
            }
            function o(e2) {
              var t3
              return e2 && e2.state ? (((t3 = e2.state).wsize = 0), (t3.whave = 0), (t3.wnext = 0), a(e2)) : U2
            }
            function h2(e2, t3) {
              var r2, n3
              return e2 && e2.state
                ? ((n3 = e2.state),
                  t3 < 0 ? ((r2 = 0), (t3 = -t3)) : ((r2 = 1 + (t3 >> 4)), t3 < 48 && (t3 &= 15)),
                  t3 && (t3 < 8 || 15 < t3)
                    ? U2
                    : (n3.window !== null && n3.wbits !== t3 && (n3.window = null),
                      (n3.wrap = r2),
                      (n3.wbits = t3),
                      o(e2)))
                : U2
            }
            function u(e2, t3) {
              var r2, n3
              return e2
                ? ((n3 = new s2()), ((e2.state = n3).window = null), (r2 = h2(e2, t3)) !== N && (e2.state = null), r2)
                : U2
            }
            var l,
              f,
              c = true
            function j(e2) {
              if (c) {
                var t3
                for (l = new I.Buf32(512), f = new I.Buf32(32), t3 = 0; t3 < 144; ) e2.lens[t3++] = 8
                for (; t3 < 256; ) e2.lens[t3++] = 9
                for (; t3 < 280; ) e2.lens[t3++] = 7
                for (; t3 < 288; ) e2.lens[t3++] = 8
                for (T(D2, e2.lens, 0, 288, l, 0, e2.work, { bits: 9 }), t3 = 0; t3 < 32; ) e2.lens[t3++] = 5
                T(F, e2.lens, 0, 32, f, 0, e2.work, { bits: 5 }), (c = false)
              }
              ;(e2.lencode = l), (e2.lenbits = 9), (e2.distcode = f), (e2.distbits = 5)
            }
            function Z(e2, t3, r2, n3) {
              var i2,
                s3 = e2.state
              return (
                s3.window === null &&
                  ((s3.wsize = 1 << s3.wbits), (s3.wnext = 0), (s3.whave = 0), (s3.window = new I.Buf8(s3.wsize))),
                n3 >= s3.wsize
                  ? (I.arraySet(s3.window, t3, r2 - s3.wsize, s3.wsize, 0), (s3.wnext = 0), (s3.whave = s3.wsize))
                  : (n3 < (i2 = s3.wsize - s3.wnext) && (i2 = n3),
                    I.arraySet(s3.window, t3, r2 - n3, i2, s3.wnext),
                    (n3 -= i2)
                      ? (I.arraySet(s3.window, t3, r2 - n3, n3, 0), (s3.wnext = n3), (s3.whave = s3.wsize))
                      : ((s3.wnext += i2),
                        s3.wnext === s3.wsize && (s3.wnext = 0),
                        s3.whave < s3.wsize && (s3.whave += i2))),
                0
              )
            }
            ;(r.inflateReset = o),
              (r.inflateReset2 = h2),
              (r.inflateResetKeep = a),
              (r.inflateInit = function (e2) {
                return u(e2, 15)
              }),
              (r.inflateInit2 = u),
              (r.inflate = function (e2, t3) {
                var r2,
                  n3,
                  i2,
                  s3,
                  a2,
                  o2,
                  h3,
                  u2,
                  l2,
                  f2,
                  c2,
                  d2,
                  p,
                  m2,
                  _2,
                  g,
                  b,
                  v,
                  y2,
                  w2,
                  k,
                  x,
                  S2,
                  z,
                  C = 0,
                  E = new I.Buf8(4),
                  A = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
                if (!e2 || !e2.state || !e2.output || (!e2.input && e2.avail_in !== 0)) return U2
                ;(r2 = e2.state).mode === 12 && (r2.mode = 13),
                  (a2 = e2.next_out),
                  (i2 = e2.output),
                  (h3 = e2.avail_out),
                  (s3 = e2.next_in),
                  (n3 = e2.input),
                  (o2 = e2.avail_in),
                  (u2 = r2.hold),
                  (l2 = r2.bits),
                  (f2 = o2),
                  (c2 = h3),
                  (x = N)
                e: for (;;)
                  switch (r2.mode) {
                    case P2:
                      if (r2.wrap === 0) {
                        r2.mode = 13
                        break
                      }
                      for (; l2 < 16; ) {
                        if (o2 === 0) break e
                        o2--, (u2 += n3[s3++] << l2), (l2 += 8)
                      }
                      if (2 & r2.wrap && u2 === 35615) {
                        ;(E[(r2.check = 0)] = 255 & u2),
                          (E[1] = (u2 >>> 8) & 255),
                          (r2.check = B(r2.check, E, 2, 0)),
                          (l2 = u2 = 0),
                          (r2.mode = 2)
                        break
                      }
                      if (
                        ((r2.flags = 0),
                        r2.head && (r2.head.done = false),
                        !(1 & r2.wrap) || (((255 & u2) << 8) + (u2 >> 8)) % 31)
                      ) {
                        ;(e2.msg = 'incorrect header check'), (r2.mode = 30)
                        break
                      }
                      if ((15 & u2) != 8) {
                        ;(e2.msg = 'unknown compression method'), (r2.mode = 30)
                        break
                      }
                      if (((l2 -= 4), (k = 8 + (15 & (u2 >>>= 4))), r2.wbits === 0)) r2.wbits = k
                      else if (k > r2.wbits) {
                        ;(e2.msg = 'invalid window size'), (r2.mode = 30)
                        break
                      }
                      ;(r2.dmax = 1 << k), (e2.adler = r2.check = 1), (r2.mode = 512 & u2 ? 10 : 12), (l2 = u2 = 0)
                      break
                    case 2:
                      for (; l2 < 16; ) {
                        if (o2 === 0) break e
                        o2--, (u2 += n3[s3++] << l2), (l2 += 8)
                      }
                      if (((r2.flags = u2), (255 & r2.flags) != 8)) {
                        ;(e2.msg = 'unknown compression method'), (r2.mode = 30)
                        break
                      }
                      if (57344 & r2.flags) {
                        ;(e2.msg = 'unknown header flags set'), (r2.mode = 30)
                        break
                      }
                      r2.head && (r2.head.text = (u2 >> 8) & 1),
                        512 & r2.flags &&
                          ((E[0] = 255 & u2), (E[1] = (u2 >>> 8) & 255), (r2.check = B(r2.check, E, 2, 0))),
                        (l2 = u2 = 0),
                        (r2.mode = 3)
                    case 3:
                      for (; l2 < 32; ) {
                        if (o2 === 0) break e
                        o2--, (u2 += n3[s3++] << l2), (l2 += 8)
                      }
                      r2.head && (r2.head.time = u2),
                        512 & r2.flags &&
                          ((E[0] = 255 & u2),
                          (E[1] = (u2 >>> 8) & 255),
                          (E[2] = (u2 >>> 16) & 255),
                          (E[3] = (u2 >>> 24) & 255),
                          (r2.check = B(r2.check, E, 4, 0))),
                        (l2 = u2 = 0),
                        (r2.mode = 4)
                    case 4:
                      for (; l2 < 16; ) {
                        if (o2 === 0) break e
                        o2--, (u2 += n3[s3++] << l2), (l2 += 8)
                      }
                      r2.head && ((r2.head.xflags = 255 & u2), (r2.head.os = u2 >> 8)),
                        512 & r2.flags &&
                          ((E[0] = 255 & u2), (E[1] = (u2 >>> 8) & 255), (r2.check = B(r2.check, E, 2, 0))),
                        (l2 = u2 = 0),
                        (r2.mode = 5)
                    case 5:
                      if (1024 & r2.flags) {
                        for (; l2 < 16; ) {
                          if (o2 === 0) break e
                          o2--, (u2 += n3[s3++] << l2), (l2 += 8)
                        }
                        ;(r2.length = u2),
                          r2.head && (r2.head.extra_len = u2),
                          512 & r2.flags &&
                            ((E[0] = 255 & u2), (E[1] = (u2 >>> 8) & 255), (r2.check = B(r2.check, E, 2, 0))),
                          (l2 = u2 = 0)
                      } else r2.head && (r2.head.extra = null)
                      r2.mode = 6
                    case 6:
                      if (
                        1024 & r2.flags &&
                        (o2 < (d2 = r2.length) && (d2 = o2),
                        d2 &&
                          (r2.head &&
                            ((k = r2.head.extra_len - r2.length),
                            r2.head.extra || (r2.head.extra = new Array(r2.head.extra_len)),
                            I.arraySet(r2.head.extra, n3, s3, d2, k)),
                          512 & r2.flags && (r2.check = B(r2.check, n3, d2, s3)),
                          (o2 -= d2),
                          (s3 += d2),
                          (r2.length -= d2)),
                        r2.length)
                      )
                        break e
                      ;(r2.length = 0), (r2.mode = 7)
                    case 7:
                      if (2048 & r2.flags) {
                        if (o2 === 0) break e
                        for (
                          d2 = 0;
                          (k = n3[s3 + d2++]),
                            r2.head && k && r2.length < 65536 && (r2.head.name += String.fromCharCode(k)),
                            k && d2 < o2;

                        );
                        if ((512 & r2.flags && (r2.check = B(r2.check, n3, d2, s3)), (o2 -= d2), (s3 += d2), k)) break e
                      } else r2.head && (r2.head.name = null)
                      ;(r2.length = 0), (r2.mode = 8)
                    case 8:
                      if (4096 & r2.flags) {
                        if (o2 === 0) break e
                        for (
                          d2 = 0;
                          (k = n3[s3 + d2++]),
                            r2.head && k && r2.length < 65536 && (r2.head.comment += String.fromCharCode(k)),
                            k && d2 < o2;

                        );
                        if ((512 & r2.flags && (r2.check = B(r2.check, n3, d2, s3)), (o2 -= d2), (s3 += d2), k)) break e
                      } else r2.head && (r2.head.comment = null)
                      r2.mode = 9
                    case 9:
                      if (512 & r2.flags) {
                        for (; l2 < 16; ) {
                          if (o2 === 0) break e
                          o2--, (u2 += n3[s3++] << l2), (l2 += 8)
                        }
                        if (u2 !== (65535 & r2.check)) {
                          ;(e2.msg = 'header crc mismatch'), (r2.mode = 30)
                          break
                        }
                        l2 = u2 = 0
                      }
                      r2.head && ((r2.head.hcrc = (r2.flags >> 9) & 1), (r2.head.done = true)),
                        (e2.adler = r2.check = 0),
                        (r2.mode = 12)
                      break
                    case 10:
                      for (; l2 < 32; ) {
                        if (o2 === 0) break e
                        o2--, (u2 += n3[s3++] << l2), (l2 += 8)
                      }
                      ;(e2.adler = r2.check = L2(u2)), (l2 = u2 = 0), (r2.mode = 11)
                    case 11:
                      if (r2.havedict === 0)
                        return (
                          (e2.next_out = a2),
                          (e2.avail_out = h3),
                          (e2.next_in = s3),
                          (e2.avail_in = o2),
                          (r2.hold = u2),
                          (r2.bits = l2),
                          2
                        )
                      ;(e2.adler = r2.check = 1), (r2.mode = 12)
                    case 12:
                      if (t3 === 5 || t3 === 6) break e
                    case 13:
                      if (r2.last) {
                        ;(u2 >>>= 7 & l2), (l2 -= 7 & l2), (r2.mode = 27)
                        break
                      }
                      for (; l2 < 3; ) {
                        if (o2 === 0) break e
                        o2--, (u2 += n3[s3++] << l2), (l2 += 8)
                      }
                      switch (((r2.last = 1 & u2), (l2 -= 1), 3 & (u2 >>>= 1))) {
                        case 0:
                          r2.mode = 14
                          break
                        case 1:
                          if ((j(r2), (r2.mode = 20), t3 !== 6)) break
                          ;(u2 >>>= 2), (l2 -= 2)
                          break e
                        case 2:
                          r2.mode = 17
                          break
                        case 3:
                          ;(e2.msg = 'invalid block type'), (r2.mode = 30)
                      }
                      ;(u2 >>>= 2), (l2 -= 2)
                      break
                    case 14:
                      for (u2 >>>= 7 & l2, l2 -= 7 & l2; l2 < 32; ) {
                        if (o2 === 0) break e
                        o2--, (u2 += n3[s3++] << l2), (l2 += 8)
                      }
                      if ((65535 & u2) != ((u2 >>> 16) ^ 65535)) {
                        ;(e2.msg = 'invalid stored block lengths'), (r2.mode = 30)
                        break
                      }
                      if (((r2.length = 65535 & u2), (l2 = u2 = 0), (r2.mode = 15), t3 === 6)) break e
                    case 15:
                      r2.mode = 16
                    case 16:
                      if ((d2 = r2.length)) {
                        if ((o2 < d2 && (d2 = o2), h3 < d2 && (d2 = h3), d2 === 0)) break e
                        I.arraySet(i2, n3, s3, d2, a2),
                          (o2 -= d2),
                          (s3 += d2),
                          (h3 -= d2),
                          (a2 += d2),
                          (r2.length -= d2)
                        break
                      }
                      r2.mode = 12
                      break
                    case 17:
                      for (; l2 < 14; ) {
                        if (o2 === 0) break e
                        o2--, (u2 += n3[s3++] << l2), (l2 += 8)
                      }
                      if (
                        ((r2.nlen = 257 + (31 & u2)),
                        (u2 >>>= 5),
                        (l2 -= 5),
                        (r2.ndist = 1 + (31 & u2)),
                        (u2 >>>= 5),
                        (l2 -= 5),
                        (r2.ncode = 4 + (15 & u2)),
                        (u2 >>>= 4),
                        (l2 -= 4),
                        286 < r2.nlen || 30 < r2.ndist)
                      ) {
                        ;(e2.msg = 'too many length or distance symbols'), (r2.mode = 30)
                        break
                      }
                      ;(r2.have = 0), (r2.mode = 18)
                    case 18:
                      for (; r2.have < r2.ncode; ) {
                        for (; l2 < 3; ) {
                          if (o2 === 0) break e
                          o2--, (u2 += n3[s3++] << l2), (l2 += 8)
                        }
                        ;(r2.lens[A[r2.have++]] = 7 & u2), (u2 >>>= 3), (l2 -= 3)
                      }
                      for (; r2.have < 19; ) r2.lens[A[r2.have++]] = 0
                      if (
                        ((r2.lencode = r2.lendyn),
                        (r2.lenbits = 7),
                        (S2 = { bits: r2.lenbits }),
                        (x = T(0, r2.lens, 0, 19, r2.lencode, 0, r2.work, S2)),
                        (r2.lenbits = S2.bits),
                        x)
                      ) {
                        ;(e2.msg = 'invalid code lengths set'), (r2.mode = 30)
                        break
                      }
                      ;(r2.have = 0), (r2.mode = 19)
                    case 19:
                      for (; r2.have < r2.nlen + r2.ndist; ) {
                        for (
                          ;
                          (g = ((C = r2.lencode[u2 & ((1 << r2.lenbits) - 1)]) >>> 16) & 255),
                            (b = 65535 & C),
                            !((_2 = C >>> 24) <= l2);

                        ) {
                          if (o2 === 0) break e
                          o2--, (u2 += n3[s3++] << l2), (l2 += 8)
                        }
                        if (b < 16) (u2 >>>= _2), (l2 -= _2), (r2.lens[r2.have++] = b)
                        else {
                          if (b === 16) {
                            for (z = _2 + 2; l2 < z; ) {
                              if (o2 === 0) break e
                              o2--, (u2 += n3[s3++] << l2), (l2 += 8)
                            }
                            if (((u2 >>>= _2), (l2 -= _2), r2.have === 0)) {
                              ;(e2.msg = 'invalid bit length repeat'), (r2.mode = 30)
                              break
                            }
                            ;(k = r2.lens[r2.have - 1]), (d2 = 3 + (3 & u2)), (u2 >>>= 2), (l2 -= 2)
                          } else if (b === 17) {
                            for (z = _2 + 3; l2 < z; ) {
                              if (o2 === 0) break e
                              o2--, (u2 += n3[s3++] << l2), (l2 += 8)
                            }
                            ;(l2 -= _2), (k = 0), (d2 = 3 + (7 & (u2 >>>= _2))), (u2 >>>= 3), (l2 -= 3)
                          } else {
                            for (z = _2 + 7; l2 < z; ) {
                              if (o2 === 0) break e
                              o2--, (u2 += n3[s3++] << l2), (l2 += 8)
                            }
                            ;(l2 -= _2), (k = 0), (d2 = 11 + (127 & (u2 >>>= _2))), (u2 >>>= 7), (l2 -= 7)
                          }
                          if (r2.have + d2 > r2.nlen + r2.ndist) {
                            ;(e2.msg = 'invalid bit length repeat'), (r2.mode = 30)
                            break
                          }
                          for (; d2--; ) r2.lens[r2.have++] = k
                        }
                      }
                      if (r2.mode === 30) break
                      if (r2.lens[256] === 0) {
                        ;(e2.msg = 'invalid code -- missing end-of-block'), (r2.mode = 30)
                        break
                      }
                      if (
                        ((r2.lenbits = 9),
                        (S2 = { bits: r2.lenbits }),
                        (x = T(D2, r2.lens, 0, r2.nlen, r2.lencode, 0, r2.work, S2)),
                        (r2.lenbits = S2.bits),
                        x)
                      ) {
                        ;(e2.msg = 'invalid literal/lengths set'), (r2.mode = 30)
                        break
                      }
                      if (
                        ((r2.distbits = 6),
                        (r2.distcode = r2.distdyn),
                        (S2 = { bits: r2.distbits }),
                        (x = T(F, r2.lens, r2.nlen, r2.ndist, r2.distcode, 0, r2.work, S2)),
                        (r2.distbits = S2.bits),
                        x)
                      ) {
                        ;(e2.msg = 'invalid distances set'), (r2.mode = 30)
                        break
                      }
                      if (((r2.mode = 20), t3 === 6)) break e
                    case 20:
                      r2.mode = 21
                    case 21:
                      if (6 <= o2 && 258 <= h3) {
                        ;(e2.next_out = a2),
                          (e2.avail_out = h3),
                          (e2.next_in = s3),
                          (e2.avail_in = o2),
                          (r2.hold = u2),
                          (r2.bits = l2),
                          R(e2, c2),
                          (a2 = e2.next_out),
                          (i2 = e2.output),
                          (h3 = e2.avail_out),
                          (s3 = e2.next_in),
                          (n3 = e2.input),
                          (o2 = e2.avail_in),
                          (u2 = r2.hold),
                          (l2 = r2.bits),
                          r2.mode === 12 && (r2.back = -1)
                        break
                      }
                      for (
                        r2.back = 0;
                        (g = ((C = r2.lencode[u2 & ((1 << r2.lenbits) - 1)]) >>> 16) & 255),
                          (b = 65535 & C),
                          !((_2 = C >>> 24) <= l2);

                      ) {
                        if (o2 === 0) break e
                        o2--, (u2 += n3[s3++] << l2), (l2 += 8)
                      }
                      if (g && (240 & g) == 0) {
                        for (
                          v = _2, y2 = g, w2 = b;
                          (g = ((C = r2.lencode[w2 + ((u2 & ((1 << (v + y2)) - 1)) >> v)]) >>> 16) & 255),
                            (b = 65535 & C),
                            !(v + (_2 = C >>> 24) <= l2);

                        ) {
                          if (o2 === 0) break e
                          o2--, (u2 += n3[s3++] << l2), (l2 += 8)
                        }
                        ;(u2 >>>= v), (l2 -= v), (r2.back += v)
                      }
                      if (((u2 >>>= _2), (l2 -= _2), (r2.back += _2), (r2.length = b), g === 0)) {
                        r2.mode = 26
                        break
                      }
                      if (32 & g) {
                        ;(r2.back = -1), (r2.mode = 12)
                        break
                      }
                      if (64 & g) {
                        ;(e2.msg = 'invalid literal/length code'), (r2.mode = 30)
                        break
                      }
                      ;(r2.extra = 15 & g), (r2.mode = 22)
                    case 22:
                      if (r2.extra) {
                        for (z = r2.extra; l2 < z; ) {
                          if (o2 === 0) break e
                          o2--, (u2 += n3[s3++] << l2), (l2 += 8)
                        }
                        ;(r2.length += u2 & ((1 << r2.extra) - 1)),
                          (u2 >>>= r2.extra),
                          (l2 -= r2.extra),
                          (r2.back += r2.extra)
                      }
                      ;(r2.was = r2.length), (r2.mode = 23)
                    case 23:
                      for (
                        ;
                        (g = ((C = r2.distcode[u2 & ((1 << r2.distbits) - 1)]) >>> 16) & 255),
                          (b = 65535 & C),
                          !((_2 = C >>> 24) <= l2);

                      ) {
                        if (o2 === 0) break e
                        o2--, (u2 += n3[s3++] << l2), (l2 += 8)
                      }
                      if ((240 & g) == 0) {
                        for (
                          v = _2, y2 = g, w2 = b;
                          (g = ((C = r2.distcode[w2 + ((u2 & ((1 << (v + y2)) - 1)) >> v)]) >>> 16) & 255),
                            (b = 65535 & C),
                            !(v + (_2 = C >>> 24) <= l2);

                        ) {
                          if (o2 === 0) break e
                          o2--, (u2 += n3[s3++] << l2), (l2 += 8)
                        }
                        ;(u2 >>>= v), (l2 -= v), (r2.back += v)
                      }
                      if (((u2 >>>= _2), (l2 -= _2), (r2.back += _2), 64 & g)) {
                        ;(e2.msg = 'invalid distance code'), (r2.mode = 30)
                        break
                      }
                      ;(r2.offset = b), (r2.extra = 15 & g), (r2.mode = 24)
                    case 24:
                      if (r2.extra) {
                        for (z = r2.extra; l2 < z; ) {
                          if (o2 === 0) break e
                          o2--, (u2 += n3[s3++] << l2), (l2 += 8)
                        }
                        ;(r2.offset += u2 & ((1 << r2.extra) - 1)),
                          (u2 >>>= r2.extra),
                          (l2 -= r2.extra),
                          (r2.back += r2.extra)
                      }
                      if (r2.offset > r2.dmax) {
                        ;(e2.msg = 'invalid distance too far back'), (r2.mode = 30)
                        break
                      }
                      r2.mode = 25
                    case 25:
                      if (h3 === 0) break e
                      if (((d2 = c2 - h3), r2.offset > d2)) {
                        if ((d2 = r2.offset - d2) > r2.whave && r2.sane) {
                          ;(e2.msg = 'invalid distance too far back'), (r2.mode = 30)
                          break
                        }
                        ;(p = d2 > r2.wnext ? ((d2 -= r2.wnext), r2.wsize - d2) : r2.wnext - d2),
                          d2 > r2.length && (d2 = r2.length),
                          (m2 = r2.window)
                      } else (m2 = i2), (p = a2 - r2.offset), (d2 = r2.length)
                      for (h3 < d2 && (d2 = h3), h3 -= d2, r2.length -= d2; (i2[a2++] = m2[p++]), --d2; );
                      r2.length === 0 && (r2.mode = 21)
                      break
                    case 26:
                      if (h3 === 0) break e
                      ;(i2[a2++] = r2.length), h3--, (r2.mode = 21)
                      break
                    case 27:
                      if (r2.wrap) {
                        for (; l2 < 32; ) {
                          if (o2 === 0) break e
                          o2--, (u2 |= n3[s3++] << l2), (l2 += 8)
                        }
                        if (
                          ((c2 -= h3),
                          (e2.total_out += c2),
                          (r2.total += c2),
                          c2 &&
                            (e2.adler = r2.check =
                              r2.flags ? B(r2.check, i2, c2, a2 - c2) : O(r2.check, i2, c2, a2 - c2)),
                          (c2 = h3),
                          (r2.flags ? u2 : L2(u2)) !== r2.check)
                        ) {
                          ;(e2.msg = 'incorrect data check'), (r2.mode = 30)
                          break
                        }
                        l2 = u2 = 0
                      }
                      r2.mode = 28
                    case 28:
                      if (r2.wrap && r2.flags) {
                        for (; l2 < 32; ) {
                          if (o2 === 0) break e
                          o2--, (u2 += n3[s3++] << l2), (l2 += 8)
                        }
                        if (u2 !== (4294967295 & r2.total)) {
                          ;(e2.msg = 'incorrect length check'), (r2.mode = 30)
                          break
                        }
                        l2 = u2 = 0
                      }
                      r2.mode = 29
                    case 29:
                      x = 1
                      break e
                    case 30:
                      x = -3
                      break e
                    case 31:
                      return -4
                    case 32:
                    default:
                      return U2
                  }
                return (
                  (e2.next_out = a2),
                  (e2.avail_out = h3),
                  (e2.next_in = s3),
                  (e2.avail_in = o2),
                  (r2.hold = u2),
                  (r2.bits = l2),
                  (r2.wsize || (c2 !== e2.avail_out && r2.mode < 30 && (r2.mode < 27 || t3 !== 4))) &&
                  Z(e2, e2.output, e2.next_out, c2 - e2.avail_out)
                    ? ((r2.mode = 31), -4)
                    : ((f2 -= e2.avail_in),
                      (c2 -= e2.avail_out),
                      (e2.total_in += f2),
                      (e2.total_out += c2),
                      (r2.total += c2),
                      r2.wrap &&
                        c2 &&
                        (e2.adler = r2.check =
                          r2.flags ? B(r2.check, i2, c2, e2.next_out - c2) : O(r2.check, i2, c2, e2.next_out - c2)),
                      (e2.data_type =
                        r2.bits +
                        (r2.last ? 64 : 0) +
                        (r2.mode === 12 ? 128 : 0) +
                        (r2.mode === 20 || r2.mode === 15 ? 256 : 0)),
                      ((f2 == 0 && c2 === 0) || t3 === 4) && x === N && (x = -5),
                      x)
                )
              }),
              (r.inflateEnd = function (e2) {
                if (!e2 || !e2.state) return U2
                var t3 = e2.state
                return t3.window && (t3.window = null), (e2.state = null), N
              }),
              (r.inflateGetHeader = function (e2, t3) {
                var r2
                return e2 && e2.state ? ((2 & (r2 = e2.state).wrap) == 0 ? U2 : (((r2.head = t3).done = false), N)) : U2
              }),
              (r.inflateSetDictionary = function (e2, t3) {
                var r2,
                  n3 = t3.length
                return e2 && e2.state
                  ? (r2 = e2.state).wrap !== 0 && r2.mode !== 11
                    ? U2
                    : r2.mode === 11 && O(1, t3, n3, 0) !== r2.check
                    ? -3
                    : Z(e2, t3, n3, n3)
                    ? ((r2.mode = 31), -4)
                    : ((r2.havedict = 1), N)
                  : U2
              }),
              (r.inflateInfo = 'pako inflate (from Nodeca project)')
          },
          { '../utils/common': 41, './adler32': 43, './crc32': 45, './inffast': 48, './inftrees': 50 },
        ],
        50: [
          function (e, t2, r) {
            var D2 = e('../utils/common'),
              F = [
                3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195,
                227, 258, 0, 0,
              ],
              N = [
                16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21,
                21, 21, 16, 72, 78,
              ],
              U2 = [
                1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073,
                4097, 6145, 8193, 12289, 16385, 24577, 0, 0,
              ],
              P2 = [
                16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
                28, 28, 29, 29, 64, 64,
              ]
            t2.exports = function (e2, t3, r2, n2, i, s2, a, o) {
              var h2,
                u,
                l,
                f,
                c,
                d2,
                p,
                m2,
                _2,
                g = o.bits,
                b = 0,
                v = 0,
                y2 = 0,
                w2 = 0,
                k = 0,
                x = 0,
                S2 = 0,
                z = 0,
                C = 0,
                E = 0,
                A = null,
                I = 0,
                O = new D2.Buf16(16),
                B = new D2.Buf16(16),
                R = null,
                T = 0
              for (b = 0; b <= 15; b++) O[b] = 0
              for (v = 0; v < n2; v++) O[t3[r2 + v]]++
              for (k = g, w2 = 15; 1 <= w2 && O[w2] === 0; w2--);
              if ((w2 < k && (k = w2), w2 === 0)) return (i[s2++] = 20971520), (i[s2++] = 20971520), (o.bits = 1), 0
              for (y2 = 1; y2 < w2 && O[y2] === 0; y2++);
              for (k < y2 && (k = y2), b = z = 1; b <= 15; b++) if (((z <<= 1), (z -= O[b]) < 0)) return -1
              if (0 < z && (e2 === 0 || w2 !== 1)) return -1
              for (B[1] = 0, b = 1; b < 15; b++) B[b + 1] = B[b] + O[b]
              for (v = 0; v < n2; v++) t3[r2 + v] !== 0 && (a[B[t3[r2 + v]]++] = v)
              if (
                ((d2 =
                  e2 === 0
                    ? ((A = R = a), 19)
                    : e2 === 1
                    ? ((A = F), (I -= 257), (R = N), (T -= 257), 256)
                    : ((A = U2), (R = P2), -1)),
                (b = y2),
                (c = s2),
                (S2 = v = E = 0),
                (l = -1),
                (f = (C = 1 << (x = k)) - 1),
                (e2 === 1 && 852 < C) || (e2 === 2 && 592 < C))
              )
                return 1
              for (;;) {
                for (
                  p = b - S2,
                    _2 = a[v] < d2 ? ((m2 = 0), a[v]) : a[v] > d2 ? ((m2 = R[T + a[v]]), A[I + a[v]]) : ((m2 = 96), 0),
                    h2 = 1 << (b - S2),
                    y2 = u = 1 << x;
                  (i[c + (E >> S2) + (u -= h2)] = (p << 24) | (m2 << 16) | _2 | 0), u !== 0;

                );
                for (h2 = 1 << (b - 1); E & h2; ) h2 >>= 1
                if ((h2 !== 0 ? ((E &= h2 - 1), (E += h2)) : (E = 0), v++, --O[b] == 0)) {
                  if (b === w2) break
                  b = t3[r2 + a[v]]
                }
                if (k < b && (E & f) !== l) {
                  for (S2 === 0 && (S2 = k), c += y2, z = 1 << (x = b - S2); x + S2 < w2 && !((z -= O[x + S2]) <= 0); )
                    x++, (z <<= 1)
                  if (((C += 1 << x), (e2 === 1 && 852 < C) || (e2 === 2 && 592 < C))) return 1
                  i[(l = E & f)] = (k << 24) | (x << 16) | (c - s2) | 0
                }
              }
              return E !== 0 && (i[c + E] = ((b - S2) << 24) | (64 << 16) | 0), (o.bits = k), 0
            }
          },
          { '../utils/common': 41 },
        ],
        51: [
          function (e, t2, r) {
            t2.exports = {
              2: 'need dictionary',
              1: 'stream end',
              0: '',
              '-1': 'file error',
              '-2': 'stream error',
              '-3': 'data error',
              '-4': 'insufficient memory',
              '-5': 'buffer error',
              '-6': 'incompatible version',
            }
          },
          {},
        ],
        52: [
          function (e, t2, r) {
            var i = e('../utils/common'),
              o = 0,
              h2 = 1
            function n2(e2) {
              for (var t3 = e2.length; 0 <= --t3; ) e2[t3] = 0
            }
            var s2 = 0,
              a = 29,
              u = 256,
              l = u + 1 + a,
              f = 30,
              c = 19,
              _2 = 2 * l + 1,
              g = 15,
              d2 = 16,
              p = 7,
              m2 = 256,
              b = 16,
              v = 17,
              y2 = 18,
              w2 = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0],
              k = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13],
              x = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7],
              S2 = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],
              z = new Array(2 * (l + 2))
            n2(z)
            var C = new Array(2 * f)
            n2(C)
            var E = new Array(512)
            n2(E)
            var A = new Array(256)
            n2(A)
            var I = new Array(a)
            n2(I)
            var O,
              B,
              R,
              T = new Array(f)
            function D2(e2, t3, r2, n3, i2) {
              ;(this.static_tree = e2),
                (this.extra_bits = t3),
                (this.extra_base = r2),
                (this.elems = n3),
                (this.max_length = i2),
                (this.has_stree = e2 && e2.length)
            }
            function F(e2, t3) {
              ;(this.dyn_tree = e2), (this.max_code = 0), (this.stat_desc = t3)
            }
            function N(e2) {
              return e2 < 256 ? E[e2] : E[256 + (e2 >>> 7)]
            }
            function U2(e2, t3) {
              ;(e2.pending_buf[e2.pending++] = 255 & t3), (e2.pending_buf[e2.pending++] = (t3 >>> 8) & 255)
            }
            function P2(e2, t3, r2) {
              e2.bi_valid > d2 - r2
                ? ((e2.bi_buf |= (t3 << e2.bi_valid) & 65535),
                  U2(e2, e2.bi_buf),
                  (e2.bi_buf = t3 >> (d2 - e2.bi_valid)),
                  (e2.bi_valid += r2 - d2))
                : ((e2.bi_buf |= (t3 << e2.bi_valid) & 65535), (e2.bi_valid += r2))
            }
            function L2(e2, t3, r2) {
              P2(e2, r2[2 * t3], r2[2 * t3 + 1])
            }
            function j(e2, t3) {
              for (var r2 = 0; (r2 |= 1 & e2), (e2 >>>= 1), (r2 <<= 1), 0 < --t3; );
              return r2 >>> 1
            }
            function Z(e2, t3, r2) {
              var n3,
                i2,
                s3 = new Array(g + 1),
                a2 = 0
              for (n3 = 1; n3 <= g; n3++) s3[n3] = a2 = (a2 + r2[n3 - 1]) << 1
              for (i2 = 0; i2 <= t3; i2++) {
                var o2 = e2[2 * i2 + 1]
                o2 !== 0 && (e2[2 * i2] = j(s3[o2]++, o2))
              }
            }
            function W2(e2) {
              var t3
              for (t3 = 0; t3 < l; t3++) e2.dyn_ltree[2 * t3] = 0
              for (t3 = 0; t3 < f; t3++) e2.dyn_dtree[2 * t3] = 0
              for (t3 = 0; t3 < c; t3++) e2.bl_tree[2 * t3] = 0
              ;(e2.dyn_ltree[2 * m2] = 1), (e2.opt_len = e2.static_len = 0), (e2.last_lit = e2.matches = 0)
            }
            function M2(e2) {
              8 < e2.bi_valid ? U2(e2, e2.bi_buf) : 0 < e2.bi_valid && (e2.pending_buf[e2.pending++] = e2.bi_buf),
                (e2.bi_buf = 0),
                (e2.bi_valid = 0)
            }
            function H2(e2, t3, r2, n3) {
              var i2 = 2 * t3,
                s3 = 2 * r2
              return e2[i2] < e2[s3] || (e2[i2] === e2[s3] && n3[t3] <= n3[r2])
            }
            function G(e2, t3, r2) {
              for (
                var n3 = e2.heap[r2], i2 = r2 << 1;
                i2 <= e2.heap_len &&
                (i2 < e2.heap_len && H2(t3, e2.heap[i2 + 1], e2.heap[i2], e2.depth) && i2++,
                !H2(t3, n3, e2.heap[i2], e2.depth));

              )
                (e2.heap[r2] = e2.heap[i2]), (r2 = i2), (i2 <<= 1)
              e2.heap[r2] = n3
            }
            function K(e2, t3, r2) {
              var n3,
                i2,
                s3,
                a2,
                o2 = 0
              if (e2.last_lit !== 0)
                for (
                  ;
                  (n3 = (e2.pending_buf[e2.d_buf + 2 * o2] << 8) | e2.pending_buf[e2.d_buf + 2 * o2 + 1]),
                    (i2 = e2.pending_buf[e2.l_buf + o2]),
                    o2++,
                    n3 === 0
                      ? L2(e2, i2, t3)
                      : (L2(e2, (s3 = A[i2]) + u + 1, t3),
                        (a2 = w2[s3]) !== 0 && P2(e2, (i2 -= I[s3]), a2),
                        L2(e2, (s3 = N(--n3)), r2),
                        (a2 = k[s3]) !== 0 && P2(e2, (n3 -= T[s3]), a2)),
                    o2 < e2.last_lit;

                );
              L2(e2, m2, t3)
            }
            function Y2(e2, t3) {
              var r2,
                n3,
                i2,
                s3 = t3.dyn_tree,
                a2 = t3.stat_desc.static_tree,
                o2 = t3.stat_desc.has_stree,
                h3 = t3.stat_desc.elems,
                u2 = -1
              for (e2.heap_len = 0, e2.heap_max = _2, r2 = 0; r2 < h3; r2++)
                s3[2 * r2] !== 0 ? ((e2.heap[++e2.heap_len] = u2 = r2), (e2.depth[r2] = 0)) : (s3[2 * r2 + 1] = 0)
              for (; e2.heap_len < 2; )
                (s3[2 * (i2 = e2.heap[++e2.heap_len] = u2 < 2 ? ++u2 : 0)] = 1),
                  (e2.depth[i2] = 0),
                  e2.opt_len--,
                  o2 && (e2.static_len -= a2[2 * i2 + 1])
              for (t3.max_code = u2, r2 = e2.heap_len >> 1; 1 <= r2; r2--) G(e2, s3, r2)
              for (
                i2 = h3;
                (r2 = e2.heap[1]),
                  (e2.heap[1] = e2.heap[e2.heap_len--]),
                  G(e2, s3, 1),
                  (n3 = e2.heap[1]),
                  (e2.heap[--e2.heap_max] = r2),
                  (e2.heap[--e2.heap_max] = n3),
                  (s3[2 * i2] = s3[2 * r2] + s3[2 * n3]),
                  (e2.depth[i2] = (e2.depth[r2] >= e2.depth[n3] ? e2.depth[r2] : e2.depth[n3]) + 1),
                  (s3[2 * r2 + 1] = s3[2 * n3 + 1] = i2),
                  (e2.heap[1] = i2++),
                  G(e2, s3, 1),
                  2 <= e2.heap_len;

              );
              ;(e2.heap[--e2.heap_max] = e2.heap[1]),
                (function (e3, t4) {
                  var r3,
                    n4,
                    i3,
                    s4,
                    a3,
                    o3,
                    h4 = t4.dyn_tree,
                    u3 = t4.max_code,
                    l2 = t4.stat_desc.static_tree,
                    f2 = t4.stat_desc.has_stree,
                    c2 = t4.stat_desc.extra_bits,
                    d3 = t4.stat_desc.extra_base,
                    p2 = t4.stat_desc.max_length,
                    m3 = 0
                  for (s4 = 0; s4 <= g; s4++) e3.bl_count[s4] = 0
                  for (h4[2 * e3.heap[e3.heap_max] + 1] = 0, r3 = e3.heap_max + 1; r3 < _2; r3++)
                    p2 < (s4 = h4[2 * h4[2 * (n4 = e3.heap[r3]) + 1] + 1] + 1) && ((s4 = p2), m3++),
                      (h4[2 * n4 + 1] = s4),
                      u3 < n4 ||
                        (e3.bl_count[s4]++,
                        (a3 = 0),
                        d3 <= n4 && (a3 = c2[n4 - d3]),
                        (o3 = h4[2 * n4]),
                        (e3.opt_len += o3 * (s4 + a3)),
                        f2 && (e3.static_len += o3 * (l2[2 * n4 + 1] + a3)))
                  if (m3 !== 0) {
                    do {
                      for (s4 = p2 - 1; e3.bl_count[s4] === 0; ) s4--
                      e3.bl_count[s4]--, (e3.bl_count[s4 + 1] += 2), e3.bl_count[p2]--, (m3 -= 2)
                    } while (0 < m3)
                    for (s4 = p2; s4 !== 0; s4--)
                      for (n4 = e3.bl_count[s4]; n4 !== 0; )
                        u3 < (i3 = e3.heap[--r3]) ||
                          (h4[2 * i3 + 1] !== s4 &&
                            ((e3.opt_len += (s4 - h4[2 * i3 + 1]) * h4[2 * i3]), (h4[2 * i3 + 1] = s4)),
                          n4--)
                  }
                })(e2, t3),
                Z(s3, u2, e2.bl_count)
            }
            function X(e2, t3, r2) {
              var n3,
                i2,
                s3 = -1,
                a2 = t3[1],
                o2 = 0,
                h3 = 7,
                u2 = 4
              for (a2 === 0 && ((h3 = 138), (u2 = 3)), t3[2 * (r2 + 1) + 1] = 65535, n3 = 0; n3 <= r2; n3++)
                (i2 = a2),
                  (a2 = t3[2 * (n3 + 1) + 1]),
                  (++o2 < h3 && i2 === a2) ||
                    (o2 < u2
                      ? (e2.bl_tree[2 * i2] += o2)
                      : i2 !== 0
                      ? (i2 !== s3 && e2.bl_tree[2 * i2]++, e2.bl_tree[2 * b]++)
                      : o2 <= 10
                      ? e2.bl_tree[2 * v]++
                      : e2.bl_tree[2 * y2]++,
                    (s3 = i2),
                    (u2 = (o2 = 0) === a2 ? ((h3 = 138), 3) : i2 === a2 ? ((h3 = 6), 3) : ((h3 = 7), 4)))
            }
            function V(e2, t3, r2) {
              var n3,
                i2,
                s3 = -1,
                a2 = t3[1],
                o2 = 0,
                h3 = 7,
                u2 = 4
              for (a2 === 0 && ((h3 = 138), (u2 = 3)), n3 = 0; n3 <= r2; n3++)
                if (((i2 = a2), (a2 = t3[2 * (n3 + 1) + 1]), !(++o2 < h3 && i2 === a2))) {
                  if (o2 < u2) for (; L2(e2, i2, e2.bl_tree), --o2 != 0; );
                  else
                    i2 !== 0
                      ? (i2 !== s3 && (L2(e2, i2, e2.bl_tree), o2--), L2(e2, b, e2.bl_tree), P2(e2, o2 - 3, 2))
                      : o2 <= 10
                      ? (L2(e2, v, e2.bl_tree), P2(e2, o2 - 3, 3))
                      : (L2(e2, y2, e2.bl_tree), P2(e2, o2 - 11, 7))
                  ;(s3 = i2), (u2 = (o2 = 0) === a2 ? ((h3 = 138), 3) : i2 === a2 ? ((h3 = 6), 3) : ((h3 = 7), 4))
                }
            }
            n2(T)
            var q = false
            function J(e2, t3, r2, n3) {
              P2(e2, (s2 << 1) + (n3 ? 1 : 0), 3),
                (function (e3, t4, r3, n4) {
                  M2(e3),
                    n4 && (U2(e3, r3), U2(e3, ~r3)),
                    i.arraySet(e3.pending_buf, e3.window, t4, r3, e3.pending),
                    (e3.pending += r3)
                })(e2, t3, r2, true)
            }
            ;(r._tr_init = function (e2) {
              q ||
                ((function () {
                  var e3,
                    t3,
                    r2,
                    n3,
                    i2,
                    s3 = new Array(g + 1)
                  for (n3 = r2 = 0; n3 < a - 1; n3++) for (I[n3] = r2, e3 = 0; e3 < 1 << w2[n3]; e3++) A[r2++] = n3
                  for (A[r2 - 1] = n3, n3 = i2 = 0; n3 < 16; n3++)
                    for (T[n3] = i2, e3 = 0; e3 < 1 << k[n3]; e3++) E[i2++] = n3
                  for (i2 >>= 7; n3 < f; n3++)
                    for (T[n3] = i2 << 7, e3 = 0; e3 < 1 << (k[n3] - 7); e3++) E[256 + i2++] = n3
                  for (t3 = 0; t3 <= g; t3++) s3[t3] = 0
                  for (e3 = 0; e3 <= 143; ) (z[2 * e3 + 1] = 8), e3++, s3[8]++
                  for (; e3 <= 255; ) (z[2 * e3 + 1] = 9), e3++, s3[9]++
                  for (; e3 <= 279; ) (z[2 * e3 + 1] = 7), e3++, s3[7]++
                  for (; e3 <= 287; ) (z[2 * e3 + 1] = 8), e3++, s3[8]++
                  for (Z(z, l + 1, s3), e3 = 0; e3 < f; e3++) (C[2 * e3 + 1] = 5), (C[2 * e3] = j(e3, 5))
                  ;(O = new D2(z, w2, u + 1, l, g)), (B = new D2(C, k, 0, f, g)), (R = new D2(new Array(0), x, 0, c, p))
                })(),
                (q = true)),
                (e2.l_desc = new F(e2.dyn_ltree, O)),
                (e2.d_desc = new F(e2.dyn_dtree, B)),
                (e2.bl_desc = new F(e2.bl_tree, R)),
                (e2.bi_buf = 0),
                (e2.bi_valid = 0),
                W2(e2)
            }),
              (r._tr_stored_block = J),
              (r._tr_flush_block = function (e2, t3, r2, n3) {
                var i2,
                  s3,
                  a2 = 0
                0 < e2.level
                  ? (e2.strm.data_type === 2 &&
                      (e2.strm.data_type = (function (e3) {
                        var t4,
                          r3 = 4093624447
                        for (t4 = 0; t4 <= 31; t4++, r3 >>>= 1) if (1 & r3 && e3.dyn_ltree[2 * t4] !== 0) return o
                        if (e3.dyn_ltree[18] !== 0 || e3.dyn_ltree[20] !== 0 || e3.dyn_ltree[26] !== 0) return h2
                        for (t4 = 32; t4 < u; t4++) if (e3.dyn_ltree[2 * t4] !== 0) return h2
                        return o
                      })(e2)),
                    Y2(e2, e2.l_desc),
                    Y2(e2, e2.d_desc),
                    (a2 = (function (e3) {
                      var t4
                      for (
                        X(e3, e3.dyn_ltree, e3.l_desc.max_code),
                          X(e3, e3.dyn_dtree, e3.d_desc.max_code),
                          Y2(e3, e3.bl_desc),
                          t4 = c - 1;
                        3 <= t4 && e3.bl_tree[2 * S2[t4] + 1] === 0;
                        t4--
                      );
                      return (e3.opt_len += 3 * (t4 + 1) + 5 + 5 + 4), t4
                    })(e2)),
                    (i2 = (e2.opt_len + 3 + 7) >>> 3),
                    (s3 = (e2.static_len + 3 + 7) >>> 3) <= i2 && (i2 = s3))
                  : (i2 = s3 = r2 + 5),
                  r2 + 4 <= i2 && t3 !== -1
                    ? J(e2, t3, r2, n3)
                    : e2.strategy === 4 || s3 === i2
                    ? (P2(e2, 2 + (n3 ? 1 : 0), 3), K(e2, z, C))
                    : (P2(e2, 4 + (n3 ? 1 : 0), 3),
                      (function (e3, t4, r3, n4) {
                        var i3
                        for (P2(e3, t4 - 257, 5), P2(e3, r3 - 1, 5), P2(e3, n4 - 4, 4), i3 = 0; i3 < n4; i3++)
                          P2(e3, e3.bl_tree[2 * S2[i3] + 1], 3)
                        V(e3, e3.dyn_ltree, t4 - 1), V(e3, e3.dyn_dtree, r3 - 1)
                      })(e2, e2.l_desc.max_code + 1, e2.d_desc.max_code + 1, a2 + 1),
                      K(e2, e2.dyn_ltree, e2.dyn_dtree)),
                  W2(e2),
                  n3 && M2(e2)
              }),
              (r._tr_tally = function (e2, t3, r2) {
                return (
                  (e2.pending_buf[e2.d_buf + 2 * e2.last_lit] = (t3 >>> 8) & 255),
                  (e2.pending_buf[e2.d_buf + 2 * e2.last_lit + 1] = 255 & t3),
                  (e2.pending_buf[e2.l_buf + e2.last_lit] = 255 & r2),
                  e2.last_lit++,
                  t3 === 0
                    ? e2.dyn_ltree[2 * r2]++
                    : (e2.matches++, t3--, e2.dyn_ltree[2 * (A[r2] + u + 1)]++, e2.dyn_dtree[2 * N(t3)]++),
                  e2.last_lit === e2.lit_bufsize - 1
                )
              }),
              (r._tr_align = function (e2) {
                P2(e2, 2, 3),
                  L2(e2, m2, z),
                  (function (e3) {
                    e3.bi_valid === 16
                      ? (U2(e3, e3.bi_buf), (e3.bi_buf = 0), (e3.bi_valid = 0))
                      : 8 <= e3.bi_valid &&
                        ((e3.pending_buf[e3.pending++] = 255 & e3.bi_buf), (e3.bi_buf >>= 8), (e3.bi_valid -= 8))
                  })(e2)
              })
          },
          { '../utils/common': 41 },
        ],
        53: [
          function (e, t2, r) {
            t2.exports = function () {
              ;(this.input = null),
                (this.next_in = 0),
                (this.avail_in = 0),
                (this.total_in = 0),
                (this.output = null),
                (this.next_out = 0),
                (this.avail_out = 0),
                (this.total_out = 0),
                (this.msg = ''),
                (this.state = null),
                (this.data_type = 2),
                (this.adler = 0)
            }
          },
          {},
        ],
        54: [
          function (e, t2, r) {
            ;(function (e2) {
              !(function (r2, n2) {
                if (!r2.setImmediate) {
                  var i,
                    s2,
                    t3,
                    a,
                    o = 1,
                    h2 = {},
                    u = false,
                    l = r2.document,
                    e3 = Object.getPrototypeOf && Object.getPrototypeOf(r2)
                  ;(e3 = e3 && e3.setTimeout ? e3 : r2),
                    (i =
                      {}.toString.call(r2.process) === '[object process]'
                        ? function (e4) {
                            process.nextTick(function () {
                              c(e4)
                            })
                          }
                        : (function () {
                            if (r2.postMessage && !r2.importScripts) {
                              var e4 = true,
                                t4 = r2.onmessage
                              return (
                                (r2.onmessage = function () {
                                  e4 = false
                                }),
                                r2.postMessage('', '*'),
                                (r2.onmessage = t4),
                                e4
                              )
                            }
                          })()
                        ? ((a = 'setImmediate$' + Math.random() + '$'),
                          r2.addEventListener
                            ? r2.addEventListener('message', d2, false)
                            : r2.attachEvent('onmessage', d2),
                          function (e4) {
                            r2.postMessage(a + e4, '*')
                          })
                        : r2.MessageChannel
                        ? (((t3 = new MessageChannel()).port1.onmessage = function (e4) {
                            c(e4.data)
                          }),
                          function (e4) {
                            t3.port2.postMessage(e4)
                          })
                        : l && 'onreadystatechange' in l.createElement('script')
                        ? ((s2 = l.documentElement),
                          function (e4) {
                            var t4 = l.createElement('script')
                            ;(t4.onreadystatechange = function () {
                              c(e4), (t4.onreadystatechange = null), s2.removeChild(t4), (t4 = null)
                            }),
                              s2.appendChild(t4)
                          })
                        : function (e4) {
                            setTimeout(c, 0, e4)
                          }),
                    (e3.setImmediate = function (e4) {
                      typeof e4 != 'function' && (e4 = new Function('' + e4))
                      for (var t4 = new Array(arguments.length - 1), r3 = 0; r3 < t4.length; r3++)
                        t4[r3] = arguments[r3 + 1]
                      var n3 = { callback: e4, args: t4 }
                      return (h2[o] = n3), i(o), o++
                    }),
                    (e3.clearImmediate = f)
                }
                function f(e4) {
                  delete h2[e4]
                }
                function c(e4) {
                  if (u) setTimeout(c, 0, e4)
                  else {
                    var t4 = h2[e4]
                    if (t4) {
                      u = true
                      try {
                        !(function (e5) {
                          var t5 = e5.callback,
                            r3 = e5.args
                          switch (r3.length) {
                            case 0:
                              t5()
                              break
                            case 1:
                              t5(r3[0])
                              break
                            case 2:
                              t5(r3[0], r3[1])
                              break
                            case 3:
                              t5(r3[0], r3[1], r3[2])
                              break
                            default:
                              t5.apply(n2, r3)
                          }
                        })(t4)
                      } finally {
                        f(e4), (u = false)
                      }
                    }
                  }
                }
                function d2(e4) {
                  e4.source === r2 &&
                    typeof e4.data == 'string' &&
                    e4.data.indexOf(a) === 0 &&
                    c(+e4.data.slice(a.length))
                }
              })(typeof self == 'undefined' ? (e2 === void 0 ? this : e2) : self)
            }.call(
              this,
              typeof commonjsGlobal != 'undefined'
                ? commonjsGlobal
                : typeof self != 'undefined'
                ? self
                : typeof window != 'undefined'
                ? window
                : {}
            ))
          },
          {},
        ],
      },
      {},
      [10]
    )(10)
  })
})(jszip_min)
var JSZip = jszip_min.exports
var common = ''
var elevation = ''
var ripple = ''
var loading = ''
var button = ''
var ButtonSfc = ''
var context = {
  locks: {},
  zIndex: 2e3,
  touchmoveForbid: true,
}
reactive(context)
var Context = reactive(context)
var toNumber = (val) => {
  if (val == null) return 0
  if (isString$1(val)) {
    val = parseFloat(val)
    val = Number.isNaN(val) ? 0 : val
    return val
  }
  if (isBool(val)) return Number(val)
  return val
}
var isHTMLSupportImage = (val) => {
  if (val == null) {
    return false
  }
  return val.startsWith('data:image') || /\.(png|jpg|gif|jpeg|svg)$/.test(val)
}
var isHTMLSupportVideo = (val) => {
  if (val == null) {
    return false
  }
  return val.startsWith('data:video') || /\.(mp4|webm|ogg)$/.test(val)
}
var isString$1 = (val) => typeof val === 'string'
var isBool = (val) => typeof val === 'boolean'
var isNumber = (val) => typeof val === 'number'
var isPlainObject$1 = (val) => Object.prototype.toString.call(val) === '[object Object]'
var isObject = (val) => typeof val === 'object' && val !== null
var isArray$1 = (val) => Array.isArray(val)
var isURL = (val) => {
  if (!val) {
    return false
  }
  return /^(http)|(\.*\/)/.test(val)
}
var isEmpty = (val) => val === void 0 || val === null || val === '' || (Array.isArray(val) && !val.length)
var removeItem = (arr, item) => {
  if (arr.length) {
    var index2 = arr.indexOf(item)
    if (index2 > -1) {
      return arr.splice(index2, 1)
    }
  }
}
var throttle = function (method, mustRunDelay) {
  if (mustRunDelay === void 0) {
    mustRunDelay = 200
  }
  var timer
  var start = 0
  return function loop() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key]
    }
    var now = Date.now()
    var elapsed = now - start
    if (!start) {
      start = now
    }
    if (timer) {
      window.clearTimeout(timer)
    }
    if (elapsed >= mustRunDelay) {
      method.apply(this, args)
      start = now
    } else {
      timer = window.setTimeout(() => {
        loop.apply(this, args)
      }, mustRunDelay - elapsed)
    }
  }
}
var createCache = (max2) => {
  var cache2 = []
  return {
    cache: cache2,
    has(key) {
      return this.cache.includes(key)
    },
    add(key) {
      if (this.has(key)) {
        return
      }
      this.cache.length === max2 && cache2.shift()
      this.cache.push(key)
    },
    remove(key) {
      this.has(key) && removeItem(this.cache, key)
    },
    clear() {
      this.cache.length = 0
    },
  }
}
var linear = (value) => value
var cubic = (value) => Math.pow(value, 3)
var easeInOutCubic = (value) => (value < 0.5 ? cubic(value * 2) / 2 : 1 - cubic((1 - value) * 2) / 2)
function parseFormat(format, time) {
  var scannedTimes = Object.values(time)
  var scannedFormats = ['DD', 'HH', 'mm', 'ss']
  var padValues = [24, 60, 60, 1e3]
  scannedFormats.forEach((scannedFormat, index2) => {
    if (!format.includes(scannedFormat)) {
      scannedTimes[index2 + 1] += scannedTimes[index2] * padValues[index2]
    } else {
      format = format.replace(scannedFormat, String(scannedTimes[index2]).padStart(2, '0'))
    }
  })
  if (format.includes('S')) {
    var ms2 = String(scannedTimes[scannedTimes.length - 1]).padStart(3, '0')
    if (format.includes('SSS')) {
      format = format.replace('SSS', ms2)
    } else if (format.includes('SS')) {
      format = format.replace('SS', ms2.slice(0, 2))
    } else {
      format = format.replace('S', ms2.slice(0, 1))
    }
  }
  return format
}
var dt = (value, defaultText) => (value == null ? defaultText : value)
var inBrowser = () => typeof window !== 'undefined'
var uniq = (arr) => [...new Set(arr)]
function kebabCase$1(str) {
  var ret = str.replace(/([A-Z])/g, ' $1').trim()
  return ret.split(' ').join('-').toLowerCase()
}
function asyncGeneratorStep$d(gen, resolve2, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg)
    var value = info.value
  } catch (error) {
    reject(error)
    return
  }
  if (info.done) {
    resolve2(value)
  } else {
    Promise.resolve(value).then(_next, _throw)
  }
}
function _asyncToGenerator$d(fn) {
  return function () {
    var self2 = this,
      args = arguments
    return new Promise(function (resolve2, reject) {
      var gen = fn.apply(self2, args)
      function _next(value) {
        asyncGeneratorStep$d(gen, resolve2, reject, _next, _throw, 'next', value)
      }
      function _throw(err) {
        asyncGeneratorStep$d(gen, resolve2, reject, _next, _throw, 'throw', err)
      }
      _next(void 0)
    })
  }
}
function getLeft(element) {
  var { left } = element.getBoundingClientRect()
  return left + (document.body.scrollLeft || document.documentElement.scrollLeft)
}
function getTop(element) {
  var { top } = element.getBoundingClientRect()
  return top + (document.body.scrollTop || document.documentElement.scrollTop)
}
function getScrollTop(element) {
  var top = 'scrollTop' in element ? element.scrollTop : element.pageYOffset
  return Math.max(top, 0)
}
function getScrollLeft(element) {
  var left = 'scrollLeft' in element ? element.scrollLeft : element.pageXOffset
  return Math.max(left, 0)
}
function inViewport(_x) {
  return _inViewport.apply(this, arguments)
}
function _inViewport() {
  _inViewport = _asyncToGenerator$d(function* (element) {
    yield doubleRaf()
    var { top, bottom, left, right } = element.getBoundingClientRect()
    var { innerWidth, innerHeight } = window
    var xInViewport = left <= innerWidth && right >= 0
    var yInViewport = top <= innerHeight && bottom >= 0
    return xInViewport && yInViewport
  })
  return _inViewport.apply(this, arguments)
}
function getTranslate(el) {
  var { transform } = window.getComputedStyle(el)
  return +transform.slice(transform.lastIndexOf(',') + 2, transform.length - 1)
}
function getParentScroller(el) {
  var element = el
  while (element) {
    if (!element.parentNode) {
      break
    }
    element = element.parentNode
    if (element === document.body || element === document.documentElement) {
      break
    }
    var scrollRE = /(scroll|auto)/
    var { overflowY, overflow } = window.getComputedStyle(element)
    if (scrollRE.test(overflowY) || scrollRE.test(overflow)) {
      return element
    }
  }
  return window
}
function getAllParentScroller(el) {
  var allParentScroller = []
  var element = el
  while (element !== window) {
    element = getParentScroller(element)
    allParentScroller.push(element)
  }
  return allParentScroller
}
var isRem = (value) => isString$1(value) && value.endsWith('rem')
var isPx = (value) => (isString$1(value) && value.endsWith('px')) || isNumber(value)
var isPercent = (value) => isString$1(value) && value.endsWith('%')
var isVw = (value) => isString$1(value) && value.endsWith('vw')
var isVh = (value) => isString$1(value) && value.endsWith('vh')
var toPxNum = (value) => {
  if (isNumber(value)) {
    return value
  }
  if (isPx(value)) {
    return +value.replace('px', '')
  }
  if (isVw(value)) {
    return (+value.replace('vw', '') * window.innerWidth) / 100
  }
  if (isVh(value)) {
    return (+value.replace('vh', '') * window.innerHeight) / 100
  }
  if (isRem(value)) {
    var num = +value.replace('rem', '')
    var rootFontSize = window.getComputedStyle(document.documentElement).fontSize
    return num * parseFloat(rootFontSize)
  }
  if (isString$1(value)) {
    return toNumber(value)
  }
  return 0
}
var toSizeUnit = (value) => {
  if (value == null) {
    return void 0
  }
  if (isPercent(value) || isVw(value) || isVh(value) || isRem(value)) {
    return value
  }
  return toPxNum(value) + 'px'
}
var multiplySizeUnit = function (value, quantity) {
  if (quantity === void 0) {
    quantity = 1
  }
  if (value == null) {
    return void 0
  }
  var legalSize = toSizeUnit(value)
  var unit = legalSize.match(/(vh|%|rem|px|vw)$/)[0]
  return '' + parseFloat(legalSize) * quantity + unit
}
function requestAnimationFrame(fn) {
  return globalThis.requestAnimationFrame ? globalThis.requestAnimationFrame(fn) : globalThis.setTimeout(fn, 16)
}
function cancelAnimationFrame(handle) {
  globalThis.cancelAnimationFrame ? globalThis.cancelAnimationFrame(handle) : globalThis.clearTimeout(handle)
}
function nextTickFrame(fn) {
  requestAnimationFrame(() => {
    requestAnimationFrame(fn)
  })
}
function doubleRaf() {
  return new Promise((resolve2) => {
    requestAnimationFrame(() => {
      requestAnimationFrame(resolve2)
    })
  })
}
function scrollTo(element, _ref) {
  var { top = 0, left = 0, duration = 300, animation } = _ref
  var startTime = Date.now()
  var scrollTop = getScrollTop(element)
  var scrollLeft = getScrollLeft(element)
  return new Promise((resolve2) => {
    var frame = () => {
      var progress = (Date.now() - startTime) / duration
      if (progress < 1) {
        var nextTop = scrollTop + (top - scrollTop) * animation(progress)
        var nextLeft = scrollLeft + (left - scrollLeft) * animation(progress)
        element.scrollTo(nextLeft, nextTop)
        requestAnimationFrame(frame)
      } else {
        element.scrollTo(left, top)
        resolve2()
      }
    }
    requestAnimationFrame(frame)
  })
}
function formatStyleVars(styleVars) {
  return Object.entries(styleVars != null ? styleVars : {}).reduce((styles, _ref2) => {
    var [key, value] = _ref2
    var cssVar = key.startsWith('--') ? key : '--' + kebabCase$1(key)
    styles[cssVar] = value
    return styles
  }, {})
}
function supportTouch() {
  var inBrowser2 = typeof window !== 'undefined'
  return inBrowser2 && 'ontouchstart' in window
}
var _excluded = ['collect', 'clear']
function asyncGeneratorStep$c(gen, resolve2, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg)
    var value = info.value
  } catch (error) {
    reject(error)
    return
  }
  if (info.done) {
    resolve2(value)
  } else {
    Promise.resolve(value).then(_next, _throw)
  }
}
function _asyncToGenerator$c(fn) {
  return function () {
    var self2 = this,
      args = arguments
    return new Promise(function (resolve2, reject) {
      var gen = fn.apply(self2, args)
      function _next(value) {
        asyncGeneratorStep$c(gen, resolve2, reject, _next, _throw, 'next', value)
      }
      function _throw(err) {
        asyncGeneratorStep$c(gen, resolve2, reject, _next, _throw, 'throw', err)
      }
      _next(void 0)
    })
  }
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {}
  var target = {}
  var sourceKeys = Object.keys(source)
  var key, i
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i]
    if (excluded.indexOf(key) >= 0) continue
    target[key] = source[key]
  }
  return target
}
function _extends$d() {
  _extends$d =
    Object.assign ||
    function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i]
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key]
          }
        }
      }
      return target
    }
  return _extends$d.apply(this, arguments)
}
function pickProps(props2, propsKey) {
  return Array.isArray(propsKey)
    ? propsKey.reduce((pickedProps, key) => {
        pickedProps[key] = props2[key]
        return pickedProps
      }, {})
    : props2[propsKey]
}
function mount(component) {
  var app = createApp(component)
  var host = document.createElement('div')
  document.body.appendChild(host)
  return {
    instance: app.mount(host),
    unmount() {
      app.unmount()
      document.body.removeChild(host)
    },
  }
}
function mountInstance(component, props2, eventListener) {
  if (props2 === void 0) {
    props2 = {}
  }
  if (eventListener === void 0) {
    eventListener = {}
  }
  var Host = {
    setup() {
      return () => h$1(component, _extends$d({}, props2, eventListener))
    },
  }
  var { unmount } = mount(Host)
  return {
    unmountInstance: unmount,
  }
}
function flatVNodes(subTree) {
  var vNodes = []
  var flat = (subTree2) => {
    if (subTree2 != null && subTree2.component) {
      flat(subTree2 == null ? void 0 : subTree2.component.subTree)
      return
    }
    if (Array.isArray(subTree2 == null ? void 0 : subTree2.children)) {
      subTree2.children.forEach((child) => {
        if (isVNode(child)) {
          vNodes.push(child)
          flat(child)
        }
      })
    }
  }
  flat(subTree)
  return vNodes
}
function useAtChildrenCounter(key) {
  var instances = reactive([])
  var parentInstance = getCurrentInstance()
  var sortInstances = () => {
    var vNodes = flatVNodes(parentInstance.subTree)
    instances.sort((a, b) => {
      return vNodes.indexOf(a.vnode) - vNodes.indexOf(b.vnode)
    })
  }
  var collect = (instance) => {
    instances.push(instance)
    sortInstances()
  }
  var clear2 = (instance) => {
    removeItem(instances, instance)
  }
  provide(key, {
    collect,
    clear: clear2,
    instances,
  })
  var length = computed(() => instances.length)
  return {
    length,
  }
}
function useAtParentIndex(key) {
  if (!keyInProvides(key)) {
    return {
      index: null,
    }
  }
  var childrenCounter = inject(key)
  var { collect, clear: clear2, instances } = childrenCounter
  var instance = getCurrentInstance()
  onMounted(() => {
    nextTick().then(() => collect(instance))
  })
  onUnmounted(() => {
    nextTick().then(() => clear2(instance))
  })
  var index2 = computed(() => instances.indexOf(instance))
  return {
    index: index2,
  }
}
function useChildren(key) {
  var childProviders = []
  var collect = (childProvider) => {
    childProviders.push(childProvider)
  }
  var clear2 = (childProvider) => {
    removeItem(childProviders, childProvider)
  }
  var bindChildren = (parentProvider) => {
    provide(
      key,
      _extends$d(
        {
          collect,
          clear: clear2,
        },
        parentProvider
      )
    )
  }
  return {
    childProviders,
    bindChildren,
  }
}
function useParent(key) {
  if (!keyInProvides(key)) {
    return {
      parentProvider: null,
      bindParent: null,
    }
  }
  var rawParentProvider = inject(key)
  var { collect, clear: clear2 } = rawParentProvider,
    parentProvider = _objectWithoutPropertiesLoose(rawParentProvider, _excluded)
  var bindParent = (childProvider) => {
    onMounted(() => collect(childProvider))
    onBeforeUnmount(() => clear2(childProvider))
  }
  return {
    parentProvider,
    bindParent,
  }
}
function keyInProvides(key) {
  var instance = getCurrentInstance()
  return key in instance.provides
}
function useValidation() {
  var errorMessage = ref('')
  var validate2 = /* @__PURE__ */ (function () {
    var _ref = _asyncToGenerator$c(function* (rules, value, apis) {
      if (!isArray$1(rules) || !rules.length) {
        return true
      }
      var resArr = yield Promise.all(rules.map((rule) => rule(value, apis)))
      return !resArr.some((res) => {
        if (res !== true) {
          errorMessage.value = String(res)
          return true
        }
        return false
      })
    })
    return function validate3(_x, _x2, _x3) {
      return _ref.apply(this, arguments)
    }
  })()
  var resetValidation = () => {
    errorMessage.value = ''
  }
  var validateWithTrigger = /* @__PURE__ */ (function () {
    var _ref2 = _asyncToGenerator$c(function* (validateTrigger, trigger, rules, value, apis) {
      if (validateTrigger.includes(trigger)) {
        ;(yield validate2(rules, value, apis)) && (errorMessage.value = '')
      }
    })
    return function validateWithTrigger2(_x4, _x5, _x6, _x7, _x8) {
      return _ref2.apply(this, arguments)
    }
  })()
  return {
    errorMessage,
    validate: validate2,
    resetValidation,
    validateWithTrigger,
  }
}
function addRouteListener(cb) {
  onMounted(() => {
    window.addEventListener('hashchange', cb)
    window.addEventListener('popstate', cb)
  })
  onUnmounted(() => {
    window.removeEventListener('hashchange', cb)
    window.removeEventListener('popstate', cb)
  })
}
function useTeleport() {
  var disabled = ref(false)
  onActivated(() => {
    disabled.value = false
  })
  onDeactivated(() => {
    disabled.value = true
  })
  return {
    disabled,
  }
}
function exposeApis(apis) {
  var instance = getCurrentInstance()
  if (instance) {
    Object.assign(instance.proxy, apis)
  }
}
function createNamespace(name) {
  var namespace = 'var-' + name
  var createBEM = (suffix) => {
    if (!suffix) return namespace
    return suffix.startsWith('--') ? '' + namespace + suffix : namespace + '__' + suffix
  }
  var classes2 = function () {
    for (var _len = arguments.length, classes3 = new Array(_len), _key = 0; _key < _len; _key++) {
      classes3[_key] = arguments[_key]
    }
    return classes3.map((className) => {
      if (isArray$1(className)) {
        var [condition, truthy, falsy = null] = className
        return condition ? truthy : falsy
      }
      return className
    })
  }
  return {
    n: createBEM,
    classes: classes2,
  }
}
function call(fn) {
  for (var _len2 = arguments.length, arg = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    arg[_key2 - 1] = arguments[_key2]
  }
  if (fn) return fn(...arg)
}
function _extends$c() {
  _extends$c =
    Object.assign ||
    function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i]
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key]
          }
        }
      }
      return target
    }
  return _extends$c.apply(this, arguments)
}
var { n: n$12 } = createNamespace('ripple')
var ANIMATION_DURATION$1 = 250
function setStyles(element) {
  var { zIndex, position } = window.getComputedStyle(element)
  element.style.overflow = 'hidden'
  element.style.overflowX = 'hidden'
  element.style.overflowY = 'hidden'
  position === 'static' && (element.style.position = 'relative')
  zIndex === 'auto' && (element.style.zIndex = '1')
}
function computeRippleStyles(element, event) {
  var { top, left } = element.getBoundingClientRect()
  var { clientWidth, clientHeight } = element
  var radius = Math.sqrt(Math.pow(clientWidth, 2) + Math.pow(clientHeight, 2)) / 2
  var size = radius * 2
  var localX = event.touches[0].clientX - left
  var localY = event.touches[0].clientY - top
  var centerX = (clientWidth - radius * 2) / 2
  var centerY = (clientHeight - radius * 2) / 2
  var x = localX - radius
  var y2 = localY - radius
  return {
    x,
    y: y2,
    centerX,
    centerY,
    size,
  }
}
function createRipple(event) {
  var _ripple = this._ripple
  _ripple.removeRipple()
  if (_ripple.disabled || _ripple.tasker) {
    return
  }
  var task = () => {
    _ripple.tasker = null
    var { x, y: y2, centerX, centerY, size } = computeRippleStyles(this, event)
    var ripple2 = document.createElement('div')
    ripple2.classList.add(n$12())
    ripple2.style.opacity = '0'
    ripple2.style.transform = 'translate(' + x + 'px, ' + y2 + 'px) scale3d(.3, .3, .3)'
    ripple2.style.width = size + 'px'
    ripple2.style.height = size + 'px'
    _ripple.color && (ripple2.style.backgroundColor = _ripple.color)
    ripple2.dataset.createdAt = String(performance.now())
    setStyles(this)
    this.appendChild(ripple2)
    window.setTimeout(() => {
      ripple2.style.transform = 'translate(' + centerX + 'px, ' + centerY + 'px) scale3d(1, 1, 1)'
      ripple2.style.opacity = '.25'
    }, 20)
  }
  _ripple.tasker = window.setTimeout(task, 60)
}
function removeRipple() {
  var _ripple = this._ripple
  var task = () => {
    var ripples = this.querySelectorAll('.' + n$12())
    if (!ripples.length) {
      return
    }
    var lastRipple = ripples[ripples.length - 1]
    var delay = ANIMATION_DURATION$1 - performance.now() + Number(lastRipple.dataset.createdAt)
    setTimeout(() => {
      lastRipple.style.opacity = '0'
      setTimeout(() => {
        var _lastRipple$parentNod
        return (_lastRipple$parentNod = lastRipple.parentNode) == null
          ? void 0
          : _lastRipple$parentNod.removeChild(lastRipple)
      }, ANIMATION_DURATION$1)
    }, delay)
  }
  _ripple.tasker ? setTimeout(task, 60) : task()
}
function forbidRippleTask() {
  var _ripple = this._ripple
  if (!supportTouch()) {
    return
  }
  if (!_ripple.touchmoveForbid) {
    return
  }
  _ripple.tasker && window.clearTimeout(_ripple.tasker)
  _ripple.tasker = null
}
function mounted$1(el, binding2) {
  var _binding$value, _binding$value$touchm, _binding$value2
  el._ripple = _extends$c(
    {
      tasker: null,
    },
    (_binding$value = binding2.value) != null ? _binding$value : {},
    {
      touchmoveForbid:
        (_binding$value$touchm =
          (_binding$value2 = binding2.value) == null ? void 0 : _binding$value2.touchmoveForbid) != null
          ? _binding$value$touchm
          : Context.touchmoveForbid,
      removeRipple: removeRipple.bind(el),
    }
  )
  el.addEventListener('touchstart', createRipple, {
    passive: true,
  })
  el.addEventListener('touchmove', forbidRippleTask, {
    passive: true,
  })
  el.addEventListener('dragstart', removeRipple, {
    passive: true,
  })
  document.addEventListener('touchend', el._ripple.removeRipple, {
    passive: true,
  })
  document.addEventListener('touchcancel', el._ripple.removeRipple, {
    passive: true,
  })
}
function unmounted(el) {
  el.removeEventListener('touchstart', createRipple)
  el.removeEventListener('touchmove', forbidRippleTask)
  el.removeEventListener('dragstart', removeRipple)
  document.removeEventListener('touchend', el._ripple.removeRipple)
  document.removeEventListener('touchcancel', el._ripple.removeRipple)
}
function updated$1(el, binding2) {
  var _binding$value3, _binding$value$touchm2, _binding$value4
  if (el._ripple.tasker) {
    el._ripple.removeRipple()
  }
  el._ripple = _extends$c({}, el._ripple, (_binding$value3 = binding2.value) != null ? _binding$value3 : {}, {
    touchmoveForbid:
      (_binding$value$touchm2 =
        (_binding$value4 = binding2.value) == null ? void 0 : _binding$value4.touchmoveForbid) != null
        ? _binding$value$touchm2
        : Context.touchmoveForbid,
    tasker: null,
  })
}
var Ripple = {
  mounted: mounted$1,
  unmounted,
  updated: updated$1,
  install(app) {
    app.directive('ripple', this)
  },
}
function positionValidator$3(position) {
  return ['top', 'bottom', 'right', 'left', 'center'].includes(position)
}
var props$U = {
  show: {
    type: Boolean,
    default: false,
  },
  position: {
    type: String,
    default: 'center',
    validator: positionValidator$3,
  },
  transition: {
    type: String,
  },
  overlay: {
    type: Boolean,
    default: true,
  },
  overlayClass: {
    type: String,
  },
  overlayStyle: {
    type: Object,
  },
  lockScroll: {
    type: Boolean,
    default: true,
  },
  closeOnClickOverlay: {
    type: Boolean,
    default: true,
  },
  teleport: {
    type: String,
  },
  onOpen: {
    type: Function,
  },
  onOpened: {
    type: Function,
  },
  onClose: {
    type: Function,
  },
  onClosed: {
    type: Function,
  },
  onClickOverlay: {
    type: Function,
  },
  onRouteChange: {
    type: Function,
  },
  'onUpdate:show': {
    type: Function,
  },
}
function resolveLock() {
  var lockCounts = Object.keys(Context.locks).length
  lockCounts <= 0 ? document.body.classList.remove('var--lock') : document.body.classList.add('var--lock')
}
function addLock(uid2) {
  Context.locks[uid2] = 1
  resolveLock()
}
function releaseLock(uid2) {
  delete Context.locks[uid2]
  resolveLock()
}
function useLock(source, useSource) {
  var { uid: uid2 } = getCurrentInstance()
  if (useSource) {
    watch(useSource, (newValue) => {
      if (newValue === false) {
        releaseLock(uid2)
      } else if (newValue === true && source() === true) {
        addLock(uid2)
      }
    })
  }
  watch(source, (newValue) => {
    if (useSource && useSource() === false) {
      return
    }
    if (newValue === true) {
      addLock(uid2)
    } else {
      releaseLock(uid2)
    }
  })
  onBeforeMount(() => {
    if (useSource && useSource() === false) {
      return
    }
    if (source() === true) {
      addLock(uid2)
    }
  })
  onUnmounted(() => {
    if (useSource && useSource() === false) {
      return
    }
    if (source() === true) {
      releaseLock(uid2)
    }
  })
  onActivated(() => {
    if (useSource && useSource() === false) {
      return
    }
    if (source() === true) {
      addLock(uid2)
    }
  })
  onDeactivated(() => {
    if (useSource && useSource() === false) {
      return
    }
    if (source() === true) {
      releaseLock(uid2)
    }
  })
}
function useZIndex(source, count) {
  var zIndex = ref(Context.zIndex)
  watch(
    source,
    (newValue) => {
      if (newValue) {
        Context.zIndex += count
        zIndex.value = Context.zIndex
      }
    },
    {
      immediate: true,
    }
  )
  return {
    zIndex,
  }
}
function _extends$b() {
  _extends$b =
    Object.assign ||
    function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i]
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key]
          }
        }
      }
      return target
    }
  return _extends$b.apply(this, arguments)
}
function _isSlot$1(s2) {
  return typeof s2 === 'function' || (Object.prototype.toString.call(s2) === '[object Object]' && !isVNode(s2))
}
var { n: n$11, classes: classes$S } = createNamespace('popup')
var Popup = defineComponent({
  name: 'VarPopup',
  inheritAttrs: false,
  props: props$U,
  setup(props2, _ref) {
    var { slots, attrs } = _ref
    var { zIndex } = useZIndex(() => props2.show, 3)
    var { disabled } = useTeleport()
    var hidePopup = () => {
      var _props$onUpdateShow
      var { closeOnClickOverlay, onClickOverlay } = props2
      onClickOverlay == null ? void 0 : onClickOverlay()
      if (!closeOnClickOverlay) {
        return
      }
      ;(_props$onUpdateShow = props2['onUpdate:show']) == null ? void 0 : _props$onUpdateShow.call(props2, false)
    }
    useLock(
      () => props2.show,
      () => props2.lockScroll
    )
    watch(
      () => props2.show,
      (newValue) => {
        var { onOpen, onClose } = props2
        newValue ? (onOpen == null ? void 0 : onOpen()) : onClose == null ? void 0 : onClose()
      }
    )
    addRouteListener(() => (props2.onRouteChange == null ? void 0 : props2.onRouteChange()))
    var renderOverlay = () => {
      var { overlayClass = '', overlayStyle } = props2
      return createVNode(
        'div',
        {
          class: classes$S(n$11('overlay'), overlayClass),
          style: _extends$b(
            {
              zIndex: zIndex.value - 1,
            },
            overlayStyle
          ),
          onClick: hidePopup,
        },
        null
      )
    }
    var renderContent = () => {
      return createVNode(
        'div',
        mergeProps(
          {
            class: classes$S(n$11('content'), 'var-elevation--3', n$11('--' + props2.position)),
            style: {
              zIndex: zIndex.value,
            },
          },
          attrs
        ),
        [slots.default == null ? void 0 : slots.default()]
      )
    }
    var renderPopup = () => {
      var { onOpened, onClosed, show, overlay, transition, position } = props2
      return createVNode(
        Transition,
        {
          name: 'var-fade',
          onAfterEnter: onOpened,
          onAfterLeave: onClosed,
        },
        {
          default: () => [
            withDirectives(
              createVNode(
                'div',
                {
                  class: classes$S('var--box', n$11()),
                  style: {
                    zIndex: zIndex.value - 2,
                  },
                },
                [
                  overlay && renderOverlay(),
                  createVNode(
                    Transition,
                    {
                      name: transition || 'var-pop-' + position,
                    },
                    {
                      default: () => [show && renderContent()],
                    }
                  ),
                ]
              ),
              [[vShow, show]]
            ),
          ],
        }
      )
    }
    return () => {
      var { teleport } = props2
      if (teleport) {
        var _slot
        return createVNode(
          Teleport,
          {
            to: teleport,
            disabled: disabled.value,
          },
          _isSlot$1((_slot = renderPopup()))
            ? _slot
            : {
                default: () => [_slot],
              }
        )
      }
      return renderPopup()
    }
  },
})
Popup.install = function (app) {
  app.component(Popup.name, Popup)
}
var props$T = {
  name: {
    type: String,
  },
  size: {
    type: [Number, String],
  },
  color: {
    type: String,
  },
  namespace: {
    type: String,
    default: 'var-icon',
  },
  transition: {
    type: [Number, String],
    default: 0,
  },
  onClick: {
    type: Function,
  },
}
function asyncGeneratorStep$b(gen, resolve2, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg)
    var value = info.value
  } catch (error) {
    reject(error)
    return
  }
  if (info.done) {
    resolve2(value)
  } else {
    Promise.resolve(value).then(_next, _throw)
  }
}
function _asyncToGenerator$b(fn) {
  return function () {
    var self2 = this,
      args = arguments
    return new Promise(function (resolve2, reject) {
      var gen = fn.apply(self2, args)
      function _next(value) {
        asyncGeneratorStep$b(gen, resolve2, reject, _next, _throw, 'next', value)
      }
      function _throw(err) {
        asyncGeneratorStep$b(gen, resolve2, reject, _next, _throw, 'throw', err)
      }
      _next(void 0)
    })
  }
}
var { n: n$10, classes: classes$R } = createNamespace('icon')
function render$Z(_ctx, _cache2) {
  return (
    openBlock(),
    createBlock(
      resolveDynamicComponent(_ctx.isURL(_ctx.name) ? 'img' : 'i'),
      {
        class: normalizeClass(
          _ctx.classes(
            _ctx.n(),
            _ctx.namespace + '--set',
            [_ctx.isURL(_ctx.name), _ctx.n('image'), _ctx.namespace + '-' + _ctx.nextName],
            [_ctx.shrinking, _ctx.n('--shrinking')]
          )
        ),
        style: normalizeStyle({
          color: _ctx.color,
          transition: 'transform ' + _ctx.toNumber(_ctx.transition) + 'ms',
          width: _ctx.isURL(_ctx.name) ? _ctx.toSizeUnit(_ctx.size) : null,
          height: _ctx.isURL(_ctx.name) ? _ctx.toSizeUnit(_ctx.size) : null,
          fontSize: _ctx.toSizeUnit(_ctx.size),
        }),
        src: _ctx.isURL(_ctx.name) ? _ctx.nextName : null,
        onClick: _ctx.onClick,
      },
      null,
      8,
      ['class', 'style', 'src', 'onClick']
    )
  )
}
var Icon = defineComponent({
  render: render$Z,
  name: 'VarIcon',
  props: props$T,
  setup(props2) {
    var nextName = ref('')
    var shrinking = ref(false)
    var handleNameChange = /* @__PURE__ */ (function () {
      var _ref = _asyncToGenerator$b(function* (newName, oldName) {
        var { transition } = props2
        if (oldName == null || toNumber(transition) === 0) {
          nextName.value = newName
          return
        }
        shrinking.value = true
        yield nextTick()
        setTimeout(() => {
          oldName != null && (nextName.value = newName)
          shrinking.value = false
        }, toNumber(transition))
      })
      return function handleNameChange2(_x, _x2) {
        return _ref.apply(this, arguments)
      }
    })()
    watch(() => props2.name, handleNameChange, {
      immediate: true,
    })
    return {
      n: n$10,
      classes: classes$R,
      nextName,
      shrinking,
      isURL,
      toNumber,
      toSizeUnit,
    }
  },
})
Icon.install = function (app) {
  app.component(Icon.name, Icon)
}
function _extends$a() {
  _extends$a =
    Object.assign ||
    function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i]
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key]
          }
        }
      }
      return target
    }
  return _extends$a.apply(this, arguments)
}
var props$S = _extends$a(
  {
    show: {
      type: Boolean,
      default: false,
    },
    actions: {
      type: Array,
      default: () => [],
    },
    title: {
      type: String,
    },
    closeOnClickAction: {
      type: Boolean,
      default: true,
    },
    onSelect: {
      type: Function,
    },
    'onUpdate:show': {
      type: Function,
    },
  },
  pickProps(props$U, [
    'overlay',
    'overlayClass',
    'overlayStyle',
    'lockScroll',
    'closeOnClickOverlay',
    'teleport',
    'onOpen',
    'onClose',
    'onOpened',
    'onClosed',
    'onClickOverlay',
    'onRouteChange',
  ])
)
var zhCN = {
  dialogTitle: '\u63D0\u793A',
  dialogConfirmButtonText: '\u786E\u8BA4',
  dialogCancelButtonText: '\u53D6\u6D88',
  actionSheetTitle: '\u8BF7\u9009\u62E9',
  listLoadingText: '\u52A0\u8F7D\u4E2D',
  listFinishedText: '\u6CA1\u6709\u66F4\u591A\u4E86',
  listErrorText: '\u52A0\u8F7D\u5931\u8D25',
  pickerTitle: '\u8BF7\u9009\u62E9',
  pickerConfirmButtonText: '\u786E\u8BA4',
  pickerCancelButtonText: '\u53D6\u6D88',
  datePickerMonthDict: {
    '01': {
      name: '\u4E00\u6708',
      abbr: '\u4E00\u6708',
    },
    '02': {
      name: '\u4E8C\u6708',
      abbr: '\u4E8C\u6708',
    },
    '03': {
      name: '\u4E09\u6708',
      abbr: '\u4E09\u6708',
    },
    '04': {
      name: '\u56DB\u6708',
      abbr: '\u56DB\u6708',
    },
    '05': {
      name: '\u4E94\u6708',
      abbr: '\u4E94\u6708',
    },
    '06': {
      name: '\u516D\u6708',
      abbr: '\u516D\u6708',
    },
    '07': {
      name: '\u4E03\u6708',
      abbr: '\u4E03\u6708',
    },
    '08': {
      name: '\u516B\u6708',
      abbr: '\u516B\u6708',
    },
    '09': {
      name: '\u4E5D\u6708',
      abbr: '\u4E5D\u6708',
    },
    10: {
      name: '\u5341\u6708',
      abbr: '\u5341\u6708',
    },
    11: {
      name: '\u5341\u4E00\u6708',
      abbr: '\u5341\u4E00\u6708',
    },
    12: {
      name: '\u5341\u4E8C\u6708',
      abbr: '\u5341\u4E8C\u6708',
    },
  },
  datePickerWeekDict: {
    0: {
      name: '\u661F\u671F\u65E5',
      abbr: '\u65E5',
    },
    1: {
      name: '\u661F\u671F\u4E00',
      abbr: '\u4E00',
    },
    2: {
      name: '\u661F\u671F\u4E8C',
      abbr: '\u4E8C',
    },
    3: {
      name: '\u661F\u671F\u4E09',
      abbr: '\u4E09',
    },
    4: {
      name: '\u661F\u671F\u56DB',
      abbr: '\u56DB',
    },
    5: {
      name: '\u661F\u671F\u4E94',
      abbr: '\u4E94',
    },
    6: {
      name: '\u661F\u671F\u516D',
      abbr: '\u516D',
    },
  },
  datePickerSelected: '\u4E2A\u88AB\u9009\u62E9',
  paginationItem: '\u6761',
  paginationPage: '\u9875',
  paginationJump: '\u524D\u5F80',
}
function _extends$9() {
  _extends$9 =
    Object.assign ||
    function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i]
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key]
          }
        }
      }
      return target
    }
  return _extends$9.apply(this, arguments)
}
function useLocale() {
  var packs2 = {}
  var pack2 = ref({})
  var add2 = (lang, pack3) => {
    pack3.lang = lang
    packs2[lang] = pack3
  }
  var use2 = (lang) => {
    if (!packs2[lang]) {
      console.warn('The ' + lang + ' does not exist. You can mount a language package using the add method')
      return {}
    }
    pack2.value = packs2[lang]
  }
  var merge2 = (lang, pack3) => {
    if (!packs2[lang]) {
      console.warn('The ' + lang + ' does not exist. You can mount a language package using the add method')
      return
    }
    packs2[lang] = _extends$9({}, packs2[lang], pack3)
    use2(lang)
  }
  return {
    packs: packs2,
    pack: pack2,
    add: add2,
    use: use2,
    merge: merge2,
  }
}
var { packs, pack, add: add$2, use, merge } = useLocale()
add$2('zh-CN', zhCN)
use('zh-CN')
var { n: n$$, classes: classes$Q } = createNamespace('action-sheet')
var _hoisted_1$l = ['onClick']
function render$Y(_ctx, _cache2) {
  var _component_var_icon = resolveComponent('var-icon')
  var _component_var_popup = resolveComponent('var-popup')
  var _directive_ripple = resolveDirective('ripple')
  return (
    openBlock(),
    createBlock(
      _component_var_popup,
      mergeProps(
        {
          class: _ctx.n('popup-radius'),
          position: 'bottom',
          overlay: _ctx.overlay,
          'overlay-class': _ctx.overlayClass,
          'overlay-style': _ctx.overlayStyle,
          'lock-scroll': _ctx.lockScroll,
          'close-on-click-overlay': _ctx.closeOnClickOverlay,
          teleport: _ctx.teleport,
          show: _ctx.popupShow,
        },
        {
          'onUpdate:show': _ctx.handlePopupUpdateShow,
        },
        {
          onOpen: _ctx.onOpen,
          onClose: _ctx.onClose,
          onClosed: _ctx.onClosed,
          onOpened: _ctx.onOpened,
          onRouteChange: _ctx.onRouteChange,
        }
      ),
      {
        default: withCtx(() => [
          createElementVNode(
            'div',
            mergeProps(
              {
                class: _ctx.classes(_ctx.n(), 'var--box'),
              },
              _ctx.$attrs
            ),
            [
              renderSlot(_ctx.$slots, 'title', {}, () => [
                createElementVNode(
                  'div',
                  {
                    class: normalizeClass(_ctx.n('title')),
                  },
                  toDisplayString(_ctx.dt(_ctx.title, _ctx.pack.actionSheetTitle)),
                  3
                ),
              ]),
              renderSlot(_ctx.$slots, 'actions', {}, () => [
                (openBlock(true),
                createElementBlock(
                  Fragment,
                  null,
                  renderList(_ctx.actions, (action) => {
                    return withDirectives(
                      (openBlock(),
                      createElementBlock(
                        'div',
                        {
                          class: normalizeClass(
                            _ctx.classes(_ctx.n('action-item'), action.className, [
                              action.disabled,
                              _ctx.n('--disabled'),
                            ])
                          ),
                          key: action.name,
                          style: normalizeStyle({
                            color: action.color,
                          }),
                          onClick: ($event) => _ctx.handleSelect(action),
                        },
                        [
                          action.icon
                            ? (openBlock(),
                              createBlock(
                                _component_var_icon,
                                {
                                  key: 0,
                                  class: normalizeClass(_ctx.n('action-icon')),
                                  'var-action-sheet-cover': '',
                                  name: action.icon,
                                  size: action.iconSize,
                                },
                                null,
                                8,
                                ['class', 'name', 'size']
                              ))
                            : createCommentVNode('v-if', true),
                          createElementVNode(
                            'div',
                            {
                              class: normalizeClass(_ctx.n('action-name')),
                            },
                            toDisplayString(action.name),
                            3
                          ),
                        ],
                        14,
                        _hoisted_1$l
                      )),
                      [
                        [
                          _directive_ripple,
                          {
                            disabled: action.disabled,
                          },
                        ],
                      ]
                    )
                  }),
                  128
                )),
              ]),
            ],
            16
          ),
        ]),
        _: 3,
      },
      16,
      [
        'class',
        'overlay',
        'overlay-class',
        'overlay-style',
        'lock-scroll',
        'close-on-click-overlay',
        'teleport',
        'show',
        'onOpen',
        'onClose',
        'onClosed',
        'onOpened',
        'onRouteChange',
      ]
    )
  )
}
var VarActionSheet = defineComponent({
  render: render$Y,
  name: 'VarActionSheet',
  directives: {
    Ripple,
  },
  components: {
    VarPopup: Popup,
    VarIcon: Icon,
  },
  inheritAttrs: false,
  props: props$S,
  setup(props2) {
    var popupShow = ref(false)
    var handleSelect = (action) => {
      if (action.disabled) {
        return
      }
      var { closeOnClickAction, onSelect } = props2
      call(onSelect, action)
      closeOnClickAction && call(props2['onUpdate:show'], false)
    }
    var handlePopupUpdateShow = (value) => call(props2['onUpdate:show'], value)
    watch(
      () => props2.show,
      (newValue) => {
        popupShow.value = newValue
      },
      {
        immediate: true,
      }
    )
    return {
      n: n$$,
      classes: classes$Q,
      handlePopupUpdateShow,
      popupShow,
      pack,
      dt,
      handleSelect,
    }
  },
})
VarActionSheet.install = function (app) {
  app.component(VarActionSheet.name, VarActionSheet)
}
function positionValidator$2(position) {
  var validPositions = ['left', 'center', 'right']
  return validPositions.includes(position)
}
var props$R = {
  color: {
    type: String,
  },
  textColor: {
    type: String,
  },
  title: {
    type: String,
  },
  titlePosition: {
    type: String,
    default: 'left',
    validator: positionValidator$2,
  },
  elevation: {
    type: Boolean,
    default: true,
  },
}
var { n: n$_, classes: classes$P } = createNamespace('app-bar')
function render$X(_ctx, _cache2) {
  return (
    openBlock(),
    createElementBlock(
      'div',
      {
        class: normalizeClass(_ctx.classes(_ctx.n(), [_ctx.elevation, 'var-elevation--3'])),
        style: normalizeStyle({
          background: _ctx.color,
          color: _ctx.textColor,
        }),
      },
      [
        createElementVNode(
          'div',
          {
            class: normalizeClass(_ctx.n('left')),
          },
          [
            renderSlot(_ctx.$slots, 'left'),
            _ctx.titlePosition === 'left'
              ? (openBlock(),
                createElementBlock(
                  'div',
                  {
                    key: 0,
                    class: normalizeClass(_ctx.n('title')),
                    style: normalizeStyle({
                      paddingLeft: _ctx.paddingLeft,
                    }),
                  },
                  [renderSlot(_ctx.$slots, 'default', {}, () => [createTextVNode(toDisplayString(_ctx.title), 1)])],
                  6
                ))
              : createCommentVNode('v-if', true),
          ],
          2
        ),
        _ctx.titlePosition === 'center'
          ? (openBlock(),
            createElementBlock(
              'div',
              {
                key: 0,
                class: normalizeClass(_ctx.n('title')),
              },
              [renderSlot(_ctx.$slots, 'default', {}, () => [createTextVNode(toDisplayString(_ctx.title), 1)])],
              2
            ))
          : createCommentVNode('v-if', true),
        createElementVNode(
          'div',
          {
            class: normalizeClass(_ctx.n('right')),
          },
          [
            _ctx.titlePosition === 'right'
              ? (openBlock(),
                createElementBlock(
                  'div',
                  {
                    key: 0,
                    class: normalizeClass(_ctx.n('title')),
                    style: normalizeStyle({
                      paddingRight: _ctx.paddingRight,
                    }),
                  },
                  [renderSlot(_ctx.$slots, 'default', {}, () => [createTextVNode(toDisplayString(_ctx.title), 1)])],
                  6
                ))
              : createCommentVNode('v-if', true),
            renderSlot(_ctx.$slots, 'right'),
          ],
          2
        ),
      ],
      6
    )
  )
}
var AppBar = defineComponent({
  render: render$X,
  name: 'VarAppBar',
  props: props$R,
  setup(props2, _ref) {
    var { slots } = _ref
    var paddingLeft = ref()
    var paddingRight = ref()
    var computePadding = () => {
      paddingLeft.value = slots.left ? 0 : void 0
      paddingRight.value = slots.right ? 0 : void 0
    }
    onMounted(computePadding)
    onUpdated(computePadding)
    return {
      n: n$_,
      classes: classes$P,
      paddingLeft,
      paddingRight,
    }
  },
})
AppBar.install = function (app) {
  app.component(AppBar.name, AppBar)
}
function typeValidator$6(type) {
  return ['circle', 'wave', 'cube', 'rect', 'disappear'].includes(type)
}
function sizeValidator$3(size) {
  return ['normal', 'mini', 'small', 'large'].includes(size)
}
var props$Q = {
  type: {
    type: String,
    default: 'circle',
    validator: typeValidator$6,
  },
  radius: {
    type: [String, Number],
  },
  size: {
    type: String,
    default: 'normal',
    validator: sizeValidator$3,
  },
  color: {
    type: String,
    default: 'currentColor',
  },
  description: {
    type: String,
  },
  loading: {
    type: Boolean,
    default: false,
  },
}
var { n: n$Z, classes: classes$O } = createNamespace('loading')
var _withScopeId$1 = (n2) => (pushScopeId(''), (n2 = n2()), popScopeId(), n2)
var _hoisted_1$k = /* @__PURE__ */ _withScopeId$1(() =>
  /* @__PURE__ */ createElementVNode(
    'svg',
    {
      viewBox: '25 25 50 50',
    },
    [
      /* @__PURE__ */ createElementVNode('circle', {
        cx: '50',
        cy: '50',
        r: '20',
        fill: 'none',
      }),
    ],
    -1
  )
)
var _hoisted_2$8 = [_hoisted_1$k]
function render$W(_ctx, _cache2) {
  return (
    openBlock(),
    createElementBlock(
      'div',
      {
        class: normalizeClass(_ctx.n()),
      },
      [
        _ctx.$slots.default
          ? (openBlock(),
            createElementBlock(
              'div',
              {
                key: 0,
                class: normalizeClass(_ctx.classes(_ctx.n('content'), [_ctx.loading, _ctx.n('content--active')])),
              },
              [
                renderSlot(_ctx.$slots, 'default'),
                _ctx.loading
                  ? (openBlock(),
                    createElementBlock(
                      'div',
                      {
                        key: 0,
                        class: normalizeClass(_ctx.n('content-mask')),
                      },
                      null,
                      2
                    ))
                  : createCommentVNode('v-if', true),
              ],
              2
            ))
          : createCommentVNode('v-if', true),
        _ctx.isShow
          ? (openBlock(),
            createElementBlock(
              'div',
              {
                key: 1,
                class: normalizeClass(
                  _ctx.classes('var--box', _ctx.n('body'), [_ctx.$slots.default, _ctx.n('inside')])
                ),
              },
              [
                _ctx.type === 'circle'
                  ? (openBlock(),
                    createElementBlock(
                      'div',
                      {
                        key: 0,
                        class: normalizeClass(_ctx.n('circle')),
                      },
                      [
                        createElementVNode(
                          'span',
                          {
                            class: normalizeClass(
                              _ctx.classes(_ctx.n('circle-block'), _ctx.n('circle-block--' + _ctx.size))
                            ),
                            style: normalizeStyle({
                              width: _ctx.multiplySizeUnit(_ctx.radius, 2),
                              height: _ctx.multiplySizeUnit(_ctx.radius, 2),
                              color: _ctx.color,
                            }),
                          },
                          _hoisted_2$8,
                          6
                        ),
                      ],
                      2
                    ))
                  : createCommentVNode('v-if', true),
                (openBlock(true),
                createElementBlock(
                  Fragment,
                  null,
                  renderList(_ctx.loadingTypeDict, (nums, key) => {
                    return (
                      openBlock(),
                      createElementBlock(
                        Fragment,
                        {
                          key,
                        },
                        [
                          _ctx.type === key
                            ? (openBlock(),
                              createElementBlock(
                                'div',
                                {
                                  key: 0,
                                  class: normalizeClass(_ctx.classes(_ctx.n(key), _ctx.n(key + '--' + _ctx.size))),
                                },
                                [
                                  (openBlock(true),
                                  createElementBlock(
                                    Fragment,
                                    null,
                                    renderList(nums, (num) => {
                                      return (
                                        openBlock(),
                                        createElementBlock(
                                          'div',
                                          {
                                            key: num + key,
                                            style: normalizeStyle({
                                              backgroundColor: _ctx.color,
                                            }),
                                            class: normalizeClass(
                                              _ctx.classes(_ctx.n(key + '-item'), _ctx.n(key + '-item--' + _ctx.size))
                                            ),
                                          },
                                          null,
                                          6
                                        )
                                      )
                                    }),
                                    128
                                  )),
                                ],
                                2
                              ))
                            : createCommentVNode('v-if', true),
                        ],
                        64
                      )
                    )
                  }),
                  128
                )),
                _ctx.$slots.description || _ctx.description
                  ? (openBlock(),
                    createElementBlock(
                      'div',
                      {
                        key: 1,
                        class: normalizeClass(_ctx.classes(_ctx.n('description'), _ctx.n('description--' + _ctx.size))),
                        style: normalizeStyle({
                          color: _ctx.color,
                        }),
                      },
                      [
                        renderSlot(_ctx.$slots, 'description', {}, () => [
                          createTextVNode(toDisplayString(_ctx.description), 1),
                        ]),
                      ],
                      6
                    ))
                  : createCommentVNode('v-if', true),
              ],
              2
            ))
          : createCommentVNode('v-if', true),
      ],
      2
    )
  )
}
var Loading = defineComponent({
  render: render$W,
  name: 'VarLoading',
  props: props$Q,
  setup(props2, _ref) {
    var { slots } = _ref
    var loadingTypeDict = {
      wave: 5,
      cube: 4,
      rect: 8,
      disappear: 3,
    }
    var isShow = computed(() => {
      if (!call(slots.default)) return true
      return props2.loading
    })
    return {
      n: n$Z,
      classes: classes$O,
      multiplySizeUnit,
      loadingTypeDict,
      isShow,
    }
  },
})
Loading.install = function (app) {
  app.component(Loading.name, Loading)
}
function typeValidator$5(type) {
  return ['default', 'primary', 'info', 'success', 'warning', 'danger'].includes(type)
}
function sizeValidator$2(size) {
  return ['normal', 'mini', 'small', 'large'].includes(size)
}
var props$P = {
  type: {
    type: String,
    default: 'default',
    validator: typeValidator$5,
  },
  size: {
    type: String,
    default: 'normal',
    validator: sizeValidator$2,
  },
  loading: {
    type: Boolean,
    default: false,
  },
  round: {
    type: Boolean,
    default: false,
  },
  block: {
    type: Boolean,
    default: false,
  },
  text: {
    type: Boolean,
    default: false,
  },
  outline: {
    type: Boolean,
    default: false,
  },
  disabled: {
    type: Boolean,
    default: false,
  },
  ripple: {
    type: Boolean,
    default: true,
  },
  color: {
    type: String,
  },
  textColor: {
    type: String,
  },
  autoLoading: {
    type: Boolean,
    default: false,
  },
  loadingRadius: {
    type: [Number, String],
    default: 12,
  },
  loadingType: pickProps(props$Q, 'type'),
  loadingSize: pickProps(props$Q, 'size'),
  onClick: {
    type: Function,
  },
  onTouchstart: {
    type: Function,
  },
}
var { n: n$Y, classes: classes$N } = createNamespace('button')
var _hoisted_1$j = ['disabled']
function render$V(_ctx, _cache2) {
  var _component_var_loading = resolveComponent('var-loading')
  var _directive_ripple = resolveDirective('ripple')
  return withDirectives(
    (openBlock(),
    createElementBlock(
      'button',
      {
        class: normalizeClass(
          _ctx.classes(
            _ctx.n(),
            'var--box',
            _ctx.n('--' + _ctx.size),
            [_ctx.block, 'var--flex ' + _ctx.n('--block'), 'var--inline-flex'],
            [_ctx.disabled, _ctx.n('--disabled')],
            [
              _ctx.text,
              _ctx.n('--text-' + _ctx.type) + ' ' + _ctx.n('--text'),
              _ctx.n('--' + _ctx.type) + ' var-elevation--2',
            ],
            [_ctx.text && _ctx.disabled, _ctx.n('--text-disabled')],
            [_ctx.round, _ctx.n('--round')],
            [_ctx.outline, _ctx.n('--outline')]
          )
        ),
        style: normalizeStyle({
          color: _ctx.textColor,
          background: _ctx.color,
        }),
        disabled: _ctx.disabled,
        onClick:
          _cache2[0] ||
          (_cache2[0] = function () {
            return _ctx.handleClick && _ctx.handleClick(...arguments)
          }),
        onTouchstart:
          _cache2[1] ||
          (_cache2[1] = function () {
            return _ctx.handleTouchstart && _ctx.handleTouchstart(...arguments)
          }),
      },
      [
        _ctx.loading || _ctx.pending
          ? (openBlock(),
            createBlock(
              _component_var_loading,
              {
                key: 0,
                class: normalizeClass(_ctx.n('loading')),
                'var-button-cover': '',
                type: _ctx.loadingType,
                size: _ctx.loadingSize,
                radius: _ctx.loadingRadius,
              },
              null,
              8,
              ['class', 'type', 'size', 'radius']
            ))
          : createCommentVNode('v-if', true),
        createElementVNode(
          'div',
          {
            class: normalizeClass(_ctx.classes(_ctx.n('content'), [_ctx.loading || _ctx.pending, _ctx.n('--hidden')])),
          },
          [renderSlot(_ctx.$slots, 'default')],
          2
        ),
      ],
      46,
      _hoisted_1$j
    )),
    [
      [
        _directive_ripple,
        {
          disabled: _ctx.disabled || !_ctx.ripple,
        },
      ],
    ]
  )
}
var Button = defineComponent({
  render: render$V,
  name: 'VarButton',
  components: {
    VarLoading: Loading,
  },
  directives: {
    Ripple,
  },
  props: props$P,
  setup(props2) {
    var pending = ref(false)
    var attemptAutoLoading = (result) => {
      if (props2.autoLoading) {
        pending.value = true
        Promise.resolve(result).finally(() => {
          pending.value = false
        })
      }
    }
    var handleClick = (e) => {
      var { loading: loading2, disabled, onClick } = props2
      if (!onClick || loading2 || disabled || pending.value) {
        return
      }
      attemptAutoLoading(onClick(e))
    }
    var handleTouchstart = (e) => {
      var { loading: loading2, disabled, onTouchstart } = props2
      if (!onTouchstart || loading2 || disabled || pending.value) {
        return
      }
      attemptAutoLoading(onTouchstart(e))
    }
    return {
      n: n$Y,
      classes: classes$N,
      pending,
      handleClick,
      handleTouchstart,
    }
  },
})
Button.install = function (app) {
  app.component(Button.name, Button)
}
var props$O = {
  visibilityHeight: {
    type: [Number, String],
    default: 200,
  },
  duration: {
    type: Number,
    default: 300,
  },
  right: {
    type: [Number, String],
  },
  bottom: {
    type: [Number, String],
  },
  target: {
    type: [String, Object],
  },
  onClick: {
    type: Function,
  },
}
var { n: n$X, classes: classes$M } = createNamespace('back-top')
function render$U(_ctx, _cache2) {
  var _component_var_icon = resolveComponent('var-icon')
  var _component_var_button = resolveComponent('var-button')
  return (
    openBlock(),
    createBlock(
      Teleport,
      {
        to: 'body',
        disabled: _ctx.disabled,
      },
      [
        createElementVNode(
          'div',
          {
            class: normalizeClass(_ctx.classes(_ctx.n(), [_ctx.show, _ctx.n('--active')])),
            ref: 'backTopEl',
            style: normalizeStyle({
              right: _ctx.toSizeUnit(_ctx.right),
              bottom: _ctx.toSizeUnit(_ctx.bottom),
            }),
            onClick:
              _cache2[0] ||
              (_cache2[0] = withModifiers(
                function () {
                  return _ctx.click && _ctx.click(...arguments)
                },
                ['stop']
              )),
          },
          [
            renderSlot(_ctx.$slots, 'default', {}, () => [
              createVNode(
                _component_var_button,
                {
                  type: 'primary',
                  round: '',
                  'var-back-top-cover': '',
                },
                {
                  default: withCtx(() => [
                    createVNode(_component_var_icon, {
                      name: 'chevron-up',
                    }),
                  ]),
                  _: 1,
                }
              ),
            ]),
          ],
          6
        ),
      ],
      8,
      ['disabled']
    )
  )
}
var BackTop = defineComponent({
  render: render$U,
  name: 'VarBackTop',
  components: {
    VarButton: Button,
    VarIcon: Icon,
  },
  props: props$O,
  setup(props2) {
    var show = ref(false)
    var backTopEl = ref(null)
    var disabled = ref(true)
    var target
    var click = (event) => {
      call(props2.onClick, event)
      var left = getScrollLeft(target)
      scrollTo(target, {
        left,
        duration: props2.duration,
        animation: easeInOutCubic,
      })
    }
    var scroll = () => {
      show.value = getScrollTop(target) >= toPxNum(props2.visibilityHeight)
    }
    var throttleScroll = throttle(scroll, 200)
    var getTarget = () => {
      var { target: target2 } = props2
      if (isString$1(target2)) {
        var el = document.querySelector(props2.target)
        if (!el) {
          throw Error('[Varlet] BackTop: target element cannot found')
        }
        return el
      }
      if (isObject(target2)) return target2
      throw Error('[Varlet] BackTop: type of prop "target" should be a selector or an element object')
    }
    onMounted(() => {
      target = props2.target ? getTarget() : getParentScroller(backTopEl.value)
      target.addEventListener('scroll', throttleScroll)
      disabled.value = false
    })
    onBeforeUnmount(() => {
      target.removeEventListener('scroll', throttleScroll)
    })
    return {
      disabled,
      show,
      backTopEl,
      toSizeUnit,
      n: n$X,
      classes: classes$M,
      click,
    }
  },
})
BackTop.install = function (app) {
  app.component(BackTop.name, BackTop)
}
function typeValidator$4(type) {
  return ['default', 'primary', 'info', 'success', 'warning', 'danger'].includes(type)
}
function positionValidator$1(position) {
  return ['right-top', 'right-bottom', 'left-top', 'left-bottom'].includes(position)
}
var props$N = {
  type: {
    type: String,
    default: 'default',
    validator: typeValidator$4,
  },
  hidden: {
    type: Boolean,
    default: false,
  },
  dot: {
    type: Boolean,
    default: false,
  },
  value: {
    type: [String, Number],
    default: 0,
  },
  maxValue: {
    type: [String, Number],
  },
  color: {
    type: String,
  },
  position: {
    type: String,
    default: 'right-top',
    validator: positionValidator$1,
  },
  icon: {
    type: String,
  },
}
var { n: n$W, classes: classes$L } = createNamespace('badge')
var _hoisted_1$i = {
  key: 1,
}
function render$T(_ctx, _cache2) {
  var _component_var_icon = resolveComponent('var-icon')
  return (
    openBlock(),
    createElementBlock(
      'div',
      {
        class: normalizeClass(_ctx.classes(_ctx.n(), 'var--box')),
      },
      [
        createVNode(
          Transition,
          {
            name: 'var-badge-fade',
          },
          {
            default: withCtx(() => [
              withDirectives(
                createElementVNode(
                  'span',
                  mergeProps(_ctx.$attrs, {
                    class: _ctx.classes(_ctx.n('content'), ..._ctx.contentClass),
                    style: {
                      background: _ctx.color,
                    },
                  }),
                  [
                    _ctx.icon && !_ctx.dot
                      ? (openBlock(),
                        createBlock(
                          _component_var_icon,
                          {
                            key: 0,
                            name: _ctx.icon,
                            size: '10px',
                          },
                          null,
                          8,
                          ['name']
                        ))
                      : (openBlock(), createElementBlock('span', _hoisted_1$i, toDisplayString(_ctx.values), 1)),
                  ],
                  16
                ),
                [[vShow, !_ctx.hidden]]
              ),
            ]),
            _: 1,
          }
        ),
        renderSlot(_ctx.$slots, 'default'),
      ],
      2
    )
  )
}
var Badge = defineComponent({
  render: render$T,
  name: 'VarBadge',
  components: {
    VarIcon: Icon,
  },
  inheritAttrs: false,
  props: props$N,
  setup(props2, _ref) {
    var { slots } = _ref
    var contentClass = computed(() => {
      var { type, position, dot, icon } = props2
      var positionBasic = slots.default && n$W('position') + ' ' + n$W('--' + position)
      var dotClass = dot ? n$W('dot') : null
      var positionClass = getPositionClass()
      var iconClass = icon ? n$W('icon') : null
      return [n$W('--' + type), positionBasic, dotClass, positionClass, iconClass]
    })
    var values = computed(() => {
      var { dot, value, maxValue } = props2
      if (dot) return ''
      if (value !== void 0 && maxValue !== void 0 && toNumber(value) > maxValue) return maxValue + '+'
      return value
    })
    var getPositionClass = () => {
      var { position, dot } = props2
      if (dot && position.includes('right')) return n$W('dot--right')
      if (dot && position.includes('left')) return n$W('dot--left')
    }
    return {
      n: n$W,
      classes: classes$L,
      values,
      contentClass,
    }
  },
})
Badge.install = function (app) {
  app.component(Badge.name, Badge)
}
var props$M = {
  active: {
    type: [Number, String],
    default: 0,
  },
  fixed: {
    type: Boolean,
    default: false,
  },
  border: {
    type: Boolean,
    default: false,
  },
  safeArea: {
    type: Boolean,
    default: false,
  },
  zIndex: {
    type: [Number, String],
    default: 1,
  },
  activeColor: {
    type: String,
  },
  inactiveColor: {
    type: String,
  },
  onChange: {
    type: Function,
  },
  'onUpdate:active': {
    type: Function,
  },
  onBeforeChange: {
    type: Function,
  },
  onFabClick: {
    type: Function,
  },
  fabProps: {
    type: Object,
  },
}
var BOTTOM_NAVIGATION_BIND_BOTTOM_NAVIGATION_ITEM_KEY = Symbol('BOTTOM_NAVIGATION_BIND_BOTTOM_NAVIGATION_ITEM_KEY')
var BOTTOM_NAVIGATION_COUNT_BOTTOM_NAVIGATION_ITEM_KEY = Symbol('BOTTOM_NAVIGATION_COUNT_BOTTOM_NAVIGATION_ITEM_KEY')
function useBottomNavigationItems() {
  var { childProviders, bindChildren } = useChildren(BOTTOM_NAVIGATION_BIND_BOTTOM_NAVIGATION_ITEM_KEY)
  var { length } = useAtChildrenCounter(BOTTOM_NAVIGATION_COUNT_BOTTOM_NAVIGATION_ITEM_KEY)
  return {
    length,
    bottomNavigationItems: childProviders,
    bindBottomNavigationItem: bindChildren,
  }
}
function _extends$8() {
  _extends$8 =
    Object.assign ||
    function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i]
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key]
          }
        }
      }
      return target
    }
  return _extends$8.apply(this, arguments)
}
var { n: n$V, classes: classes$K } = createNamespace('bottom-navigation')
var { n: nItem } = createNamespace('bottom-navigation-item')
var RIGHT_HALF_SPACE_CLASS = nItem('--right-half-space')
var LEFT_HALF_SPACE_CLASS = nItem('--left-half-space')
var RIGHT_SPACE_CLASS = nItem('--right-space')
var defaultFabProps = {
  type: 'primary',
}
function render$S(_ctx, _cache2) {
  var _component_var_button = resolveComponent('var-button')
  return (
    openBlock(),
    createElementBlock(
      'div',
      {
        class: normalizeClass(
          _ctx.classes(
            _ctx.n(),
            [_ctx.fixed, _ctx.n('--fixed')],
            [_ctx.border, _ctx.n('--border')],
            [_ctx.safeArea, _ctx.n('--safe-area')]
          )
        ),
        ref: 'bottomNavigationDom',
        style: normalizeStyle('z-index:' + _ctx.zIndex),
      },
      [
        renderSlot(_ctx.$slots, 'default'),
        _ctx.$slots.fab
          ? (openBlock(),
            createBlock(
              _component_var_button,
              mergeProps(
                {
                  key: 0,
                  class: _ctx.classes(_ctx.n('fab'), [_ctx.length % 2, _ctx.n('--fab-right'), _ctx.n('--fab-center')]),
                  'var-bottom-navigation__fab': '',
                  onClick: _ctx.handleFabClick,
                },
                _ctx.fabProps,
                {
                  round: '',
                }
              ),
              {
                default: withCtx(() => [renderSlot(_ctx.$slots, 'fab')]),
                _: 3,
              },
              16,
              ['class', 'onClick']
            ))
          : createCommentVNode('v-if', true),
      ],
      6
    )
  )
}
var BottomNavigation = defineComponent({
  render: render$S,
  name: 'VarBottomNavigation',
  components: {
    VarButton: Button,
  },
  props: props$M,
  setup(props2, _ref) {
    var { slots } = _ref
    var bottomNavigationDom = ref(null)
    var active = computed(() => props2.active)
    var activeColor = computed(() => props2.activeColor)
    var inactiveColor = computed(() => props2.inactiveColor)
    var fabProps = ref({})
    var { length, bottomNavigationItems, bindBottomNavigationItem } = useBottomNavigationItems()
    var matchBoundary = () => {
      if (length.value === 0 || matchName() || matchIndex()) {
        return
      }
      handleActiveIndex()
    }
    var matchName = () => {
      return bottomNavigationItems.find((_ref2) => {
        var { name } = _ref2
        return active.value === name.value
      })
    }
    var matchIndex = () => {
      return bottomNavigationItems.find((_ref3) => {
        var { index: index2 } = _ref3
        return active.value === index2.value
      })
    }
    var handleActiveIndex = () => {
      if (!isNumber(active.value)) {
        return
      }
      if (active.value < 0) {
        call(props2['onUpdate:active'], 0)
      } else if (active.value > length.value - 1) {
        call(props2['onUpdate:active'], length.value - 1)
      }
    }
    var onToggle = (changedValue) => {
      props2.onBeforeChange ? handleBeforeChange(changedValue) : handleChange(changedValue)
    }
    var handleBeforeChange = (changedValue) => {
      Promise.resolve(call(props2.onBeforeChange, changedValue)).then((res) => res && handleChange(changedValue))
    }
    var handleChange = (changedValue) => {
      call(props2['onUpdate:active'], changedValue)
      call(props2.onChange, changedValue)
    }
    var removeMarginClass = () => {
      var bottomNavigationItems2 = getBottomNavigationItems()
      bottomNavigationItems2.forEach((dom) => {
        dom.classList.remove(RIGHT_HALF_SPACE_CLASS, LEFT_HALF_SPACE_CLASS, RIGHT_SPACE_CLASS)
      })
    }
    var addMarginClass = (length2) => {
      var bottomNavigationItems2 = getBottomNavigationItems()
      var itemsNum = bottomNavigationItems2.length
      var isEven = length2 % 2 === 0
      bottomNavigationItems2.forEach((bottomNavigationItem, i) => {
        handleMarginClass(isEven, bottomNavigationItem, i, itemsNum)
      })
    }
    var handleMarginClass = (isEven, dom, i, length2) => {
      var isLast = i === length2 - 1
      if (!isEven && isLast) {
        dom.classList.add(RIGHT_SPACE_CLASS)
        return
      }
      var isFabLeft = i === length2 / 2 - 1
      var isFabRight = i === length2 / 2
      if (isFabLeft) {
        dom.classList.add(RIGHT_HALF_SPACE_CLASS)
      } else if (isFabRight) {
        dom.classList.add(LEFT_HALF_SPACE_CLASS)
      }
    }
    var getBottomNavigationItems = () => {
      return Array.from(bottomNavigationDom.value.querySelectorAll('.' + nItem()))
    }
    var handleFabClick = () => {
      call(props2.onFabClick)
    }
    var bottomNavigationProvider = {
      active,
      activeColor,
      inactiveColor,
      onToggle,
    }
    bindBottomNavigationItem(bottomNavigationProvider)
    watch(() => length.value, matchBoundary)
    watch(
      () => props2.fabProps,
      (newValue) => {
        fabProps.value = _extends$8({}, defaultFabProps, newValue)
      },
      {
        immediate: true,
        deep: true,
      }
    )
    onMounted(() => {
      if (!slots.fab) {
        return
      }
      addMarginClass(length.value)
    })
    onUpdated(() => {
      removeMarginClass()
      if (!slots.fab) {
        return
      }
      addMarginClass(length.value)
    })
    return {
      n: n$V,
      classes: classes$K,
      length,
      bottomNavigationDom,
      handleFabClick,
      fabProps,
    }
  },
})
BottomNavigation.install = function (app) {
  app.component(BottomNavigation.name, BottomNavigation)
}
var props$L = {
  name: {
    type: String,
  },
  icon: {
    type: String,
  },
  label: {
    type: String,
  },
  namespace: {
    type: String,
    default: 'var-icon',
  },
  badge: {
    type: [Boolean, Object],
    default: false,
  },
  onClick: {
    type: Function,
  },
}
function useBottomNavigation() {
  var { parentProvider, bindParent } = useParent(BOTTOM_NAVIGATION_BIND_BOTTOM_NAVIGATION_ITEM_KEY)
  var { index: index2 } = useAtParentIndex(BOTTOM_NAVIGATION_COUNT_BOTTOM_NAVIGATION_ITEM_KEY)
  if (!parentProvider || !bindParent || !index2) {
    throw Error('<var-bottom-navigation-item/> must in <var-bottom-navigation/>')
  }
  return {
    index: index2,
    bottomNavigation: parentProvider,
    bindBottomNavigation: bindParent,
  }
}
var { n: n$U, classes: classes$J } = createNamespace('bottom-navigation-item')
var defaultBadgeProps = {
  type: 'danger',
  dot: true,
}
function render$R(_ctx, _cache2) {
  var _component_var_icon = resolveComponent('var-icon')
  var _component_var_badge = resolveComponent('var-badge')
  var _directive_ripple = resolveDirective('ripple')
  return withDirectives(
    (openBlock(),
    createElementBlock(
      'button',
      {
        class: normalizeClass(
          _ctx.classes(_ctx.n(), [_ctx.active === _ctx.index || _ctx.active === _ctx.name, _ctx.n('--active')])
        ),
        style: normalizeStyle({
          color: _ctx.computeColorStyle(),
        }),
        onClick:
          _cache2[0] ||
          (_cache2[0] = function () {
            return _ctx.handleClick && _ctx.handleClick(...arguments)
          }),
      },
      [
        _ctx.icon && !_ctx.$slots.icon
          ? (openBlock(),
            createBlock(
              _component_var_icon,
              {
                key: 0,
                name: _ctx.icon,
                namespace: _ctx.namespace,
                class: normalizeClass(_ctx.n('icon')),
                'var-bottom-navigation-item-cover': '',
              },
              null,
              8,
              ['name', 'namespace', 'class']
            ))
          : createCommentVNode('v-if', true),
        renderSlot(_ctx.$slots, 'icon', {
          active: _ctx.active === _ctx.index || _ctx.active === _ctx.name,
        }),
        _ctx.badge
          ? (openBlock(),
            createBlock(
              _component_var_badge,
              mergeProps(
                {
                  key: 1,
                },
                _ctx.badgeProps,
                {
                  class: _ctx.n('badge'),
                  'var-bottom-navigation-item-cover': '',
                }
              ),
              null,
              16,
              ['class']
            ))
          : createCommentVNode('v-if', true),
        createElementVNode(
          'span',
          {
            class: normalizeClass(_ctx.n('label')),
          },
          [
            !_ctx.$slots.default
              ? (openBlock(),
                createElementBlock(
                  Fragment,
                  {
                    key: 0,
                  },
                  [createTextVNode(toDisplayString(_ctx.label), 1)],
                  2112
                ))
              : createCommentVNode('v-if', true),
            renderSlot(_ctx.$slots, 'default'),
          ],
          2
        ),
      ],
      6
    )),
    [[_directive_ripple]]
  )
}
var BottomNavigationItem = defineComponent({
  render: render$R,
  name: 'VarBottomNavigationItem',
  components: {
    VarBadge: Badge,
    VarIcon: Icon,
  },
  directives: {
    Ripple,
  },
  props: props$L,
  setup(props2) {
    var name = computed(() => props2.name)
    var badge = computed(() => props2.badge)
    var badgeProps = ref({})
    var { index: index2, bottomNavigation, bindBottomNavigation } = useBottomNavigation()
    var { active, activeColor, inactiveColor } = bottomNavigation
    var bottomNavigationItemProvider = {
      name,
      index: index2,
    }
    var computeColorStyle = () => {
      return active.value === name.value || active.value === index2.value ? activeColor.value : inactiveColor.value
    }
    var handleClick = () => {
      var _name$value
      var active2 = (_name$value = name.value) != null ? _name$value : index2.value
      call(props2.onClick, active2)
      call(bottomNavigation.onToggle, active2)
    }
    bindBottomNavigation(bottomNavigationItemProvider)
    watch(
      () => badge.value,
      (newValue) => {
        badgeProps.value = newValue === true ? defaultBadgeProps : badge.value
      },
      {
        immediate: true,
      }
    )
    return {
      n: n$U,
      classes: classes$J,
      index: index2,
      active,
      badge,
      badgeProps,
      computeColorStyle,
      handleClick,
    }
  },
})
BottomNavigationItem.install = function (app) {
  app.component(BottomNavigationItem.name, BottomNavigationItem)
}
function fitValidator$1(fit) {
  return ['fill', 'contain', 'cover', 'none', 'scale-down'].includes(fit)
}
var props$K = {
  src: {
    type: String,
  },
  fit: {
    type: String,
    validator: fitValidator$1,
    default: 'cover',
  },
  height: {
    type: [String, Number],
  },
  imageHeight: {
    type: [String, Number],
  },
  imageWidth: {
    type: [String, Number],
  },
  layout: {
    type: String,
    default: 'column',
  },
  floating: {
    type: Boolean,
    default: false,
  },
  'onUpdate:floating': {
    type: Function,
  },
  floatingDuration: {
    type: Number,
    default: 250,
  },
  alt: {
    type: String,
  },
  title: {
    type: String,
  },
  subtitle: {
    type: String,
  },
  description: {
    type: String,
  },
  elevation: {
    type: [Number, String],
  },
  ripple: {
    type: Boolean,
    default: false,
  },
  onClick: {
    type: Function,
  },
}
function asyncGeneratorStep$a(gen, resolve2, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg)
    var value = info.value
  } catch (error) {
    reject(error)
    return
  }
  if (info.done) {
    resolve2(value)
  } else {
    Promise.resolve(value).then(_next, _throw)
  }
}
function _asyncToGenerator$a(fn) {
  return function () {
    var self2 = this,
      args = arguments
    return new Promise(function (resolve2, reject) {
      var gen = fn.apply(self2, args)
      function _next(value) {
        asyncGeneratorStep$a(gen, resolve2, reject, _next, _throw, 'next', value)
      }
      function _throw(err) {
        asyncGeneratorStep$a(gen, resolve2, reject, _next, _throw, 'throw', err)
      }
      _next(void 0)
    })
  }
}
var { n: n$T, classes: classes$I } = createNamespace('card')
var RIPPLE_DELAY = 500
var _hoisted_1$h = ['src', 'alt']
function render$Q(_ctx, _cache2) {
  var _component_var_icon = resolveComponent('var-icon')
  var _component_var_button = resolveComponent('var-button')
  var _directive_ripple = resolveDirective('ripple')
  return withDirectives(
    (openBlock(),
    createElementBlock(
      'div',
      {
        ref: 'card',
        class: normalizeClass(
          _ctx.classes(
            _ctx.n(),
            [_ctx.isRow, _ctx.n('--layout-row')],
            [_ctx.elevation, 'var-elevation--' + _ctx.elevation, 'var-elevation--1']
          )
        ),
        style: normalizeStyle({
          zIndex: _ctx.floated ? _ctx.zIndex : void 0,
        }),
        onClick:
          _cache2[0] ||
          (_cache2[0] = function () {
            return _ctx.onClick && _ctx.onClick(...arguments)
          }),
      },
      [
        createElementVNode(
          'div',
          {
            ref: 'cardFloater',
            class: normalizeClass(_ctx.classes(_ctx.n('floater'))),
            style: normalizeStyle({
              width: _ctx.floaterWidth,
              height: _ctx.floaterHeight,
              top: _ctx.floaterTop,
              left: _ctx.floaterLeft,
              overflow: _ctx.floaterOverflow,
              position: _ctx.floaterPosition,
              transition: _ctx.floated
                ? 'background-color ' +
                  _ctx.floatingDuration +
                  'ms, width ' +
                  _ctx.floatingDuration +
                  'ms, height ' +
                  _ctx.floatingDuration +
                  'ms, top ' +
                  _ctx.floatingDuration +
                  'ms, left ' +
                  _ctx.floatingDuration +
                  'ms'
                : void 0,
            }),
          },
          [
            renderSlot(_ctx.$slots, 'image', {}, () => {
              var _ctx$imageHeight
              return [
                _ctx.src
                  ? (openBlock(),
                    createElementBlock(
                      'img',
                      {
                        key: 0,
                        class: normalizeClass(_ctx.n('image')),
                        style: normalizeStyle({
                          objectFit: _ctx.fit,
                          height: _ctx.toSizeUnit(
                            (_ctx$imageHeight = _ctx.imageHeight) != null ? _ctx$imageHeight : _ctx.height
                          ),
                          width: _ctx.toSizeUnit(_ctx.imageWidth),
                        }),
                        src: _ctx.src,
                        alt: _ctx.alt,
                      },
                      null,
                      14,
                      _hoisted_1$h
                    ))
                  : createCommentVNode('v-if', true),
              ]
            }),
            createElementVNode(
              'div',
              {
                class: normalizeClass(_ctx.n('container')),
              },
              [
                renderSlot(_ctx.$slots, 'title', {}, () => [
                  _ctx.title
                    ? (openBlock(),
                      createElementBlock(
                        'div',
                        {
                          key: 0,
                          class: normalizeClass(_ctx.n('title')),
                        },
                        toDisplayString(_ctx.title),
                        3
                      ))
                    : createCommentVNode('v-if', true),
                ]),
                renderSlot(_ctx.$slots, 'subtitle', {}, () => [
                  _ctx.subtitle
                    ? (openBlock(),
                      createElementBlock(
                        'div',
                        {
                          key: 0,
                          class: normalizeClass(_ctx.n('subtitle')),
                        },
                        toDisplayString(_ctx.subtitle),
                        3
                      ))
                    : createCommentVNode('v-if', true),
                ]),
                renderSlot(_ctx.$slots, 'description', {}, () => [
                  _ctx.description
                    ? (openBlock(),
                      createElementBlock(
                        'div',
                        {
                          key: 0,
                          class: normalizeClass(_ctx.n('description')),
                        },
                        toDisplayString(_ctx.description),
                        3
                      ))
                    : createCommentVNode('v-if', true),
                ]),
                _ctx.$slots.extra
                  ? (openBlock(),
                    createElementBlock(
                      'div',
                      {
                        key: 0,
                        class: normalizeClass(_ctx.n('footer')),
                      },
                      [renderSlot(_ctx.$slots, 'extra')],
                      2
                    ))
                  : createCommentVNode('v-if', true),
                _ctx.$slots.content && !_ctx.isRow
                  ? (openBlock(),
                    createElementBlock(
                      'div',
                      {
                        key: 1,
                        class: normalizeClass(_ctx.n('content')),
                        style: normalizeStyle({
                          height: _ctx.contentHeight,
                          opacity: _ctx.opacity,
                          transition: 'opacity ' + _ctx.floatingDuration * 2 + 'ms',
                        }),
                      },
                      [renderSlot(_ctx.$slots, 'content')],
                      6
                    ))
                  : createCommentVNode('v-if', true),
              ],
              2
            ),
            _ctx.showFloatingButtons
              ? (openBlock(),
                createElementBlock(
                  'div',
                  {
                    key: 0,
                    class: normalizeClass(_ctx.classes(_ctx.n('floating-buttons'), 'var--box')),
                    style: normalizeStyle({
                      zIndex: _ctx.zIndex,
                      opacity: _ctx.opacity,
                      transition: 'opacity ' + _ctx.floatingDuration * 2 + 'ms',
                    }),
                  },
                  [
                    renderSlot(_ctx.$slots, 'close-button', {}, () => [
                      createVNode(
                        _component_var_button,
                        {
                          'var-card-cover': '',
                          round: '',
                          class: normalizeClass(_ctx.classes(_ctx.n('close-button'), 'var-elevation--6')),
                          onClick: withModifiers(_ctx.close, ['stop']),
                        },
                        {
                          default: withCtx(() => [
                            createVNode(
                              _component_var_icon,
                              {
                                'var-card-cover': '',
                                name: 'window-close',
                                class: normalizeClass(_ctx.n('close-button-icon')),
                              },
                              null,
                              8,
                              ['class']
                            ),
                          ]),
                          _: 1,
                        },
                        8,
                        ['class', 'onClick']
                      ),
                    ]),
                  ],
                  6
                ))
              : createCommentVNode('v-if', true),
          ],
          6
        ),
        createElementVNode(
          'div',
          {
            class: normalizeClass(_ctx.n('holder')),
            style: normalizeStyle({
              width: _ctx.holderWidth,
              height: _ctx.holderHeight,
            }),
          },
          null,
          6
        ),
      ],
      6
    )),
    [
      [
        _directive_ripple,
        {
          disabled: !_ctx.ripple || _ctx.floater,
        },
      ],
    ]
  )
}
var Card = defineComponent({
  render: render$Q,
  name: 'VarCard',
  directives: {
    Ripple,
  },
  components: {
    VarIcon: Icon,
    VarButton: Button,
  },
  props: props$K,
  setup(props2) {
    var card = ref(null)
    var cardFloater = ref(null)
    var holderWidth = ref('auto')
    var holderHeight = ref('auto')
    var floaterWidth = ref('100%')
    var floaterHeight = ref('100%')
    var floaterTop = ref('auto')
    var floaterLeft = ref('auto')
    var floaterPosition = ref(void 0)
    var floaterOverflow = ref('hidden')
    var contentHeight = ref('0px')
    var opacity = ref('0')
    var { zIndex } = useZIndex(() => props2.floating, 1)
    var isRow = computed(() => props2.layout === 'row')
    var showFloatingButtons = ref(false)
    var floated = ref(false)
    useLock(
      () => props2.floating,
      () => isRow
    )
    var dropdownFloaterTop = 'auto'
    var dropdownFloaterLeft = 'auto'
    var dropper = null
    var floater = ref(null)
    var floating = /* @__PURE__ */ (function () {
      var _ref = _asyncToGenerator$a(function* () {
        clearTimeout(floater.value)
        clearTimeout(dropper)
        floater.value = null
        floater.value = setTimeout(
          /* @__PURE__ */ _asyncToGenerator$a(function* () {
            var { width, height, left, top } = card.value.getBoundingClientRect()
            holderWidth.value = toSizeUnit(width)
            holderHeight.value = toSizeUnit(height)
            floaterWidth.value = holderWidth.value
            floaterHeight.value = holderHeight.value
            floaterTop.value = toSizeUnit(top)
            floaterLeft.value = toSizeUnit(left)
            floaterPosition.value = 'fixed'
            dropdownFloaterTop = floaterTop.value
            dropdownFloaterLeft = floaterLeft.value
            showFloatingButtons.value = true
            yield doubleRaf()
            floaterTop.value = '0'
            floaterLeft.value = '0'
            floaterWidth.value = '100vw'
            floaterHeight.value = '100vh'
            contentHeight.value = 'auto'
            opacity.value = '1'
            floaterOverflow.value = 'auto'
            floated.value = true
          }),
          props2.ripple ? RIPPLE_DELAY : 0
        )
      })
      return function floating2() {
        return _ref.apply(this, arguments)
      }
    })()
    var dropdown = () => {
      clearTimeout(dropper)
      clearTimeout(floater.value)
      floater.value = null
      floaterWidth.value = holderWidth.value
      floaterHeight.value = holderHeight.value
      floaterTop.value = dropdownFloaterTop
      floaterLeft.value = dropdownFloaterLeft
      contentHeight.value = '0px'
      opacity.value = '0'
      showFloatingButtons.value = false
      dropper = setTimeout(() => {
        holderWidth.value = 'auto'
        holderHeight.value = 'auto'
        floaterWidth.value = '100%'
        floaterHeight.value = '100%'
        floaterTop.value = 'auto'
        floaterLeft.value = 'auto'
        dropdownFloaterTop = 'auto'
        dropdownFloaterLeft = 'auto'
        floaterOverflow.value = 'hidden'
        floaterPosition.value = void 0
        floated.value = false
      }, props2.floatingDuration)
    }
    var close = () => {
      call(props2['onUpdate:floating'], false)
    }
    watch(
      () => props2.floating,
      (value) => {
        if (isRow.value) return
        nextTick(() => {
          value ? floating() : dropdown()
        })
      },
      {
        immediate: true,
      }
    )
    return {
      n: n$T,
      classes: classes$I,
      toSizeUnit,
      card,
      cardFloater,
      holderWidth,
      holderHeight,
      floater,
      floaterWidth,
      floaterHeight,
      floaterTop,
      floaterLeft,
      floaterPosition,
      floaterOverflow,
      contentHeight,
      opacity,
      zIndex,
      isRow,
      close,
      showFloatingButtons,
      floated,
    }
  },
})
Card.install = function (app) {
  app.component(Card.name, Card)
}
var props$J = {
  title: {
    type: [Number, String],
  },
  icon: {
    type: String,
  },
  desc: {
    type: String,
  },
  border: {
    type: Boolean,
    default: false,
  },
  iconClass: {
    type: String,
  },
  titleClass: {
    type: String,
  },
  descClass: {
    type: String,
  },
  extraClass: {
    type: String,
  },
}
var { n: n$S, classes: classes$H } = createNamespace('cell')
function render$P(_ctx, _cache2) {
  var _component_var_icon = resolveComponent('var-icon')
  return (
    openBlock(),
    createElementBlock(
      'div',
      {
        class: normalizeClass(_ctx.classes(_ctx.n(), [_ctx.border, _ctx.n('--border')])),
      },
      [
        _ctx.$slots.icon || _ctx.icon
          ? (openBlock(),
            createElementBlock(
              'div',
              {
                key: 0,
                class: normalizeClass(_ctx.classes(_ctx.n('icon'), [_ctx.iconClass, _ctx.iconClass])),
              },
              [
                renderSlot(_ctx.$slots, 'icon', {}, () => [
                  createVNode(
                    _component_var_icon,
                    {
                      class: 'var--flex',
                      name: _ctx.icon,
                    },
                    null,
                    8,
                    ['name']
                  ),
                ]),
              ],
              2
            ))
          : createCommentVNode('v-if', true),
        createElementVNode(
          'div',
          {
            class: normalizeClass(_ctx.n('content')),
          },
          [
            createElementVNode(
              'div',
              {
                class: normalizeClass(_ctx.classes(_ctx.n('title'), [_ctx.titleClass, _ctx.titleClass])),
              },
              [renderSlot(_ctx.$slots, 'default', {}, () => [createTextVNode(toDisplayString(_ctx.title), 1)])],
              2
            ),
            _ctx.$slots.desc || _ctx.desc
              ? (openBlock(),
                createElementBlock(
                  'div',
                  {
                    key: 0,
                    class: normalizeClass(_ctx.classes(_ctx.n('desc'), [_ctx.descClass, _ctx.descClass])),
                  },
                  [renderSlot(_ctx.$slots, 'desc', {}, () => [createTextVNode(toDisplayString(_ctx.desc), 1)])],
                  2
                ))
              : createCommentVNode('v-if', true),
          ],
          2
        ),
        _ctx.$slots.extra
          ? (openBlock(),
            createElementBlock(
              'div',
              {
                key: 1,
                class: normalizeClass(_ctx.classes(_ctx.n('extra'), [_ctx.extraClass, _ctx.extraClass])),
              },
              [renderSlot(_ctx.$slots, 'extra')],
              2
            ))
          : createCommentVNode('v-if', true),
      ],
      2
    )
  )
}
var Cell = defineComponent({
  render: render$P,
  name: 'VarCell',
  components: {
    VarIcon: Icon,
  },
  props: props$J,
  setup() {
    return {
      n: n$S,
      classes: classes$H,
    }
  },
})
Cell.install = function (app) {
  app.component(Cell.name, Cell)
}
var props$I = {
  errorMessage: {
    type: String,
    default: '',
  },
  maxlengthText: {
    type: String,
    default: '',
  },
}
var { n: n$R } = createNamespace('form-details')
function render$O(_ctx, _cache2) {
  return (
    openBlock(),
    createBlock(
      Transition,
      {
        name: _ctx.n(),
      },
      {
        default: withCtx(() => [
          _ctx.errorMessage || _ctx.maxlengthText
            ? (openBlock(),
              createElementBlock(
                'div',
                {
                  key: 0,
                  class: normalizeClass(_ctx.n()),
                },
                [
                  createElementVNode(
                    'div',
                    {
                      class: normalizeClass(_ctx.n('message')),
                    },
                    toDisplayString(_ctx.errorMessage),
                    3
                  ),
                  createElementVNode(
                    'div',
                    {
                      class: normalizeClass(_ctx.n('length')),
                    },
                    toDisplayString(_ctx.maxlengthText),
                    3
                  ),
                ],
                2
              ))
            : createCommentVNode('v-if', true),
        ]),
        _: 1,
      },
      8,
      ['name']
    )
  )
}
var FormDetails = defineComponent({
  render: render$O,
  name: 'VarFormDetails',
  props: props$I,
  setup: () => ({
    n: n$R,
  }),
})
FormDetails.install = function (app) {
  app.component(FormDetails.name, FormDetails)
}
var props$H = {
  modelValue: {
    type: [String, Number, Boolean, Object, Array],
    default: false,
  },
  checkedValue: {
    type: [String, Number, Boolean, Object, Array],
    default: true,
  },
  uncheckedValue: {
    type: [String, Number, Boolean, Object, Array],
    default: false,
  },
  checkedColor: {
    type: String,
  },
  uncheckedColor: {
    type: String,
  },
  disabled: {
    type: Boolean,
    default: false,
  },
  readonly: {
    type: Boolean,
    default: false,
  },
  iconSize: {
    type: [String, Number],
  },
  ripple: {
    type: Boolean,
    default: true,
  },
  validateTrigger: {
    type: Array,
    default: ['onChange'],
  },
  rules: {
    type: Array,
  },
  onClick: {
    type: Function,
  },
  onChange: {
    type: Function,
  },
  'onUpdate:modelValue': {
    type: Function,
  },
}
var CHECKBOX_GROUP_BIND_CHECKBOX_KEY = Symbol('CHECKBOX_GROUP_BIND_CHECKBOX_KEY')
var CHECKBOX_GROUP_COUNT_CHECKBOX_KEY = Symbol('CHECKBOX_GROUP_COUNT_CHECKBOX_KEY')
function useCheckboxes() {
  var { bindChildren, childProviders } = useChildren(CHECKBOX_GROUP_BIND_CHECKBOX_KEY)
  var { length } = useAtChildrenCounter(CHECKBOX_GROUP_COUNT_CHECKBOX_KEY)
  return {
    length,
    checkboxes: childProviders,
    bindCheckboxes: bindChildren,
  }
}
function useCheckboxGroup() {
  var { bindParent, parentProvider } = useParent(CHECKBOX_GROUP_BIND_CHECKBOX_KEY)
  var { index: index2 } = useAtParentIndex(CHECKBOX_GROUP_COUNT_CHECKBOX_KEY)
  return {
    index: index2,
    checkboxGroup: parentProvider,
    bindCheckboxGroup: bindParent,
  }
}
var FORM_BIND_FORM_ITEM_KEY = Symbol('FORM_BIND_FORM_ITEM_KEY')
function useForm() {
  var { bindParent, parentProvider } = useParent(FORM_BIND_FORM_ITEM_KEY)
  return {
    bindForm: bindParent,
    form: parentProvider,
  }
}
function useFormItems() {
  var { bindChildren, childProviders } = useChildren(FORM_BIND_FORM_ITEM_KEY)
  return {
    formItems: childProviders,
    bindFormItems: bindChildren,
  }
}
var { n: n$Q, classes: classes$G } = createNamespace('checkbox')
function render$N(_ctx, _cache2) {
  var _component_var_icon = resolveComponent('var-icon')
  var _component_var_form_details = resolveComponent('var-form-details')
  var _directive_ripple = resolveDirective('ripple')
  return (
    openBlock(),
    createElementBlock(
      'div',
      {
        class: normalizeClass(_ctx.n('wrap')),
        onClick:
          _cache2[0] ||
          (_cache2[0] = function () {
            return _ctx.handleClick && _ctx.handleClick(...arguments)
          }),
      },
      [
        createElementVNode(
          'div',
          {
            class: normalizeClass(_ctx.n()),
          },
          [
            withDirectives(
              (openBlock(),
              createElementBlock(
                'div',
                {
                  class: normalizeClass(
                    _ctx.classes(
                      _ctx.n('action'),
                      [_ctx.checked, _ctx.n('--checked'), _ctx.n('--unchecked')],
                      [_ctx.errorMessage || _ctx.checkboxGroupErrorMessage, _ctx.n('--error')],
                      [_ctx.formDisabled || _ctx.disabled, _ctx.n('--disabled')]
                    )
                  ),
                  style: normalizeStyle({
                    color: _ctx.checked ? _ctx.checkedColor : _ctx.uncheckedColor,
                  }),
                },
                [
                  _ctx.checked
                    ? renderSlot(
                        _ctx.$slots,
                        'checked-icon',
                        {
                          key: 0,
                        },
                        () => [
                          createVNode(
                            _component_var_icon,
                            {
                              class: normalizeClass(
                                _ctx.classes(_ctx.n('icon'), [_ctx.withAnimation, _ctx.n('--with-animation')])
                              ),
                              name: 'checkbox-marked',
                              size: _ctx.iconSize,
                              'var-checkbox-cover': '',
                            },
                            null,
                            8,
                            ['class', 'size']
                          ),
                        ]
                      )
                    : renderSlot(
                        _ctx.$slots,
                        'unchecked-icon',
                        {
                          key: 1,
                        },
                        () => [
                          createVNode(
                            _component_var_icon,
                            {
                              class: normalizeClass(
                                _ctx.classes(_ctx.n('icon'), [_ctx.withAnimation, _ctx.n('--with-animation')])
                              ),
                              name: 'checkbox-blank-outline',
                              size: _ctx.iconSize,
                              'var-checkbox-cover': '',
                            },
                            null,
                            8,
                            ['class', 'size']
                          ),
                        ]
                      ),
                ],
                6
              )),
              [
                [
                  _directive_ripple,
                  {
                    disabled: _ctx.formReadonly || _ctx.readonly || _ctx.formDisabled || _ctx.disabled || !_ctx.ripple,
                  },
                ],
              ]
            ),
            createElementVNode(
              'div',
              {
                class: normalizeClass(
                  _ctx.classes(
                    _ctx.n('text'),
                    [_ctx.errorMessage || _ctx.checkboxGroupErrorMessage, _ctx.n('--error')],
                    [_ctx.formDisabled || _ctx.disabled, _ctx.n('--disabled')]
                  )
                ),
              },
              [renderSlot(_ctx.$slots, 'default')],
              2
            ),
          ],
          2
        ),
        createVNode(
          _component_var_form_details,
          {
            'error-message': _ctx.errorMessage,
          },
          null,
          8,
          ['error-message']
        ),
      ],
      2
    )
  )
}
var Checkbox = defineComponent({
  render: render$N,
  name: 'VarCheckbox',
  directives: {
    Ripple,
  },
  components: {
    VarIcon: Icon,
    VarFormDetails: FormDetails,
  },
  props: props$H,
  setup(props2) {
    var value = ref(false)
    var checked = computed(() => value.value === props2.checkedValue)
    var checkedValue = computed(() => props2.checkedValue)
    var withAnimation = ref(false)
    var { checkboxGroup, bindCheckboxGroup } = useCheckboxGroup()
    var { form, bindForm } = useForm()
    var { errorMessage, validateWithTrigger: vt, validate: v, resetValidation } = useValidation()
    var validateWithTrigger = (trigger) => {
      nextTick(() => {
        var { validateTrigger, rules, modelValue } = props2
        vt(validateTrigger, trigger, rules, modelValue)
      })
    }
    var change = (changedValue) => {
      value.value = changedValue
      var { checkedValue: checkedValue2, onChange } = props2
      call(props2['onUpdate:modelValue'], value.value)
      call(onChange, value.value)
      validateWithTrigger('onChange')
      changedValue === checkedValue2
        ? checkboxGroup == null
          ? void 0
          : checkboxGroup.onChecked(checkedValue2)
        : checkboxGroup == null
        ? void 0
        : checkboxGroup.onUnchecked(checkedValue2)
    }
    var handleClick = (e) => {
      var { disabled, readonly, checkedValue: checkedValue2, uncheckedValue, onClick } = props2
      if ((form != null && form.disabled.value) || disabled) {
        return
      }
      call(onClick, e)
      if ((form != null && form.readonly.value) || readonly) {
        return
      }
      withAnimation.value = true
      var maximum = checkboxGroup ? checkboxGroup.checkedCount.value >= Number(checkboxGroup.max.value) : false
      if (!checked.value && maximum) {
        return
      }
      change(checked.value ? uncheckedValue : checkedValue2)
    }
    var sync = (values) => {
      var { checkedValue: checkedValue2, uncheckedValue } = props2
      value.value = values.includes(checkedValue2) ? checkedValue2 : uncheckedValue
    }
    var resetWithAnimation = () => {
      withAnimation.value = false
    }
    var reset = () => {
      call(props2['onUpdate:modelValue'], props2.uncheckedValue)
      resetValidation()
    }
    var toggle = (changedValue) => {
      var { checkedValue: checkedValue2, uncheckedValue } = props2
      var shouldReverse = ![checkedValue2, uncheckedValue].includes(changedValue)
      if (shouldReverse) {
        changedValue = checked.value ? uncheckedValue : checkedValue2
      }
      change(changedValue)
    }
    var validate2 = () => v(props2.rules, props2.modelValue)
    watch(
      () => props2.modelValue,
      (newValue) => {
        value.value = newValue
      },
      {
        immediate: true,
      }
    )
    var checkboxProvider = {
      checkedValue,
      checked,
      sync,
      validate: validate2,
      resetValidation,
      reset,
      resetWithAnimation,
    }
    call(bindCheckboxGroup, checkboxProvider)
    call(bindForm, checkboxProvider)
    return {
      withAnimation,
      checked,
      errorMessage,
      checkboxGroupErrorMessage: checkboxGroup == null ? void 0 : checkboxGroup.errorMessage,
      formDisabled: form == null ? void 0 : form.disabled,
      formReadonly: form == null ? void 0 : form.readonly,
      n: n$Q,
      classes: classes$G,
      handleClick,
      toggle,
      reset,
      validate: validate2,
      resetValidation,
    }
  },
})
Checkbox.install = function (app) {
  app.component(Checkbox.name, Checkbox)
}
function directionValidator$3(direction) {
  return ['horizontal', 'vertical'].includes(direction)
}
var props$G = {
  modelValue: {
    type: Array,
    default: () => [],
  },
  max: {
    type: [String, Number],
  },
  direction: {
    type: String,
    default: 'horizontal',
    validator: directionValidator$3,
  },
  validateTrigger: {
    type: Array,
    default: ['onChange'],
  },
  rules: {
    type: Array,
  },
  onChange: {
    type: Function,
  },
  'onUpdate:modelValue': {
    type: Function,
  },
}
var { n: n$P, classes: classes$F } = createNamespace('checkbox-group')
function render$M(_ctx, _cache2) {
  var _component_var_form_details = resolveComponent('var-form-details')
  return (
    openBlock(),
    createElementBlock(
      'div',
      {
        class: normalizeClass(_ctx.n('wrap')),
      },
      [
        createElementVNode(
          'div',
          {
            class: normalizeClass(_ctx.classes(_ctx.n(), _ctx.n('--' + _ctx.direction))),
          },
          [renderSlot(_ctx.$slots, 'default')],
          2
        ),
        createVNode(
          _component_var_form_details,
          {
            'error-message': _ctx.errorMessage,
          },
          null,
          8,
          ['error-message']
        ),
      ],
      2
    )
  )
}
var CheckboxGroup = defineComponent({
  render: render$M,
  name: 'VarCheckboxGroup',
  components: {
    VarFormDetails: FormDetails,
  },
  props: props$G,
  setup(props2) {
    var max2 = computed(() => props2.max)
    var checkedCount = computed(() => props2.modelValue.length)
    var { length, checkboxes, bindCheckboxes } = useCheckboxes()
    var { bindForm } = useForm()
    var { errorMessage, validateWithTrigger: vt, validate: v, resetValidation } = useValidation()
    var checkboxGroupErrorMessage = computed(() => errorMessage.value)
    var validateWithTrigger = (trigger) => {
      nextTick(() => {
        var { validateTrigger, rules, modelValue } = props2
        vt(validateTrigger, trigger, rules, modelValue)
      })
    }
    var change = (changedModelValue) => {
      call(props2['onUpdate:modelValue'], changedModelValue)
      call(props2.onChange, changedModelValue)
      validateWithTrigger('onChange')
    }
    var onChecked = (changedValue) => {
      var { modelValue } = props2
      if (!modelValue.includes(changedValue)) {
        change([...modelValue, changedValue])
      }
    }
    var onUnchecked = (changedValue) => {
      var { modelValue } = props2
      if (!modelValue.includes(changedValue)) {
        return
      }
      change(modelValue.filter((value) => value !== changedValue))
    }
    var syncCheckboxes = () =>
      checkboxes.forEach((_ref) => {
        var { sync } = _ref
        return sync(props2.modelValue)
      })
    var resetWithAnimation = () => {
      checkboxes.forEach((checkbox) => checkbox.resetWithAnimation())
    }
    var checkAll2 = () => {
      var checkedValues = checkboxes.map((_ref2) => {
        var { checkedValue } = _ref2
        return checkedValue.value
      })
      var changedModelValue = uniq(checkedValues)
      resetWithAnimation()
      call(props2['onUpdate:modelValue'], changedModelValue)
      return changedModelValue
    }
    var inverseAll = () => {
      var checkedValues = checkboxes
        .filter((_ref3) => {
          var { checked } = _ref3
          return !checked.value
        })
        .map((_ref4) => {
          var { checkedValue } = _ref4
          return checkedValue.value
        })
      var changedModelValue = uniq(checkedValues)
      resetWithAnimation()
      call(props2['onUpdate:modelValue'], changedModelValue)
      return changedModelValue
    }
    var reset = () => {
      call(props2['onUpdate:modelValue'], [])
      resetValidation()
    }
    var validate2 = () => v(props2.rules, props2.modelValue)
    watch(() => props2.modelValue, syncCheckboxes, {
      deep: true,
    })
    watch(() => length.value, syncCheckboxes)
    var checkboxGroupProvider = {
      max: max2,
      checkedCount,
      onChecked,
      onUnchecked,
      validate: validate2,
      resetValidation,
      reset,
      errorMessage: checkboxGroupErrorMessage,
    }
    bindCheckboxes(checkboxGroupProvider)
    call(bindForm, checkboxGroupProvider)
    return {
      errorMessage,
      n: n$P,
      classes: classes$F,
      checkAll: checkAll2,
      inverseAll,
      reset,
      validate: validate2,
      resetValidation,
    }
  },
})
CheckboxGroup.install = function (app) {
  app.component(CheckboxGroup.name, CheckboxGroup)
}
function typeValidator$3(type) {
  return ['default', 'primary', 'info', 'success', 'warning', 'danger'].includes(type)
}
function sizeValidator$1(size) {
  return ['normal', 'mini', 'small', 'large'].includes(size)
}
var props$F = {
  type: {
    type: String,
    default: 'default',
    validator: typeValidator$3,
  },
  size: {
    type: String,
    default: 'normal',
    validator: sizeValidator$1,
  },
  color: {
    type: String,
  },
  textColor: {
    type: String,
  },
  iconName: pickProps(props$T, 'name'),
  plain: {
    type: Boolean,
    default: false,
  },
  round: {
    type: Boolean,
    default: true,
  },
  block: {
    type: Boolean,
    default: false,
  },
  closable: {
    type: Boolean,
    default: false,
  },
  onClose: {
    type: Function,
  },
}
var { n: n$O, classes: classes$E } = createNamespace('chip')
function render$L(_ctx, _cache2) {
  var _component_var_icon = resolveComponent('var-icon')
  return (
    openBlock(),
    createBlock(
      Transition,
      {
        name: 'var-fade',
      },
      {
        default: withCtx(() => [
          createElementVNode(
            'span',
            mergeProps(
              {
                class: _ctx.classes(_ctx.n(), 'var--box', ..._ctx.contentClass),
                style: _ctx.chipStyles,
              },
              _ctx.$attrs
            ),
            [
              renderSlot(_ctx.$slots, 'left'),
              createElementVNode(
                'span',
                {
                  class: normalizeClass(_ctx.n('text-' + _ctx.size)),
                },
                [renderSlot(_ctx.$slots, 'default')],
                2
              ),
              renderSlot(_ctx.$slots, 'right'),
              _ctx.closable
                ? (openBlock(),
                  createElementBlock(
                    'span',
                    {
                      key: 0,
                      class: normalizeClass(_ctx.n('--close')),
                      onClick:
                        _cache2[0] ||
                        (_cache2[0] = function () {
                          return _ctx.onClose && _ctx.onClose(...arguments)
                        }),
                    },
                    [
                      createVNode(
                        _component_var_icon,
                        {
                          name: '' + (_ctx.iconName ? _ctx.iconName : 'close-circle'),
                        },
                        null,
                        8,
                        ['name']
                      ),
                    ],
                    2
                  ))
                : createCommentVNode('v-if', true),
            ],
            16
          ),
        ]),
        _: 3,
      }
    )
  )
}
var Chip = defineComponent({
  render: render$L,
  name: 'VarChip',
  components: {
    VarIcon: Icon,
  },
  inheritAttrs: false,
  props: props$F,
  setup(props2) {
    var chipStyles = computed(() => {
      var { plain, textColor, color } = props2
      if (plain) {
        return {
          color: textColor || color,
          borderColor: color,
        }
      }
      return {
        color: textColor,
        background: color,
      }
    })
    var contentClass = computed(() => {
      var { size, block, type, plain, round: round2 } = props2
      var blockClass = block ? 'var--flex' : 'var--inline-flex'
      var plainTypeClass = plain ? n$O('plain') + ' ' + n$O('plain-' + type) : n$O('--' + type)
      var roundClass = round2 ? n$O('--round') : null
      return [n$O('--' + size), blockClass, plainTypeClass, roundClass]
    })
    return {
      n: n$O,
      classes: classes$E,
      chipStyles,
      contentClass,
    }
  },
})
Chip.install = function (app) {
  app.component(Chip.name, Chip)
}
var props$E = {
  span: {
    type: [String, Number],
    default: 24,
  },
  offset: {
    type: [String, Number],
    default: 0,
  },
  onClick: {
    type: Function,
  },
  xs: {
    type: [Object, Number, String],
  },
  sm: {
    type: [Object, Number, String],
  },
  md: {
    type: [Object, Number, String],
  },
  lg: {
    type: [Object, Number, String],
  },
  xl: {
    type: [Object, Number, String],
  },
}
var ROW_BIND_COL_KEY = Symbol('ROW_BIND_COL_KEY')
var ROW_COUNT_COL_KEY = Symbol('ROW_COUNT_COL_KEY')
function useCols() {
  var { bindChildren, childProviders } = useChildren(ROW_BIND_COL_KEY)
  var { length } = useAtChildrenCounter(ROW_COUNT_COL_KEY)
  return {
    length,
    cols: childProviders,
    bindCols: bindChildren,
  }
}
function useRow() {
  var { parentProvider, bindParent } = useParent(ROW_BIND_COL_KEY)
  var { index: index2 } = useAtParentIndex(ROW_COUNT_COL_KEY)
  if (!parentProvider || !bindParent || !index2) {
    console.warn('col must in row')
  }
  return {
    index: index2,
    row: parentProvider,
    bindRow: bindParent,
  }
}
var { n: n$N, classes: classes$D } = createNamespace('col')
function render$K(_ctx, _cache2) {
  return (
    openBlock(),
    createElementBlock(
      'div',
      {
        class: normalizeClass(
          _ctx.classes(
            _ctx.n(),
            'var--box',
            [_ctx.span >= 0, _ctx.n('--span-' + _ctx.span)],
            [_ctx.offset, _ctx.n('--offset-' + _ctx.offset)],
            ..._ctx.getSize('xs', _ctx.xs),
            ..._ctx.getSize('sm', _ctx.sm),
            ..._ctx.getSize('md', _ctx.md),
            ..._ctx.getSize('lg', _ctx.lg),
            ..._ctx.getSize('xl', _ctx.xl)
          )
        ),
        style: normalizeStyle({
          paddingLeft: _ctx.toSizeUnit(_ctx.padding.left),
          paddingRight: _ctx.toSizeUnit(_ctx.padding.right),
        }),
        onClick:
          _cache2[0] ||
          (_cache2[0] = function () {
            return _ctx.onClick && _ctx.onClick(...arguments)
          }),
      },
      [renderSlot(_ctx.$slots, 'default')],
      6
    )
  )
}
var Col = defineComponent({
  render: render$K,
  name: 'VarCol',
  props: props$E,
  setup(props2) {
    var padding = ref({
      left: 0,
      right: 0,
    })
    var span = computed(() => toNumber(props2.span))
    var offset = computed(() => toNumber(props2.offset))
    var { row, bindRow } = useRow()
    var colProvider = {
      setPadding(pad) {
        padding.value = pad
      },
    }
    var getSize = (mode, size) => {
      var classes2 = []
      if (size == null) {
        return classes2
      }
      if (isPlainObject$1(size)) {
        var { offset: _offset, span: _span } = size
        Number(_span) >= 0 && classes2.push(n$N('--span-' + mode + '-' + _span))
        _offset && classes2.push(n$N('--offset-' + mode + '-' + _offset))
      } else {
        Number(size) >= 0 && classes2.push(n$N('--span-' + mode + '-' + size))
      }
      return classes2
    }
    watch([() => props2.span, () => props2.offset], () => {
      row == null ? void 0 : row.computePadding()
    })
    call(bindRow, colProvider)
    return {
      n: n$N,
      classes: classes$D,
      padding,
      toNumber,
      toSizeUnit,
      getSize,
      span,
      offset,
    }
  },
})
Col.install = function (app) {
  app.component(Col.name, Col)
}
var COLLAPSE_BIND_COLLAPSE_ITEM_KEY = Symbol('COLLAPSE_BIND_COLLAPSE_ITEM_KEY')
var COLLAPSE_COUNT_COLLAPSE_ITEM_KEY = Symbol('COLLAPSE_COUNT_COLLAPSE_ITEM_KEY')
function useCollapseItem() {
  var { bindChildren, childProviders } = useChildren(COLLAPSE_BIND_COLLAPSE_ITEM_KEY)
  var { length } = useAtChildrenCounter(COLLAPSE_COUNT_COLLAPSE_ITEM_KEY)
  return {
    length,
    collapseItem: childProviders,
    bindCollapseItem: bindChildren,
  }
}
var props$D = {
  modelValue: {
    type: [Array, String, Number],
  },
  accordion: {
    type: Boolean,
    default: false,
  },
  offset: {
    type: Boolean,
    default: true,
  },
  onChange: {
    type: Function,
  },
  'onUpdate:modelValue': {
    type: Function,
  },
}
var { n: n$M } = createNamespace('collapse')
function render$J(_ctx, _cache2) {
  return (
    openBlock(),
    createElementBlock(
      'div',
      {
        class: normalizeClass(_ctx.n()),
      },
      [renderSlot(_ctx.$slots, 'default')],
      2
    )
  )
}
var Collapse = defineComponent({
  render: render$J,
  name: 'VarCollapse',
  props: props$D,
  setup(props2) {
    var { length, collapseItem, bindCollapseItem } = useCollapseItem()
    var active = computed(() => props2.modelValue)
    var offset = computed(() => props2.offset)
    var checkValue = () => {
      if (!props2.accordion && !isArray$1(props2.modelValue)) {
        console.error('[Varlet] Collapse: type of prop "modelValue" should be an Array')
        return false
      }
      if (props2.accordion && isArray$1(props2.modelValue)) {
        console.error('[Varlet] Collapse: type of prop "modelValue" should be a String or Number')
        return false
      }
      return true
    }
    var getValue = (value, isExpand) => {
      if (!checkValue()) return null
      if (isExpand) return props2.accordion ? value : [...props2.modelValue, value]
      return props2.accordion ? null : props2.modelValue.filter((name) => name !== value)
    }
    var updateItem = (value, isExpand) => {
      var modelValue = getValue(value, isExpand)
      call(props2['onUpdate:modelValue'], modelValue)
      call(props2.onChange, modelValue)
    }
    var matchName = () => {
      if (props2.accordion) {
        return collapseItem.find((_ref) => {
          var { name } = _ref
          return props2.modelValue === name.value
        })
      }
      var filterItem = collapseItem.filter((_ref2) => {
        var { name } = _ref2
        if (name.value === void 0) return false
        return props2.modelValue.includes(name.value)
      })
      return filterItem.length ? filterItem : void 0
    }
    var matchIndex = () => {
      if (props2.accordion) {
        return collapseItem.find((_ref3) => {
          var { index: index2, name } = _ref3
          return name.value === void 0 ? props2.modelValue === index2.value : false
        })
      }
      return collapseItem.filter((_ref4) => {
        var { index: index2, name } = _ref4
        return name.value === void 0 ? props2.modelValue.includes(index2.value) : false
      })
    }
    var resize = () => {
      if (!checkValue()) return
      var matchProviders = matchName() || matchIndex()
      if ((props2.accordion && !matchProviders) || (!props2.accordion && !matchProviders.length)) {
        collapseItem.forEach((provider) => {
          provider.init(props2.accordion, false)
        })
        return
      }
      collapseItem.forEach((provider) => {
        var isShow = props2.accordion ? matchProviders === provider : matchProviders.includes(provider)
        provider.init(props2.accordion, isShow)
      })
    }
    var collapseProvider = {
      active,
      offset,
      updateItem,
    }
    bindCollapseItem(collapseProvider)
    watch(
      () => length.value,
      () => nextTick().then(resize)
    )
    watch(
      () => props2.modelValue,
      () => nextTick().then(resize)
    )
    return {
      n: n$M,
    }
  },
})
Collapse.install = function (app) {
  app.component(Collapse.name, Collapse)
}
function useCollapse() {
  var { parentProvider, bindParent } = useParent(COLLAPSE_BIND_COLLAPSE_ITEM_KEY)
  var { index: index2 } = useAtParentIndex(COLLAPSE_COUNT_COLLAPSE_ITEM_KEY)
  if (!parentProvider || !bindParent || !index2) {
    throw Error('[Varlet] Collapse: <var-collapse-item/> must in <var-collapse>')
  }
  return {
    index: index2,
    collapse: parentProvider,
    bindCollapse: bindParent,
  }
}
var props$C = {
  name: {
    type: [String, Number],
  },
  title: {
    type: String,
  },
  icon: {
    type: String,
    default: 'chevron-down',
  },
  disabled: {
    type: Boolean,
    default: false,
  },
}
var { n: n$L, classes: classes$C } = createNamespace('collapse-item')
function render$I(_ctx, _cache2) {
  var _component_var_icon = resolveComponent('var-icon')
  return (
    openBlock(),
    createElementBlock(
      'div',
      {
        class: normalizeClass(
          _ctx.classes(_ctx.n(), [_ctx.offset && _ctx.isShow, _ctx.n('--active')], [_ctx.disabled, _ctx.n('--disable')])
        ),
      },
      [
        createElementVNode(
          'div',
          {
            class: normalizeClass(_ctx.n('header')),
            onClick: _cache2[0] || (_cache2[0] = ($event) => _ctx.toggle()),
          },
          [
            createElementVNode(
              'div',
              {
                class: normalizeClass(_ctx.n('header-title')),
              },
              [renderSlot(_ctx.$slots, 'title', {}, () => [createTextVNode(toDisplayString(_ctx.title), 1)])],
              2
            ),
            createElementVNode(
              'div',
              {
                class: normalizeClass(_ctx.n('header-icon')),
              },
              [
                renderSlot(_ctx.$slots, 'icon', {}, () => [
                  createVNode(
                    _component_var_icon,
                    {
                      name: _ctx.icon,
                      transition: 250,
                      class: normalizeClass(
                        _ctx.classes(
                          _ctx.n('header-icon'),
                          [_ctx.isShow && _ctx.icon === 'chevron-down', _ctx.n('header-open')],
                          [_ctx.disabled, _ctx.n('header--disable')]
                        )
                      ),
                    },
                    null,
                    8,
                    ['name', 'class']
                  ),
                ]),
              ],
              2
            ),
          ],
          2
        ),
        withDirectives(
          createElementVNode(
            'div',
            {
              class: normalizeClass(_ctx.n('content')),
              ref: 'contentEl',
              onTransitionend:
                _cache2[1] ||
                (_cache2[1] = function () {
                  return _ctx.transitionend && _ctx.transitionend(...arguments)
                }),
            },
            [
              createElementVNode(
                'div',
                {
                  class: normalizeClass(_ctx.n('content-wrap')),
                },
                [renderSlot(_ctx.$slots, 'default')],
                2
              ),
            ],
            34
          ),
          [[vShow, _ctx.show]]
        ),
      ],
      2
    )
  )
}
var CollapseItem = defineComponent({
  render: render$I,
  name: 'VarCollapseItem',
  components: {
    VarIcon: Icon,
  },
  props: props$C,
  setup(props2) {
    var { index: index2, collapse, bindCollapse } = useCollapse()
    var contentEl = ref(null)
    var show = ref(false)
    var isShow = ref(false)
    var { active, offset, updateItem } = collapse
    var name = computed(() => props2.name)
    var init = (accordion, show2) => {
      if (active.value === void 0 || (accordion && isArray$1(active.value)) || show2 === isShow.value) return
      isShow.value = show2
      toggle(true)
    }
    var toggle = (initOrAccordion) => {
      if (props2.disabled) return
      if (!initOrAccordion) {
        updateItem(props2.name || index2.value, !isShow.value)
      }
    }
    var openPanel = () => {
      if (!contentEl.value) return
      contentEl.value.style.height = ''
      show.value = true
      nextTick(() => {
        var { offsetHeight } = contentEl.value
        contentEl.value.style.height = 0 + 'px'
        requestAnimationFrame(() => {
          contentEl.value.style.height = offsetHeight + 'px'
        })
      })
    }
    var closePanel = () => {
      if (!contentEl.value) return
      contentEl.value.style.height = 0 + 'px'
    }
    var transitionend = () => {
      if (!isShow.value) {
        show.value = false
        contentEl.value.style.height = ''
      }
    }
    var collapseItemProvider = {
      index: index2,
      name,
      init,
    }
    bindCollapse(collapseItemProvider)
    watch(isShow, (value) => {
      if (value) openPanel()
      else closePanel()
    })
    return {
      n: n$L,
      classes: classes$C,
      show,
      isShow,
      offset,
      toggle,
      contentEl,
      transitionend,
    }
  },
})
CollapseItem.install = function (app) {
  app.component(CollapseItem.name, CollapseItem)
}
var props$B = {
  time: {
    type: [String, Number],
    default: 0,
  },
  format: {
    type: String,
    default: 'HH : mm : ss',
  },
  autoStart: {
    type: Boolean,
    default: true,
  },
  onEnd: {
    type: Function,
  },
  onChange: {
    type: Function,
  },
}
var { n: n$K } = createNamespace('countdown')
var SECOND = 1e3
var MINUTE = 60 * SECOND
var HOUR = 60 * MINUTE
var DAY = 24 * HOUR
function render$H(_ctx, _cache2) {
  return (
    openBlock(),
    createElementBlock(
      'div',
      {
        class: normalizeClass(_ctx.n()),
      },
      [
        renderSlot(_ctx.$slots, 'default', normalizeProps(guardReactiveProps(_ctx.timeData)), () => [
          createTextVNode(toDisplayString(_ctx.showTime), 1),
        ]),
      ],
      2
    )
  )
}
var Countdown = defineComponent({
  render: render$H,
  name: 'VarCountdown',
  props: props$B,
  setup(props2) {
    var endTime = ref(0)
    var isStart = ref(false)
    var showTime = ref('')
    var handle = ref(0)
    var pauseTime = ref(0)
    var timeData = ref({
      days: 0,
      hours: 0,
      minutes: 0,
      seconds: 0,
      milliseconds: 0,
    })
    var formatTime = (durationTime) => {
      var days = Math.floor(durationTime / DAY)
      var hours = Math.floor((durationTime % DAY) / HOUR)
      var minutes = Math.floor((durationTime % HOUR) / MINUTE)
      var seconds = Math.floor((durationTime % MINUTE) / SECOND)
      var milliseconds = Math.floor(durationTime % SECOND)
      var time = {
        days,
        hours,
        minutes,
        seconds,
        milliseconds,
      }
      timeData.value = time
      call(props2.onChange, timeData.value)
      showTime.value = parseFormat(props2.format, time)
    }
    var countdown = () => {
      var { time, onEnd, autoStart } = props2
      var now = Date.now()
      if (!endTime.value) endTime.value = now + toNumber(time)
      var durationTime = endTime.value - now
      if (durationTime < 0) durationTime = 0
      pauseTime.value = durationTime
      formatTime(durationTime)
      if (durationTime === 0) {
        call(onEnd)
        return
      }
      if (autoStart || isStart.value) handle.value = requestAnimationFrame(countdown)
    }
    var start = () => {
      if (isStart.value) return
      isStart.value = true
      endTime.value = Date.now() + (pauseTime.value || toNumber(props2.time))
      countdown()
    }
    var pause = () => {
      isStart.value = false
    }
    var reset = () => {
      endTime.value = 0
      isStart.value = false
      cancelAnimationFrame(handle.value)
      countdown()
    }
    watch(
      () => props2.time,
      () => reset(),
      {
        immediate: true,
      }
    )
    return {
      showTime,
      timeData,
      n: n$K,
      start,
      pause,
      reset,
    }
  },
})
Countdown.install = function (app) {
  app.component(Countdown.name, Countdown)
}
var EXP_LIMIT = 9e15,
  MAX_DIGITS = 1e9,
  NUMERALS = '0123456789abcdef',
  LN10 =
    '2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058',
  PI =
    '3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789',
  DEFAULTS = {
    precision: 20,
    rounding: 4,
    modulo: 1,
    toExpNeg: -7,
    toExpPos: 21,
    minE: -EXP_LIMIT,
    maxE: EXP_LIMIT,
    crypto: false,
  },
  inexact,
  quadrant,
  external = true,
  decimalError = '[DecimalError] ',
  invalidArgument = decimalError + 'Invalid argument: ',
  precisionLimitExceeded = decimalError + 'Precision limit exceeded',
  cryptoUnavailable = decimalError + 'crypto unavailable',
  tag = '[object Decimal]',
  mathfloor = Math.floor,
  mathpow = Math.pow,
  isBinary = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i,
  isHex = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i,
  isOctal = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i,
  isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,
  BASE = 1e7,
  LOG_BASE = 7,
  MAX_SAFE_INTEGER = 9007199254740991,
  LN10_PRECISION = LN10.length - 1,
  PI_PRECISION = PI.length - 1,
  P = { toStringTag: tag }
P.absoluteValue = P.abs = function () {
  var x = new this.constructor(this)
  if (x.s < 0) x.s = 1
  return finalise(x)
}
P.ceil = function () {
  return finalise(new this.constructor(this), this.e + 1, 2)
}
P.clampedTo = P.clamp = function (min2, max2) {
  var k,
    x = this,
    Ctor = x.constructor
  min2 = new Ctor(min2)
  max2 = new Ctor(max2)
  if (!min2.s || !max2.s) return new Ctor(NaN)
  if (min2.gt(max2)) throw Error(invalidArgument + max2)
  k = x.cmp(min2)
  return k < 0 ? min2 : x.cmp(max2) > 0 ? max2 : new Ctor(x)
}
P.comparedTo = P.cmp = function (y2) {
  var i,
    j,
    xdL,
    ydL,
    x = this,
    xd = x.d,
    yd = (y2 = new x.constructor(y2)).d,
    xs = x.s,
    ys = y2.s
  if (!xd || !yd) {
    return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ (xs < 0) ? 1 : -1
  }
  if (!xd[0] || !yd[0]) return xd[0] ? xs : yd[0] ? -ys : 0
  if (xs !== ys) return xs
  if (x.e !== y2.e) return (x.e > y2.e) ^ (xs < 0) ? 1 : -1
  xdL = xd.length
  ydL = yd.length
  for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {
    if (xd[i] !== yd[i]) return (xd[i] > yd[i]) ^ (xs < 0) ? 1 : -1
  }
  return xdL === ydL ? 0 : (xdL > ydL) ^ (xs < 0) ? 1 : -1
}
P.cosine = P.cos = function () {
  var pr,
    rm,
    x = this,
    Ctor = x.constructor
  if (!x.d) return new Ctor(NaN)
  if (!x.d[0]) return new Ctor(1)
  pr = Ctor.precision
  rm = Ctor.rounding
  Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE
  Ctor.rounding = 1
  x = cosine(Ctor, toLessThanHalfPi(Ctor, x))
  Ctor.precision = pr
  Ctor.rounding = rm
  return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true)
}
P.cubeRoot = P.cbrt = function () {
  var e,
    m2,
    n2,
    r,
    rep,
    s2,
    sd,
    t2,
    t3,
    t3plusx,
    x = this,
    Ctor = x.constructor
  if (!x.isFinite() || x.isZero()) return new Ctor(x)
  external = false
  s2 = x.s * mathpow(x.s * x, 1 / 3)
  if (!s2 || Math.abs(s2) == 1 / 0) {
    n2 = digitsToString(x.d)
    e = x.e
    if ((s2 = (e - n2.length + 1) % 3)) n2 += s2 == 1 || s2 == -2 ? '0' : '00'
    s2 = mathpow(n2, 1 / 3)
    e = mathfloor((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2))
    if (s2 == 1 / 0) {
      n2 = '5e' + e
    } else {
      n2 = s2.toExponential()
      n2 = n2.slice(0, n2.indexOf('e') + 1) + e
    }
    r = new Ctor(n2)
    r.s = x.s
  } else {
    r = new Ctor(s2.toString())
  }
  sd = (e = Ctor.precision) + 3
  for (;;) {
    t2 = r
    t3 = t2.times(t2).times(t2)
    t3plusx = t3.plus(x)
    r = divide(t3plusx.plus(x).times(t2), t3plusx.plus(t3), sd + 2, 1)
    if (digitsToString(t2.d).slice(0, sd) === (n2 = digitsToString(r.d)).slice(0, sd)) {
      n2 = n2.slice(sd - 3, sd + 1)
      if (n2 == '9999' || (!rep && n2 == '4999')) {
        if (!rep) {
          finalise(t2, e + 1, 0)
          if (t2.times(t2).times(t2).eq(x)) {
            r = t2
            break
          }
        }
        sd += 4
        rep = 1
      } else {
        if (!+n2 || (!+n2.slice(1) && n2.charAt(0) == '5')) {
          finalise(r, e + 1, 1)
          m2 = !r.times(r).times(r).eq(x)
        }
        break
      }
    }
  }
  external = true
  return finalise(r, e, Ctor.rounding, m2)
}
P.decimalPlaces = P.dp = function () {
  var w2,
    d2 = this.d,
    n2 = NaN
  if (d2) {
    w2 = d2.length - 1
    n2 = (w2 - mathfloor(this.e / LOG_BASE)) * LOG_BASE
    w2 = d2[w2]
    if (w2) for (; w2 % 10 == 0; w2 /= 10) n2--
    if (n2 < 0) n2 = 0
  }
  return n2
}
P.dividedBy = P.div = function (y2) {
  return divide(this, new this.constructor(y2))
}
P.dividedToIntegerBy = P.divToInt = function (y2) {
  var x = this,
    Ctor = x.constructor
  return finalise(divide(x, new Ctor(y2), 0, 1, 1), Ctor.precision, Ctor.rounding)
}
P.equals = P.eq = function (y2) {
  return this.cmp(y2) === 0
}
P.floor = function () {
  return finalise(new this.constructor(this), this.e + 1, 3)
}
P.greaterThan = P.gt = function (y2) {
  return this.cmp(y2) > 0
}
P.greaterThanOrEqualTo = P.gte = function (y2) {
  var k = this.cmp(y2)
  return k == 1 || k === 0
}
P.hyperbolicCosine = P.cosh = function () {
  var k,
    n2,
    pr,
    rm,
    len,
    x = this,
    Ctor = x.constructor,
    one = new Ctor(1)
  if (!x.isFinite()) return new Ctor(x.s ? 1 / 0 : NaN)
  if (x.isZero()) return one
  pr = Ctor.precision
  rm = Ctor.rounding
  Ctor.precision = pr + Math.max(x.e, x.sd()) + 4
  Ctor.rounding = 1
  len = x.d.length
  if (len < 32) {
    k = Math.ceil(len / 3)
    n2 = (1 / tinyPow(4, k)).toString()
  } else {
    k = 16
    n2 = '2.3283064365386962890625e-10'
  }
  x = taylorSeries(Ctor, 1, x.times(n2), new Ctor(1), true)
  var cosh2_x,
    i = k,
    d8 = new Ctor(8)
  for (; i--; ) {
    cosh2_x = x.times(x)
    x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))))
  }
  return finalise(x, (Ctor.precision = pr), (Ctor.rounding = rm), true)
}
P.hyperbolicSine = P.sinh = function () {
  var k,
    pr,
    rm,
    len,
    x = this,
    Ctor = x.constructor
  if (!x.isFinite() || x.isZero()) return new Ctor(x)
  pr = Ctor.precision
  rm = Ctor.rounding
  Ctor.precision = pr + Math.max(x.e, x.sd()) + 4
  Ctor.rounding = 1
  len = x.d.length
  if (len < 3) {
    x = taylorSeries(Ctor, 2, x, x, true)
  } else {
    k = 1.4 * Math.sqrt(len)
    k = k > 16 ? 16 : k | 0
    x = x.times(1 / tinyPow(5, k))
    x = taylorSeries(Ctor, 2, x, x, true)
    var sinh2_x,
      d5 = new Ctor(5),
      d16 = new Ctor(16),
      d20 = new Ctor(20)
    for (; k--; ) {
      sinh2_x = x.times(x)
      x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))))
    }
  }
  Ctor.precision = pr
  Ctor.rounding = rm
  return finalise(x, pr, rm, true)
}
P.hyperbolicTangent = P.tanh = function () {
  var pr,
    rm,
    x = this,
    Ctor = x.constructor
  if (!x.isFinite()) return new Ctor(x.s)
  if (x.isZero()) return new Ctor(x)
  pr = Ctor.precision
  rm = Ctor.rounding
  Ctor.precision = pr + 7
  Ctor.rounding = 1
  return divide(x.sinh(), x.cosh(), (Ctor.precision = pr), (Ctor.rounding = rm))
}
P.inverseCosine = P.acos = function () {
  var halfPi,
    x = this,
    Ctor = x.constructor,
    k = x.abs().cmp(1),
    pr = Ctor.precision,
    rm = Ctor.rounding
  if (k !== -1) {
    return k === 0 ? (x.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0)) : new Ctor(NaN)
  }
  if (x.isZero()) return getPi(Ctor, pr + 4, rm).times(0.5)
  Ctor.precision = pr + 6
  Ctor.rounding = 1
  x = x.asin()
  halfPi = getPi(Ctor, pr + 4, rm).times(0.5)
  Ctor.precision = pr
  Ctor.rounding = rm
  return halfPi.minus(x)
}
P.inverseHyperbolicCosine = P.acosh = function () {
  var pr,
    rm,
    x = this,
    Ctor = x.constructor
  if (x.lte(1)) return new Ctor(x.eq(1) ? 0 : NaN)
  if (!x.isFinite()) return new Ctor(x)
  pr = Ctor.precision
  rm = Ctor.rounding
  Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4
  Ctor.rounding = 1
  external = false
  x = x.times(x).minus(1).sqrt().plus(x)
  external = true
  Ctor.precision = pr
  Ctor.rounding = rm
  return x.ln()
}
P.inverseHyperbolicSine = P.asinh = function () {
  var pr,
    rm,
    x = this,
    Ctor = x.constructor
  if (!x.isFinite() || x.isZero()) return new Ctor(x)
  pr = Ctor.precision
  rm = Ctor.rounding
  Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6
  Ctor.rounding = 1
  external = false
  x = x.times(x).plus(1).sqrt().plus(x)
  external = true
  Ctor.precision = pr
  Ctor.rounding = rm
  return x.ln()
}
P.inverseHyperbolicTangent = P.atanh = function () {
  var pr,
    rm,
    wpr,
    xsd,
    x = this,
    Ctor = x.constructor
  if (!x.isFinite()) return new Ctor(NaN)
  if (x.e >= 0) return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN)
  pr = Ctor.precision
  rm = Ctor.rounding
  xsd = x.sd()
  if (Math.max(xsd, pr) < 2 * -x.e - 1) return finalise(new Ctor(x), pr, rm, true)
  Ctor.precision = wpr = xsd - x.e
  x = divide(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1)
  Ctor.precision = pr + 4
  Ctor.rounding = 1
  x = x.ln()
  Ctor.precision = pr
  Ctor.rounding = rm
  return x.times(0.5)
}
P.inverseSine = P.asin = function () {
  var halfPi,
    k,
    pr,
    rm,
    x = this,
    Ctor = x.constructor
  if (x.isZero()) return new Ctor(x)
  k = x.abs().cmp(1)
  pr = Ctor.precision
  rm = Ctor.rounding
  if (k !== -1) {
    if (k === 0) {
      halfPi = getPi(Ctor, pr + 4, rm).times(0.5)
      halfPi.s = x.s
      return halfPi
    }
    return new Ctor(NaN)
  }
  Ctor.precision = pr + 6
  Ctor.rounding = 1
  x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan()
  Ctor.precision = pr
  Ctor.rounding = rm
  return x.times(2)
}
P.inverseTangent = P.atan = function () {
  var i,
    j,
    k,
    n2,
    px,
    t2,
    r,
    wpr,
    x2,
    x = this,
    Ctor = x.constructor,
    pr = Ctor.precision,
    rm = Ctor.rounding
  if (!x.isFinite()) {
    if (!x.s) return new Ctor(NaN)
    if (pr + 4 <= PI_PRECISION) {
      r = getPi(Ctor, pr + 4, rm).times(0.5)
      r.s = x.s
      return r
    }
  } else if (x.isZero()) {
    return new Ctor(x)
  } else if (x.abs().eq(1) && pr + 4 <= PI_PRECISION) {
    r = getPi(Ctor, pr + 4, rm).times(0.25)
    r.s = x.s
    return r
  }
  Ctor.precision = wpr = pr + 10
  Ctor.rounding = 1
  k = Math.min(28, (wpr / LOG_BASE + 2) | 0)
  for (i = k; i; --i) x = x.div(x.times(x).plus(1).sqrt().plus(1))
  external = false
  j = Math.ceil(wpr / LOG_BASE)
  n2 = 1
  x2 = x.times(x)
  r = new Ctor(x)
  px = x
  for (; i !== -1; ) {
    px = px.times(x2)
    t2 = r.minus(px.div((n2 += 2)))
    px = px.times(x2)
    r = t2.plus(px.div((n2 += 2)))
    if (r.d[j] !== void 0) for (i = j; r.d[i] === t2.d[i] && i--; );
  }
  if (k) r = r.times(2 << (k - 1))
  external = true
  return finalise(r, (Ctor.precision = pr), (Ctor.rounding = rm), true)
}
P.isFinite = function () {
  return !!this.d
}
P.isInteger = P.isInt = function () {
  return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2
}
P.isNaN = function () {
  return !this.s
}
P.isNegative = P.isNeg = function () {
  return this.s < 0
}
P.isPositive = P.isPos = function () {
  return this.s > 0
}
P.isZero = function () {
  return !!this.d && this.d[0] === 0
}
P.lessThan = P.lt = function (y2) {
  return this.cmp(y2) < 0
}
P.lessThanOrEqualTo = P.lte = function (y2) {
  return this.cmp(y2) < 1
}
P.logarithm = P.log = function (base2) {
  var isBase10,
    d2,
    denominator,
    k,
    inf,
    num,
    sd,
    r,
    arg = this,
    Ctor = arg.constructor,
    pr = Ctor.precision,
    rm = Ctor.rounding,
    guard = 5
  if (base2 == null) {
    base2 = new Ctor(10)
    isBase10 = true
  } else {
    base2 = new Ctor(base2)
    d2 = base2.d
    if (base2.s < 0 || !d2 || !d2[0] || base2.eq(1)) return new Ctor(NaN)
    isBase10 = base2.eq(10)
  }
  d2 = arg.d
  if (arg.s < 0 || !d2 || !d2[0] || arg.eq(1)) {
    return new Ctor(d2 && !d2[0] ? -1 / 0 : arg.s != 1 ? NaN : d2 ? 0 : 1 / 0)
  }
  if (isBase10) {
    if (d2.length > 1) {
      inf = true
    } else {
      for (k = d2[0]; k % 10 === 0; ) k /= 10
      inf = k !== 1
    }
  }
  external = false
  sd = pr + guard
  num = naturalLogarithm(arg, sd)
  denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base2, sd)
  r = divide(num, denominator, sd, 1)
  if (checkRoundingDigits(r.d, (k = pr), rm)) {
    do {
      sd += 10
      num = naturalLogarithm(arg, sd)
      denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base2, sd)
      r = divide(num, denominator, sd, 1)
      if (!inf) {
        if (+digitsToString(r.d).slice(k + 1, k + 15) + 1 == 1e14) {
          r = finalise(r, pr + 1, 0)
        }
        break
      }
    } while (checkRoundingDigits(r.d, (k += 10), rm))
  }
  external = true
  return finalise(r, pr, rm)
}
P.minus = P.sub = function (y2) {
  var d2,
    e,
    i,
    j,
    k,
    len,
    pr,
    rm,
    xd,
    xe,
    xLTy,
    yd,
    x = this,
    Ctor = x.constructor
  y2 = new Ctor(y2)
  if (!x.d || !y2.d) {
    if (!x.s || !y2.s) y2 = new Ctor(NaN)
    else if (x.d) y2.s = -y2.s
    else y2 = new Ctor(y2.d || x.s !== y2.s ? x : NaN)
    return y2
  }
  if (x.s != y2.s) {
    y2.s = -y2.s
    return x.plus(y2)
  }
  xd = x.d
  yd = y2.d
  pr = Ctor.precision
  rm = Ctor.rounding
  if (!xd[0] || !yd[0]) {
    if (yd[0]) y2.s = -y2.s
    else if (xd[0]) y2 = new Ctor(x)
    else return new Ctor(rm === 3 ? -0 : 0)
    return external ? finalise(y2, pr, rm) : y2
  }
  e = mathfloor(y2.e / LOG_BASE)
  xe = mathfloor(x.e / LOG_BASE)
  xd = xd.slice()
  k = xe - e
  if (k) {
    xLTy = k < 0
    if (xLTy) {
      d2 = xd
      k = -k
      len = yd.length
    } else {
      d2 = yd
      e = xe
      len = xd.length
    }
    i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2
    if (k > i) {
      k = i
      d2.length = 1
    }
    d2.reverse()
    for (i = k; i--; ) d2.push(0)
    d2.reverse()
  } else {
    i = xd.length
    len = yd.length
    xLTy = i < len
    if (xLTy) len = i
    for (i = 0; i < len; i++) {
      if (xd[i] != yd[i]) {
        xLTy = xd[i] < yd[i]
        break
      }
    }
    k = 0
  }
  if (xLTy) {
    d2 = xd
    xd = yd
    yd = d2
    y2.s = -y2.s
  }
  len = xd.length
  for (i = yd.length - len; i > 0; --i) xd[len++] = 0
  for (i = yd.length; i > k; ) {
    if (xd[--i] < yd[i]) {
      for (j = i; j && xd[--j] === 0; ) xd[j] = BASE - 1
      --xd[j]
      xd[i] += BASE
    }
    xd[i] -= yd[i]
  }
  for (; xd[--len] === 0; ) xd.pop()
  for (; xd[0] === 0; xd.shift()) --e
  if (!xd[0]) return new Ctor(rm === 3 ? -0 : 0)
  y2.d = xd
  y2.e = getBase10Exponent(xd, e)
  return external ? finalise(y2, pr, rm) : y2
}
P.modulo = P.mod = function (y2) {
  var q,
    x = this,
    Ctor = x.constructor
  y2 = new Ctor(y2)
  if (!x.d || !y2.s || (y2.d && !y2.d[0])) return new Ctor(NaN)
  if (!y2.d || (x.d && !x.d[0])) {
    return finalise(new Ctor(x), Ctor.precision, Ctor.rounding)
  }
  external = false
  if (Ctor.modulo == 9) {
    q = divide(x, y2.abs(), 0, 3, 1)
    q.s *= y2.s
  } else {
    q = divide(x, y2, 0, Ctor.modulo, 1)
  }
  q = q.times(y2)
  external = true
  return x.minus(q)
}
P.naturalExponential = P.exp = function () {
  return naturalExponential(this)
}
P.naturalLogarithm = P.ln = function () {
  return naturalLogarithm(this)
}
P.negated = P.neg = function () {
  var x = new this.constructor(this)
  x.s = -x.s
  return finalise(x)
}
P.plus = P.add = function (y2) {
  var carry,
    d2,
    e,
    i,
    k,
    len,
    pr,
    rm,
    xd,
    yd,
    x = this,
    Ctor = x.constructor
  y2 = new Ctor(y2)
  if (!x.d || !y2.d) {
    if (!x.s || !y2.s) y2 = new Ctor(NaN)
    else if (!x.d) y2 = new Ctor(y2.d || x.s === y2.s ? x : NaN)
    return y2
  }
  if (x.s != y2.s) {
    y2.s = -y2.s
    return x.minus(y2)
  }
  xd = x.d
  yd = y2.d
  pr = Ctor.precision
  rm = Ctor.rounding
  if (!xd[0] || !yd[0]) {
    if (!yd[0]) y2 = new Ctor(x)
    return external ? finalise(y2, pr, rm) : y2
  }
  k = mathfloor(x.e / LOG_BASE)
  e = mathfloor(y2.e / LOG_BASE)
  xd = xd.slice()
  i = k - e
  if (i) {
    if (i < 0) {
      d2 = xd
      i = -i
      len = yd.length
    } else {
      d2 = yd
      e = k
      len = xd.length
    }
    k = Math.ceil(pr / LOG_BASE)
    len = k > len ? k + 1 : len + 1
    if (i > len) {
      i = len
      d2.length = 1
    }
    d2.reverse()
    for (; i--; ) d2.push(0)
    d2.reverse()
  }
  len = xd.length
  i = yd.length
  if (len - i < 0) {
    i = len
    d2 = yd
    yd = xd
    xd = d2
  }
  for (carry = 0; i; ) {
    carry = ((xd[--i] = xd[i] + yd[i] + carry) / BASE) | 0
    xd[i] %= BASE
  }
  if (carry) {
    xd.unshift(carry)
    ++e
  }
  for (len = xd.length; xd[--len] == 0; ) xd.pop()
  y2.d = xd
  y2.e = getBase10Exponent(xd, e)
  return external ? finalise(y2, pr, rm) : y2
}
P.precision = P.sd = function (z) {
  var k,
    x = this
  if (z !== void 0 && z !== !!z && z !== 1 && z !== 0) throw Error(invalidArgument + z)
  if (x.d) {
    k = getPrecision(x.d)
    if (z && x.e + 1 > k) k = x.e + 1
  } else {
    k = NaN
  }
  return k
}
P.round = function () {
  var x = this,
    Ctor = x.constructor
  return finalise(new Ctor(x), x.e + 1, Ctor.rounding)
}
P.sine = P.sin = function () {
  var pr,
    rm,
    x = this,
    Ctor = x.constructor
  if (!x.isFinite()) return new Ctor(NaN)
  if (x.isZero()) return new Ctor(x)
  pr = Ctor.precision
  rm = Ctor.rounding
  Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE
  Ctor.rounding = 1
  x = sine(Ctor, toLessThanHalfPi(Ctor, x))
  Ctor.precision = pr
  Ctor.rounding = rm
  return finalise(quadrant > 2 ? x.neg() : x, pr, rm, true)
}
P.squareRoot = P.sqrt = function () {
  var m2,
    n2,
    sd,
    r,
    rep,
    t2,
    x = this,
    d2 = x.d,
    e = x.e,
    s2 = x.s,
    Ctor = x.constructor
  if (s2 !== 1 || !d2 || !d2[0]) {
    return new Ctor(!s2 || (s2 < 0 && (!d2 || d2[0])) ? NaN : d2 ? x : 1 / 0)
  }
  external = false
  s2 = Math.sqrt(+x)
  if (s2 == 0 || s2 == 1 / 0) {
    n2 = digitsToString(d2)
    if ((n2.length + e) % 2 == 0) n2 += '0'
    s2 = Math.sqrt(n2)
    e = mathfloor((e + 1) / 2) - (e < 0 || e % 2)
    if (s2 == 1 / 0) {
      n2 = '5e' + e
    } else {
      n2 = s2.toExponential()
      n2 = n2.slice(0, n2.indexOf('e') + 1) + e
    }
    r = new Ctor(n2)
  } else {
    r = new Ctor(s2.toString())
  }
  sd = (e = Ctor.precision) + 3
  for (;;) {
    t2 = r
    r = t2.plus(divide(x, t2, sd + 2, 1)).times(0.5)
    if (digitsToString(t2.d).slice(0, sd) === (n2 = digitsToString(r.d)).slice(0, sd)) {
      n2 = n2.slice(sd - 3, sd + 1)
      if (n2 == '9999' || (!rep && n2 == '4999')) {
        if (!rep) {
          finalise(t2, e + 1, 0)
          if (t2.times(t2).eq(x)) {
            r = t2
            break
          }
        }
        sd += 4
        rep = 1
      } else {
        if (!+n2 || (!+n2.slice(1) && n2.charAt(0) == '5')) {
          finalise(r, e + 1, 1)
          m2 = !r.times(r).eq(x)
        }
        break
      }
    }
  }
  external = true
  return finalise(r, e, Ctor.rounding, m2)
}
P.tangent = P.tan = function () {
  var pr,
    rm,
    x = this,
    Ctor = x.constructor
  if (!x.isFinite()) return new Ctor(NaN)
  if (x.isZero()) return new Ctor(x)
  pr = Ctor.precision
  rm = Ctor.rounding
  Ctor.precision = pr + 10
  Ctor.rounding = 1
  x = x.sin()
  x.s = 1
  x = divide(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0)
  Ctor.precision = pr
  Ctor.rounding = rm
  return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true)
}
P.times = P.mul = function (y2) {
  var carry,
    e,
    i,
    k,
    r,
    rL,
    t2,
    xdL,
    ydL,
    x = this,
    Ctor = x.constructor,
    xd = x.d,
    yd = (y2 = new Ctor(y2)).d
  y2.s *= x.s
  if (!xd || !xd[0] || !yd || !yd[0]) {
    return new Ctor(!y2.s || (xd && !xd[0] && !yd) || (yd && !yd[0] && !xd) ? NaN : !xd || !yd ? y2.s / 0 : y2.s * 0)
  }
  e = mathfloor(x.e / LOG_BASE) + mathfloor(y2.e / LOG_BASE)
  xdL = xd.length
  ydL = yd.length
  if (xdL < ydL) {
    r = xd
    xd = yd
    yd = r
    rL = xdL
    xdL = ydL
    ydL = rL
  }
  r = []
  rL = xdL + ydL
  for (i = rL; i--; ) r.push(0)
  for (i = ydL; --i >= 0; ) {
    carry = 0
    for (k = xdL + i; k > i; ) {
      t2 = r[k] + yd[i] * xd[k - i - 1] + carry
      r[k--] = t2 % BASE | 0
      carry = (t2 / BASE) | 0
    }
    r[k] = (r[k] + carry) % BASE | 0
  }
  for (; !r[--rL]; ) r.pop()
  if (carry) ++e
  else r.shift()
  y2.d = r
  y2.e = getBase10Exponent(r, e)
  return external ? finalise(y2, Ctor.precision, Ctor.rounding) : y2
}
P.toBinary = function (sd, rm) {
  return toStringBinary(this, 2, sd, rm)
}
P.toDecimalPlaces = P.toDP = function (dp, rm) {
  var x = this,
    Ctor = x.constructor
  x = new Ctor(x)
  if (dp === void 0) return x
  checkInt32(dp, 0, MAX_DIGITS)
  if (rm === void 0) rm = Ctor.rounding
  else checkInt32(rm, 0, 8)
  return finalise(x, dp + x.e + 1, rm)
}
P.toExponential = function (dp, rm) {
  var str,
    x = this,
    Ctor = x.constructor
  if (dp === void 0) {
    str = finiteToString(x, true)
  } else {
    checkInt32(dp, 0, MAX_DIGITS)
    if (rm === void 0) rm = Ctor.rounding
    else checkInt32(rm, 0, 8)
    x = finalise(new Ctor(x), dp + 1, rm)
    str = finiteToString(x, true, dp + 1)
  }
  return x.isNeg() && !x.isZero() ? '-' + str : str
}
P.toFixed = function (dp, rm) {
  var str,
    y2,
    x = this,
    Ctor = x.constructor
  if (dp === void 0) {
    str = finiteToString(x)
  } else {
    checkInt32(dp, 0, MAX_DIGITS)
    if (rm === void 0) rm = Ctor.rounding
    else checkInt32(rm, 0, 8)
    y2 = finalise(new Ctor(x), dp + x.e + 1, rm)
    str = finiteToString(y2, false, dp + y2.e + 1)
  }
  return x.isNeg() && !x.isZero() ? '-' + str : str
}
P.toFraction = function (maxD) {
  var d2,
    d0,
    d1,
    d22,
    e,
    k,
    n2,
    n0,
    n1,
    pr,
    q,
    r,
    x = this,
    xd = x.d,
    Ctor = x.constructor
  if (!xd) return new Ctor(x)
  n1 = d0 = new Ctor(1)
  d1 = n0 = new Ctor(0)
  d2 = new Ctor(d1)
  e = d2.e = getPrecision(xd) - x.e - 1
  k = e % LOG_BASE
  d2.d[0] = mathpow(10, k < 0 ? LOG_BASE + k : k)
  if (maxD == null) {
    maxD = e > 0 ? d2 : n1
  } else {
    n2 = new Ctor(maxD)
    if (!n2.isInt() || n2.lt(n1)) throw Error(invalidArgument + n2)
    maxD = n2.gt(d2) ? (e > 0 ? d2 : n1) : n2
  }
  external = false
  n2 = new Ctor(digitsToString(xd))
  pr = Ctor.precision
  Ctor.precision = e = xd.length * LOG_BASE * 2
  for (;;) {
    q = divide(n2, d2, 0, 1, 1)
    d22 = d0.plus(q.times(d1))
    if (d22.cmp(maxD) == 1) break
    d0 = d1
    d1 = d22
    d22 = n1
    n1 = n0.plus(q.times(d22))
    n0 = d22
    d22 = d2
    d2 = n2.minus(q.times(d22))
    n2 = d22
  }
  d22 = divide(maxD.minus(d0), d1, 0, 1, 1)
  n0 = n0.plus(d22.times(n1))
  d0 = d0.plus(d22.times(d1))
  n0.s = n1.s = x.s
  r = divide(n1, d1, e, 1).minus(x).abs().cmp(divide(n0, d0, e, 1).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0]
  Ctor.precision = pr
  external = true
  return r
}
P.toHexadecimal = P.toHex = function (sd, rm) {
  return toStringBinary(this, 16, sd, rm)
}
P.toNearest = function (y2, rm) {
  var x = this,
    Ctor = x.constructor
  x = new Ctor(x)
  if (y2 == null) {
    if (!x.d) return x
    y2 = new Ctor(1)
    rm = Ctor.rounding
  } else {
    y2 = new Ctor(y2)
    if (rm === void 0) {
      rm = Ctor.rounding
    } else {
      checkInt32(rm, 0, 8)
    }
    if (!x.d) return y2.s ? x : y2
    if (!y2.d) {
      if (y2.s) y2.s = x.s
      return y2
    }
  }
  if (y2.d[0]) {
    external = false
    x = divide(x, y2, 0, rm, 1).times(y2)
    external = true
    finalise(x)
  } else {
    y2.s = x.s
    x = y2
  }
  return x
}
P.toNumber = function () {
  return +this
}
P.toOctal = function (sd, rm) {
  return toStringBinary(this, 8, sd, rm)
}
P.toPower = P.pow = function (y2) {
  var e,
    k,
    pr,
    r,
    rm,
    s2,
    x = this,
    Ctor = x.constructor,
    yn = +(y2 = new Ctor(y2))
  if (!x.d || !y2.d || !x.d[0] || !y2.d[0]) return new Ctor(mathpow(+x, yn))
  x = new Ctor(x)
  if (x.eq(1)) return x
  pr = Ctor.precision
  rm = Ctor.rounding
  if (y2.eq(1)) return finalise(x, pr, rm)
  e = mathfloor(y2.e / LOG_BASE)
  if (e >= y2.d.length - 1 && (k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {
    r = intPow(Ctor, x, k, pr)
    return y2.s < 0 ? new Ctor(1).div(r) : finalise(r, pr, rm)
  }
  s2 = x.s
  if (s2 < 0) {
    if (e < y2.d.length - 1) return new Ctor(NaN)
    if ((y2.d[e] & 1) == 0) s2 = 1
    if (x.e == 0 && x.d[0] == 1 && x.d.length == 1) {
      x.s = s2
      return x
    }
  }
  k = mathpow(+x, yn)
  e =
    k == 0 || !isFinite(k)
      ? mathfloor(yn * (Math.log('0.' + digitsToString(x.d)) / Math.LN10 + x.e + 1))
      : new Ctor(k + '').e
  if (e > Ctor.maxE + 1 || e < Ctor.minE - 1) return new Ctor(e > 0 ? s2 / 0 : 0)
  external = false
  Ctor.rounding = x.s = 1
  k = Math.min(12, (e + '').length)
  r = naturalExponential(y2.times(naturalLogarithm(x, pr + k)), pr)
  if (r.d) {
    r = finalise(r, pr + 5, 1)
    if (checkRoundingDigits(r.d, pr, rm)) {
      e = pr + 10
      r = finalise(naturalExponential(y2.times(naturalLogarithm(x, e + k)), e), e + 5, 1)
      if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 1e14) {
        r = finalise(r, pr + 1, 0)
      }
    }
  }
  r.s = s2
  external = true
  Ctor.rounding = rm
  return finalise(r, pr, rm)
}
P.toPrecision = function (sd, rm) {
  var str,
    x = this,
    Ctor = x.constructor
  if (sd === void 0) {
    str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos)
  } else {
    checkInt32(sd, 1, MAX_DIGITS)
    if (rm === void 0) rm = Ctor.rounding
    else checkInt32(rm, 0, 8)
    x = finalise(new Ctor(x), sd, rm)
    str = finiteToString(x, sd <= x.e || x.e <= Ctor.toExpNeg, sd)
  }
  return x.isNeg() && !x.isZero() ? '-' + str : str
}
P.toSignificantDigits = P.toSD = function (sd, rm) {
  var x = this,
    Ctor = x.constructor
  if (sd === void 0) {
    sd = Ctor.precision
    rm = Ctor.rounding
  } else {
    checkInt32(sd, 1, MAX_DIGITS)
    if (rm === void 0) rm = Ctor.rounding
    else checkInt32(rm, 0, 8)
  }
  return finalise(new Ctor(x), sd, rm)
}
P.toString = function () {
  var x = this,
    Ctor = x.constructor,
    str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos)
  return x.isNeg() && !x.isZero() ? '-' + str : str
}
P.truncated = P.trunc = function () {
  return finalise(new this.constructor(this), this.e + 1, 1)
}
P.valueOf = P.toJSON = function () {
  var x = this,
    Ctor = x.constructor,
    str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos)
  return x.isNeg() ? '-' + str : str
}
function digitsToString(d2) {
  var i,
    k,
    ws,
    indexOfLastWord = d2.length - 1,
    str = '',
    w2 = d2[0]
  if (indexOfLastWord > 0) {
    str += w2
    for (i = 1; i < indexOfLastWord; i++) {
      ws = d2[i] + ''
      k = LOG_BASE - ws.length
      if (k) str += getZeroString(k)
      str += ws
    }
    w2 = d2[i]
    ws = w2 + ''
    k = LOG_BASE - ws.length
    if (k) str += getZeroString(k)
  } else if (w2 === 0) {
    return '0'
  }
  for (; w2 % 10 === 0; ) w2 /= 10
  return str + w2
}
function checkInt32(i, min2, max2) {
  if (i !== ~~i || i < min2 || i > max2) {
    throw Error(invalidArgument + i)
  }
}
function checkRoundingDigits(d2, i, rm, repeating) {
  var di, k, r, rd
  for (k = d2[0]; k >= 10; k /= 10) --i
  if (--i < 0) {
    i += LOG_BASE
    di = 0
  } else {
    di = Math.ceil((i + 1) / LOG_BASE)
    i %= LOG_BASE
  }
  k = mathpow(10, LOG_BASE - i)
  rd = d2[di] % k | 0
  if (repeating == null) {
    if (i < 3) {
      if (i == 0) rd = (rd / 100) | 0
      else if (i == 1) rd = (rd / 10) | 0
      r = (rm < 4 && rd == 99999) || (rm > 3 && rd == 49999) || rd == 5e4 || rd == 0
    } else {
      r =
        (((rm < 4 && rd + 1 == k) || (rm > 3 && rd + 1 == k / 2)) &&
          ((d2[di + 1] / k / 100) | 0) == mathpow(10, i - 2) - 1) ||
        ((rd == k / 2 || rd == 0) && ((d2[di + 1] / k / 100) | 0) == 0)
    }
  } else {
    if (i < 4) {
      if (i == 0) rd = (rd / 1e3) | 0
      else if (i == 1) rd = (rd / 100) | 0
      else if (i == 2) rd = (rd / 10) | 0
      r = ((repeating || rm < 4) && rd == 9999) || (!repeating && rm > 3 && rd == 4999)
    } else {
      r =
        (((repeating || rm < 4) && rd + 1 == k) || (!repeating && rm > 3 && rd + 1 == k / 2)) &&
        ((d2[di + 1] / k / 1e3) | 0) == mathpow(10, i - 3) - 1
    }
  }
  return r
}
function convertBase(str, baseIn, baseOut) {
  var j,
    arr = [0],
    arrL,
    i = 0,
    strL = str.length
  for (; i < strL; ) {
    for (arrL = arr.length; arrL--; ) arr[arrL] *= baseIn
    arr[0] += NUMERALS.indexOf(str.charAt(i++))
    for (j = 0; j < arr.length; j++) {
      if (arr[j] > baseOut - 1) {
        if (arr[j + 1] === void 0) arr[j + 1] = 0
        arr[j + 1] += (arr[j] / baseOut) | 0
        arr[j] %= baseOut
      }
    }
  }
  return arr.reverse()
}
function cosine(Ctor, x) {
  var k, len, y2
  if (x.isZero()) return x
  len = x.d.length
  if (len < 32) {
    k = Math.ceil(len / 3)
    y2 = (1 / tinyPow(4, k)).toString()
  } else {
    k = 16
    y2 = '2.3283064365386962890625e-10'
  }
  Ctor.precision += k
  x = taylorSeries(Ctor, 1, x.times(y2), new Ctor(1))
  for (var i = k; i--; ) {
    var cos2x = x.times(x)
    x = cos2x.times(cos2x).minus(cos2x).times(8).plus(1)
  }
  Ctor.precision -= k
  return x
}
var divide = (function () {
  function multiplyInteger(x, k, base2) {
    var temp,
      carry = 0,
      i = x.length
    for (x = x.slice(); i--; ) {
      temp = x[i] * k + carry
      x[i] = temp % base2 | 0
      carry = (temp / base2) | 0
    }
    if (carry) x.unshift(carry)
    return x
  }
  function compare(a, b, aL, bL) {
    var i, r
    if (aL != bL) {
      r = aL > bL ? 1 : -1
    } else {
      for (i = r = 0; i < aL; i++) {
        if (a[i] != b[i]) {
          r = a[i] > b[i] ? 1 : -1
          break
        }
      }
    }
    return r
  }
  function subtract(a, b, aL, base2) {
    var i = 0
    for (; aL--; ) {
      a[aL] -= i
      i = a[aL] < b[aL] ? 1 : 0
      a[aL] = i * base2 + a[aL] - b[aL]
    }
    for (; !a[0] && a.length > 1; ) a.shift()
  }
  return function (x, y2, pr, rm, dp, base2) {
    var cmp,
      e,
      i,
      k,
      logBase,
      more,
      prod,
      prodL,
      q,
      qd,
      rem,
      remL,
      rem0,
      sd,
      t2,
      xi,
      xL,
      yd0,
      yL,
      yz,
      Ctor = x.constructor,
      sign2 = x.s == y2.s ? 1 : -1,
      xd = x.d,
      yd = y2.d
    if (!xd || !xd[0] || !yd || !yd[0]) {
      return new Ctor(
        !x.s || !y2.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN : (xd && xd[0] == 0) || !yd ? sign2 * 0 : sign2 / 0
      )
    }
    if (base2) {
      logBase = 1
      e = x.e - y2.e
    } else {
      base2 = BASE
      logBase = LOG_BASE
      e = mathfloor(x.e / logBase) - mathfloor(y2.e / logBase)
    }
    yL = yd.length
    xL = xd.length
    q = new Ctor(sign2)
    qd = q.d = []
    for (i = 0; yd[i] == (xd[i] || 0); i++);
    if (yd[i] > (xd[i] || 0)) e--
    if (pr == null) {
      sd = pr = Ctor.precision
      rm = Ctor.rounding
    } else if (dp) {
      sd = pr + (x.e - y2.e) + 1
    } else {
      sd = pr
    }
    if (sd < 0) {
      qd.push(1)
      more = true
    } else {
      sd = (sd / logBase + 2) | 0
      i = 0
      if (yL == 1) {
        k = 0
        yd = yd[0]
        sd++
        for (; (i < xL || k) && sd--; i++) {
          t2 = k * base2 + (xd[i] || 0)
          qd[i] = (t2 / yd) | 0
          k = t2 % yd | 0
        }
        more = k || i < xL
      } else {
        k = (base2 / (yd[0] + 1)) | 0
        if (k > 1) {
          yd = multiplyInteger(yd, k, base2)
          xd = multiplyInteger(xd, k, base2)
          yL = yd.length
          xL = xd.length
        }
        xi = yL
        rem = xd.slice(0, yL)
        remL = rem.length
        for (; remL < yL; ) rem[remL++] = 0
        yz = yd.slice()
        yz.unshift(0)
        yd0 = yd[0]
        if (yd[1] >= base2 / 2) ++yd0
        do {
          k = 0
          cmp = compare(yd, rem, yL, remL)
          if (cmp < 0) {
            rem0 = rem[0]
            if (yL != remL) rem0 = rem0 * base2 + (rem[1] || 0)
            k = (rem0 / yd0) | 0
            if (k > 1) {
              if (k >= base2) k = base2 - 1
              prod = multiplyInteger(yd, k, base2)
              prodL = prod.length
              remL = rem.length
              cmp = compare(prod, rem, prodL, remL)
              if (cmp == 1) {
                k--
                subtract(prod, yL < prodL ? yz : yd, prodL, base2)
              }
            } else {
              if (k == 0) cmp = k = 1
              prod = yd.slice()
            }
            prodL = prod.length
            if (prodL < remL) prod.unshift(0)
            subtract(rem, prod, remL, base2)
            if (cmp == -1) {
              remL = rem.length
              cmp = compare(yd, rem, yL, remL)
              if (cmp < 1) {
                k++
                subtract(rem, yL < remL ? yz : yd, remL, base2)
              }
            }
            remL = rem.length
          } else if (cmp === 0) {
            k++
            rem = [0]
          }
          qd[i++] = k
          if (cmp && rem[0]) {
            rem[remL++] = xd[xi] || 0
          } else {
            rem = [xd[xi]]
            remL = 1
          }
        } while ((xi++ < xL || rem[0] !== void 0) && sd--)
        more = rem[0] !== void 0
      }
      if (!qd[0]) qd.shift()
    }
    if (logBase == 1) {
      q.e = e
      inexact = more
    } else {
      for (i = 1, k = qd[0]; k >= 10; k /= 10) i++
      q.e = i + e * logBase - 1
      finalise(q, dp ? pr + q.e + 1 : pr, rm, more)
    }
    return q
  }
})()
function finalise(x, sd, rm, isTruncated) {
  var digits,
    i,
    j,
    k,
    rd,
    roundUp,
    w2,
    xd,
    xdi,
    Ctor = x.constructor
  out: if (sd != null) {
    xd = x.d
    if (!xd) return x
    for (digits = 1, k = xd[0]; k >= 10; k /= 10) digits++
    i = sd - digits
    if (i < 0) {
      i += LOG_BASE
      j = sd
      w2 = xd[(xdi = 0)]
      rd = (w2 / mathpow(10, digits - j - 1)) % 10 | 0
    } else {
      xdi = Math.ceil((i + 1) / LOG_BASE)
      k = xd.length
      if (xdi >= k) {
        if (isTruncated) {
          for (; k++ <= xdi; ) xd.push(0)
          w2 = rd = 0
          digits = 1
          i %= LOG_BASE
          j = i - LOG_BASE + 1
        } else {
          break out
        }
      } else {
        w2 = k = xd[xdi]
        for (digits = 1; k >= 10; k /= 10) digits++
        i %= LOG_BASE
        j = i - LOG_BASE + digits
        rd = j < 0 ? 0 : (w2 / mathpow(10, digits - j - 1)) % 10 | 0
      }
    }
    isTruncated = isTruncated || sd < 0 || xd[xdi + 1] !== void 0 || (j < 0 ? w2 : w2 % mathpow(10, digits - j - 1))
    roundUp =
      rm < 4
        ? (rd || isTruncated) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
        : rd > 5 ||
          (rd == 5 &&
            (rm == 4 ||
              isTruncated ||
              (rm == 6 && (i > 0 ? (j > 0 ? w2 / mathpow(10, digits - j) : 0) : xd[xdi - 1]) % 10 & 1) ||
              rm == (x.s < 0 ? 8 : 7)))
    if (sd < 1 || !xd[0]) {
      xd.length = 0
      if (roundUp) {
        sd -= x.e + 1
        xd[0] = mathpow(10, (LOG_BASE - (sd % LOG_BASE)) % LOG_BASE)
        x.e = -sd || 0
      } else {
        xd[0] = x.e = 0
      }
      return x
    }
    if (i == 0) {
      xd.length = xdi
      k = 1
      xdi--
    } else {
      xd.length = xdi + 1
      k = mathpow(10, LOG_BASE - i)
      xd[xdi] = j > 0 ? ((w2 / mathpow(10, digits - j)) % mathpow(10, j) | 0) * k : 0
    }
    if (roundUp) {
      for (;;) {
        if (xdi == 0) {
          for (i = 1, j = xd[0]; j >= 10; j /= 10) i++
          j = xd[0] += k
          for (k = 1; j >= 10; j /= 10) k++
          if (i != k) {
            x.e++
            if (xd[0] == BASE) xd[0] = 1
          }
          break
        } else {
          xd[xdi] += k
          if (xd[xdi] != BASE) break
          xd[xdi--] = 0
          k = 1
        }
      }
    }
    for (i = xd.length; xd[--i] === 0; ) xd.pop()
  }
  if (external) {
    if (x.e > Ctor.maxE) {
      x.d = null
      x.e = NaN
    } else if (x.e < Ctor.minE) {
      x.e = 0
      x.d = [0]
    }
  }
  return x
}
function finiteToString(x, isExp, sd) {
  if (!x.isFinite()) return nonFiniteToString(x)
  var k,
    e = x.e,
    str = digitsToString(x.d),
    len = str.length
  if (isExp) {
    if (sd && (k = sd - len) > 0) {
      str = str.charAt(0) + '.' + str.slice(1) + getZeroString(k)
    } else if (len > 1) {
      str = str.charAt(0) + '.' + str.slice(1)
    }
    str = str + (x.e < 0 ? 'e' : 'e+') + x.e
  } else if (e < 0) {
    str = '0.' + getZeroString(-e - 1) + str
    if (sd && (k = sd - len) > 0) str += getZeroString(k)
  } else if (e >= len) {
    str += getZeroString(e + 1 - len)
    if (sd && (k = sd - e - 1) > 0) str = str + '.' + getZeroString(k)
  } else {
    if ((k = e + 1) < len) str = str.slice(0, k) + '.' + str.slice(k)
    if (sd && (k = sd - len) > 0) {
      if (e + 1 === len) str += '.'
      str += getZeroString(k)
    }
  }
  return str
}
function getBase10Exponent(digits, e) {
  var w2 = digits[0]
  for (e *= LOG_BASE; w2 >= 10; w2 /= 10) e++
  return e
}
function getLn10(Ctor, sd, pr) {
  if (sd > LN10_PRECISION) {
    external = true
    if (pr) Ctor.precision = pr
    throw Error(precisionLimitExceeded)
  }
  return finalise(new Ctor(LN10), sd, 1, true)
}
function getPi(Ctor, sd, rm) {
  if (sd > PI_PRECISION) throw Error(precisionLimitExceeded)
  return finalise(new Ctor(PI), sd, rm, true)
}
function getPrecision(digits) {
  var w2 = digits.length - 1,
    len = w2 * LOG_BASE + 1
  w2 = digits[w2]
  if (w2) {
    for (; w2 % 10 == 0; w2 /= 10) len--
    for (w2 = digits[0]; w2 >= 10; w2 /= 10) len++
  }
  return len
}
function getZeroString(k) {
  var zs = ''
  for (; k--; ) zs += '0'
  return zs
}
function intPow(Ctor, x, n2, pr) {
  var isTruncated,
    r = new Ctor(1),
    k = Math.ceil(pr / LOG_BASE + 4)
  external = false
  for (;;) {
    if (n2 % 2) {
      r = r.times(x)
      if (truncate(r.d, k)) isTruncated = true
    }
    n2 = mathfloor(n2 / 2)
    if (n2 === 0) {
      n2 = r.d.length - 1
      if (isTruncated && r.d[n2] === 0) ++r.d[n2]
      break
    }
    x = x.times(x)
    truncate(x.d, k)
  }
  external = true
  return r
}
function isOdd(n2) {
  return n2.d[n2.d.length - 1] & 1
}
function maxOrMin(Ctor, args, ltgt) {
  var y2,
    x = new Ctor(args[0]),
    i = 0
  for (; ++i < args.length; ) {
    y2 = new Ctor(args[i])
    if (!y2.s) {
      x = y2
      break
    } else if (x[ltgt](y2)) {
      x = y2
    }
  }
  return x
}
function naturalExponential(x, sd) {
  var denominator,
    guard,
    j,
    pow2,
    sum2,
    t2,
    wpr,
    rep = 0,
    i = 0,
    k = 0,
    Ctor = x.constructor,
    rm = Ctor.rounding,
    pr = Ctor.precision
  if (!x.d || !x.d[0] || x.e > 17) {
    return new Ctor(x.d ? (!x.d[0] ? 1 : x.s < 0 ? 0 : 1 / 0) : x.s ? (x.s < 0 ? 0 : x) : 0 / 0)
  }
  if (sd == null) {
    external = false
    wpr = pr
  } else {
    wpr = sd
  }
  t2 = new Ctor(0.03125)
  while (x.e > -2) {
    x = x.times(t2)
    k += 5
  }
  guard = ((Math.log(mathpow(2, k)) / Math.LN10) * 2 + 5) | 0
  wpr += guard
  denominator = pow2 = sum2 = new Ctor(1)
  Ctor.precision = wpr
  for (;;) {
    pow2 = finalise(pow2.times(x), wpr, 1)
    denominator = denominator.times(++i)
    t2 = sum2.plus(divide(pow2, denominator, wpr, 1))
    if (digitsToString(t2.d).slice(0, wpr) === digitsToString(sum2.d).slice(0, wpr)) {
      j = k
      while (j--) sum2 = finalise(sum2.times(sum2), wpr, 1)
      if (sd == null) {
        if (rep < 3 && checkRoundingDigits(sum2.d, wpr - guard, rm, rep)) {
          Ctor.precision = wpr += 10
          denominator = pow2 = t2 = new Ctor(1)
          i = 0
          rep++
        } else {
          return finalise(sum2, (Ctor.precision = pr), rm, (external = true))
        }
      } else {
        Ctor.precision = pr
        return sum2
      }
    }
    sum2 = t2
  }
}
function naturalLogarithm(y2, sd) {
  var c,
    c0,
    denominator,
    e,
    numerator,
    rep,
    sum2,
    t2,
    wpr,
    x1,
    x2,
    n2 = 1,
    guard = 10,
    x = y2,
    xd = x.d,
    Ctor = x.constructor,
    rm = Ctor.rounding,
    pr = Ctor.precision
  if (x.s < 0 || !xd || !xd[0] || (!x.e && xd[0] == 1 && xd.length == 1)) {
    return new Ctor(xd && !xd[0] ? -1 / 0 : x.s != 1 ? NaN : xd ? 0 : x)
  }
  if (sd == null) {
    external = false
    wpr = pr
  } else {
    wpr = sd
  }
  Ctor.precision = wpr += guard
  c = digitsToString(xd)
  c0 = c.charAt(0)
  if (Math.abs((e = x.e)) < 15e14) {
    while ((c0 < 7 && c0 != 1) || (c0 == 1 && c.charAt(1) > 3)) {
      x = x.times(y2)
      c = digitsToString(x.d)
      c0 = c.charAt(0)
      n2++
    }
    e = x.e
    if (c0 > 1) {
      x = new Ctor('0.' + c)
      e++
    } else {
      x = new Ctor(c0 + '.' + c.slice(1))
    }
  } else {
    t2 = getLn10(Ctor, wpr + 2, pr).times(e + '')
    x = naturalLogarithm(new Ctor(c0 + '.' + c.slice(1)), wpr - guard).plus(t2)
    Ctor.precision = pr
    return sd == null ? finalise(x, pr, rm, (external = true)) : x
  }
  x1 = x
  sum2 = numerator = x = divide(x.minus(1), x.plus(1), wpr, 1)
  x2 = finalise(x.times(x), wpr, 1)
  denominator = 3
  for (;;) {
    numerator = finalise(numerator.times(x2), wpr, 1)
    t2 = sum2.plus(divide(numerator, new Ctor(denominator), wpr, 1))
    if (digitsToString(t2.d).slice(0, wpr) === digitsToString(sum2.d).slice(0, wpr)) {
      sum2 = sum2.times(2)
      if (e !== 0) sum2 = sum2.plus(getLn10(Ctor, wpr + 2, pr).times(e + ''))
      sum2 = divide(sum2, new Ctor(n2), wpr, 1)
      if (sd == null) {
        if (checkRoundingDigits(sum2.d, wpr - guard, rm, rep)) {
          Ctor.precision = wpr += guard
          t2 = numerator = x = divide(x1.minus(1), x1.plus(1), wpr, 1)
          x2 = finalise(x.times(x), wpr, 1)
          denominator = rep = 1
        } else {
          return finalise(sum2, (Ctor.precision = pr), rm, (external = true))
        }
      } else {
        Ctor.precision = pr
        return sum2
      }
    }
    sum2 = t2
    denominator += 2
  }
}
function nonFiniteToString(x) {
  return String((x.s * x.s) / 0)
}
function parseDecimal(x, str) {
  var e, i, len
  if ((e = str.indexOf('.')) > -1) str = str.replace('.', '')
  if ((i = str.search(/e/i)) > 0) {
    if (e < 0) e = i
    e += +str.slice(i + 1)
    str = str.substring(0, i)
  } else if (e < 0) {
    e = str.length
  }
  for (i = 0; str.charCodeAt(i) === 48; i++);
  for (len = str.length; str.charCodeAt(len - 1) === 48; --len);
  str = str.slice(i, len)
  if (str) {
    len -= i
    x.e = e = e - i - 1
    x.d = []
    i = (e + 1) % LOG_BASE
    if (e < 0) i += LOG_BASE
    if (i < len) {
      if (i) x.d.push(+str.slice(0, i))
      for (len -= LOG_BASE; i < len; ) x.d.push(+str.slice(i, (i += LOG_BASE)))
      str = str.slice(i)
      i = LOG_BASE - str.length
    } else {
      i -= len
    }
    for (; i--; ) str += '0'
    x.d.push(+str)
    if (external) {
      if (x.e > x.constructor.maxE) {
        x.d = null
        x.e = NaN
      } else if (x.e < x.constructor.minE) {
        x.e = 0
        x.d = [0]
      }
    }
  } else {
    x.e = 0
    x.d = [0]
  }
  return x
}
function parseOther(x, str) {
  var base2, Ctor, divisor, i, isFloat, len, p, xd, xe
  if (str.indexOf('_') > -1) {
    str = str.replace(/(\d)_(?=\d)/g, '$1')
    if (isDecimal.test(str)) return parseDecimal(x, str)
  } else if (str === 'Infinity' || str === 'NaN') {
    if (!+str) x.s = NaN
    x.e = NaN
    x.d = null
    return x
  }
  if (isHex.test(str)) {
    base2 = 16
    str = str.toLowerCase()
  } else if (isBinary.test(str)) {
    base2 = 2
  } else if (isOctal.test(str)) {
    base2 = 8
  } else {
    throw Error(invalidArgument + str)
  }
  i = str.search(/p/i)
  if (i > 0) {
    p = +str.slice(i + 1)
    str = str.substring(2, i)
  } else {
    str = str.slice(2)
  }
  i = str.indexOf('.')
  isFloat = i >= 0
  Ctor = x.constructor
  if (isFloat) {
    str = str.replace('.', '')
    len = str.length
    i = len - i
    divisor = intPow(Ctor, new Ctor(base2), i, i * 2)
  }
  xd = convertBase(str, base2, BASE)
  xe = xd.length - 1
  for (i = xe; xd[i] === 0; --i) xd.pop()
  if (i < 0) return new Ctor(x.s * 0)
  x.e = getBase10Exponent(xd, xe)
  x.d = xd
  external = false
  if (isFloat) x = divide(x, divisor, len * 4)
  if (p) x = x.times(Math.abs(p) < 54 ? mathpow(2, p) : Decimal.pow(2, p))
  external = true
  return x
}
function sine(Ctor, x) {
  var k,
    len = x.d.length
  if (len < 3) {
    return x.isZero() ? x : taylorSeries(Ctor, 2, x, x)
  }
  k = 1.4 * Math.sqrt(len)
  k = k > 16 ? 16 : k | 0
  x = x.times(1 / tinyPow(5, k))
  x = taylorSeries(Ctor, 2, x, x)
  var sin2_x,
    d5 = new Ctor(5),
    d16 = new Ctor(16),
    d20 = new Ctor(20)
  for (; k--; ) {
    sin2_x = x.times(x)
    x = x.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))))
  }
  return x
}
function taylorSeries(Ctor, n2, x, y2, isHyperbolic) {
  var j,
    t2,
    u,
    x2,
    pr = Ctor.precision,
    k = Math.ceil(pr / LOG_BASE)
  external = false
  x2 = x.times(x)
  u = new Ctor(y2)
  for (;;) {
    t2 = divide(u.times(x2), new Ctor(n2++ * n2++), pr, 1)
    u = isHyperbolic ? y2.plus(t2) : y2.minus(t2)
    y2 = divide(t2.times(x2), new Ctor(n2++ * n2++), pr, 1)
    t2 = u.plus(y2)
    if (t2.d[k] !== void 0) {
      for (j = k; t2.d[j] === u.d[j] && j--; );
      if (j == -1) break
    }
    j = u
    u = y2
    y2 = t2
    t2 = j
  }
  external = true
  t2.d.length = k + 1
  return t2
}
function tinyPow(b, e) {
  var n2 = b
  while (--e) n2 *= b
  return n2
}
function toLessThanHalfPi(Ctor, x) {
  var t2,
    isNeg = x.s < 0,
    pi = getPi(Ctor, Ctor.precision, 1),
    halfPi = pi.times(0.5)
  x = x.abs()
  if (x.lte(halfPi)) {
    quadrant = isNeg ? 4 : 1
    return x
  }
  t2 = x.divToInt(pi)
  if (t2.isZero()) {
    quadrant = isNeg ? 3 : 2
  } else {
    x = x.minus(t2.times(pi))
    if (x.lte(halfPi)) {
      quadrant = isOdd(t2) ? (isNeg ? 2 : 3) : isNeg ? 4 : 1
      return x
    }
    quadrant = isOdd(t2) ? (isNeg ? 1 : 4) : isNeg ? 3 : 2
  }
  return x.minus(pi).abs()
}
function toStringBinary(x, baseOut, sd, rm) {
  var base2,
    e,
    i,
    k,
    len,
    roundUp,
    str,
    xd,
    y2,
    Ctor = x.constructor,
    isExp = sd !== void 0
  if (isExp) {
    checkInt32(sd, 1, MAX_DIGITS)
    if (rm === void 0) rm = Ctor.rounding
    else checkInt32(rm, 0, 8)
  } else {
    sd = Ctor.precision
    rm = Ctor.rounding
  }
  if (!x.isFinite()) {
    str = nonFiniteToString(x)
  } else {
    str = finiteToString(x)
    i = str.indexOf('.')
    if (isExp) {
      base2 = 2
      if (baseOut == 16) {
        sd = sd * 4 - 3
      } else if (baseOut == 8) {
        sd = sd * 3 - 2
      }
    } else {
      base2 = baseOut
    }
    if (i >= 0) {
      str = str.replace('.', '')
      y2 = new Ctor(1)
      y2.e = str.length - i
      y2.d = convertBase(finiteToString(y2), 10, base2)
      y2.e = y2.d.length
    }
    xd = convertBase(str, 10, base2)
    e = len = xd.length
    for (; xd[--len] == 0; ) xd.pop()
    if (!xd[0]) {
      str = isExp ? '0p+0' : '0'
    } else {
      if (i < 0) {
        e--
      } else {
        x = new Ctor(x)
        x.d = xd
        x.e = e
        x = divide(x, y2, sd, rm, 0, base2)
        xd = x.d
        e = x.e
        roundUp = inexact
      }
      i = xd[sd]
      k = base2 / 2
      roundUp = roundUp || xd[sd + 1] !== void 0
      roundUp =
        rm < 4
          ? (i !== void 0 || roundUp) && (rm === 0 || rm === (x.s < 0 ? 3 : 2))
          : i > k || (i === k && (rm === 4 || roundUp || (rm === 6 && xd[sd - 1] & 1) || rm === (x.s < 0 ? 8 : 7)))
      xd.length = sd
      if (roundUp) {
        for (; ++xd[--sd] > base2 - 1; ) {
          xd[sd] = 0
          if (!sd) {
            ++e
            xd.unshift(1)
          }
        }
      }
      for (len = xd.length; !xd[len - 1]; --len);
      for (i = 0, str = ''; i < len; i++) str += NUMERALS.charAt(xd[i])
      if (isExp) {
        if (len > 1) {
          if (baseOut == 16 || baseOut == 8) {
            i = baseOut == 16 ? 4 : 3
            for (--len; len % i; len++) str += '0'
            xd = convertBase(str, base2, baseOut)
            for (len = xd.length; !xd[len - 1]; --len);
            for (i = 1, str = '1.'; i < len; i++) str += NUMERALS.charAt(xd[i])
          } else {
            str = str.charAt(0) + '.' + str.slice(1)
          }
        }
        str = str + (e < 0 ? 'p' : 'p+') + e
      } else if (e < 0) {
        for (; ++e; ) str = '0' + str
        str = '0.' + str
      } else {
        if (++e > len) for (e -= len; e--; ) str += '0'
        else if (e < len) str = str.slice(0, e) + '.' + str.slice(e)
      }
    }
    str = (baseOut == 16 ? '0x' : baseOut == 2 ? '0b' : baseOut == 8 ? '0o' : '') + str
  }
  return x.s < 0 ? '-' + str : str
}
function truncate(arr, len) {
  if (arr.length > len) {
    arr.length = len
    return true
  }
}
function abs(x) {
  return new this(x).abs()
}
function acos(x) {
  return new this(x).acos()
}
function acosh(x) {
  return new this(x).acosh()
}
function add$1(x, y2) {
  return new this(x).plus(y2)
}
function asin(x) {
  return new this(x).asin()
}
function asinh(x) {
  return new this(x).asinh()
}
function atan(x) {
  return new this(x).atan()
}
function atanh(x) {
  return new this(x).atanh()
}
function atan2(y2, x) {
  y2 = new this(y2)
  x = new this(x)
  var r,
    pr = this.precision,
    rm = this.rounding,
    wpr = pr + 4
  if (!y2.s || !x.s) {
    r = new this(NaN)
  } else if (!y2.d && !x.d) {
    r = getPi(this, wpr, 1).times(x.s > 0 ? 0.25 : 0.75)
    r.s = y2.s
  } else if (!x.d || y2.isZero()) {
    r = x.s < 0 ? getPi(this, pr, rm) : new this(0)
    r.s = y2.s
  } else if (!y2.d || x.isZero()) {
    r = getPi(this, wpr, 1).times(0.5)
    r.s = y2.s
  } else if (x.s < 0) {
    this.precision = wpr
    this.rounding = 1
    r = this.atan(divide(y2, x, wpr, 1))
    x = getPi(this, wpr, 1)
    this.precision = pr
    this.rounding = rm
    r = y2.s < 0 ? r.minus(x) : r.plus(x)
  } else {
    r = this.atan(divide(y2, x, wpr, 1))
  }
  return r
}
function cbrt(x) {
  return new this(x).cbrt()
}
function ceil(x) {
  return finalise((x = new this(x)), x.e + 1, 2)
}
function clamp(x, min2, max2) {
  return new this(x).clamp(min2, max2)
}
function config(obj) {
  if (!obj || typeof obj !== 'object') throw Error(decimalError + 'Object expected')
  var i,
    p,
    v,
    useDefaults = obj.defaults === true,
    ps = [
      'precision',
      1,
      MAX_DIGITS,
      'rounding',
      0,
      8,
      'toExpNeg',
      -EXP_LIMIT,
      0,
      'toExpPos',
      0,
      EXP_LIMIT,
      'maxE',
      0,
      EXP_LIMIT,
      'minE',
      -EXP_LIMIT,
      0,
      'modulo',
      0,
      9,
    ]
  for (i = 0; i < ps.length; i += 3) {
    if (((p = ps[i]), useDefaults)) this[p] = DEFAULTS[p]
    if ((v = obj[p]) !== void 0) {
      if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2]) this[p] = v
      else throw Error(invalidArgument + p + ': ' + v)
    }
  }
  if (((p = 'crypto'), useDefaults)) this[p] = DEFAULTS[p]
  if ((v = obj[p]) !== void 0) {
    if (v === true || v === false || v === 0 || v === 1) {
      if (v) {
        if (typeof crypto != 'undefined' && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
          this[p] = true
        } else {
          throw Error(cryptoUnavailable)
        }
      } else {
        this[p] = false
      }
    } else {
      throw Error(invalidArgument + p + ': ' + v)
    }
  }
  return this
}
function cos(x) {
  return new this(x).cos()
}
function cosh(x) {
  return new this(x).cosh()
}
function clone(obj) {
  var i, p, ps
  function Decimal2(v) {
    var e,
      i2,
      t2,
      x = this
    if (!(x instanceof Decimal2)) return new Decimal2(v)
    x.constructor = Decimal2
    if (isDecimalInstance(v)) {
      x.s = v.s
      if (external) {
        if (!v.d || v.e > Decimal2.maxE) {
          x.e = NaN
          x.d = null
        } else if (v.e < Decimal2.minE) {
          x.e = 0
          x.d = [0]
        } else {
          x.e = v.e
          x.d = v.d.slice()
        }
      } else {
        x.e = v.e
        x.d = v.d ? v.d.slice() : v.d
      }
      return
    }
    t2 = typeof v
    if (t2 === 'number') {
      if (v === 0) {
        x.s = 1 / v < 0 ? -1 : 1
        x.e = 0
        x.d = [0]
        return
      }
      if (v < 0) {
        v = -v
        x.s = -1
      } else {
        x.s = 1
      }
      if (v === ~~v && v < 1e7) {
        for (e = 0, i2 = v; i2 >= 10; i2 /= 10) e++
        if (external) {
          if (e > Decimal2.maxE) {
            x.e = NaN
            x.d = null
          } else if (e < Decimal2.minE) {
            x.e = 0
            x.d = [0]
          } else {
            x.e = e
            x.d = [v]
          }
        } else {
          x.e = e
          x.d = [v]
        }
        return
      } else if (v * 0 !== 0) {
        if (!v) x.s = NaN
        x.e = NaN
        x.d = null
        return
      }
      return parseDecimal(x, v.toString())
    } else if (t2 !== 'string') {
      throw Error(invalidArgument + v)
    }
    if ((i2 = v.charCodeAt(0)) === 45) {
      v = v.slice(1)
      x.s = -1
    } else {
      if (i2 === 43) v = v.slice(1)
      x.s = 1
    }
    return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v)
  }
  Decimal2.prototype = P
  Decimal2.ROUND_UP = 0
  Decimal2.ROUND_DOWN = 1
  Decimal2.ROUND_CEIL = 2
  Decimal2.ROUND_FLOOR = 3
  Decimal2.ROUND_HALF_UP = 4
  Decimal2.ROUND_HALF_DOWN = 5
  Decimal2.ROUND_HALF_EVEN = 6
  Decimal2.ROUND_HALF_CEIL = 7
  Decimal2.ROUND_HALF_FLOOR = 8
  Decimal2.EUCLID = 9
  Decimal2.config = Decimal2.set = config
  Decimal2.clone = clone
  Decimal2.isDecimal = isDecimalInstance
  Decimal2.abs = abs
  Decimal2.acos = acos
  Decimal2.acosh = acosh
  Decimal2.add = add$1
  Decimal2.asin = asin
  Decimal2.asinh = asinh
  Decimal2.atan = atan
  Decimal2.atanh = atanh
  Decimal2.atan2 = atan2
  Decimal2.cbrt = cbrt
  Decimal2.ceil = ceil
  Decimal2.clamp = clamp
  Decimal2.cos = cos
  Decimal2.cosh = cosh
  Decimal2.div = div
  Decimal2.exp = exp
  Decimal2.floor = floor
  Decimal2.hypot = hypot
  Decimal2.ln = ln
  Decimal2.log = log
  Decimal2.log10 = log10
  Decimal2.log2 = log2
  Decimal2.max = max
  Decimal2.min = min
  Decimal2.mod = mod
  Decimal2.mul = mul
  Decimal2.pow = pow
  Decimal2.random = random
  Decimal2.round = round
  Decimal2.sign = sign
  Decimal2.sin = sin
  Decimal2.sinh = sinh
  Decimal2.sqrt = sqrt
  Decimal2.sub = sub
  Decimal2.sum = sum
  Decimal2.tan = tan
  Decimal2.tanh = tanh
  Decimal2.trunc = trunc
  if (obj === void 0) obj = {}
  if (obj) {
    if (obj.defaults !== true) {
      ps = ['precision', 'rounding', 'toExpNeg', 'toExpPos', 'maxE', 'minE', 'modulo', 'crypto']
      for (i = 0; i < ps.length; ) if (!obj.hasOwnProperty((p = ps[i++]))) obj[p] = this[p]
    }
  }
  Decimal2.config(obj)
  return Decimal2
}
function div(x, y2) {
  return new this(x).div(y2)
}
function exp(x) {
  return new this(x).exp()
}
function floor(x) {
  return finalise((x = new this(x)), x.e + 1, 3)
}
function hypot() {
  var i,
    n2,
    t2 = new this(0)
  external = false
  for (i = 0; i < arguments.length; ) {
    n2 = new this(arguments[i++])
    if (!n2.d) {
      if (n2.s) {
        external = true
        return new this(1 / 0)
      }
      t2 = n2
    } else if (t2.d) {
      t2 = t2.plus(n2.times(n2))
    }
  }
  external = true
  return t2.sqrt()
}
function isDecimalInstance(obj) {
  return obj instanceof Decimal || (obj && obj.toStringTag === tag) || false
}
function ln(x) {
  return new this(x).ln()
}
function log(x, y2) {
  return new this(x).log(y2)
}
function log2(x) {
  return new this(x).log(2)
}
function log10(x) {
  return new this(x).log(10)
}
function max() {
  return maxOrMin(this, arguments, 'lt')
}
function min() {
  return maxOrMin(this, arguments, 'gt')
}
function mod(x, y2) {
  return new this(x).mod(y2)
}
function mul(x, y2) {
  return new this(x).mul(y2)
}
function pow(x, y2) {
  return new this(x).pow(y2)
}
function random(sd) {
  var d2,
    e,
    k,
    n2,
    i = 0,
    r = new this(1),
    rd = []
  if (sd === void 0) sd = this.precision
  else checkInt32(sd, 1, MAX_DIGITS)
  k = Math.ceil(sd / LOG_BASE)
  if (!this.crypto) {
    for (; i < k; ) rd[i++] = (Math.random() * 1e7) | 0
  } else if (crypto.getRandomValues) {
    d2 = crypto.getRandomValues(new Uint32Array(k))
    for (; i < k; ) {
      n2 = d2[i]
      if (n2 >= 429e7) {
        d2[i] = crypto.getRandomValues(new Uint32Array(1))[0]
      } else {
        rd[i++] = n2 % 1e7
      }
    }
  } else if (crypto.randomBytes) {
    d2 = crypto.randomBytes((k *= 4))
    for (; i < k; ) {
      n2 = d2[i] + (d2[i + 1] << 8) + (d2[i + 2] << 16) + ((d2[i + 3] & 127) << 24)
      if (n2 >= 214e7) {
        crypto.randomBytes(4).copy(d2, i)
      } else {
        rd.push(n2 % 1e7)
        i += 4
      }
    }
    i = k / 4
  } else {
    throw Error(cryptoUnavailable)
  }
  k = rd[--i]
  sd %= LOG_BASE
  if (k && sd) {
    n2 = mathpow(10, LOG_BASE - sd)
    rd[i] = ((k / n2) | 0) * n2
  }
  for (; rd[i] === 0; i--) rd.pop()
  if (i < 0) {
    e = 0
    rd = [0]
  } else {
    e = -1
    for (; rd[0] === 0; e -= LOG_BASE) rd.shift()
    for (k = 1, n2 = rd[0]; n2 >= 10; n2 /= 10) k++
    if (k < LOG_BASE) e -= LOG_BASE - k
  }
  r.e = e
  r.d = rd
  return r
}
function round(x) {
  return finalise((x = new this(x)), x.e + 1, this.rounding)
}
function sign(x) {
  x = new this(x)
  return x.d ? (x.d[0] ? x.s : 0 * x.s) : x.s || NaN
}
function sin(x) {
  return new this(x).sin()
}
function sinh(x) {
  return new this(x).sinh()
}
function sqrt(x) {
  return new this(x).sqrt()
}
function sub(x, y2) {
  return new this(x).sub(y2)
}
function sum() {
  var i = 0,
    args = arguments,
    x = new this(args[i])
  external = false
  for (; x.s && ++i < args.length; ) x = x.plus(args[i])
  external = true
  return finalise(x, this.precision, this.rounding)
}
function tan(x) {
  return new this(x).tan()
}
function tanh(x) {
  return new this(x).tanh()
}
function trunc(x) {
  return finalise((x = new this(x)), x.e + 1, 1)
}
P[Symbol.for('nodejs.util.inspect.custom')] = P.toString
P[Symbol.toStringTag] = 'Decimal'
var Decimal = (P.constructor = clone(DEFAULTS))
LN10 = new Decimal(LN10)
PI = new Decimal(PI)
var props$A = {
  modelValue: {
    type: [String, Number],
    default: 0,
  },
  min: {
    type: [String, Number],
  },
  max: {
    type: [String, Number],
  },
  step: {
    type: [String, Number],
    default: 1,
  },
  color: {
    type: String,
  },
  inputWidth: {
    type: [String, Number],
  },
  inputTextSize: {
    type: [String, Number],
  },
  buttonSize: {
    type: [String, Number],
  },
  decimalLength: {
    type: [String, Number],
  },
  disabled: {
    type: Boolean,
    default: false,
  },
  readonly: {
    type: Boolean,
    default: false,
  },
  disableIncrement: {
    type: Boolean,
    default: false,
  },
  disableDecrement: {
    type: Boolean,
    default: false,
  },
  disableInput: {
    type: Boolean,
    default: false,
  },
  lazyChange: {
    type: Boolean,
    default: false,
  },
  incrementButton: {
    type: Boolean,
    default: true,
  },
  decrementButton: {
    type: Boolean,
    default: true,
  },
  press: {
    type: Boolean,
    default: true,
  },
  ripple: {
    type: Boolean,
    default: true,
  },
  validateTrigger: {
    type: Array,
    default: () => ['onInputChange', 'onLazyChange', 'onIncrement', 'onDecrement'],
  },
  rules: {
    type: Array,
  },
  onBeforeChange: {
    type: Function,
  },
  onChange: {
    type: Function,
  },
  onIncrement: {
    type: Function,
  },
  onDecrement: {
    type: Function,
  },
  'onUpdate:modelValue': {
    type: Function,
  },
}
var { n: n$J, classes: classes$B } = createNamespace('counter')
var SPEED = 100
var DELAY = 600
var _hoisted_1$g = ['inputmode', 'readonly', 'disabled']
function render$G(_ctx, _cache2) {
  var _component_var_icon = resolveComponent('var-icon')
  var _component_var_form_details = resolveComponent('var-form-details')
  var _directive_ripple = resolveDirective('ripple')
  return (
    openBlock(),
    createElementBlock(
      'div',
      {
        class: normalizeClass(_ctx.classes(_ctx.n(), 'var--box')),
      },
      [
        createElementVNode(
          'div',
          mergeProps(
            {
              class: _ctx.classes(
                _ctx.n('controller'),
                'var-elevation--2',
                [_ctx.disabled || _ctx.formDisabled, _ctx.n('--disabled')],
                [_ctx.errorMessage, _ctx.n('--error')]
              ),
              style: {
                background: _ctx.color ? _ctx.color : void 0,
              },
            },
            _ctx.$attrs
          ),
          [
            withDirectives(
              createVNode(
                _component_var_icon,
                {
                  'var-counter-cover': '',
                  name: 'minus',
                  class: normalizeClass(
                    _ctx.classes(_ctx.n('decrement-button'), [!_ctx.decrementButton, _ctx.n('--hidden')])
                  ),
                  style: normalizeStyle({
                    width: _ctx.toSizeUnit(_ctx.buttonSize),
                    height: _ctx.toSizeUnit(_ctx.buttonSize),
                  }),
                  onClick: _ctx.decrement,
                  onTouchstart: _ctx.pressDecrement,
                  onTouchend: _ctx.releaseDecrement,
                  onTouchcancel: _ctx.releaseDecrement,
                },
                null,
                8,
                ['class', 'style', 'onClick', 'onTouchstart', 'onTouchend', 'onTouchcancel']
              ),
              [
                [
                  _directive_ripple,
                  {
                    disabled:
                      !_ctx.ripple ||
                      _ctx.disabled ||
                      _ctx.readonly ||
                      _ctx.disableDecrement ||
                      !_ctx.decrementButton ||
                      _ctx.isMin,
                  },
                ],
              ]
            ),
            withDirectives(
              createElementVNode(
                'input',
                {
                  class: normalizeClass(_ctx.n('input')),
                  style: normalizeStyle({
                    width: _ctx.toSizeUnit(_ctx.inputWidth),
                    fontSize: _ctx.toSizeUnit(_ctx.inputTextSize),
                  }),
                  inputmode: _ctx.toNumber(_ctx.decimalLength) === 0 ? 'numeric' : 'decimal',
                  readonly: _ctx.readonly || _ctx.formReadonly,
                  disabled: _ctx.disabled || _ctx.formDisabled || _ctx.disableInput,
                  'onUpdate:modelValue': _cache2[0] || (_cache2[0] = ($event) => (_ctx.inputValue = $event)),
                  onChange:
                    _cache2[1] ||
                    (_cache2[1] = function () {
                      return _ctx.handleChange && _ctx.handleChange(...arguments)
                    }),
                },
                null,
                46,
                _hoisted_1$g
              ),
              [[vModelText, _ctx.inputValue]]
            ),
            withDirectives(
              createVNode(
                _component_var_icon,
                {
                  'var-counter-cover': '',
                  name: 'plus',
                  class: normalizeClass(
                    _ctx.classes(_ctx.n('increment-button'), [!_ctx.incrementButton, _ctx.n('--hidden')])
                  ),
                  style: normalizeStyle({
                    width: _ctx.toSizeUnit(_ctx.buttonSize),
                    height: _ctx.toSizeUnit(_ctx.buttonSize),
                  }),
                  onClick: _ctx.increment,
                  onTouchstart: _ctx.pressIncrement,
                  onTouchend: _ctx.releaseIncrement,
                  onTouchcancel: _ctx.releaseIncrement,
                },
                null,
                8,
                ['class', 'style', 'onClick', 'onTouchstart', 'onTouchend', 'onTouchcancel']
              ),
              [
                [
                  _directive_ripple,
                  {
                    disabled:
                      !_ctx.ripple ||
                      _ctx.disabled ||
                      _ctx.readonly ||
                      _ctx.disableIncrement ||
                      !_ctx.incrementButton ||
                      _ctx.isMax,
                  },
                ],
              ]
            ),
          ],
          16
        ),
        createVNode(
          _component_var_form_details,
          {
            'error-message': _ctx.errorMessage,
          },
          null,
          8,
          ['error-message']
        ),
      ],
      2
    )
  )
}
var Counter = defineComponent({
  render: render$G,
  name: 'VarCounter',
  components: {
    VarIcon: Icon,
    VarFormDetails: FormDetails,
  },
  directives: {
    Ripple,
  },
  inheritAttrs: false,
  props: props$A,
  setup(props2) {
    var inputValue = ref('')
    var incrementTimer
    var decrementTimer
    var incrementDelayTimer
    var decrementDelayTimer
    var { bindForm, form } = useForm()
    var { errorMessage, validateWithTrigger: vt, validate: v, resetValidation } = useValidation()
    var { readonly: formReadonly, disabled: formDisabled } = form != null ? form : {}
    var validate2 = () => v(props2.rules, props2.modelValue)
    var validateWithTrigger = (trigger) => {
      nextTick(() => {
        var { validateTrigger, rules, modelValue } = props2
        vt(validateTrigger, trigger, rules, modelValue)
      })
    }
    var reset = () => {
      var { min: min2 } = props2
      call(props2['onUpdate:modelValue'], min2 != null ? toNumber(min2) : 0)
      resetValidation()
    }
    var counterProvider = {
      reset,
      validate: validate2,
      resetValidation,
    }
    var isMax = computed(() => {
      var { max: max2, modelValue } = props2
      return max2 != null && toNumber(modelValue) >= toNumber(max2)
    })
    var isMin = computed(() => {
      var { min: min2, modelValue } = props2
      return min2 != null && toNumber(modelValue) <= toNumber(min2)
    })
    var normalizeValue = (value) => {
      var { decimalLength, max: max2, min: min2 } = props2
      var num = toNumber(value)
      if (max2 != null && num > toNumber(max2)) {
        num = toNumber(max2)
      }
      if (min2 != null && num < toNumber(min2)) {
        num = toNumber(min2)
      }
      value = String(num)
      if (decimalLength != null) {
        value = num.toFixed(toNumber(decimalLength))
      }
      return value
    }
    var handleChange = (event) => {
      var { lazyChange, onBeforeChange } = props2
      var { value } = event.target
      var normalizedValue = normalizeValue(value)
      lazyChange ? call(onBeforeChange, toNumber(normalizedValue), change) : setNormalizedValue(normalizedValue)
      validateWithTrigger('onInputChange')
    }
    var decrement = () => {
      var {
        disabled,
        readonly,
        disableDecrement,
        decrementButton,
        lazyChange,
        step,
        modelValue,
        onDecrement,
        onBeforeChange,
      } = props2
      if (
        (formDisabled != null && formDisabled.value) ||
        (formReadonly != null && formReadonly.value) ||
        disabled ||
        readonly ||
        disableDecrement ||
        !decrementButton
      ) {
        return
      }
      if (isMin.value) {
        return
      }
      var value = new Decimal(toNumber(modelValue)).minus(new Decimal(toNumber(step))).toString()
      var normalizedValue = normalizeValue(value)
      var normalizedValueNum = toNumber(normalizedValue)
      call(onDecrement, normalizedValueNum)
      if (lazyChange) {
        call(onBeforeChange, normalizedValueNum, change)
      } else {
        setNormalizedValue(normalizedValue)
        validateWithTrigger('onDecrement')
      }
    }
    var increment = () => {
      var {
        disabled,
        readonly,
        disableIncrement,
        incrementButton,
        lazyChange,
        step,
        modelValue,
        onIncrement,
        onBeforeChange,
      } = props2
      if (
        (formDisabled != null && formDisabled.value) ||
        (formReadonly != null && formReadonly.value) ||
        disabled ||
        readonly ||
        disableIncrement ||
        !incrementButton
      ) {
        return
      }
      if (isMax.value) {
        return
      }
      var value = new Decimal(toNumber(modelValue)).plus(new Decimal(toNumber(step))).toString()
      var normalizedValue = normalizeValue(value)
      var normalizedValueNum = toNumber(normalizedValue)
      call(onIncrement, normalizedValueNum)
      if (lazyChange) {
        call(onBeforeChange, normalizedValueNum, change)
      } else {
        setNormalizedValue(normalizedValue)
        validateWithTrigger('onIncrement')
      }
    }
    var pressDecrement = () => {
      var { press, lazyChange } = props2
      if (!press || lazyChange) {
        return
      }
      decrementDelayTimer = window.setTimeout(() => {
        continuedDecrement()
      }, DELAY)
    }
    var pressIncrement = () => {
      var { press, lazyChange } = props2
      if (!press || lazyChange) {
        return
      }
      incrementDelayTimer = window.setTimeout(() => {
        continuedIncrement()
      }, DELAY)
    }
    var releaseDecrement = () => {
      decrementTimer && clearTimeout(decrementTimer)
      decrementDelayTimer && clearTimeout(decrementDelayTimer)
    }
    var releaseIncrement = () => {
      incrementTimer && clearTimeout(incrementTimer)
      incrementDelayTimer && clearTimeout(incrementDelayTimer)
    }
    var continuedIncrement = () => {
      incrementTimer = window.setTimeout(() => {
        increment()
        continuedIncrement()
      }, SPEED)
    }
    var continuedDecrement = () => {
      decrementTimer = window.setTimeout(() => {
        decrement()
        continuedDecrement()
      }, SPEED)
    }
    var setNormalizedValue = (normalizedValue) => {
      inputValue.value = normalizedValue
      var normalizedValueNum = toNumber(normalizedValue)
      call(props2['onUpdate:modelValue'], normalizedValueNum)
    }
    var change = (value) => {
      setNormalizedValue(normalizeValue(String(value)))
      validateWithTrigger('onLazyChange')
    }
    call(bindForm, counterProvider)
    watch(
      () => props2.modelValue,
      (newValue) => {
        setNormalizedValue(normalizeValue(String(newValue)))
        call(props2.onChange, toNumber(newValue))
      }
    )
    setNormalizedValue(normalizeValue(String(props2.modelValue)))
    return {
      n: n$J,
      classes: classes$B,
      inputValue,
      errorMessage,
      formDisabled,
      formReadonly,
      isMax,
      isMin,
      validate: validate2,
      reset,
      resetValidation,
      handleChange,
      decrement,
      increment,
      pressDecrement,
      pressIncrement,
      releaseDecrement,
      releaseIncrement,
      toSizeUnit,
      toNumber,
    }
  },
})
Counter.install = function (app) {
  app.component(Counter.name, Counter)
}
var SECONDS_A_MINUTE = 60
var SECONDS_A_HOUR = SECONDS_A_MINUTE * 60
var SECONDS_A_DAY = SECONDS_A_HOUR * 24
var SECONDS_A_WEEK = SECONDS_A_DAY * 7
var MILLISECONDS_A_SECOND = 1e3
var MILLISECONDS_A_MINUTE = SECONDS_A_MINUTE * MILLISECONDS_A_SECOND
var MILLISECONDS_A_HOUR = SECONDS_A_HOUR * MILLISECONDS_A_SECOND
var MILLISECONDS_A_DAY = SECONDS_A_DAY * MILLISECONDS_A_SECOND
var MILLISECONDS_A_WEEK = SECONDS_A_WEEK * MILLISECONDS_A_SECOND
var MS = 'millisecond'
var S = 'second'
var MIN = 'minute'
var H = 'hour'
var D = 'day'
var W = 'week'
var M = 'month'
var Q = 'quarter'
var Y = 'year'
var DATE = 'date'
var FORMAT_DEFAULT = 'YYYY-MM-DDTHH:mm:ssZ'
var INVALID_DATE_STRING = 'Invalid Date'
var REGEX_PARSE = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/
var REGEX_FORMAT = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g
var en = {
  name: 'en',
  weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
  months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
}
var padStart = function padStart2(string2, length, pad) {
  var s2 = String(string2)
  if (!s2 || s2.length >= length) return string2
  return '' + Array(length + 1 - s2.length).join(pad) + string2
}
var padZoneStr = function padZoneStr2(instance) {
  var negMinutes = -instance.utcOffset()
  var minutes = Math.abs(negMinutes)
  var hourOffset = Math.floor(minutes / 60)
  var minuteOffset = minutes % 60
  return (negMinutes <= 0 ? '+' : '-') + padStart(hourOffset, 2, '0') + ':' + padStart(minuteOffset, 2, '0')
}
var monthDiff = function monthDiff2(a, b) {
  if (a.date() < b.date()) return -monthDiff2(b, a)
  var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month())
  var anchor = a.clone().add(wholeMonthDiff, M)
  var c = b - anchor < 0
  var anchor2 = a.clone().add(wholeMonthDiff + (c ? -1 : 1), M)
  return +(-(wholeMonthDiff + (b - anchor) / (c ? anchor - anchor2 : anchor2 - anchor)) || 0)
}
var absFloor = function absFloor2(n2) {
  return n2 < 0 ? Math.ceil(n2) || 0 : Math.floor(n2)
}
var prettyUnit = function prettyUnit2(u) {
  var special = {
    M,
    y: Y,
    w: W,
    d: D,
    D: DATE,
    h: H,
    m: MIN,
    s: S,
    ms: MS,
    Q,
  }
  return (
    special[u] ||
    String(u || '')
      .toLowerCase()
      .replace(/s$/, '')
  )
}
var isUndefined = function isUndefined2(s2) {
  return s2 === void 0
}
var U = {
  s: padStart,
  z: padZoneStr,
  m: monthDiff,
  a: absFloor,
  p: prettyUnit,
  u: isUndefined,
}
var L = 'en'
var Ls = {}
Ls[L] = en
var isDayjs = function isDayjs2(d2) {
  return d2 instanceof Dayjs
}
var parseLocale = function parseLocale2(preset, object2, isLocal) {
  var l
  if (!preset) return L
  if (typeof preset === 'string') {
    var presetLower = preset.toLowerCase()
    if (Ls[presetLower]) {
      l = presetLower
    }
    if (object2) {
      Ls[presetLower] = object2
      l = presetLower
    }
    var presetSplit = preset.split('-')
    if (!l && presetSplit.length > 1) {
      return parseLocale2(presetSplit[0])
    }
  } else {
    var name = preset.name
    Ls[name] = preset
    l = name
  }
  if (!isLocal && l) L = l
  return l || (!isLocal && L)
}
var dayjs = function dayjs2(date, c) {
  if (isDayjs(date)) {
    return date.clone()
  }
  var cfg = typeof c === 'object' ? c : {}
  cfg.date = date
  cfg.args = arguments
  return new Dayjs(cfg)
}
var wrapper = function wrapper2(date, instance) {
  return dayjs(date, {
    locale: instance.$L,
    utc: instance.$u,
    x: instance.$x,
    $offset: instance.$offset,
  })
}
var Utils = U
Utils.l = parseLocale
Utils.i = isDayjs
Utils.w = wrapper
var parseDate = function parseDate2(cfg) {
  var date = cfg.date,
    utc = cfg.utc
  if (date === null) return new Date(NaN)
  if (Utils.u(date)) return new Date()
  if (date instanceof Date) return new Date(date)
  if (typeof date === 'string' && !/Z$/i.test(date)) {
    var d2 = date.match(REGEX_PARSE)
    if (d2) {
      var m2 = d2[2] - 1 || 0
      var ms2 = (d2[7] || '0').substring(0, 3)
      if (utc) {
        return new Date(Date.UTC(d2[1], m2, d2[3] || 1, d2[4] || 0, d2[5] || 0, d2[6] || 0, ms2))
      }
      return new Date(d2[1], m2, d2[3] || 1, d2[4] || 0, d2[5] || 0, d2[6] || 0, ms2)
    }
  }
  return new Date(date)
}
var Dayjs = /* @__PURE__ */ (function () {
  function Dayjs2(cfg) {
    this.$L = parseLocale(cfg.locale, null, true)
    this.parse(cfg)
  }
  var _proto = Dayjs2.prototype
  _proto.parse = function parse2(cfg) {
    this.$d = parseDate(cfg)
    this.$x = cfg.x || {}
    this.init()
  }
  _proto.init = function init() {
    var $d = this.$d
    this.$y = $d.getFullYear()
    this.$M = $d.getMonth()
    this.$D = $d.getDate()
    this.$W = $d.getDay()
    this.$H = $d.getHours()
    this.$m = $d.getMinutes()
    this.$s = $d.getSeconds()
    this.$ms = $d.getMilliseconds()
  }
  _proto.$utils = function $utils() {
    return Utils
  }
  _proto.isValid = function isValid() {
    return !(this.$d.toString() === INVALID_DATE_STRING)
  }
  _proto.isSame = function isSame(that, units) {
    var other = dayjs(that)
    return this.startOf(units) <= other && other <= this.endOf(units)
  }
  _proto.isAfter = function isAfter(that, units) {
    return dayjs(that) < this.startOf(units)
  }
  _proto.isBefore = function isBefore(that, units) {
    return this.endOf(units) < dayjs(that)
  }
  _proto.$g = function $g(input, get2, set) {
    if (Utils.u(input)) return this[get2]
    return this.set(set, input)
  }
  _proto.unix = function unix() {
    return Math.floor(this.valueOf() / 1e3)
  }
  _proto.valueOf = function valueOf() {
    return this.$d.getTime()
  }
  _proto.startOf = function startOf(units, _startOf) {
    var _this = this
    var isStartOf = !Utils.u(_startOf) ? _startOf : true
    var unit = Utils.p(units)
    var instanceFactory = function instanceFactory2(d2, m2) {
      var ins = Utils.w(_this.$u ? Date.UTC(_this.$y, m2, d2) : new Date(_this.$y, m2, d2), _this)
      return isStartOf ? ins : ins.endOf(D)
    }
    var instanceFactorySet = function instanceFactorySet2(method, slice) {
      var argumentStart = [0, 0, 0, 0]
      var argumentEnd = [23, 59, 59, 999]
      return Utils.w(
        _this.toDate()[method].apply(_this.toDate('s'), (isStartOf ? argumentStart : argumentEnd).slice(slice)),
        _this
      )
    }
    var $W = this.$W,
      $M = this.$M,
      $D = this.$D
    var utcPad = 'set' + (this.$u ? 'UTC' : '')
    switch (unit) {
      case Y:
        return isStartOf ? instanceFactory(1, 0) : instanceFactory(31, 11)
      case M:
        return isStartOf ? instanceFactory(1, $M) : instanceFactory(0, $M + 1)
      case W: {
        var weekStart = this.$locale().weekStart || 0
        var gap = ($W < weekStart ? $W + 7 : $W) - weekStart
        return instanceFactory(isStartOf ? $D - gap : $D + (6 - gap), $M)
      }
      case D:
      case DATE:
        return instanceFactorySet(utcPad + 'Hours', 0)
      case H:
        return instanceFactorySet(utcPad + 'Minutes', 1)
      case MIN:
        return instanceFactorySet(utcPad + 'Seconds', 2)
      case S:
        return instanceFactorySet(utcPad + 'Milliseconds', 3)
      default:
        return this.clone()
    }
  }
  _proto.endOf = function endOf(arg) {
    return this.startOf(arg, false)
  }
  _proto.$set = function $set(units, _int) {
    var _C$D$C$DATE$C$M$C$Y$C
    var unit = Utils.p(units)
    var utcPad = 'set' + (this.$u ? 'UTC' : '')
    var name = ((_C$D$C$DATE$C$M$C$Y$C = {}),
    (_C$D$C$DATE$C$M$C$Y$C[D] = utcPad + 'Date'),
    (_C$D$C$DATE$C$M$C$Y$C[DATE] = utcPad + 'Date'),
    (_C$D$C$DATE$C$M$C$Y$C[M] = utcPad + 'Month'),
    (_C$D$C$DATE$C$M$C$Y$C[Y] = utcPad + 'FullYear'),
    (_C$D$C$DATE$C$M$C$Y$C[H] = utcPad + 'Hours'),
    (_C$D$C$DATE$C$M$C$Y$C[MIN] = utcPad + 'Minutes'),
    (_C$D$C$DATE$C$M$C$Y$C[S] = utcPad + 'Seconds'),
    (_C$D$C$DATE$C$M$C$Y$C[MS] = utcPad + 'Milliseconds'),
    _C$D$C$DATE$C$M$C$Y$C)[unit]
    var arg = unit === D ? this.$D + (_int - this.$W) : _int
    if (unit === M || unit === Y) {
      var date = this.clone().set(DATE, 1)
      date.$d[name](arg)
      date.init()
      this.$d = date.set(DATE, Math.min(this.$D, date.daysInMonth())).$d
    } else if (name) this.$d[name](arg)
    this.init()
    return this
  }
  _proto.set = function set(string2, _int2) {
    return this.clone().$set(string2, _int2)
  }
  _proto.get = function get2(unit) {
    return this[Utils.p(unit)]()
  }
  _proto.add = function add2(number, units) {
    var _this2 = this,
      _C$MIN$C$H$C$S$unit
    number = Number(number)
    var unit = Utils.p(units)
    var instanceFactorySet = function instanceFactorySet2(n2) {
      var d2 = dayjs(_this2)
      return Utils.w(d2.date(d2.date() + Math.round(n2 * number)), _this2)
    }
    if (unit === M) {
      return this.set(M, this.$M + number)
    }
    if (unit === Y) {
      return this.set(Y, this.$y + number)
    }
    if (unit === D) {
      return instanceFactorySet(1)
    }
    if (unit === W) {
      return instanceFactorySet(7)
    }
    var step =
      ((_C$MIN$C$H$C$S$unit = {}),
      (_C$MIN$C$H$C$S$unit[MIN] = MILLISECONDS_A_MINUTE),
      (_C$MIN$C$H$C$S$unit[H] = MILLISECONDS_A_HOUR),
      (_C$MIN$C$H$C$S$unit[S] = MILLISECONDS_A_SECOND),
      _C$MIN$C$H$C$S$unit)[unit] || 1
    var nextTimeStamp = this.$d.getTime() + number * step
    return Utils.w(nextTimeStamp, this)
  }
  _proto.subtract = function subtract(number, string2) {
    return this.add(number * -1, string2)
  }
  _proto.format = function format(formatStr) {
    var _this3 = this
    var locale = this.$locale()
    if (!this.isValid()) return locale.invalidDate || INVALID_DATE_STRING
    var str = formatStr || FORMAT_DEFAULT
    var zoneStr = Utils.z(this)
    var $H = this.$H,
      $m = this.$m,
      $M = this.$M
    var weekdays = locale.weekdays,
      months = locale.months,
      meridiem = locale.meridiem
    var getShort = function getShort2(arr, index2, full, length) {
      return (arr && (arr[index2] || arr(_this3, str))) || full[index2].slice(0, length)
    }
    var get$H = function get$H2(num) {
      return Utils.s($H % 12 || 12, num, '0')
    }
    var meridiemFunc =
      meridiem ||
      function (hour, minute, isLowercase) {
        var m2 = hour < 12 ? 'AM' : 'PM'
        return isLowercase ? m2.toLowerCase() : m2
      }
    var matches = {
      YY: String(this.$y).slice(-2),
      YYYY: this.$y,
      M: $M + 1,
      MM: Utils.s($M + 1, 2, '0'),
      MMM: getShort(locale.monthsShort, $M, months, 3),
      MMMM: getShort(months, $M),
      D: this.$D,
      DD: Utils.s(this.$D, 2, '0'),
      d: String(this.$W),
      dd: getShort(locale.weekdaysMin, this.$W, weekdays, 2),
      ddd: getShort(locale.weekdaysShort, this.$W, weekdays, 3),
      dddd: weekdays[this.$W],
      H: String($H),
      HH: Utils.s($H, 2, '0'),
      h: get$H(1),
      hh: get$H(2),
      a: meridiemFunc($H, $m, true),
      A: meridiemFunc($H, $m, false),
      m: String($m),
      mm: Utils.s($m, 2, '0'),
      s: String(this.$s),
      ss: Utils.s(this.$s, 2, '0'),
      SSS: Utils.s(this.$ms, 3, '0'),
      Z: zoneStr,
    }
    return str.replace(REGEX_FORMAT, function (match, $1) {
      return $1 || matches[match] || zoneStr.replace(':', '')
    })
  }
  _proto.utcOffset = function utcOffset() {
    return -Math.round(this.$d.getTimezoneOffset() / 15) * 15
  }
  _proto.diff = function diff2(input, units, _float) {
    var _C$Y$C$M$C$Q$C$W$C$D$
    var unit = Utils.p(units)
    var that = dayjs(input)
    var zoneDelta = (that.utcOffset() - this.utcOffset()) * MILLISECONDS_A_MINUTE
    var diff3 = this - that
    var result = Utils.m(this, that)
    result =
      ((_C$Y$C$M$C$Q$C$W$C$D$ = {}),
      (_C$Y$C$M$C$Q$C$W$C$D$[Y] = result / 12),
      (_C$Y$C$M$C$Q$C$W$C$D$[M] = result),
      (_C$Y$C$M$C$Q$C$W$C$D$[Q] = result / 3),
      (_C$Y$C$M$C$Q$C$W$C$D$[W] = (diff3 - zoneDelta) / MILLISECONDS_A_WEEK),
      (_C$Y$C$M$C$Q$C$W$C$D$[D] = (diff3 - zoneDelta) / MILLISECONDS_A_DAY),
      (_C$Y$C$M$C$Q$C$W$C$D$[H] = diff3 / MILLISECONDS_A_HOUR),
      (_C$Y$C$M$C$Q$C$W$C$D$[MIN] = diff3 / MILLISECONDS_A_MINUTE),
      (_C$Y$C$M$C$Q$C$W$C$D$[S] = diff3 / MILLISECONDS_A_SECOND),
      _C$Y$C$M$C$Q$C$W$C$D$)[unit] || diff3
    return _float ? result : Utils.a(result)
  }
  _proto.daysInMonth = function daysInMonth() {
    return this.endOf(M).$D
  }
  _proto.$locale = function $locale() {
    return Ls[this.$L]
  }
  _proto.locale = function locale(preset, object2) {
    if (!preset) return this.$L
    var that = this.clone()
    var nextLocaleName = parseLocale(preset, object2, true)
    if (nextLocaleName) that.$L = nextLocaleName
    return that
  }
  _proto.clone = function clone2() {
    return Utils.w(this.$d, this)
  }
  _proto.toDate = function toDate() {
    return new Date(this.valueOf())
  }
  _proto.toJSON = function toJSON() {
    return this.isValid() ? this.toISOString() : null
  }
  _proto.toISOString = function toISOString() {
    return this.$d.toISOString()
  }
  _proto.toString = function toString2() {
    return this.$d.toUTCString()
  }
  return Dayjs2
})()
var proto = Dayjs.prototype
dayjs.prototype = proto
;[
  ['$ms', MS],
  ['$s', S],
  ['$m', MIN],
  ['$H', H],
  ['$W', D],
  ['$M', M],
  ['$y', Y],
  ['$D', DATE],
].forEach(function (g) {
  proto[g[1]] = function (input) {
    return this.$g(input, g[0], g[1])
  }
})
dayjs.extend = function (plugin, option) {
  if (!plugin.$i) {
    plugin(option, Dayjs, dayjs)
    plugin.$i = true
  }
  return dayjs
}
dayjs.locale = parseLocale
dayjs.isDayjs = isDayjs
dayjs.unix = function (timestamp) {
  return dayjs(timestamp * 1e3)
}
dayjs.en = Ls[L]
dayjs.Ls = Ls
dayjs.p = {}
var isSameOrBefore = function (o, c) {
  c.prototype.isSameOrBefore = function (that, units) {
    return this.isSame(that, units) || this.isBefore(that, units)
  }
}
var isSameOrAfter = function (o, c) {
  c.prototype.isSameOrAfter = function (that, units) {
    return this.isSame(that, units) || this.isAfter(that, units)
  }
}
function typeValidator$2(type) {
  return ['date', 'month'].includes(type)
}
var MONTH_LIST = [
  {
    index: '01',
  },
  {
    index: '02',
  },
  {
    index: '03',
  },
  {
    index: '04',
  },
  {
    index: '05',
  },
  {
    index: '06',
  },
  {
    index: '07',
  },
  {
    index: '08',
  },
  {
    index: '09',
  },
  {
    index: '10',
  },
  {
    index: '11',
  },
  {
    index: '12',
  },
]
var WEEK_HEADER = [
  {
    index: '0',
  },
  {
    index: '1',
  },
  {
    index: '2',
  },
  {
    index: '3',
  },
  {
    index: '4',
  },
  {
    index: '5',
  },
  {
    index: '6',
  },
]
var props$z = {
  modelValue: {
    type: [String, Array],
  },
  type: {
    type: String,
    default: 'date',
    validator: typeValidator$2,
  },
  allowedDates: {
    type: Function,
  },
  color: {
    type: String,
  },
  headerColor: {
    type: String,
  },
  shadow: {
    type: Boolean,
    default: false,
  },
  firstDayOfWeek: {
    type: [String, Number],
    default: 0,
  },
  min: {
    type: String,
  },
  max: {
    type: String,
  },
  showCurrent: {
    type: Boolean,
    default: true,
  },
  readonly: {
    type: Boolean,
    default: false,
  },
  multiple: {
    type: Boolean,
    default: false,
  },
  range: {
    type: Boolean,
    default: false,
  },
  touchable: {
    type: Boolean,
    default: true,
  },
  onChange: {
    type: Function,
  },
  'onUpdate:modelValue': {
    type: Function,
  },
}
var { n: n$I } = createNamespace('picker-header')
function render$F(_ctx, _cache2) {
  var _component_var_icon = resolveComponent('var-icon')
  var _component_var_button = resolveComponent('var-button')
  return (
    openBlock(),
    createElementBlock(
      'div',
      {
        class: normalizeClass(_ctx.n()),
      },
      [
        createVNode(
          _component_var_button,
          {
            round: '',
            text: '',
            style: {
              filter: 'opacity(0.54)',
            },
            disabled: _ctx.disabled.left,
            onClick: _cache2[0] || (_cache2[0] = ($event) => _ctx.checkDate('prev')),
          },
          {
            default: withCtx(() => [
              createVNode(_component_var_icon, {
                name: 'chevron-left',
              }),
            ]),
            _: 1,
          },
          8,
          ['disabled']
        ),
        createElementVNode(
          'div',
          {
            class: normalizeClass(_ctx.n('value')),
            onClick: _cache2[1] || (_cache2[1] = ($event) => _ctx.$emit('check-panel')),
          },
          [
            createVNode(
              Transition,
              {
                name: 'var-date-picker' + (_ctx.reverse ? '-reverse' : '') + '-translatex',
              },
              {
                default: withCtx(() => [
                  (openBlock(),
                  createElementBlock(
                    'div',
                    {
                      key: _ctx.showDate,
                    },
                    toDisplayString(_ctx.showDate),
                    1
                  )),
                ]),
                _: 1,
              },
              8,
              ['name']
            ),
          ],
          2
        ),
        createVNode(
          _component_var_button,
          {
            round: '',
            text: '',
            style: {
              filter: 'opacity(0.54)',
            },
            disabled: _ctx.disabled.right,
            onClick: _cache2[2] || (_cache2[2] = ($event) => _ctx.checkDate('next')),
          },
          {
            default: withCtx(() => [
              createVNode(_component_var_icon, {
                name: 'chevron-right',
              }),
            ]),
            _: 1,
          },
          8,
          ['disabled']
        ),
      ],
      2
    )
  )
}
var PanelHeader = defineComponent({
  render: render$F,
  name: 'PanelHeader',
  components: {
    VarButton: Button,
    VarIcon: Icon,
  },
  props: {
    date: {
      type: Object,
      required: true,
    },
    type: {
      type: String,
      default: 'date',
    },
    disabled: {
      type: Object,
      required: true,
    },
  },
  emits: ['check-panel', 'check-date'],
  setup(props2, _ref) {
    var { emit } = _ref
    var reverse = ref(false)
    var forwardOrBackNum = ref(0)
    var showDate = computed(() => {
      var _pack$value$datePicke
      var { date, type } = props2
      var { previewMonth, previewYear } = date
      if (type === 'month') return toNumber(previewYear) + forwardOrBackNum.value
      var monthName =
        (_pack$value$datePicke = pack.value.datePickerMonthDict) == null
          ? void 0
          : _pack$value$datePicke[previewMonth.index].name
      return pack.value.lang === 'zh-CN' ? previewYear + ' ' + monthName : monthName + ' ' + previewYear
    })
    var checkDate = (checkType) => {
      if ((checkType === 'prev' && props2.disabled.left) || (checkType === 'next' && props2.disabled.right)) return
      emit('check-date', checkType)
      reverse.value = checkType === 'prev'
      forwardOrBackNum.value += checkType === 'prev' ? -1 : 1
    }
    watch(
      () => props2.date,
      () => {
        forwardOrBackNum.value = 0
      }
    )
    return {
      n: n$I,
      reverse,
      showDate,
      checkDate,
    }
  },
})
function _extends$7() {
  _extends$7 =
    Object.assign ||
    function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i]
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key]
          }
        }
      }
      return target
    }
  return _extends$7.apply(this, arguments)
}
dayjs.extend(isSameOrBefore)
dayjs.extend(isSameOrAfter)
var { n: n$H, classes: classes$A } = createNamespace('month-picker')
var { n: nDate$1 } = createNamespace('date-picker')
function render$E(_ctx, _cache2) {
  var _component_panel_header = resolveComponent('panel-header')
  var _component_var_button = resolveComponent('var-button')
  return (
    openBlock(),
    createElementBlock(
      'div',
      {
        class: normalizeClass(_ctx.n()),
      },
      [
        createElementVNode(
          'div',
          {
            class: normalizeClass(_ctx.n('content')),
          },
          [
            createVNode(
              _component_panel_header,
              {
                ref: 'headerEl',
                type: 'month',
                date: _ctx.preview,
                disabled: _ctx.panelBtnDisabled,
                onCheckPanel: _ctx.clickYear,
                onCheckDate: _ctx.checkDate,
              },
              null,
              8,
              ['date', 'disabled', 'onCheckPanel', 'onCheckDate']
            ),
            createVNode(
              Transition,
              {
                name: '' + _ctx.nDate() + (_ctx.reverse ? '-reverse' : '') + '-translatex',
              },
              {
                default: withCtx(() => [
                  (openBlock(),
                  createElementBlock(
                    'ul',
                    {
                      key: _ctx.panelKey,
                    },
                    [
                      (openBlock(true),
                      createElementBlock(
                        Fragment,
                        null,
                        renderList(_ctx.MONTH_LIST, (month) => {
                          return (
                            openBlock(),
                            createElementBlock(
                              'li',
                              {
                                key: month.index,
                              },
                              [
                                createVNode(
                                  _component_var_button,
                                  mergeProps(
                                    {
                                      type: 'primary',
                                      'var-month-picker-cover': '',
                                      ripple: false,
                                    },
                                    _extends$7({}, _ctx.buttonProps(month.index)),
                                    {
                                      onClick: (event) => _ctx.chooseMonth(month, event),
                                    }
                                  ),
                                  {
                                    default: withCtx(() => [
                                      createTextVNode(toDisplayString(_ctx.getMonthAbbr(month.index)), 1),
                                    ]),
                                    _: 2,
                                  },
                                  1040,
                                  ['onClick']
                                ),
                              ]
                            )
                          )
                        }),
                        128
                      )),
                    ]
                  )),
                ]),
                _: 1,
              },
              8,
              ['name']
            ),
          ],
          2
        ),
      ],
      2
    )
  )
}
var MonthPickerPanel = defineComponent({
  render: render$E,
  name: 'MonthPickerPanel',
  components: {
    VarButton: Button,
    PanelHeader,
  },
  props: {
    choose: {
      type: Object,
      required: true,
    },
    preview: {
      type: Object,
      required: true,
    },
    current: {
      type: String,
      required: true,
    },
    clickYear: {
      type: Function,
      required: true,
    },
    componentProps: {
      type: Object,
      required: true,
    },
  },
  emits: ['check-preview', 'choose-month'],
  setup(props2, _ref) {
    var { emit } = _ref
    var [currentYear, currentMonth] = props2.current.split('-')
    var reverse = ref(false)
    var panelKey = ref(0)
    var headerEl = ref(null)
    var panelBtnDisabled = reactive({
      left: false,
      right: false,
    })
    var isSameYear = computed(() => props2.choose.chooseYear === props2.preview.previewYear)
    var isCurrentYear = computed(() => props2.preview.previewYear === currentYear)
    var getMonthAbbr = (key) => {
      var _pack$value$datePicke, _pack$value$datePicke2
      return (_pack$value$datePicke =
        (_pack$value$datePicke2 = pack.value.datePickerMonthDict) == null
          ? void 0
          : _pack$value$datePicke2[key].abbr) != null
        ? _pack$value$datePicke
        : ''
    }
    var inRange = (key) => {
      var {
        preview: { previewYear },
        componentProps: { min: min2, max: max2 },
      } = props2
      var isBeforeMax = true
      var isAfterMin = true
      var previewDate = previewYear + '-' + key
      if (max2) isBeforeMax = dayjs(previewDate).isSameOrBefore(dayjs(max2), 'month')
      if (min2) isAfterMin = dayjs(previewDate).isSameOrAfter(dayjs(min2), 'month')
      return isBeforeMax && isAfterMin
    }
    var shouldChoose = (val) => {
      var {
        choose: { chooseMonths, chooseDays, chooseRangeMonth },
        componentProps: { type, range },
      } = props2
      if (range) {
        if (!chooseRangeMonth.length) return false
        var isBeforeMax = dayjs(val).isSameOrBefore(dayjs(chooseRangeMonth[1]), 'month')
        var isAfterMin = dayjs(val).isSameOrAfter(dayjs(chooseRangeMonth[0]), 'month')
        return isBeforeMax && isAfterMin
      }
      if (type === 'month') return chooseMonths.includes(val)
      return chooseDays.some((value) => value.includes(val))
    }
    var buttonProps = (key) => {
      var {
        choose: { chooseMonth: chooseMonth2 },
        preview: { previewYear },
        componentProps: { allowedDates, color, multiple, range },
      } = props2
      var val = previewYear + '-' + key
      var monthExist = () => {
        if (range || multiple) return shouldChoose(val)
        return (chooseMonth2 == null ? void 0 : chooseMonth2.index) === key && isSameYear.value
      }
      var computeDisabled = () => {
        if (!inRange(key)) return true
        if (!allowedDates) return false
        return !allowedDates(val)
      }
      var disabled = computeDisabled()
      var computeText = () => {
        if (disabled) return true
        if (range || multiple) return !shouldChoose(val)
        return !isSameYear.value || (chooseMonth2 == null ? void 0 : chooseMonth2.index) !== key
      }
      var computeOutline = () => {
        if (!(isCurrentYear.value && currentMonth === key && props2.componentProps.showCurrent)) return false
        if ((range || multiple || isSameYear.value) && disabled) return true
        if (range || multiple) return !shouldChoose(val)
        if (isSameYear.value) return (chooseMonth2 == null ? void 0 : chooseMonth2.index) !== currentMonth
        return true
      }
      var textColorOrCover = () => {
        if (disabled) return ''
        if (computeOutline()) return color != null ? color : ''
        if (monthExist()) return ''
        return nDate$1() + '-color-cover'
      }
      var isCover = textColorOrCover().startsWith(nDate$1())
      return {
        outline: computeOutline(),
        text: computeText(),
        color: !computeText() ? color : '',
        textColor: isCover ? '' : textColorOrCover(),
        [nDate$1() + '-color-cover']: isCover,
        class: classes$A(n$H('button'), [disabled, n$H('button--disabled')]),
      }
    }
    var chooseMonth = (month, event) => {
      var buttonEl = event.currentTarget
      if (buttonEl.classList.contains(n$H('button--disabled'))) return
      emit('choose-month', month)
    }
    var checkDate = (checkType) => {
      reverse.value = checkType === 'prev'
      panelKey.value += checkType === 'prev' ? -1 : 1
      emit('check-preview', 'year', checkType)
    }
    var forwardRef = (checkType) => {
      headerEl.value.checkDate(checkType)
    }
    watch(
      () => props2.preview.previewYear,
      (year) => {
        var {
          componentProps: { min: min2, max: max2 },
        } = props2
        if (max2) panelBtnDisabled.right = !dayjs('' + (toNumber(year) + 1)).isSameOrBefore(dayjs(max2), 'year')
        if (min2) panelBtnDisabled.left = !dayjs('' + (toNumber(year) - 1)).isSameOrAfter(dayjs(min2), 'year')
      },
      {
        immediate: true,
      }
    )
    return {
      n: n$H,
      nDate: nDate$1,
      pack,
      MONTH_LIST,
      headerEl,
      reverse,
      panelKey,
      panelBtnDisabled,
      forwardRef,
      buttonProps,
      getMonthAbbr,
      chooseMonth,
      checkDate,
    }
  },
})
var { n: n$G, classes: classes$z } = createNamespace('year-picker')
var _hoisted_1$f = ['onClick']
function render$D(_ctx, _cache2) {
  return (
    openBlock(),
    createElementBlock(
      'ul',
      {
        class: normalizeClass(_ctx.n()),
      },
      [
        (openBlock(true),
        createElementBlock(
          Fragment,
          null,
          renderList(_ctx.yearList, (year) => {
            return (
              openBlock(),
              createElementBlock(
                'li',
                {
                  key: year,
                  class: normalizeClass(
                    _ctx.classes(_ctx.n('item'), [year === _ctx.toNumber(_ctx.preview), _ctx.n('item--active')])
                  ),
                  style: normalizeStyle({
                    color: year === _ctx.toNumber(_ctx.preview) ? _ctx.componentProps.color : '',
                  }),
                  onClick: ($event) => _ctx.chooseYear(year),
                },
                toDisplayString(year),
                15,
                _hoisted_1$f
              )
            )
          }),
          128
        )),
      ],
      2
    )
  )
}
var YearPickerPanel = defineComponent({
  render: render$D,
  name: 'YearPickerPanel',
  props: {
    preview: {
      type: String,
    },
    componentProps: {
      type: Object,
      required: true,
    },
  },
  emits: ['choose-year'],
  setup(props2, _ref) {
    var { emit } = _ref
    var yearList = computed(() => {
      var list2 = []
      var {
        preview,
        componentProps: { max: max2, min: min2 },
      } = props2
      if (!preview) return list2
      var yearRange = [toNumber(preview) + 100, toNumber(preview) - 100]
      if (max2) {
        var formatMax = dayjs(max2).format('YYYY-MM-D')
        var year = toNumber(formatMax.split('-')[0])
        if (year < yearRange[0] && year > yearRange[1]) yearRange = [year, yearRange[1]]
        if (year <= yearRange[1]) return [year]
      }
      if (min2) {
        var formatMin = dayjs(min2).format('YYYY-MM-D')
        var _year = toNumber(formatMin.split('-')[0])
        if (_year < yearRange[0] && _year > yearRange[1]) yearRange = [yearRange[0], _year]
        if (_year >= yearRange[0]) return [_year]
      }
      for (var i = yearRange[0]; i >= yearRange[1]; i--) {
        list2.push(i)
      }
      return list2
    })
    var chooseYear = (year) => {
      emit('choose-year', year)
    }
    onMounted(() => {
      var activeEl = document.querySelector('.' + n$G('item--active'))
      activeEl == null
        ? void 0
        : activeEl.scrollIntoView({
            block: 'center',
          })
    })
    return {
      n: n$G,
      classes: classes$z,
      yearList,
      chooseYear,
      toNumber,
    }
  },
})
function _extends$6() {
  _extends$6 =
    Object.assign ||
    function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i]
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key]
          }
        }
      }
      return target
    }
  return _extends$6.apply(this, arguments)
}
dayjs.extend(isSameOrBefore)
dayjs.extend(isSameOrAfter)
var { n: n$F, classes: classes$y } = createNamespace('day-picker')
var { n: nDate } = createNamespace('date-picker')
function render$C(_ctx, _cache2) {
  var _component_panel_header = resolveComponent('panel-header')
  var _component_var_button = resolveComponent('var-button')
  return (
    openBlock(),
    createElementBlock(
      'div',
      {
        class: normalizeClass(_ctx.n()),
      },
      [
        createElementVNode(
          'div',
          {
            class: normalizeClass(_ctx.n('content')),
          },
          [
            createVNode(
              _component_panel_header,
              {
                ref: 'headerEl',
                type: 'day',
                date: _ctx.preview,
                disabled: _ctx.panelBtnDisabled,
                onCheckPanel: _ctx.clickMonth,
                onCheckDate: _ctx.checkDate,
              },
              null,
              8,
              ['date', 'disabled', 'onCheckPanel', 'onCheckDate']
            ),
            createVNode(
              Transition,
              {
                name: '' + _ctx.nDate() + (_ctx.reverse ? '-reverse' : '') + '-translatex',
              },
              {
                default: withCtx(() => [
                  (openBlock(),
                  createElementBlock(
                    'div',
                    {
                      key: _ctx.panelKey,
                    },
                    [
                      createElementVNode(
                        'ul',
                        {
                          class: normalizeClass(_ctx.n('head')),
                        },
                        [
                          (openBlock(true),
                          createElementBlock(
                            Fragment,
                            null,
                            renderList(_ctx.sortWeekList, (week) => {
                              return (
                                openBlock(),
                                createElementBlock(
                                  'li',
                                  {
                                    key: week.index,
                                  },
                                  toDisplayString(_ctx.getDayAbbr(week.index)),
                                  1
                                )
                              )
                            }),
                            128
                          )),
                        ],
                        2
                      ),
                      createElementVNode(
                        'ul',
                        {
                          class: normalizeClass(_ctx.n('body')),
                        },
                        [
                          (openBlock(true),
                          createElementBlock(
                            Fragment,
                            null,
                            renderList(_ctx.days, (day, index2) => {
                              return (
                                openBlock(),
                                createElementBlock(
                                  'li',
                                  {
                                    key: index2,
                                  },
                                  [
                                    createVNode(
                                      _component_var_button,
                                      mergeProps(
                                        {
                                          type: 'primary',
                                          'var-day-picker-cover': '',
                                          round: '',
                                          ripple: false,
                                        },
                                        _extends$6({}, _ctx.buttonProps(day)),
                                        {
                                          onClick: (event) => _ctx.chooseDay(day, event),
                                        }
                                      ),
                                      {
                                        default: withCtx(() => [
                                          createTextVNode(toDisplayString(_ctx.filterDay(day)), 1),
                                        ]),
                                        _: 2,
                                      },
                                      1040,
                                      ['onClick']
                                    ),
                                  ]
                                )
                              )
                            }),
                            128
                          )),
                        ],
                        2
                      ),
                    ]
                  )),
                ]),
                _: 1,
              },
              8,
              ['name']
            ),
          ],
          2
        ),
      ],
      2
    )
  )
}
var DayPickerPanel = defineComponent({
  render: render$C,
  name: 'DayPickerPanel',
  components: {
    VarButton: Button,
    PanelHeader,
  },
  props: {
    choose: {
      type: Object,
      required: true,
    },
    preview: {
      type: Object,
      required: true,
    },
    current: {
      type: String,
      required: true,
    },
    clickMonth: {
      type: Function,
      required: true,
    },
    componentProps: {
      type: Object,
      required: true,
    },
  },
  emits: ['check-preview', 'choose-day'],
  setup(props2, _ref) {
    var { emit } = _ref
    var [currentYear, currentMonth, currentDay] = props2.current.split('-')
    var days = ref([])
    var reverse = ref(false)
    var panelKey = ref(0)
    var headerEl = ref(null)
    var panelBtnDisabled = reactive({
      left: false,
      right: false,
    })
    var isCurrent = computed(
      () => props2.preview.previewYear === currentYear && props2.preview.previewMonth.index === currentMonth
    )
    var isSame = computed(() => {
      var _props$choose$chooseM
      return (
        props2.choose.chooseYear === props2.preview.previewYear &&
        ((_props$choose$chooseM = props2.choose.chooseMonth) == null ? void 0 : _props$choose$chooseM.index) ===
          props2.preview.previewMonth.index
      )
    })
    var sortWeekList = computed(() => {
      var index2 = WEEK_HEADER.findIndex((week) => week.index === props2.componentProps.firstDayOfWeek)
      if (index2 === -1 || index2 === 0) return WEEK_HEADER
      return WEEK_HEADER.slice(index2).concat(WEEK_HEADER.slice(0, index2))
    })
    var getDayAbbr = (key) => {
      var _pack$value$datePicke, _pack$value$datePicke2
      return (_pack$value$datePicke =
        (_pack$value$datePicke2 = pack.value.datePickerWeekDict) == null ? void 0 : _pack$value$datePicke2[key].abbr) !=
        null
        ? _pack$value$datePicke
        : ''
    }
    var filterDay = (day) => (day > 0 ? day : '')
    var initDate = () => {
      var {
        preview: { previewMonth, previewYear },
      } = props2
      var monthNum = dayjs(previewYear + '-' + previewMonth.index).daysInMonth()
      var firstDayToWeek = dayjs(previewYear + '-' + previewMonth.index + '-01').day()
      var index2 = sortWeekList.value.findIndex((week) => week.index === '' + firstDayToWeek)
      days.value = [...Array(index2).fill(-1), ...Array.from(Array(monthNum + 1).keys())].filter((value) => value)
    }
    var initHeader = () => {
      var {
        preview: { previewYear, previewMonth },
        componentProps: { max: max2, min: min2 },
      } = props2
      if (max2) {
        var date = previewYear + '-' + (toNumber(previewMonth.index) + 1)
        panelBtnDisabled.right = !dayjs(date).isSameOrBefore(dayjs(max2), 'month')
      }
      if (min2) {
        var _date = previewYear + '-' + (toNumber(previewMonth.index) - 1)
        panelBtnDisabled.left = !dayjs(_date).isSameOrAfter(dayjs(min2), 'month')
      }
    }
    var inRange = (day) => {
      var {
        preview: { previewYear, previewMonth },
        componentProps: { min: min2, max: max2 },
      } = props2
      var isBeforeMax = true
      var isAfterMin = true
      var previewDate = previewYear + '-' + previewMonth.index + '-' + day
      if (max2) isBeforeMax = dayjs(previewDate).isSameOrBefore(dayjs(max2), 'day')
      if (min2) isAfterMin = dayjs(previewDate).isSameOrAfter(dayjs(min2), 'day')
      return isBeforeMax && isAfterMin
    }
    var shouldChoose = (val) => {
      var {
        choose: { chooseDays, chooseRangeDay },
        componentProps: { range },
      } = props2
      if (range) {
        if (!chooseRangeDay.length) return false
        var isBeforeMax = dayjs(val).isSameOrBefore(dayjs(chooseRangeDay[1]), 'day')
        var isAfterMin = dayjs(val).isSameOrAfter(dayjs(chooseRangeDay[0]), 'day')
        return isBeforeMax && isAfterMin
      }
      return chooseDays.includes(val)
    }
    var buttonProps = (day) => {
      if (day < 0) {
        return {
          text: true,
          outline: false,
          textColor: '',
          class: n$F('button'),
        }
      }
      var {
        choose: { chooseDay: chooseDay2 },
        preview: { previewYear, previewMonth },
        componentProps: { allowedDates, color, multiple, range },
      } = props2
      var val = previewYear + '-' + previewMonth.index + '-' + day
      var dayExist = () => {
        if (range || multiple) return shouldChoose(val)
        return toNumber(chooseDay2) === day && isSame.value
      }
      var computeDisabled = () => {
        if (!inRange(day)) return true
        if (!allowedDates) return false
        return !allowedDates(val)
      }
      var disabled = computeDisabled()
      var computeText = () => {
        if (disabled) return true
        if (range || multiple) return !shouldChoose(val)
        return !isSame.value || toNumber(chooseDay2) !== day
      }
      var computeOutline = () => {
        if (!(isCurrent.value && toNumber(currentDay) === day && props2.componentProps.showCurrent)) return false
        if ((range || multiple || isSame.value) && disabled) return true
        if (range || multiple) return !shouldChoose(val)
        if (isSame.value) return chooseDay2 !== currentDay
        return true
      }
      var textColorOrCover = () => {
        if (disabled) return ''
        if (computeOutline()) return color != null ? color : ''
        if (dayExist()) return ''
        return nDate() + '-color-cover'
      }
      var isCover = textColorOrCover().startsWith(nDate())
      return {
        text: computeText(),
        outline: computeOutline(),
        textColor: isCover ? '' : textColorOrCover(),
        [nDate() + '-color-cover']: isCover,
        class: classes$y(n$F('button'), n$F('button--usable'), [disabled, n$F('button--disabled')]),
      }
    }
    var checkDate = (checkType) => {
      reverse.value = checkType === 'prev'
      panelKey.value += checkType === 'prev' ? -1 : 1
      emit('check-preview', 'month', checkType)
    }
    var chooseDay = (day, event) => {
      var buttonEl = event.currentTarget
      if (buttonEl.classList.contains(n$F('button--disabled'))) return
      emit('choose-day', day)
    }
    var forwardRef = (checkType) => {
      headerEl.value.checkDate(checkType)
    }
    onMounted(() => {
      initDate()
      initHeader()
    })
    watch(
      () => props2.preview,
      () => {
        initDate()
        initHeader()
      }
    )
    return {
      n: n$F,
      nDate,
      days,
      reverse,
      headerEl,
      panelKey,
      sortWeekList,
      panelBtnDisabled,
      forwardRef,
      filterDay,
      getDayAbbr,
      checkDate,
      chooseDay,
      buttonProps,
    }
  },
})
var { n: n$E, classes: classes$x } = createNamespace('date-picker')
function render$B(_ctx, _cache2) {
  var _component_year_picker_panel = resolveComponent('year-picker-panel')
  var _component_month_picker_panel = resolveComponent('month-picker-panel')
  var _component_day_picker_panel = resolveComponent('day-picker-panel')
  return (
    openBlock(),
    createElementBlock(
      'div',
      {
        class: normalizeClass(_ctx.classes(_ctx.n(), [_ctx.shadow, 'var-elevation--2'])),
      },
      [
        createElementVNode(
          'div',
          {
            class: normalizeClass(_ctx.n('title')),
            style: normalizeStyle({
              background: _ctx.headerColor || _ctx.color,
            }),
          },
          [
            createElementVNode(
              'div',
              {
                class: normalizeClass(
                  _ctx.classes(_ctx.n('title-year'), [_ctx.isYearPanel, _ctx.n('title-year--active')])
                ),
                onClick: _cache2[0] || (_cache2[0] = ($event) => _ctx.clickEl('year')),
              },
              [
                renderSlot(
                  _ctx.$slots,
                  'year',
                  {
                    year: _ctx.previewYear,
                  },
                  () => [createTextVNode(toDisplayString(_ctx.previewYear), 1)]
                ),
              ],
              2
            ),
            createElementVNode(
              'div',
              {
                class: normalizeClass(
                  _ctx.classes(
                    _ctx.n('title-date'),
                    [!_ctx.isYearPanel, _ctx.n('title-date--active')],
                    [_ctx.range, _ctx.n('title-date--range')]
                  )
                ),
                onClick: _cache2[1] || (_cache2[1] = ($event) => _ctx.clickEl('date')),
              },
              [
                createVNode(
                  Transition,
                  {
                    name: _ctx.multiple ? '' : '' + _ctx.n() + (_ctx.reverse ? '-reverse' : '') + '-translatey',
                  },
                  {
                    default: withCtx(() => {
                      var _ctx$chooseMonth, _ctx$chooseMonth2, _ctx$chooseMonth3
                      return [
                        _ctx.type === 'month'
                          ? (openBlock(),
                            createElementBlock(
                              'div',
                              {
                                key:
                                  '' +
                                  _ctx.chooseYear +
                                  ((_ctx$chooseMonth = _ctx.chooseMonth) == null ? void 0 : _ctx$chooseMonth.index),
                              },
                              [
                                _ctx.range
                                  ? renderSlot(
                                      _ctx.$slots,
                                      'range',
                                      {
                                        key: 0,
                                        choose: _ctx.getChoose.chooseRangeMonth,
                                      },
                                      () => [createTextVNode(toDisplayString(_ctx.getMonthTitle), 1)]
                                    )
                                  : _ctx.multiple
                                  ? renderSlot(
                                      _ctx.$slots,
                                      'multiple',
                                      {
                                        key: 1,
                                        choose: _ctx.getChoose.chooseMonths,
                                      },
                                      () => [createTextVNode(toDisplayString(_ctx.getMonthTitle), 1)]
                                    )
                                  : renderSlot(
                                      _ctx.$slots,
                                      'month',
                                      {
                                        key: 2,
                                        month:
                                          (_ctx$chooseMonth2 = _ctx.chooseMonth) == null
                                            ? void 0
                                            : _ctx$chooseMonth2.index,
                                        year: _ctx.chooseYear,
                                      },
                                      () => [createTextVNode(toDisplayString(_ctx.getMonthTitle), 1)]
                                    ),
                              ]
                            ))
                          : (openBlock(),
                            createElementBlock(
                              'div',
                              {
                                key:
                                  '' +
                                  _ctx.chooseYear +
                                  ((_ctx$chooseMonth3 = _ctx.chooseMonth) == null ? void 0 : _ctx$chooseMonth3.index) +
                                  _ctx.chooseDay,
                              },
                              [
                                _ctx.range
                                  ? renderSlot(
                                      _ctx.$slots,
                                      'range',
                                      {
                                        key: 0,
                                        choose: _ctx.formatRange,
                                      },
                                      () => [createTextVNode(toDisplayString(_ctx.getDateTitle), 1)]
                                    )
                                  : _ctx.multiple
                                  ? renderSlot(
                                      _ctx.$slots,
                                      'multiple',
                                      {
                                        key: 1,
                                        choose: _ctx.getChoose.chooseDays,
                                      },
                                      () => [createTextVNode(toDisplayString(_ctx.getDateTitle), 1)]
                                    )
                                  : renderSlot(
                                      _ctx.$slots,
                                      'date',
                                      normalizeProps(
                                        mergeProps(
                                          {
                                            key: 2,
                                          },
                                          _ctx.slotProps
                                        )
                                      ),
                                      () => [createTextVNode(toDisplayString(_ctx.getDateTitle), 1)]
                                    ),
                              ]
                            )),
                      ]
                    }),
                    _: 3,
                  },
                  8,
                  ['name']
                ),
              ],
              2
            ),
          ],
          6
        ),
        createElementVNode(
          'div',
          {
            class: normalizeClass(_ctx.n('body')),
            onTouchstart:
              _cache2[2] ||
              (_cache2[2] = function () {
                return _ctx.handleTouchstart && _ctx.handleTouchstart(...arguments)
              }),
            onTouchmove:
              _cache2[3] ||
              (_cache2[3] = function () {
                return _ctx.handleTouchmove && _ctx.handleTouchmove(...arguments)
              }),
            onTouchend:
              _cache2[4] ||
              (_cache2[4] = function () {
                return _ctx.handleTouchend && _ctx.handleTouchend(...arguments)
              }),
          },
          [
            createVNode(
              Transition,
              {
                name: _ctx.n() + '-panel-fade',
              },
              {
                default: withCtx(() => [
                  _ctx.getPanelType === 'year'
                    ? (openBlock(),
                      createBlock(
                        _component_year_picker_panel,
                        {
                          key: 0,
                          'component-props': _ctx.componentProps,
                          preview: _ctx.previewYear,
                          onChooseYear: _ctx.getChooseYear,
                        },
                        null,
                        8,
                        ['component-props', 'preview', 'onChooseYear']
                      ))
                    : _ctx.getPanelType === 'month'
                    ? (openBlock(),
                      createBlock(
                        _component_month_picker_panel,
                        {
                          key: 1,
                          ref: 'monthPanelEl',
                          current: _ctx.currentDate,
                          choose: _ctx.getChoose,
                          preview: _ctx.getPreview,
                          'click-year': () => _ctx.clickEl('year'),
                          'component-props': _ctx.componentProps,
                          onChooseMonth: _ctx.getChooseMonth,
                          onCheckPreview: _ctx.checkPreview,
                        },
                        null,
                        8,
                        [
                          'current',
                          'choose',
                          'preview',
                          'click-year',
                          'component-props',
                          'onChooseMonth',
                          'onCheckPreview',
                        ]
                      ))
                    : _ctx.getPanelType === 'date'
                    ? (openBlock(),
                      createBlock(
                        _component_day_picker_panel,
                        {
                          key: 2,
                          ref: 'dayPanelEl',
                          current: _ctx.currentDate,
                          choose: _ctx.getChoose,
                          preview: _ctx.getPreview,
                          'component-props': _ctx.componentProps,
                          'click-month': () => _ctx.clickEl('month'),
                          onChooseDay: _ctx.getChooseDay,
                          onCheckPreview: _ctx.checkPreview,
                        },
                        null,
                        8,
                        [
                          'current',
                          'choose',
                          'preview',
                          'component-props',
                          'click-month',
                          'onChooseDay',
                          'onCheckPreview',
                        ]
                      ))
                    : createCommentVNode('v-if', true),
                ]),
                _: 1,
              },
              8,
              ['name']
            ),
          ],
          34
        ),
      ],
      2
    )
  )
}
var DatePicker = defineComponent({
  render: render$B,
  name: 'VarDatePicker',
  components: {
    MonthPickerPanel,
    YearPickerPanel,
    DayPickerPanel,
  },
  props: props$z,
  setup(props2) {
    var startX = 0
    var startY = 0
    var checkType = ''
    var touchDirection
    var currentDate = dayjs().format('YYYY-MM-D')
    var [currentYear, currentMonth] = currentDate.split('-')
    var monthDes = MONTH_LIST.find((month) => month.index === currentMonth)
    var isYearPanel = ref(false)
    var isMonthPanel = ref(false)
    var rangeDone = ref(true)
    var chooseMonth = ref()
    var chooseYear = ref()
    var chooseDay = ref()
    var previewMonth = ref(monthDes)
    var previewYear = ref(currentYear)
    var reverse = ref(false)
    var chooseMonths = ref([])
    var chooseDays = ref([])
    var chooseRangeMonth = ref([])
    var chooseRangeDay = ref([])
    var monthPanelEl = ref(null)
    var dayPanelEl = ref(null)
    var componentProps = reactive({
      allowedDates: props2.allowedDates,
      type: props2.type,
      color: props2.color,
      firstDayOfWeek: props2.firstDayOfWeek,
      min: props2.min,
      max: props2.max,
      showCurrent: props2.showCurrent,
      multiple: props2.multiple,
      range: props2.range,
    })
    var getChoose = computed(() => ({
      chooseMonth: chooseMonth.value,
      chooseYear: chooseYear.value,
      chooseDay: chooseDay.value,
      chooseMonths: chooseMonths.value,
      chooseDays: chooseDays.value,
      chooseRangeMonth: chooseRangeMonth.value,
      chooseRangeDay: chooseRangeDay.value,
    }))
    var getPreview = computed(() => ({
      previewMonth: previewMonth.value,
      previewYear: previewYear.value,
    }))
    var getMonthTitle = computed(() => {
      var { multiple, range } = props2
      if (range) {
        return chooseRangeMonth.value.length ? chooseRangeMonth.value[0] + ' ~ ' + chooseRangeMonth.value[1] : ''
      }
      var monthName = ''
      if (chooseMonth.value) {
        var _pack$value$datePicke, _pack$value$datePicke2
        monthName =
          (_pack$value$datePicke =
            (_pack$value$datePicke2 = pack.value.datePickerMonthDict) == null
              ? void 0
              : _pack$value$datePicke2[chooseMonth.value.index].name) != null
            ? _pack$value$datePicke
            : ''
      }
      return multiple ? '' + chooseMonths.value.length + pack.value.datePickerSelected : monthName
    })
    var getDateTitle = computed(() => {
      var _pack$value$datePicke3, _pack$value$datePicke4, _pack$value$datePicke5, _pack$value$datePicke6
      var { multiple, range } = props2
      if (range) {
        var formatRangeDays = chooseRangeDay.value.map((date) => dayjs(date).format('YYYY-MM-DD'))
        return formatRangeDays.length ? formatRangeDays[0] + ' ~ ' + formatRangeDays[1] : ''
      }
      if (multiple) return '' + chooseDays.value.length + pack.value.datePickerSelected
      if (!chooseYear.value || !chooseMonth.value || !chooseDay.value) return ''
      var weekIndex = dayjs(chooseYear.value + '-' + chooseMonth.value.index + '-' + chooseDay.value).day()
      var week = WEEK_HEADER.find((value) => value.index === '' + weekIndex)
      var weekName =
        (_pack$value$datePicke3 =
          (_pack$value$datePicke4 = pack.value.datePickerWeekDict) == null
            ? void 0
            : _pack$value$datePicke4[week.index].name) != null
          ? _pack$value$datePicke3
          : ''
      var monthName =
        (_pack$value$datePicke5 =
          (_pack$value$datePicke6 = pack.value.datePickerMonthDict) == null
            ? void 0
            : _pack$value$datePicke6[chooseMonth.value.index].name) != null
          ? _pack$value$datePicke5
          : ''
      var showDay = chooseDay.value.padStart(2, '0')
      if (pack.value.lang === 'zh-CN') return chooseMonth.value.index + '-' + showDay + ' ' + weekName.slice(0, 3)
      return weekName.slice(0, 3) + ', ' + monthName.slice(0, 3) + ' ' + chooseDay.value
    })
    var getPanelType = computed(() => {
      if (isYearPanel.value) return 'year'
      if (props2.type === 'month' || isMonthPanel.value) return 'month'
      if (props2.type === 'date') return 'date'
      return ''
    })
    var isUntouchable = computed(() => {
      return !props2.touchable || ['', 'year'].includes(getPanelType.value)
    })
    var slotProps = computed(() => {
      var _chooseMonth$value, _chooseDay$value, _chooseYear$value, _chooseMonth$value$in, _chooseMonth$value2
      var weekIndex = dayjs(
        chooseYear.value +
          '-' +
          ((_chooseMonth$value = chooseMonth.value) == null ? void 0 : _chooseMonth$value.index) +
          '-' +
          chooseDay.value
      ).day()
      var date = chooseDay.value
        ? (_chooseDay$value = chooseDay.value) == null
          ? void 0
          : _chooseDay$value.padStart(2, '0')
        : ''
      return {
        week: '' + weekIndex,
        year: (_chooseYear$value = chooseYear.value) != null ? _chooseYear$value : '',
        month:
          (_chooseMonth$value$in =
            (_chooseMonth$value2 = chooseMonth.value) == null ? void 0 : _chooseMonth$value2.index) != null
            ? _chooseMonth$value$in
            : '',
        date,
      }
    })
    var formatRange = computed(() => getChoose.value.chooseRangeDay.map((choose) => dayjs(choose).format('YYYY-MM-DD')))
    var isSameYear = computed(() => chooseYear.value === previewYear.value)
    var isSameMonth = computed(() => {
      var _chooseMonth$value3
      return (
        ((_chooseMonth$value3 = chooseMonth.value) == null ? void 0 : _chooseMonth$value3.index) ===
        previewMonth.value.index
      )
    })
    var clickEl = (type) => {
      if (type === 'year') isYearPanel.value = true
      else if (type === 'month') isMonthPanel.value = true
      else {
        isYearPanel.value = false
        isMonthPanel.value = false
      }
    }
    var handleTouchstart = (event) => {
      if (isUntouchable.value) return
      var { clientX, clientY } = event.touches[0]
      startX = clientX
      startY = clientY
    }
    var getDirection = (x, y2) => {
      return x >= y2 && x > 20 ? 'x' : 'y'
    }
    var handleTouchmove = (event) => {
      if (isUntouchable.value) return
      var { clientX, clientY } = event.touches[0]
      var x = clientX - startX
      var y2 = clientY - startY
      touchDirection = getDirection(Math.abs(x), Math.abs(y2))
      checkType = x > 0 ? 'prev' : 'next'
    }
    var handleTouchend = () => {
      if (isUntouchable.value || touchDirection !== 'x') return
      var componentRef = getPanelType.value === 'month' ? monthPanelEl : dayPanelEl
      nextTickFrame(() => {
        componentRef.value.forwardRef(checkType)
        resetState()
      })
    }
    var updateRange = (date, type) => {
      var rangeDate = type === 'month' ? chooseRangeMonth : chooseRangeDay
      rangeDate.value = rangeDone.value ? [date, date] : [rangeDate.value[0], date]
      rangeDone.value = !rangeDone.value
      if (rangeDone.value) {
        var isChangeOrder = dayjs(rangeDate.value[0]).isAfter(rangeDate.value[1])
        var _date = isChangeOrder ? [rangeDate.value[1], rangeDate.value[0]] : [...rangeDate.value]
        call(props2['onUpdate:modelValue'], _date)
        call(props2.onChange, _date)
      }
    }
    var updateMultiple = (date, type) => {
      var multipleDates = type === 'month' ? chooseMonths : chooseDays
      var formatType = type === 'month' ? 'YYYY-MM' : 'YYYY-MM-DD'
      var formatDates = multipleDates.value.map((date2) => dayjs(date2).format(formatType))
      var index2 = formatDates.findIndex((choose) => choose === date)
      if (index2 === -1) formatDates.push(date)
      else formatDates.splice(index2, 1)
      call(props2['onUpdate:modelValue'], formatDates)
      call(props2.onChange, formatDates)
    }
    var getReverse = (dateType, date) => {
      if (!chooseYear.value || !chooseMonth.value) return false
      if (!isSameYear.value) return chooseYear.value > previewYear.value
      if (dateType === 'month') return date.index < chooseMonth.value.index
      return isSameMonth.value ? date < toNumber(chooseDay.value) : chooseMonth.value.index > previewMonth.value.index
    }
    var getChooseDay = (day) => {
      var { readonly, range, multiple, onChange, 'onUpdate:modelValue': updateModelValue } = props2
      if (day < 0 || readonly) return
      reverse.value = getReverse('day', day)
      var date = previewYear.value + '-' + previewMonth.value.index + '-' + day
      var formatDate = dayjs(date).format('YYYY-MM-DD')
      if (range) updateRange(formatDate, 'day')
      else if (multiple) updateMultiple(formatDate, 'day')
      else {
        call(updateModelValue, formatDate)
        call(onChange, formatDate)
      }
    }
    var getChooseMonth = (month) => {
      var { type, readonly, range, multiple, onChange, 'onUpdate:modelValue': updateModelValue } = props2
      reverse.value = getReverse('month', month)
      if (type === 'month' && !readonly) {
        var date = previewYear.value + '-' + month.index
        if (range) updateRange(date, 'month')
        else if (multiple) updateMultiple(date, 'month')
        else {
          call(updateModelValue, date)
          call(onChange, date)
        }
      } else {
        previewMonth.value = month
      }
      isMonthPanel.value = false
    }
    var getChooseYear = (year) => {
      previewYear.value = '' + year
      isYearPanel.value = false
      isMonthPanel.value = true
    }
    var checkPreview = (type, checkType2) => {
      var changeValue = checkType2 === 'prev' ? -1 : 1
      if (type === 'year') {
        previewYear.value = '' + (toNumber(previewYear.value) + changeValue)
      } else {
        var checkIndex = toNumber(previewMonth.value.index) + changeValue
        if (checkIndex < 1) {
          previewYear.value = '' + (toNumber(previewYear.value) - 1)
          checkIndex = 12
        }
        if (checkIndex > 12) {
          previewYear.value = '' + (toNumber(previewYear.value) + 1)
          checkIndex = 1
        }
        previewMonth.value = MONTH_LIST.find((month) => toNumber(month.index) === checkIndex)
      }
    }
    var checkValue = () => {
      if ((props2.multiple || props2.range) && !isArray$1(props2.modelValue)) {
        console.error('[Varlet] DatePicker: type of prop "modelValue" should be an Array')
        return false
      }
      if (!props2.multiple && !props2.range && isArray$1(props2.modelValue)) {
        console.error('[Varlet] DatePicker: type of prop "modelValue" should be a String')
        return false
      }
      return true
    }
    var invalidFormatDate = (date) => {
      if (isArray$1(date)) return false
      if (date === 'Invalid Date') {
        console.error('[Varlet] DatePicker: "modelValue" is an Invalid Date')
        return true
      }
      return false
    }
    var rangeInit = (value, type) => {
      var rangeDate = type === 'month' ? chooseRangeMonth : chooseRangeDay
      var formatType = type === 'month' ? 'YYYY-MM' : 'YYYY-MM-D'
      var formatDateList = value.map((choose) => dayjs(choose).format(formatType)).slice(0, 2)
      var isValid = rangeDate.value.some((date) => invalidFormatDate(date))
      if (isValid) return
      rangeDate.value = formatDateList
      var isChangeOrder = dayjs(rangeDate.value[0]).isAfter(rangeDate.value[1])
      if (rangeDate.value.length === 2 && isChangeOrder) {
        rangeDate.value = [rangeDate.value[1], rangeDate.value[0]]
      }
    }
    var multipleInit = (value, type) => {
      var rangeDate = type === 'month' ? chooseMonths : chooseDays
      var formatType = type === 'month' ? 'YYYY-MM' : 'YYYY-MM-D'
      var formatDateList = Array.from(new Set(value.map((choose) => dayjs(choose).format(formatType))))
      rangeDate.value = formatDateList.filter((date) => date !== 'Invalid Date')
    }
    var dateInit = (value) => {
      var formatDate = dayjs(value).format('YYYY-MM-D')
      if (invalidFormatDate(formatDate)) return
      var [yearValue, monthValue, dayValue] = formatDate.split('-')
      var monthDes2 = MONTH_LIST.find((month) => month.index === monthValue)
      chooseMonth.value = monthDes2
      chooseYear.value = yearValue
      chooseDay.value = dayValue
      previewMonth.value = monthDes2
      previewYear.value = yearValue
    }
    var resetState = () => {
      startY = 0
      startX = 0
      checkType = ''
      touchDirection = void 0
    }
    watch(
      () => props2.modelValue,
      (value) => {
        if (!checkValue() || invalidFormatDate(value) || !value) return
        if (props2.range) {
          if (!isArray$1(value)) return
          rangeDone.value = value.length !== 1
          rangeInit(value, props2.type)
        } else if (props2.multiple) {
          if (!isArray$1(value)) return
          multipleInit(value, props2.type)
        } else {
          dateInit(value)
        }
      },
      {
        immediate: true,
      }
    )
    watch(getPanelType, resetState)
    return {
      n: n$E,
      classes: classes$x,
      monthPanelEl,
      dayPanelEl,
      reverse,
      currentDate,
      chooseMonth,
      chooseYear,
      chooseDay,
      previewYear,
      isYearPanel,
      isMonthPanel,
      getMonthTitle,
      getDateTitle,
      getPanelType,
      getChoose,
      getPreview,
      componentProps,
      slotProps,
      formatRange,
      clickEl,
      handleTouchstart,
      handleTouchmove,
      handleTouchend,
      getChooseDay,
      getChooseMonth,
      getChooseYear,
      checkPreview,
    }
  },
})
DatePicker.install = function (app) {
  app.component(DatePicker.name, DatePicker)
}
function _extends$5() {
  _extends$5 =
    Object.assign ||
    function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i]
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key]
          }
        }
      }
      return target
    }
  return _extends$5.apply(this, arguments)
}
function messageAlignValidator(messageAlign) {
  return ['left', 'center', 'right'].includes(messageAlign)
}
var props$y = _extends$5(
  {
    show: {
      type: Boolean,
      default: false,
    },
    title: {
      type: String,
    },
    message: {
      type: String,
    },
    messageAlign: {
      type: String,
      default: 'left',
      validator: messageAlignValidator,
    },
    confirmButton: {
      type: Boolean,
      default: true,
    },
    cancelButton: {
      type: Boolean,
      default: true,
    },
    confirmButtonText: {
      type: String,
    },
    cancelButtonText: {
      type: String,
    },
    confirmButtonTextColor: {
      type: String,
    },
    cancelButtonTextColor: {
      type: String,
    },
    confirmButtonColor: {
      type: String,
    },
    cancelButtonColor: {
      type: String,
    },
    onBeforeClose: {
      type: Function,
    },
    onConfirm: {
      type: Function,
    },
    onCancel: {
      type: Function,
    },
    'onUpdate:show': {
      type: Function,
    },
    dialogClass: {
      type: String,
    },
    dialogStyle: {
      type: Object,
    },
  },
  pickProps(props$U, [
    'overlay',
    'overlayClass',
    'overlayStyle',
    'lockScroll',
    'closeOnClickOverlay',
    'teleport',
    'onOpen',
    'onClose',
    'onOpened',
    'onClosed',
    'onClickOverlay',
    'onRouteChange',
  ])
)
var { n: n$D, classes: classes$w } = createNamespace('dialog')
function render$A(_ctx, _cache2) {
  var _component_var_button = resolveComponent('var-button')
  var _component_var_popup = resolveComponent('var-popup')
  return (
    openBlock(),
    createBlock(
      _component_var_popup,
      {
        class: normalizeClass(_ctx.n('popup')),
        'var-dialog-cover': '',
        show: _ctx.popupShow,
        overlay: _ctx.overlay,
        'overlay-class': _ctx.overlayClass,
        'overlay-style': _ctx.overlayStyle,
        'lock-scroll': _ctx.lockScroll,
        'close-on-click-overlay': _ctx.popupCloseOnClickOverlay,
        teleport: _ctx.teleport,
        onOpen: _ctx.onOpen,
        onClose: _ctx.onClose,
        onClosed: _ctx.onClosed,
        onOpened: _ctx.onOpened,
        onRouteChange: _ctx.onRouteChange,
        onClickOverlay: _ctx.handleClickOverlay,
      },
      {
        default: withCtx(() => [
          createElementVNode(
            'div',
            mergeProps(
              {
                class: _ctx.classes('var--box', _ctx.n(), _ctx.dialogClass),
                style: _ctx.dialogStyle,
              },
              _ctx.$attrs
            ),
            [
              createElementVNode(
                'div',
                {
                  class: normalizeClass(_ctx.n('title')),
                },
                [
                  renderSlot(_ctx.$slots, 'title', {}, () => [
                    createTextVNode(toDisplayString(_ctx.dt(_ctx.title, _ctx.pack.dialogTitle)), 1),
                  ]),
                ],
                2
              ),
              createElementVNode(
                'div',
                {
                  class: normalizeClass(_ctx.n('message')),
                  style: normalizeStyle({
                    textAlign: _ctx.messageAlign,
                  }),
                },
                [renderSlot(_ctx.$slots, 'default', {}, () => [createTextVNode(toDisplayString(_ctx.message), 1)])],
                6
              ),
              createElementVNode(
                'div',
                {
                  class: normalizeClass(_ctx.n('actions')),
                },
                [
                  _ctx.cancelButton
                    ? (openBlock(),
                      createBlock(
                        _component_var_button,
                        {
                          key: 0,
                          class: normalizeClass(_ctx.classes(_ctx.n('button'), _ctx.n('cancel-button'))),
                          'var-dialog-cover': '',
                          text: '',
                          'text-color': _ctx.cancelButtonTextColor,
                          color: _ctx.cancelButtonColor,
                          onClick: _ctx.cancel,
                        },
                        {
                          default: withCtx(() => [
                            createTextVNode(
                              toDisplayString(_ctx.dt(_ctx.cancelButtonText, _ctx.pack.dialogCancelButtonText)),
                              1
                            ),
                          ]),
                          _: 1,
                        },
                        8,
                        ['class', 'text-color', 'color', 'onClick']
                      ))
                    : createCommentVNode('v-if', true),
                  _ctx.confirmButton
                    ? (openBlock(),
                      createBlock(
                        _component_var_button,
                        {
                          key: 1,
                          class: normalizeClass(_ctx.classes(_ctx.n('button'), _ctx.n('confirm-button'))),
                          'var-dialog-cover': '',
                          text: '',
                          'text-color': _ctx.confirmButtonTextColor,
                          color: _ctx.confirmButtonColor,
                          onClick: _ctx.confirm,
                        },
                        {
                          default: withCtx(() => [
                            createTextVNode(
                              toDisplayString(_ctx.dt(_ctx.confirmButtonText, _ctx.pack.dialogConfirmButtonText)),
                              1
                            ),
                          ]),
                          _: 1,
                        },
                        8,
                        ['class', 'text-color', 'color', 'onClick']
                      ))
                    : createCommentVNode('v-if', true),
                ],
                2
              ),
            ],
            16
          ),
        ]),
        _: 3,
      },
      8,
      [
        'class',
        'show',
        'overlay',
        'overlay-class',
        'overlay-style',
        'lock-scroll',
        'close-on-click-overlay',
        'teleport',
        'onOpen',
        'onClose',
        'onClosed',
        'onOpened',
        'onRouteChange',
        'onClickOverlay',
      ]
    )
  )
}
var VarDialog = defineComponent({
  render: render$A,
  name: 'VarDialog',
  components: {
    VarPopup: Popup,
    VarButton: Button,
  },
  inheritAttrs: false,
  props: props$y,
  setup(props2) {
    var popupShow = ref(false)
    var popupCloseOnClickOverlay = ref(false)
    var done = () => call(props2['onUpdate:show'], false)
    var handleClickOverlay = () => {
      var { closeOnClickOverlay, onClickOverlay, onBeforeClose } = props2
      call(onClickOverlay)
      if (!closeOnClickOverlay) {
        return
      }
      if (onBeforeClose != null) {
        onBeforeClose('close', done)
        return
      }
      call(props2['onUpdate:show'], false)
    }
    var confirm = () => {
      var { onBeforeClose, onConfirm } = props2
      call(onConfirm)
      if (onBeforeClose != null) {
        onBeforeClose('confirm', done)
        return
      }
      call(props2['onUpdate:show'], false)
    }
    var cancel = () => {
      var { onBeforeClose, onCancel } = props2
      call(onCancel)
      if (onBeforeClose != null) {
        onBeforeClose('cancel', done)
        return
      }
      call(props2['onUpdate:show'], false)
    }
    watch(
      () => props2.show,
      (newValue) => {
        popupShow.value = newValue
      },
      {
        immediate: true,
      }
    )
    watch(
      () => props2.closeOnClickOverlay,
      (newValue) => {
        if (props2.onBeforeClose != null) {
          popupCloseOnClickOverlay.value = false
          return
        }
        popupCloseOnClickOverlay.value = newValue
      },
      {
        immediate: true,
      }
    )
    return {
      n: n$D,
      classes: classes$w,
      pack,
      dt,
      popupShow,
      popupCloseOnClickOverlay,
      handleClickOverlay,
      confirm,
      cancel,
    }
  },
})
VarDialog.install = function (app) {
  app.component(VarDialog.name, VarDialog)
}
var props$x = {
  inset: {
    type: [Boolean, Number, String],
    default: false,
  },
  vertical: {
    type: Boolean,
    default: false,
  },
  description: {
    type: String,
  },
  margin: {
    type: String,
  },
  dashed: {
    type: Boolean,
    default: false,
  },
}
function _extends$4() {
  _extends$4 =
    Object.assign ||
    function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i]
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key]
          }
        }
      }
      return target
    }
  return _extends$4.apply(this, arguments)
}
var { n: n$C, classes: classes$v } = createNamespace('divider')
function render$z(_ctx, _cache2) {
  return (
    openBlock(),
    createElementBlock(
      'div',
      {
        class: normalizeClass(
          _ctx.classes(
            _ctx.n(),
            'var--box',
            [_ctx.vertical, _ctx.n('--vertical')],
            [_ctx.withText, _ctx.n('--with-text')],
            [_ctx.isInset, _ctx.n('--inset')],
            [_ctx.dashed, _ctx.n('--dashed')]
          )
        ),
        style: normalizeStyle(_ctx.style),
      },
      [
        renderSlot(_ctx.$slots, 'default', {}, () => [
          _ctx.description
            ? (openBlock(),
              createElementBlock(
                'span',
                {
                  key: 0,
                  class: normalizeClass(_ctx.n('text')),
                },
                toDisplayString(_ctx.description),
                3
              ))
            : createCommentVNode('v-if', true),
        ]),
      ],
      6
    )
  )
}
var Divider = defineComponent({
  render: render$z,
  name: 'VarDivider',
  props: props$x,
  setup(props2, _ref) {
    var { slots } = _ref
    var state = reactive({
      withText: false,
    })
    var isInset = computed(() => (isBool(props2.inset) ? props2.inset : true))
    var style = computed(() => {
      var { inset, vertical, margin } = props2
      var baseStyle = {
        margin,
      }
      if (isBool(inset) || inset === 0) return _extends$4({}, baseStyle)
      var _inset = toNumber(inset)
      var absInsetWithUnit = Math.abs(_inset) + (inset + '').replace(_inset + '', '')
      return vertical
        ? _extends$4({}, baseStyle, {
            height: 'calc(80% - ' + toSizeUnit(absInsetWithUnit) + ')',
          })
        : _extends$4({}, baseStyle, {
            width: 'calc(100% - ' + toSizeUnit(absInsetWithUnit) + ')',
            left: _inset > 0 ? toSizeUnit(absInsetWithUnit) : toSizeUnit(0),
          })
    })
    var checkHasText = () => {
      state.withText = Boolean(slots.default) || Boolean(props2.description)
    }
    onMounted(() => {
      checkHasText()
    })
    onUpdated(() => {
      checkHasText()
    })
    return _extends$4(
      {
        n: n$C,
        classes: classes$v,
      },
      toRefs(state),
      {
        style,
        isInset,
      }
    )
  },
})
Divider.install = function (app) {
  app.component(Divider.name, Divider)
}
var props$w = {
  disabled: {
    type: Boolean,
    default: false,
  },
  readonly: {
    type: Boolean,
    default: false,
  },
}
function asyncGeneratorStep$9(gen, resolve2, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg)
    var value = info.value
  } catch (error) {
    reject(error)
    return
  }
  if (info.done) {
    resolve2(value)
  } else {
    Promise.resolve(value).then(_next, _throw)
  }
}
function _asyncToGenerator$9(fn) {
  return function () {
    var self2 = this,
      args = arguments
    return new Promise(function (resolve2, reject) {
      var gen = fn.apply(self2, args)
      function _next(value) {
        asyncGeneratorStep$9(gen, resolve2, reject, _next, _throw, 'next', value)
      }
      function _throw(err) {
        asyncGeneratorStep$9(gen, resolve2, reject, _next, _throw, 'throw', err)
      }
      _next(void 0)
    })
  }
}
var { n: n$B } = createNamespace('form')
function render$y(_ctx, _cache2) {
  return (
    openBlock(),
    createElementBlock(
      'div',
      {
        class: normalizeClass(_ctx.n()),
      },
      [renderSlot(_ctx.$slots, 'default')],
      2
    )
  )
}
var Form = defineComponent({
  render: render$y,
  name: 'VarForm',
  props: props$w,
  setup(props2) {
    var disabled = computed(() => props2.disabled)
    var readonly = computed(() => props2.readonly)
    var { formItems, bindFormItems } = useFormItems()
    var validate2 = /* @__PURE__ */ (function () {
      var _ref = _asyncToGenerator$9(function* () {
        var res = yield Promise.all(
          formItems.map((_ref2) => {
            var { validate: validate3 } = _ref2
            return validate3()
          })
        )
        return res.every((r) => r === true)
      })
      return function validate3() {
        return _ref.apply(this, arguments)
      }
    })()
    var reset = () =>
      formItems.forEach((_ref3) => {
        var { reset: reset2 } = _ref3
        return reset2()
      })
    var resetValidation = () =>
      formItems.forEach((_ref4) => {
        var { resetValidation: resetValidation2 } = _ref4
        return resetValidation2()
      })
    var formProvider = {
      disabled,
      readonly,
    }
    bindFormItems(formProvider)
    return {
      n: n$B,
      validate: validate2,
      reset,
      resetValidation,
    }
  },
})
Form.install = function (app) {
  app.component(Form.name, Form)
}
function asyncGeneratorStep$8(gen, resolve2, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg)
    var value = info.value
  } catch (error) {
    reject(error)
    return
  }
  if (info.done) {
    resolve2(value)
  } else {
    Promise.resolve(value).then(_next, _throw)
  }
}
function _asyncToGenerator$8(fn) {
  return function () {
    var self2 = this,
      args = arguments
    return new Promise(function (resolve2, reject) {
      var gen = fn.apply(self2, args)
      function _next(value) {
        asyncGeneratorStep$8(gen, resolve2, reject, _next, _throw, 'next', value)
      }
      function _throw(err) {
        asyncGeneratorStep$8(gen, resolve2, reject, _next, _throw, 'throw', err)
      }
      _next(void 0)
    })
  }
}
function _extends$3() {
  _extends$3 =
    Object.assign ||
    function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i]
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key]
          }
        }
      }
      return target
    }
  return _extends$3.apply(this, arguments)
}
var BACKGROUND_IMAGE_ARG_NAME = 'background-image'
var LAZY_LOADING = 'lazy-loading'
var LAZY_ERROR = 'lazy-error'
var LAZY_ATTEMPT = 'lazy-attempt'
var EVENTS = ['scroll', 'wheel', 'mousewheel', 'resize', 'animationend', 'transitionend', 'touchmove']
var PIXEL = 'data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=='
var lazyElements = []
var listenTargets = []
var imageCache = createCache(100)
var defaultLazyOptions = {
  loading: PIXEL,
  error: PIXEL,
  attempt: 3,
  throttleWait: 300,
  events: EVENTS,
}
var checkAllWithThrottle = throttle(checkAll, defaultLazyOptions.throttleWait)
function setSRC(el, src) {
  if (el._lazy.arg === BACKGROUND_IMAGE_ARG_NAME) {
    el.style.backgroundImage = 'url(' + src + ')'
  } else {
    el.setAttribute('src', src)
  }
}
function setLoading(el) {
  el._lazy.loading && setSRC(el, el._lazy.loading)
  checkAll()
}
function setError(el) {
  el._lazy.error && setSRC(el, el._lazy.error)
  el._lazy.state = 'error'
  clear(el)
  checkAll()
}
function setSuccess(el, attemptSRC) {
  setSRC(el, attemptSRC)
  el._lazy.state = 'success'
  clear(el)
  checkAll()
}
function bindEvents(listenTarget) {
  var _defaultLazyOptions$e
  if (listenTargets.includes(listenTarget)) {
    return
  }
  listenTargets.push(listenTarget)
  ;(_defaultLazyOptions$e = defaultLazyOptions.events) == null
    ? void 0
    : _defaultLazyOptions$e.forEach((event) => {
        listenTarget.addEventListener(event, checkAllWithThrottle, {
          passive: true,
        })
      })
}
function unbindEvents() {
  listenTargets.forEach((listenTarget) => {
    var _defaultLazyOptions$e2
    ;(_defaultLazyOptions$e2 = defaultLazyOptions.events) == null
      ? void 0
      : _defaultLazyOptions$e2.forEach((event) => {
          listenTarget.removeEventListener(event, checkAllWithThrottle)
        })
  })
  listenTargets.length = 0
}
function createLazy(el, binding2) {
  var _el$getAttribute, _el$getAttribute2
  var lazyOptions = {
    loading: (_el$getAttribute = el.getAttribute(LAZY_LOADING)) != null ? _el$getAttribute : defaultLazyOptions.loading,
    error: (_el$getAttribute2 = el.getAttribute(LAZY_ERROR)) != null ? _el$getAttribute2 : defaultLazyOptions.error,
    attempt: el.getAttribute(LAZY_ATTEMPT) ? Number(el.getAttribute(LAZY_ATTEMPT)) : defaultLazyOptions.attempt,
  }
  el._lazy = _extends$3(
    {
      src: binding2.value,
      arg: binding2.arg,
      currentAttempt: 0,
      state: 'pending',
      attemptLock: false,
    },
    lazyOptions
  )
  setSRC(el, PIXEL)
  call(defaultLazyOptions.filter, el._lazy)
}
function createImage(el, attemptSRC) {
  var image = new Image()
  image.src = attemptSRC
  el._lazy.preloadImage = image
  image.addEventListener('load', () => {
    el._lazy.attemptLock = false
    imageCache.add(attemptSRC)
    setSuccess(el, attemptSRC)
  })
  image.addEventListener('error', () => {
    el._lazy.attemptLock = false
    el._lazy.currentAttempt >= el._lazy.attempt ? setError(el) : attemptLoad(el)
  })
}
function attemptLoad(el) {
  if (el._lazy.attemptLock) {
    return
  }
  el._lazy.attemptLock = true
  el._lazy.currentAttempt++
  var { src: attemptSRC } = el._lazy
  if (imageCache.has(attemptSRC)) {
    setSuccess(el, attemptSRC)
    el._lazy.attemptLock = false
    return
  }
  setLoading(el)
  createImage(el, attemptSRC)
}
function check(_x) {
  return _check.apply(this, arguments)
}
function _check() {
  _check = _asyncToGenerator$8(function* (el) {
    ;(yield inViewport(el)) && attemptLoad(el)
  })
  return _check.apply(this, arguments)
}
function checkAll() {
  lazyElements.forEach((el) => check(el))
}
function add(_x2) {
  return _add.apply(this, arguments)
}
function _add() {
  _add = _asyncToGenerator$8(function* (el) {
    !lazyElements.includes(el) && lazyElements.push(el)
    getAllParentScroller(el).forEach(bindEvents)
    yield check(el)
  })
  return _add.apply(this, arguments)
}
function clear(el) {
  removeItem(lazyElements, el)
  lazyElements.length === 0 && unbindEvents()
}
function diff(el, binding2) {
  var { src, arg } = el._lazy
  return src !== binding2.value || arg !== binding2.arg
}
function mounted(_x3, _x4) {
  return _mounted.apply(this, arguments)
}
function _mounted() {
  _mounted = _asyncToGenerator$8(function* (el, binding2) {
    createLazy(el, binding2)
    yield add(el)
  })
  return _mounted.apply(this, arguments)
}
function updated(_x5, _x6) {
  return _updated.apply(this, arguments)
}
function _updated() {
  _updated = _asyncToGenerator$8(function* (el, binding2) {
    if (!diff(el, binding2)) {
      lazyElements.includes(el) && (yield check(el))
      return
    }
    yield mounted(el, binding2)
  })
  return _updated.apply(this, arguments)
}
function mergeLazyOptions(lazyOptions) {
  if (lazyOptions === void 0) {
    lazyOptions = {}
  }
  var { events, loading: loading2, error, attempt, throttleWait, filter } = lazyOptions
  defaultLazyOptions.events = events != null ? events : defaultLazyOptions.events
  defaultLazyOptions.loading = loading2 != null ? loading2 : defaultLazyOptions.loading
  defaultLazyOptions.error = error != null ? error : defaultLazyOptions.error
  defaultLazyOptions.attempt = attempt != null ? attempt : defaultLazyOptions.attempt
  defaultLazyOptions.throttleWait = throttleWait != null ? throttleWait : defaultLazyOptions.throttleWait
  defaultLazyOptions.filter = filter
}
var Lazy = {
  mounted,
  unmounted: clear,
  updated,
  install(app, lazyOptions) {
    mergeLazyOptions(lazyOptions)
    checkAllWithThrottle = throttle(checkAll, defaultLazyOptions.throttleWait)
    app.directive('lazy', this)
  },
}
function fitValidator(fit) {
  return ['fill', 'contain', 'cover', 'none', 'scale-down'].includes(fit)
}
var props$v = {
  src: {
    type: String,
  },
  fit: {
    type: String,
    validator: fitValidator,
    default: 'fill',
  },
  alt: {
    type: String,
  },
  width: {
    type: [String, Number],
  },
  height: {
    type: [String, Number],
  },
  radius: {
    type: [String, Number],
    default: 0,
  },
  loading: {
    type: String,
  },
  error: {
    type: String,
  },
  lazy: {
    type: Boolean,
    default: false,
  },
  ripple: {
    type: Boolean,
    default: false,
  },
  block: {
    type: Boolean,
    default: true,
  },
  onClick: {
    type: Function,
  },
  onLoad: {
    type: Function,
  },
  onError: {
    type: Function,
  },
}
var { n: n$A, classes: classes$u } = createNamespace('image')
var _hoisted_1$e = ['alt', 'lazy-error', 'lazy-loading']
var _hoisted_2$7 = ['alt', 'src']
function render$x(_ctx, _cache2) {
  var _directive_lazy = resolveDirective('lazy')
  var _directive_ripple = resolveDirective('ripple')
  return withDirectives(
    (openBlock(),
    createElementBlock(
      'div',
      {
        class: normalizeClass(_ctx.classes(_ctx.n(), 'var--box', [!_ctx.block, 'var--inline-block'])),
        style: normalizeStyle({
          width: _ctx.toSizeUnit(_ctx.width),
          height: _ctx.toSizeUnit(_ctx.height),
          'border-radius': _ctx.toSizeUnit(_ctx.radius),
        }),
      },
      [
        _ctx.lazy
          ? withDirectives(
              (openBlock(),
              createElementBlock(
                'img',
                {
                  key: 0,
                  class: normalizeClass(_ctx.n('image')),
                  alt: _ctx.alt,
                  'lazy-error': _ctx.error,
                  'lazy-loading': _ctx.loading,
                  style: normalizeStyle({
                    objectFit: _ctx.fit,
                  }),
                  onLoad:
                    _cache2[0] ||
                    (_cache2[0] = function () {
                      return _ctx.handleLoad && _ctx.handleLoad(...arguments)
                    }),
                  onError:
                    _cache2[1] ||
                    (_cache2[1] = function () {
                      return _ctx.handleError && _ctx.handleError(...arguments)
                    }),
                  onClick:
                    _cache2[2] ||
                    (_cache2[2] = function () {
                      return _ctx.onClick && _ctx.onClick(...arguments)
                    }),
                },
                null,
                46,
                _hoisted_1$e
              )),
              [[_directive_lazy, _ctx.src]]
            )
          : (openBlock(),
            createElementBlock(
              'img',
              {
                key: 1,
                class: normalizeClass(_ctx.n('image')),
                alt: _ctx.alt,
                style: normalizeStyle({
                  objectFit: _ctx.fit,
                }),
                src: _ctx.src,
                onLoad:
                  _cache2[3] ||
                  (_cache2[3] = function () {
                    return _ctx.handleLoad && _ctx.handleLoad(...arguments)
                  }),
                onError:
                  _cache2[4] ||
                  (_cache2[4] = function () {
                    return _ctx.handleError && _ctx.handleError(...arguments)
                  }),
                onClick:
                  _cache2[5] ||
                  (_cache2[5] = function () {
                    return _ctx.onClick && _ctx.onClick(...arguments)
                  }),
              },
              null,
              46,
              _hoisted_2$7
            )),
      ],
      6
    )),
    [
      [
        _directive_ripple,
        {
          disabled: !_ctx.ripple,
        },
      ],
    ]
  )
}
var Image$1 = defineComponent({
  render: render$x,
  name: 'VarImage',
  directives: {
    Lazy,
    Ripple,
  },
  props: props$v,
  setup(props2) {
    var handleLoad = (e) => {
      var el = e.currentTarget
      var { lazy, onLoad, onError } = props2
      if (lazy) {
        el._lazy.state === 'success' && call(onLoad, e)
        el._lazy.state === 'error' && call(onError, e)
      } else {
        call(onLoad, e)
      }
    }
    var handleError = (e) => {
      var { lazy, onError } = props2
      !lazy && call(onError, e)
    }
    return {
      n: n$A,
      classes: classes$u,
      toSizeUnit,
      handleLoad,
      handleError,
    }
  },
})
Image$1.install = function (app) {
  app.component(Image$1.name, Image$1)
}
var SWIPE_BIND_SWIPE_ITEM_KEY = Symbol('SWIPE_BIND_SWIPE_ITEM_KEY')
var SWIPE_COUNT_SWIPE_ITEM_KEY = Symbol('SWIPE_COUNT_SWIPE_ITEM_KEY')
function useSwipeItems() {
  var { childProviders, bindChildren } = useChildren(SWIPE_BIND_SWIPE_ITEM_KEY)
  var { length } = useAtChildrenCounter(SWIPE_COUNT_SWIPE_ITEM_KEY)
  return {
    length,
    swipeItems: childProviders,
    bindSwipeItems: bindChildren,
  }
}
var props$u = {
  loop: {
    type: Boolean,
    default: true,
  },
  autoplay: {
    type: [String, Number],
  },
  duration: {
    type: [String, Number],
    default: 300,
  },
  initialIndex: {
    type: [String, Number],
    default: 0,
  },
  indicator: {
    type: Boolean,
    default: true,
  },
  indicatorColor: {
    type: String,
  },
  vertical: {
    type: Boolean,
    default: false,
  },
  touchable: {
    type: Boolean,
    default: true,
  },
  onChange: {
    type: Function,
  },
}
function asyncGeneratorStep$7(gen, resolve2, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg)
    var value = info.value
  } catch (error) {
    reject(error)
    return
  }
  if (info.done) {
    resolve2(value)
  } else {
    Promise.resolve(value).then(_next, _throw)
  }
}
function _asyncToGenerator$7(fn) {
  return function () {
    var self2 = this,
      args = arguments
    return new Promise(function (resolve2, reject) {
      var gen = fn.apply(self2, args)
      function _next(value) {
        asyncGeneratorStep$7(gen, resolve2, reject, _next, _throw, 'next', value)
      }
      function _throw(err) {
        asyncGeneratorStep$7(gen, resolve2, reject, _next, _throw, 'throw', err)
      }
      _next(void 0)
    })
  }
}
var SWIPE_DELAY = 250
var SWIPE_DISTANCE = 20
var { n: n$z, classes: classes$t } = createNamespace('swipe')
var _hoisted_1$d = ['onClick']
function render$w(_ctx, _cache2) {
  return (
    openBlock(),
    createElementBlock(
      'div',
      {
        class: normalizeClass(_ctx.n()),
        ref: 'swipeEl',
      },
      [
        createElementVNode(
          'div',
          {
            class: normalizeClass(_ctx.classes(_ctx.n('track'), [_ctx.vertical, _ctx.n('--vertical')])),
            style: normalizeStyle({
              width: !_ctx.vertical ? _ctx.trackSize + 'px' : void 0,
              height: _ctx.vertical ? _ctx.trackSize + 'px' : void 0,
              transform: 'translate' + (_ctx.vertical ? 'Y' : 'X') + '(' + _ctx.translate + 'px)',
              transitionDuration: _ctx.lockDuration ? '0ms' : _ctx.toNumber(_ctx.duration) + 'ms',
            }),
            onTouchstart:
              _cache2[0] ||
              (_cache2[0] = function () {
                return _ctx.handleTouchstart && _ctx.handleTouchstart(...arguments)
              }),
            onTouchmove:
              _cache2[1] ||
              (_cache2[1] = function () {
                return _ctx.handleTouchmove && _ctx.handleTouchmove(...arguments)
              }),
            onTouchend:
              _cache2[2] ||
              (_cache2[2] = function () {
                return _ctx.handleTouchend && _ctx.handleTouchend(...arguments)
              }),
          },
          [renderSlot(_ctx.$slots, 'default')],
          38
        ),
        renderSlot(
          _ctx.$slots,
          'indicator',
          {
            index: _ctx.index,
            length: _ctx.length,
          },
          () => [
            _ctx.indicator && _ctx.length
              ? (openBlock(),
                createElementBlock(
                  'div',
                  {
                    key: 0,
                    class: normalizeClass(
                      _ctx.classes(_ctx.n('indicators'), [_ctx.vertical, _ctx.n('--indicators-vertical')])
                    ),
                  },
                  [
                    (openBlock(true),
                    createElementBlock(
                      Fragment,
                      null,
                      renderList(_ctx.length, (l, idx) => {
                        return (
                          openBlock(),
                          createElementBlock(
                            'div',
                            {
                              class: normalizeClass(
                                _ctx.classes(
                                  _ctx.n('indicator'),
                                  [_ctx.index === idx, _ctx.n('--indicator-active')],
                                  [_ctx.vertical, _ctx.n('--indicator-vertical')]
                                )
                              ),
                              style: normalizeStyle({
                                background: _ctx.indicatorColor,
                              }),
                              key: l,
                              onClick: ($event) => _ctx.to(idx),
                            },
                            null,
                            14,
                            _hoisted_1$d
                          )
                        )
                      }),
                      128
                    )),
                  ],
                  2
                ))
              : createCommentVNode('v-if', true),
          ]
        ),
      ],
      2
    )
  )
}
var Swipe = defineComponent({
  render: render$w,
  name: 'VarSwipe',
  props: props$u,
  setup(props2) {
    var swipeEl = ref(null)
    var size = ref(0)
    var vertical = computed(() => props2.vertical)
    var trackSize = ref(0)
    var translate = ref(0)
    var lockDuration = ref(false)
    var index2 = ref(0)
    var { swipeItems, bindSwipeItems, length } = useSwipeItems()
    var touching = false
    var timer = -1
    var startX
    var startY
    var startTime
    var prevX
    var prevY
    var findSwipeItem = (idx) =>
      swipeItems.find((_ref) => {
        var { index: index3 } = _ref
        return index3.value === idx
      })
    var dispatchBorrower = () => {
      if (!props2.loop) {
        return
      }
      if (translate.value >= 0) {
        findSwipeItem(length.value - 1).setTranslate(-trackSize.value)
      }
      if (translate.value <= -(trackSize.value - size.value)) {
        findSwipeItem(0).setTranslate(trackSize.value)
      }
      if (translate.value > -(trackSize.value - size.value) && translate.value < 0) {
        findSwipeItem(length.value - 1).setTranslate(0)
        findSwipeItem(0).setTranslate(0)
      }
    }
    var getSwipeIndex = (targetSwipeIndex) => {
      var swipeIndex = isNumber(targetSwipeIndex)
        ? targetSwipeIndex
        : Math.floor((translate.value - size.value / 2) / -size.value)
      var { loop } = props2
      if (swipeIndex <= -1) {
        return loop ? -1 : 0
      }
      if (swipeIndex >= length.value) {
        return loop ? length.value : length.value - 1
      }
      return swipeIndex
    }
    var swipeIndexToIndex = (swipeIndex) => {
      var { loop } = props2
      if (swipeIndex === -1) {
        return loop ? length.value - 1 : 0
      }
      if (swipeIndex === length.value) {
        return loop ? 0 : length.value - 1
      }
      return swipeIndex
    }
    var boundaryIndex = (index3) => {
      var { loop } = props2
      if (index3 < 0) {
        return loop ? length.value - 1 : 0
      }
      if (index3 > length.value - 1) {
        return loop ? 0 : length.value - 1
      }
      return index3
    }
    var fixPosition = (fn) => {
      var overLeft = translate.value >= size.value
      var overRight = translate.value <= -trackSize.value
      var leftTranslate = 0
      var rightTranslate = -(trackSize.value - size.value)
      lockDuration.value = true
      if (overLeft || overRight) {
        lockDuration.value = true
        translate.value = overRight ? leftTranslate : rightTranslate
        findSwipeItem(0).setTranslate(0)
        findSwipeItem(length.value - 1).setTranslate(0)
      }
      nextTickFrame(() => {
        lockDuration.value = false
        call(fn)
      })
    }
    var initialIndex = () => {
      index2.value = boundaryIndex(toNumber(props2.initialIndex))
    }
    var startAutoplay = () => {
      var { autoplay } = props2
      if (!autoplay || length.value <= 1) {
        return
      }
      stopAutoplay()
      timer = window.setTimeout(() => {
        next()
        startAutoplay()
      }, toNumber(autoplay))
    }
    var stopAutoplay = () => {
      timer && clearTimeout(timer)
    }
    var getDirection = (x, y2) => {
      if (x > y2 && x > 10) {
        return 'horizontal'
      }
      if (y2 > x && y2 > 10) {
        return 'vertical'
      }
    }
    var handleTouchstart = (event) => {
      if (length.value <= 1 || !props2.touchable) {
        return
      }
      var { clientX, clientY } = event.touches[0]
      startX = clientX
      startY = clientY
      startTime = performance.now()
      touching = true
      stopAutoplay()
      fixPosition(() => {
        lockDuration.value = true
      })
    }
    var handleTouchmove = (event) => {
      var { touchable, vertical: vertical2 } = props2
      if (!touching || !touchable) {
        return
      }
      var { clientX, clientY } = event.touches[0]
      var deltaX = Math.abs(clientX - startX)
      var deltaY = Math.abs(clientY - startY)
      var direction = getDirection(deltaX, deltaY)
      var expectDirection = vertical2 ? 'vertical' : 'horizontal'
      if (direction === expectDirection) {
        event.preventDefault()
        var moveX = prevX !== void 0 ? clientX - prevX : 0
        var moveY = prevY !== void 0 ? clientY - prevY : 0
        prevX = clientX
        prevY = clientY
        translate.value += vertical2 ? moveY : moveX
        dispatchBorrower()
      }
    }
    var handleTouchend = () => {
      if (!touching) {
        return
      }
      var { vertical: vertical2, onChange } = props2
      var positive = vertical2 ? prevY < startY : prevX < startX
      var distance = vertical2 ? Math.abs(startY - prevY) : Math.abs(startX - prevX)
      var quickSwiping = performance.now() - startTime <= SWIPE_DELAY && distance >= SWIPE_DISTANCE
      var swipeIndex = quickSwiping
        ? positive
          ? getSwipeIndex(index2.value + 1)
          : getSwipeIndex(index2.value - 1)
        : getSwipeIndex()
      touching = false
      lockDuration.value = false
      prevX = void 0
      prevY = void 0
      translate.value = swipeIndex * -size.value
      var prevIndex = index2.value
      index2.value = swipeIndexToIndex(swipeIndex)
      startAutoplay()
      prevIndex !== index2.value && call(onChange, index2.value)
    }
    var resize = () => {
      lockDuration.value = true
      size.value = props2.vertical ? swipeEl.value.offsetHeight : swipeEl.value.offsetWidth
      trackSize.value = size.value * length.value
      translate.value = index2.value * -size.value
      swipeItems.forEach((swipeItem) => {
        swipeItem.setTranslate(0)
      })
      startAutoplay()
      setTimeout(() => {
        lockDuration.value = false
      })
    }
    var next = () => {
      if (length.value <= 1) {
        return
      }
      var { loop, onChange } = props2
      var currentIndex = index2.value
      index2.value = boundaryIndex(currentIndex + 1)
      call(onChange, index2.value)
      fixPosition(() => {
        if (currentIndex === length.value - 1 && loop) {
          findSwipeItem(0).setTranslate(trackSize.value)
          translate.value = length.value * -size.value
          return
        }
        if (currentIndex !== length.value - 1) {
          translate.value = index2.value * -size.value
        }
      })
    }
    var prev = () => {
      if (length.value <= 1) {
        return
      }
      var { loop, onChange } = props2
      var currentIndex = index2.value
      index2.value = boundaryIndex(currentIndex - 1)
      call(onChange, index2.value)
      fixPosition(() => {
        if (currentIndex === 0 && loop) {
          findSwipeItem(length.value - 1).setTranslate(-trackSize.value)
          translate.value = size.value
          return
        }
        if (currentIndex !== 0) {
          translate.value = index2.value * -size.value
        }
      })
    }
    var to = (idx) => {
      if (length.value <= 1 || idx === index2.value) {
        return
      }
      idx = idx < 0 ? 0 : idx
      idx = idx >= length.value ? length.value : idx
      var task = idx > index2.value ? next : prev
      Array.from({
        length: Math.abs(idx - index2.value),
      }).forEach(task)
    }
    var swipeProvider = {
      size,
      vertical,
    }
    bindSwipeItems(swipeProvider)
    watch(
      () => length.value,
      /* @__PURE__ */ _asyncToGenerator$7(function* () {
        yield doubleRaf()
        initialIndex()
        resize()
      })
    )
    onMounted(() => {
      window.addEventListener('resize', resize)
    })
    onUnmounted(() => {
      window.removeEventListener('resize', resize)
      stopAutoplay()
    })
    return {
      n: n$z,
      classes: classes$t,
      length,
      index: index2,
      swipeEl,
      trackSize,
      translate,
      lockDuration,
      handleTouchstart,
      handleTouchmove,
      handleTouchend,
      next,
      prev,
      to,
      resize,
      toNumber,
    }
  },
})
Swipe.install = function (app) {
  app.component(Swipe.name, Swipe)
}
function useSwipe() {
  var { bindParent, parentProvider } = useParent(SWIPE_BIND_SWIPE_ITEM_KEY)
  var { index: index2 } = useAtParentIndex(SWIPE_COUNT_SWIPE_ITEM_KEY)
  if (!bindParent || !parentProvider || !index2) {
    throw Error('<var-swipe-item/> must in <var-swipe/>')
  }
  return {
    index: index2,
    swipe: parentProvider,
    bindSwipe: bindParent,
  }
}
var { n: n$y } = createNamespace('swipe-item')
function render$v(_ctx, _cache2) {
  return (
    openBlock(),
    createElementBlock(
      'div',
      {
        class: normalizeClass(_ctx.n()),
        style: normalizeStyle({
          width: !_ctx.vertical ? _ctx.size + 'px' : void 0,
          height: _ctx.vertical ? _ctx.size + 'px' : void 0,
          transform: 'translate' + (_ctx.vertical ? 'Y' : 'X') + '(' + _ctx.translate + 'px)',
        }),
      },
      [renderSlot(_ctx.$slots, 'default')],
      6
    )
  )
}
var SwipeItem = defineComponent({
  render: render$v,
  name: 'VarSwipeItem',
  setup() {
    var translate = ref(0)
    var { swipe, bindSwipe, index: index2 } = useSwipe()
    var { size, vertical } = swipe
    var setTranslate = (x) => {
      translate.value = x
    }
    var swipeItemProvider = {
      index: index2,
      setTranslate,
    }
    bindSwipe(swipeItemProvider)
    return {
      n: n$y,
      size,
      vertical,
      translate,
    }
  },
})
SwipeItem.install = function (app) {
  app.component(SwipeItem.name, SwipeItem)
}
function _extends$2() {
  _extends$2 =
    Object.assign ||
    function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i]
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key]
          }
        }
      }
      return target
    }
  return _extends$2.apply(this, arguments)
}
var props$t = _extends$2(
  {
    show: {
      type: Boolean,
      default: false,
    },
    images: {
      type: Array,
      default: () => [],
    },
    current: {
      type: String,
    },
    zoom: {
      type: [String, Number],
      default: 2,
    },
    closeable: {
      type: Boolean,
      default: false,
    },
    'onUpdate:show': {
      type: Function,
    },
  },
  pickProps(props$u, ['loop', 'indicator', 'onChange']),
  pickProps(props$U, ['lockScroll', 'teleport', 'onOpen', 'onClose', 'onOpened', 'onClosed', 'onRouteChange'])
)
var { n: n$x, classes: classes$s } = createNamespace('image-preview')
var DISTANCE_OFFSET = 12
var EVENT_DELAY = 200
var TAP_DELAY = 350
var ANIMATION_DURATION = 200
var _hoisted_1$c = ['src', 'alt']
function render$u(_ctx, _cache2) {
  var _component_var_swipe_item = resolveComponent('var-swipe-item')
  var _component_var_swipe = resolveComponent('var-swipe')
  var _component_var_icon = resolveComponent('var-icon')
  var _component_var_popup = resolveComponent('var-popup')
  return (
    openBlock(),
    createBlock(
      _component_var_popup,
      {
        class: normalizeClass(_ctx.n('popup')),
        'var-image-preview-cover': '',
        transition: 'var-fade',
        show: _ctx.popupShow,
        overlay: false,
        'close-on-click-overlay': false,
        'lock-scroll': _ctx.lockScroll,
        teleport: _ctx.teleport,
        onOpen: _ctx.onOpen,
        onClose: _ctx.onClose,
        onClosed: _ctx.onClosed,
        onOpened: _ctx.onOpened,
        onRouteChange: _ctx.onRouteChange,
      },
      {
        default: withCtx(() => [
          createVNode(
            _component_var_swipe,
            mergeProps(
              {
                class: _ctx.n('swipe'),
                'var-image-preview-cover': '',
                touchable: _ctx.canSwipe,
                indicator: _ctx.indicator && _ctx.images.length > 1,
                'initial-index': _ctx.initialIndex,
                loop: _ctx.loop,
                onChange: _ctx.onChange,
              },
              _ctx.$attrs
            ),
            {
              default: withCtx(() => [
                (openBlock(true),
                createElementBlock(
                  Fragment,
                  null,
                  renderList(_ctx.images, (image) => {
                    return (
                      openBlock(),
                      createBlock(
                        _component_var_swipe_item,
                        {
                          class: normalizeClass(_ctx.n('swipe-item')),
                          'var-image-preview-cover': '',
                          key: image,
                        },
                        {
                          default: withCtx(() => [
                            createElementVNode(
                              'div',
                              {
                                class: normalizeClass(_ctx.n('zoom-container')),
                                style: normalizeStyle({
                                  transform:
                                    'scale(' +
                                    _ctx.scale +
                                    ') translate(' +
                                    _ctx.translateX +
                                    'px, ' +
                                    _ctx.translateY +
                                    'px)',
                                  transitionTimingFunction: _ctx.transitionTimingFunction,
                                  transitionDuration: _ctx.transitionDuration,
                                }),
                                onTouchstart:
                                  _cache2[0] ||
                                  (_cache2[0] = function () {
                                    return _ctx.handleTouchstart && _ctx.handleTouchstart(...arguments)
                                  }),
                                onTouchmove:
                                  _cache2[1] ||
                                  (_cache2[1] = function () {
                                    return _ctx.handleTouchmove && _ctx.handleTouchmove(...arguments)
                                  }),
                                onTouchend:
                                  _cache2[2] ||
                                  (_cache2[2] = function () {
                                    return _ctx.handleTouchend && _ctx.handleTouchend(...arguments)
                                  }),
                              },
                              [
                                createElementVNode(
                                  'img',
                                  {
                                    class: normalizeClass(_ctx.n('image')),
                                    src: image,
                                    alt: image,
                                  },
                                  null,
                                  10,
                                  _hoisted_1$c
                                ),
                              ],
                              38
                            ),
                          ]),
                          _: 2,
                        },
                        1032,
                        ['class']
                      )
                    )
                  }),
                  128
                )),
              ]),
              indicator: withCtx((_ref) => {
                var { index: index2, length } = _ref
                return [
                  renderSlot(
                    _ctx.$slots,
                    'indicator',
                    {
                      index: index2,
                      length,
                    },
                    () => [
                      _ctx.indicator && _ctx.images.length > 1
                        ? (openBlock(),
                          createElementBlock(
                            'div',
                            {
                              key: 0,
                              class: normalizeClass(_ctx.n('indicators')),
                            },
                            toDisplayString(index2 + 1) + ' / ' + toDisplayString(length),
                            3
                          ))
                        : createCommentVNode('v-if', true),
                    ]
                  ),
                ]
              }),
              _: 3,
            },
            16,
            ['class', 'touchable', 'indicator', 'initial-index', 'loop', 'onChange']
          ),
          renderSlot(_ctx.$slots, 'close-icon', {}, () => [
            _ctx.closeable
              ? (openBlock(),
                createBlock(
                  _component_var_icon,
                  {
                    key: 0,
                    class: normalizeClass(_ctx.n('close-icon')),
                    name: 'close-circle',
                    'var-image-preview-cover': '',
                    onClick: _ctx.close,
                  },
                  null,
                  8,
                  ['class', 'onClick']
                ))
              : createCommentVNode('v-if', true),
          ]),
          createElementVNode(
            'div',
            {
              class: normalizeClass(_ctx.n('extra')),
            },
            [renderSlot(_ctx.$slots, 'extra')],
            2
          ),
        ]),
        _: 3,
      },
      8,
      ['class', 'show', 'lock-scroll', 'teleport', 'onOpen', 'onClose', 'onClosed', 'onOpened', 'onRouteChange']
    )
  )
}
var VarImagePreview = defineComponent({
  render: render$u,
  name: 'VarImagePreview',
  components: {
    VarSwipe: Swipe,
    VarSwipeItem: SwipeItem,
    VarPopup: Popup,
    VarIcon: Icon,
  },
  inheritAttrs: false,
  props: props$t,
  setup(props2) {
    var popupShow = ref(false)
    var initialIndex = computed(() => {
      var { images, current } = props2
      var index2 = images.findIndex((image) => image === current)
      return index2 >= 0 ? index2 : 0
    })
    var scale = ref(1)
    var translateX = ref(0)
    var translateY = ref(0)
    var transitionTimingFunction = ref(void 0)
    var transitionDuration = ref(void 0)
    var canSwipe = ref(true)
    var startTouch = null
    var prevTouch = null
    var checker = null
    var getDistance = (touch, target) => {
      var { clientX: touchX, clientY: touchY } = touch
      var { clientX: targetX, clientY: targetY } = target
      return Math.abs(Math.sqrt(Math.pow(targetX - touchX, 2) + Math.pow(targetY - touchY, 2)))
    }
    var createVarTouch = (touches, target) => ({
      clientX: touches.clientX,
      clientY: touches.clientY,
      timestamp: Date.now(),
      target,
    })
    var zoomIn = () => {
      scale.value = toNumber(props2.zoom)
      canSwipe.value = false
      prevTouch = null
      window.setTimeout(() => {
        transitionTimingFunction.value = 'linear'
        transitionDuration.value = '0s'
      }, ANIMATION_DURATION)
    }
    var zoomOut = () => {
      scale.value = 1
      translateX.value = 0
      translateY.value = 0
      canSwipe.value = true
      prevTouch = null
      transitionTimingFunction.value = void 0
      transitionDuration.value = void 0
    }
    var isDoubleTouch = (currentTouch) => {
      if (!prevTouch) {
        return false
      }
      return (
        getDistance(prevTouch, currentTouch) <= DISTANCE_OFFSET &&
        currentTouch.timestamp - prevTouch.timestamp <= EVENT_DELAY &&
        prevTouch.target === currentTouch.target
      )
    }
    var isTapTouch = (target) => {
      if (!target || !startTouch || !prevTouch) {
        return false
      }
      return (
        getDistance(startTouch, prevTouch) <= DISTANCE_OFFSET &&
        Date.now() - prevTouch.timestamp < TAP_DELAY &&
        (target === startTouch.target || target.parentNode === startTouch.target)
      )
    }
    var handleTouchend = (event) => {
      checker = window.setTimeout(() => {
        isTapTouch(event.target) && close()
        startTouch = null
      }, EVENT_DELAY)
    }
    var handleTouchstart = (event) => {
      checker && window.clearTimeout(checker)
      var { touches } = event
      var currentTouch = createVarTouch(touches[0], event.currentTarget)
      startTouch = currentTouch
      if (isDoubleTouch(currentTouch)) {
        scale.value > 1 ? zoomOut() : zoomIn()
        return
      }
      prevTouch = currentTouch
    }
    var getZoom = (target) => {
      var { offsetWidth, offsetHeight } = target
      var { naturalWidth, naturalHeight } = target.querySelector('.var-image-preview__image')
      return {
        width: offsetWidth,
        height: offsetHeight,
        imageRadio: naturalHeight / naturalWidth,
        rootRadio: offsetHeight / offsetWidth,
        zoom: toNumber(props2.zoom),
      }
    }
    var getLimitX = (target) => {
      var { zoom, imageRadio, rootRadio, width, height } = getZoom(target)
      if (!imageRadio) {
        return 0
      }
      var displayWidth = imageRadio > rootRadio ? height / imageRadio : width
      return Math.max(0, (zoom * displayWidth - width) / 2) / zoom
    }
    var getLimitY = (target) => {
      var { zoom, imageRadio, rootRadio, width, height } = getZoom(target)
      if (!imageRadio) {
        return 0
      }
      var displayHeight = imageRadio > rootRadio ? height : width * imageRadio
      return Math.max(0, (zoom * displayHeight - height) / 2) / zoom
    }
    var getMoveTranslate = (current, move, limit) => {
      if (current + move >= limit) {
        return limit
      }
      if (current + move <= -limit) {
        return -limit
      }
      return current + move
    }
    var handleTouchmove = (event) => {
      if (!prevTouch) {
        return
      }
      var target = event.currentTarget
      var { touches } = event
      var currentTouch = createVarTouch(touches[0], target)
      if (scale.value > 1) {
        var moveX = currentTouch.clientX - prevTouch.clientX
        var moveY = currentTouch.clientY - prevTouch.clientY
        var limitX = getLimitX(target)
        var limitY = getLimitY(target)
        translateX.value = getMoveTranslate(translateX.value, moveX, limitX)
        translateY.value = getMoveTranslate(translateY.value, moveY, limitY)
      }
      prevTouch = currentTouch
    }
    var close = () => {
      if (scale.value > 1) {
        zoomOut()
        setTimeout(() => call(props2['onUpdate:show'], false), ANIMATION_DURATION)
        return
      }
      call(props2['onUpdate:show'], false)
    }
    watch(
      () => props2.show,
      (newValue) => {
        popupShow.value = newValue
      },
      {
        immediate: true,
      }
    )
    return {
      n: n$x,
      classes: classes$s,
      initialIndex,
      popupShow,
      scale,
      translateX,
      translateY,
      canSwipe,
      transitionTimingFunction,
      transitionDuration,
      handleTouchstart,
      handleTouchmove,
      handleTouchend,
      close,
    }
  },
})
var singletonOptions
function ImagePreview(options2) {
  if (!inBrowser()) {
    return
  }
  ImagePreview.close()
  var imagePreviewOptions = isString$1(options2)
    ? {
        images: [options2],
      }
    : isArray$1(options2)
    ? {
        images: options2,
      }
    : options2
  var reactiveImagePreviewOptions = reactive(imagePreviewOptions)
  reactiveImagePreviewOptions.teleport = 'body'
  singletonOptions = reactiveImagePreviewOptions
  var { unmountInstance } = mountInstance(VarImagePreview, reactiveImagePreviewOptions, {
    onClose: () => (reactiveImagePreviewOptions.onClose == null ? void 0 : reactiveImagePreviewOptions.onClose()),
    onClosed: () => {
      reactiveImagePreviewOptions.onClosed == null ? void 0 : reactiveImagePreviewOptions.onClosed()
      unmountInstance()
      singletonOptions === reactiveImagePreviewOptions && (singletonOptions = null)
    },
    onRouteChange: () => {
      unmountInstance()
      singletonOptions === reactiveImagePreviewOptions && (singletonOptions = null)
    },
    'onUpdate:show': (value) => {
      reactiveImagePreviewOptions.show = value
    },
  })
  reactiveImagePreviewOptions.show = true
}
ImagePreview.close = () => {
  if (singletonOptions != null) {
    var prevSingletonOptions = singletonOptions
    singletonOptions = null
    nextTick().then(() => {
      prevSingletonOptions.show = false
    })
  }
}
VarImagePreview.install = function (app) {
  app.component(VarImagePreview.name, VarImagePreview)
}
ImagePreview.install = function (app) {
  app.component(VarImagePreview.name, VarImagePreview)
}
ImagePreview.Component = VarImagePreview
var props$s = {
  offsetTop: {
    type: [String, Number],
    default: 0,
  },
  zIndex: {
    type: [String, Number],
    default: 10,
  },
  cssMode: {
    type: Boolean,
    default: false,
  },
  disabled: {
    type: Boolean,
    default: false,
  },
  onScroll: {
    type: Function,
  },
}
function asyncGeneratorStep$6(gen, resolve2, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg)
    var value = info.value
  } catch (error) {
    reject(error)
    return
  }
  if (info.done) {
    resolve2(value)
  } else {
    Promise.resolve(value).then(_next, _throw)
  }
}
function _asyncToGenerator$6(fn) {
  return function () {
    var self2 = this,
      args = arguments
    return new Promise(function (resolve2, reject) {
      var gen = fn.apply(self2, args)
      function _next(value) {
        asyncGeneratorStep$6(gen, resolve2, reject, _next, _throw, 'next', value)
      }
      function _throw(err) {
        asyncGeneratorStep$6(gen, resolve2, reject, _next, _throw, 'throw', err)
      }
      _next(void 0)
    })
  }
}
var { n: n$w, classes: classes$r } = createNamespace('sticky')
function render$t(_ctx, _cache2) {
  return (
    openBlock(),
    createElementBlock(
      'div',
      {
        class: normalizeClass(_ctx.classes(_ctx.n(), [_ctx.enableCSSMode, _ctx.n('--css-mode')])),
        ref: 'stickyEl',
        style: normalizeStyle({
          zIndex: _ctx.toNumber(_ctx.zIndex),
          top: _ctx.enableCSSMode ? _ctx.offsetTop + 'px' : void 0,
          width: _ctx.enableFixedMode ? _ctx.fixedWidth : void 0,
          height: _ctx.enableFixedMode ? _ctx.fixedHeight : void 0,
        }),
      },
      [
        createElementVNode(
          'div',
          {
            class: normalizeClass(_ctx.n('wrapper')),
            ref: 'wrapperEl',
            style: normalizeStyle({
              zIndex: _ctx.toNumber(_ctx.zIndex),
              position: _ctx.enableFixedMode ? 'fixed' : void 0,
              width: _ctx.enableFixedMode ? _ctx.fixedWrapperWidth : void 0,
              height: _ctx.enableFixedMode ? _ctx.fixedWrapperHeight : void 0,
              left: _ctx.enableFixedMode ? _ctx.fixedLeft : void 0,
              top: _ctx.enableFixedMode ? _ctx.fixedTop : void 0,
            }),
          },
          [renderSlot(_ctx.$slots, 'default')],
          6
        ),
      ],
      6
    )
  )
}
var Sticky = defineComponent({
  render: render$t,
  name: 'VarSticky',
  props: props$s,
  setup(props2) {
    var stickyEl = ref(null)
    var wrapperEl = ref(null)
    var isFixed = ref(false)
    var fixedTop = ref('0px')
    var fixedLeft = ref('0px')
    var fixedWidth = ref('auto')
    var fixedHeight = ref('auto')
    var fixedWrapperWidth = ref('auto')
    var fixedWrapperHeight = ref('auto')
    var enableCSSMode = computed(() => !props2.disabled && props2.cssMode)
    var enableFixedMode = computed(() => !props2.disabled && isFixed.value)
    var offsetTop = computed(() => toPxNum(props2.offsetTop))
    var scroller
    var handleScroll = () => {
      var { onScroll, cssMode, disabled } = props2
      if (disabled) {
        return
      }
      var scrollerTop = 0
      if (scroller !== window) {
        var { top } = scroller.getBoundingClientRect()
        scrollerTop = top
      }
      var wrapper3 = wrapperEl.value
      var sticky = stickyEl.value
      var { top: stickyTop, left: stickyLeft } = sticky.getBoundingClientRect()
      var currentOffsetTop = stickyTop - scrollerTop
      if (currentOffsetTop <= offsetTop.value) {
        if (!cssMode) {
          fixedWidth.value = sticky.offsetWidth + 'px'
          fixedHeight.value = sticky.offsetHeight + 'px'
          fixedTop.value = scrollerTop + offsetTop.value + 'px'
          fixedLeft.value = stickyLeft + 'px'
          fixedWrapperWidth.value = wrapper3.offsetWidth + 'px'
          fixedWrapperHeight.value = wrapper3.offsetHeight + 'px'
          isFixed.value = true
        }
        call(onScroll, offsetTop.value, true)
      } else {
        isFixed.value = false
        call(onScroll, currentOffsetTop, false)
      }
    }
    var addScrollListener = /* @__PURE__ */ (function () {
      var _ref = _asyncToGenerator$6(function* () {
        yield doubleRaf()
        scroller = getParentScroller(stickyEl.value)
        scroller !== window && scroller.addEventListener('scroll', handleScroll)
        window.addEventListener('scroll', handleScroll)
        handleScroll()
      })
      return function addScrollListener2() {
        return _ref.apply(this, arguments)
      }
    })()
    var removeScrollListener = () => {
      scroller !== window && scroller.removeEventListener('scroll', handleScroll)
      window.removeEventListener('scroll', handleScroll)
    }
    watch(() => props2.disabled, handleScroll)
    onActivated(addScrollListener)
    onDeactivated(removeScrollListener)
    onMounted(addScrollListener)
    onUnmounted(removeScrollListener)
    return {
      n: n$w,
      classes: classes$r,
      stickyEl,
      wrapperEl,
      isFixed,
      offsetTop,
      fixedTop,
      fixedLeft,
      fixedWidth,
      fixedHeight,
      fixedWrapperWidth,
      fixedWrapperHeight,
      enableCSSMode,
      enableFixedMode,
      toNumber,
    }
  },
})
Sticky.install = function (app) {
  app.component(Sticky.name, Sticky)
}
var INDEX_BAR_BIND_INDEX_ANCHOR_KEY = Symbol('INDEX_BAR_BIND_INDEX_ANCHOR_KEY')
var INDEX_BAR_COUNT_INDEX_ANCHOR_KEY = Symbol('INDEX_BAR_COUNT_INDEX_ANCHOR_KEY')
function useIndexAnchors() {
  var { bindChildren, childProviders } = useChildren(INDEX_BAR_BIND_INDEX_ANCHOR_KEY)
  var { length } = useAtChildrenCounter(INDEX_BAR_COUNT_INDEX_ANCHOR_KEY)
  return {
    length,
    indexAnchors: childProviders,
    bindIndexAnchors: bindChildren,
  }
}
function useIndexBar() {
  var { parentProvider, bindParent } = useParent(INDEX_BAR_BIND_INDEX_ANCHOR_KEY)
  var { index: index2 } = useAtParentIndex(INDEX_BAR_COUNT_INDEX_ANCHOR_KEY)
  if (!parentProvider || !bindParent) {
    throw Error('[Varlet] IndexAnchor: You should use this component in "IndexBar"')
  }
  return {
    index: index2,
    indexBar: parentProvider,
    bindIndexBar: bindParent,
  }
}
var props$r = {
  index: {
    type: [Number, String],
  },
}
var { n: n$v, classes: classes$q } = createNamespace('index-anchor')
function render$s(_ctx, _cache2) {
  return (
    openBlock(),
    createBlock(
      resolveDynamicComponent(_ctx.sticky ? 'var-sticky' : _ctx.Transition),
      {
        'offset-top': _ctx.sticky ? _ctx.stickyOffsetTop : null,
        'z-index': _ctx.sticky ? _ctx.zIndex : null,
        disabled: _ctx.disabled && !_ctx.cssMode,
        'css-mode': _ctx.cssMode,
        ref: 'anchorEl',
      },
      {
        default: withCtx(() => [
          createElementVNode(
            'div',
            mergeProps(
              {
                class: _ctx.n(),
              },
              _ctx.$attrs
            ),
            [renderSlot(_ctx.$slots, 'default', {}, () => [createTextVNode(toDisplayString(_ctx.name), 1)])],
            16
          ),
        ]),
        _: 3,
      },
      8,
      ['offset-top', 'z-index', 'disabled', 'css-mode']
    )
  )
}
var IndexAnchor = defineComponent({
  render: render$s,
  name: 'VarIndexAnchor',
  components: {
    VarSticky: Sticky,
  },
  inheritAttrs: false,
  props: props$r,
  setup(props2) {
    var { index: index2, indexBar, bindIndexBar } = useIndexBar()
    var ownTop = ref(0)
    var disabled = ref(false)
    var name = computed(() => props2.index)
    var anchorEl = ref(null)
    var { active, sticky, cssMode, stickyOffsetTop, zIndex } = indexBar
    var setOwnTop = () => {
      if (!anchorEl.value) return
      ownTop.value = anchorEl.value.$el ? anchorEl.value.$el.offsetTop : anchorEl.value.offsetTop
    }
    var setDisabled = (value) => {
      disabled.value = value
    }
    var indexAnchorProvider = {
      index: index2,
      name,
      ownTop,
      setOwnTop,
      setDisabled,
    }
    bindIndexBar(indexAnchorProvider)
    return {
      n: n$v,
      classes: classes$q,
      name,
      anchorEl,
      active,
      sticky,
      zIndex,
      disabled,
      cssMode,
      stickyOffsetTop,
      Transition,
    }
  },
})
IndexAnchor.install = function (app) {
  app.component(IndexAnchor.name, IndexAnchor)
}
var props$q = {
  sticky: {
    type: Boolean,
    default: true,
  },
  stickyOffsetTop: {
    type: [String, Number],
    default: 0,
  },
  cssMode: {
    type: Boolean,
    default: false,
  },
  hideList: {
    type: Boolean,
    default: false,
  },
  zIndex: {
    type: [Number, String],
    default: 1,
  },
  highlightColor: {
    type: String,
  },
  duration: {
    type: [Number, String],
    default: 0,
  },
  onClick: {
    type: Function,
  },
  onChange: {
    type: Function,
  },
}
function asyncGeneratorStep$5(gen, resolve2, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg)
    var value = info.value
  } catch (error) {
    reject(error)
    return
  }
  if (info.done) {
    resolve2(value)
  } else {
    Promise.resolve(value).then(_next, _throw)
  }
}
function _asyncToGenerator$5(fn) {
  return function () {
    var self2 = this,
      args = arguments
    return new Promise(function (resolve2, reject) {
      var gen = fn.apply(self2, args)
      function _next(value) {
        asyncGeneratorStep$5(gen, resolve2, reject, _next, _throw, 'next', value)
      }
      function _throw(err) {
        asyncGeneratorStep$5(gen, resolve2, reject, _next, _throw, 'throw', err)
      }
      _next(void 0)
    })
  }
}
var { n: n$u, classes: classes$p } = createNamespace('index-bar')
var _hoisted_1$b = ['onClick']
function render$r(_ctx, _cache2) {
  return (
    openBlock(),
    createElementBlock(
      'div',
      {
        class: normalizeClass(_ctx.n()),
        ref: 'barEl',
      },
      [
        renderSlot(_ctx.$slots, 'default'),
        createElementVNode(
          'ul',
          {
            class: normalizeClass(_ctx.n('anchor-list')),
            style: normalizeStyle({
              zIndex: _ctx.toNumber(_ctx.zIndex) + 2,
              display: _ctx.hideList ? 'none' : 'block',
            }),
          },
          [
            (openBlock(true),
            createElementBlock(
              Fragment,
              null,
              renderList(_ctx.anchorNameList, (anchorName) => {
                return (
                  openBlock(),
                  createElementBlock(
                    'li',
                    {
                      key: anchorName,
                      class: normalizeClass(
                        _ctx.classes(_ctx.n('anchor-item'), [_ctx.active === anchorName, _ctx.n('anchor-item--active')])
                      ),
                      style: normalizeStyle({
                        color: _ctx.active === anchorName && _ctx.highlightColor ? _ctx.highlightColor : '',
                      }),
                      onClick: ($event) => _ctx.anchorClick(anchorName, true),
                    },
                    toDisplayString(anchorName),
                    15,
                    _hoisted_1$b
                  )
                )
              }),
              128
            )),
          ],
          6
        ),
      ],
      2
    )
  )
}
var IndexBar = defineComponent({
  render: render$r,
  name: 'VarIndexBar',
  props: props$q,
  setup(props2) {
    var { length, indexAnchors, bindIndexAnchors } = useIndexAnchors()
    var clickedName = ref('')
    var scroller = ref(null)
    var barEl = ref(null)
    var anchorNameList = ref([])
    var active = ref()
    var sticky = computed(() => props2.sticky)
    var cssMode = computed(() => props2.cssMode)
    var stickyOffsetTop = computed(() => toPxNum(props2.stickyOffsetTop))
    var zIndex = computed(() => props2.zIndex)
    var indexBarProvider = {
      active,
      sticky,
      cssMode,
      stickyOffsetTop,
      zIndex,
    }
    bindIndexAnchors(indexBarProvider)
    var emitEvent = (anchor) => {
      var anchorName = isPlainObject$1(anchor) ? anchor.name.value : anchor
      if (anchorName === active.value || anchorName === void 0) return
      active.value = anchorName
      call(props2.onChange, anchorName)
    }
    var handleScroll = () => {
      var scrollTop = getScrollTop(scroller.value)
      var scrollHeight = scroller.value === window ? document.body.scrollHeight : scroller.value.scrollHeight
      var { offsetTop } = barEl.value
      indexAnchors.forEach((anchor, index2) => {
        var anchorTop = anchor.ownTop.value
        var top = scrollTop - anchorTop + stickyOffsetTop.value - offsetTop
        var distance =
          index2 === indexAnchors.length - 1
            ? scrollHeight
            : indexAnchors[index2 + 1].ownTop.value - anchor.ownTop.value
        if (top >= 0 && top < distance && !clickedName.value) {
          if (index2 && !props2.cssMode) {
            indexAnchors[index2 - 1].setDisabled(true)
          }
          anchor.setDisabled(false)
          emitEvent(anchor)
        }
      })
    }
    var anchorClick = /* @__PURE__ */ (function () {
      var _ref = _asyncToGenerator$5(function* (anchorName, manualCall) {
        var { offsetTop } = barEl.value
        if (manualCall) call(props2.onClick, anchorName)
        if (anchorName === active.value) return
        var indexAnchor = indexAnchors.find((_ref2) => {
          var { name } = _ref2
          return anchorName === name.value
        })
        if (!indexAnchor) return
        var top = indexAnchor.ownTop.value - stickyOffsetTop.value + offsetTop
        var left = getScrollLeft(scroller.value)
        clickedName.value = anchorName
        emitEvent(anchorName)
        yield scrollTo(scroller.value, {
          left,
          top,
          animation: easeInOutCubic,
          duration: toNumber(props2.duration),
        })
        nextTickFrame(() => {
          clickedName.value = ''
        })
      })
      return function anchorClick2(_x, _x2) {
        return _ref.apply(this, arguments)
      }
    })()
    var scrollTo$1 = (index2) => {
      requestAnimationFrame(() => anchorClick(index2))
    }
    watch(
      () => length.value,
      /* @__PURE__ */ _asyncToGenerator$5(function* () {
        yield doubleRaf()
        indexAnchors.forEach((_ref4) => {
          var { name, setOwnTop } = _ref4
          if (name.value) anchorNameList.value.push(name.value)
          setOwnTop()
        })
      })
    )
    onMounted(
      /* @__PURE__ */ _asyncToGenerator$5(function* () {
        yield doubleRaf()
        scroller.value = getParentScroller(barEl.value)
        scroller.value.addEventListener('scroll', handleScroll)
      })
    )
    onBeforeUnmount(() => {
      call(scroller.value.removeEventListener, 'scroll', handleScroll)
    })
    return {
      n: n$u,
      classes: classes$p,
      barEl,
      active,
      zIndex,
      anchorNameList,
      toNumber,
      scrollTo: scrollTo$1,
      anchorClick,
    }
  },
})
IndexBar.install = function (app) {
  app.component(IndexBar.name, IndexBar)
}
function typeValidator$1(type) {
  return ['text', 'password', 'number'].includes(type)
}
var props$p = {
  modelValue: {
    type: String,
  },
  modelModifiers: {
    type: Object,
    default: () => ({}),
  },
  type: {
    type: String,
    default: 'text',
    validator: typeValidator$1,
  },
  textarea: {
    type: Boolean,
    default: false,
  },
  rows: {
    type: [String, Number],
    default: 8,
  },
  placeholder: {
    type: String,
  },
  line: {
    type: Boolean,
    default: true,
  },
  hint: {
    type: Boolean,
    default: true,
  },
  textColor: {
    type: String,
  },
  focusColor: {
    type: String,
  },
  blurColor: {
    type: String,
  },
  maxlength: {
    type: [String, Number],
  },
  disabled: {
    type: Boolean,
    default: false,
  },
  readonly: {
    type: Boolean,
    default: false,
  },
  clearable: {
    type: Boolean,
    default: false,
  },
  resize: {
    type: Boolean,
    default: false,
  },
  autofocus: {
    type: Boolean,
    default: false,
  },
  validateTrigger: {
    type: Array,
    default: () => ['onInput', 'onClear'],
  },
  rules: {
    type: Array,
  },
  onFocus: {
    type: Function,
  },
  onBlur: {
    type: Function,
  },
  onClick: {
    type: Function,
  },
  onClear: {
    type: Function,
  },
  onInput: {
    type: Function,
  },
  onChange: {
    type: Function,
  },
  'onUpdate:modelValue': {
    type: Function,
  },
}
var { n: n$t, classes: classes$o } = createNamespace('input')
var _hoisted_1$a = ['id', 'disabled', 'type', 'value', 'maxlength', 'rows']
var _hoisted_2$6 = ['id', 'disabled', 'type', 'value', 'maxlength']
var _hoisted_3$2 = ['for']
function render$q(_ctx, _cache2) {
  var _component_var_icon = resolveComponent('var-icon')
  var _component_var_form_details = resolveComponent('var-form-details')
  return (
    openBlock(),
    createElementBlock(
      'div',
      {
        class: normalizeClass(_ctx.classes(_ctx.n(), 'var--box', [_ctx.disabled, _ctx.n('--disabled')])),
        onClick:
          _cache2[8] ||
          (_cache2[8] = function () {
            return _ctx.handleClick && _ctx.handleClick(...arguments)
          }),
      },
      [
        createElementVNode(
          'div',
          {
            class: normalizeClass(
              _ctx.classes(
                _ctx.n('controller'),
                [_ctx.isFocus, _ctx.n('--focus')],
                [_ctx.errorMessage, _ctx.n('--error')],
                [_ctx.formDisabled || _ctx.disabled, _ctx.n('--disabled')]
              )
            ),
            style: normalizeStyle({
              color: !_ctx.errorMessage ? (_ctx.isFocus ? _ctx.focusColor : _ctx.blurColor) : void 0,
            }),
          },
          [
            createElementVNode(
              'div',
              {
                class: normalizeClass(_ctx.classes(_ctx.n('icon'), [!_ctx.hint, _ctx.n('--non-hint')])),
              },
              [renderSlot(_ctx.$slots, 'prepend-icon')],
              2
            ),
            createElementVNode(
              'div',
              {
                class: normalizeClass(_ctx.classes(_ctx.n('wrap'), [!_ctx.hint, _ctx.n('--non-hint')])),
              },
              [
                _ctx.type === 'password'
                  ? (openBlock(),
                    createElementBlock(
                      'input',
                      {
                        key: 0,
                        class: normalizeClass(_ctx.n('autocomplete')),
                      },
                      null,
                      2
                    ))
                  : createCommentVNode('v-if', true),
                _ctx.textarea
                  ? (openBlock(),
                    createElementBlock(
                      'textarea',
                      {
                        key: 1,
                        class: normalizeClass(
                          _ctx.classes(
                            _ctx.n('input'),
                            _ctx.n('--textarea'),
                            [_ctx.formDisabled || _ctx.disabled, _ctx.n('--disabled')],
                            [_ctx.errorMessage, _ctx.n('--caret-error')]
                          )
                        ),
                        ref: 'el',
                        autocomplete: 'new-password',
                        id: _ctx.id,
                        disabled: _ctx.formDisabled || _ctx.disabled || _ctx.formReadonly || _ctx.readonly,
                        type: _ctx.type,
                        value: _ctx.modelValue,
                        maxlength: _ctx.maxlength,
                        rows: _ctx.rows,
                        style: normalizeStyle({
                          color: _ctx.textColor,
                          caretColor: !_ctx.errorMessage ? _ctx.focusColor : void 0,
                          resize: _ctx.resize ? 'vertical' : 'none',
                        }),
                        onFocus:
                          _cache2[0] ||
                          (_cache2[0] = function () {
                            return _ctx.handleFocus && _ctx.handleFocus(...arguments)
                          }),
                        onBlur:
                          _cache2[1] ||
                          (_cache2[1] = function () {
                            return _ctx.handleBlur && _ctx.handleBlur(...arguments)
                          }),
                        onInput:
                          _cache2[2] ||
                          (_cache2[2] = function () {
                            return _ctx.handleInput && _ctx.handleInput(...arguments)
                          }),
                        onChange:
                          _cache2[3] ||
                          (_cache2[3] = function () {
                            return _ctx.handleChange && _ctx.handleChange(...arguments)
                          }),
                      },
                      '\n        ',
                      46,
                      _hoisted_1$a
                    ))
                  : (openBlock(),
                    createElementBlock(
                      'input',
                      {
                        key: 2,
                        class: normalizeClass(
                          _ctx.classes(
                            _ctx.n('input'),
                            [_ctx.formDisabled || _ctx.disabled, _ctx.n('--disabled')],
                            [_ctx.errorMessage, _ctx.n('--caret-error')]
                          )
                        ),
                        ref: 'el',
                        autocomplete: 'new-password',
                        id: _ctx.id,
                        disabled: _ctx.formDisabled || _ctx.disabled || _ctx.formReadonly || _ctx.readonly,
                        type: _ctx.type,
                        value: _ctx.modelValue,
                        maxlength: _ctx.maxlength,
                        style: normalizeStyle({
                          color: _ctx.textColor,
                          caretColor: !_ctx.errorMessage ? _ctx.focusColor : void 0,
                        }),
                        onFocus:
                          _cache2[4] ||
                          (_cache2[4] = function () {
                            return _ctx.handleFocus && _ctx.handleFocus(...arguments)
                          }),
                        onBlur:
                          _cache2[5] ||
                          (_cache2[5] = function () {
                            return _ctx.handleBlur && _ctx.handleBlur(...arguments)
                          }),
                        onInput:
                          _cache2[6] ||
                          (_cache2[6] = function () {
                            return _ctx.handleInput && _ctx.handleInput(...arguments)
                          }),
                        onChange:
                          _cache2[7] ||
                          (_cache2[7] = function () {
                            return _ctx.handleChange && _ctx.handleChange(...arguments)
                          }),
                      },
                      null,
                      46,
                      _hoisted_2$6
                    )),
                createElementVNode(
                  'label',
                  {
                    class: normalizeClass(
                      _ctx.classes(
                        'var--ellipsis',
                        [_ctx.isFocus, _ctx.n('--focus')],
                        [_ctx.errorMessage, _ctx.n('--error')],
                        [_ctx.textarea, _ctx.n('textarea-placeholder'), _ctx.n('placeholder')],
                        _ctx.computePlaceholderState(),
                        [!_ctx.hint, _ctx.n('--placeholder-non-hint')]
                      )
                    ),
                    style: normalizeStyle({
                      color: !_ctx.errorMessage ? (_ctx.isFocus ? _ctx.focusColor : _ctx.blurColor) : void 0,
                    }),
                    for: _ctx.id,
                  },
                  toDisplayString(_ctx.placeholder),
                  15,
                  _hoisted_3$2
                ),
              ],
              2
            ),
            createElementVNode(
              'div',
              {
                class: normalizeClass(_ctx.classes(_ctx.n('icon'), [!_ctx.hint, _ctx.n('--non-hint')])),
              },
              [
                renderSlot(_ctx.$slots, 'append-icon', {}, () => [
                  _ctx.clearable && !_ctx.isEmpty(_ctx.modelValue)
                    ? (openBlock(),
                      createBlock(
                        _component_var_icon,
                        {
                          key: 0,
                          class: normalizeClass(_ctx.n('clear-icon')),
                          'var-input-cover': '',
                          name: 'close-circle',
                          size: '14px',
                          onClick: _ctx.handleClear,
                        },
                        null,
                        8,
                        ['class', 'onClick']
                      ))
                    : createCommentVNode('v-if', true),
                ]),
              ],
              2
            ),
          ],
          6
        ),
        _ctx.line
          ? (openBlock(),
            createElementBlock(
              'div',
              {
                key: 0,
                class: normalizeClass(
                  _ctx.classes(
                    _ctx.n('line'),
                    [_ctx.formDisabled || _ctx.disabled, _ctx.n('--line-disabled')],
                    [_ctx.errorMessage, _ctx.n('--line-error')]
                  )
                ),
                style: normalizeStyle({
                  background: !_ctx.errorMessage ? _ctx.blurColor : void 0,
                }),
              },
              [
                createElementVNode(
                  'div',
                  {
                    class: normalizeClass(
                      _ctx.classes(
                        _ctx.n('dot'),
                        [_ctx.isFocus, _ctx.n('--spread')],
                        [_ctx.formDisabled || _ctx.disabled, _ctx.n('--line-disabled')],
                        [_ctx.errorMessage, _ctx.n('--line-error')]
                      )
                    ),
                    style: normalizeStyle({
                      background: !_ctx.errorMessage ? _ctx.focusColor : void 0,
                    }),
                  },
                  null,
                  6
                ),
              ],
              6
            ))
          : createCommentVNode('v-if', true),
        createVNode(
          _component_var_form_details,
          {
            'error-message': _ctx.errorMessage,
            'maxlength-text': _ctx.maxlengthText,
          },
          null,
          8,
          ['error-message', 'maxlength-text']
        ),
      ],
      2
    )
  )
}
var Input = defineComponent({
  render: render$q,
  name: 'VarInput',
  components: {
    VarIcon: Icon,
    VarFormDetails: FormDetails,
  },
  props: props$p,
  setup(props2) {
    var id = ref('var-input-' + getCurrentInstance().uid)
    var el = ref(null)
    var isFocus = ref(false)
    var maxlengthText = computed(() => {
      var { maxlength, modelValue } = props2
      if (!maxlength) {
        return ''
      }
      if (isEmpty(modelValue)) {
        return '0 / ' + maxlength
      }
      return String(modelValue).length + '/' + maxlength
    })
    var { bindForm, form } = useForm()
    var { errorMessage, validateWithTrigger: vt, validate: v, resetValidation } = useValidation()
    var validateWithTrigger = (trigger) => {
      nextTick(() => {
        var { validateTrigger, rules, modelValue } = props2
        vt(validateTrigger, trigger, rules, modelValue)
      })
    }
    var computePlaceholderState = () => {
      var { hint, modelValue } = props2
      if (!hint && !isEmpty(modelValue)) {
        return n$t('--placeholder-hidden')
      }
      if (hint && (!isEmpty(modelValue) || isFocus.value)) {
        return n$t('--placeholder-hint')
      }
    }
    var handleFocus = (e) => {
      isFocus.value = true
      call(props2.onFocus, e)
      validateWithTrigger('onFocus')
    }
    var handleBlur = (e) => {
      isFocus.value = false
      call(props2.onBlur, e)
      validateWithTrigger('onBlur')
    }
    var handleInput = (e) => {
      var { value } = e.target
      value = withTrim(value)
      call(props2['onUpdate:modelValue'], value)
      call(props2.onInput, value, e)
      validateWithTrigger('onInput')
    }
    var handleChange = (e) => {
      var { value } = e.target
      call(props2.onChange, withTrim(value), e)
      validateWithTrigger('onChange')
    }
    var handleClear = () => {
      var { disabled, readonly, clearable, onClear } = props2
      if (
        (form != null && form.disabled.value) ||
        (form != null && form.readonly.value) ||
        disabled ||
        readonly ||
        !clearable
      ) {
        return
      }
      call(props2['onUpdate:modelValue'], '')
      call(onClear, '')
      validateWithTrigger('onClear')
    }
    var handleClick = (e) => {
      var { disabled, onClick } = props2
      if ((form != null && form.disabled.value) || disabled) {
        return
      }
      call(onClick, e)
      validateWithTrigger('onClick')
    }
    var withTrim = (value) => (props2.modelModifiers.trim ? value.trim() : value)
    var reset = () => {
      call(props2['onUpdate:modelValue'], '')
      resetValidation()
    }
    var validate2 = () => v(props2.rules, props2.modelValue)
    var focus = () => {
      var _el$value
      ;(_el$value = el.value) == null ? void 0 : _el$value.focus()
    }
    var blur = () => {
      el.value.blur()
    }
    var inputProvider = {
      reset,
      validate: validate2,
      resetValidation,
    }
    call(bindForm, inputProvider)
    onMounted(() => {
      if (props2.autofocus) focus()
    })
    return {
      el,
      id,
      isFocus,
      errorMessage,
      maxlengthText,
      formDisabled: form == null ? void 0 : form.disabled,
      formReadonly: form == null ? void 0 : form.readonly,
      n: n$t,
      classes: classes$o,
      isEmpty,
      computePlaceholderState,
      handleFocus,
      handleBlur,
      handleInput,
      handleChange,
      handleClear,
      handleClick,
      validate: validate2,
      resetValidation,
      reset,
      focus,
      blur,
    }
  },
})
Input.install = function (app) {
  app.component(Input.name, Input)
}
var props$o = {
  loading: {
    type: Boolean,
    default: false,
  },
  immediateCheck: {
    type: Boolean,
    default: true,
  },
  finished: {
    type: Boolean,
    default: false,
  },
  error: {
    type: Boolean,
    default: false,
  },
  offset: {
    type: [String, Number],
    default: 0,
  },
  loadingText: {
    type: String,
  },
  finishedText: {
    type: String,
  },
  errorText: {
    type: String,
  },
  onLoad: {
    type: Function,
  },
  'onUpdate:loading': {
    type: Function,
  },
  'onUpdate:error': {
    type: Function,
  },
}
function asyncGeneratorStep$4(gen, resolve2, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg)
    var value = info.value
  } catch (error) {
    reject(error)
    return
  }
  if (info.done) {
    resolve2(value)
  } else {
    Promise.resolve(value).then(_next, _throw)
  }
}
function _asyncToGenerator$4(fn) {
  return function () {
    var self2 = this,
      args = arguments
    return new Promise(function (resolve2, reject) {
      var gen = fn.apply(self2, args)
      function _next(value) {
        asyncGeneratorStep$4(gen, resolve2, reject, _next, _throw, 'next', value)
      }
      function _throw(err) {
        asyncGeneratorStep$4(gen, resolve2, reject, _next, _throw, 'throw', err)
      }
      _next(void 0)
    })
  }
}
var { n: n$s, classes: classes$n } = createNamespace('list')
function render$p(_ctx, _cache2) {
  var _component_var_loading = resolveComponent('var-loading')
  var _directive_ripple = resolveDirective('ripple')
  return (
    openBlock(),
    createElementBlock(
      'div',
      {
        class: normalizeClass(_ctx.classes(_ctx.n(), 'var--box')),
        ref: 'listEl',
      },
      [
        renderSlot(_ctx.$slots, 'default'),
        _ctx.loading
          ? renderSlot(
              _ctx.$slots,
              'loading',
              {
                key: 0,
              },
              () => [
                createElementVNode(
                  'div',
                  {
                    class: normalizeClass(_ctx.n('loading')),
                  },
                  [
                    createElementVNode(
                      'div',
                      {
                        class: normalizeClass(_ctx.n('loading-text')),
                      },
                      toDisplayString(_ctx.dt(_ctx.loadingText, _ctx.pack.listLoadingText)),
                      3
                    ),
                    createVNode(_component_var_loading, {
                      size: 'mini',
                      radius: 10,
                    }),
                  ],
                  2
                ),
              ]
            )
          : createCommentVNode('v-if', true),
        _ctx.finished
          ? renderSlot(
              _ctx.$slots,
              'finished',
              {
                key: 1,
              },
              () => [
                createElementVNode(
                  'div',
                  {
                    class: normalizeClass(_ctx.n('finished')),
                  },
                  toDisplayString(_ctx.dt(_ctx.finishedText, _ctx.pack.listFinishedText)),
                  3
                ),
              ]
            )
          : createCommentVNode('v-if', true),
        _ctx.error
          ? renderSlot(
              _ctx.$slots,
              'error',
              {
                key: 2,
              },
              () => [
                withDirectives(
                  (openBlock(),
                  createElementBlock(
                    'div',
                    {
                      class: normalizeClass(_ctx.n('error')),
                      onClick:
                        _cache2[0] ||
                        (_cache2[0] = function () {
                          return _ctx.load && _ctx.load(...arguments)
                        }),
                    },
                    [createTextVNode(toDisplayString(_ctx.dt(_ctx.errorText, _ctx.pack.listErrorText)), 1)],
                    2
                  )),
                  [[_directive_ripple]]
                ),
              ]
            )
          : createCommentVNode('v-if', true),
        createElementVNode(
          'div',
          {
            class: normalizeClass(_ctx.n('detector')),
            ref: 'detectorEl',
          },
          null,
          2
        ),
      ],
      2
    )
  )
}
var List = defineComponent({
  render: render$p,
  name: 'VarList',
  directives: {
    Ripple,
  },
  components: {
    VarLoading: Loading,
  },
  props: props$o,
  setup(props2) {
    var listEl = ref(null)
    var detectorEl = ref(null)
    var scroller
    var load = () => {
      call(props2['onUpdate:error'], false)
      call(props2['onUpdate:loading'], true)
      call(props2.onLoad)
    }
    var isReachBottom = () => {
      var containerBottom = scroller === window ? window.innerHeight : scroller.getBoundingClientRect().bottom
      var { bottom: detectorBottom } = detectorEl.value.getBoundingClientRect()
      return Math.floor(detectorBottom) - toPxNum(props2.offset) <= containerBottom
    }
    var check2 = /* @__PURE__ */ (function () {
      var _ref = _asyncToGenerator$4(function* () {
        yield nextTick()
        var { loading: loading2, finished, error } = props2
        if (!loading2 && !finished && !error && isReachBottom()) {
          load()
        }
      })
      return function check3() {
        return _ref.apply(this, arguments)
      }
    })()
    onMounted(() => {
      scroller = getParentScroller(listEl.value)
      props2.immediateCheck && check2()
      scroller.addEventListener('scroll', check2)
    })
    onUnmounted(() => {
      scroller.removeEventListener('scroll', check2)
    })
    return {
      pack,
      listEl,
      detectorEl,
      dt,
      isNumber,
      load,
      check: check2,
      n: n$s,
      classes: classes$n,
    }
  },
})
List.install = function (app) {
  app.component(List.name, List)
}
function alignmentValidator(alignment) {
  return ['top', 'bottom'].includes(alignment)
}
var props$n = {
  show: {
    type: Boolean,
    default: false,
  },
  alignment: {
    type: String,
    default: 'top',
    validator: alignmentValidator,
  },
  offsetX: {
    type: [Number, String],
    default: 0,
  },
  offsetY: {
    type: [Number, String],
    default: 0,
  },
  teleport: {
    type: String,
    default: 'body',
  },
  onOpen: {
    type: Function,
  },
  onOpened: {
    type: Function,
  },
  onClose: {
    type: Function,
  },
  onClosed: {
    type: Function,
  },
  'onUpdate:show': {
    type: Function,
  },
}
function asyncGeneratorStep$3(gen, resolve2, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg)
    var value = info.value
  } catch (error) {
    reject(error)
    return
  }
  if (info.done) {
    resolve2(value)
  } else {
    Promise.resolve(value).then(_next, _throw)
  }
}
function _asyncToGenerator$3(fn) {
  return function () {
    var self2 = this,
      args = arguments
    return new Promise(function (resolve2, reject) {
      var gen = fn.apply(self2, args)
      function _next(value) {
        asyncGeneratorStep$3(gen, resolve2, reject, _next, _throw, 'next', value)
      }
      function _throw(err) {
        asyncGeneratorStep$3(gen, resolve2, reject, _next, _throw, 'throw', err)
      }
      _next(void 0)
    })
  }
}
function _isSlot(s2) {
  return typeof s2 === 'function' || (Object.prototype.toString.call(s2) === '[object Object]' && !isVNode(s2))
}
var { n: n$r, classes: classes$m } = createNamespace('menu')
var Menu = defineComponent({
  name: 'VarMenu',
  props: props$n,
  setup(props2, _ref) {
    var { slots } = _ref
    var host = ref(null)
    var menu = ref(null)
    var to = ref()
    var top = ref(0)
    var left = ref(0)
    var { zIndex } = useZIndex(() => props2.show, 1)
    var { disabled } = useTeleport()
    var clickSelf = false
    var computeTop = (alignment) => {
      return alignment === 'top' ? getTop(host.value) : getTop(host.value) - menu.value.offsetHeight
    }
    var handleClick = () => {
      clickSelf = true
    }
    var handleMenuClose = () => {
      if (clickSelf) {
        clickSelf = false
        return
      }
      if (!props2.show) {
        return
      }
      call(props2['onUpdate:show'], false)
    }
    var resize = () => {
      top.value = computeTop(props2.alignment)
      left.value = getLeft(host.value)
    }
    var transitionStyle = computed(() => {
      return {
        top: 'calc(' + top.value + 'px + ' + toSizeUnit(props2.offsetY) + ')',
        left: 'calc(' + left.value + 'px + ' + toSizeUnit(props2.offsetX) + ')',
        zIndex: zIndex.value,
      }
    })
    var renderTransition = () =>
      createVNode(
        Transition,
        {
          name: n$r(),
          onAfterEnter: props2.onOpened,
          onAfterLeave: props2.onClosed,
        },
        {
          default: () => [
            withDirectives(
              createVNode(
                'div',
                {
                  class: classes$m(n$r('menu'), 'var-elevation--3'),
                  ref: menu,
                  style: transitionStyle.value,
                  onClick: (event) => {
                    event.stopPropagation()
                  },
                },
                [call(slots.menu)]
              ),
              [[vShow, props2.show]]
            ),
          ],
        }
      )
    watch(() => props2.alignment, resize)
    watch(
      () => props2.show,
      /* @__PURE__ */ (function () {
        var _ref2 = _asyncToGenerator$3(function* (newValue) {
          var { onOpen, onClose } = props2
          if (newValue) {
            yield nextTick()
            resize()
          }
          newValue ? call(onOpen) : call(onClose)
        })
        return function (_x) {
          return _ref2.apply(this, arguments)
        }
      })()
    )
    watch(
      () => props2.teleport,
      (newValue) => {
        to.value = newValue
      }
    )
    onMounted(() => {
      to.value = props2.teleport
      resize()
      document.addEventListener('click', handleMenuClose)
      window.addEventListener('resize', resize)
    })
    onUnmounted(() => {
      document.removeEventListener('click', handleMenuClose)
      window.removeEventListener('resize', resize)
    })
    exposeApis({
      resize,
    })
    return () => {
      var _slot
      return createVNode(
        'div',
        {
          class: n$r(),
          ref: host,
          onClick: handleClick,
        },
        [
          call(slots.default),
          to.value
            ? createVNode(
                Teleport,
                {
                  to: to.value,
                  disabled: disabled.value,
                },
                _isSlot((_slot = renderTransition()))
                  ? _slot
                  : {
                      default: () => [_slot],
                    }
              )
            : renderTransition(),
        ]
      )
    }
  },
})
Menu.install = function (app) {
  app.component(Menu.name, Menu)
}
var SELECT_BIND_OPTION_KEY = Symbol('SELECT_BIND_OPTION_KEY')
var SELECT_COUNT_OPTION_KEY = Symbol('SELECT_COUNT_OPTION_KEY')
function useOptions() {
  var { bindChildren, childProviders } = useChildren(SELECT_BIND_OPTION_KEY)
  var { length } = useAtChildrenCounter(SELECT_COUNT_OPTION_KEY)
  return {
    length,
    options: childProviders,
    bindOptions: bindChildren,
  }
}
function useSelect() {
  var { bindParent, parentProvider } = useParent(SELECT_BIND_OPTION_KEY)
  var { index: index2 } = useAtParentIndex(SELECT_COUNT_OPTION_KEY)
  if (!bindParent || !parentProvider) {
    throw Error('<var-option/> must in <var-select/>')
  }
  return {
    index: index2,
    select: parentProvider,
    bindSelect: bindParent,
  }
}
var props$m = {
  label: {},
  value: {},
}
var { n: n$q, classes: classes$l } = createNamespace('option')
function render$o(_ctx, _cache2) {
  var _component_var_checkbox = resolveComponent('var-checkbox')
  var _directive_ripple = resolveDirective('ripple')
  return withDirectives(
    (openBlock(),
    createElementBlock(
      'div',
      {
        class: normalizeClass(_ctx.classes(_ctx.n(), 'var--box', [_ctx.optionSelected, _ctx.n('--selected-color')])),
        style: normalizeStyle({
          width: _ctx.wrapWidth,
          color: _ctx.optionSelected ? _ctx.focusColor : void 0,
        }),
        onClick:
          _cache2[2] ||
          (_cache2[2] = function () {
            return _ctx.handleClick && _ctx.handleClick(...arguments)
          }),
      },
      [
        createElementVNode(
          'div',
          {
            class: normalizeClass(
              _ctx.classes(_ctx.n('cover'), [_ctx.optionSelected, _ctx.n('--selected-background')])
            ),
            style: normalizeStyle({
              background: _ctx.optionSelected ? _ctx.focusColor : void 0,
            }),
          },
          null,
          6
        ),
        _ctx.multiple
          ? (openBlock(),
            createBlock(
              _component_var_checkbox,
              {
                key: 0,
                ref: 'checkbox',
                'checked-color': _ctx.focusColor,
                modelValue: _ctx.optionSelected,
                'onUpdate:modelValue': _cache2[0] || (_cache2[0] = ($event) => (_ctx.optionSelected = $event)),
                onClick: _cache2[1] || (_cache2[1] = withModifiers(() => {}, ['stop'])),
                onChange: _ctx.handleSelect,
              },
              null,
              8,
              ['checked-color', 'modelValue', 'onChange']
            ))
          : createCommentVNode('v-if', true),
        createElementVNode(
          'div',
          {
            class: normalizeClass(_ctx.classes(_ctx.n('text'), 'var--ellipsis')),
          },
          [renderSlot(_ctx.$slots, 'default', {}, () => [createTextVNode(toDisplayString(_ctx.label), 1)])],
          2
        ),
      ],
      6
    )),
    [[_directive_ripple]]
  )
}
var Option = defineComponent({
  render: render$o,
  name: 'VarOption',
  directives: {
    Ripple,
  },
  components: {
    VarCheckbox: Checkbox,
  },
  props: props$m,
  setup(props2) {
    var optionSelected = ref(false)
    var selected = computed(() => optionSelected.value)
    var label = computed(() => props2.label)
    var value = computed(() => props2.value)
    var { select, bindSelect } = useSelect()
    var { wrapWidth, multiple, focusColor, onSelect } = select
    var handleClick = () => {
      optionSelected.value = !optionSelected.value
      onSelect(optionProvider)
    }
    var handleSelect = () => onSelect(optionProvider)
    var sync = (checked) => {
      optionSelected.value = checked
    }
    var optionProvider = {
      label,
      value,
      selected,
      sync,
    }
    watch(
      [() => props2.label, () => props2.value],
      () => {
        if (props2.label == null && props2.value == null) {
          throw Error("Props label and value can't both be undefined\n")
        }
      },
      {
        immediate: true,
      }
    )
    bindSelect(optionProvider)
    return {
      n: n$q,
      classes: classes$l,
      optionSelected,
      wrapWidth,
      multiple,
      focusColor,
      handleClick,
      handleSelect,
    }
  },
})
Option.install = function (app) {
  app.component(Option.name, Option)
}
var props$l = {
  current: {
    type: [Number, String],
  },
  size: {
    type: [Number, String],
    default: 10,
  },
  total: {
    type: [Number, String],
    default: 0,
  },
  maxPagerCount: {
    type: Number,
    default: 3,
  },
  disabled: {
    type: Boolean,
    default: false,
  },
  simple: {
    type: Boolean,
    default: true,
  },
  showSizeChanger: {
    type: Boolean,
    default: true,
  },
  showQuickJumper: {
    type: Boolean,
    default: false,
  },
  sizeOption: {
    type: Array,
    default: () => [10, 20, 50, 100],
  },
  showTotal: {
    type: Function,
  },
  onChange: {
    type: Function,
  },
  'onUpdate:current': {
    type: Function,
  },
  'onUpdate:size': {
    type: Function,
  },
}
var { n: n$p, classes: classes$k } = createNamespace('pagination')
var _hoisted_1$9 = ['item-mode', 'onClick']
function render$n(_ctx, _cache2) {
  var _component_var_icon = resolveComponent('var-icon')
  var _component_var_input = resolveComponent('var-input')
  var _component_var_cell = resolveComponent('var-cell')
  var _component_var_menu = resolveComponent('var-menu')
  var _directive_ripple = resolveDirective('ripple')
  return (
    openBlock(),
    createElementBlock(
      'ul',
      {
        class: normalizeClass(_ctx.n()),
      },
      [
        withDirectives(
          (openBlock(),
          createElementBlock(
            'li',
            {
              class: normalizeClass(
                _ctx.classes(
                  _ctx.n('item'),
                  _ctx.n('prev'),
                  [_ctx.current <= 1 || _ctx.disabled, _ctx.n('item--disabled')],
                  [_ctx.simple, _ctx.n('item--hover'), 'var-elevation--2']
                )
              ),
              onClick: _cache2[0] || (_cache2[0] = ($event) => _ctx.clickItem('prev')),
            },
            [
              renderSlot(_ctx.$slots, 'prev', {}, () => [
                createVNode(_component_var_icon, {
                  name: 'chevron-left',
                }),
              ]),
            ],
            2
          )),
          [
            [
              _directive_ripple,
              {
                disabled: _ctx.current <= 1 || _ctx.disabled,
              },
            ],
          ]
        ),
        _ctx.simple
          ? (openBlock(),
            createElementBlock(
              'li',
              {
                key: 0,
                class: normalizeClass(_ctx.classes(_ctx.n('simple'), [_ctx.disabled, _ctx.n('item--disabled')])),
              },
              [
                createVNode(
                  _component_var_input,
                  {
                    modelValue: _ctx.simpleValue,
                    'onUpdate:modelValue': _cache2[1] || (_cache2[1] = ($event) => (_ctx.simpleValue = $event)),
                    disabled: _ctx.disabled,
                    'var-pagination-cover': '',
                    onBlur: _cache2[2] || (_cache2[2] = ($event) => _ctx.setPage('simple', _ctx.simpleValue, $event)),
                    onKeydown:
                      _cache2[3] ||
                      (_cache2[3] = withKeys(($event) => _ctx.setPage('simple', _ctx.simpleValue, $event), ['enter'])),
                  },
                  null,
                  8,
                  ['modelValue', 'disabled']
                ),
                createElementVNode('span', null, '/ ' + toDisplayString(_ctx.pageCount), 1),
              ],
              2
            ))
          : (openBlock(true),
            createElementBlock(
              Fragment,
              {
                key: 1,
              },
              renderList(_ctx.pageList, (item, index2) => {
                return withDirectives(
                  (openBlock(),
                  createElementBlock(
                    'li',
                    {
                      key: _ctx.toNumber(item) + index2,
                      'item-mode': _ctx.getMode(item, index2),
                      class: normalizeClass(
                        _ctx.classes(
                          _ctx.n('item'),
                          'var-elevation--2',
                          [item === _ctx.current && !_ctx.disabled, _ctx.n('item--active')],
                          [_ctx.isHideEllipsis(item, index2), _ctx.n('item--hide')],
                          [_ctx.disabled, _ctx.n('item--disabled')],
                          [item === _ctx.current && _ctx.disabled, _ctx.n('item--disabled--active')]
                        )
                      ),
                      onClick: ($event) => _ctx.clickItem(item, index2),
                    },
                    [createTextVNode(toDisplayString(item), 1)],
                    10,
                    _hoisted_1$9
                  )),
                  [
                    [
                      _directive_ripple,
                      {
                        disabled: _ctx.disabled,
                      },
                    ],
                  ]
                )
              }),
              128
            )),
        withDirectives(
          (openBlock(),
          createElementBlock(
            'li',
            {
              class: normalizeClass(
                _ctx.classes(
                  _ctx.n('item'),
                  _ctx.n('next'),
                  [_ctx.current >= _ctx.pageCount || _ctx.disabled, _ctx.n('item--disabled')],
                  [_ctx.simple, _ctx.n('item--hover'), 'var-elevation--2']
                )
              ),
              onClick: _cache2[4] || (_cache2[4] = ($event) => _ctx.clickItem('next')),
            },
            [
              renderSlot(_ctx.$slots, 'next', {}, () => [
                createVNode(_component_var_icon, {
                  name: 'chevron-right',
                }),
              ]),
            ],
            2
          )),
          [
            [
              _directive_ripple,
              {
                disabled: _ctx.current >= _ctx.pageCount || _ctx.disabled,
              },
            ],
          ]
        ),
        _ctx.showSizeChanger
          ? (openBlock(),
            createElementBlock(
              'li',
              {
                key: 2,
                class: normalizeClass(_ctx.classes(_ctx.n('size'), [_ctx.disabled, _ctx.n('item--disabled')])),
              },
              [
                createVNode(
                  _component_var_menu,
                  {
                    show: _ctx.menuVisible,
                    'onUpdate:show': _cache2[6] || (_cache2[6] = ($event) => (_ctx.menuVisible = $event)),
                    'offset-x': -4,
                  },
                  {
                    menu: withCtx(() => [
                      (openBlock(true),
                      createElementBlock(
                        Fragment,
                        null,
                        renderList(_ctx.sizeOption, (option, index2) => {
                          return withDirectives(
                            (openBlock(),
                            createBlock(
                              _component_var_cell,
                              {
                                class: normalizeClass(
                                  _ctx.classes(_ctx.n('list'), [_ctx.size === option, _ctx.n('list--active')])
                                ),
                                key: index2,
                                onClick: ($event) => _ctx.clickSize(option),
                              },
                              {
                                default: withCtx(() => [
                                  createTextVNode(
                                    toDisplayString(option) +
                                      toDisplayString(_ctx.pack.paginationItem) +
                                      ' / ' +
                                      toDisplayString(_ctx.pack.paginationPage),
                                    1
                                  ),
                                ]),
                                _: 2,
                              },
                              1032,
                              ['class', 'onClick']
                            )),
                            [[_directive_ripple]]
                          )
                        }),
                        128
                      )),
                    ]),
                    default: withCtx(() => [
                      createElementVNode(
                        'div',
                        {
                          class: normalizeClass(
                            _ctx.classes(_ctx.n('size--open'), [
                              _ctx.current <= 1 || _ctx.disabled,
                              _ctx.n('size--open--disabled'),
                            ])
                          ),
                          onClick:
                            _cache2[5] ||
                            (_cache2[5] = function () {
                              return _ctx.showMenu && _ctx.showMenu(...arguments)
                            }),
                        },
                        [
                          createElementVNode(
                            'span',
                            null,
                            toDisplayString(_ctx.size) +
                              toDisplayString(_ctx.pack.paginationItem) +
                              ' / ' +
                              toDisplayString(_ctx.pack.paginationPage),
                            1
                          ),
                          createVNode(
                            _component_var_icon,
                            {
                              class: normalizeClass(_ctx.n('size--open-icon')),
                              'var-pagination-cover': '',
                              name: 'menu-down',
                            },
                            null,
                            8,
                            ['class']
                          ),
                        ],
                        2
                      ),
                    ]),
                    _: 1,
                  },
                  8,
                  ['show']
                ),
              ],
              2
            ))
          : createCommentVNode('v-if', true),
        _ctx.showQuickJumper && !_ctx.simple
          ? (openBlock(),
            createElementBlock(
              'li',
              {
                key: 3,
                class: normalizeClass(_ctx.classes(_ctx.n('quickly'), [_ctx.disabled, 'item--disabled'])),
              },
              [
                createTextVNode(toDisplayString(_ctx.pack.paginationJump) + ' ', 1),
                createVNode(
                  _component_var_input,
                  {
                    modelValue: _ctx.inputValue,
                    'onUpdate:modelValue': _cache2[7] || (_cache2[7] = ($event) => (_ctx.inputValue = $event)),
                    disabled: _ctx.disabled,
                    'var-pagination-cover': '',
                    onBlur: _cache2[8] || (_cache2[8] = ($event) => _ctx.setPage('quick', _ctx.inputValue, $event)),
                    onKeydown:
                      _cache2[9] ||
                      (_cache2[9] = withKeys(($event) => _ctx.setPage('quick', _ctx.inputValue, $event), ['enter'])),
                  },
                  null,
                  8,
                  ['modelValue', 'disabled']
                ),
              ],
              2
            ))
          : createCommentVNode('v-if', true),
        _ctx.totalText
          ? (openBlock(),
            createElementBlock(
              'li',
              {
                key: 4,
                class: normalizeClass(_ctx.n('total')),
              },
              toDisplayString(_ctx.totalText),
              3
            ))
          : createCommentVNode('v-if', true),
      ],
      2
    )
  )
}
var Pagination = defineComponent({
  render: render$n,
  name: 'VarPagination',
  components: {
    VarMenu: Menu,
    VarIcon: Icon,
    VarCell: Cell,
    VarInput: Input,
  },
  directives: {
    Ripple,
  },
  props: props$l,
  setup(props2) {
    var menuVisible = ref(false)
    var inputValue = ref('')
    var simpleValue = ref('1')
    var isHideEllipsisHead = ref(false)
    var isHideEllipsisTail = ref(false)
    var current = ref(toNumber(props2.current) || 1)
    var size = ref(toNumber(props2.size) || 10)
    var pageList = ref([])
    var activePosition = computed(() => Math.ceil(props2.maxPagerCount / 2))
    var pageCount = computed(() => Math.ceil(toNumber(props2.total) / toNumber(size.value)))
    var range = computed(() => {
      var start = size.value * (current.value - 1) + 1
      var end = Math.min(size.value * current.value, toNumber(props2.total))
      return [start, end]
    })
    var totalText = computed(() => {
      if (!props2.showTotal) return ''
      return props2.showTotal(toNumber(props2.total), range.value)
    })
    var isHideEllipsis = (item, index2) => {
      if (isNumber(item)) return false
      return index2 === 1 ? isHideEllipsisHead.value : isHideEllipsisTail.value
    }
    var getMode = (item, index2) => {
      if (isNumber(item)) return 'basic'
      return index2 === 1 ? 'head' : 'tail'
    }
    var clickItem = (item, index2) => {
      if (item === current.value || props2.disabled) return
      if (isNumber(item)) current.value = item
      else if (item === 'prev') current.value > 1 && (current.value -= 1)
      else if (item === 'next') current.value < pageCount.value && (current.value += 1)
      else if (item === '...') {
        if (index2 === 1) {
          current.value = Math.max(current.value - props2.maxPagerCount, 1)
        } else {
          current.value = Math.min(current.value + props2.maxPagerCount, pageCount.value)
        }
      }
    }
    var showMenu = () => {
      if (props2.disabled) return
      menuVisible.value = true
    }
    var clickSize = (option) => {
      size.value = option
      menuVisible.value = false
    }
    var isValidatePage = (value) => {
      var pattern = /^[1-9][0-9]*$/
      return pattern.test(value)
    }
    var setPage = (type, value, event) => {
      event.target.blur()
      if (isValidatePage(value)) {
        var valueNum = toNumber(value)
        if (valueNum > pageCount.value) {
          valueNum = pageCount.value
          simpleValue.value = '' + valueNum
        }
        if (valueNum !== current.value) current.value = valueNum
      }
      if (type === 'quick') inputValue.value = ''
      if (type === 'simple' && !isValidatePage(value)) simpleValue.value = '' + current.value
    }
    watch([() => props2.current, () => props2.size], (_ref) => {
      var [newCurrent, newSize] = _ref
      current.value = toNumber(newCurrent) || 1
      size.value = toNumber(newSize || 10)
    })
    watch(
      [current, size],
      (_ref2, _ref3) => {
        var _props$onUpdateCurre, _props$onUpdateSize
        var [newCurrent, newSize] = _ref2
        var [oldCurrent, oldSize] = _ref3
        if (newCurrent > pageCount.value) {
          current.value = pageCount.value
          return
        }
        var list2 = []
        var { maxPagerCount, total, onChange } = props2
        var oldCount = Math.ceil(toNumber(total) / toNumber(oldSize))
        var rEllipseSign = pageCount.value - (maxPagerCount - activePosition.value) - 1
        simpleValue.value = '' + newCurrent
        if (pageCount.value - 2 > maxPagerCount) {
          if (oldCurrent === void 0 || pageCount.value !== oldCount) {
            for (var i = 2; i < maxPagerCount + 2; i++) {
              list2.push(i)
            }
          }
          if (newCurrent <= maxPagerCount && newCurrent < rEllipseSign) {
            list2 = []
            for (var _i = 1; _i < maxPagerCount + 1; _i++) {
              list2.push(_i + 1)
            }
            isHideEllipsisHead.value = true
            isHideEllipsisTail.value = false
          }
          if (newCurrent > maxPagerCount && newCurrent < rEllipseSign) {
            list2 = []
            for (var _i2 = 1; _i2 < maxPagerCount + 1; _i2++) {
              list2.push(newCurrent + _i2 - activePosition.value)
            }
            isHideEllipsisHead.value = newCurrent === 2 && maxPagerCount === 1
            isHideEllipsisTail.value = false
          }
          if (newCurrent >= rEllipseSign) {
            list2 = []
            for (var _i3 = 1; _i3 < maxPagerCount + 1; _i3++) {
              list2.push(pageCount.value - (maxPagerCount - _i3) - 1)
            }
            isHideEllipsisHead.value = false
            isHideEllipsisTail.value = true
          }
          list2 = [1, '...', ...list2, '...', pageCount.value]
        } else {
          for (var _i4 = 1; _i4 <= pageCount.value; _i4++) {
            list2.push(_i4)
          }
        }
        pageList.value = list2
        if (oldCurrent !== void 0) onChange == null ? void 0 : onChange(newCurrent, newSize)
        ;(_props$onUpdateCurre = props2['onUpdate:current']) == null
          ? void 0
          : _props$onUpdateCurre.call(props2, newCurrent)
        ;(_props$onUpdateSize = props2['onUpdate:size']) == null ? void 0 : _props$onUpdateSize.call(props2, newSize)
      },
      {
        immediate: true,
      }
    )
    return {
      n: n$p,
      classes: classes$k,
      pack,
      current,
      menuVisible,
      size,
      pageCount,
      pageList,
      inputValue,
      simpleValue,
      totalText,
      getMode,
      isHideEllipsis,
      clickItem,
      showMenu,
      clickSize,
      setPage,
      toNumber,
    }
  },
})
Pagination.install = function (app) {
  app.component(Pagination.name, Pagination)
}
function _extends$1() {
  _extends$1 =
    Object.assign ||
    function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i]
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key]
          }
        }
      }
      return target
    }
  return _extends$1.apply(this, arguments)
}
var props$k = _extends$1(
  {
    columns: {
      type: Array,
      default: () => [],
    },
    title: {
      type: String,
    },
    textKey: {
      type: String,
      default: 'text',
    },
    toolbar: {
      type: Boolean,
      default: true,
    },
    cascade: {
      type: Boolean,
      default: false,
    },
    cascadeInitialIndexes: {
      type: Array,
      default: () => [],
    },
    optionHeight: {
      type: [Number, String],
      default: 44,
    },
    optionCount: {
      type: [Number, String],
      default: 6,
    },
    confirmButtonText: {
      type: String,
    },
    cancelButtonText: {
      type: String,
    },
    confirmButtonTextColor: {
      type: String,
    },
    cancelButtonTextColor: {
      type: String,
    },
    dynamic: {
      type: Boolean,
      default: false,
    },
    onChange: {
      type: Function,
    },
    onConfirm: {
      type: Function,
    },
    onCancel: {
      type: Function,
    },
    textFormatter: {
      type: Function,
      default: (text) => text,
    },
  },
  pickProps(props$U, [
    'show',
    'onUpdate:show',
    'closeOnClickOverlay',
    'teleport',
    'onOpen',
    'onClose',
    'onOpened',
    'onClosed',
    'onClickOverlay',
    'onRouteChange',
  ])
)
var { n: n$o, classes: classes$j } = createNamespace('picker')
var MOMENTUM_RECORD_TIME = 300
var MOMENTUM_ALLOW_DISTANCE = 15
var sid = 0
var _hoisted_1$8 = ['onTouchstart', 'onTouchmove', 'onTouchend']
var _hoisted_2$5 = ['onTransitionend']
function render$m(_ctx, _cache2) {
  var _component_var_button = resolveComponent('var-button')
  return (
    openBlock(),
    createBlock(
      resolveDynamicComponent(_ctx.dynamic ? 'var-popup' : _ctx.Transition),
      mergeProps(
        _ctx.dynamic
          ? {
              onOpen: _ctx.onOpen,
              onOpened: _ctx.onOpened,
              onClose: _ctx.onClose,
              onClosed: _ctx.onClosed,
              onClickOverlay: _ctx.onClickOverlay,
              onRouteChange: _ctx.onRouteChange,
              closeOnClickOverlay: _ctx.closeOnClickOverlay,
              teleport: _ctx.teleport,
              show: _ctx.show,
              'onUpdate:show': _ctx.handlePopupUpdateShow,
              position: 'bottom',
              class: _ctx.n('popup'),
            }
          : null,
        {
          'var-picker-cover': '',
        }
      ),
      {
        default: withCtx(() => [
          createElementVNode(
            'div',
            mergeProps(
              {
                class: _ctx.n(),
              },
              _ctx.$attrs
            ),
            [
              createElementVNode(
                'div',
                {
                  class: normalizeClass(_ctx.n('toolbar')),
                },
                [
                  renderSlot(_ctx.$slots, 'cancel', {}, () => [
                    createVNode(
                      _component_var_button,
                      {
                        class: normalizeClass(_ctx.n('cancel-button')),
                        'var-picker-cover': '',
                        text: '',
                        'text-color': _ctx.cancelButtonTextColor,
                        onClick: _ctx.cancel,
                      },
                      {
                        default: withCtx(() => [
                          createTextVNode(
                            toDisplayString(_ctx.dt(_ctx.cancelButtonText, _ctx.pack.pickerCancelButtonText)),
                            1
                          ),
                        ]),
                        _: 1,
                      },
                      8,
                      ['class', 'text-color', 'onClick']
                    ),
                  ]),
                  renderSlot(_ctx.$slots, 'title', {}, () => [
                    createElementVNode(
                      'div',
                      {
                        class: normalizeClass(_ctx.n('title')),
                      },
                      toDisplayString(_ctx.dt(_ctx.title, _ctx.pack.pickerTitle)),
                      3
                    ),
                  ]),
                  renderSlot(_ctx.$slots, 'confirm', {}, () => [
                    createVNode(
                      _component_var_button,
                      {
                        class: normalizeClass(_ctx.n('confirm-button')),
                        text: '',
                        'var-picker-cover': '',
                        'text-color': _ctx.confirmButtonTextColor,
                        onClick: _ctx.confirm,
                      },
                      {
                        default: withCtx(() => [
                          createTextVNode(
                            toDisplayString(_ctx.dt(_ctx.confirmButtonText, _ctx.pack.pickerConfirmButtonText)),
                            1
                          ),
                        ]),
                        _: 1,
                      },
                      8,
                      ['class', 'text-color', 'onClick']
                    ),
                  ]),
                ],
                2
              ),
              createElementVNode(
                'div',
                {
                  class: normalizeClass(_ctx.n('columns')),
                  style: normalizeStyle({
                    height: _ctx.columnHeight + 'px',
                  }),
                },
                [
                  (openBlock(true),
                  createElementBlock(
                    Fragment,
                    null,
                    renderList(_ctx.scrollColumns, (c) => {
                      return (
                        openBlock(),
                        createElementBlock(
                          'div',
                          {
                            class: normalizeClass(_ctx.n('column')),
                            key: c.id,
                            onTouchstart: ($event) => _ctx.handleTouchstart($event, c),
                            onTouchmove: withModifiers(($event) => _ctx.handleTouchmove($event, c), ['prevent']),
                            onTouchend: ($event) => _ctx.handleTouchend($event, c),
                          },
                          [
                            createElementVNode(
                              'div',
                              {
                                class: normalizeClass(_ctx.n('scroller')),
                                ref_for: true,
                                ref: (el) => _ctx.getScrollEl(el, c),
                                style: normalizeStyle({
                                  transform: 'translateY(' + c.translate + 'px)',
                                  transitionDuration: c.duration + 'ms',
                                  transitionProperty: c.duration ? 'transform' : 'none',
                                }),
                                onTransitionend: ($event) => _ctx.handleTransitionend(c),
                              },
                              [
                                (openBlock(true),
                                createElementBlock(
                                  Fragment,
                                  null,
                                  renderList(c.column.texts, (t2) => {
                                    return (
                                      openBlock(),
                                      createElementBlock(
                                        'div',
                                        {
                                          class: normalizeClass(_ctx.n('option')),
                                          style: normalizeStyle({
                                            height: _ctx.optionHeight + 'px',
                                          }),
                                          key: t2,
                                        },
                                        [
                                          createElementVNode(
                                            'div',
                                            {
                                              class: normalizeClass(_ctx.n('text')),
                                            },
                                            toDisplayString(_ctx.textFormatter(t2, c.columnIndex)),
                                            3
                                          ),
                                        ],
                                        6
                                      )
                                    )
                                  }),
                                  128
                                )),
                              ],
                              46,
                              _hoisted_2$5
                            ),
                          ],
                          42,
                          _hoisted_1$8
                        )
                      )
                    }),
                    128
                  )),
                  createElementVNode(
                    'div',
                    {
                      class: normalizeClass(_ctx.n('picked')),
                      style: normalizeStyle({
                        top: _ctx.center + 'px',
                        height: _ctx.optionHeight + 'px',
                      }),
                    },
                    null,
                    6
                  ),
                  createElementVNode(
                    'div',
                    {
                      class: normalizeClass(_ctx.n('mask')),
                      style: normalizeStyle({
                        backgroundSize: '100% ' + (_ctx.columnHeight - _ctx.optionHeight) / 2 + 'px',
                      }),
                    },
                    null,
                    6
                  ),
                ],
                6
              ),
            ],
            16
          ),
        ]),
        _: 3,
      },
      16
    )
  )
}
var VarPicker = defineComponent({
  render: render$m,
  name: 'VarPicker',
  components: {
    VarButton: Button,
    VarPopup: Popup,
  },
  inheritAttrs: false,
  props: props$k,
  setup(props2) {
    var scrollColumns = ref([])
    var optionHeight = computed(() => toPxNum(props2.optionHeight))
    var optionCount = computed(() => toPxNum(props2.optionCount))
    var center = computed(() => (optionCount.value * optionHeight.value) / 2 - optionHeight.value / 2)
    var columnHeight = computed(() => optionCount.value * optionHeight.value)
    var prevIndexes = []
    var getScrollEl = (el, scrollColumn) => {
      scrollColumn.scrollEl = el
    }
    var handlePopupUpdateShow = (value) => {
      call(props2['onUpdate:show'], value)
    }
    var limitTranslate = (scrollColumn) => {
      var START_LIMIT = optionHeight.value + center.value
      var END_LIMIT = center.value - scrollColumn.column.texts.length * optionHeight.value
      if (scrollColumn.translate >= START_LIMIT) {
        scrollColumn.translate = START_LIMIT
      }
      if (scrollColumn.translate <= END_LIMIT) {
        scrollColumn.translate = END_LIMIT
      }
    }
    var boundaryIndex = (scrollColumn, index2) => {
      var { length } = scrollColumn.column.texts
      index2 = index2 >= length ? length - 1 : index2
      index2 = index2 <= 0 ? 0 : index2
      return index2
    }
    var getIndex = (scrollColumn) => {
      var index2 = Math.round((center.value - scrollColumn.translate) / optionHeight.value)
      return boundaryIndex(scrollColumn, index2)
    }
    var getPicked = () => {
      var texts = scrollColumns.value.map((scrollColumn) => scrollColumn.column.texts[scrollColumn.index])
      var indexes = scrollColumns.value.map((scrollColumn) => scrollColumn.index)
      return {
        texts,
        indexes,
      }
    }
    var scrollTo2 = function (scrollColumn, index2, duration, noEmit) {
      if (noEmit === void 0) {
        noEmit = false
      }
      var translate = center.value - boundaryIndex(scrollColumn, index2) * optionHeight.value
      if (translate === scrollColumn.translate) {
        scrollColumn.scrolling = false
        !noEmit && change(scrollColumn)
      }
      scrollColumn.translate = translate
      scrollColumn.duration = duration
    }
    var momentum = (scrollColumn, distance, duration) => {
      scrollColumn.translate += (Math.abs(distance / duration) / 3e-3) * (distance < 0 ? -1 : 1)
    }
    var handleTouchstart = (event, scrollColumn) => {
      scrollColumn.touching = true
      scrollColumn.scrolling = false
      scrollColumn.duration = 0
      scrollColumn.translate = getTranslate(scrollColumn.scrollEl)
    }
    var handleTouchmove = (event, scrollColumn) => {
      if (!scrollColumn.touching) {
        return
      }
      var { clientY } = event.touches[0]
      var moveY = scrollColumn.prevY !== void 0 ? clientY - scrollColumn.prevY : 0
      scrollColumn.prevY = clientY
      scrollColumn.translate += moveY
      limitTranslate(scrollColumn)
      var now = performance.now()
      if (now - scrollColumn.momentumTime > MOMENTUM_RECORD_TIME) {
        scrollColumn.momentumTime = now
        scrollColumn.momentumPrevY = scrollColumn.translate
      }
    }
    var handleTouchend = (event, scrollColumn) => {
      scrollColumn.touching = false
      scrollColumn.scrolling = true
      scrollColumn.prevY = void 0
      var distance = scrollColumn.translate - scrollColumn.momentumPrevY
      var duration = performance.now() - scrollColumn.momentumTime
      var shouldMomentum = Math.abs(distance) >= MOMENTUM_ALLOW_DISTANCE && duration <= MOMENTUM_RECORD_TIME
      shouldMomentum && momentum(scrollColumn, distance, duration)
      scrollColumn.index = getIndex(scrollColumn)
      scrollTo2(scrollColumn, scrollColumn.index, shouldMomentum ? 1e3 : 200)
    }
    var handleTransitionend = (scrollColumn) => {
      scrollColumn.scrolling = false
      change(scrollColumn)
    }
    var normalizeNormalColumns = (normalColumns) => {
      return normalColumns.map((column, columnIndex) => {
        var _normalColumn$initial
        var normalColumn = isArray$1(column)
          ? {
              texts: column,
            }
          : column
        var scrollColumn = {
          id: sid++,
          prevY: void 0,
          momentumPrevY: void 0,
          touching: false,
          translate: center.value,
          index: (_normalColumn$initial = normalColumn.initialIndex) != null ? _normalColumn$initial : 0,
          columnIndex,
          duration: 0,
          momentumTime: 0,
          column: normalColumn,
          scrollEl: null,
          scrolling: false,
        }
        scrollTo2(scrollColumn, scrollColumn.index, 0, true)
        return scrollColumn
      })
    }
    var normalizeCascadeColumns = (cascadeColumns) => {
      var scrollColumns2 = []
      createChildren(scrollColumns2, cascadeColumns, 0, true)
      return scrollColumns2
    }
    var createChildren = function (scrollColumns2, children, columnIndex, initial) {
      if (initial === void 0) {
        initial = false
      }
      if (isArray$1(children) && children.length) {
        var _props$cascadeInitial
        var index2 = initial
          ? (_props$cascadeInitial = props2.cascadeInitialIndexes[scrollColumns2.length]) != null
            ? _props$cascadeInitial
            : 0
          : 0
        var scrollColumn = {
          id: sid++,
          prevY: void 0,
          momentumPrevY: void 0,
          touching: false,
          translate: center.value,
          index: index2,
          columnIndex,
          duration: 0,
          momentumTime: 0,
          column: {
            texts: children.map((cascadeColumn) => cascadeColumn[props2.textKey]),
          },
          columns: children,
          scrollEl: null,
          scrolling: false,
        }
        scrollColumns2.push(scrollColumn)
        scrollTo2(scrollColumn, scrollColumn.index, 0, true)
        createChildren(scrollColumns2, scrollColumn.columns[scrollColumn.index].children, columnIndex + 1, initial)
      }
    }
    var rebuildChildren = (scrollColumn) => {
      scrollColumns.value.splice(scrollColumns.value.indexOf(scrollColumn) + 1)
      createChildren(
        scrollColumns.value,
        scrollColumn.columns[scrollColumn.index].children,
        scrollColumn.columnIndex + 1
      )
    }
    var change = (scrollColumn) => {
      var { cascade, onChange } = props2
      cascade && rebuildChildren(scrollColumn)
      var hasScrolling = scrollColumns.value.some((scrollColumn2) => scrollColumn2.scrolling)
      if (hasScrolling) {
        return
      }
      var { texts, indexes } = getPicked()
      var samePicked = indexes.every((index2, idx) => index2 === prevIndexes[idx])
      if (samePicked) {
        return
      }
      prevIndexes = [...indexes]
      call(onChange, texts, indexes)
    }
    var stopScroll = () => {
      if (props2.cascade) {
        var currentScrollColumn = scrollColumns.value.find((scrollColumn) => scrollColumn.scrolling)
        if (currentScrollColumn) {
          currentScrollColumn.translate = getTranslate(currentScrollColumn.scrollEl)
          currentScrollColumn.index = getIndex(currentScrollColumn)
          scrollTo2(currentScrollColumn, currentScrollColumn.index, 0, true)
          currentScrollColumn.scrolling = false
          rebuildChildren(currentScrollColumn)
        }
      } else {
        scrollColumns.value.forEach((scrollColumn) => {
          scrollColumn.translate = getTranslate(scrollColumn.scrollEl)
          scrollColumn.index = getIndex(scrollColumn)
          scrollTo2(scrollColumn, scrollColumn.index, 0)
        })
      }
    }
    var confirm = () => {
      stopScroll()
      var { texts, indexes } = getPicked()
      prevIndexes = [...indexes]
      call(props2.onConfirm, texts, indexes)
    }
    var cancel = () => {
      stopScroll()
      var { texts, indexes } = getPicked()
      prevIndexes = [...indexes]
      call(props2.onCancel, texts, indexes)
    }
    watch(
      () => props2.columns,
      (newValue) => {
        scrollColumns.value = props2.cascade
          ? normalizeCascadeColumns(toRaw(newValue))
          : normalizeNormalColumns(toRaw(newValue))
        var { indexes } = getPicked()
        prevIndexes = [...indexes]
      },
      {
        immediate: true,
        deep: true,
      }
    )
    return {
      n: n$o,
      classes: classes$j,
      pack,
      optionHeight,
      optionCount,
      scrollColumns,
      columnHeight,
      center,
      Transition,
      getScrollEl,
      handlePopupUpdateShow,
      handleTouchstart,
      handleTouchmove,
      handleTouchend,
      handleTransitionend,
      confirm,
      cancel,
      dt,
    }
  },
})
VarPicker.install = function (app) {
  app.component(VarPicker.name, VarPicker)
}
function modeValidator(mode) {
  return ['linear', 'circle'].includes(mode)
}
var props$j = {
  mode: {
    type: String,
    default: 'linear',
    validator: modeValidator,
  },
  lineWidth: {
    type: [Number, String],
    default: 4,
  },
  color: {
    type: String,
  },
  trackColor: {
    type: String,
  },
  ripple: {
    type: Boolean,
    default: false,
  },
  value: {
    type: [Number, String],
    default: 0,
  },
  label: {
    type: Boolean,
    default: false,
  },
  size: {
    type: [Number, String],
    default: 40,
  },
  rotate: {
    type: Number,
    default: 0,
  },
  track: {
    type: Boolean,
    default: true,
  },
}
var { n: n$n, classes: classes$i } = createNamespace('progress')
var _hoisted_1$7 = ['viewBox']
var _hoisted_2$4 = ['cx', 'cy', 'r', 'stroke-width']
var _hoisted_3$1 = ['cx', 'cy', 'r', 'stroke-width']
function render$l(_ctx, _cache2) {
  return (
    openBlock(),
    createElementBlock(
      'div',
      {
        class: normalizeClass(_ctx.n()),
      },
      [
        _ctx.mode === 'linear'
          ? (openBlock(),
            createElementBlock(
              'div',
              {
                key: 0,
                class: normalizeClass(_ctx.n('linear')),
              },
              [
                createElementVNode(
                  'div',
                  mergeProps(
                    {
                      class: _ctx.n('linear-block'),
                      style: {
                        height: _ctx.toSizeUnit(_ctx.lineWidth),
                      },
                    },
                    _ctx.$attrs
                  ),
                  [
                    _ctx.track
                      ? (openBlock(),
                        createElementBlock(
                          'div',
                          {
                            key: 0,
                            class: normalizeClass(_ctx.n('linear-background')),
                            style: normalizeStyle({
                              background: _ctx.trackColor,
                            }),
                          },
                          null,
                          6
                        ))
                      : createCommentVNode('v-if', true),
                    createElementVNode(
                      'div',
                      {
                        class: normalizeClass(
                          _ctx.classes(_ctx.n('linear-certain'), [_ctx.ripple, _ctx.n('linear-ripple')])
                        ),
                        style: normalizeStyle({
                          background: _ctx.color,
                          width: _ctx.linearProps.width,
                        }),
                      },
                      null,
                      6
                    ),
                  ],
                  16
                ),
                _ctx.label
                  ? (openBlock(),
                    createElementBlock(
                      'div',
                      mergeProps(
                        {
                          key: 0,
                          class: _ctx.n('linear-label'),
                        },
                        _ctx.$attrs
                      ),
                      [
                        renderSlot(_ctx.$slots, 'default', {}, () => [
                          createTextVNode(toDisplayString(_ctx.linearProps.roundValue), 1),
                        ]),
                      ],
                      16
                    ))
                  : createCommentVNode('v-if', true),
              ],
              2
            ))
          : createCommentVNode('v-if', true),
        _ctx.mode === 'circle'
          ? (openBlock(),
            createElementBlock(
              'div',
              {
                key: 1,
                class: normalizeClass(_ctx.n('circle')),
                style: normalizeStyle({
                  width: _ctx.toSizeUnit(_ctx.size),
                  height: _ctx.toSizeUnit(_ctx.size),
                }),
              },
              [
                (openBlock(),
                createElementBlock(
                  'svg',
                  {
                    class: normalizeClass(_ctx.n('circle-svg')),
                    style: normalizeStyle({
                      transform: 'rotate(' + (_ctx.rotate - 90) + 'deg)',
                    }),
                    viewBox: _ctx.circleProps.viewBox,
                  },
                  [
                    _ctx.track
                      ? (openBlock(),
                        createElementBlock(
                          'circle',
                          {
                            key: 0,
                            class: normalizeClass(_ctx.n('circle-background')),
                            cx: _ctx.multiplySizeUnit(_ctx.size, 0.5),
                            cy: _ctx.multiplySizeUnit(_ctx.size, 0.5),
                            r: _ctx.circleProps.radius,
                            fill: 'transparent',
                            'stroke-width': _ctx.toSizeUnit(_ctx.lineWidth),
                            style: normalizeStyle({
                              strokeDasharray: _ctx.circleProps.perimeter,
                              stroke: _ctx.trackColor,
                            }),
                          },
                          null,
                          14,
                          _hoisted_2$4
                        ))
                      : createCommentVNode('v-if', true),
                    createElementVNode(
                      'circle',
                      {
                        class: normalizeClass(_ctx.n('circle-certain')),
                        cx: _ctx.multiplySizeUnit(_ctx.size, 0.5),
                        cy: _ctx.multiplySizeUnit(_ctx.size, 0.5),
                        r: _ctx.circleProps.radius,
                        fill: 'transparent',
                        'stroke-width': _ctx.toSizeUnit(_ctx.lineWidth),
                        style: normalizeStyle({
                          strokeDasharray: _ctx.circleProps.strokeDasharray,
                          stroke: _ctx.color,
                        }),
                      },
                      null,
                      14,
                      _hoisted_3$1
                    ),
                  ],
                  14,
                  _hoisted_1$7
                )),
                _ctx.label
                  ? (openBlock(),
                    createElementBlock(
                      'div',
                      mergeProps(
                        {
                          key: 0,
                          class: _ctx.n('circle-label'),
                        },
                        _ctx.$attrs
                      ),
                      [
                        renderSlot(_ctx.$slots, 'default', {}, () => [
                          createTextVNode(toDisplayString(_ctx.circleProps.roundValue), 1),
                        ]),
                      ],
                      16
                    ))
                  : createCommentVNode('v-if', true),
              ],
              6
            ))
          : createCommentVNode('v-if', true),
      ],
      2
    )
  )
}
var Progress = defineComponent({
  render: render$l,
  name: 'VarProgress',
  inheritAttrs: false,
  props: props$j,
  setup(props2) {
    var linearProps = computed(() => {
      var value = toNumber(props2.value)
      var width = value > 100 ? 100 : value
      var roundValue = value > 100 ? 100 : Math.round(value)
      return {
        width: width + '%',
        roundValue: roundValue + '%',
      }
    })
    var circleProps = computed(() => {
      var { size, lineWidth, value } = props2
      var viewBox = '0 0 ' + toPxNum(size) + ' ' + toPxNum(size)
      var roundValue = toNumber(value) > 100 ? 100 : Math.round(toNumber(value))
      var radius = (toPxNum(size) - toPxNum(lineWidth)) / 2
      var perimeter = 2 * Math.PI * radius
      var strokeDasharray = (roundValue / 100) * perimeter + ', ' + perimeter
      return {
        viewBox,
        radius,
        strokeDasharray,
        perimeter,
        roundValue: roundValue + '%',
      }
    })
    return {
      n: n$n,
      classes: classes$i,
      toSizeUnit,
      multiplySizeUnit,
      linearProps,
      circleProps,
    }
  },
})
Progress.install = function (app) {
  app.component(Progress.name, Progress)
}
var props$i = {
  modelValue: {
    type: Boolean,
  },
  disabled: {
    type: Boolean,
    default: false,
  },
  animationDuration: {
    type: [Number, String],
    default: 300,
  },
  successDuration: {
    type: [Number, String],
    default: 2e3,
  },
  bgColor: {
    type: String,
  },
  successBgColor: {
    type: String,
  },
  color: {
    type: String,
  },
  successColor: {
    type: String,
  },
  onRefresh: {
    type: Function,
  },
  'onUpdate:modelValue': {
    type: Function,
  },
}
function asyncGeneratorStep$2(gen, resolve2, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg)
    var value = info.value
  } catch (error) {
    reject(error)
    return
  }
  if (info.done) {
    resolve2(value)
  } else {
    Promise.resolve(value).then(_next, _throw)
  }
}
function _asyncToGenerator$2(fn) {
  return function () {
    var self2 = this,
      args = arguments
    return new Promise(function (resolve2, reject) {
      var gen = fn.apply(self2, args)
      function _next(value) {
        asyncGeneratorStep$2(gen, resolve2, reject, _next, _throw, 'next', value)
      }
      function _throw(err) {
        asyncGeneratorStep$2(gen, resolve2, reject, _next, _throw, 'throw', err)
      }
      _next(void 0)
    })
  }
}
var { n: n$m, classes: classes$h } = createNamespace('pull-refresh')
var MAX_DISTANCE = 100
var CONTROL_POSITION = -50
var ICON_TRANSITION = 150
function render$k(_ctx, _cache2) {
  var _component_var_icon = resolveComponent('var-icon')
  return (
    openBlock(),
    createElementBlock(
      'div',
      {
        ref: 'freshNode',
        class: normalizeClass(_ctx.n()),
        onTouchstart:
          _cache2[0] ||
          (_cache2[0] = function () {
            return _ctx.touchStart && _ctx.touchStart(...arguments)
          }),
        onTouchmove:
          _cache2[1] ||
          (_cache2[1] = function () {
            return _ctx.touchMove && _ctx.touchMove(...arguments)
          }),
        onTouchend:
          _cache2[2] ||
          (_cache2[2] = function () {
            return _ctx.touchEnd && _ctx.touchEnd(...arguments)
          }),
        onTouchcancel:
          _cache2[3] ||
          (_cache2[3] = function () {
            return _ctx.touchEnd && _ctx.touchEnd(...arguments)
          }),
      },
      [
        createElementVNode(
          'div',
          {
            class: normalizeClass(
              _ctx.classes(_ctx.n('control'), 'var-elevation--2', [_ctx.isSuccess, _ctx.n('control-success')])
            ),
            style: normalizeStyle(_ctx.controlStyle),
          },
          [
            createVNode(
              _component_var_icon,
              {
                name: _ctx.iconName,
                transition: _ctx.ICON_TRANSITION,
                class: normalizeClass(
                  _ctx.classes(_ctx.n('icon'), [
                    _ctx.refreshStatus === 'loading' && _ctx.iconHasChanged,
                    _ctx.n('animation'),
                  ])
                ),
                'var-pull-refresh-cover': '',
              },
              null,
              8,
              ['name', 'transition', 'class']
            ),
          ],
          6
        ),
        renderSlot(_ctx.$slots, 'default'),
      ],
      34
    )
  )
}
var PullRefresh = defineComponent({
  render: render$k,
  name: 'VarPullRefresh',
  components: {
    VarIcon: Icon,
  },
  props: props$i,
  setup(props2) {
    var scroller
    var changing
    var freshNode = ref(null)
    var startPosition = ref(0)
    var distance = ref(CONTROL_POSITION)
    var iconName = ref('arrow-down')
    var refreshStatus = ref('default')
    var isEnd = ref(false)
    var iconHasChanged = ref(true)
    var isTouchable = computed(
      () => refreshStatus.value !== 'loading' && refreshStatus.value !== 'success' && !props2.disabled
    )
    var controlStyle = computed(() => ({
      transform: 'translate3d(0px, ' + distance.value + 'px, 0px) translate(-50%, 0)',
      transition: isEnd.value ? 'transform ' + props2.animationDuration + 'ms' : void 0,
      background: props2.successBgColor || props2.bgColor,
      color: props2.successColor || props2.color,
    }))
    var isSuccess = computed(() => refreshStatus.value === 'success')
    var changeIcon = () => {
      return new Promise((resolve2) => {
        window.setTimeout(() => {
          iconHasChanged.value = true
          resolve2()
        }, ICON_TRANSITION)
      })
    }
    var touchStart = (event) => {
      if (!isTouchable.value) return
      refreshStatus.value = 'pulling'
      startPosition.value = event.touches[0].clientY
    }
    var touchMove = (event) => {
      var scrollTop = getScrollTop(scroller)
      if (scrollTop > 0 || !isTouchable.value) return
      if (scrollTop === 0 && distance.value > CONTROL_POSITION) event.cancelable && event.preventDefault()
      var moveDistance = (event.touches[0].clientY - startPosition.value) / 2 + CONTROL_POSITION
      distance.value = moveDistance >= MAX_DISTANCE ? MAX_DISTANCE : moveDistance
      if (distance.value >= MAX_DISTANCE * 0.2) {
        iconHasChanged.value = false
        iconName.value = 'refresh'
        changing = changeIcon()
      } else {
        iconName.value = 'arrow-down'
      }
    }
    var touchEnd = /* @__PURE__ */ (function () {
      var _ref = _asyncToGenerator$2(function* () {
        if (!isTouchable.value) return
        isEnd.value = true
        if (distance.value >= MAX_DISTANCE * 0.2) {
          var _props$onUpdateModel
          yield changing
          refreshStatus.value = 'loading'
          distance.value = MAX_DISTANCE * 0.3
          ;(_props$onUpdateModel = props2['onUpdate:modelValue']) == null
            ? void 0
            : _props$onUpdateModel.call(props2, true)
          props2.onRefresh == null ? void 0 : props2.onRefresh()
        } else {
          refreshStatus.value = 'loosing'
          iconName.value = 'arrow-down'
          distance.value = CONTROL_POSITION
          setTimeout(() => {
            isEnd.value = false
          }, toNumber(props2.animationDuration))
        }
      })
      return function touchEnd2() {
        return _ref.apply(this, arguments)
      }
    })()
    var reset = () => {
      setTimeout(() => {
        refreshStatus.value = 'default'
        iconName.value = 'arrow-down'
        isEnd.value = false
      }, toNumber(props2.animationDuration))
    }
    watch(
      () => props2.modelValue,
      (newValue) => {
        if (newValue === false) {
          isEnd.value = true
          refreshStatus.value = 'success'
          iconName.value = 'checkbox-marked-circle'
          setTimeout(() => {
            distance.value = CONTROL_POSITION
            reset()
          }, toNumber(props2.successDuration))
        }
      }
    )
    onMounted(() => {
      scroller = getParentScroller(freshNode.value)
    })
    return {
      n: n$m,
      classes: classes$h,
      iconHasChanged,
      ICON_TRANSITION,
      refreshStatus,
      freshNode,
      touchStart,
      touchMove,
      touchEnd,
      iconName,
      controlStyle,
      isSuccess,
    }
  },
})
PullRefresh.install = function (app) {
  app.component(PullRefresh.name, PullRefresh)
}
var props$h = {
  modelValue: {
    type: [String, Number, Boolean, Object, Array],
    default: false,
  },
  checkedValue: {
    type: [String, Number, Boolean, Object, Array],
    default: true,
  },
  uncheckedValue: {
    type: [String, Number, Boolean, Object, Array],
    default: false,
  },
  disabled: {
    type: Boolean,
    default: false,
  },
  readonly: {
    type: Boolean,
    default: false,
  },
  checkedColor: {
    type: String,
  },
  uncheckedColor: {
    type: String,
  },
  iconSize: {
    type: [String, Number],
  },
  ripple: {
    type: Boolean,
    default: true,
  },
  validateTrigger: {
    type: Array,
    default: () => ['onChange'],
  },
  rules: {
    type: Array,
  },
  onClick: {
    type: Function,
  },
  onChange: {
    type: Function,
  },
  'onUpdate:modelValue': {
    type: Function,
  },
}
var RADIO_GROUP_BIND_RADIO_KEY = Symbol('RADIO_GROUP_BIND_RADIO_KEY')
var RADIO_GROUP_COUNT_RADIO_KEY = Symbol('RADIO_GROUP_COUNT_RADIO_KEY')
function useRadios() {
  var { bindChildren, childProviders } = useChildren(RADIO_GROUP_BIND_RADIO_KEY)
  var { length } = useAtChildrenCounter(RADIO_GROUP_COUNT_RADIO_KEY)
  return {
    length,
    radios: childProviders,
    bindRadios: bindChildren,
  }
}
function useRadioGroup() {
  var { bindParent, parentProvider } = useParent(RADIO_GROUP_BIND_RADIO_KEY)
  var { index: index2 } = useAtParentIndex(RADIO_GROUP_COUNT_RADIO_KEY)
  return {
    index: index2,
    radioGroup: parentProvider,
    bindRadioGroup: bindParent,
  }
}
var { n: n$l, classes: classes$g } = createNamespace('radio')
function render$j(_ctx, _cache2) {
  var _component_var_icon = resolveComponent('var-icon')
  var _component_var_form_details = resolveComponent('var-form-details')
  var _directive_ripple = resolveDirective('ripple')
  return (
    openBlock(),
    createElementBlock(
      'div',
      {
        class: normalizeClass(_ctx.n('wrap')),
      },
      [
        createElementVNode(
          'div',
          mergeProps(
            {
              class: _ctx.n(),
              onClick:
                _cache2[0] ||
                (_cache2[0] = function () {
                  return _ctx.handleClick && _ctx.handleClick(...arguments)
                }),
            },
            _ctx.$attrs
          ),
          [
            withDirectives(
              (openBlock(),
              createElementBlock(
                'div',
                {
                  class: normalizeClass(
                    _ctx.classes(
                      _ctx.n('action'),
                      [_ctx.checked, _ctx.n('--checked'), _ctx.n('--unchecked')],
                      [_ctx.errorMessage || _ctx.radioGroupErrorMessage, _ctx.n('--error')],
                      [_ctx.formDisabled || _ctx.disabled, _ctx.n('--disabled')]
                    )
                  ),
                  style: normalizeStyle({
                    color: _ctx.checked ? _ctx.checkedColor : _ctx.uncheckedColor,
                  }),
                },
                [
                  _ctx.checked
                    ? renderSlot(
                        _ctx.$slots,
                        'checked-icon',
                        {
                          key: 0,
                        },
                        () => [
                          createVNode(
                            _component_var_icon,
                            {
                              class: normalizeClass(
                                _ctx.classes(_ctx.n('icon'), [_ctx.withAnimation, _ctx.n('--with-animation')])
                              ),
                              'var-radio-cover': '',
                              name: 'radio-marked',
                              size: _ctx.iconSize,
                            },
                            null,
                            8,
                            ['class', 'size']
                          ),
                        ]
                      )
                    : renderSlot(
                        _ctx.$slots,
                        'unchecked-icon',
                        {
                          key: 1,
                        },
                        () => [
                          createVNode(
                            _component_var_icon,
                            {
                              class: normalizeClass(
                                _ctx.classes(_ctx.n('icon'), [_ctx.withAnimation, _ctx.n('--with-animation')])
                              ),
                              'var-radio-cover': '',
                              name: 'radio-blank',
                              size: _ctx.iconSize,
                            },
                            null,
                            8,
                            ['class', 'size']
                          ),
                        ]
                      ),
                ],
                6
              )),
              [
                [
                  _directive_ripple,
                  {
                    disabled: _ctx.formReadonly || _ctx.readonly || _ctx.formDisabled || _ctx.disabled || !_ctx.ripple,
                  },
                ],
              ]
            ),
            createElementVNode(
              'div',
              {
                class: normalizeClass(
                  _ctx.classes(
                    _ctx.n('text'),
                    [_ctx.errorMessage || _ctx.radioGroupErrorMessage, _ctx.n('--error')],
                    [_ctx.formDisabled || _ctx.disabled, _ctx.n('--disabled')]
                  )
                ),
              },
              [renderSlot(_ctx.$slots, 'default')],
              2
            ),
          ],
          16
        ),
        createVNode(
          _component_var_form_details,
          {
            'error-message': _ctx.errorMessage,
          },
          null,
          8,
          ['error-message']
        ),
      ],
      2
    )
  )
}
var Radio = defineComponent({
  render: render$j,
  name: 'VarRadio',
  directives: {
    Ripple,
  },
  components: {
    VarIcon: Icon,
    VarFormDetails: FormDetails,
  },
  inheritAttrs: false,
  props: props$h,
  setup(props2) {
    var value = ref(false)
    var checked = computed(() => value.value === props2.checkedValue)
    var withAnimation = ref(false)
    var { radioGroup, bindRadioGroup } = useRadioGroup()
    var { form, bindForm } = useForm()
    var { errorMessage, validateWithTrigger: vt, validate: v, resetValidation } = useValidation()
    var validateWithTrigger = (trigger) => {
      nextTick(() => {
        var { validateTrigger, rules, modelValue } = props2
        vt(validateTrigger, trigger, rules, modelValue)
      })
    }
    var change = (changedValue) => {
      var { checkedValue, onChange } = props2
      if (radioGroup && value.value === checkedValue) {
        return
      }
      value.value = changedValue
      call(props2['onUpdate:modelValue'], value.value)
      call(onChange, value.value)
      radioGroup == null ? void 0 : radioGroup.onToggle(checkedValue)
      validateWithTrigger('onChange')
    }
    var handleClick = (e) => {
      var { disabled, readonly, uncheckedValue, checkedValue, onClick } = props2
      if ((form != null && form.disabled.value) || disabled) {
        return
      }
      call(onClick, e)
      if ((form != null && form.readonly.value) || readonly) {
        return
      }
      withAnimation.value = true
      change(checked.value ? uncheckedValue : checkedValue)
    }
    var sync = (v2) => {
      var { checkedValue, uncheckedValue } = props2
      value.value = v2 === checkedValue ? checkedValue : uncheckedValue
    }
    var reset = () => {
      call(props2['onUpdate:modelValue'], props2.uncheckedValue)
      resetValidation()
    }
    var validate2 = () => v(props2.rules, props2.modelValue)
    var toggle = (changedValue) => {
      var { uncheckedValue, checkedValue } = props2
      var shouldReverse = ![uncheckedValue, checkedValue].includes(changedValue)
      if (shouldReverse) {
        changedValue = checked.value ? uncheckedValue : checkedValue
      }
      change(changedValue)
    }
    watch(
      () => props2.modelValue,
      (newValue) => {
        value.value = newValue
      },
      {
        immediate: true,
      }
    )
    var radioProvider = {
      sync,
      validate: validate2,
      resetValidation,
      reset,
    }
    call(bindRadioGroup, radioProvider)
    call(bindForm, radioProvider)
    return {
      withAnimation,
      checked,
      errorMessage,
      radioGroupErrorMessage: radioGroup == null ? void 0 : radioGroup.errorMessage,
      formDisabled: form == null ? void 0 : form.disabled,
      formReadonly: form == null ? void 0 : form.readonly,
      n: n$l,
      classes: classes$g,
      handleClick,
      toggle,
      reset,
      validate: validate2,
      resetValidation,
    }
  },
})
Radio.install = function (app) {
  app.component(Radio.name, Radio)
}
function directionValidator$2(direction) {
  return ['horizontal', 'vertical'].includes(direction)
}
var props$g = {
  modelValue: {
    type: [String, Number, Boolean, Object, Array],
    default: void 0,
  },
  direction: {
    type: String,
    default: 'horizontal',
    validator: directionValidator$2,
  },
  validateTrigger: {
    type: Array,
    default: () => ['onChange'],
  },
  rules: {
    type: Array,
  },
  onChange: {
    type: Function,
  },
  'onUpdate:modelValue': {
    type: Function,
  },
}
var { n: n$k, classes: classes$f } = createNamespace('radio-group')
function render$i(_ctx, _cache2) {
  var _component_var_form_details = resolveComponent('var-form-details')
  return (
    openBlock(),
    createElementBlock(
      'div',
      {
        class: normalizeClass(_ctx.n('wrap')),
      },
      [
        createElementVNode(
          'div',
          {
            class: normalizeClass(_ctx.classes(_ctx.n(), _ctx.n('--' + _ctx.direction))),
          },
          [renderSlot(_ctx.$slots, 'default')],
          2
        ),
        createVNode(
          _component_var_form_details,
          {
            'error-message': _ctx.errorMessage,
          },
          null,
          8,
          ['error-message']
        ),
      ],
      2
    )
  )
}
var RadioGroup = defineComponent({
  render: render$i,
  name: 'VarRadioGroup',
  components: {
    VarFormDetails: FormDetails,
  },
  props: props$g,
  setup(props2) {
    var { length, radios, bindRadios } = useRadios()
    var { bindForm } = useForm()
    var { errorMessage, validateWithTrigger: vt, validate: v, resetValidation } = useValidation()
    var radioGroupErrorMessage = computed(() => errorMessage.value)
    var validateWithTrigger = (trigger) => {
      nextTick(() => {
        var { validateTrigger, rules, modelValue } = props2
        vt(validateTrigger, trigger, rules, modelValue)
      })
    }
    var syncRadios = () =>
      radios.forEach((_ref) => {
        var { sync } = _ref
        return sync(props2.modelValue)
      })
    var onToggle = (changedValue) => {
      call(props2['onUpdate:modelValue'], changedValue)
      call(props2.onChange, changedValue)
      validateWithTrigger('onChange')
    }
    var validate2 = () => v(props2.rules, props2.modelValue)
    var reset = () => {
      call(props2['onUpdate:modelValue'], void 0)
      resetValidation()
    }
    watch(() => props2.modelValue, syncRadios)
    watch(() => length.value, syncRadios)
    var radioGroupProvider = {
      onToggle,
      validate: validate2,
      reset,
      resetValidation,
      errorMessage: radioGroupErrorMessage,
    }
    call(bindForm, radioGroupProvider)
    bindRadios(radioGroupProvider)
    return {
      errorMessage,
      n: n$k,
      classes: classes$f,
      reset,
      validate: validate2,
      resetValidation,
    }
  },
})
RadioGroup.install = function (app) {
  app.component(RadioGroup.name, RadioGroup)
}
var props$f = {
  modelValue: {
    type: [String, Number],
    default: 0,
  },
  count: {
    type: [String, Number],
    default: 5,
  },
  color: {
    type: String,
  },
  icon: {
    type: String,
    default: 'star',
  },
  emptyColor: {
    type: String,
  },
  emptyIcon: {
    type: String,
    default: 'star-outline',
  },
  size: {
    type: [String, Number],
  },
  gap: {
    type: [String, Number],
  },
  namespace: {
    type: String,
  },
  half: {
    type: Boolean,
    default: false,
  },
  halfIcon: {
    type: String,
    default: 'star-half-full',
  },
  disabled: {
    type: Boolean,
    default: false,
  },
  disabledColor: {
    type: String,
  },
  readonly: {
    type: Boolean,
    default: false,
  },
  ripple: {
    type: Boolean,
    default: true,
  },
  rules: {
    type: Array,
  },
  onChange: {
    type: Function,
  },
  'onUpdate:modelValue': {
    type: Function,
  },
}
var { n: n$j } = createNamespace('rate')
var _hoisted_1$6 = ['onClick']
function render$h(_ctx, _cache2) {
  var _component_var_icon = resolveComponent('var-icon')
  var _component_var_form_details = resolveComponent('var-form-details')
  var _directive_ripple = resolveDirective('ripple')
  return (
    openBlock(),
    createElementBlock(
      'div',
      {
        class: normalizeClass(_ctx.n('wrap')),
      },
      [
        createElementVNode(
          'div',
          {
            class: normalizeClass(_ctx.n()),
          },
          [
            (openBlock(true),
            createElementBlock(
              Fragment,
              null,
              renderList(_ctx.toNumber(_ctx.count), (val) => {
                return withDirectives(
                  (openBlock(),
                  createElementBlock(
                    'div',
                    {
                      key: val,
                      style: normalizeStyle(_ctx.getStyle(val)),
                      class: normalizeClass(_ctx.getClass(val)),
                      onClick: ($event) => _ctx.handleClick(val, $event),
                    },
                    [
                      createVNode(
                        _component_var_icon,
                        {
                          class: normalizeClass(_ctx.n('content-icon')),
                          'var-rate-cover': '',
                          transition: 0,
                          namespace: _ctx.namespace,
                          name: _ctx.getIconName(val),
                          style: normalizeStyle({
                            fontSize: _ctx.toSizeUnit(_ctx.size),
                          }),
                        },
                        null,
                        8,
                        ['class', 'namespace', 'name', 'style']
                      ),
                    ],
                    14,
                    _hoisted_1$6
                  )),
                  [
                    [
                      _directive_ripple,
                      {
                        disabled:
                          _ctx.formReadonly || _ctx.readonly || _ctx.formDisabled || _ctx.disabled || !_ctx.ripple,
                      },
                    ],
                  ]
                )
              }),
              128
            )),
          ],
          2
        ),
        createVNode(
          _component_var_form_details,
          {
            'error-message': _ctx.errorMessage,
          },
          null,
          8,
          ['error-message']
        ),
      ],
      2
    )
  )
}
var Rate = defineComponent({
  render: render$h,
  name: 'VarRate',
  components: {
    VarIcon: Icon,
    VarFormDetails: FormDetails,
  },
  directives: {
    Ripple,
  },
  props: props$f,
  setup(props2) {
    var { form, bindForm } = useForm()
    var { errorMessage, validateWithTrigger: vt, validate: v, resetValidation } = useValidation()
    var getStyle = (val) => {
      var { count, size, gap } = props2
      return {
        color: transformValue(val).color,
        marginRight: val !== toNumber(count) ? toSizeUnit(gap) : 0,
        width: toSizeUnit(size),
        height: toSizeUnit(size),
        borderRadius: '50%',
      }
    }
    var getClass = (val) => {
      var { type, color } = transformValue(val)
      return {
        [n$j('content')]: true,
        [n$j('--disabled')]: (form == null ? void 0 : form.disabled.value) || props2.disabled,
        [n$j('--error')]: errorMessage.value,
        [n$j('--primary')]: type !== 'empty' && !color,
      }
    }
    var getIconName = (val) => {
      var { type } = transformValue(val)
      var { icon, halfIcon, emptyIcon } = props2
      return type === 'full' ? icon : type === 'half' ? halfIcon : emptyIcon
    }
    var transformValue = (index2) => {
      var { modelValue, disabled, disabledColor, color, half, emptyColor } = props2
      var iconColor
      if (disabled || (form != null && form.disabled.value)) iconColor = disabledColor
      else if (color) iconColor = color
      if (index2 <= toNumber(modelValue)) {
        return {
          type: 'full',
          score: index2,
          color: iconColor,
        }
      }
      if (half && index2 <= toNumber(modelValue) + 0.5) {
        return {
          type: 'half',
          score: index2,
          color: iconColor,
        }
      }
      return {
        type: 'empty',
        score: index2,
        color: disabled || (form != null && form.disabled.value) ? disabledColor : emptyColor,
      }
    }
    var changeValue = (score, event) => {
      if (props2.half) {
        var { offsetWidth } = event.target
        if (event.offsetX <= Math.floor(offsetWidth / 2)) score -= 0.5
      }
      call(props2['onUpdate:modelValue'], score)
    }
    var validate2 = () => v(props2.rules, toNumber(props2.modelValue))
    var validateWithTrigger = () => nextTick(() => vt(['onChange'], 'onChange', props2.rules, props2.modelValue))
    var handleClick = (score, event) => {
      var { readonly, disabled, onChange } = props2
      if (readonly || disabled || (form != null && form.disabled.value) || (form != null && form.readonly.value)) {
        return
      }
      changeValue(score, event)
      call(onChange, score)
      validateWithTrigger()
    }
    var reset = () => {
      call(props2['onUpdate:modelValue'], 0)
      resetValidation()
    }
    var rateProvider = {
      reset,
      validate: validate2,
      resetValidation,
    }
    call(bindForm, rateProvider)
    return {
      errorMessage,
      formDisabled: form == null ? void 0 : form.disabled,
      formReadonly: form == null ? void 0 : form.readonly,
      getStyle,
      getClass,
      getIconName,
      handleClick,
      reset,
      validate: validate2,
      resetValidation,
      toSizeUnit,
      toNumber,
      n: n$j,
    }
  },
})
Rate.install = function (app) {
  app.component(Rate.name, Rate)
}
function justifyValidator$1(justify) {
  return ['flex-start', 'flex-end', 'center', 'space-between', 'space-around'].includes(justify)
}
function alignValidator(align) {
  return ['flex-start', 'center', 'flex-end'].includes(align)
}
var props$e = {
  gutter: {
    type: [String, Number],
    default: 0,
  },
  justify: {
    type: String,
    default: 'flex-start',
    validator: justifyValidator$1,
  },
  align: {
    type: String,
    default: 'flex-start',
    validator: alignValidator,
  },
  onClick: {
    type: Function,
  },
}
var { n: n$i, classes: classes$e } = createNamespace('row')
function render$g(_ctx, _cache2) {
  return (
    openBlock(),
    createElementBlock(
      'div',
      {
        class: normalizeClass(_ctx.classes(_ctx.n(), 'var--box')),
        style: normalizeStyle({
          justifyContent: _ctx.justify,
          alignItems: _ctx.align,
          margin: _ctx.average ? '0 -' + _ctx.average + 'px' : void 0,
        }),
        onClick:
          _cache2[0] ||
          (_cache2[0] = function () {
            return _ctx.onClick && _ctx.onClick(...arguments)
          }),
      },
      [renderSlot(_ctx.$slots, 'default')],
      6
    )
  )
}
var Row = defineComponent({
  render: render$g,
  name: 'VarRow',
  props: props$e,
  setup(props2) {
    var { cols, bindCols, length } = useCols()
    var average = computed(() => {
      var gutter = toPxNum(props2.gutter)
      return gutter / 2
    })
    var computePadding = () => {
      cols.forEach((col) => {
        col.setPadding({
          left: average.value,
          right: average.value,
        })
      })
    }
    var rowProvider = {
      computePadding,
    }
    watch(() => length.value, computePadding)
    watch(() => props2.gutter, computePadding)
    bindCols(rowProvider)
    return {
      n: n$i,
      classes: classes$e,
      average,
    }
  },
})
Row.install = function (app) {
  app.component(Row.name, Row)
}
function textAlignValidator(textAlign) {
  return ['left', 'right', 'center'].includes(textAlign)
}
var props$d = {
  modelValue: {
    default: void 0,
  },
  placeholder: {
    type: String,
  },
  multiple: {
    type: Boolean,
    default: false,
  },
  offsetY: {
    type: [String, Number],
    default: 0,
  },
  chip: {
    type: Boolean,
    default: false,
  },
  line: {
    type: Boolean,
    default: true,
  },
  hint: {
    type: Boolean,
    default: true,
  },
  textColor: {
    type: String,
  },
  focusColor: {
    type: String,
  },
  blurColor: {
    type: String,
  },
  disabled: {
    type: Boolean,
    default: false,
  },
  readonly: {
    type: Boolean,
    default: false,
  },
  clearable: {
    type: Boolean,
    default: false,
  },
  separator: {
    type: String,
    default: ',',
  },
  textAlign: {
    type: String,
    default: 'left',
    validator: textAlignValidator,
  },
  validateTrigger: {
    type: Array,
    default: () => ['onChange', 'onClear', 'onClose'],
  },
  rules: {
    type: Array,
  },
  onFocus: {
    type: Function,
  },
  onBlur: {
    type: Function,
  },
  onClick: {
    type: Function,
  },
  onClear: {
    type: Function,
  },
  onClose: {
    type: Function,
  },
  onChange: {
    type: Function,
  },
  'onUpdate:modelValue': {
    type: Function,
  },
}
var { n: n$h, classes: classes$d } = createNamespace('select')
var _hoisted_1$5 = {
  key: 0,
}
var _hoisted_2$3 = {
  key: 1,
}
function render$f(_ctx, _cache2) {
  var _component_var_chip = resolveComponent('var-chip')
  var _component_var_icon = resolveComponent('var-icon')
  var _component_var_menu = resolveComponent('var-menu')
  var _component_var_form_details = resolveComponent('var-form-details')
  return (
    openBlock(),
    createElementBlock(
      'div',
      {
        class: normalizeClass(
          _ctx.classes(_ctx.n(), 'var--box', [_ctx.formDisabled || _ctx.disabled, _ctx.n('--disabled')])
        ),
        onClick:
          _cache2[3] ||
          (_cache2[3] = function () {
            return _ctx.handleClick && _ctx.handleClick(...arguments)
          }),
      },
      [
        createElementVNode(
          'div',
          {
            class: normalizeClass(
              _ctx.classes(
                _ctx.n('controller'),
                [_ctx.isFocus, _ctx.n('--focus')],
                [_ctx.errorMessage, _ctx.n('--error')],
                [_ctx.formDisabled || _ctx.disabled, _ctx.n('--disabled')]
              )
            ),
            style: normalizeStyle({
              color: !_ctx.errorMessage ? (_ctx.isFocus ? _ctx.focusColor : _ctx.blurColor) : void 0,
            }),
          },
          [
            createElementVNode(
              'div',
              {
                class: normalizeClass(_ctx.classes(_ctx.n('icon'), [!_ctx.hint, _ctx.n('--non-hint')])),
              },
              [renderSlot(_ctx.$slots, 'prepend-icon')],
              2
            ),
            createVNode(
              _component_var_menu,
              {
                class: normalizeClass(_ctx.n('menu')),
                'var-select-cover': '',
                'offset-y': _ctx.offsetY,
                show: _ctx.isFocus,
                'onUpdate:show': _cache2[2] || (_cache2[2] = ($event) => (_ctx.isFocus = $event)),
                onClose: _ctx.handleBlur,
              },
              {
                menu: withCtx(() => [
                  createElementVNode(
                    'div',
                    {
                      class: normalizeClass(_ctx.n('scroller')),
                    },
                    [renderSlot(_ctx.$slots, 'default')],
                    2
                  ),
                ]),
                default: withCtx(() => [
                  createElementVNode(
                    'div',
                    {
                      class: normalizeClass(_ctx.classes(_ctx.n('wrap'), [!_ctx.hint, _ctx.n('--non-hint')])),
                      ref: 'wrapEl',
                      onClick:
                        _cache2[1] ||
                        (_cache2[1] = function () {
                          return _ctx.handleFocus && _ctx.handleFocus(...arguments)
                        }),
                    },
                    [
                      createElementVNode(
                        'div',
                        {
                          class: normalizeClass(
                            _ctx.classes(
                              _ctx.n('select'),
                              [_ctx.errorMessage, _ctx.n('--error')],
                              [_ctx.formDisabled || _ctx.disabled, _ctx.n('--disabled')]
                            )
                          ),
                          style: normalizeStyle({
                            textAlign: _ctx.textAlign,
                            color: _ctx.textColor,
                          }),
                        },
                        [
                          _ctx.multiple
                            ? (openBlock(),
                              createElementBlock('div', _hoisted_1$5, [
                                _ctx.chip
                                  ? (openBlock(),
                                    createElementBlock(
                                      'div',
                                      {
                                        key: 0,
                                        class: normalizeClass(_ctx.n('chips')),
                                      },
                                      [
                                        (openBlock(true),
                                        createElementBlock(
                                          Fragment,
                                          null,
                                          renderList(_ctx.labels, (l) => {
                                            return (
                                              openBlock(),
                                              createBlock(
                                                _component_var_chip,
                                                {
                                                  class: normalizeClass(_ctx.n('chip')),
                                                  'var-select-cover': '',
                                                  closable: '',
                                                  size: 'small',
                                                  type: _ctx.errorMessage ? 'danger' : void 0,
                                                  key: l,
                                                  onClick:
                                                    _cache2[0] || (_cache2[0] = withModifiers(() => {}, ['stop'])),
                                                  onClose: () => _ctx.handleClose(l),
                                                },
                                                {
                                                  default: withCtx(() => [createTextVNode(toDisplayString(l), 1)]),
                                                  _: 2,
                                                },
                                                1032,
                                                ['class', 'type', 'onClose']
                                              )
                                            )
                                          }),
                                          128
                                        )),
                                      ],
                                      2
                                    ))
                                  : (openBlock(),
                                    createElementBlock(
                                      'div',
                                      {
                                        key: 1,
                                        class: normalizeClass(_ctx.n('values')),
                                      },
                                      toDisplayString(_ctx.labels.join(_ctx.separator)),
                                      3
                                    )),
                              ]))
                            : (openBlock(), createElementBlock('span', _hoisted_2$3, toDisplayString(_ctx.label), 1)),
                          createVNode(
                            _component_var_icon,
                            {
                              class: normalizeClass(
                                _ctx.classes(_ctx.n('arrow'), [_ctx.isFocus, _ctx.n('--arrow-rotate')])
                              ),
                              'var-select-cover': '',
                              name: 'menu-down',
                              transition: 300,
                            },
                            null,
                            8,
                            ['class']
                          ),
                        ],
                        6
                      ),
                      createElementVNode(
                        'label',
                        {
                          class: normalizeClass(
                            _ctx.classes(
                              _ctx.n('placeholder'),
                              'var--ellipsis',
                              [_ctx.isFocus, _ctx.n('--focus')],
                              [_ctx.errorMessage, _ctx.n('--error')],
                              [_ctx.formDisabled || _ctx.disabled, _ctx.n('--disabled')],
                              _ctx.computePlaceholderState(),
                              [!_ctx.hint, _ctx.n('--placeholder-non-hint')]
                            )
                          ),
                          style: normalizeStyle({
                            color: !_ctx.errorMessage ? (_ctx.isFocus ? _ctx.focusColor : _ctx.blurColor) : void 0,
                          }),
                        },
                        toDisplayString(_ctx.placeholder),
                        7
                      ),
                    ],
                    2
                  ),
                ]),
                _: 3,
              },
              8,
              ['class', 'offset-y', 'show', 'onClose']
            ),
            createElementVNode(
              'div',
              {
                class: normalizeClass(_ctx.classes(_ctx.n('icon'), [!_ctx.hint, _ctx.n('--non-hint')])),
              },
              [
                renderSlot(_ctx.$slots, 'append-icon', {}, () => [
                  _ctx.clearable
                    ? (openBlock(),
                      createBlock(
                        _component_var_icon,
                        {
                          key: 0,
                          class: normalizeClass(_ctx.n('clear-icon')),
                          name: 'close-circle',
                          size: '14px',
                          onClick: _ctx.handleClear,
                        },
                        null,
                        8,
                        ['class', 'onClick']
                      ))
                    : createCommentVNode('v-if', true),
                ]),
              ],
              2
            ),
          ],
          6
        ),
        _ctx.line
          ? (openBlock(),
            createElementBlock(
              'div',
              {
                key: 0,
                class: normalizeClass(
                  _ctx.classes(
                    _ctx.n('line'),
                    [_ctx.formDisabled || _ctx.disabled, _ctx.n('--line-disabled')],
                    [_ctx.errorMessage, _ctx.n('--line-error')]
                  )
                ),
                style: normalizeStyle({
                  background: !_ctx.errorMessage ? _ctx.blurColor : void 0,
                }),
              },
              [
                createElementVNode(
                  'div',
                  {
                    class: normalizeClass(
                      _ctx.classes(
                        _ctx.n('dot'),
                        [_ctx.isFocus, _ctx.n('--spread')],
                        [_ctx.formDisabled || _ctx.disabled, _ctx.n('--line-disabled')],
                        [_ctx.errorMessage, _ctx.n('--line-error')]
                      )
                    ),
                    style: normalizeStyle({
                      background: !_ctx.errorMessage ? _ctx.focusColor : void 0,
                    }),
                  },
                  null,
                  6
                ),
              ],
              6
            ))
          : createCommentVNode('v-if', true),
        createVNode(
          _component_var_form_details,
          {
            'error-message': _ctx.errorMessage,
          },
          null,
          8,
          ['error-message']
        ),
      ],
      2
    )
  )
}
var Select = defineComponent({
  render: render$f,
  name: 'VarSelect',
  components: {
    VarIcon: Icon,
    VarMenu: Menu,
    VarChip: Chip,
    VarFormDetails: FormDetails,
  },
  props: props$d,
  setup(props2) {
    var wrapEl = ref(null)
    var isFocus = ref(false)
    var multiple = computed(() => props2.multiple)
    var focusColor = computed(() => props2.focusColor)
    var label = ref('')
    var labels = ref([])
    var wrapWidth = ref('0px')
    var offsetY = ref(0)
    var { bindForm, form } = useForm()
    var { length, options: options2, bindOptions } = useOptions()
    var { errorMessage, validateWithTrigger: vt, validate: v, resetValidation } = useValidation()
    var computeLabel = () => {
      var { multiple: multiple2, modelValue } = props2
      if (multiple2) {
        var rawModelValue = modelValue
        labels.value = rawModelValue.map(findLabel)
      }
      if (!multiple2 && !isEmpty(modelValue)) {
        label.value = findLabel(modelValue)
      }
      if (!multiple2 && isEmpty(modelValue)) {
        label.value = ''
      }
    }
    var validateWithTrigger = (trigger) => {
      nextTick(() => {
        var { validateTrigger, rules, modelValue } = props2
        vt(validateTrigger, trigger, rules, modelValue)
      })
    }
    var findValueOrLabel = (_ref) => {
      var { value, label: label2 } = _ref
      if (value.value != null) {
        return value.value
      }
      return label2.value
    }
    var findLabel = (modelValue) => {
      var _option$label$value, _option
      var option = options2.find((_ref2) => {
        var { value } = _ref2
        return value.value === modelValue
      })
      if (!option) {
        option = options2.find((_ref3) => {
          var { label: label2 } = _ref3
          return label2.value === modelValue
        })
      }
      return (_option$label$value = (_option = option) == null ? void 0 : _option.label.value) != null
        ? _option$label$value
        : ''
    }
    var computePlaceholderState = () => {
      var { hint, modelValue } = props2
      if (!hint && !isEmpty(modelValue)) {
        return n$h('--placeholder-hidden')
      }
      if (hint && (!isEmpty(modelValue) || isFocus.value)) {
        return n$h('--placeholder-hint')
      }
    }
    var getWrapWidth = () => {
      return (wrapEl.value && window.getComputedStyle(wrapEl.value).width) || '0px'
    }
    var getOffsetY = () => {
      var paddingTop = (wrapEl.value && window.getComputedStyle(wrapEl.value).paddingTop) || '0px'
      return toPxNum(paddingTop) * 1.5
    }
    var handleFocus = () => {
      var { disabled, readonly, onFocus } = props2
      if ((form != null && form.disabled.value) || (form != null && form.readonly.value) || disabled || readonly) {
        return
      }
      wrapWidth.value = getWrapWidth()
      offsetY.value = getOffsetY() + toPxNum(props2.offsetY)
      isFocus.value = true
      call(onFocus)
      validateWithTrigger('onFocus')
    }
    var handleBlur = () => {
      var { disabled, readonly, onBlur } = props2
      if ((form != null && form.disabled.value) || (form != null && form.readonly.value) || disabled || readonly) {
        return
      }
      call(onBlur)
      validateWithTrigger('onBlur')
    }
    var onSelect = (option) => {
      var { disabled, readonly, multiple: multiple2, onChange } = props2
      if ((form != null && form.disabled.value) || (form != null && form.readonly.value) || disabled || readonly) {
        return
      }
      var selectedValue = multiple2
        ? options2
            .filter((_ref4) => {
              var { selected } = _ref4
              return selected.value
            })
            .map(findValueOrLabel)
        : findValueOrLabel(option)
      call(props2['onUpdate:modelValue'], selectedValue)
      call(onChange, selectedValue)
      validateWithTrigger('onChange')
      !multiple2 && (isFocus.value = false)
    }
    var handleClear = () => {
      var { disabled, readonly, multiple: multiple2, clearable, onClear } = props2
      if (
        (form != null && form.disabled.value) ||
        (form != null && form.readonly.value) ||
        disabled ||
        readonly ||
        !clearable
      ) {
        return
      }
      var changedModelValue = multiple2 ? [] : void 0
      call(props2['onUpdate:modelValue'], changedModelValue)
      call(onClear, changedModelValue)
      validateWithTrigger('onClear')
    }
    var handleClick = (e) => {
      var { disabled, onClick } = props2
      if ((form != null && form.disabled.value) || disabled) {
        return
      }
      call(onClick, e)
      validateWithTrigger('onClick')
    }
    var handleClose = (text) => {
      var { disabled, readonly, modelValue, onClose } = props2
      if ((form != null && form.disabled.value) || (form != null && form.readonly.value) || disabled || readonly) {
        return
      }
      var rawModelValue = modelValue
      var option = options2.find((_ref5) => {
        var { label: label2 } = _ref5
        return label2.value === text
      })
      var currentModelValue = rawModelValue.filter((value) => {
        var _value$value
        return value !== ((_value$value = option.value.value) != null ? _value$value : option.label.value)
      })
      call(props2['onUpdate:modelValue'], currentModelValue)
      call(onClose, currentModelValue)
      validateWithTrigger('onClose')
    }
    var syncOptions = () => {
      var { multiple: multiple2, modelValue } = props2
      if (multiple2) {
        var rawModelValue = modelValue
        options2.forEach((option) => option.sync(rawModelValue.includes(findValueOrLabel(option))))
      } else {
        options2.forEach((option) => option.sync(modelValue === findValueOrLabel(option)))
      }
      computeLabel()
    }
    var focus = () => {
      wrapWidth.value = getWrapWidth()
      offsetY.value = getOffsetY() + toPxNum(props2.offsetY)
      isFocus.value = true
    }
    var blur = () => {
      isFocus.value = false
    }
    var validate2 = () => v(props2.rules, props2.modelValue)
    var reset = () => {
      call(props2['onUpdate:modelValue'], props2.multiple ? [] : void 0)
      resetValidation()
    }
    watch(
      () => props2.multiple,
      () => {
        var { multiple: multiple2, modelValue } = props2
        if (multiple2 && !isArray$1(modelValue)) {
          throw Error('The modelValue must be an array when multiple is true')
        }
      }
    )
    watch(() => props2.modelValue, syncOptions, {
      deep: true,
    })
    watch(() => length.value, syncOptions)
    var selectProvider = {
      wrapWidth: computed(() => wrapWidth.value),
      multiple,
      focusColor,
      onSelect,
      reset,
      validate: validate2,
      resetValidation,
    }
    bindOptions(selectProvider)
    call(bindForm, selectProvider)
    return {
      wrapEl,
      offsetY,
      isFocus,
      errorMessage,
      formDisabled: form == null ? void 0 : form.disabled,
      label,
      labels,
      n: n$h,
      classes: classes$d,
      computePlaceholderState,
      handleFocus,
      handleBlur,
      handleClear,
      handleClick,
      handleClose,
      reset,
      validate: validate2,
      resetValidation,
      focus,
      blur,
    }
  },
})
Select.install = function (app) {
  app.component(Select.name, Select)
}
var props$c = {
  loading: {
    type: Boolean,
    default: true,
  },
  title: {
    type: Boolean,
    default: false,
  },
  card: {
    type: Boolean,
    default: false,
  },
  avatar: {
    type: Boolean,
    default: false,
  },
  fullscreen: {
    type: Boolean,
    default: false,
  },
  fullscreenZIndex: {
    type: [Number, String],
    default: 100,
  },
  titleWidth: {
    type: [Number, String],
  },
  cardHeight: {
    type: [Number, String],
  },
  avatarSize: {
    type: [Number, String],
  },
  rows: {
    type: [Number, String],
    default: 3,
  },
  rowsWidth: {
    type: Array,
    default: () => [],
  },
}
var { n: n$g, classes: classes$c } = createNamespace('skeleton')
function render$e(_ctx, _cache2) {
  return (
    openBlock(),
    createElementBlock(
      'div',
      {
        class: normalizeClass(_ctx.classes('var--box', _ctx.n())),
      },
      [
        !_ctx.loading
          ? (openBlock(),
            createElementBlock(
              'div',
              {
                key: 0,
                class: normalizeClass(_ctx.n('data')),
              },
              [renderSlot(_ctx.$slots, 'default')],
              2
            ))
          : createCommentVNode('v-if', true),
        _ctx.loading && !_ctx.fullscreen
          ? (openBlock(),
            createElementBlock(
              'div',
              {
                key: 1,
                class: normalizeClass(_ctx.n('content')),
              },
              [
                _ctx.card
                  ? (openBlock(),
                    createElementBlock(
                      'div',
                      {
                        key: 0,
                        class: normalizeClass(_ctx.n('card')),
                        style: normalizeStyle({
                          height: _ctx.toSizeUnit(_ctx.cardHeight),
                        }),
                      },
                      [
                        createElementVNode(
                          'div',
                          {
                            class: normalizeClass(_ctx.n('--animation')),
                          },
                          null,
                          2
                        ),
                      ],
                      6
                    ))
                  : createCommentVNode('v-if', true),
                createElementVNode(
                  'div',
                  {
                    class: normalizeClass(_ctx.n('article')),
                  },
                  [
                    _ctx.avatar
                      ? (openBlock(),
                        createElementBlock(
                          'div',
                          {
                            key: 0,
                            class: normalizeClass(_ctx.n('avatar')),
                            style: normalizeStyle({
                              width: _ctx.toSizeUnit(_ctx.avatarSize),
                              height: _ctx.toSizeUnit(_ctx.avatarSize),
                            }),
                          },
                          [
                            createElementVNode(
                              'div',
                              {
                                class: normalizeClass(_ctx.n('--animation')),
                              },
                              null,
                              2
                            ),
                          ],
                          6
                        ))
                      : createCommentVNode('v-if', true),
                    createElementVNode(
                      'div',
                      {
                        class: normalizeClass(_ctx.n('section')),
                      },
                      [
                        _ctx.title
                          ? (openBlock(),
                            createElementBlock(
                              'div',
                              {
                                key: 0,
                                class: normalizeClass(_ctx.n('title')),
                                style: normalizeStyle({
                                  width: _ctx.toSizeUnit(_ctx.titleWidth),
                                }),
                              },
                              [
                                createElementVNode(
                                  'div',
                                  {
                                    class: normalizeClass(_ctx.n('--animation')),
                                  },
                                  null,
                                  2
                                ),
                              ],
                              6
                            ))
                          : createCommentVNode('v-if', true),
                        (openBlock(true),
                        createElementBlock(
                          Fragment,
                          null,
                          renderList(_ctx.toNumber(_ctx.rows), (r, index2) => {
                            return (
                              openBlock(),
                              createElementBlock(
                                'div',
                                {
                                  class: normalizeClass(_ctx.n('row')),
                                  key: r,
                                  style: normalizeStyle({
                                    width: _ctx.toSizeUnit(_ctx.rowsWidth[index2]),
                                  }),
                                },
                                [
                                  createElementVNode(
                                    'div',
                                    {
                                      class: normalizeClass(_ctx.n('--animation')),
                                    },
                                    null,
                                    2
                                  ),
                                ],
                                6
                              )
                            )
                          }),
                          128
                        )),
                      ],
                      2
                    ),
                  ],
                  2
                ),
              ],
              2
            ))
          : createCommentVNode('v-if', true),
        _ctx.loading && _ctx.fullscreen
          ? (openBlock(),
            createElementBlock(
              'div',
              {
                key: 2,
                class: normalizeClass(_ctx.n('fullscreen')),
                style: normalizeStyle({
                  zIndex: _ctx.toNumber(_ctx.fullscreenZIndex),
                }),
              },
              [
                createElementVNode(
                  'div',
                  {
                    class: normalizeClass(_ctx.n('--animation')),
                  },
                  null,
                  2
                ),
              ],
              6
            ))
          : createCommentVNode('v-if', true),
      ],
      2
    )
  )
}
var Skeleton = defineComponent({
  render: render$e,
  name: 'VarSkeleton',
  props: props$c,
  setup() {
    return {
      n: n$g,
      classes: classes$c,
      toSizeUnit,
      toNumber,
    }
  },
})
Skeleton.install = function (app) {
  app.component(Skeleton.name, Skeleton)
}
function labelValidator(label) {
  return ['always', 'normal', 'never'].includes(label)
}
var props$b = {
  modelValue: {
    type: [Number, Array],
    default: 0,
  },
  step: {
    type: [Number, String],
    default: 1,
  },
  range: {
    type: Boolean,
    default: false,
  },
  labelVisible: {
    type: String,
    default: 'normal',
    validator: labelValidator,
  },
  activeColor: {
    type: String,
  },
  trackColor: {
    type: String,
  },
  thumbColor: {
    type: String,
  },
  labelColor: {
    type: String,
  },
  labelTextColor: {
    type: String,
  },
  trackHeight: {
    type: [String, Number],
  },
  thumbSize: {
    type: [String, Number],
  },
  disabled: {
    type: Boolean,
    default: false,
  },
  readonly: {
    type: Boolean,
    default: false,
  },
  rules: {
    type: Array,
  },
  onChange: {
    type: Function,
  },
  onStart: {
    type: Function,
  },
  onEnd: {
    type: Function,
  },
  'onUpdate:modelValue': {
    type: Function,
  },
}
function _extends() {
  _extends =
    Object.assign ||
    function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i]
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key]
          }
        }
      }
      return target
    }
  return _extends.apply(this, arguments)
}
var { n: n$f, classes: classes$b } = createNamespace('slider')
var Thumbs
;(function (Thumbs2) {
  Thumbs2['First'] = '1'
  Thumbs2['Second'] = '2'
})(Thumbs || (Thumbs = {}))
var _hoisted_1$4 = ['onTouchstart', 'onTouchmove', 'onTouchend', 'onTouchcancel']
function render$d(_ctx, _cache2) {
  var _component_var_form_details = resolveComponent('var-form-details')
  return (
    openBlock(),
    createElementBlock(
      'div',
      {
        class: normalizeClass(_ctx.n()),
      },
      [
        createElementVNode(
          'div',
          {
            class: normalizeClass(
              _ctx.classes(
                _ctx.n('block'),
                [_ctx.isDisabled, _ctx.n('--disabled')],
                [_ctx.errorMessage, _ctx.n('--error')]
              )
            ),
            style: normalizeStyle({
              height: _ctx.thumbSize === void 0 ? _ctx.thumbSize : _ctx.multiplySizeUnit(_ctx.thumbSize, 3),
              margin: _ctx.thumbSize === void 0 ? _ctx.thumbSize : '0 ' + _ctx.multiplySizeUnit(_ctx.thumbSize, 0.5),
            }),
            ref: 'sliderEl',
            onClick:
              _cache2[0] ||
              (_cache2[0] = function () {
                return _ctx.click && _ctx.click(...arguments)
              }),
          },
          [
            createElementVNode(
              'div',
              {
                class: normalizeClass(_ctx.n('track')),
              },
              [
                createElementVNode(
                  'div',
                  {
                    class: normalizeClass(_ctx.n('track-background')),
                    style: normalizeStyle({
                      background: _ctx.trackColor,
                      height: _ctx.multiplySizeUnit(_ctx.trackHeight),
                    }),
                  },
                  null,
                  6
                ),
                createElementVNode(
                  'div',
                  {
                    class: normalizeClass(_ctx.n('track-fill')),
                    style: normalizeStyle(_ctx.getFillStyle),
                  },
                  null,
                  6
                ),
              ],
              2
            ),
            (openBlock(true),
            createElementBlock(
              Fragment,
              null,
              renderList(_ctx.thumbList, (item) => {
                return (
                  openBlock(),
                  createElementBlock(
                    'div',
                    {
                      class: normalizeClass(_ctx.n('thumb')),
                      key: item.enumValue,
                      style: normalizeStyle({
                        left: item.value + '%',
                        zIndex: _ctx.thumbsProps[item.enumValue].active ? 1 : void 0,
                      }),
                      onTouchstart: ($event) => _ctx.start($event, item.enumValue),
                      onTouchmove: ($event) => _ctx.move($event, item.enumValue),
                      onTouchend: ($event) => _ctx.end(item.enumValue),
                      onTouchcancel: ($event) => _ctx.end(item.enumValue),
                    },
                    [
                      renderSlot(
                        _ctx.$slots,
                        'button',
                        {
                          currentValue: item.value,
                        },
                        () => [
                          createElementVNode(
                            'div',
                            {
                              class: normalizeClass(_ctx.n('thumb-block')),
                              style: normalizeStyle({
                                background: _ctx.thumbColor,
                                height: _ctx.multiplySizeUnit(_ctx.thumbSize),
                                width: _ctx.multiplySizeUnit(_ctx.thumbSize),
                              }),
                            },
                            null,
                            6
                          ),
                          createElementVNode(
                            'div',
                            {
                              class: normalizeClass(
                                _ctx.classes(_ctx.n('thumb-ripple'), [
                                  _ctx.thumbsProps[item.enumValue].active,
                                  _ctx.n('thumb-ripple--active'),
                                ])
                              ),
                              style: normalizeStyle(
                                _extends(
                                  {
                                    background: _ctx.thumbColor,
                                  },
                                  _ctx.getRippleSize(item)
                                )
                              ),
                            },
                            null,
                            6
                          ),
                          createElementVNode(
                            'div',
                            {
                              class: normalizeClass(
                                _ctx.classes(_ctx.n('thumb-label'), [
                                  _ctx.showLabel(item.enumValue),
                                  _ctx.n('thumb-label--active'),
                                ])
                              ),
                              style: normalizeStyle({
                                background: _ctx.labelColor,
                                color: _ctx.labelTextColor,
                                height:
                                  _ctx.thumbSize === void 0 ? _ctx.thumbSize : _ctx.multiplySizeUnit(_ctx.thumbSize, 2),
                                width:
                                  _ctx.thumbSize === void 0 ? _ctx.thumbSize : _ctx.multiplySizeUnit(_ctx.thumbSize, 2),
                              }),
                            },
                            [createElementVNode('span', null, toDisplayString(item.value), 1)],
                            6
                          ),
                        ]
                      ),
                    ],
                    46,
                    _hoisted_1$4
                  )
                )
              }),
              128
            )),
          ],
          6
        ),
        createVNode(
          _component_var_form_details,
          {
            'error-message': _ctx.errorMessage,
            class: normalizeClass(_ctx.n('form')),
            'var-slider-cover': '',
          },
          null,
          8,
          ['error-message', 'class']
        ),
      ],
      2
    )
  )
}
var Slider = defineComponent({
  render: render$d,
  name: 'VarSlider',
  components: {
    VarFormDetails: FormDetails,
  },
  props: props$b,
  setup(props2) {
    var { bindForm, form } = useForm()
    var { errorMessage, validateWithTrigger: vt, validate: v, resetValidation } = useValidation()
    var validate2 = () => v(props2.rules, props2.modelValue)
    var getThumbProps = () => ({
      startPosition: 0,
      currentLeft: 0,
      active: false,
      percentValue: 0,
    })
    var validateWithTrigger = () => nextTick(() => vt(['onChange'], 'onChange', props2.rules, props2.modelValue))
    var sliderEl = ref(null)
    var maxWidth = ref(0)
    var isScroll = ref(false)
    var thumbsProps = reactive({
      [Thumbs.First]: getThumbProps(),
      [Thumbs.Second]: getThumbProps(),
    })
    var unitWidth = computed(() => (maxWidth.value / 100) * toNumber(props2.step))
    var thumbList = computed(() => {
      var list2 = [
        {
          value: props2.modelValue,
          enumValue: Thumbs.First,
        },
      ]
      if (props2.range && isArray$1(props2.modelValue)) {
        list2 = [
          {
            value: props2.modelValue[0],
            enumValue: Thumbs.First,
          },
          {
            value: props2.modelValue[1],
            enumValue: Thumbs.Second,
          },
        ]
      }
      return list2
    })
    var getRippleSize = (item) => {
      var size
      if (props2.thumbSize !== void 0) {
        size = thumbsProps[item.enumValue].active ? multiplySizeUnit(props2.thumbSize, 3) : '0px'
      }
      return {
        height: size,
        width: size,
      }
    }
    var showLabel = (type) => {
      if (props2.labelVisible === 'always') return true
      if (props2.labelVisible === 'never') return false
      return thumbsProps[type].active
    }
    var getFillStyle = computed(() => {
      var { activeColor, range, modelValue } = props2
      var width = range && isArray$1(modelValue) ? Math.abs(modelValue[0] - modelValue[1]) : modelValue
      var left = range && isArray$1(modelValue) ? Math.min(modelValue[0], modelValue[1]) : 0
      return {
        width: width + '%',
        left: left + '%',
        background: activeColor,
      }
    })
    var isDisabled = computed(() => props2.disabled || (form == null ? void 0 : form.disabled.value))
    var isReadonly = computed(() => props2.readonly || (form == null ? void 0 : form.readonly.value))
    var setPercent = (moveDistance, type) => {
      var rangeValue = []
      var { step, range, modelValue, onChange } = props2
      var stepNumber = toNumber(step)
      var roundDistance = Math.round(moveDistance / unitWidth.value)
      var curValue = roundDistance * stepNumber
      var prevValue = thumbsProps[type].percentValue
      thumbsProps[type].percentValue = curValue / stepNumber
      if (range && isArray$1(modelValue)) {
        rangeValue = type === Thumbs.First ? [curValue, modelValue[1]] : [modelValue[0], curValue]
      }
      if (prevValue !== curValue) {
        var value = range ? rangeValue : curValue
        call(onChange, value)
        call(props2['onUpdate:modelValue'], value)
        validateWithTrigger()
      }
    }
    var getType2 = (offset) => {
      if (!props2.range) return Thumbs.First
      var thumb1Distance = thumbsProps[Thumbs.First].percentValue * unitWidth.value
      var thumb2Distance = thumbsProps[Thumbs.Second].percentValue * unitWidth.value
      var offsetToThumb1 = Math.abs(offset - thumb1Distance)
      var offsetToThumb2 = Math.abs(offset - thumb2Distance)
      return offsetToThumb1 <= offsetToThumb2 ? Thumbs.First : Thumbs.Second
    }
    var start = (event, type) => {
      if (!maxWidth.value) maxWidth.value = sliderEl.value.offsetWidth
      if (isDisabled.value || isReadonly.value) return
      call(props2.onStart)
      isScroll.value = true
      thumbsProps[type].startPosition = event.touches[0].clientX
    }
    var move = (event, type) => {
      if (isDisabled.value || isReadonly.value || !isScroll.value) return
      var moveDistance = event.touches[0].clientX - thumbsProps[type].startPosition + thumbsProps[type].currentLeft
      thumbsProps[type].active = true
      if (moveDistance <= 0) moveDistance = 0
      else if (moveDistance >= maxWidth.value) moveDistance = maxWidth.value
      setPercent(moveDistance, type)
    }
    var end = (type) => {
      var { range, modelValue, onEnd } = props2
      if (isDisabled.value || isReadonly.value) return
      var rangeValue = []
      thumbsProps[type].currentLeft = thumbsProps[type].percentValue * unitWidth.value
      thumbsProps[type].active = false
      var curValue = thumbsProps[type].percentValue
      if (range && isArray$1(modelValue)) {
        rangeValue = type === Thumbs.First ? [curValue, modelValue[1]] : [modelValue[0], curValue]
      }
      call(onEnd, range ? rangeValue : curValue)
      isScroll.value = false
    }
    var click = (event) => {
      if (isDisabled.value || isReadonly.value) return
      if (event.target.closest('.var-slider__thumb')) return
      var offset = event.clientX - getLeft(event.currentTarget)
      var type = getType2(offset)
      setPercent(offset, type)
      end(type)
    }
    var stepValidator = () => {
      var stepNumber = toNumber(props2.step)
      if (isNaN(stepNumber)) {
        console.warn('[Varlet] Slider: type of prop "step" should be Number')
        return false
      }
      if (stepNumber < 1 || stepNumber > 100) {
        console.warn('[Varlet] Slider: "step" should be >= 0 and <= 100')
        return false
      }
      if (parseInt('' + props2.step, 10) !== stepNumber) {
        console.warn('[Varlet] Slider: "step" should be an Integer')
        return false
      }
      return true
    }
    var valueValidator = () => {
      var { range, modelValue } = props2
      if (range && !isArray$1(modelValue)) {
        console.error('[Varlet] Slider: "modelValue" should be an Array')
        return false
      }
      if (!range && isArray$1(modelValue)) {
        console.error('[Varlet] Slider: "modelValue" should be a Number')
        return false
      }
      if (range && isArray$1(modelValue) && modelValue.length < 2) {
        console.error('[Varlet] Slider: "modelValue" should have two value')
        return false
      }
      return true
    }
    var setProps = function (modelValue, step) {
      if (modelValue === void 0) {
        modelValue = props2.modelValue
      }
      if (step === void 0) {
        step = toNumber(props2.step)
      }
      if (props2.range && isArray$1(modelValue)) {
        thumbsProps[Thumbs.First].percentValue = modelValue[0] / step
        thumbsProps[Thumbs.First].currentLeft = thumbsProps[Thumbs.First].percentValue * unitWidth.value
        thumbsProps[Thumbs.Second].percentValue = modelValue[1] / step
        thumbsProps[Thumbs.Second].currentLeft = thumbsProps[Thumbs.Second].percentValue * unitWidth.value
      } else if (isNumber(modelValue)) {
        thumbsProps[Thumbs.First].currentLeft = (modelValue / step) * unitWidth.value
      }
    }
    watch([() => props2.modelValue, () => props2.step], (_ref) => {
      var [modelValue, step] = _ref
      if (!stepValidator() || !valueValidator() || isScroll.value) return
      setProps(modelValue, toNumber(step))
    })
    watch(maxWidth, () => setProps())
    onMounted(() => {
      if (!stepValidator() || !valueValidator()) return
      maxWidth.value = sliderEl.value.offsetWidth
    })
    var reset = () => {
      var resetValue = props2.range ? [0, 0] : 0
      call(props2['onUpdate:modelValue'], resetValue)
      resetValidation()
    }
    var sliderProvider = {
      reset,
      validate: validate2,
      resetValidation,
    }
    call(bindForm, sliderProvider)
    return {
      n: n$f,
      classes: classes$b,
      Thumbs,
      sliderEl,
      getFillStyle,
      isDisabled,
      errorMessage,
      thumbsProps,
      thumbList,
      multiplySizeUnit,
      toNumber,
      getRippleSize,
      showLabel,
      start,
      move,
      end,
      click,
    }
  },
})
Slider.install = function (app) {
  app.component(Slider.name, Slider)
}
function positionValidator(position) {
  var validPositions = ['top', 'center', 'bottom']
  return validPositions.includes(position)
}
function typeValidator(type) {
  return SNACKBAR_TYPE.includes(type)
}
var props$a = {
  type: {
    type: String,
    validator: typeValidator,
  },
  position: {
    type: String,
    default: 'top',
    validator: positionValidator,
  },
  content: {
    type: String,
  },
  contentClass: {
    type: String,
  },
  duration: {
    type: Number,
    default: 3e3,
  },
  vertical: {
    type: Boolean,
    default: false,
  },
  loadingType: pickProps(props$Q, 'type'),
  loadingSize: pickProps(props$Q, 'size'),
  lockScroll: {
    type: Boolean,
    default: false,
  },
  show: {
    type: Boolean,
    default: false,
  },
  teleport: {
    type: String,
    default: 'body',
  },
  forbidClick: {
    type: Boolean,
    default: false,
  },
  onOpen: {
    type: Function,
    default: () => {},
  },
  onOpened: {
    type: Function,
    default: () => {},
  },
  onClose: {
    type: Function,
    default: () => {},
  },
  onClosed: {
    type: Function,
    default: () => {},
  },
  'onUpdate:show': {
    type: Function,
  },
  _update: {
    type: String,
  },
}
var { n: n$e, classes: classes$a } = createNamespace('snackbar')
var ICON_TYPE_DICT = {
  success: 'checkbox-marked-circle',
  warning: 'warning',
  info: 'information',
  error: 'error',
  loading: '',
}
function render$c(_ctx, _cache2) {
  var _component_var_icon = resolveComponent('var-icon')
  var _component_var_loading = resolveComponent('var-loading')
  return withDirectives(
    (openBlock(),
    createElementBlock(
      'div',
      {
        class: normalizeClass(_ctx.n()),
        style: normalizeStyle({
          pointerEvents: _ctx.isForbidClick ? 'auto' : 'none',
          zIndex: _ctx.zIndex,
        }),
      },
      [
        createElementVNode(
          'div',
          {
            class: normalizeClass(
              _ctx.classes(
                _ctx.n('wrapper'),
                _ctx.n('wrapper-' + _ctx.position),
                'var-elevation--4',
                [_ctx.vertical, _ctx.n('vertical')],
                [_ctx.type && _ctx.SNACKBAR_TYPE.includes(_ctx.type), _ctx.n('wrapper-' + _ctx.type)]
              )
            ),
            style: normalizeStyle({
              zIndex: _ctx.zIndex,
            }),
          },
          [
            createElementVNode(
              'div',
              {
                class: normalizeClass([_ctx.n('content'), _ctx.contentClass]),
              },
              [renderSlot(_ctx.$slots, 'default', {}, () => [createTextVNode(toDisplayString(_ctx.content), 1)])],
              2
            ),
            createElementVNode(
              'div',
              {
                class: normalizeClass(_ctx.n('action')),
              },
              [
                _ctx.iconName
                  ? (openBlock(),
                    createBlock(
                      _component_var_icon,
                      {
                        key: 0,
                        name: _ctx.iconName,
                      },
                      null,
                      8,
                      ['name']
                    ))
                  : createCommentVNode('v-if', true),
                _ctx.type === 'loading'
                  ? (openBlock(),
                    createBlock(
                      _component_var_loading,
                      {
                        key: 1,
                        type: _ctx.loadingType,
                        size: _ctx.loadingSize,
                      },
                      null,
                      8,
                      ['type', 'size']
                    ))
                  : createCommentVNode('v-if', true),
                renderSlot(_ctx.$slots, 'action'),
              ],
              2
            ),
          ],
          6
        ),
      ],
      6
    )),
    [[vShow, _ctx.show]]
  )
}
var VarSnackbarCore = defineComponent({
  render: render$c,
  name: 'VarSnackbarCore',
  components: {
    VarLoading: Loading,
    VarIcon: Icon,
  },
  props: props$a,
  setup(props2) {
    var timer = ref(null)
    var { zIndex } = useZIndex(() => props2.show, 1)
    useLock(
      () => props2.show,
      () => props2.lockScroll
    )
    var isForbidClick = computed(() => props2.type === 'loading' || props2.forbidClick)
    var iconName = computed(() => {
      if (!props2.type) return ''
      return ICON_TYPE_DICT[props2.type]
    })
    var updateAfterDuration = () => {
      timer.value = setTimeout(() => {
        var _props$onUpdateShow
        props2.type !== 'loading' &&
          ((_props$onUpdateShow = props2['onUpdate:show']) == null ? void 0 : _props$onUpdateShow.call(props2, false))
      }, props2.duration)
    }
    watch(
      () => props2.show,
      (show) => {
        if (show) {
          props2.onOpen == null ? void 0 : props2.onOpen()
          updateAfterDuration()
        } else if (show === false) {
          clearTimeout(timer.value)
          props2.onClose == null ? void 0 : props2.onClose()
        }
      }
    )
    watch(
      () => props2._update,
      () => {
        clearTimeout(timer.value)
        updateAfterDuration()
      }
    )
    onMounted(() => {
      if (props2.show) {
        props2.onOpen == null ? void 0 : props2.onOpen()
        updateAfterDuration()
      }
    })
    return {
      SNACKBAR_TYPE,
      n: n$e,
      classes: classes$a,
      zIndex,
      iconName,
      isForbidClick,
    }
  },
})
var { n: n$d } = createNamespace('snackbar')
function render$b(_ctx, _cache2) {
  var _component_var_snackbar_core = resolveComponent('var-snackbar-core')
  return (
    openBlock(),
    createBlock(
      Teleport,
      {
        to: _ctx.teleport,
        disabled: _ctx.disabled,
      },
      [
        createVNode(
          Transition,
          {
            name: _ctx.n() + '-fade',
            onAfterEnter: _ctx.onOpened,
            onAfterLeave: _ctx.onClosed,
          },
          {
            default: withCtx(() => [
              createVNode(
                _component_var_snackbar_core,
                mergeProps(_ctx.$props, {
                  class: _ctx.n('transition'),
                }),
                {
                  action: withCtx(() => [renderSlot(_ctx.$slots, 'action')]),
                  default: withCtx(() => [
                    renderSlot(_ctx.$slots, 'default', {}, () => [createTextVNode(toDisplayString(_ctx.content), 1)]),
                  ]),
                  _: 3,
                },
                16,
                ['class']
              ),
            ]),
            _: 3,
          },
          8,
          ['name', 'onAfterEnter', 'onAfterLeave']
        ),
      ],
      8,
      ['to', 'disabled']
    )
  )
}
var VarSnackbar = defineComponent({
  render: render$b,
  name: 'VarSnackbar',
  components: {
    VarSnackbarCore,
  },
  props: props$a,
  setup() {
    var { disabled } = useTeleport()
    return {
      n: n$d,
      disabled,
    }
  },
})
var SNACKBAR_TYPE = ['loading', 'success', 'warning', 'info', 'error']
reactive([])
SNACKBAR_TYPE.forEach((type) => {})
VarSnackbar.install = function (app) {
  app.component(VarSnackbar.name, VarSnackbar)
}
var internalSizeValidator = (size) => ['mini', 'small', 'normal', 'large'].includes(size)
var sizeValidator = (size) => {
  return internalSizeValidator(size) || isArray$1(size) || isNumber(size) || isString$1(size)
}
var justifyValidator = (justify) => {
  return ['start', 'end', 'center', 'space-around', 'space-between'].includes(justify)
}
var props$9 = {
  align: {
    type: String,
  },
  size: {
    type: [String, Number, Array],
    default: 'normal',
    validator: sizeValidator,
  },
  wrap: {
    type: Boolean,
    default: true,
  },
  direction: {
    type: String,
    default: 'row',
  },
  justify: {
    type: String,
    default: 'start',
    validator: justifyValidator,
  },
  inline: {
    type: Boolean,
    default: false,
  },
}
var { n: n$c, classes: classes$9 } = createNamespace('space')
var internalSizes = {
  mini: [4, 4],
  small: [6, 6],
  normal: [8, 12],
  large: [12, 20],
}
var Space = defineComponent({
  name: 'VarSpace',
  props: props$9,
  setup(props2, _ref) {
    var { slots } = _ref
    var getSize = (size, isInternalSize) => {
      return isInternalSize ? internalSizes[size] : isArray$1(size) ? size.map(toPxNum) : [toPxNum(size), toPxNum(size)]
    }
    return () => {
      var _call2
      var { inline, justify, align, wrap: wrap2, direction, size } = props2
      var children = (_call2 = call(slots.default)) != null ? _call2 : []
      var isInternalSize = internalSizeValidator(size)
      var [y2, x] = getSize(size, isInternalSize)
      var flatten = (vNodes) => {
        var result = []
        vNodes.forEach((vNode) => {
          if (vNode.type === Comment) return
          if (vNode.type === Fragment && isArray$1(vNode.children)) {
            vNode.children.forEach((item) => {
              result.push(item)
            })
            return
          }
          result.push(vNode)
        })
        return result
      }
      children = flatten(children)
      var lastIndex = children.length - 1
      var spacers = children.map((child, index2) => {
        var width = direction === 'row' ? void 0 : '100%'
        var margin = '0'
        if (direction === 'row') {
          if (justify === 'start' || justify === 'center' || justify === 'end') {
            if (index2 !== lastIndex) {
              margin = y2 / 2 + 'px ' + x + 'px ' + y2 / 2 + 'px 0'
            } else {
              margin = y2 / 2 + 'px 0'
            }
          } else if (justify === 'space-around') {
            margin = y2 / 2 + 'px ' + x / 2 + 'px'
          } else if (justify === 'space-between') {
            if (index2 === 0) {
              margin = y2 / 2 + 'px ' + x / 2 + 'px ' + y2 / 2 + 'px 0'
            } else if (index2 === lastIndex) {
              margin = y2 / 2 + 'px 0 ' + y2 / 2 + 'px ' + x / 2 + 'px'
            } else {
              margin = y2 / 2 + 'px ' + x / 2 + 'px'
            }
          }
        }
        if (direction === 'column' && index2 !== lastIndex) {
          margin = '0 0 ' + y2 + 'px 0'
        }
        return createVNode(
          'div',
          {
            style: {
              margin,
              width,
            },
          },
          [child]
        )
      })
      return createVNode(
        'div',
        {
          class: classes$9(n$c(), 'var--box', [inline, n$c('--inline')]),
          style: {
            flexDirection: direction,
            justifyContent: justify,
            alignItems: align,
            flexWrap: wrap2 ? 'wrap' : 'nowrap',
            margin: direction === 'row' ? '-' + y2 / 2 + 'px 0' : void 0,
          },
        },
        [spacers]
      )
    }
  },
})
Space.install = function (app) {
  app.component(Space.name, Space)
}
var props$8 = {
  activeIcon: {
    type: String,
    default: 'check',
  },
  currentIcon: {
    type: String,
  },
  inactiveIcon: {
    type: String,
  },
}
var STEPS_BIND_STEP_KEY = Symbol('STEPS_BIND_STEP_KEY')
var STEPS_COUNT_STEP_KEY = Symbol('STEPS_COUNT_STEP_KEY')
function useStep() {
  var { bindChildren, childProviders } = useChildren(STEPS_BIND_STEP_KEY)
  var { length } = useAtChildrenCounter(STEPS_COUNT_STEP_KEY)
  return {
    length,
    step: childProviders,
    bindStep: bindChildren,
  }
}
function useSteps() {
  var { parentProvider, bindParent } = useParent(STEPS_BIND_STEP_KEY)
  var { index: index2 } = useAtParentIndex(STEPS_COUNT_STEP_KEY)
  if (!parentProvider || !bindParent || !index2) {
    throw Error('[Varlet] Steps: <step/> must in <steps>')
  }
  return {
    index: index2,
    steps: parentProvider,
    bindSteps: bindParent,
  }
}
var { n: n$b, classes: classes$8 } = createNamespace('step')
var _hoisted_1$3 = {
  key: 3,
}
function render$a(_ctx, _cache2) {
  var _component_var_icon = resolveComponent('var-icon')
  return (
    openBlock(),
    createElementBlock(
      'div',
      {
        class: normalizeClass(_ctx.n()),
      },
      [
        createElementVNode(
          'div',
          {
            class: normalizeClass(_ctx.n(_ctx.direction)),
          },
          [
            createElementVNode(
              'div',
              {
                class: normalizeClass(_ctx.n(_ctx.direction + '-main')),
                ref: _ctx.getRef,
              },
              [
                createElementVNode(
                  'div',
                  {
                    class: normalizeClass(
                      _ctx.classes(_ctx.n(_ctx.direction + '-tag'), [
                        _ctx.isActive || _ctx.isCurrent,
                        _ctx.n(_ctx.direction + '-tag--active'),
                      ])
                    ),
                    style: normalizeStyle({
                      backgroundColor: _ctx.isActive || _ctx.isCurrent ? _ctx.activeColor : _ctx.inactiveColor,
                    }),
                    onClick:
                      _cache2[0] ||
                      (_cache2[0] = function () {
                        return _ctx.click && _ctx.click(...arguments)
                      }),
                  },
                  [
                    _ctx.isActive
                      ? (openBlock(),
                        createBlock(
                          _component_var_icon,
                          {
                            key: 0,
                            class: normalizeClass(_ctx.n('icon')),
                            'var-step-cover': '',
                            name: _ctx.activeIcon,
                          },
                          null,
                          8,
                          ['class', 'name']
                        ))
                      : _ctx.isCurrent && _ctx.currentIcon
                      ? (openBlock(),
                        createBlock(
                          _component_var_icon,
                          {
                            key: 1,
                            class: normalizeClass(_ctx.n('icon')),
                            'var-step-cover': '',
                            name: _ctx.currentIcon,
                          },
                          null,
                          8,
                          ['class', 'name']
                        ))
                      : _ctx.inactiveIcon
                      ? (openBlock(),
                        createBlock(
                          _component_var_icon,
                          {
                            key: 2,
                            class: normalizeClass(_ctx.n('icon')),
                            'var-step-cover': '',
                            name: _ctx.inactiveIcon,
                          },
                          null,
                          8,
                          ['class', 'name']
                        ))
                      : (openBlock(), createElementBlock('span', _hoisted_1$3, toDisplayString(_ctx.index + 1), 1)),
                  ],
                  6
                ),
                createElementVNode(
                  'div',
                  {
                    class: normalizeClass(
                      _ctx.classes(_ctx.n(_ctx.direction + '-content'), [
                        _ctx.isActive || _ctx.isCurrent,
                        _ctx.n(_ctx.direction + '-content--active'),
                      ])
                    ),
                    onClick:
                      _cache2[1] ||
                      (_cache2[1] = function () {
                        return _ctx.click && _ctx.click(...arguments)
                      }),
                  },
                  [renderSlot(_ctx.$slots, 'default')],
                  2
                ),
              ],
              2
            ),
            !_ctx.isLastChild
              ? (openBlock(),
                createElementBlock(
                  'div',
                  {
                    key: 0,
                    class: normalizeClass(_ctx.n(_ctx.direction + '-line')),
                    style: normalizeStyle({
                      margin: _ctx.lineMargin,
                    }),
                  },
                  null,
                  6
                ))
              : createCommentVNode('v-if', true),
          ],
          2
        ),
      ],
      2
    )
  )
}
var Step = defineComponent({
  render: render$a,
  name: 'VarStep',
  components: {
    VarIcon: Icon,
  },
  props: props$8,
  setup() {
    var main = ref(null)
    var lineMargin = ref('')
    var isLastChild = ref(false)
    var { index: index2, steps, bindSteps } = useSteps()
    var { active, length, activeColor, inactiveColor, direction, clickStep } = steps
    var isCurrent = computed(() => active.value === index2.value)
    var isActive = computed(() => index2.value !== -1 && active.value > index2.value)
    var stepProvider = {
      index: index2,
    }
    var click = () => clickStep(index2.value)
    var getRef = (el) => {
      if (direction.value === 'horizontal') {
        main.value = el
      }
    }
    bindSteps(stepProvider)
    watch(length, (newLength) => {
      isLastChild.value = newLength - 1 === index2.value
      if (main.value) {
        var margin = main.value.offsetWidth / 2 - 14
        lineMargin.value = '0 -' + margin + 'px'
      }
    })
    return {
      n: n$b,
      classes: classes$8,
      main,
      index: index2,
      isActive,
      isCurrent,
      direction,
      lineMargin,
      activeColor,
      inactiveColor,
      isLastChild,
      click,
      getRef,
    }
  },
})
Step.install = function (app) {
  app.component(Step.name, Step)
}
function directionValidator$1(direction) {
  return ['horizontal', 'vertical'].includes(direction)
}
var props$7 = {
  active: {
    type: [String, Number],
    default: 0,
  },
  direction: {
    type: String,
    default: 'horizontal',
    validator: directionValidator$1,
  },
  activeColor: {
    type: String,
  },
  inactiveColor: {
    type: String,
  },
  onClickStep: {
    type: Function,
  },
}
var { n: n$a } = createNamespace('steps')
function render$9(_ctx, _cache2) {
  return (
    openBlock(),
    createElementBlock(
      'div',
      {
        class: normalizeClass(_ctx.n()),
        style: normalizeStyle({
          flexDirection: _ctx.direction === 'horizontal' ? 'row' : 'column',
        }),
      },
      [renderSlot(_ctx.$slots, 'default')],
      6
    )
  )
}
var Steps = defineComponent({
  render: render$9,
  name: 'VarSteps',
  props: props$7,
  setup(props2) {
    var active = computed(() => props2.active)
    var activeColor = computed(() => props2.activeColor)
    var inactiveColor = computed(() => props2.inactiveColor)
    var direction = computed(() => props2.direction)
    var { length, bindStep } = useStep()
    var clickStep = (index2) => {
      call(props2.onClickStep, index2)
    }
    var stepsProvider = {
      active,
      length,
      direction,
      activeColor,
      inactiveColor,
      clickStep,
    }
    bindStep(stepsProvider)
    return {
      n: n$a,
    }
  },
})
Steps.install = function (app) {
  app.component(Steps.name, Steps)
}
var { n: n$9 } = createNamespace('style-provider')
var VarStyleProvider = defineComponent({
  name: 'VarStyleProvider',
  props: {
    styleVars: {
      type: Object,
      default: () => ({}),
    },
  },
  setup(props2, _ref) {
    var { slots } = _ref
    return () =>
      h$1(
        'div',
        {
          class: n$9(),
          style: formatStyleVars(props2.styleVars),
        },
        call(slots.default)
      )
  },
})
VarStyleProvider.install = function (app) {
  app.component(VarStyleProvider.name, VarStyleProvider)
}
var props$6 = {
  modelValue: {
    default: false,
  },
  activeValue: {
    default: true,
  },
  inactiveValue: {
    default: false,
  },
  disabled: {
    type: Boolean,
    default: false,
  },
  readonly: {
    type: Boolean,
    default: false,
  },
  loading: {
    type: Boolean,
    default: false,
  },
  color: {
    type: String,
  },
  loadingColor: {
    type: String,
  },
  closeColor: {
    type: String,
  },
  size: {
    type: [String, Number],
  },
  rules: {
    type: Array,
  },
  ripple: {
    type: Boolean,
    default: true,
  },
  onClick: {
    type: Function,
  },
  onChange: {
    type: Function,
  },
  'onUpdate:modelValue': {
    type: Function,
  },
}
var { n: n$8, classes: classes$7 } = createNamespace('switch')
function render$8(_ctx, _cache2) {
  var _component_var_loading = resolveComponent('var-loading')
  var _component_var_form_details = resolveComponent('var-form-details')
  var _directive_ripple = resolveDirective('ripple')
  return (
    openBlock(),
    createElementBlock(
      'div',
      {
        class: normalizeClass(_ctx.n()),
      },
      [
        createElementVNode(
          'div',
          {
            class: normalizeClass(
              _ctx.classes(_ctx.n('block'), [_ctx.disabled || _ctx.formDisabled, _ctx.n('--disable')])
            ),
            onClick:
              _cache2[0] ||
              (_cache2[0] = function () {
                return _ctx.switchActive && _ctx.switchActive(...arguments)
              }),
            style: normalizeStyle(_ctx.styleComputed.switch),
          },
          [
            createElementVNode(
              'div',
              {
                style: normalizeStyle(_ctx.styleComputed.track),
                class: normalizeClass(
                  _ctx.classes(
                    _ctx.n('track'),
                    [_ctx.modelValue === _ctx.activeValue, _ctx.n('track--active')],
                    [_ctx.errorMessage, _ctx.n('track--error')]
                  )
                ),
              },
              null,
              6
            ),
            withDirectives(
              (openBlock(),
              createElementBlock(
                'div',
                {
                  class: normalizeClass(
                    _ctx.classes(_ctx.n('ripple'), [_ctx.modelValue === _ctx.activeValue, _ctx.n('ripple--active')])
                  ),
                  style: normalizeStyle(_ctx.styleComputed.ripple),
                },
                [
                  createElementVNode(
                    'div',
                    {
                      style: normalizeStyle(_ctx.styleComputed.handle),
                      class: normalizeClass(
                        _ctx.classes(
                          _ctx.n('handle'),
                          'var-elevation--2',
                          [_ctx.modelValue === _ctx.activeValue, _ctx.n('handle--active')],
                          [_ctx.errorMessage, _ctx.n('handle--error')]
                        )
                      ),
                    },
                    [
                      _ctx.loading
                        ? (openBlock(),
                          createBlock(
                            _component_var_loading,
                            {
                              key: 0,
                              radius: _ctx.radius,
                            },
                            null,
                            8,
                            ['radius']
                          ))
                        : createCommentVNode('v-if', true),
                    ],
                    6
                  ),
                ],
                6
              )),
              [
                [
                  _directive_ripple,
                  {
                    disabled: !_ctx.ripple || _ctx.disabled || _ctx.loading || _ctx.formDisabled,
                  },
                ],
              ]
            ),
          ],
          6
        ),
        createVNode(
          _component_var_form_details,
          {
            'error-message': _ctx.errorMessage,
          },
          null,
          8,
          ['error-message']
        ),
      ],
      2
    )
  )
}
var Switch = defineComponent({
  render: render$8,
  name: 'VarSwitch',
  components: {
    VarLoading: Loading,
    VarFormDetails: FormDetails,
  },
  directives: {
    Ripple,
  },
  props: props$6,
  setup(props2) {
    var { bindForm, form } = useForm()
    var { errorMessage, validateWithTrigger: vt, validate: v, resetValidation } = useValidation()
    var validate2 = () => v(props2.rules, props2.modelValue)
    var validateWithTrigger = () => nextTick(() => vt(['onChange'], 'onChange', props2.rules, props2.modelValue))
    var styleComputed = computed(() => {
      var { size, modelValue, color, closeColor, loadingColor, activeValue } = props2
      return {
        handle: {
          width: multiplySizeUnit(size),
          height: multiplySizeUnit(size),
          backgroundColor: modelValue === activeValue ? color || '' : closeColor || '',
          color: loadingColor && loadingColor,
        },
        ripple: {
          left: modelValue === activeValue ? multiplySizeUnit(size, 0.5) : '-' + multiplySizeUnit(size, 0.5),
          color: modelValue === activeValue ? color || '' : closeColor || '#999',
          width: multiplySizeUnit(size, 2),
          height: multiplySizeUnit(size, 2),
        },
        track: {
          height: multiplySizeUnit(size, 0.72),
          width: multiplySizeUnit(size, 1.9),
          borderRadius: multiplySizeUnit(size, 2 / 3),
          filter:
            modelValue === activeValue || (errorMessage != null && errorMessage.value)
              ? 'opacity(.6)'
              : 'brightness(.6)',
          backgroundColor: modelValue === activeValue ? color || '' : closeColor || '',
        },
        switch: {
          height: multiplySizeUnit(size, 1.2),
          width: multiplySizeUnit(size, 2),
        },
      }
    })
    var radius = computed(() => {
      var { size = '5.333vw' } = props2
      return multiplySizeUnit(size, 0.4)
    })
    var switchActive = (event) => {
      var {
        onClick,
        onChange,
        disabled,
        loading: loading2,
        readonly,
        modelValue,
        activeValue,
        inactiveValue,
        'onUpdate:modelValue': updateModelValue,
      } = props2
      call(onClick, event)
      if (
        disabled ||
        loading2 ||
        readonly ||
        (form != null && form.disabled.value) ||
        (form != null && form.readonly.value)
      )
        return
      var newValue = modelValue === activeValue ? inactiveValue : activeValue
      call(onChange, newValue)
      call(updateModelValue, newValue)
      validateWithTrigger()
    }
    var reset = () => {
      call(props2['onUpdate:modelValue'], props2.inactiveValue)
      resetValidation()
    }
    var switchProvider = {
      reset,
      validate: validate2,
      resetValidation,
    }
    call(bindForm, switchProvider)
    return {
      n: n$8,
      classes: classes$7,
      switchActive,
      radius,
      styleComputed,
      errorMessage,
      formDisabled: form == null ? void 0 : form.disabled,
      formReadonly: form == null ? void 0 : form.readonly,
    }
  },
})
Switch.install = function (app) {
  app.component(Switch.name, Switch)
}
var props$5 = {
  name: {
    type: [String, Number],
  },
  disabled: {
    type: Boolean,
    default: false,
  },
  onClick: {
    type: Function,
  },
}
var TABS_BIND_TAB_KEY = Symbol('TABS_BIND_TAB_KEY')
var TABS_COUNT_TAB_KEY = Symbol('TABS_COUNT_TAB_KEY')
function useTabList() {
  var { childProviders, bindChildren } = useChildren(TABS_BIND_TAB_KEY)
  var { length } = useAtChildrenCounter(TABS_COUNT_TAB_KEY)
  return {
    length,
    tabList: childProviders,
    bindTabList: bindChildren,
  }
}
function useTabs() {
  var { parentProvider, bindParent } = useParent(TABS_BIND_TAB_KEY)
  var { index: index2 } = useAtParentIndex(TABS_COUNT_TAB_KEY)
  if (!parentProvider || !bindParent || !index2) {
    throw Error('<var-tab/> must in <var-tabs/>')
  }
  return {
    index: index2,
    tabs: parentProvider,
    bindTabs: bindParent,
  }
}
var { n: n$7, classes: classes$6 } = createNamespace('tab')
function render$7(_ctx, _cache2) {
  var _directive_ripple = resolveDirective('ripple')
  return withDirectives(
    (openBlock(),
    createElementBlock(
      'div',
      {
        class: normalizeClass(
          _ctx.classes(_ctx.n(), 'var--box', _ctx.computeColorClass(), _ctx.n('--' + _ctx.itemDirection))
        ),
        ref: 'tabEl',
        style: normalizeStyle({
          color: _ctx.computeColorStyle(),
        }),
        onClick:
          _cache2[0] ||
          (_cache2[0] = function () {
            return _ctx.handleClick && _ctx.handleClick(...arguments)
          }),
      },
      [renderSlot(_ctx.$slots, 'default')],
      6
    )),
    [
      [
        _directive_ripple,
        {
          disabled: _ctx.disabled,
        },
      ],
    ]
  )
}
var Tab = defineComponent({
  render: render$7,
  name: 'VarTab',
  directives: {
    Ripple,
  },
  props: props$5,
  setup(props2) {
    var tabEl = ref(null)
    var name = computed(() => props2.name)
    var disabled = computed(() => props2.disabled)
    var element = computed(() => tabEl.value)
    var { index: index2, tabs, bindTabs } = useTabs()
    var { onTabClick, active, activeColor, inactiveColor, disabledColor, itemDirection, resize } = tabs
    var tabProvider = {
      name,
      index: index2,
      disabled,
      element,
    }
    bindTabs(tabProvider)
    var computeColorStyle = () => {
      var { disabled: disabled2, name: name2 } = props2
      return disabled2
        ? disabledColor.value
        : active.value === name2 || active.value === (index2 == null ? void 0 : index2.value)
        ? activeColor.value
        : inactiveColor.value
    }
    var computeColorClass = () => {
      var { disabled: disabled2, name: name2 } = props2
      return disabled2
        ? 'var-tab--disabled'
        : active.value === name2 || active.value === (index2 == null ? void 0 : index2.value)
        ? 'var-tab--active'
        : 'var-tab--inactive'
    }
    var handleClick = (event) => {
      var { disabled: disabled2, name: name2, onClick } = props2
      if (disabled2) {
        return
      }
      onClick == null ? void 0 : onClick(name2 != null ? name2 : index2.value, event)
      onTabClick(tabProvider)
    }
    watch(() => props2.name, resize)
    watch(() => props2.disabled, resize)
    return {
      n: n$7,
      classes: classes$6,
      tabEl,
      active,
      activeColor,
      inactiveColor,
      itemDirection,
      computeColorStyle,
      computeColorClass,
      handleClick,
    }
  },
})
Tab.install = function (app) {
  app.component(Tab.name, Tab)
}
var TABS_ITEMS_BIND_TAB_ITEM_KEY = Symbol('TABS_ITEMS_BIND_TAB_ITEM_KEY')
var TABS_ITEMS_COUNT_TAB_ITEM_KEY = Symbol('TABS_ITEMS_COUNT_TAB_ITEM_KEY')
function useTabItem() {
  var { bindChildren, childProviders } = useChildren(TABS_ITEMS_BIND_TAB_ITEM_KEY)
  var { length } = useAtChildrenCounter(TABS_ITEMS_COUNT_TAB_ITEM_KEY)
  return {
    length,
    tabItemList: childProviders,
    bindTabItem: bindChildren,
  }
}
function useTabsItems() {
  var { parentProvider, bindParent } = useParent(TABS_ITEMS_BIND_TAB_ITEM_KEY)
  var { index: index2 } = useAtParentIndex(TABS_ITEMS_COUNT_TAB_ITEM_KEY)
  if (!parentProvider || !bindParent || !index2) {
    throw Error('<var-tab-item/> must in <var-tabs-items/>')
  }
  return {
    index: index2,
    tabsItems: parentProvider,
    bindTabsItems: bindParent,
  }
}
var props$4 = {
  name: {
    type: [String, Number],
  },
}
var { n: n$6, classes: classes$5 } = createNamespace('tab-item')
function render$6(_ctx, _cache2) {
  var _component_var_swipe_item = resolveComponent('var-swipe-item')
  return (
    openBlock(),
    createBlock(
      _component_var_swipe_item,
      {
        class: normalizeClass(_ctx.classes(_ctx.n(), [!_ctx.current, _ctx.n('--inactive')])),
        'var-tab-item-cover': '',
      },
      {
        default: withCtx(() => [
          _ctx.initSlot
            ? renderSlot(_ctx.$slots, 'default', {
                key: 0,
              })
            : createCommentVNode('v-if', true),
        ]),
        _: 3,
      },
      8,
      ['class']
    )
  )
}
var TabItem = defineComponent({
  render: render$6,
  name: 'VarTabItem',
  components: {
    VarSwipeItem: SwipeItem,
  },
  props: props$4,
  setup(props2) {
    var current = ref(false)
    var initSlot = ref(false)
    var name = computed(() => props2.name)
    var { index: index2, bindTabsItems } = useTabsItems()
    var setCurrent = (value) => {
      if (!initSlot.value && value) {
        initSlot.value = true
      }
      current.value = value
    }
    var tabItemProvider = {
      index: index2,
      name,
      setCurrent,
    }
    bindTabsItems(tabItemProvider)
    return {
      n: n$6,
      classes: classes$5,
      current,
      initSlot,
    }
  },
})
TabItem.install = function (app) {
  app.component(TabItem.name, TabItem)
}
var { n: n$5, classes: classes$4 } = createNamespace('table')
function render$5(_ctx, _cache2) {
  return (
    openBlock(),
    createElementBlock(
      'div',
      {
        class: normalizeClass(_ctx.classes(_ctx.n(), 'var-elevation--1 var--box')),
      },
      [
        createElementVNode(
          'div',
          {
            class: normalizeClass(_ctx.n('main')),
          },
          [
            createElementVNode(
              'table',
              {
                class: normalizeClass(_ctx.n('table')),
                style: normalizeStyle({
                  width: _ctx.toSizeUnit(_ctx.fullWidth),
                }),
              },
              [renderSlot(_ctx.$slots, 'default')],
              6
            ),
          ],
          2
        ),
        _ctx.$slots.footer
          ? (openBlock(),
            createElementBlock(
              'div',
              {
                key: 0,
                class: normalizeClass(_ctx.n('footer')),
              },
              [renderSlot(_ctx.$slots, 'footer')],
              2
            ))
          : createCommentVNode('v-if', true),
      ],
      2
    )
  )
}
var Table = defineComponent({
  render: render$5,
  name: 'VarTable',
  props: {
    fullWidth: {
      type: [Number, String],
      default: '100%',
    },
  },
  setup() {
    return {
      toSizeUnit,
      n: n$5,
      classes: classes$4,
    }
  },
})
Table.install = function (app) {
  app.component(Table.name, Table)
}
function directionValidator(direction) {
  return ['horizontal', 'vertical'].includes(direction)
}
var props$3 = {
  active: {
    type: [String, Number],
    default: 0,
  },
  layoutDirection: {
    type: String,
    default: 'horizontal',
    validator: directionValidator,
  },
  itemDirection: {
    type: String,
    default: 'horizontal',
    validator: directionValidator,
  },
  fixedBottom: {
    type: Boolean,
    default: false,
  },
  activeColor: {
    type: String,
  },
  inactiveColor: {
    type: String,
  },
  disabledColor: {
    type: String,
  },
  color: {
    type: String,
  },
  indicatorColor: {
    type: String,
  },
  indicatorSize: {
    type: [String, Number],
  },
  elevation: {
    type: Boolean,
    default: false,
  },
  sticky: {
    type: Boolean,
    default: false,
  },
  safeArea: {
    type: Boolean,
    default: false,
  },
  offsetTop: pickProps(props$s, 'offsetTop'),
  onClick: {
    type: Function,
  },
  onChange: {
    type: Function,
  },
  'onUpdate:active': {
    type: Function,
  },
}
function asyncGeneratorStep$1(gen, resolve2, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg)
    var value = info.value
  } catch (error) {
    reject(error)
    return
  }
  if (info.done) {
    resolve2(value)
  } else {
    Promise.resolve(value).then(_next, _throw)
  }
}
function _asyncToGenerator$1(fn) {
  return function () {
    var self2 = this,
      args = arguments
    return new Promise(function (resolve2, reject) {
      var gen = fn.apply(self2, args)
      function _next(value) {
        asyncGeneratorStep$1(gen, resolve2, reject, _next, _throw, 'next', value)
      }
      function _throw(err) {
        asyncGeneratorStep$1(gen, resolve2, reject, _next, _throw, 'throw', err)
      }
      _next(void 0)
    })
  }
}
var { n: n$4, classes: classes$3 } = createNamespace('tabs')
function render$4(_ctx, _cache2) {
  return (
    openBlock(),
    createBlock(
      resolveDynamicComponent(_ctx.sticky ? 'var-sticky' : _ctx.Transition),
      {
        'offset-top': _ctx.sticky ? _ctx.offsetTop : null,
      },
      {
        default: withCtx(() => [
          createElementVNode(
            'div',
            mergeProps(
              {
                class: _ctx.classes(
                  _ctx.n(),
                  'var--box',
                  _ctx.n('--item-' + _ctx.itemDirection),
                  _ctx.n('--layout-' + _ctx.layoutDirection + '-padding'),
                  [_ctx.elevation, 'var-elevation--4'],
                  [_ctx.fixedBottom, _ctx.n('--fixed-bottom')],
                  [_ctx.safeArea, _ctx.n('--safe-area')]
                ),
                style: {
                  background: _ctx.color,
                },
              },
              _ctx.$attrs
            ),
            [
              createElementVNode(
                'div',
                {
                  ref: 'scrollerEl',
                  class: normalizeClass(
                    _ctx.classes(
                      _ctx.n('tab-wrap'),
                      [_ctx.scrollable, _ctx.n('--layout-' + _ctx.layoutDirection + '-scrollable')],
                      _ctx.n('--layout-' + _ctx.layoutDirection)
                    )
                  ),
                },
                [
                  renderSlot(_ctx.$slots, 'default'),
                  createElementVNode(
                    'div',
                    {
                      class: normalizeClass(
                        _ctx.classes(_ctx.n('indicator'), _ctx.n('--layout-' + _ctx.layoutDirection + '-indicator'))
                      ),
                      style: normalizeStyle({
                        width:
                          _ctx.layoutDirection === 'horizontal'
                            ? _ctx.indicatorWidth
                            : _ctx.toSizeUnit(_ctx.indicatorSize),
                        height:
                          _ctx.layoutDirection === 'horizontal'
                            ? _ctx.toSizeUnit(_ctx.indicatorSize)
                            : _ctx.indicatorHeight,
                        transform:
                          _ctx.layoutDirection === 'horizontal'
                            ? 'translateX(' + _ctx.indicatorX + ')'
                            : 'translateY(' + _ctx.indicatorY + ')',
                        background: _ctx.indicatorColor || _ctx.activeColor,
                      }),
                    },
                    null,
                    6
                  ),
                ],
                2
              ),
            ],
            16
          ),
        ]),
        _: 3,
      },
      8,
      ['offset-top']
    )
  )
}
var Tabs = defineComponent({
  render: render$4,
  name: 'VarTabs',
  components: {
    VarSticky: Sticky,
  },
  inheritAttrs: false,
  props: props$3,
  setup(props2) {
    var indicatorWidth = ref('0px')
    var indicatorHeight = ref('0px')
    var indicatorX = ref('0px')
    var indicatorY = ref('0px')
    var scrollable = ref(false)
    var scrollerEl = ref(null)
    var active = computed(() => props2.active)
    var activeColor = computed(() => props2.activeColor)
    var inactiveColor = computed(() => props2.inactiveColor)
    var disabledColor = computed(() => props2.disabledColor)
    var itemDirection = computed(() => props2.itemDirection)
    var { tabList, bindTabList, length } = useTabList()
    var onTabClick = (tab) => {
      var _tab$name$value
      var currentActive = (_tab$name$value = tab.name.value) != null ? _tab$name$value : tab.index.value
      var { active: active2, onChange, onClick } = props2
      call(props2['onUpdate:active'], currentActive)
      call(onClick, currentActive)
      currentActive !== active2 && call(onChange, currentActive)
    }
    var matchName = () => {
      return tabList.find((_ref) => {
        var { name } = _ref
        return props2.active === name.value
      })
    }
    var matchIndex = (activeIndex) => {
      return tabList.find((_ref2) => {
        var { index: index2 } = _ref2
        return (activeIndex != null ? activeIndex : props2.active) === index2.value
      })
    }
    var matchBoundary = () => {
      if (length.value === 0) {
        return
      }
      var { active: active2 } = props2
      if (isNumber(active2)) {
        var activeIndex = active2 > length.value - 1 ? length.value - 1 : 0
        call(props2['onUpdate:active'], activeIndex)
        return matchIndex(activeIndex)
      }
    }
    var watchScrollable = () => {
      scrollable.value = tabList.length >= 5
    }
    var moveIndicator = (_ref3) => {
      var { element } = _ref3
      var el = element.value
      if (props2.layoutDirection === 'horizontal') {
        indicatorWidth.value = (el == null ? void 0 : el.offsetWidth) + 'px'
        indicatorX.value = (el == null ? void 0 : el.offsetLeft) + 'px'
      } else {
        indicatorHeight.value = (el == null ? void 0 : el.offsetHeight) + 'px'
        indicatorY.value = (el == null ? void 0 : el.offsetTop) + 'px'
      }
    }
    var scrollToCenter = (_ref4) => {
      var { element } = _ref4
      if (!scrollable.value) {
        return
      }
      var scroller = scrollerEl.value
      var el = element.value
      if (props2.layoutDirection === 'horizontal') {
        var left = el.offsetLeft + el.offsetWidth / 2 - scroller.offsetWidth / 2
        scrollTo(scroller, {
          left,
          animation: linear,
        })
      } else {
        var top = el.offsetTop + el.offsetHeight / 2 - scroller.offsetHeight / 2
        scrollTo(scroller, {
          top,
          animation: linear,
        })
      }
    }
    var resize = () => {
      var tab = matchName() || matchIndex() || matchBoundary()
      if (!tab || tab.disabled.value) {
        return
      }
      watchScrollable()
      moveIndicator(tab)
      scrollToCenter(tab)
    }
    var tabsProvider = {
      active,
      activeColor,
      inactiveColor,
      disabledColor,
      itemDirection,
      resize,
      onTabClick,
    }
    bindTabList(tabsProvider)
    watch(
      () => length.value,
      /* @__PURE__ */ _asyncToGenerator$1(function* () {
        yield doubleRaf()
        resize()
      })
    )
    watch(() => props2.active, resize)
    onMounted(() => window.addEventListener('resize', resize))
    onUnmounted(() => window.removeEventListener('resize', resize))
    return {
      indicatorWidth,
      indicatorHeight,
      indicatorX,
      indicatorY,
      scrollable,
      scrollerEl,
      Transition,
      toSizeUnit,
      n: n$4,
      classes: classes$3,
      resize,
    }
  },
})
Tabs.install = function (app) {
  app.component(Tabs.name, Tabs)
}
var props$2 = {
  active: {
    type: [String, Number],
    default: 0,
  },
  canSwipe: {
    type: Boolean,
    default: true,
  },
  loop: {
    type: Boolean,
    default: false,
  },
  'onUpdate:active': {
    type: Function,
  },
}
var { n: n$3 } = createNamespace('tabs-items')
function render$3(_ctx, _cache2) {
  var _component_var_swipe = resolveComponent('var-swipe')
  return (
    openBlock(),
    createBlock(
      _component_var_swipe,
      {
        class: normalizeClass(_ctx.n()),
        ref: 'swipe',
        loop: _ctx.loop,
        touchable: _ctx.canSwipe,
        indicator: false,
        onChange: _ctx.handleSwipeChange,
      },
      {
        default: withCtx(() => [renderSlot(_ctx.$slots, 'default')]),
        _: 3,
      },
      8,
      ['class', 'loop', 'touchable', 'onChange']
    )
  )
}
var TabsItems = defineComponent({
  render: render$3,
  name: 'VarTabsItems',
  components: {
    VarSwipe: Swipe,
  },
  props: props$2,
  setup(props2) {
    var swipe = ref(null)
    var { tabItemList, bindTabItem, length } = useTabItem()
    var matchName = (active) => {
      return tabItemList.find((_ref) => {
        var { name } = _ref
        return active === name.value
      })
    }
    var matchIndex = (active) => {
      return tabItemList.find((_ref2) => {
        var { index: index2 } = _ref2
        return active === index2.value
      })
    }
    var matchActive = (active) => {
      return matchName(active) || matchIndex(active)
    }
    var handleActiveChange = (newValue) => {
      var _swipe$value
      var newActiveTabItemProvider = matchActive(newValue)
      if (!newActiveTabItemProvider) {
        return
      }
      tabItemList.forEach((_ref3) => {
        var { setCurrent } = _ref3
        return setCurrent(false)
      })
      newActiveTabItemProvider.setCurrent(true)
      ;(_swipe$value = swipe.value) == null ? void 0 : _swipe$value.to(newActiveTabItemProvider.index.value)
    }
    var handleSwipeChange = (currentIndex) => {
      var _tabItem$name$value
      var tabItem = tabItemList.find((_ref4) => {
        var { index: index2 } = _ref4
        return index2.value === currentIndex
      })
      var active = (_tabItem$name$value = tabItem.name.value) != null ? _tabItem$name$value : tabItem.index.value
      call(props2['onUpdate:active'], active)
    }
    var tabsItemsProvider = {}
    bindTabItem(tabsItemsProvider)
    watch(() => props2.active, handleActiveChange)
    watch(
      () => length.value,
      () => handleActiveChange(props2.active)
    )
    return {
      swipe,
      n: n$3,
      handleSwipeChange,
    }
  },
})
TabsItems.install = function (app) {
  app.component(TabsItems.name, TabsItems)
}
var hoursAmpm = ['12', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11']
var hours24 = ['00', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23']
var minSec = ['00', '05', '10', '15', '20', '25', '30', '35', '40', '45', '50', '55']
function formatValidator(type) {
  return ['ampm', '24hr'].includes(type)
}
var props$1 = {
  modelValue: {
    type: String,
  },
  shadow: {
    type: Boolean,
    default: false,
  },
  color: {
    type: String,
  },
  headerColor: {
    type: String,
  },
  format: {
    type: String,
    default: 'ampm',
    validator: formatValidator,
  },
  allowedTime: {
    type: Object,
  },
  min: {
    type: String,
  },
  max: {
    type: String,
  },
  useSeconds: {
    type: Boolean,
    default: false,
  },
  readonly: {
    type: Boolean,
    default: false,
  },
  'onUpdate:modelValue': {
    type: Function,
  },
  onChange: {
    type: Function,
  },
}
var notConvert = (format, ampm) => format === '24hr' || ampm === 'am'
var convertHour = (format, ampm, hour) => {
  var index2 = hoursAmpm.findIndex((hourAmpm) => toNumber(hourAmpm) === toNumber(hour))
  var getHour = notConvert(format, ampm) ? hour : hours24[index2]
  return {
    hourStr: getHour,
    hourNum: toNumber(getHour),
  }
}
var getNumberTime = (time) => {
  var [hour, minute, second] = time.split(':')
  return {
    hour: toNumber(hour),
    minute: toNumber(minute),
    second: toNumber(second),
  }
}
var getIsDisableMinute = (values) => {
  var _values$allowedTime, _values$allowedTime2
  var { time, format, ampm, hour, max: max2, min: min2, disableHour } = values
  var { hourStr, hourNum } = convertHour(format, ampm, hour)
  var isBetweenMinMax = false
  var isAllow = false
  if (disableHour.includes(hourStr)) return true
  if (max2 && !min2) {
    var { hour: maxHour, minute: maxMinute } = getNumberTime(max2)
    isBetweenMinMax = maxHour === hourNum && time > maxMinute
  }
  if (!max2 && min2) {
    var { hour: minHour, minute: minMinute } = getNumberTime(min2)
    isBetweenMinMax = minHour === hourNum && time < minMinute
  }
  if (max2 && min2) {
    var { hour: _maxHour, minute: _maxMinute } = getNumberTime(max2)
    var { hour: _minHour, minute: _minMinute } = getNumberTime(min2)
    isBetweenMinMax = (_minHour === hourNum && time < _minMinute) || (_maxHour === hourNum && time > _maxMinute)
  }
  if ((_values$allowedTime = values.allowedTime) != null && _values$allowedTime.minutes)
    isAllow = (_values$allowedTime2 = values.allowedTime) == null ? void 0 : _values$allowedTime2.minutes(time)
  return isBetweenMinMax || isAllow
}
var getIsDisableSecond = (values) => {
  var _values$allowedTime3, _values$allowedTime4
  var { time, format, ampm, hour, minute, max: max2, min: min2, disableHour } = values
  var { hourStr, hourNum } = convertHour(format, ampm, hour)
  var isBetweenMinMax = false
  var isAllow = false
  if (disableHour.includes(hourStr)) return true
  if (max2 && !min2) {
    var { hour: maxHour, minute: maxMinute, second: maxSecond } = getNumberTime(max2)
    isBetweenMinMax = (maxHour === hourNum && maxMinute < minute) || (maxMinute === minute && time > maxSecond)
  }
  if (!max2 && min2) {
    var { hour: minHour, minute: minMinute, second: minSecond } = getNumberTime(min2)
    isBetweenMinMax = (minHour === hourNum && minMinute > minute) || (minMinute === minute && time > minSecond)
  }
  if (max2 && min2) {
    var { hour: _maxHour2, minute: _maxMinute2, second: _maxSecond } = getNumberTime(max2)
    var { hour: _minHour2, minute: _minMinute2, second: _minSecond } = getNumberTime(min2)
    isBetweenMinMax =
      (_maxHour2 === hourNum && _maxMinute2 < minute) ||
      (_minHour2 === hourNum && _minMinute2 > minute) ||
      (_maxHour2 === hourNum && _maxMinute2 === minute && time > _maxSecond) ||
      (_minHour2 === hourNum && _minMinute2 === minute && time < _minSecond)
  }
  if ((_values$allowedTime3 = values.allowedTime) != null && _values$allowedTime3.seconds)
    isAllow = (_values$allowedTime4 = values.allowedTime) == null ? void 0 : _values$allowedTime4.seconds(time)
  return isBetweenMinMax || isAllow
}
var { n: n$2, classes: classes$2 } = createNamespace('time-picker')
function render$2(_ctx, _cache2) {
  return (
    openBlock(),
    createElementBlock(
      'div',
      {
        class: normalizeClass(_ctx.n('clock')),
      },
      [
        createElementVNode(
          'div',
          {
            class: normalizeClass(_ctx.n('clock-hand')),
            style: normalizeStyle(_ctx.handStyle),
          },
          null,
          6
        ),
        (openBlock(true),
        createElementBlock(
          Fragment,
          null,
          renderList(_ctx.timeScales, (timeScale, index2) => {
            return (
              openBlock(),
              createElementBlock(
                'div',
                {
                  class: normalizeClass(
                    _ctx.classes(
                      _ctx.n('clock-item'),
                      [_ctx.isActive(index2, false), _ctx.n('clock-item--active')],
                      [_ctx.isDisable(timeScale), _ctx.n('clock-item--disable')]
                    )
                  ),
                  key: timeScale,
                  style: normalizeStyle(_ctx.getStyle(index2, timeScale, false)),
                },
                toDisplayString(timeScale),
                7
              )
            )
          }),
          128
        )),
        _ctx.format === '24hr' && _ctx.type === 'hour'
          ? (openBlock(),
            createElementBlock(
              'div',
              {
                key: 0,
                class: normalizeClass(_ctx.n('clock-inner')),
                ref: 'inner',
              },
              [
                (openBlock(true),
                createElementBlock(
                  Fragment,
                  null,
                  renderList(_ctx.hours24, (hour, index2) => {
                    return (
                      openBlock(),
                      createElementBlock(
                        'div',
                        {
                          class: normalizeClass(
                            _ctx.classes(
                              _ctx.n('clock-item'),
                              [_ctx.isActive(index2, true), _ctx.n('clock-item--active')],
                              [_ctx.isDisable(hour), _ctx.n('clock-item--disable')]
                            )
                          ),
                          key: hour,
                          style: normalizeStyle(_ctx.getStyle(index2, hour, true)),
                        },
                        toDisplayString(hour),
                        7
                      )
                    )
                  }),
                  128
                )),
              ],
              2
            ))
          : createCommentVNode('v-if', true),
      ],
      2
    )
  )
}
var Clock = defineComponent({
  render: render$2,
  name: 'Clock',
  props: {
    isInner: {
      type: Boolean,
      required: true,
    },
    rad: {
      type: Number,
    },
    format: {
      type: String,
      default: 'ampm',
    },
    allowedTime: {
      type: Object,
    },
    time: {
      type: Object,
      required: true,
    },
    useSeconds: {
      type: Boolean,
      default: false,
    },
    preventNextUpdate: {
      type: Boolean,
      default: false,
    },
    type: {
      type: String,
      default: 'hour',
    },
    ampm: {
      type: String,
      default: 'am',
    },
    color: {
      type: String,
    },
    min: {
      type: String,
    },
    max: {
      type: String,
    },
  },
  emits: ['update', 'change-prevent-update'],
  setup(props2, _ref) {
    var { emit } = _ref
    var inner = ref(null)
    var disableHour = ref([])
    var disable24HourIndex = ref([])
    var handStyle = computed(() => ({
      transform: 'rotate(' + toNumber(props2.rad) + 'deg)',
      height: props2.isInner && props2.type === 'hour' ? 'calc(50% - 40px)' : 'calc(50% - 4px)',
      backgroundColor: getHandleColor(),
      borderColor: getHandleColor(),
    }))
    var activeItemIndex = computed(() => {
      if (props2.rad === void 0) return
      var value = props2.rad / 30
      return value >= 0 ? value : value + 12
    })
    var timeScales = computed(() => {
      if (props2.type === 'hour') return hoursAmpm
      return minSec
    })
    var isDisableMinSec = (time, isDisable2) => {
      var _time
      time = (_time = time) != null ? _time : props2.type === 'minute' ? props2.time.minute : props2.time.second
      var disableMethod = props2.type === 'minute' ? getIsDisableMinute : getIsDisableSecond
      var values = {
        time: toNumber(time),
        format: props2.format,
        ampm: props2.ampm,
        hour: props2.time.hour,
        minute: toNumber(props2.time.minute),
        max: props2.max,
        min: props2.min,
        allowedTime: props2.allowedTime,
        disableHour: disableHour.value,
      }
      if (isDisable2 && props2.type === 'minute') Reflect.deleteProperty(values, 'minute')
      return disableMethod(values)
    }
    var getHandleColor = () => {
      if (activeItemIndex.value === void 0) return props2.color
      var hour = props2.isInner ? hours24[activeItemIndex.value] : timeScales.value[activeItemIndex.value]
      if (timeScales.value === minSec) {
        return isDisableMinSec() ? '#bdbdbd' : props2.color
      }
      return isDisable(hour) ? '#bdbdbd' : props2.color
    }
    var isActive = (index2, inner2) => {
      if (inner2) return activeItemIndex.value === index2 && props2.isInner
      return activeItemIndex.value === index2 && (!props2.isInner || props2.type !== 'hour')
    }
    var isDisable = (time) => {
      if (props2.type === 'hour') {
        if (notConvert(props2.format, props2.ampm)) return disableHour.value.includes(time)
        var timeIndex = hoursAmpm.findIndex((hour) => hour === time)
        return disable24HourIndex.value.includes(timeIndex)
      }
      return isDisableMinSec(time, true)
    }
    var getStyle = (index2, hour, inner2) => {
      var rad = ((2 * Math.PI) / 12) * index2 - Math.PI / 2
      var left = 50 * (1 + Math.cos(rad))
      var top = 50 * (1 + Math.sin(rad))
      var computedColor = () => {
        if (!isActive(index2, inner2)) {
          return {
            backgroundColor: void 0,
            color: void 0,
          }
        }
        if (isDisable(hour)) {
          return {
            backgroundColor: '#bdbdbd',
            color: '#fff',
          }
        }
        return {
          backgroundColor: props2.color,
          color: void 0,
        }
      }
      var { backgroundColor, color } = computedColor()
      return {
        left: left + '%',
        top: top + '%',
        backgroundColor,
        color,
      }
    }
    var getSize = () => {
      var { width, height } = inner.value.getBoundingClientRect()
      return {
        width,
        height,
      }
    }
    var getHour = () => {
      if (activeItemIndex.value === void 0) return void 0
      var hours = props2.ampm === 'am' ? hoursAmpm : hours24
      return hours[activeItemIndex.value].padStart(2, '0')
    }
    watch([activeItemIndex, () => props2.isInner], (_ref2, _ref3) => {
      var [index2, inner2] = _ref2
      var [oldIndex, oldInner] = _ref3
      var isSame = index2 === oldIndex && inner2 === oldInner
      if (isSame || props2.type !== 'hour' || activeItemIndex.value === void 0) return
      var newHour = inner2 ? hours24[activeItemIndex.value] : getHour()
      var second = props2.useSeconds ? ':' + props2.time.second : ''
      var newTime = newHour + ':' + props2.time.minute + second
      if (!props2.preventNextUpdate) emit('update', newTime)
      emit('change-prevent-update')
    })
    watch(
      () => props2.rad,
      (rad, oldRad) => {
        if (props2.type === 'hour' || rad === void 0 || oldRad === void 0) return
        var radToMinSec = rad / 6 >= 0 ? rad / 6 : rad / 6 + 60
        var oldRadToMinSec = oldRad / 6 >= 0 ? oldRad / 6 : oldRad / 6 + 60
        if (radToMinSec === oldRadToMinSec) return
        var newTime
        var { hourStr } = convertHour(props2.format, props2.ampm, props2.time.hour)
        if (props2.type === 'minute') {
          var newMinute = dayjs().minute(radToMinSec).format('mm')
          var second = props2.useSeconds ? ':' + props2.time.second : ''
          newTime = hourStr + ':' + newMinute + second
        }
        if (props2.type === 'second') {
          var newSecond = dayjs().second(radToMinSec).format('ss')
          var _second = props2.useSeconds ? ':' + newSecond : ''
          newTime = hourStr + ':' + props2.time.minute + _second
        }
        emit('update', newTime)
      }
    )
    watch(
      [() => props2.max, () => props2.min, () => props2.allowedTime],
      (_ref4) => {
        var [max2, min2, allowedTime] = _ref4
        disableHour.value = []
        if (max2 && !min2) {
          var { hour: maxHour } = getNumberTime(max2)
          var disableAmpmHours = hoursAmpm.filter((hour) => toNumber(hour) > maxHour)
          var disable24Hours = hours24.filter((hour) => toNumber(hour) > maxHour)
          disableHour.value = [...disableAmpmHours, ...disable24Hours]
        }
        if (!max2 && min2) {
          var { hour: minHour } = getNumberTime(min2)
          var _disableAmpmHours = hoursAmpm.filter((hour) => toNumber(hour) < minHour)
          var _disable24Hours = hours24.filter((hour) => toNumber(hour) < minHour)
          disableHour.value = [..._disableAmpmHours, ..._disable24Hours]
        }
        if (max2 && min2) {
          var { hour: _maxHour } = getNumberTime(max2)
          var { hour: _minHour } = getNumberTime(min2)
          var _disableAmpmHours2 = hoursAmpm.filter((hour) => toNumber(hour) < _minHour || toNumber(hour) > _maxHour)
          var _disable24Hours2 = hours24.filter((hour) => toNumber(hour) < _minHour || toNumber(hour) > _maxHour)
          disableHour.value = [..._disableAmpmHours2, ..._disable24Hours2]
        }
        if (allowedTime != null && allowedTime.hours) {
          var { hours } = allowedTime
          var _disableAmpmHours3 = hoursAmpm.filter((hour) => !hours(toNumber(hour)))
          var _disable24Hours3 = hours24.filter((hour) => !hours(toNumber(hour)))
          disableHour.value = [
            .../* @__PURE__ */ new Set([...disableHour.value, ..._disableAmpmHours3, ..._disable24Hours3]),
          ]
        }
        disable24HourIndex.value = disableHour.value
          .map((hour) => hours24.findIndex((hour24) => hour === hour24))
          .filter((hour) => hour >= 0)
      },
      {
        immediate: true,
      }
    )
    return {
      n: n$2,
      classes: classes$2,
      hours24,
      timeScales,
      inner,
      handStyle,
      disableHour,
      isActive,
      isDisable,
      getSize,
      getStyle,
      activeItemIndex,
    }
  },
})
var { n: n$1, classes: classes$1 } = createNamespace('time-picker')
var _withScopeId = (n2) => (pushScopeId(''), (n2 = n2()), popScopeId(), n2)
var _hoisted_1$2 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createElementVNode('span', null, ':', -1))
var _hoisted_2$2 = {
  key: 0,
}
function render$1(_ctx, _cache2) {
  var _component_clock = resolveComponent('clock')
  return (
    openBlock(),
    createElementBlock(
      'div',
      {
        class: normalizeClass(_ctx.classes(_ctx.n(), [_ctx.shadow, 'var-elevation--2'])),
        ref: 'picker',
      },
      [
        createElementVNode(
          'div',
          {
            class: normalizeClass(_ctx.n('title')),
            style: normalizeStyle({
              background: _ctx.headerColor || _ctx.color,
            }),
          },
          [
            createElementVNode(
              'div',
              {
                class: normalizeClass(_ctx.n('title-time')),
              },
              [
                createElementVNode(
                  'div',
                  {
                    class: normalizeClass(
                      _ctx.classes(_ctx.n('title-btn'), [_ctx.type === 'hour', _ctx.n('title-btn--active')])
                    ),
                    onClick: _cache2[0] || (_cache2[0] = ($event) => _ctx.checkPanel('hour')),
                  },
                  toDisplayString(_ctx.time.hour),
                  3
                ),
                _hoisted_1$2,
                createElementVNode(
                  'div',
                  {
                    class: normalizeClass(
                      _ctx.classes(_ctx.n('title-btn'), [_ctx.type === 'minute', _ctx.n('title-btn--active')])
                    ),
                    onClick: _cache2[1] || (_cache2[1] = ($event) => _ctx.checkPanel('minute')),
                  },
                  toDisplayString(_ctx.time.minute),
                  3
                ),
                _ctx.useSeconds
                  ? (openBlock(), createElementBlock('span', _hoisted_2$2, ':'))
                  : createCommentVNode('v-if', true),
                _ctx.useSeconds
                  ? (openBlock(),
                    createElementBlock(
                      'div',
                      {
                        key: 1,
                        class: normalizeClass(
                          _ctx.classes(_ctx.n('title-btn'), [_ctx.type === 'second', _ctx.n('title-btn--active')])
                        ),
                        onClick: _cache2[2] || (_cache2[2] = ($event) => _ctx.checkPanel('second')),
                      },
                      toDisplayString(_ctx.time.second),
                      3
                    ))
                  : createCommentVNode('v-if', true),
              ],
              2
            ),
            _ctx.format === 'ampm'
              ? (openBlock(),
                createElementBlock(
                  'div',
                  {
                    key: 0,
                    class: normalizeClass(_ctx.n('title-ampm')),
                  },
                  [
                    createElementVNode(
                      'div',
                      {
                        class: normalizeClass(
                          _ctx.classes(_ctx.n('title-btn'), [_ctx.ampm === 'am', _ctx.n('title-btn--active')])
                        ),
                        onClick: _cache2[3] || (_cache2[3] = ($event) => _ctx.checkAmpm('am')),
                      },
                      'AM',
                      2
                    ),
                    createElementVNode(
                      'div',
                      {
                        class: normalizeClass(
                          _ctx.classes(_ctx.n('title-btn'), [_ctx.ampm === 'pm', _ctx.n('title-btn--active')])
                        ),
                        onClick: _cache2[4] || (_cache2[4] = ($event) => _ctx.checkAmpm('pm')),
                      },
                      'PM',
                      2
                    ),
                  ],
                  2
                ))
              : createCommentVNode('v-if', true),
          ],
          6
        ),
        createElementVNode(
          'div',
          {
            class: normalizeClass(_ctx.n('body')),
          },
          [
            createElementVNode(
              'div',
              {
                class: normalizeClass(_ctx.n('clock-container')),
                onTouchstart:
                  _cache2[5] ||
                  (_cache2[5] = function () {
                    return _ctx.moveHand && _ctx.moveHand(...arguments)
                  }),
                onTouchmove:
                  _cache2[6] ||
                  (_cache2[6] = function () {
                    return _ctx.moveHand && _ctx.moveHand(...arguments)
                  }),
                onTouchend:
                  _cache2[7] ||
                  (_cache2[7] = function () {
                    return _ctx.end && _ctx.end(...arguments)
                  }),
                ref: 'container',
              },
              [
                createVNode(
                  Transition,
                  {
                    name: _ctx.n() + '-panel-fade',
                  },
                  {
                    default: withCtx(() => [
                      (openBlock(),
                      createBlock(
                        _component_clock,
                        {
                          key: _ctx.type,
                          ref: 'inner',
                          type: _ctx.type,
                          ampm: _ctx.ampm,
                          color: _ctx.color,
                          'is-inner': _ctx.isInner,
                          format: _ctx.format,
                          'allowed-time': _ctx.allowedTime,
                          rad: _ctx.getRad,
                          time: _ctx.time,
                          'prevent-next-update': _ctx.isPreventNextUpdate,
                          'use-seconds': _ctx.useSeconds,
                          max: _ctx.max,
                          min: _ctx.min,
                          onUpdate: _ctx.update,
                          onChangePreventUpdate: _ctx.changePreventUpdate,
                        },
                        null,
                        8,
                        [
                          'type',
                          'ampm',
                          'color',
                          'is-inner',
                          'format',
                          'allowed-time',
                          'rad',
                          'time',
                          'prevent-next-update',
                          'use-seconds',
                          'max',
                          'min',
                          'onUpdate',
                          'onChangePreventUpdate',
                        ]
                      )),
                    ]),
                    _: 1,
                  },
                  8,
                  ['name']
                ),
              ],
              34
            ),
          ],
          2
        ),
      ],
      2
    )
  )
}
var TimePicker = defineComponent({
  render: render$1,
  name: 'VarTimePicker',
  components: {
    Clock,
  },
  props: props$1,
  setup(props2) {
    var container = ref(null)
    var picker = ref(null)
    var inner = ref(null)
    var isInner = ref(false)
    var isPreventNextUpdate = ref(false)
    var isActualInner = ref(false)
    var isChosenUsableHour = ref(false)
    var isChosenUsableMinute = ref(false)
    var hourRad = ref(void 0)
    var minuteRad = ref(0)
    var secondRad = ref(0)
    var type = ref('hour')
    var ampm = ref('am')
    var isDisableHour = ref(false)
    var isDisableMinute = ref(false)
    var time = ref({
      hour: '00',
      minute: '00',
      second: '00',
    })
    var center = reactive({
      x: 0,
      y: 0,
    })
    var innerRange = reactive({
      x: [],
      y: [],
    })
    var getRad = computed(() => {
      if (type.value === 'hour') return hourRad.value
      if (type.value === 'minute') return minuteRad.value
      return secondRad.value
    })
    var update = (newTime) => {
      call(props2['onUpdate:modelValue'], newTime)
      call(props2.onChange, newTime)
    }
    var rad2deg = (rad) => {
      return rad * 57.29577951308232
    }
    var checkPanel = (panelType) => {
      isChosenUsableHour.value = false
      isDisableMinute.value = false
      type.value = panelType
    }
    var findAvailableHour = (ampm2) => {
      var { disableHour } = inner.value
      var index2 = hoursAmpm.findIndex((hour) => toNumber(hour) === toNumber(time.value.hour))
      var hours = ampm2 === 'am' ? hoursAmpm : hours24
      var realignmentHours = [...hours.slice(index2), ...hours.slice(0, index2)]
      return realignmentHours.find((hour, index3) => {
        isPreventNextUpdate.value = index3 !== 0
        return !disableHour.includes(hour)
      })
    }
    var checkAmpm = (ampmType) => {
      if (props2.readonly) return
      ampm.value = ampmType
      var newHour = findAvailableHour(ampmType)
      if (!newHour) return
      var second = props2.useSeconds ? ':' + time.value.second : ''
      var newTime = newHour.padStart(2, '0') + ':' + time.value.minute + second
      update(newTime)
    }
    var getInner = (clientX, clientY) => {
      var xIsInRange = clientX >= innerRange.x[0] && clientX <= innerRange.x[1]
      var yIsInRange = clientY >= innerRange.y[0] && clientY <= innerRange.y[1]
      return xIsInRange && yIsInRange
    }
    var getTime = (value) => {
      var hourFormat = props2.format === '24hr' ? 'HH' : 'hh'
      var { hour, minute, second } = getNumberTime(value)
      return {
        hour: dayjs().hour(hour).format(hourFormat),
        minute: dayjs().minute(minute).format('mm'),
        second: dayjs().second(second).format('ss'),
      }
    }
    var getHourIndex = (rad) => {
      var value = rad / 30
      return value >= 0 ? value : value + 12
    }
    var getRangeSize = () => {
      var { width: innerWidth, height: innerHeight } = inner.value.getSize()
      var rangeXMin = center.x - innerWidth / 2 - 8
      var rangeXMax = center.x + innerWidth / 2 + 8
      var rangeYMin = center.y - innerHeight / 2 - 8
      var rangeYMax = center.y + innerHeight / 2 + 8
      return {
        rangeXMin,
        rangeXMax,
        rangeYMin,
        rangeYMax,
      }
    }
    var setHourRad = (clientX, clientY, roundDeg) => {
      var { disableHour } = inner.value
      isActualInner.value = getInner(clientX, clientY)
      var rad = Math.round(roundDeg / 30) * 30 + 90
      var index2 = getHourIndex(rad)
      var anotherHour = isInner.value ? hoursAmpm[index2] : hours24[index2]
      if (!disableHour.includes(anotherHour)) {
        isInner.value = props2.format === '24hr' ? getInner(clientX, clientY) : false
      }
      if (isInner.value !== isActualInner.value) return
      var newHour = isInner.value || ampm.value === 'pm' ? hours24[index2] : hoursAmpm[index2]
      isDisableHour.value = disableHour.includes(newHour)
      if (isDisableHour.value) return
      hourRad.value = rad
      isChosenUsableHour.value = true
    }
    var setMinuteRad = (roundDeg) => {
      var { disableHour } = inner.value
      var rad = Math.round(roundDeg / 6) * 6 + 90
      var radToMin = rad / 6 >= 0 ? rad / 6 : rad / 6 + 60
      var values = {
        time: radToMin,
        format: props2.format,
        ampm: ampm.value,
        hour: time.value.hour,
        max: props2.max,
        min: props2.min,
        disableHour,
        allowedTime: props2.allowedTime,
      }
      isDisableMinute.value = getIsDisableMinute(values)
      if (isDisableMinute.value) return
      minuteRad.value = rad
      isChosenUsableMinute.value = true
    }
    var setSecondRad = (roundDeg) => {
      var { disableHour } = inner.value
      var rad = Math.round(roundDeg / 6) * 6 + 90
      var radToSec = rad / 6 >= 0 ? rad / 6 : rad / 6 + 60
      var values = {
        time: radToSec,
        format: props2.format,
        ampm: ampm.value,
        hour: time.value.hour,
        minute: toNumber(time.value.minute),
        max: props2.max,
        min: props2.min,
        disableHour,
        allowedTime: props2.allowedTime,
      }
      if (!getIsDisableSecond(values)) secondRad.value = rad
    }
    var setCenterAndRange = () => {
      var { left, top, width, height } = container.value.getBoundingClientRect()
      center.x = left + width / 2
      center.y = top + height / 2
      if (type.value === 'hour' && props2.format === '24hr') {
        var { rangeXMin, rangeXMax, rangeYMin, rangeYMax } = getRangeSize()
        innerRange.x = [rangeXMin, rangeXMax]
        innerRange.y = [rangeYMin, rangeYMax]
      }
    }
    var moveHand = (event) => {
      event.preventDefault()
      if (props2.readonly) return
      setCenterAndRange()
      var { clientX, clientY } = event.touches[0]
      var x = clientX - center.x
      var y2 = clientY - center.y
      var roundDeg = Math.round(rad2deg(Math.atan2(y2, x)))
      if (type.value === 'hour') setHourRad(clientX, clientY, roundDeg)
      else if (type.value === 'minute') setMinuteRad(roundDeg)
      else setSecondRad(roundDeg)
    }
    var end = () => {
      if (props2.readonly) return
      if (type.value === 'hour' && isChosenUsableHour.value) {
        type.value = 'minute'
        return
      }
      if (type.value === 'minute' && props2.useSeconds && isChosenUsableMinute.value) {
        type.value = 'second'
      }
    }
    var changePreventUpdate = () => {
      isPreventNextUpdate.value = false
    }
    watch(
      () => props2.modelValue,
      (value) => {
        if (value) {
          var { hour, minute, second } = getNumberTime(value)
          var formatHour12 = dayjs().hour(hour).format('hh')
          var formatHour24 = dayjs().hour(hour).format('HH')
          var formatMinute = dayjs().minute(minute).format('mm')
          var formatSecond = dayjs().second(second).format('ss')
          hourRad.value = (formatHour12 === '12' ? 0 : toNumber(formatHour12)) * 30
          minuteRad.value = toNumber(formatMinute) * 6
          secondRad.value = toNumber(formatSecond) * 6
          time.value = getTime(value)
          if (props2.format !== '24hr') {
            ampm.value = ('' + hour).padStart(2, '0') === formatHour24 && hours24.includes(formatHour24) ? 'pm' : 'am'
          }
          isInner.value = props2.format === '24hr' && hours24.includes(formatHour24)
        }
      },
      {
        immediate: true,
      }
    )
    return {
      n: n$1,
      classes: classes$1,
      getRad,
      time,
      container,
      inner,
      picker,
      isInner,
      type,
      ampm,
      isPreventNextUpdate,
      moveHand,
      checkPanel,
      checkAmpm,
      end,
      update,
      changePreventUpdate,
    }
  },
})
TimePicker.install = function (app) {
  app.component(TimePicker.name, TimePicker)
}
var props = {
  modelValue: {
    type: Array,
    default: () => [],
  },
  accept: {
    type: String,
    default: 'image/*',
  },
  capture: {
    type: [String, Boolean],
    default: void 0,
  },
  multiple: {
    type: Boolean,
    default: false,
  },
  readonly: {
    type: Boolean,
    default: false,
  },
  disabled: {
    type: Boolean,
    default: false,
  },
  removable: {
    type: Boolean,
    default: true,
  },
  maxlength: {
    type: [Number, String],
  },
  maxsize: {
    type: [Number, String],
  },
  previewed: {
    type: Boolean,
    default: true,
  },
  ripple: {
    type: Boolean,
    default: true,
  },
  validateTrigger: {
    type: Array,
    default: () => ['onChange', 'onRemove'],
  },
  rules: {
    type: Array,
  },
  hideList: {
    type: Boolean,
    default: false,
  },
  onBeforeRead: {
    type: Function,
  },
  onAfterRead: {
    type: Function,
  },
  onBeforeRemove: {
    type: Function,
  },
  onRemove: {
    type: Function,
  },
  onOversize: {
    type: Function,
  },
  'onUpdate:modelValue': {
    type: Function,
  },
}
function asyncGeneratorStep(gen, resolve2, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg)
    var value = info.value
  } catch (error) {
    reject(error)
    return
  }
  if (info.done) {
    resolve2(value)
  } else {
    Promise.resolve(value).then(_next, _throw)
  }
}
function _asyncToGenerator(fn) {
  return function () {
    var self2 = this,
      args = arguments
    return new Promise(function (resolve2, reject) {
      var gen = fn.apply(self2, args)
      function _next(value) {
        asyncGeneratorStep(gen, resolve2, reject, _next, _throw, 'next', value)
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve2, reject, _next, _throw, 'throw', err)
      }
      _next(void 0)
    })
  }
}
var { n, classes } = createNamespace('uploader')
var fid = 0
var _hoisted_1$1 = ['onClick']
var _hoisted_2$1 = ['onClick']
var _hoisted_3 = ['src', 'alt']
var _hoisted_4 = ['multiple', 'accept', 'capture', 'disabled']
var _hoisted_5 = ['src']
function render(_ctx, _cache2) {
  var _component_var_icon = resolveComponent('var-icon')
  var _component_var_form_details = resolveComponent('var-form-details')
  var _component_var_popup = resolveComponent('var-popup')
  var _directive_ripple = resolveDirective('ripple')
  return (
    openBlock(),
    createElementBlock(
      'div',
      {
        class: normalizeClass(_ctx.classes(_ctx.n(), 'var--box')),
      },
      [
        createElementVNode(
          'div',
          {
            class: normalizeClass(_ctx.n('file-list')),
          },
          [
            (openBlock(true),
            createElementBlock(
              Fragment,
              null,
              renderList(_ctx.files, (f) => {
                return withDirectives(
                  (openBlock(),
                  createElementBlock(
                    'div',
                    {
                      class: normalizeClass(
                        _ctx.classes(_ctx.n('file'), 'var-elevation--2', [f.state === 'loading', _ctx.n('--loading')])
                      ),
                      key: f.id,
                      onClick: ($event) => _ctx.preview(f),
                    },
                    [
                      createElementVNode(
                        'div',
                        {
                          class: normalizeClass(_ctx.n('file-name')),
                        },
                        toDisplayString(f.name || f.url),
                        3
                      ),
                      _ctx.removable
                        ? (openBlock(),
                          createElementBlock(
                            'div',
                            {
                              key: 0,
                              class: normalizeClass(_ctx.n('file-close')),
                              onClick: withModifiers(($event) => _ctx.handleRemove(f), ['stop']),
                            },
                            [
                              createVNode(
                                _component_var_icon,
                                {
                                  class: normalizeClass(_ctx.n('file-close-icon')),
                                  'var-uploader-cover': '',
                                  name: 'delete',
                                },
                                null,
                                8,
                                ['class']
                              ),
                            ],
                            10,
                            _hoisted_2$1
                          ))
                        : createCommentVNode('v-if', true),
                      f.cover
                        ? (openBlock(),
                          createElementBlock(
                            'img',
                            {
                              key: 1,
                              class: normalizeClass(_ctx.n('file-cover')),
                              style: normalizeStyle({
                                objectFit: f.fit,
                              }),
                              src: f.cover,
                              alt: f.name,
                            },
                            null,
                            14,
                            _hoisted_3
                          ))
                        : createCommentVNode('v-if', true),
                      createElementVNode(
                        'div',
                        {
                          class: normalizeClass(
                            _ctx.classes(
                              _ctx.n('file-indicator'),
                              [f.state === 'success', _ctx.n('--success')],
                              [f.state === 'error', _ctx.n('--error')]
                            )
                          ),
                        },
                        null,
                        2
                      ),
                    ],
                    10,
                    _hoisted_1$1
                  )),
                  [
                    [
                      _directive_ripple,
                      {
                        disabled:
                          _ctx.disabled || _ctx.formDisabled || _ctx.readonly || _ctx.formReadonly || !_ctx.ripple,
                      },
                    ],
                  ]
                )
              }),
              128
            )),
            !_ctx.maxlength || _ctx.modelValue.length < _ctx.maxlength
              ? withDirectives(
                  (openBlock(),
                  createElementBlock(
                    'div',
                    {
                      key: 0,
                      class: normalizeClass(
                        _ctx.classes(
                          [!_ctx.$slots.default, _ctx.n('action') + ' var-elevation--2'],
                          [_ctx.disabled || _ctx.formDisabled, _ctx.n('--disabled')]
                        )
                      ),
                      onClick:
                        _cache2[1] ||
                        (_cache2[1] = function () {
                          return _ctx.triggerAction && _ctx.triggerAction(...arguments)
                        }),
                    },
                    [
                      createElementVNode(
                        'input',
                        {
                          ref: 'input',
                          class: normalizeClass(_ctx.n('action-input')),
                          type: 'file',
                          multiple: _ctx.multiple,
                          accept: _ctx.accept,
                          capture: _ctx.capture,
                          disabled: _ctx.disabled || _ctx.formDisabled || _ctx.readonly || _ctx.formReadonly,
                          onChange:
                            _cache2[0] ||
                            (_cache2[0] = function () {
                              return _ctx.handleChange && _ctx.handleChange(...arguments)
                            }),
                        },
                        null,
                        42,
                        _hoisted_4
                      ),
                      renderSlot(_ctx.$slots, 'default', {}, () => [
                        createVNode(
                          _component_var_icon,
                          {
                            class: normalizeClass(_ctx.n('action-icon')),
                            'var-uploader-cover': '',
                            name: 'plus',
                          },
                          null,
                          8,
                          ['class']
                        ),
                      ]),
                    ],
                    2
                  )),
                  [
                    [
                      _directive_ripple,
                      {
                        disabled:
                          _ctx.disabled ||
                          _ctx.formDisabled ||
                          _ctx.readonly ||
                          _ctx.formReadonly ||
                          !_ctx.ripple ||
                          _ctx.$slots.default,
                      },
                    ],
                  ]
                )
              : createCommentVNode('v-if', true),
          ],
          2
        ),
        createVNode(
          _component_var_form_details,
          {
            'error-message': _ctx.errorMessage,
            'maxlength-text': _ctx.maxlengthText,
          },
          null,
          8,
          ['error-message', 'maxlength-text']
        ),
        createVNode(
          _component_var_popup,
          {
            class: normalizeClass(_ctx.n('preview')),
            'var-uploader-cover': '',
            position: 'center',
            show: _ctx.showPreview,
            'onUpdate:show': _cache2[2] || (_cache2[2] = ($event) => (_ctx.showPreview = $event)),
            onClosed: _cache2[3] || (_cache2[3] = ($event) => (_ctx.currentPreview = null)),
          },
          {
            default: withCtx(() => {
              var _ctx$currentPreview, _ctx$currentPreview2
              return [
                _ctx.currentPreview &&
                _ctx.isHTMLSupportVideo(
                  (_ctx$currentPreview = _ctx.currentPreview) == null ? void 0 : _ctx$currentPreview.url
                )
                  ? (openBlock(),
                    createElementBlock(
                      'video',
                      {
                        key: 0,
                        class: normalizeClass(_ctx.n('preview-video')),
                        playsinline: 'true',
                        'webkit-playsinline': 'true',
                        'x5-playsinline': 'true',
                        'x5-video-player-type': 'h5',
                        'x5-video-player-fullscreen': 'false',
                        controls: '',
                        src: (_ctx$currentPreview2 = _ctx.currentPreview) == null ? void 0 : _ctx$currentPreview2.url,
                      },
                      null,
                      10,
                      _hoisted_5
                    ))
                  : createCommentVNode('v-if', true),
              ]
            }),
            _: 1,
          },
          8,
          ['class', 'show']
        ),
      ],
      2
    )
  )
}
var Uploader = defineComponent({
  render,
  name: 'VarUploader',
  directives: {
    Ripple,
  },
  components: {
    VarIcon: Icon,
    VarPopup: Popup,
    VarFormDetails: FormDetails,
  },
  props,
  setup(props2) {
    var input = ref(null)
    var showPreview = ref(false)
    var currentPreview = ref(null)
    var maxlengthText = computed(() => {
      var {
        maxlength,
        modelValue: { length },
      } = props2
      return isNumber(maxlength) ? length + ' / ' + maxlength : ''
    })
    var { form, bindForm } = useForm()
    var { errorMessage, validateWithTrigger: vt, validate: v, resetValidation } = useValidation()
    var files = computed(() => {
      var { modelValue, hideList } = props2
      if (hideList) {
        return []
      }
      return modelValue
    })
    var triggerAction = () => {
      input.value.click()
    }
    var preview = (varFile) => {
      var { disabled, readonly, previewed } = props2
      if (
        (form != null && form.disabled.value) ||
        (form != null && form.readonly.value) ||
        disabled ||
        readonly ||
        !previewed
      ) {
        return
      }
      var { url } = varFile
      if (isString$1(url) && isHTMLSupportImage(url)) {
        ImagePreview(url)
        return
      }
      if (isString$1(url) && isHTMLSupportVideo(url)) {
        currentPreview.value = varFile
        showPreview.value = true
      }
    }
    var createVarFile = (file2) => {
      return {
        id: fid++,
        url: '',
        cover: '',
        name: file2.name,
        file: file2,
      }
    }
    var getFiles = (event) => {
      var el = event.target
      var { files: fileList } = el
      return Array.from(fileList)
    }
    var resolver = (varFile) => {
      return new Promise((resolve2) => {
        var fileReader = new FileReader()
        fileReader.onload = () => {
          var base64 = fileReader.result
          varFile.file.type.startsWith('image') && (varFile.cover = base64)
          varFile.url = base64
          resolve2(varFile)
        }
        fileReader.readAsDataURL(varFile.file)
      })
    }
    var getResolvers = (varFiles) => varFiles.map(resolver)
    var getBeforeReaders = (varFiles) => {
      var { onBeforeRead } = props2
      return varFiles.map((varFile) => {
        return new Promise((resolve2) => {
          var valid = onBeforeRead ? onBeforeRead(reactive(varFile)) : true
          Promise.resolve(valid).then((valid2) =>
            resolve2({
              valid: valid2,
              varFile,
            })
          )
        })
      })
    }
    var handleChange = /* @__PURE__ */ (function () {
      var _ref = _asyncToGenerator(function* (event) {
        var { maxsize, maxlength, modelValue, onOversize, onAfterRead, readonly, disabled } = props2
        if ((form != null && form.disabled.value) || (form != null && form.readonly.value) || disabled || readonly) {
          return
        }
        var getValidSizeVarFile = (varFiles2) => {
          return varFiles2.filter((varFile) => {
            if (varFile.file.size > toNumber(maxsize)) {
              call(onOversize, reactive(varFile))
              return false
            }
            return true
          })
        }
        var getValidLengthVarFiles = (varFiles2) => {
          var limit = Math.min(varFiles2.length, toNumber(maxlength) - modelValue.length)
          return varFiles2.slice(0, limit)
        }
        var files2 = getFiles(event)
        var varFiles = files2.map(createVarFile)
        varFiles = maxsize != null ? getValidSizeVarFile(varFiles) : varFiles
        varFiles = maxlength != null ? getValidLengthVarFiles(varFiles) : varFiles
        var resolvedVarFiles = yield Promise.all(getResolvers(varFiles))
        var validationVarFiles = yield Promise.all(getBeforeReaders(resolvedVarFiles))
        var validVarFiles = validationVarFiles
          .filter((_ref2) => {
            var { valid } = _ref2
            return valid
          })
          .map((_ref3) => {
            var { varFile } = _ref3
            return varFile
          })
        call(props2['onUpdate:modelValue'], [...modelValue, ...validVarFiles])
        event.target.value = ''
        validVarFiles.forEach((varFile) => call(onAfterRead, reactive(varFile)))
      })
      return function handleChange2(_x) {
        return _ref.apply(this, arguments)
      }
    })()
    var handleRemove = /* @__PURE__ */ (function () {
      var _ref4 = _asyncToGenerator(function* (removedVarFile) {
        var { disabled, readonly, modelValue, onBeforeRemove, onRemove } = props2
        if ((form != null && form.disabled.value) || (form != null && form.readonly.value) || disabled || readonly) {
          return
        }
        if (onBeforeRemove && !(yield onBeforeRemove(removedVarFile))) {
          return
        }
        var expectedFiles = modelValue.filter((varFile) => varFile !== removedVarFile)
        call(onRemove, removedVarFile)
        validateWithTrigger('onRemove')
        call(props2['onUpdate:modelValue'], expectedFiles)
      })
      return function handleRemove2(_x2) {
        return _ref4.apply(this, arguments)
      }
    })()
    var getSuccess = () => props2.modelValue.filter((varFile) => varFile.state === 'success')
    var getError = () => props2.modelValue.filter((varFile) => varFile.state === 'error')
    var getLoading = () => props2.modelValue.filter((varFile) => varFile.state === 'loading')
    var varFileUtils = {
      getSuccess,
      getError,
      getLoading,
    }
    var validateWithTrigger = (trigger) => {
      nextTick(() => {
        var { validateTrigger, rules, modelValue } = props2
        vt(validateTrigger, trigger, rules, modelValue, varFileUtils)
      })
    }
    var callReset = false
    var validate2 = () => v(props2.rules, props2.modelValue, varFileUtils)
    var reset = () => {
      callReset = true
      call(props2['onUpdate:modelValue'], [])
      resetValidation()
    }
    var uploaderProvider = {
      validate: validate2,
      resetValidation,
      reset,
    }
    call(bindForm, uploaderProvider)
    watch(
      () => props2.modelValue,
      () => {
        !callReset && validateWithTrigger('onChange')
        callReset = false
      },
      {
        deep: true,
      }
    )
    return {
      n,
      classes,
      input,
      files,
      showPreview,
      currentPreview,
      errorMessage,
      maxlengthText,
      isHTMLSupportVideo,
      isHTMLSupportImage,
      formDisabled: form == null ? void 0 : form.disabled,
      formReadonly: form == null ? void 0 : form.readonly,
      preview,
      triggerAction,
      handleChange,
      handleRemove,
      getSuccess,
      getError,
      getLoading,
      validate: validate2,
      resetValidation,
      reset,
    }
  },
})
Uploader.install = function (app) {
  app.component(Uploader.name, Uploader)
}
var FileSaver_min = { exports: {} }
;(function (module, exports) {
  ;(function (a, b) {
    b()
  })(commonjsGlobal, function () {
    function b(a2, b2) {
      return (
        typeof b2 == 'undefined'
          ? (b2 = { autoBom: false })
          : typeof b2 != 'object' &&
            (console.warn('Deprecated: Expected third argument to be a object'), (b2 = { autoBom: !b2 })),
        b2.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(a2.type)
          ? new Blob(['\uFEFF', a2], { type: a2.type })
          : a2
      )
    }
    function c(a2, b2, c2) {
      var d3 = new XMLHttpRequest()
      d3.open('GET', a2),
        (d3.responseType = 'blob'),
        (d3.onload = function () {
          g(d3.response, b2, c2)
        }),
        (d3.onerror = function () {
          console.error('could not download file')
        }),
        d3.send()
    }
    function d2(a2) {
      var b2 = new XMLHttpRequest()
      b2.open('HEAD', a2, false)
      try {
        b2.send()
      } catch (a3) {}
      return 200 <= b2.status && 299 >= b2.status
    }
    function e(a2) {
      try {
        a2.dispatchEvent(new MouseEvent('click'))
      } catch (c2) {
        var b2 = document.createEvent('MouseEvents')
        b2.initMouseEvent('click', true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null),
          a2.dispatchEvent(b2)
      }
    }
    var f =
        typeof window == 'object' && window.window === window
          ? window
          : typeof self == 'object' && self.self === self
          ? self
          : typeof commonjsGlobal == 'object' && commonjsGlobal.global === commonjsGlobal
          ? commonjsGlobal
          : void 0,
      a =
        f.navigator &&
        /Macintosh/.test(navigator.userAgent) &&
        /AppleWebKit/.test(navigator.userAgent) &&
        !/Safari/.test(navigator.userAgent),
      g =
        f.saveAs ||
        (typeof window != 'object' || window !== f
          ? function () {}
          : 'download' in HTMLAnchorElement.prototype && !a
          ? function (b2, g2, h2) {
              var i = f.URL || f.webkitURL,
                j = document.createElement('a')
              ;(g2 = g2 || b2.name || 'download'),
                (j.download = g2),
                (j.rel = 'noopener'),
                typeof b2 == 'string'
                  ? ((j.href = b2),
                    j.origin === location.origin ? e(j) : d2(j.href) ? c(b2, g2, h2) : e(j, (j.target = '_blank')))
                  : ((j.href = i.createObjectURL(b2)),
                    setTimeout(function () {
                      i.revokeObjectURL(j.href)
                    }, 4e4),
                    setTimeout(function () {
                      e(j)
                    }, 0))
            }
          : 'msSaveOrOpenBlob' in navigator
          ? function (f2, g2, h2) {
              if (((g2 = g2 || f2.name || 'download'), typeof f2 != 'string')) navigator.msSaveOrOpenBlob(b(f2, h2), g2)
              else if (d2(f2)) c(f2, g2, h2)
              else {
                var i = document.createElement('a')
                ;(i.href = f2),
                  (i.target = '_blank'),
                  setTimeout(function () {
                    e(i)
                  })
              }
            }
          : function (b2, d3, e2, g2) {
              if (
                ((g2 = g2 || open('', '_blank')),
                g2 && (g2.document.title = g2.document.body.innerText = 'downloading...'),
                typeof b2 == 'string')
              )
                return c(b2, d3, e2)
              var h2 = b2.type === 'application/octet-stream',
                i = /constructor/i.test(f.HTMLElement) || f.safari,
                j = /CriOS\/[\d]+/.test(navigator.userAgent)
              if ((j || (h2 && i) || a) && typeof FileReader != 'undefined') {
                var k = new FileReader()
                ;(k.onloadend = function () {
                  var a2 = k.result
                  ;(a2 = j ? a2 : a2.replace(/^data:[^;]*;/, 'data:attachment/file;')),
                    g2 ? (g2.location.href = a2) : (location = a2),
                    (g2 = null)
                }),
                  k.readAsDataURL(b2)
              } else {
                var l = f.URL || f.webkitURL,
                  m2 = l.createObjectURL(b2)
                g2 ? (g2.location = m2) : (location.href = m2),
                  (g2 = null),
                  setTimeout(function () {
                    l.revokeObjectURL(m2)
                  }, 4e4)
              }
            })
    ;(f.saveAs = g.saveAs = g), (module.exports = g)
  })
})(FileSaver_min)
const isPlainObject = (val) => Object.prototype.toString.call(val) === '[object Object]'
const isArray = (val) => Array.isArray(val)
const isString = (val) => typeof val === 'string'
function kebabCase(str) {
  const ret = str.replace(/([A-Z])/g, ' $1').trim()
  return ret.split(' ').join('-').toLowerCase()
}
const _hoisted_1 = { class: 'varlet-low-code-codegen' }
const _hoisted_2 = /* @__PURE__ */ createTextVNode('Codegen')
const _sfc_main = defineComponent({
  setup(__props) {
    const getRendererSchema = () => {
      return window[0].VarletLowcodeRenderer.default.schema.value
    }
    const getRendererAssets = () => {
      return window[0].VarletLowcodeRenderer.default.assets.value
    }
    const getRendererAssetsManager = () => {
      return window[0].VarletLowcodeCore.assetsManager
    }
    const stringifyObject = (object2) => {
      return JSON.stringify(object2).replace(/"(.+)":/g, '$1:')
    }
    const convertExpressionValue = (value) => {
      value = value
        .replace(/\$index\[['"](.+)['"]\]/g, '$index_$1')
        .replace(/\$index\.(.+)(?![.\[])/g, '$index_$1')
        .replace(/\$item\[['"](.+)['"]\]/g, '$item_$1')
        .replace(/\$item\.(.+)(?![.\[])/g, '$item_$1')
        .replace(/\$slotProps\[['"](.+)['"]\]/g, '$slotProps_$1')
        .replace(/\$slotProps\.(.+)(?![.\[])/g, '$slotProps_$1')
      const ast = parse_1(value, {
        sourceType: 'module',
      })
      traverse(ast, {
        MemberExpression(path2) {
          if (
            path2.node.object.type === 'Identifier' &&
            path2.node.property.type === 'Identifier' &&
            path2.node.property.name === 'value'
          ) {
            path2.replaceWith(lib$b.identifier(path2.node.object.name))
          }
        },
      })
      const { code: code2 } = _default$5(ast)
      return code2.endsWith(';') ? code2.slice(0, -1) : code2
    }
    const convertEventName = (key) => {
      if (!key.startsWith('on')) {
        return `:${kebabCase(key)}`
      }
      const eventName = kebabCase(key.slice(2))
      return `@${eventName.at(0).toLowerCase()}${eventName.slice(1)}`
    }
    const genPackages = () => {
      const packages = {}
      schemaManager.visitSchemaNode(getRendererSchema(), (schemaNode) => {
        if (schemaManager.isSchemaPageNode(schemaNode) || schemaManager.isSchemaTextNode(schemaNode)) {
          return
        }
        const { packageName, packageVersion } = getRendererAssetsManager().findProfile(
          getRendererAssets(),
          schemaNode.name,
          schemaNode.library
        )
        packages[schemaNode.library] = [packageName, packageVersion]
      })
      return packages
    }
    const genProps = (schemaNode) => {
      var _a
      return Object.entries((_a = schemaNode.props) != null ? _a : {}).reduce((propsString, [key, value]) => {
        if (schemaManager.isExpressionBinding(value)) {
          propsString += ` ${convertEventName(key)}="${convertExpressionValue(value.value)}"`
          return propsString
        }
        if (schemaManager.isObjectBinding(value)) {
          propsString += ` :${key}="${stringifyObject(value.value)}"`
          return propsString
        }
        if (isArray(value)) {
          propsString += ` :${key}="${stringifyObject(value)}"`
          return propsString
        }
        if (isString(value)) {
          propsString += ` ${key}="${value}"`
          return propsString
        }
        propsString += ` :${key}="${value}"`
        return propsString
      }, '')
    }
    const genCondition = (schemaNode) => {
      if (!Object.hasOwn(schemaNode, 'if')) {
        return ''
      }
      if (schemaManager.isExpressionBinding(schemaNode.if)) {
        return ` v-if="${convertExpressionValue(schemaNode.if.value)}"`
      }
      if (schemaManager.isObjectBinding(schemaNode.if)) {
        return ` v-if="${stringifyObject(schemaNode.if.value)}"`
      }
      if (isArray(schemaNode.if)) {
        return ` v-if="${stringifyObject(schemaNode.if)}"`
      }
      if (isString(schemaNode.if)) {
        return ` v-if="'${schemaNode.if}'"`
      }
      return ` v-if="${schemaNode.if}"`
    }
    const genLoop = (schemaNode) => {
      if (!Object.hasOwn(schemaNode, 'for')) {
        return ''
      }
      if (schemaManager.isExpressionBinding(schemaNode.for)) {
        return ` v-for="$item_${schemaNode.id} in ${convertExpressionValue(schemaNode.for.value)}"`
      }
      if (schemaManager.isObjectBinding(schemaNode.for)) {
        return ` v-for="$item_${schemaNode.id} in ${stringifyObject(schemaNode.for.value)}"`
      }
      if (isArray(schemaNode.for)) {
        return ` v-for="$item_${schemaNode.id} in ${stringifyObject(schemaNode.for)}"`
      }
      if (isString(schemaNode.for)) {
        return ` v-for="$item_${schemaNode.id} in '${schemaNode.for}'"`
      }
      return ` v-for="$item_${schemaNode.id} in ${schemaNode.for}"`
    }
    const genSlots = (schemaNodeSlots, schemaNode, material, depth) => {
      return Object.entries(schemaNodeSlots)
        .map(([slotName, slot]) => {
          var _a, _b, _c
          const hasSlotProps =
            (_c =
              (_b = (_a = material.slots) == null ? void 0 : _a.find((slot2) => slot2.name === slotName)) == null
                ? void 0
                : _b.hasSlotProps) != null
              ? _c
              : false
          const slotPropsVariable = hasSlotProps ? `="$slotProps_${schemaNode.id}"` : ''
          if (slotName === 'default' && !hasSlotProps) {
            return slot.children.map((schemaNode2) => genSchemaNode(schemaNode2, depth + 1)).join('\n')
          }
          const indent = ' '.repeat((depth + 1) * 2)
          return `${indent}<template #${slotName}${slotPropsVariable}>
${slot.children.map((schemaNode2) => genSchemaNode(schemaNode2, depth + 2)).join('\n')}
${indent}</template>`
        })
        .join('\n')
    }
    const genSchemaNode = (schemaNode, depth = 1) => {
      var _a, _b
      const indent = ' '.repeat(depth * 2)
      if (
        schemaManager.isSchemaPageNode(schemaNode) &&
        isArray((_a = schemaNode.slots) == null ? void 0 : _a.default.children)
      ) {
        return schemaNode.slots.default.children.map((schemaNode2) => genSchemaNode(schemaNode2, depth + 1)).join('\n')
      }
      if (
        schemaManager.isSchemaPageNode(schemaNode) &&
        !isArray((_b = schemaNode.slots) == null ? void 0 : _b.default.children)
      ) {
        return ''
      }
      if (schemaManager.isSchemaTextNode(schemaNode)) {
        if (schemaManager.isExpressionBinding(schemaNode.textContent)) {
          return `${indent}{{ ${convertExpressionValue(schemaNode.textContent.value)} }}`
        }
        return `${indent}${schemaNode.textContent}`
      }
      const material = getRendererAssetsManager().findMaterial(getRendererAssets(), schemaNode.name, schemaNode.library)
      const { name } = material.codegen
      if (!isPlainObject(schemaNode.slots)) {
        return `${indent}<${name}${genProps(schemaNode)}${genCondition(schemaNode)}${genLoop(schemaNode)} />`
      }
      return `${indent}<${name}${genProps(schemaNode)}${genCondition(schemaNode)}${genLoop(schemaNode)}>
${genSlots(schemaNode.slots, schemaNode, material, depth)}
${indent}</${name}>`
    }
    const genApp = (packages) => {
      const schema = getRendererSchema()
      return `<template>
  <div class="varlet-low-code-page">
${genSchemaNode(schema)}
  </div>
</template>

<script>
import {
  defineComponent,
  ref,
  reactive,
  computed,
  watch,
  onBeforeMount,
  onMounted,
  onBeforeUpdate,
  onUpdated,
  onBeforeUnmount,
  onUnmounted,
} from 'vue'
${genPackageImports(packages)}

${schema.code}

export default defineComponent({
  setup
})
<${'/'}script>
`
    }
    const genPackageImports = (packages) => {
      return Object.entries(packages).map(([library, [packageName]]) => {
        return `import ${library} from '${packageName}'
`
      })
    }
    const genMain = (packages) => {
      const packageUses = Object.entries(packages).map(([library]) => {
        return `.use(${library})`
      })
      return `import App from './App.vue'
${genPackageImports(packages)}
import { createApp } from 'vue'

const app = createApp(App)

app${packageUses.join('')}
app.mount('#app')
`
    }
    const genPkg = (packages) => {
      const packagesString = Object.entries(packages).map(([_2, [packageName, packageVersion]]) => {
        return `    "${packageName}": "${packageVersion}"`
      })
      return pkg.replace(
        '"vite": "latest"',
        `"vite": "latest",
${packagesString.join(',\n')}`
      )
    }
    const genIndex = () => {
      const resources = getRendererAssetsManager().getResources(getRendererAssets())
      const scripts = resources.map((resource) => `    <script src="${resource}"><${'/'}script>`)
      return index.replace(
        `    <script type="module" src="/src/main.js"><${'/'}script>`,
        `${scripts.join('\n')}
    <script type="module" src="/src/main.js"><${'/'}script>`
      )
    }
    const genConfig = (packages) => {
      const externals = Object.entries(packages).map(([library, [packageName]]) => {
        return `      '${packageName}': '${library}'`
      })
      return config$1.replace(
        '    viteExternalsPlugin()',
        `    viteExternalsPlugin({
      vue: 'Vue',
${externals.join(',\n')}
    })`
      )
    }
    const save = async () => {
      const packages = genPackages()
      const zip = new JSZip()
      zip.file('index.html', genIndex())
      zip.file('package.json', genPkg(packages))
      zip.file('vite.config.js', genConfig(packages))
      zip.file('README.md', readme)
      const src = zip.folder('src')
      src.file('App.vue', genApp(packages))
      src.file('main.js', genMain(packages))
      const blob = await zip.generateAsync({ type: 'blob' })
      FileSaver_min.exports.saveAs(blob, 'vite-varlet-low-code-starter.zip')
    }
    return (_ctx, _cache2) => {
      return (
        openBlock(),
        createElementBlock('div', _hoisted_1, [
          createVNode(
            unref(Button),
            {
              type: 'primary',
              onClick: save,
            },
            {
              default: withCtx(() => [_hoisted_2]),
              _: 1,
            }
          ),
        ])
      )
    }
  },
})
var buffer = {}
var base64Js = {}
base64Js.byteLength = byteLength
base64Js.toByteArray = toByteArray
base64Js.fromByteArray = fromByteArray
var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array
var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63
function getLens(b64) {
  var len = b64.length
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len
  var placeHoldersLen = validLen === len ? 0 : 4 - (validLen % 4)
  return [validLen, placeHoldersLen]
}
function byteLength(b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3) / 4 - placeHoldersLen
}
function _byteLength(b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3) / 4 - placeHoldersLen
}
function toByteArray(b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))
  var curByte = 0
  var len = placeHoldersLen > 0 ? validLen - 4 : validLen
  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 255
    arr[curByte++] = (tmp >> 8) & 255
    arr[curByte++] = tmp & 255
  }
  if (placeHoldersLen === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 255
  }
  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 255
    arr[curByte++] = tmp & 255
  }
  return arr
}
function tripletToBase64(num) {
  return lookup[(num >> 18) & 63] + lookup[(num >> 12) & 63] + lookup[(num >> 6) & 63] + lookup[num & 63]
}
function encodeChunk(uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = ((uint8[i] << 16) & 16711680) + ((uint8[i + 1] << 8) & 65280) + (uint8[i + 2] & 255)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}
function fromByteArray(uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3
  var parts = []
  var maxChunkLength = 16383
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength))
  }
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(lookup[tmp >> 2] + lookup[(tmp << 4) & 63] + '==')
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(lookup[tmp >> 10] + lookup[(tmp >> 4) & 63] + lookup[(tmp << 2) & 63] + '=')
  }
  return parts.join('')
}
var ieee754 = {}
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function (buffer2, offset, isLE, mLen, nBytes) {
  var e, m2
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? nBytes - 1 : 0
  var d2 = isLE ? -1 : 1
  var s2 = buffer2[offset + i]
  i += d2
  e = s2 & ((1 << -nBits) - 1)
  s2 >>= -nBits
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer2[offset + i], i += d2, nBits -= 8) {}
  m2 = e & ((1 << -nBits) - 1)
  e >>= -nBits
  nBits += mLen
  for (; nBits > 0; m2 = m2 * 256 + buffer2[offset + i], i += d2, nBits -= 8) {}
  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m2 ? NaN : (s2 ? -1 : 1) * Infinity
  } else {
    m2 = m2 + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s2 ? -1 : 1) * m2 * Math.pow(2, e - mLen)
}
ieee754.write = function (buffer2, value, offset, isLE, mLen, nBytes) {
  var e, m2, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0
  var i = isLE ? 0 : nBytes - 1
  var d2 = isLE ? 1 : -1
  var s2 = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0
  value = Math.abs(value)
  if (isNaN(value) || value === Infinity) {
    m2 = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }
    if (e + eBias >= eMax) {
      m2 = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m2 = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m2 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }
  for (; mLen >= 8; buffer2[offset + i] = m2 & 255, i += d2, m2 /= 256, mLen -= 8) {}
  e = (e << mLen) | m2
  eLen += mLen
  for (; eLen > 0; buffer2[offset + i] = e & 255, i += d2, e /= 256, eLen -= 8) {}
  buffer2[offset + i - d2] |= s2 * 128
}
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
;(function (exports) {
  const base64 = base64Js
  const ieee754$1 = ieee754
  const customInspectSymbol =
    typeof Symbol === 'function' && typeof Symbol['for'] === 'function'
      ? Symbol['for']('nodejs.util.inspect.custom')
      : null
  exports.Buffer = Buffer2
  exports.SlowBuffer = SlowBuffer
  exports.INSPECT_MAX_BYTES = 50
  const K_MAX_LENGTH = 2147483647
  exports.kMaxLength = K_MAX_LENGTH
  Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport()
  if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' && typeof console.error === 'function') {
    console.error(
      'This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
    )
  }
  function typedArraySupport() {
    try {
      const arr = new Uint8Array(1)
      const proto2 = {
        foo: function () {
          return 42
        },
      }
      Object.setPrototypeOf(proto2, Uint8Array.prototype)
      Object.setPrototypeOf(arr, proto2)
      return arr.foo() === 42
    } catch (e) {
      return false
    }
  }
  Object.defineProperty(Buffer2.prototype, 'parent', {
    enumerable: true,
    get: function () {
      if (!Buffer2.isBuffer(this)) return void 0
      return this.buffer
    },
  })
  Object.defineProperty(Buffer2.prototype, 'offset', {
    enumerable: true,
    get: function () {
      if (!Buffer2.isBuffer(this)) return void 0
      return this.byteOffset
    },
  })
  function createBuffer(length) {
    if (length > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length + '" is invalid for option "size"')
    }
    const buf = new Uint8Array(length)
    Object.setPrototypeOf(buf, Buffer2.prototype)
    return buf
  }
  function Buffer2(arg, encodingOrOffset, length) {
    if (typeof arg === 'number') {
      if (typeof encodingOrOffset === 'string') {
        throw new TypeError('The "string" argument must be of type string. Received type number')
      }
      return allocUnsafe(arg)
    }
    return from(arg, encodingOrOffset, length)
  }
  Buffer2.poolSize = 8192
  function from(value, encodingOrOffset, length) {
    if (typeof value === 'string') {
      return fromString(value, encodingOrOffset)
    }
    if (ArrayBuffer.isView(value)) {
      return fromArrayView(value)
    }
    if (value == null) {
      throw new TypeError(
        'The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' +
          typeof value
      )
    }
    if (isInstance(value, ArrayBuffer) || (value && isInstance(value.buffer, ArrayBuffer))) {
      return fromArrayBuffer(value, encodingOrOffset, length)
    }
    if (
      typeof SharedArrayBuffer !== 'undefined' &&
      (isInstance(value, SharedArrayBuffer) || (value && isInstance(value.buffer, SharedArrayBuffer)))
    ) {
      return fromArrayBuffer(value, encodingOrOffset, length)
    }
    if (typeof value === 'number') {
      throw new TypeError('The "value" argument must not be of type number. Received type number')
    }
    const valueOf = value.valueOf && value.valueOf()
    if (valueOf != null && valueOf !== value) {
      return Buffer2.from(valueOf, encodingOrOffset, length)
    }
    const b = fromObject(value)
    if (b) return b
    if (
      typeof Symbol !== 'undefined' &&
      Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function'
    ) {
      return Buffer2.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)
    }
    throw new TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' +
        typeof value
    )
  }
  Buffer2.from = function (value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length)
  }
  Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype)
  Object.setPrototypeOf(Buffer2, Uint8Array)
  function assertSize(size) {
    if (typeof size !== 'number') {
      throw new TypeError('"size" argument must be of type number')
    } else if (size < 0) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"')
    }
  }
  function alloc(size, fill, encoding) {
    assertSize(size)
    if (size <= 0) {
      return createBuffer(size)
    }
    if (fill !== void 0) {
      return typeof encoding === 'string' ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill)
    }
    return createBuffer(size)
  }
  Buffer2.alloc = function (size, fill, encoding) {
    return alloc(size, fill, encoding)
  }
  function allocUnsafe(size) {
    assertSize(size)
    return createBuffer(size < 0 ? 0 : checked(size) | 0)
  }
  Buffer2.allocUnsafe = function (size) {
    return allocUnsafe(size)
  }
  Buffer2.allocUnsafeSlow = function (size) {
    return allocUnsafe(size)
  }
  function fromString(string2, encoding) {
    if (typeof encoding !== 'string' || encoding === '') {
      encoding = 'utf8'
    }
    if (!Buffer2.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    const length = byteLength2(string2, encoding) | 0
    let buf = createBuffer(length)
    const actual = buf.write(string2, encoding)
    if (actual !== length) {
      buf = buf.slice(0, actual)
    }
    return buf
  }
  function fromArrayLike(array) {
    const length = array.length < 0 ? 0 : checked(array.length) | 0
    const buf = createBuffer(length)
    for (let i = 0; i < length; i += 1) {
      buf[i] = array[i] & 255
    }
    return buf
  }
  function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
      const copy = new Uint8Array(arrayView)
      return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)
    }
    return fromArrayLike(arrayView)
  }
  function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds')
    }
    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('"length" is outside of buffer bounds')
    }
    let buf
    if (byteOffset === void 0 && length === void 0) {
      buf = new Uint8Array(array)
    } else if (length === void 0) {
      buf = new Uint8Array(array, byteOffset)
    } else {
      buf = new Uint8Array(array, byteOffset, length)
    }
    Object.setPrototypeOf(buf, Buffer2.prototype)
    return buf
  }
  function fromObject(obj) {
    if (Buffer2.isBuffer(obj)) {
      const len = checked(obj.length) | 0
      const buf = createBuffer(len)
      if (buf.length === 0) {
        return buf
      }
      obj.copy(buf, 0, 0, len)
      return buf
    }
    if (obj.length !== void 0) {
      if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
        return createBuffer(0)
      }
      return fromArrayLike(obj)
    }
    if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data)
    }
  }
  function checked(length) {
    if (length >= K_MAX_LENGTH) {
      throw new RangeError(
        'Attempt to allocate Buffer larger than maximum size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes'
      )
    }
    return length | 0
  }
  function SlowBuffer(length) {
    if (+length != length) {
      length = 0
    }
    return Buffer2.alloc(+length)
  }
  Buffer2.isBuffer = function isBuffer2(b) {
    return b != null && b._isBuffer === true && b !== Buffer2.prototype
  }
  Buffer2.compare = function compare(a, b) {
    if (isInstance(a, Uint8Array)) a = Buffer2.from(a, a.offset, a.byteLength)
    if (isInstance(b, Uint8Array)) b = Buffer2.from(b, b.offset, b.byteLength)
    if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
      throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array')
    }
    if (a === b) return 0
    let x = a.length
    let y2 = b.length
    for (let i = 0, len = Math.min(x, y2); i < len; ++i) {
      if (a[i] !== b[i]) {
        x = a[i]
        y2 = b[i]
        break
      }
    }
    if (x < y2) return -1
    if (y2 < x) return 1
    return 0
  }
  Buffer2.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case 'hex':
      case 'utf8':
      case 'utf-8':
      case 'ascii':
      case 'latin1':
      case 'binary':
      case 'base64':
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return true
      default:
        return false
    }
  }
  Buffer2.concat = function concat(list2, length) {
    if (!Array.isArray(list2)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    if (list2.length === 0) {
      return Buffer2.alloc(0)
    }
    let i
    if (length === void 0) {
      length = 0
      for (i = 0; i < list2.length; ++i) {
        length += list2[i].length
      }
    }
    const buffer2 = Buffer2.allocUnsafe(length)
    let pos = 0
    for (i = 0; i < list2.length; ++i) {
      let buf = list2[i]
      if (isInstance(buf, Uint8Array)) {
        if (pos + buf.length > buffer2.length) {
          if (!Buffer2.isBuffer(buf)) buf = Buffer2.from(buf)
          buf.copy(buffer2, pos)
        } else {
          Uint8Array.prototype.set.call(buffer2, buf, pos)
        }
      } else if (!Buffer2.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers')
      } else {
        buf.copy(buffer2, pos)
      }
      pos += buf.length
    }
    return buffer2
  }
  function byteLength2(string2, encoding) {
    if (Buffer2.isBuffer(string2)) {
      return string2.length
    }
    if (ArrayBuffer.isView(string2) || isInstance(string2, ArrayBuffer)) {
      return string2.byteLength
    }
    if (typeof string2 !== 'string') {
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string2
      )
    }
    const len = string2.length
    const mustMatch = arguments.length > 2 && arguments[2] === true
    if (!mustMatch && len === 0) return 0
    let loweredCase = false
    for (;;) {
      switch (encoding) {
        case 'ascii':
        case 'latin1':
        case 'binary':
          return len
        case 'utf8':
        case 'utf-8':
          return utf8ToBytes(string2).length
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return len * 2
        case 'hex':
          return len >>> 1
        case 'base64':
          return base64ToBytes(string2).length
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes(string2).length
          }
          encoding = ('' + encoding).toLowerCase()
          loweredCase = true
      }
    }
  }
  Buffer2.byteLength = byteLength2
  function slowToString(encoding, start, end) {
    let loweredCase = false
    if (start === void 0 || start < 0) {
      start = 0
    }
    if (start > this.length) {
      return ''
    }
    if (end === void 0 || end > this.length) {
      end = this.length
    }
    if (end <= 0) {
      return ''
    }
    end >>>= 0
    start >>>= 0
    if (end <= start) {
      return ''
    }
    if (!encoding) encoding = 'utf8'
    while (true) {
      switch (encoding) {
        case 'hex':
          return hexSlice(this, start, end)
        case 'utf8':
        case 'utf-8':
          return utf8Slice(this, start, end)
        case 'ascii':
          return asciiSlice(this, start, end)
        case 'latin1':
        case 'binary':
          return latin1Slice(this, start, end)
        case 'base64':
          return base64Slice(this, start, end)
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return utf16leSlice(this, start, end)
        default:
          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
          encoding = (encoding + '').toLowerCase()
          loweredCase = true
      }
    }
  }
  Buffer2.prototype._isBuffer = true
  function swap(b, n2, m2) {
    const i = b[n2]
    b[n2] = b[m2]
    b[m2] = i
  }
  Buffer2.prototype.swap16 = function swap16() {
    const len = this.length
    if (len % 2 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 16-bits')
    }
    for (let i = 0; i < len; i += 2) {
      swap(this, i, i + 1)
    }
    return this
  }
  Buffer2.prototype.swap32 = function swap32() {
    const len = this.length
    if (len % 4 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 32-bits')
    }
    for (let i = 0; i < len; i += 4) {
      swap(this, i, i + 3)
      swap(this, i + 1, i + 2)
    }
    return this
  }
  Buffer2.prototype.swap64 = function swap64() {
    const len = this.length
    if (len % 8 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 64-bits')
    }
    for (let i = 0; i < len; i += 8) {
      swap(this, i, i + 7)
      swap(this, i + 1, i + 6)
      swap(this, i + 2, i + 5)
      swap(this, i + 3, i + 4)
    }
    return this
  }
  Buffer2.prototype.toString = function toString2() {
    const length = this.length
    if (length === 0) return ''
    if (arguments.length === 0) return utf8Slice(this, 0, length)
    return slowToString.apply(this, arguments)
  }
  Buffer2.prototype.toLocaleString = Buffer2.prototype.toString
  Buffer2.prototype.equals = function equals2(b) {
    if (!Buffer2.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
    if (this === b) return true
    return Buffer2.compare(this, b) === 0
  }
  Buffer2.prototype.inspect = function inspect() {
    let str = ''
    const max2 = exports.INSPECT_MAX_BYTES
    str = this.toString('hex', 0, max2)
      .replace(/(.{2})/g, '$1 ')
      .trim()
    if (this.length > max2) str += ' ... '
    return '<Buffer ' + str + '>'
  }
  if (customInspectSymbol) {
    Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect
  }
  Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
      target = Buffer2.from(target, target.offset, target.byteLength)
    }
    if (!Buffer2.isBuffer(target)) {
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
      )
    }
    if (start === void 0) {
      start = 0
    }
    if (end === void 0) {
      end = target ? target.length : 0
    }
    if (thisStart === void 0) {
      thisStart = 0
    }
    if (thisEnd === void 0) {
      thisEnd = this.length
    }
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError('out of range index')
    }
    if (thisStart >= thisEnd && start >= end) {
      return 0
    }
    if (thisStart >= thisEnd) {
      return -1
    }
    if (start >= end) {
      return 1
    }
    start >>>= 0
    end >>>= 0
    thisStart >>>= 0
    thisEnd >>>= 0
    if (this === target) return 0
    let x = thisEnd - thisStart
    let y2 = end - start
    const len = Math.min(x, y2)
    const thisCopy = this.slice(thisStart, thisEnd)
    const targetCopy = target.slice(start, end)
    for (let i = 0; i < len; ++i) {
      if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i]
        y2 = targetCopy[i]
        break
      }
    }
    if (x < y2) return -1
    if (y2 < x) return 1
    return 0
  }
  function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
    if (buffer2.length === 0) return -1
    if (typeof byteOffset === 'string') {
      encoding = byteOffset
      byteOffset = 0
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648
    }
    byteOffset = +byteOffset
    if (numberIsNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer2.length - 1
    }
    if (byteOffset < 0) byteOffset = buffer2.length + byteOffset
    if (byteOffset >= buffer2.length) {
      if (dir) return -1
      else byteOffset = buffer2.length - 1
    } else if (byteOffset < 0) {
      if (dir) byteOffset = 0
      else return -1
    }
    if (typeof val === 'string') {
      val = Buffer2.from(val, encoding)
    }
    if (Buffer2.isBuffer(val)) {
      if (val.length === 0) {
        return -1
      }
      return arrayIndexOf(buffer2, val, byteOffset, encoding, dir)
    } else if (typeof val === 'number') {
      val = val & 255
      if (typeof Uint8Array.prototype.indexOf === 'function') {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset)
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset)
        }
      }
      return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir)
    }
    throw new TypeError('val must be string, number or Buffer')
  }
  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    let indexSize = 1
    let arrLength = arr.length
    let valLength = val.length
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase()
      if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
        if (arr.length < 2 || val.length < 2) {
          return -1
        }
        indexSize = 2
        arrLength /= 2
        valLength /= 2
        byteOffset /= 2
      }
    }
    function read(buf, i2) {
      if (indexSize === 1) {
        return buf[i2]
      } else {
        return buf.readUInt16BE(i2 * indexSize)
      }
    }
    let i
    if (dir) {
      let foundIndex = -1
      for (i = byteOffset; i < arrLength; i++) {
        if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
          if (foundIndex === -1) foundIndex = i
          if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
        } else {
          if (foundIndex !== -1) i -= i - foundIndex
          foundIndex = -1
        }
      }
    } else {
      if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
      for (i = byteOffset; i >= 0; i--) {
        let found = true
        for (let j = 0; j < valLength; j++) {
          if (read(arr, i + j) !== read(val, j)) {
            found = false
            break
          }
        }
        if (found) return i
      }
    }
    return -1
  }
  Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1
  }
  Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
  }
  Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
  }
  function hexWrite(buf, string2, offset, length) {
    offset = Number(offset) || 0
    const remaining = buf.length - offset
    if (!length) {
      length = remaining
    } else {
      length = Number(length)
      if (length > remaining) {
        length = remaining
      }
    }
    const strLen = string2.length
    if (length > strLen / 2) {
      length = strLen / 2
    }
    let i
    for (i = 0; i < length; ++i) {
      const parsed = parseInt(string2.substr(i * 2, 2), 16)
      if (numberIsNaN(parsed)) return i
      buf[offset + i] = parsed
    }
    return i
  }
  function utf8Write(buf, string2, offset, length) {
    return blitBuffer(utf8ToBytes(string2, buf.length - offset), buf, offset, length)
  }
  function asciiWrite(buf, string2, offset, length) {
    return blitBuffer(asciiToBytes(string2), buf, offset, length)
  }
  function base64Write(buf, string2, offset, length) {
    return blitBuffer(base64ToBytes(string2), buf, offset, length)
  }
  function ucs2Write(buf, string2, offset, length) {
    return blitBuffer(utf16leToBytes(string2, buf.length - offset), buf, offset, length)
  }
  Buffer2.prototype.write = function write(string2, offset, length, encoding) {
    if (offset === void 0) {
      encoding = 'utf8'
      length = this.length
      offset = 0
    } else if (length === void 0 && typeof offset === 'string') {
      encoding = offset
      length = this.length
      offset = 0
    } else if (isFinite(offset)) {
      offset = offset >>> 0
      if (isFinite(length)) {
        length = length >>> 0
        if (encoding === void 0) encoding = 'utf8'
      } else {
        encoding = length
        length = void 0
      }
    } else {
      throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported')
    }
    const remaining = this.length - offset
    if (length === void 0 || length > remaining) length = remaining
    if ((string2.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
      throw new RangeError('Attempt to write outside buffer bounds')
    }
    if (!encoding) encoding = 'utf8'
    let loweredCase = false
    for (;;) {
      switch (encoding) {
        case 'hex':
          return hexWrite(this, string2, offset, length)
        case 'utf8':
        case 'utf-8':
          return utf8Write(this, string2, offset, length)
        case 'ascii':
        case 'latin1':
        case 'binary':
          return asciiWrite(this, string2, offset, length)
        case 'base64':
          return base64Write(this, string2, offset, length)
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return ucs2Write(this, string2, offset, length)
        default:
          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
          encoding = ('' + encoding).toLowerCase()
          loweredCase = true
      }
    }
  }
  Buffer2.prototype.toJSON = function toJSON() {
    return {
      type: 'Buffer',
      data: Array.prototype.slice.call(this._arr || this, 0),
    }
  }
  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base64.fromByteArray(buf)
    } else {
      return base64.fromByteArray(buf.slice(start, end))
    }
  }
  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end)
    const res = []
    let i = start
    while (i < end) {
      const firstByte = buf[i]
      let codePoint = null
      let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1
      if (i + bytesPerSequence <= end) {
        let secondByte, thirdByte, fourthByte, tempCodePoint
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte
            }
            break
          case 2:
            secondByte = buf[i + 1]
            if ((secondByte & 192) === 128) {
              tempCodePoint = ((firstByte & 31) << 6) | (secondByte & 63)
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint
              }
            }
            break
          case 3:
            secondByte = buf[i + 1]
            thirdByte = buf[i + 2]
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = ((firstByte & 15) << 12) | ((secondByte & 63) << 6) | (thirdByte & 63)
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint
              }
            }
            break
          case 4:
            secondByte = buf[i + 1]
            thirdByte = buf[i + 2]
            fourthByte = buf[i + 3]
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint =
                ((firstByte & 15) << 18) | ((secondByte & 63) << 12) | ((thirdByte & 63) << 6) | (fourthByte & 63)
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533
        bytesPerSequence = 1
      } else if (codePoint > 65535) {
        codePoint -= 65536
        res.push(((codePoint >>> 10) & 1023) | 55296)
        codePoint = 56320 | (codePoint & 1023)
      }
      res.push(codePoint)
      i += bytesPerSequence
    }
    return decodeCodePointsArray(res)
  }
  const MAX_ARGUMENTS_LENGTH = 4096
  function decodeCodePointsArray(codePoints) {
    const len = codePoints.length
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints)
    }
    let res = ''
    let i = 0
    while (i < len) {
      res += String.fromCharCode.apply(String, codePoints.slice(i, (i += MAX_ARGUMENTS_LENGTH)))
    }
    return res
  }
  function asciiSlice(buf, start, end) {
    let ret = ''
    end = Math.min(buf.length, end)
    for (let i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i] & 127)
    }
    return ret
  }
  function latin1Slice(buf, start, end) {
    let ret = ''
    end = Math.min(buf.length, end)
    for (let i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i])
    }
    return ret
  }
  function hexSlice(buf, start, end) {
    const len = buf.length
    if (!start || start < 0) start = 0
    if (!end || end < 0 || end > len) end = len
    let out = ''
    for (let i = start; i < end; ++i) {
      out += hexSliceLookupTable[buf[i]]
    }
    return out
  }
  function utf16leSlice(buf, start, end) {
    const bytes = buf.slice(start, end)
    let res = ''
    for (let i = 0; i < bytes.length - 1; i += 2) {
      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
    }
    return res
  }
  Buffer2.prototype.slice = function slice(start, end) {
    const len = this.length
    start = ~~start
    end = end === void 0 ? len : ~~end
    if (start < 0) {
      start += len
      if (start < 0) start = 0
    } else if (start > len) {
      start = len
    }
    if (end < 0) {
      end += len
      if (end < 0) end = 0
    } else if (end > len) {
      end = len
    }
    if (end < start) end = start
    const newBuf = this.subarray(start, end)
    Object.setPrototypeOf(newBuf, Buffer2.prototype)
    return newBuf
  }
  function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint')
    if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
  }
  Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0
    byteLength3 = byteLength3 >>> 0
    if (!noAssert) checkOffset(offset, byteLength3, this.length)
    let val = this[offset]
    let mul2 = 1
    let i = 0
    while (++i < byteLength3 && (mul2 *= 256)) {
      val += this[offset + i] * mul2
    }
    return val
  }
  Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0
    byteLength3 = byteLength3 >>> 0
    if (!noAssert) {
      checkOffset(offset, byteLength3, this.length)
    }
    let val = this[offset + --byteLength3]
    let mul2 = 1
    while (byteLength3 > 0 && (mul2 *= 256)) {
      val += this[offset + --byteLength3] * mul2
    }
    return val
  }
  Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0
    if (!noAssert) checkOffset(offset, 1, this.length)
    return this[offset]
  }
  Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0
    if (!noAssert) checkOffset(offset, 2, this.length)
    return this[offset] | (this[offset + 1] << 8)
  }
  Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0
    if (!noAssert) checkOffset(offset, 2, this.length)
    return (this[offset] << 8) | this[offset + 1]
  }
  Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0
    if (!noAssert) checkOffset(offset, 4, this.length)
    return (this[offset] | (this[offset + 1] << 8) | (this[offset + 2] << 16)) + this[offset + 3] * 16777216
  }
  Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0
    if (!noAssert) checkOffset(offset, 4, this.length)
    return this[offset] * 16777216 + ((this[offset + 1] << 16) | (this[offset + 2] << 8) | this[offset + 3])
  }
  Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0
    validateNumber(offset, 'offset')
    const first = this[offset]
    const last2 = this[offset + 7]
    if (first === void 0 || last2 === void 0) {
      boundsError(offset, this.length - 8)
    }
    const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24
    const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last2 * 2 ** 24
    return BigInt(lo) + (BigInt(hi) << BigInt(32))
  })
  Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0
    validateNumber(offset, 'offset')
    const first = this[offset]
    const last2 = this[offset + 7]
    if (first === void 0 || last2 === void 0) {
      boundsError(offset, this.length - 8)
    }
    const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset]
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last2
    return (BigInt(hi) << BigInt(32)) + BigInt(lo)
  })
  Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0
    byteLength3 = byteLength3 >>> 0
    if (!noAssert) checkOffset(offset, byteLength3, this.length)
    let val = this[offset]
    let mul2 = 1
    let i = 0
    while (++i < byteLength3 && (mul2 *= 256)) {
      val += this[offset + i] * mul2
    }
    mul2 *= 128
    if (val >= mul2) val -= Math.pow(2, 8 * byteLength3)
    return val
  }
  Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0
    byteLength3 = byteLength3 >>> 0
    if (!noAssert) checkOffset(offset, byteLength3, this.length)
    let i = byteLength3
    let mul2 = 1
    let val = this[offset + --i]
    while (i > 0 && (mul2 *= 256)) {
      val += this[offset + --i] * mul2
    }
    mul2 *= 128
    if (val >= mul2) val -= Math.pow(2, 8 * byteLength3)
    return val
  }
  Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0
    if (!noAssert) checkOffset(offset, 1, this.length)
    if (!(this[offset] & 128)) return this[offset]
    return (255 - this[offset] + 1) * -1
  }
  Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0
    if (!noAssert) checkOffset(offset, 2, this.length)
    const val = this[offset] | (this[offset + 1] << 8)
    return val & 32768 ? val | 4294901760 : val
  }
  Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0
    if (!noAssert) checkOffset(offset, 2, this.length)
    const val = this[offset + 1] | (this[offset] << 8)
    return val & 32768 ? val | 4294901760 : val
  }
  Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0
    if (!noAssert) checkOffset(offset, 4, this.length)
    return this[offset] | (this[offset + 1] << 8) | (this[offset + 2] << 16) | (this[offset + 3] << 24)
  }
  Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0
    if (!noAssert) checkOffset(offset, 4, this.length)
    return (this[offset] << 24) | (this[offset + 1] << 16) | (this[offset + 2] << 8) | this[offset + 3]
  }
  Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0
    validateNumber(offset, 'offset')
    const first = this[offset]
    const last2 = this[offset + 7]
    if (first === void 0 || last2 === void 0) {
      boundsError(offset, this.length - 8)
    }
    const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last2 << 24)
    return (
      (BigInt(val) << BigInt(32)) +
      BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24)
    )
  })
  Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0
    validateNumber(offset, 'offset')
    const first = this[offset]
    const last2 = this[offset + 7]
    if (first === void 0 || last2 === void 0) {
      boundsError(offset, this.length - 8)
    }
    const val = (first << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset]
    return (
      (BigInt(val) << BigInt(32)) +
      BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last2)
    )
  })
  Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0
    if (!noAssert) checkOffset(offset, 4, this.length)
    return ieee754$1.read(this, offset, true, 23, 4)
  }
  Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0
    if (!noAssert) checkOffset(offset, 4, this.length)
    return ieee754$1.read(this, offset, false, 23, 4)
  }
  Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0
    if (!noAssert) checkOffset(offset, 8, this.length)
    return ieee754$1.read(this, offset, true, 52, 8)
  }
  Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0
    if (!noAssert) checkOffset(offset, 8, this.length)
    return ieee754$1.read(this, offset, false, 52, 8)
  }
  function checkInt(buf, value, offset, ext, max2, min2) {
    if (!Buffer2.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
    if (value > max2 || value < min2) throw new RangeError('"value" argument is out of bounds')
    if (offset + ext > buf.length) throw new RangeError('Index out of range')
  }
  Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(
    value,
    offset,
    byteLength3,
    noAssert
  ) {
    value = +value
    offset = offset >>> 0
    byteLength3 = byteLength3 >>> 0
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1
      checkInt(this, value, offset, byteLength3, maxBytes, 0)
    }
    let mul2 = 1
    let i = 0
    this[offset] = value & 255
    while (++i < byteLength3 && (mul2 *= 256)) {
      this[offset + i] = (value / mul2) & 255
    }
    return offset + byteLength3
  }
  Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(
    value,
    offset,
    byteLength3,
    noAssert
  ) {
    value = +value
    offset = offset >>> 0
    byteLength3 = byteLength3 >>> 0
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1
      checkInt(this, value, offset, byteLength3, maxBytes, 0)
    }
    let i = byteLength3 - 1
    let mul2 = 1
    this[offset + i] = value & 255
    while (--i >= 0 && (mul2 *= 256)) {
      this[offset + i] = (value / mul2) & 255
    }
    return offset + byteLength3
  }
  Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value
    offset = offset >>> 0
    if (!noAssert) checkInt(this, value, offset, 1, 255, 0)
    this[offset] = value & 255
    return offset + 1
  }
  Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value
    offset = offset >>> 0
    if (!noAssert) checkInt(this, value, offset, 2, 65535, 0)
    this[offset] = value & 255
    this[offset + 1] = value >>> 8
    return offset + 2
  }
  Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value
    offset = offset >>> 0
    if (!noAssert) checkInt(this, value, offset, 2, 65535, 0)
    this[offset] = value >>> 8
    this[offset + 1] = value & 255
    return offset + 2
  }
  Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value
    offset = offset >>> 0
    if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0)
    this[offset + 3] = value >>> 24
    this[offset + 2] = value >>> 16
    this[offset + 1] = value >>> 8
    this[offset] = value & 255
    return offset + 4
  }
  Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value
    offset = offset >>> 0
    if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0)
    this[offset] = value >>> 24
    this[offset + 1] = value >>> 16
    this[offset + 2] = value >>> 8
    this[offset + 3] = value & 255
    return offset + 4
  }
  function wrtBigUInt64LE(buf, value, offset, min2, max2) {
    checkIntBI(value, min2, max2, buf, offset, 7)
    let lo = Number(value & BigInt(4294967295))
    buf[offset++] = lo
    lo = lo >> 8
    buf[offset++] = lo
    lo = lo >> 8
    buf[offset++] = lo
    lo = lo >> 8
    buf[offset++] = lo
    let hi = Number((value >> BigInt(32)) & BigInt(4294967295))
    buf[offset++] = hi
    hi = hi >> 8
    buf[offset++] = hi
    hi = hi >> 8
    buf[offset++] = hi
    hi = hi >> 8
    buf[offset++] = hi
    return offset
  }
  function wrtBigUInt64BE(buf, value, offset, min2, max2) {
    checkIntBI(value, min2, max2, buf, offset, 7)
    let lo = Number(value & BigInt(4294967295))
    buf[offset + 7] = lo
    lo = lo >> 8
    buf[offset + 6] = lo
    lo = lo >> 8
    buf[offset + 5] = lo
    lo = lo >> 8
    buf[offset + 4] = lo
    let hi = Number((value >> BigInt(32)) & BigInt(4294967295))
    buf[offset + 3] = hi
    hi = hi >> 8
    buf[offset + 2] = hi
    hi = hi >> 8
    buf[offset + 1] = hi
    hi = hi >> 8
    buf[offset] = hi
    return offset + 8
  }
  Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
  })
  Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
  })
  Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength3, noAssert) {
    value = +value
    offset = offset >>> 0
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1)
      checkInt(this, value, offset, byteLength3, limit - 1, -limit)
    }
    let i = 0
    let mul2 = 1
    let sub2 = 0
    this[offset] = value & 255
    while (++i < byteLength3 && (mul2 *= 256)) {
      if (value < 0 && sub2 === 0 && this[offset + i - 1] !== 0) {
        sub2 = 1
      }
      this[offset + i] = (((value / mul2) >> 0) - sub2) & 255
    }
    return offset + byteLength3
  }
  Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength3, noAssert) {
    value = +value
    offset = offset >>> 0
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1)
      checkInt(this, value, offset, byteLength3, limit - 1, -limit)
    }
    let i = byteLength3 - 1
    let mul2 = 1
    let sub2 = 0
    this[offset + i] = value & 255
    while (--i >= 0 && (mul2 *= 256)) {
      if (value < 0 && sub2 === 0 && this[offset + i + 1] !== 0) {
        sub2 = 1
      }
      this[offset + i] = (((value / mul2) >> 0) - sub2) & 255
    }
    return offset + byteLength3
  }
  Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value
    offset = offset >>> 0
    if (!noAssert) checkInt(this, value, offset, 1, 127, -128)
    if (value < 0) value = 255 + value + 1
    this[offset] = value & 255
    return offset + 1
  }
  Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value
    offset = offset >>> 0
    if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768)
    this[offset] = value & 255
    this[offset + 1] = value >>> 8
    return offset + 2
  }
  Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value
    offset = offset >>> 0
    if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768)
    this[offset] = value >>> 8
    this[offset + 1] = value & 255
    return offset + 2
  }
  Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value
    offset = offset >>> 0
    if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648)
    this[offset] = value & 255
    this[offset + 1] = value >>> 8
    this[offset + 2] = value >>> 16
    this[offset + 3] = value >>> 24
    return offset + 4
  }
  Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value
    offset = offset >>> 0
    if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648)
    if (value < 0) value = 4294967295 + value + 1
    this[offset] = value >>> 24
    this[offset + 1] = value >>> 16
    this[offset + 2] = value >>> 8
    this[offset + 3] = value & 255
    return offset + 4
  }
  Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
  })
  Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
  })
  function checkIEEE754(buf, value, offset, ext, max2, min2) {
    if (offset + ext > buf.length) throw new RangeError('Index out of range')
    if (offset < 0) throw new RangeError('Index out of range')
  }
  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value
    offset = offset >>> 0
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4)
    }
    ieee754$1.write(buf, value, offset, littleEndian, 23, 4)
    return offset + 4
  }
  Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert)
  }
  Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert)
  }
  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value
    offset = offset >>> 0
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8)
    }
    ieee754$1.write(buf, value, offset, littleEndian, 52, 8)
    return offset + 8
  }
  Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert)
  }
  Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert)
  }
  Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
    if (!Buffer2.isBuffer(target)) throw new TypeError('argument should be a Buffer')
    if (!start) start = 0
    if (!end && end !== 0) end = this.length
    if (targetStart >= target.length) targetStart = target.length
    if (!targetStart) targetStart = 0
    if (end > 0 && end < start) end = start
    if (end === start) return 0
    if (target.length === 0 || this.length === 0) return 0
    if (targetStart < 0) {
      throw new RangeError('targetStart out of bounds')
    }
    if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
    if (end < 0) throw new RangeError('sourceEnd out of bounds')
    if (end > this.length) end = this.length
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start
    }
    const len = end - start
    if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
      this.copyWithin(targetStart, start, end)
    } else {
      Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart)
    }
    return len
  }
  Buffer2.prototype.fill = function fill(val, start, end, encoding) {
    if (typeof val === 'string') {
      if (typeof start === 'string') {
        encoding = start
        start = 0
        end = this.length
      } else if (typeof end === 'string') {
        encoding = end
        end = this.length
      }
      if (encoding !== void 0 && typeof encoding !== 'string') {
        throw new TypeError('encoding must be a string')
      }
      if (typeof encoding === 'string' && !Buffer2.isEncoding(encoding)) {
        throw new TypeError('Unknown encoding: ' + encoding)
      }
      if (val.length === 1) {
        const code2 = val.charCodeAt(0)
        if ((encoding === 'utf8' && code2 < 128) || encoding === 'latin1') {
          val = code2
        }
      }
    } else if (typeof val === 'number') {
      val = val & 255
    } else if (typeof val === 'boolean') {
      val = Number(val)
    }
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError('Out of range index')
    }
    if (end <= start) {
      return this
    }
    start = start >>> 0
    end = end === void 0 ? this.length : end >>> 0
    if (!val) val = 0
    let i
    if (typeof val === 'number') {
      for (i = start; i < end; ++i) {
        this[i] = val
      }
    } else {
      const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding)
      const len = bytes.length
      if (len === 0) {
        throw new TypeError('The value "' + val + '" is invalid for argument "value"')
      }
      for (i = 0; i < end - start; ++i) {
        this[i + start] = bytes[i % len]
      }
    }
    return this
  }
  const errors = {}
  function E(sym, getMessage, Base) {
    errors[sym] = class NodeError extends Base {
      constructor() {
        super()
        Object.defineProperty(this, 'message', {
          value: getMessage.apply(this, arguments),
          writable: true,
          configurable: true,
        })
        this.name = `${this.name} [${sym}]`
        this.stack
        delete this.name
      }
      get code() {
        return sym
      }
      set code(value) {
        Object.defineProperty(this, 'code', {
          configurable: true,
          enumerable: true,
          value,
          writable: true,
        })
      }
      toString() {
        return `${this.name} [${sym}]: ${this.message}`
      }
    }
  }
  E(
    'ERR_BUFFER_OUT_OF_BOUNDS',
    function (name) {
      if (name) {
        return `${name} is outside of buffer bounds`
      }
      return 'Attempt to access memory outside buffer bounds'
    },
    RangeError
  )
  E(
    'ERR_INVALID_ARG_TYPE',
    function (name, actual) {
      return `The "${name}" argument must be of type number. Received type ${typeof actual}`
    },
    TypeError
  )
  E(
    'ERR_OUT_OF_RANGE',
    function (str, range, input) {
      let msg = `The value of "${str}" is out of range.`
      let received = input
      if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
        received = addNumericalSeparator(String(input))
      } else if (typeof input === 'bigint') {
        received = String(input)
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
          received = addNumericalSeparator(received)
        }
        received += 'n'
      }
      msg += ` It must be ${range}. Received ${received}`
      return msg
    },
    RangeError
  )
  function addNumericalSeparator(val) {
    let res = ''
    let i = val.length
    const start = val[0] === '-' ? 1 : 0
    for (; i >= start + 4; i -= 3) {
      res = `_${val.slice(i - 3, i)}${res}`
    }
    return `${val.slice(0, i)}${res}`
  }
  function checkBounds(buf, offset, byteLength3) {
    validateNumber(offset, 'offset')
    if (buf[offset] === void 0 || buf[offset + byteLength3] === void 0) {
      boundsError(offset, buf.length - (byteLength3 + 1))
    }
  }
  function checkIntBI(value, min2, max2, buf, offset, byteLength3) {
    if (value > max2 || value < min2) {
      const n2 = typeof min2 === 'bigint' ? 'n' : ''
      let range
      if (byteLength3 > 3) {
        if (min2 === 0 || min2 === BigInt(0)) {
          range = `>= 0${n2} and < 2${n2} ** ${(byteLength3 + 1) * 8}${n2}`
        } else {
          range = `>= -(2${n2} ** ${(byteLength3 + 1) * 8 - 1}${n2}) and < 2 ** ${(byteLength3 + 1) * 8 - 1}${n2}`
        }
      } else {
        range = `>= ${min2}${n2} and <= ${max2}${n2}`
      }
      throw new errors.ERR_OUT_OF_RANGE('value', range, value)
    }
    checkBounds(buf, offset, byteLength3)
  }
  function validateNumber(value, name) {
    if (typeof value !== 'number') {
      throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)
    }
  }
  function boundsError(value, length, type) {
    if (Math.floor(value) !== value) {
      validateNumber(value, type)
      throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)
    }
    if (length < 0) {
      throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()
    }
    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', `>= ${type ? 1 : 0} and <= ${length}`, value)
  }
  const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g
  function base64clean(str) {
    str = str.split('=')[0]
    str = str.trim().replace(INVALID_BASE64_RE, '')
    if (str.length < 2) return ''
    while (str.length % 4 !== 0) {
      str = str + '='
    }
    return str
  }
  function utf8ToBytes(string2, units) {
    units = units || Infinity
    let codePoint
    const length = string2.length
    let leadSurrogate = null
    const bytes = []
    for (let i = 0; i < length; ++i) {
      codePoint = string2.charCodeAt(i)
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189)
            continue
          } else if (i + 1 === length) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189)
            continue
          }
          leadSurrogate = codePoint
          continue
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189)
          leadSurrogate = codePoint
          continue
        }
        codePoint = (((leadSurrogate - 55296) << 10) | (codePoint - 56320)) + 65536
      } else if (leadSurrogate) {
        if ((units -= 3) > -1) bytes.push(239, 191, 189)
      }
      leadSurrogate = null
      if (codePoint < 128) {
        if ((units -= 1) < 0) break
        bytes.push(codePoint)
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0) break
        bytes.push((codePoint >> 6) | 192, (codePoint & 63) | 128)
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0) break
        bytes.push((codePoint >> 12) | 224, ((codePoint >> 6) & 63) | 128, (codePoint & 63) | 128)
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0) break
        bytes.push(
          (codePoint >> 18) | 240,
          ((codePoint >> 12) & 63) | 128,
          ((codePoint >> 6) & 63) | 128,
          (codePoint & 63) | 128
        )
      } else {
        throw new Error('Invalid code point')
      }
    }
    return bytes
  }
  function asciiToBytes(str) {
    const byteArray = []
    for (let i = 0; i < str.length; ++i) {
      byteArray.push(str.charCodeAt(i) & 255)
    }
    return byteArray
  }
  function utf16leToBytes(str, units) {
    let c, hi, lo
    const byteArray = []
    for (let i = 0; i < str.length; ++i) {
      if ((units -= 2) < 0) break
      c = str.charCodeAt(i)
      hi = c >> 8
      lo = c % 256
      byteArray.push(lo)
      byteArray.push(hi)
    }
    return byteArray
  }
  function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str))
  }
  function blitBuffer(src, dst, offset, length) {
    let i
    for (i = 0; i < length; ++i) {
      if (i + offset >= dst.length || i >= src.length) break
      dst[i + offset] = src[i]
    }
    return i
  }
  function isInstance(obj, type) {
    return (
      obj instanceof type ||
      (obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name)
    )
  }
  function numberIsNaN(obj) {
    return obj !== obj
  }
  const hexSliceLookupTable = (function () {
    const alphabet = '0123456789abcdef'
    const table = new Array(256)
    for (let i = 0; i < 16; ++i) {
      const i16 = i * 16
      for (let j = 0; j < 16; ++j) {
        table[i16 + j] = alphabet[i] + alphabet[j]
      }
    }
    return table
  })()
  function defineBigIntMethod(fn) {
    return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn
  }
  function BufferBigIntNotDefined() {
    throw new Error('BigInt not supported')
  }
})(buffer)
window.Buffer = buffer.Buffer
export { _sfc_main as default }
